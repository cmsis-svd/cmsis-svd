<?xml version="1.0" encoding="utf-8"?>
<!-- File naming: <part/series name>.svd -->
<!--
  Copyright (C) 2012-2014 ARM Limited. All rights reserved.

  Purpose: System Viewer Description (SVD) Example (Schema Version 1.1)
           This is a description of a none-existent and incomplete device
		   for demonstration purposes only.
		   
  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are met:
   - Redistributions of source code must retain the above copyright
     notice, this list of conditions and the following disclaimer.
   - Redistributions in binary form must reproduce the above copyright
     notice, this list of conditions and the following disclaimer in the
     documentation and/or other materials provided with the distribution.
   - Neither the name of ARM nor the names of its contributors may be used 
     to endorse or promote products derived from this software without 
     specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  POSSIBILITY OF SUCH DAMAGE.
 -->
<device schemaVersion="1.1" xmlns:xs="http://www.w3.org/2001/XMLSchema-instance" xs:noNamespaceSchemaLocation="CMSIS-SVD.xsd">
  <vendor>ABOV Semiconductor Co., Ltd.</vendor>
  <!-- device vendor name -->
  <vendorID>ABOV</vendorID>
  <!-- device vendor short name -->
  <name>A31G314</name>
  <!-- name of part-->
  <series>A31G314</series>
  <!-- device series the device belongs to -->
  <version>1.0</version>
  <!-- version of this description, adding CMSIS-SVD 1.1 tags -->
  <description>ARM 32-bit Cortex-M0+ Microcontroller based device, CPU clock up to 48MHz, etc. </description>
  <licenseText>
    <!-- this license text will appear in header file. \n force line breaks -->
    ARM Limited (ARM) is supplying this software for use with Cortex-M\n
    processor based microcontroller, but can be equally used for other\n
    suitable  processor architectures. This file can be freely distributed.\n
    Modifications to this file shall be clearly marked.\n
    \n
    THIS SOFTWARE IS PROVIDED "AS IS".  NO WARRANTIES, WHETHER EXPRESS, IMPLIED\n
    OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF\n
    MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.\n
    ARM SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR\n
    CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
  </licenseText>
  <cpu>
    <!-- details about the cpu embedded in the device -->
    <name>CM0PLUS</name>
    <revision>r0p1</revision>
    <endian>little</endian>
    <mpuPresent>false</mpuPresent>
    <fpuPresent>false</fpuPresent>
    <vtorPresent>true</vtorPresent>
    <nvicPrioBits>2</nvicPrioBits>
    <vendorSystickConfig>false</vendorSystickConfig>
  </cpu>
  <addressUnitBits>8</addressUnitBits>
  <!-- byte addressable memory -->
  <width>32</width>
  <!-- bus width is 32 bits -->
  <!-- default settings implicitly inherited by subsequent sections -->
  <size>32</size>
  <!-- this is the default size (number of bits) of all peripherals
                                                                       and register that do not define "size" themselves -->
  <access>read-write</access>
  <!-- default access permission for all subsequent registers -->
  <resetValue>0x00000000</resetValue>
  <!-- by default all bits of the registers are initialized to 0 on reset -->
  <resetMask>0xFFFFFFFF</resetMask>
  <!-- by default all 32Bits of the registers are used -->
  <peripherals>
    <!--SCU-->
    <peripheral>
      <name>SCU</name>
      <version>1.0</version>
      <description>System Control Unit</description>
      <groupName>SCU</groupName>
      <baseAddress>0x40000000</baseAddress>
      <size>32</size>
      <access>read-write</access>
      <addressBlock>
        <offset>0</offset>
        <size>0x100</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <!--SMR : System Mode Register-->
        <register>
          <name>SMR</name>
          <description>System Mode Register</description>
          <addressOffset>0x04</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>ROSCAON</name>
              <description>ROSC Always on select bit in power down mode
0: ROSC is automatically off entering power down mode
1: ROSC isn't automatically off entering power down mode</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>BGRAON</name>
              <description>BGR Always on select bit in power down mode
0: BGR is automatically off entering power down mode
1: BGR isn't automatically off entering power down mode</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>VDCAON</name>
              <description>VDC Always on select bit in power down mode</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PREVMODE</name>
              <description>Previous operating mode before current reset event</description>
              <bitOffset>4</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <!--SCR : System Control Register-->
        <register>
          <name>SCR</name>
          <description>System Control Register</description>
          <addressOffset>0x08</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>WTIDKY</name>
              <description>On writes, write 0x9EB3 to these bits, otherwise the write is ignored.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>SWRST</name>
              <description>Internal soft reset activation bit (check RSER[4] for reset)</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <!--WUER : Wake up source enable register-->
        <register>
          <name>WUER</name>
          <description>Wake up source enable register</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>GPIOFWUE</name>
              <description>Enable wakeup source of GPIOF port pin change event</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIOEWUE</name>
              <description>Enable wakeup source of GPIOE port pin change event</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIODWUE</name>
              <description>Enable wakeup source of GPIOD port pin change event</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIOCWUE</name>
              <description>Enable wakeup source of GPIOC port pin change event</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIOBWUE</name>
              <description>Enable wakeup source of GPIOB port pin change event</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIOAWUE</name>
              <description>Enable wakeup source of GPIOA port pin change event</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>WTWUE</name>
              <description>Enable wakeup source of watch timer event</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>WDTWUE</name>
              <description>Enable wakeup source of watchdog timer event</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>LVDWUE</name>
              <description>Enable wakeup source of LVD event</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <!--WUSR : Wake up source status register-->
        <register>
          <name>WUSR</name>
          <description>Wake up source status register</description>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>GPIOFWU</name>
              <description>Status of wakeup source of GPIOF port pin change event</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>GPIOEWU</name>
              <description>Status of wakeup source of GPIOE port pin change event</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>GPIODWU</name>
              <description>Status of wakeup source of GPIOD port pin change event</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>GPIOCWU</name>
              <description>Status of wakeup source of GPIOC port pin change event</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>GPIOBWU</name>
              <description>Status of wakeup source of GPIOB port pin change event</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>GPIOAWU</name>
              <description>Status of wakeup source of GPIOA port pin change event</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>WTWU</name>
              <description>Status of wakeup source of watch timer event</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>WDTWU</name>
              <description>Status of wakeup source of watchdog timer event</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>LVDWU</name>
              <description>Status of wakeup source of LVD event</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <!--RSER : Reset source enable register-->
        <register>
          <name>RSER</name>
          <description>Reset source enable register</description>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000049</resetValue>
          <fields>
            <field>
              <name>PINRST</name>
              <description>External pin reset enable bit</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CPURST</name>
              <description>CPU request reset enable bit</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SWRST</name>
              <description>Software reset enable bit</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>WDTRST</name>
              <description>Watchdog Timer reset enable bit</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MCKFRST</name>
              <description>MCLK Clock fail reset enable bit</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MOFRST</name>
              <description>MOSC Clock fail reset enable bit</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>LVDRST</name>
              <description>LVD reset enable bit</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <!--RSSR : Reset source status register-->
        <register>
          <name>RSSR</name>
          <description>Reset source status register</description>
          <addressOffset>0x1C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000049</resetValue>
          <fields>
            <field>
              <name>PORST</name>
              <description>Power on reset status bit</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PINRST</name>
              <description>External pin reset status bit</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CPURST</name>
              <description>CPU request reset status bit</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SWRST</name>
              <description>Software reset status bit</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>WDTRST</name>
              <description>Watchdog Timer reset status bit</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MCKFRST</name>
              <description>MCLK Clock fail reset status bit</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MOFRST</name>
              <description>MOSC Clock fail reset status bit</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>LVDRST</name>
              <description>LVD reset status bit</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <!--PRER1 : Peripheral reset enable register 1-->
        <register>
          <name>PRER1</name>
          <description>Peripheral reset enable register 1</description>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <fields>
            <field>
              <name>WT</name>
              <description>WT reset mask</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TIMER21</name>
              <description>TIMER21 reset mask</description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TIMER20</name>
              <description>TIMER20 reset mask</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TIMER30</name>
              <description>TIMER30 reset mask</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TIMER16</name>
              <description>TIMER16 reset mask</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TIMER15</name>
              <description>TIMER15 reset mask</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TIMER14</name>
              <description>TIMER14 reset mask</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TIMER13</name>
              <description>TIMER13 reset mask</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TIMER12</name>
              <description>TIMER12 reset mask</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TIMER11</name>
              <description>TIMER11 reset mask</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TIMER10</name>
              <description>TIMER10 reset mask</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIOF</name>
              <description>GPIOF reset mask</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIOE</name>
              <description>GPIOE reset mask</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIOD</name>
              <description>GPIOD reset mask</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIOC</name>
              <description>GPIOC reset mask</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIOB</name>
              <description>GPIOB reset mask</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIOA</name>
              <description>GPIOA reset mask</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DMA</name>
              <description>DMA reset mask</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PCU</name>
              <description>PCU reset mask</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>WDT</name>
              <description>WDT reset mask</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FMC</name>
              <description>FMC reset mask</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SCU</name>
              <description>SCU reset mask</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <!--PRER2 : Peripheral reset enable register 1-->
        <register>
          <name>PRER2</name>
          <description>Peripheral reset enable register 2</description>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <fields>
            <field>
              <name>CRC</name>
              <description>CRC reset mask</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>LED</name>
              <description>LED reset mask</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>LCD</name>
              <description>LCD reset mask</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TOUCH</name>
              <description>TOUCH reset mask</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ADPCM</name>
              <description>ADPCM reset mask</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>COMP</name>
              <description>COMP reset mask</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DAC</name>
              <description>DAC reset mask</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ADC</name>
              <description>ADC reset mask</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>HSICMU</name>
              <description>HSICMU reset mask</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>USB</name>
              <description>USB reset mask</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>UART1</name>
              <description>UART1 reset mask</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>UART0</name>
              <description>UART0 reset mask</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>USART13</name>
              <description>USART13 reset mask</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>USART12</name>
              <description>USART12 reset mask</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>USART11</name>
              <description>USART11 reset mask</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>USART10</name>
              <description>USART10 reset mask</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C2</name>
              <description>I2C2 reset mask</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C1</name>
              <description>I2C1 reset mask</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C0</name>
              <description>I2C0 reset mask</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <!--PER1 : Peripheral enable register 1-->
        <register>
          <name>PER1</name>
          <description>Peripheral enable register 1</description>
          <addressOffset>0x28</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <fields>
            <field>
              <name>WT</name>
              <description>WT function enable</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TIMER21</name>
              <description>TIMER21 function enable</description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TIMER20</name>
              <description>TIMER20 function enable</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TIMER30</name>
              <description>TIMER30 function enable</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TIMER16</name>
              <description>TIMER16 function enable</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TIMER15</name>
              <description>TIMER15 function enable</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TIMER14</name>
              <description>TIMER14 function enable</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TIMER13</name>
              <description>TIMER13 function enable</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TIMER12</name>
              <description>TIMER12 function enable</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TIMER11</name>
              <description>TIMER11 function enable</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TIMER10</name>
              <description>TIMER10 function enable</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIOF</name>
              <description>GPIOF function enable</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIOE</name>
              <description>GPIOE function enable</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIOD</name>
              <description>GPIOD function enable</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIOC</name>
              <description>GPIOC function enable</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIOB</name>
              <description>GPIOB function enable</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIOA</name>
              <description>GPIOA function enable</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DMA</name>
              <description>DMA function enable</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <!--PER2 : Peripheral enable register 2-->
        <register>
          <name>PER2</name>
          <description>Peripheral enable register 2</description>
          <addressOffset>0x2C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <fields>
            <field>
              <name>CRC</name>
              <description>CRC function enable</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>LED</name>
              <description>LED function enable</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>LCD</name>
              <description>LCD function enable</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TOUCH</name>
              <description>TOUCH function enable</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ADPCM</name>
              <description>ADPCM function enable</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>COMP</name>
              <description>COMP function enable</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DAC</name>
              <description>DAC function enable</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ADC</name>
              <description>ADC function enable</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SOFCTMR</name>
              <description>SOFCTMR function enable</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>USB</name>
              <description>USB function enable</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>UART1</name>
              <description>UART1 function enable</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>UART0</name>
              <description>UART0 function enable</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>USART13</name>
              <description>USART13 function enable</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>USART12</name>
              <description>USART12 function enable</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>USART11</name>
              <description>USART11 function enable</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>USART10</name>
              <description>USART10 function enable</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C2</name>
              <description>I2C2 function enable</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C1</name>
              <description>I2C1 function enable</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C0</name>
              <description>I2C0 function enable</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <!--PCER1 : Peripheral clock enable register 1-->
        <register>
          <name>PCER1</name>
          <description>Peripheral clock enable register 1</description>
          <addressOffset>0x30</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <fields>
            <field>
              <name>WT</name>
              <description>WT clock enable</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TIMER21</name>
              <description>TIMER21 clock enable</description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TIMER20</name>
              <description>TIMER20 clock enable</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TIMER30</name>
              <description>TIMER30 clock enable</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TIMER16</name>
              <description>TIMER16 clock enable</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TIMER14</name>
              <description>TIMER14 clock enable</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TIMER13</name>
              <description>TIMER13 clock enable</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TIMER12</name>
              <description>TIMER12 clock enable</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TIMER11</name>
              <description>TIMER11 clock enable</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TIMER10</name>
              <description>TIMER10 clock enable</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIOF</name>
              <description>GPIOF clock enable</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIOE</name>
              <description>GPIOE clock enable</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIOD</name>
              <description>GPIOD clock enable</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIOC</name>
              <description>GPIOC clock enable</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIOB</name>
              <description>GPIOB clock enable</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIOA</name>
              <description>GPIOA clock enable</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DMA</name>
              <description>DMA clock enable</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <!--PCER2 : Peripheral clock enable register 2-->
        <register>
          <name>PCER2</name>
          <description>Peripheral clock enable register 2</description>
          <addressOffset>0x34</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <fields>
            <field>
              <name>CRC</name>
              <description>CRC clock enable</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>LED</name>
              <description>LED clock enable</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>LCD</name>
              <description>LCD clock enable</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TOUCH</name>
              <description>TOUCH clock enable</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ADPCM</name>
              <description>ADPCM clock enable</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>COMP</name>
              <description>COMP clock enable</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DAC</name>
              <description>DAC clock enable</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ADC</name>
              <description>ADC clock enable</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>HSICMU</name>
              <description>HSICMU clock enable</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>USB</name>
              <description>USB clock enable</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>UART1</name>
              <description>UART1 clock enable</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>UART0</name>
              <description>UART0 clock enable</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>USART13</name>
              <description>USART13 clock enable</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>USART12</name>
              <description>USART12 clock enable</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>USART11</name>
              <description>USART11 clock enable</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>USART10</name>
              <description>USART10 clock enable</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C2</name>
              <description>I2C2 clock enable</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C1</name>
              <description>I2C1 clock enable</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C0</name>
              <description>I2C0 clock enable</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <!--PPCLKSR : Peripheral clock selection register-->
        <register>
          <name>PPCLKSR</name>
          <description>Peripheral clock selection register</description>
          <addressOffset>0x38</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>T1xCLK</name>
              <description>Timer 1x Clock Selection bit</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>T20CLK</name>
              <description>Timer 20 Clock Selection bit</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>T30CLK</name>
              <description>Timer 30 Clock Selection bit</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>LEDCLK</name>
              <description>LED Clock Selection bit</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>USBCLK</name>
              <description>USB Clock Selection bit</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>LCDCLK</name>
              <description>LCD Driver Clock Selection bit</description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>WTCLK</name>
              <description>Watch Timer Clock Selection bit
Note) These bits should be changed during the WTEN bit of watch timer control register (WTCR) is "0b"</description>
              <bitOffset>3</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>WDTCLK</name>
              <description>Watch-dog Timer Clock Selection bit</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <!--CSCR : Clock Source Control register-->
        <register>
          <name>CSCR</name>
          <description>Clock Source Control register</description>
          <addressOffset>0x40</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000800</resetValue>
          <fields>
            <field>
              <name>WTIDKY</name>
              <description>On writes, write 0xA507 to these bits, otherwise the write is ignored.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>SOSCCON</name>
              <description>External crystal sub oscillator control</description>
              <bitOffset>12</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>LSICON</name>
              <description>Low speed internal oscillator control</description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>HSICON</name>
              <description>High speed internal oscillator control</description>
              <bitOffset>4</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MOSCCON</name>
              <description>External crystal main oscillator control</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <!--SCCR : System Clock Control register-->
        <register>
          <name>SCCR</name>
          <description>System Clock Control register</description>
          <addressOffset>0x44</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>WTIDKY</name>
              <description>On writes, write 0x570A to these bits, otherwise the write is ignored.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>FINSEL</name>
              <description>PLL input source FIN select register</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MCLKSEL</name>
              <description>System clock select register</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <!--CMR : Clock Monitoring register-->
        <register>
          <name>CMR</name>
          <description>Clock Monitoring register</description>
          <addressOffset>0x48</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000090</resetValue>
          <fields>
            <field>
              <name>MCLKREC</name>
              <description>MCLK fail auto recovery</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SOSCMNT</name>
              <description>External sub oscillator monitoring enable</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SOSCIE</name>
              <description>External sub oscillator fail interrupt enable</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SOSCFAIL</name>
              <description>External sub oscillator fail interrupt</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SOSCSTS</name>
              <description>External sub oscillator status</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MCLKMNT</name>
              <description>MCLK monitoring enable</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MCLKIE</name>
              <description>MCLK fail interrupt enable</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MCLKFAIL</name>
              <description>MCLK fail interrupt</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MCLKSTS</name>
              <description>MCLK clock status</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MOSCMNT</name>
              <description>External main oscillator monitoring enable</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MOSCIE</name>
              <description>External main oscillator fail interrupt enable</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MOSCFAIL</name>
              <description>External main oscillator fail interrupt</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MOSCSTS</name>
              <description>External main oscillator status</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <!--NMIR : NMI control register-->
        <register>
          <name>NMIR</name>
          <description>NMI control register</description>
          <addressOffset>0x4C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>ACCESSCODE</name>
              <description>This field enables writing access to this register.
Writing 0xA32C is to enable writing.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>WDTINTSTS</name>
              <description>WDT Interrupt condition status bit
This bit can't invoke NMI interrupt without enable bit</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>MCLKFAILSTS</name>
              <description>MCLK Fail condition status bit
This bit can't invoke NMI interrupt without enable bit</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>LVDSTS</name>
              <description>LVD condition status bit
This bit can't invoke NMI interrupt without enable bit</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>WDTINTEN</name>
              <description>WDT Interrupt condition enable for NMI interrupt</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MCLKFAILEN</name>
              <description>MCLK Fail condition enable for NMI interrupt</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>LVDEN</name>
              <description>LVD Fail condition enable for NMI interrupt</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <!--COR : Clock Output Control register-->
        <register>
          <name>COR</name>
          <description>Clock Output Control register</description>
          <addressOffset>0x50</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0000000f</resetValue>
          <fields>
            <field>
              <name>CLKOEN</name>
              <description>Clock output enable</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CLKODIV</name>
              <description>Clock output divider value
CLKO=MCLK (CLKODIV=0)
CLKO=MCLK/2(CLKODIV+1)  (CLKODIV &gt; 0)</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <!--PLLCON : PLL Control register-->
        <register>
          <name>PLLCON</name>
          <description>PLL Control register</description>
          <addressOffset>0x60</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>LOCK</name>
              <description>LOCK status</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PLLRSTB</name>
              <description>PLL reset</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PLLEN</name>
              <description>PLL enable</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>BYPASSB</name>
              <description>FIN bypass</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PLLMODE</name>
              <description>PLL VCO mode</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PREDIV</name>
              <description>FIN predivider
FIN divided by (PREDIV + 1), (FIN/1 ~ FIN/8)</description>
              <bitOffset>16</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>POSTDIV1</name>
              <description>Feedback control 1 (N1)
N1 = POSTDIV1 + 1</description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>POSTDIV2</name>
              <description>Feedback control 1 (N2)
N2 = POSTDIV2 + 1</description>
              <bitOffset>4</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OUTDIV</name>
              <description>output divider control (P)
P = OUTDIV + 1</description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <!--VDCCON : VDC Control register-->
        <register>
          <name>VDCCON</name>
          <description>VDC Control register</description>
          <addressOffset>0x64</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x040f007f</resetValue>
          <fields>
            <field>
              <name>VDC33_WTIDKY</name>
              <description>VDC33 Write Identification Key
On writes, write 0xA to these bits, otherwise the write is ignored.</description>
              <bitOffset>28</bitOffset>
              <bitWidth>4</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>VDC33_PDBGR</name>
              <description>VDC33 BGR Power Down Signal</description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>VDC33_STOP</name>
              <description>VDC33 STOP Mode Enable Signal</description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>VDC33_BYPASS</name>
              <description>VDC33 Bypass Mode Enable Signal</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>VDC33_LOCK</name>
              <description>VDC33 VDC option write enable.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>VDC15_WTIDKY</name>
              <description>VDC15 Write Identification Key
On writes, write 0x5 to these bits, otherwise the write is ignored.</description>
              <bitOffset>20</bitOffset>
              <bitWidth>4</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>VDC15_PDBGR</name>
              <description>VDC15 1.2V BGR / 1.0V Buffer Power Down Signal
*In BGR on off, VDCLOCK_I should be 0
</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>VDC15_STOP</name>
              <description>VDC15 STOP Mode Control Signal</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>VDC15_IDLE</name>
              <description>VDC15 STOP1 Mode Control Signal</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>VDC15_LOCK</name>
              <description>VDC15 VDCLOCK Control Signal for *BGR Stabilization
*In BGR off on Sequence, VDCLOCK_I should be 0 during 120usec</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>VDCWDLY_WEN</name>
              <description>VDCWDLY value write enable. VDCWDLY value can be written with writing '1' to VDCWDLY_WEN bit simultaneously.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>VDCWDLY</name>
              <description>VDC warm-up delay count value. 
When SCU is waked up from powerdown mode, the warm-up delay is inserted for VDC output being stabilized.
The amount of delay can be defined with this register value 7F : 4msec </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <!--ROSCCON: ROSC Control Register-->
        <register>
          <name>ROSCCON</name>
          <description>ROSC Control Register</description>
          <addressOffset>0x6c</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>EN_LDO</name>
              <description>Internal LDO On/Off</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SKIP_LS</name>
              <description>Internal Level Shifter control signal</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <!--EOSCR : External Oscillator control register-->
        <register>
          <name>EOSCR</name>
          <description>External Oscillator control register</description>
          <addressOffset>0x80</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00002014</resetValue>
          <fields>
            <field>
              <name>ESEN</name>
              <description>Write enable for External SOSC</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>ESISEL</name>
              <description>Internal Level Shifter control signal</description>
              <bitOffset>12</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ESNCBYPS</name>
              <description>Noise Cancel Bypass enable for External SOSC</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EMEN</name>
              <description>Write enable for External MOSC</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>ISE</name>
              <description>Select current for External MOSC</description>
              <bitOffset>4</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>NCOPT</name>
              <description>Noise Cancel delay Option for External MOSC</description>
              <bitOffset>2</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>NCSKIP</name>
              <description>Noise Cancel Bypass enable for External SOSC</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <!--EMODR : External mode pin read register-->
        <register>
          <name>EMODR</name>
          <description>External mode pin read register</description>
          <addressOffset>0x84</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>SCANMD</name>
              <description>SCAN Mode level</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TEST</name>
              <description>TEST Mode level</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>BOOT</name>
              <description>BOOT pin level</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <!-- MCCR1: Miscellaneous Clock Control Register 1 -->
        <register>
          <name>MCCR1</name>
          <description>Miscellaneous Clock Control Register 1</description>
          <addressOffset>0x90</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TEXT1CSEL</name>
              <description>TIMER1n EXT Clock source select bit</description>
              <bitOffset>24</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TEXT1DIV</name>
              <description>TIMER1n EXT Clock N divider
To change the value, set 0x0 first without changing TEXT1CSEL</description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>STCSEL</name>
              <description>systick clock source sel</description>
              <bitOffset>8</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>STDIV</name>
              <description>SYSTICK Clock N divider
To change the value, set 0x0 first without changing STCSEL</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <!-- MCCR2: Miscellaneous Clock Control Register 2 -->
        <register>
          <name>MCCR2</name>
          <description>Miscellaneous Clock Control Register 2</description>
          <addressOffset>0x94</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TEXT3CSEL</name>
              <description>TIMER 30 EXT Clock source select bit</description>
              <bitOffset>24</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TEXT3DIV</name>
              <description>TIMER 30 EXT Clock N divider
To change the value, set 0x0 first without changing TEXT3DIV</description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TEXT2CSEL</name>
              <description>TEXT2CSEL</description>
              <bitOffset>8</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TEXT2DIV</name>
              <description>TIMER 20 EXT Clock N divider
To change the value, set 0x0 first without changing TEXT2CSEL</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <!-- MCCR3: Miscellaneous Clock Control Register 3 -->
        <register>
          <name>MCCR3</name>
          <description>Miscellaneous Clock Control Register 3</description>
          <addressOffset>0x98</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WTEXTCSEL</name>
              <description>WTEXTCSEL</description>
              <bitOffset>24</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>WTEXTCDIV</name>
              <description>WT External Clock N divider
To change the value, set 0x0 first without changing WTEXTCSEL</description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>WDTCSEL</name>
              <description>WDT clock sel</description>
              <bitOffset>8</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>WDTDIV</name>
              <description>WDT Clock N divider
To change the value, set 0x0 first without changing WDTCSEL</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <!-- MCCR4: Miscellaneous Clock Control Register 4 -->
        <register>
          <name>MCCR4</name>
          <description>Miscellaneous Clock Control Register 4</description>
          <addressOffset>0x9C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PD1CSEL</name>
              <description>Debounce Clock for PORT source select bit (PD,PE,PF)</description>
              <bitOffset>24</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PD1DIV</name>
              <description>PORT Debounce Clock N divider (PD,PE,PF)
To change the value, set 0x0 first without changing PD1CSEL</description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>PD0CSEL</name>
              <description>Debounce Clock for PORT source select bit (PA,PB,PC)</description>
              <bitOffset>8</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PD0DIV</name>
              <description>PORT Debounce Clock N divider  (PA,PB,PC)
To change the value, set 0x0 first without changing PD0CSEL</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <!-- MCCR5: Miscellaneous Clock Control Register 5 -->
        <register>
          <name>MCCR5</name>
          <description>Miscellaneous Clock Control Register 5</description>
          <addressOffset>0xA0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>LCDCSEL</name>
              <description>LCD Clock source select bit</description>
              <bitOffset>24</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>LCDDIV</name>
              <description>LCD Clock N divider
To change the value, set 0x0 first without changing LCDCSEL</description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>LEDCSEL</name>
              <description>LED Clock source select bit</description>
              <bitOffset>8</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>LEDDIV</name>
              <description>LED Clock N divider
To change the value, set 0x0 first without changing LEDCSEL</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <!-- MCCR6: Miscellaneous Clock Control Register 6 -->
        <register>
          <name>MCCR6</name>
          <description>Miscellaneous Clock Control Register 6</description>
          <addressOffset>0xA4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>USBCSEL</name>
              <description>USB Clock source select bit</description>
              <bitOffset>24</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>USBCDIV</name>
              <description>USB Clock N divider
To change the value, set 0x0 first without changing USBCSEL</description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <!--SCUCC-->
    <peripheral>
      <name>SCUCC</name>
      <version>1.0</version>
      <description>CHIP CONFIGURATION</description>
      <groupName>SCU</groupName>
      <baseAddress>0x4000f000</baseAddress>
      <size>32</size>
      <access>read-write</access>
      <addressBlock>
        <offset>0</offset>
        <size>0x00c</size>
        <usage>registers</usage>
      </addressBlock>
      <interrupt>
        <name>SYSCLKFAIL</name>
        <value>01</value>
      </interrupt>
      <registers>
        <!--VENDORID : Vendor Identification Register-->
        <register>
          <name>VENDORID</name>
          <description>Vendor Identification Register</description>
          <addressOffset>0x00</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x41424f56</resetValue>
          <fields>
            <field>
              <name>VENDID</name>
              <description>Vendor Identification bits</description>
              <bitRange>[31:00]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <!--CHIPID : Chip Identification Register-->
        <register>
          <name>CHIPID</name>
          <description>Chip Identification Register</description>
          <addressOffset>0x04</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x4d31f000</resetValue>
          <fields>
            <field>
              <name>CHIPID</name>
              <description>Chip Identification bits. 0x4D31F000: 32k bytes flash memory for program 0x4D31F001: 16k bytes flash memory for program</description>
              <bitRange>[31:00]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <!--REVNR : Revision Number Register-->
        <register>
          <name>REVNR</name>
          <description>Revision Number Register</description>
          <addressOffset>0x08</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>REVNO</name>
              <description>Chip Revision Number. These bits are fixed by manufacturer.</description>
              <bitRange>[07:00]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <!--SCULV-->
    <peripheral>
      <name>SCULV</name>
      <version>1.0</version>
      <description>LOW VOLTAGE INDICATOR(LVI) AND LOW VOLTAGE RESET(LVR)</description>
      <groupName>SCU</groupName>
      <baseAddress>0x40005100</baseAddress>
      <size>32</size>
      <access>read-write</access>
      <addressBlock>
        <offset>0</offset>
        <size>0x00c</size>
        <usage>registers</usage>
      </addressBlock>
      <interrupt>
        <name>LVI</name>
        <value>00</value>
      </interrupt>
      <registers>
        <!--LVICR : Low Voltage Indicator Control Register-->
        <register>
          <name>LVICR</name>
          <description>Low Voltage Indicator Control Register</description>
          <addressOffset>0x00</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>LVIEN</name>
              <description>LVI Enable bit</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>LVINTEN</name>
              <description>LVI Interrupt Enable bit</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>LVIFLAG</name>
              <description>LVI Interrupt Flag bit</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>LVIVS</name>
              <description>LVI Voltage Selection bits</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <!--LVRCR : Low Voltage Reset Control Register-->
        <register>
          <name>LVRCR</name>
          <description>Low Voltage Reset Control Register</description>
          <addressOffset>0x04</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>LVREN</name>
              <description>LVR Enable bits</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <!--LVRCNFIG : Configuration for Low Voltage Reset-->
        <register>
          <name>LVRCNFIG</name>
          <description>Configuration for Low Voltage Reset</description>
          <addressOffset>0x08</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>WTIDKY</name>
              <description>Write Identification Key
On writes, write 0x72A5 to these bits, otherwise the write is ignored.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>LVRENM</name>
              <description>LVR Reset Operation Control Master Configuration</description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>LVRVS</name>
              <description>LVR Voltage Selection bits</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <!--PA-->
    <peripheral>
      <name>PA</name>
      <version>1.0</version>
      <description>General Port A</description>
      <groupName>GPIO</groupName>
      <baseAddress>0x40001000</baseAddress>
      <size>32</size>
      <access>read-write</access>
      <addressBlock>
        <offset>0</offset>
        <size>0x40</size>
        <usage>registers</usage>
      </addressBlock>
      <interrupt>
        <name>GPIOAB</name>
        <value>03</value>
      </interrupt>
      <registers>
        <!--MOD : Port n Mode Register-->
        <register>
          <name>MOD</name>
          <description>Port n Mode Register</description>
          <addressOffset>0x00</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>MODE15</name>
              <description>Pin 15 Mode Selection bits</description>
              <bitRange>[31:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MODE14</name>
              <description>Pin 14 Mode Selection bits</description>
              <bitRange>[29:28]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MODE13</name>
              <description>Pin 13 Mode Selection bits</description>
              <bitRange>[27:26]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MODE12</name>
              <description>Pin 12 Mode Selection bits</description>
              <bitRange>[25:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MODE11</name>
              <description>Pin 11 Mode Selection bits</description>
              <bitRange>[23:22]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MODE10</name>
              <description>Pin 10 Mode Selection bits</description>
              <bitRange>[21:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MODE9</name>
              <description>Pin 9 Mode Selection bits</description>
              <bitRange>[19:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MODE8</name>
              <description>Pin 8 Mode Selection bits</description>
              <bitRange>[17:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MODE7</name>
              <description>Pin 7 Mode Selection bits</description>
              <bitRange>[15:14]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MODE6</name>
              <description>Pin 6 Mode Selection bits</description>
              <bitRange>[13:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MODE5</name>
              <description>Pin 5 Mode Selection bits</description>
              <bitRange>[11:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MODE4</name>
              <description>Pin 4 Mode Selection bits</description>
              <bitRange>[09:08]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MODE3</name>
              <description>Pin 3 Mode Selection bits</description>
              <bitRange>[07:06]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MODE2</name>
              <description>Pin 2 Mode Selection bits</description>
              <bitRange>[05:04]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MODE1</name>
              <description>Pin 1 Mode Selection bits</description>
              <bitRange>[03:02]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MODE0</name>
              <description>Pin 0 Mode Selection bits</description>
              <bitRange>[01:00]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <!--TYP : Port n Output Type Selection Register-->
        <register>
          <name>TYP</name>
          <description>Port n Output Type Selection Register</description>
          <addressOffset>0x04</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>TYP15</name>
              <description>Pin 15 Output Type Selection bit</description>
              <bitRange>[15:15]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TYP14</name>
              <description>Pin 15 Output Type Selection bit</description>
              <bitRange>[14:14]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TYP13</name>
              <description>Pin 13 Output Type Selection bit</description>
              <bitRange>[13:13]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TYP12</name>
              <description>Pin 12 Output Type Selection bit</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TYP11</name>
              <description>Pin 11 Output Type Selection bit</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TYP10</name>
              <description>Pin 10 Output Type Selection bit</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TYP9</name>
              <description>Pin 9 Output Type Selection bit</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TYP8</name>
              <description>Pin 8 Output Type Selection bit</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TYP7</name>
              <description>Pin 7 Output Type Selection bit</description>
              <bitRange>[07:07]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TYP6</name>
              <description>Pin 6 Output Type Selection bit</description>
              <bitRange>[06:06]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TYP5</name>
              <description>Pin 5 Output Type Selection bit</description>
              <bitRange>[05:05]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TYP4</name>
              <description>Pin 4 Output Type Selection bit</description>
              <bitRange>[04:04]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TYP3</name>
              <description>Pin 3 Output Type Selection bit</description>
              <bitRange>[03:03]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TYP2</name>
              <description>Pin 2 Output Type Selection bit</description>
              <bitRange>[02:02]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TYP1</name>
              <description>Pin 1 Output Type Selection bit</description>
              <bitRange>[01:01]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TYP0</name>
              <description>Pin 0 Output Type Selection bit</description>
              <bitRange>[00:00]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <!--AFSR1 : Port n Alternative Function Selection Register 1-->
        <register>
          <name>AFSR1</name>
          <description>Port n Alternative Function Selection Register 1</description>
          <addressOffset>0x08</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>AFSR7</name>
              <description>Pin 7 Alternative Function Selection bits</description>
              <bitRange>[31:28]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>AFSR6</name>
              <description>Pin 6 Alternative Function Selection bits</description>
              <bitRange>[27:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>AFSR5</name>
              <description>Pin 5 Alternative Function Selection bits</description>
              <bitRange>[23:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>AFSR4</name>
              <description>Pin 4 Alternative Function Selection bits</description>
              <bitRange>[19:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>AFSR3</name>
              <description>Pin 3 Alternative Function Selection bits</description>
              <bitRange>[15:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>AFSR2</name>
              <description>Pin 2 Alternative Function Selection bits</description>
              <bitRange>[11:08]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>AFSR1</name>
              <description>Pin 1 Alternative Function Selection bits</description>
              <bitRange>[07:04]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>AFSR0</name>
              <description>Pin 0 Alternative Function Selection bits</description>
              <bitRange>[03:00]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <!--AFSR2 : Port n Alternative Function Selection Register 2-->
        <register>
          <name>AFSR2</name>
          <description>Port n Alternative Function Selection Register 2</description>
          <addressOffset>0x0C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>AFSR15</name>
              <description>Pin 15 Alternative Function Selection bits</description>
              <bitRange>[31:28]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>AFSR14</name>
              <description>Pin 14 Alternative Function Selection bits</description>
              <bitRange>[27:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>AFSR13</name>
              <description>Pin 13 Alternative Function Selection bits</description>
              <bitRange>[23:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>AFSR12</name>
              <description>Pin 12 Alternative Function Selection bits</description>
              <bitRange>[19:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>AFSR11</name>
              <description>Pin 11 Alternative Function Selection bits</description>
              <bitRange>[15:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>AFSR10</name>
              <description>Pin 10 Alternative Function Selection bits</description>
              <bitRange>[11:08]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>AFSR9</name>
              <description>Pin 9 Alternative Function Selection bits</description>
              <bitRange>[07:04]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>AFSR8</name>
              <description>Pin 8 Alternative Function Selection bits</description>
              <bitRange>[03:00]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <!--PUPD : Port n Pull-up/down Resistor Selection Register-->
        <register>
          <name>PUPD</name>
          <description>Port n Pull-up/down Resistor Selection Register</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>PUPD15</name>
              <description>Pin 15 Pull-up/down Resistor Selection bits</description>
              <bitRange>[31:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PUPD14</name>
              <description>Pin 14 Pull-up/down Resistor Selection bits</description>
              <bitRange>[29:28]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PUPD13</name>
              <description>Pin 13 Pull-up/down Resistor Selection bits</description>
              <bitRange>[27:26]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PUPD12</name>
              <description>Pin 12 Pull-up/down Resistor Selection bits</description>
              <bitRange>[25:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PUPD11</name>
              <description>Pin 11 Pull-up/down Resistor Selection bits</description>
              <bitRange>[23:22]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PUPD10</name>
              <description>Pin 10 Pull-up/down Resistor Selection bits</description>
              <bitRange>[21:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PUPD9</name>
              <description>Pin 9 Pull-up/down Resistor Selection bits</description>
              <bitRange>[19:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PUPD8</name>
              <description>Pin 8 Pull-up/down Resistor Selection bits</description>
              <bitRange>[17:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PUPD7</name>
              <description>Pin 7 Pull-up/down Resistor Selection bits</description>
              <bitRange>[15:14]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PUPD6</name>
              <description>Pin 6 Pull-up/down Resistor Selection bits</description>
              <bitRange>[13:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PUPD5</name>
              <description>Pin 5 Pull-up/down Resistor Selection bits</description>
              <bitRange>[11:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PUPD4</name>
              <description>Pin 4 Pull-up/down Resistor Selection bits</description>
              <bitRange>[09:08]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PUPD3</name>
              <description>Pin 3 Pull-up/down Resistor Selection bits</description>
              <bitRange>[07:06]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PUPD2</name>
              <description>Pin 2 Pull-up/down Resistor Selection bits</description>
              <bitRange>[05:04]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PUPD1</name>
              <description>Pin 1 Pull-up/down Resistor Selection bits</description>
              <bitRange>[03:02]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PUPD0</name>
              <description>Pin 0 Pull-up/down Resistor Selection bits</description>
              <bitRange>[01:00]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <!--INDR : Port n Input Data Register-->
        <register>
          <name>INDR</name>
          <description>Port n Input Data Register</description>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>INDR15</name>
              <description>Pin 15 Input Data bit</description>
              <bitRange>[15:15]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>INDR14</name>
              <description>Pin 14 Input Data bit</description>
              <bitRange>[14:14]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>INDR13</name>
              <description>Pin 13 Input Data bit</description>
              <bitRange>[13:13]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>INDR12</name>
              <description>Pin 12 Input Data bit</description>
              <bitRange>[12:12]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>INDR11</name>
              <description>Pin 11 Input Data bit</description>
              <bitRange>[11:11]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>INDR10</name>
              <description>Pin 10 Input Data bit</description>
              <bitRange>[10:10]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>INDR9</name>
              <description>Pin 9 Input Data bit</description>
              <bitRange>[9:9]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>INDR8</name>
              <description>Pin 8 Input Data bit</description>
              <bitRange>[8:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>INDR7</name>
              <description>Pin 7 Input Data bit</description>
              <bitRange>[07:07]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>INDR6</name>
              <description>Pin 6 Input Data bit</description>
              <bitRange>[06:06]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>INDR5</name>
              <description>Pin 5 Input Data bit</description>
              <bitRange>[05:05]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>INDR4</name>
              <description>Pin 4 Input Data bit</description>
              <bitRange>[04:04]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>INDR3</name>
              <description>Pin 3 Input Data bit</description>
              <bitRange>[03:03]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>INDR2</name>
              <description>Pin 2 Input Data bit</description>
              <bitRange>[02:02]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>INDR1</name>
              <description>Pin 1 Input Data bit</description>
              <bitRange>[01:01]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>INDR0</name>
              <description>Pin 0 Input Data bit</description>
              <bitRange>[00:00]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <!--OUTDR : Port n Output Data Register-->
        <register>
          <name>OUTDR</name>
          <description>Port n Output Data Register</description>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>OUTDR15</name>
              <description>Pin 15 Output Data bit</description>
              <bitRange>[15:15]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OUTDR14</name>
              <description>Pin 14 Output Data bit</description>
              <bitRange>[14:14]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OUTDR13</name>
              <description>Pin 13 Output Data bit</description>
              <bitRange>[13:13]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OUTDR12</name>
              <description>Pin 12 Output Data bit</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OUTDR11</name>
              <description>Pin 11 Output Data bit</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OUTDR10</name>
              <description>Pin 10 Output Data bit</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OUTDR9</name>
              <description>Pin 9 Output Data bit</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OUTDR8</name>
              <description>Pin 8 Output Data bit</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OUTDR7</name>
              <description>Pin 7 Output Data bit</description>
              <bitRange>[07:07]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OUTDR6</name>
              <description>Pin 6 Output Data bit</description>
              <bitRange>[06:06]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OUTDR5</name>
              <description>Pin 5 Output Data bit</description>
              <bitRange>[05:05]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OUTDR4</name>
              <description>Pin 4 Output Data bit</description>
              <bitRange>[04:04]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OUTDR3</name>
              <description>Pin 3 Output Data bit</description>
              <bitRange>[03:03]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OUTDR2</name>
              <description>Pin 2 Output Data bit</description>
              <bitRange>[02:02]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OUTDR1</name>
              <description>Pin 1 Output Data bit</description>
              <bitRange>[01:01]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OUTDR0</name>
              <description>Pin 0 Output Data bit</description>
              <bitRange>[00:00]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <!--BSR : Port n Output Bit Set Register-->
        <register>
          <name>BSR</name>
          <description>Port n Output Bit Set Register</description>
          <addressOffset>0x1c</addressOffset>
          <size>32</size>
          <access>write-only</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>BSR15</name>
              <description>Pin 15 Output Set bit. This bit is always read to 0</description>
              <bitRange>[15:15]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>BSR14</name>
              <description>Pin 14 Output Set bit. This bit is always read to 0</description>
              <bitRange>[14:14]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>BSR13</name>
              <description>Pin 13 Output Set bit. This bit is always read to 0</description>
              <bitRange>[13:13]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>BSR12</name>
              <description>Pin 12 Output Set bit. This bit is always read to 0</description>
              <bitRange>[12:12]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>BSR11</name>
              <description>Pin 11 Output Set bit. This bit is always read to 0</description>
              <bitRange>[11:11]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>BSR10</name>
              <description>Pin 10 Output Set bit. This bit is always read to 0</description>
              <bitRange>[10:10]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>BSR9</name>
              <description>Pin 9 Output Set bit. This bit is always read to 0</description>
              <bitRange>[09:09]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>BSR8</name>
              <description>Pin 8 Output Set bit. This bit is always read to 0</description>
              <bitRange>[08:08]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>BSR7</name>
              <description>Pin 7 Output Set bit. This bit is always read to 0</description>
              <bitRange>[07:07]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>BSR6</name>
              <description>Pin 6 Output Set bit. This bit is always read to 0</description>
              <bitRange>[06:06]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>BSR5</name>
              <description>Pin 5 Output Set bit. This bit is always read to 0</description>
              <bitRange>[05:05]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>BSR4</name>
              <description>Pin 4 Output Set bit. This bit is always read to 0</description>
              <bitRange>[04:04]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>BSR3</name>
              <description>Pin 3 Output Set bit. This bit is always read to 0</description>
              <bitRange>[03:03]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>BSR2</name>
              <description>Pin 2 Output Set bit. This bit is always read to 0</description>
              <bitRange>[02:02]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>BSR1</name>
              <description>Pin 1 Output Set bit. This bit is always read to 0</description>
              <bitRange>[01:01]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>BSR0</name>
              <description>Pin 0 Output Set bit. This bit is always read to 0</description>
              <bitRange>[00:00]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <!--BCR : Port n Output Bit Clear Register-->
        <register>
          <name>BCR</name>
          <description>Port n Output Bit Clear Register</description>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <access>write-only</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>BCR15</name>
              <description>Pin 15 Output Clear bit. This bit is always read to 0.</description>
              <bitRange>[15:15]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>BCR14</name>
              <description>Pin 14 Output Clear bit. This bit is always read to 0.</description>
              <bitRange>[14:14]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>BCR13</name>
              <description>Pin 13 Output Clear bit. This bit is always read to 0.</description>
              <bitRange>[13:13]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>BCR12</name>
              <description>Pin 12 Output Clear bit. This bit is always read to 0.</description>
              <bitRange>[12:12]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>BCR11</name>
              <description>Pin 11 Output Clear bit. This bit is always read to 0.</description>
              <bitRange>[11:11]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>BCR10</name>
              <description>Pin 10 Output Clear bit. This bit is always read to 0.</description>
              <bitRange>[10:10]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>BCR9</name>
              <description>Pin 9 Output Clear bit. This bit is always read to 0.</description>
              <bitRange>[09:09]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>BCR8</name>
              <description>Pin 8 Output Clear bit. This bit is always read to 0.</description>
              <bitRange>[08:08]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>BCR7</name>
              <description>Pin 7 Output Clear bit. This bit is always read to 0.</description>
              <bitRange>[07:07]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>BCR6</name>
              <description>Pin 6 Output Clear bit. This bit is always read to 0.</description>
              <bitRange>[06:06]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>BCR5</name>
              <description>Pin 5 Output Clear bit. This bit is always read to 0.</description>
              <bitRange>[05:05]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>BCR4</name>
              <description>Pin 4 Output Clear bit. This bit is always read to 0.</description>
              <bitRange>[04:04]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>BCR3</name>
              <description>Pin 3 Output Clear bit. This bit is always read to 0.</description>
              <bitRange>[03:03]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>BCR2</name>
              <description>Pin 2 Output Clear bit. This bit is always read to 0.</description>
              <bitRange>[02:02]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>BCR1</name>
              <description>Pin 1 Output Clear bit. This bit is always read to 0.</description>
              <bitRange>[01:01]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>BCR0</name>
              <description>Pin 0 Output Clear bit. This bit is always read to 0.</description>
              <bitRange>[00:00]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <!--OUTDMSK : Port n Output Bit Clear Register-->
        <register>
          <name>OUTDMSK</name>
          <description>Port n Output Data Mask Register</description>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>OUTDMSK15</name>
              <description>Pin 15 Output Data Mask bit</description>
              <bitRange>[15:15]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OUTDMSK14</name>
              <description>Pin 14 Output Data Mask bit</description>
              <bitRange>[14:14]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OUTDMSK13</name>
              <description>Pin 13 Output Data Mask bit</description>
              <bitRange>[13:13]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OUTDMSK12</name>
              <description>Pin 12 Output Data Mask bit</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OUTDMSK11</name>
              <description>Pin 11 Output Data Mask bit</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OUTDMSK10</name>
              <description>Pin 10 Output Data Mask bit</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OUTDMSK9</name>
              <description>Pin 9 Output Data Mask bit</description>
              <bitRange>[09:09]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OUTDMSK8</name>
              <description>Pin 8 Output Data Mask bit</description>
              <bitRange>[08:08]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OUTDMSK7</name>
              <description>Pin 7 Output Data Mask bit</description>
              <bitRange>[07:07]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OUTDMSK6</name>
              <description>Pin 6 Output Data Mask bit</description>
              <bitRange>[06:06]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OUTDMSK5</name>
              <description>Pin 5 Output Data Mask bit</description>
              <bitRange>[05:05]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OUTDMSK4</name>
              <description>Pin 4 Output Data Mask bit</description>
              <bitRange>[04:04]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OUTDMSK3</name>
              <description>Pin 3 Output Data Mask bit</description>
              <bitRange>[03:03]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OUTDMSK2</name>
              <description>Pin 2 Output Data Mask bit</description>
              <bitRange>[02:02]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OUTDMSK1</name>
              <description>Pin 1 Output Data Mask bit</description>
              <bitRange>[01:01]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OUTDMSK0</name>
              <description>Pin 0 Output Data Mask bit</description>
              <bitRange>[00:00]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <!--DBCR : Port n Output Bit Clear Register-->
        <register>
          <name>DBCR</name>
          <description>Port n Debounce Control Register</description>
          <addressOffset>0x28</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>DBEN15</name>
              <description>Pin 15 Debounce Enable bit</description>
              <bitRange>[15:15]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DBEN14</name>
              <description>Pin 14 Debounce Enable bit</description>
              <bitRange>[14:14]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DBEN13</name>
              <description>Pin 13 Debounce Enable bit</description>
              <bitRange>[13:13]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DBEN12</name>
              <description>Pin 12 Debounce Enable bit</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DBEN11</name>
              <description>Pin 11 Debounce Enable bit</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DBEN10</name>
              <description>Pin 10 Debounce Enable bit</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DBEN9</name>
              <description>Pin 9 Debounce Enable bit</description>
              <bitRange>[09:09]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DBEN8</name>
              <description>Pin 8 Debounce Enable bit</description>
              <bitRange>[08:08]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DBEN7</name>
              <description>Pin 7 Debounce Enable bit</description>
              <bitRange>[07:07]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DBEN6</name>
              <description>Pin 6 Debounce Enable bit</description>
              <bitRange>[06:06]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DBEN5</name>
              <description>Pin 5 Debounce Enable bit</description>
              <bitRange>[05:05]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DBEN4</name>
              <description>Pin 4 Debounce Enable bit</description>
              <bitRange>[04:04]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DBEN3</name>
              <description>Pin 3 Debounce Enable bit</description>
              <bitRange>[03:03]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DBEN2</name>
              <description>Pin 2 Debounce Enable bit</description>
              <bitRange>[02:02]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DBEN1</name>
              <description>Pin 1 Debounce Enable bit</description>
              <bitRange>[01:01]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DBEN0</name>
              <description>Pin 0 Debounce Enable bit</description>
              <bitRange>[00:00]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <!--IER : Port n interrupt enable register-->
        <register>
          <name>IER</name>
          <description>Port n interrupt enable register</description>
          <addressOffset>0x2C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>P15</name>
              <description>P15 interrupt enable</description>
              <bitOffset>30</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>P14</name>
              <description>P14 interrupt enable</description>
              <bitOffset>28</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>P13</name>
              <description>P13 interrupt enable</description>
              <bitOffset>26</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>P12</name>
              <description>P12 interrupt enable</description>
              <bitOffset>24</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>P11</name>
              <description>P11  interrupt enable</description>
              <bitOffset>22</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>P10</name>
              <description>P10 interrupt enable</description>
              <bitOffset>20</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>P9</name>
              <description>P9  interrupt enable</description>
              <bitOffset>18</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>P8</name>
              <description>P8 interrupt enable</description>
              <bitOffset>16</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>P7</name>
              <description>P7  interrupt enable</description>
              <bitOffset>14</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>P6</name>
              <description>P6 interrupt enable</description>
              <bitOffset>12</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>P5</name>
              <description>P5  interrupt enable</description>
              <bitOffset>10</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>P4</name>
              <description>P4 interrupt enable</description>
              <bitOffset>8</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>P3</name>
              <description>P3  interrupt enable</description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>P2</name>
              <description>P2 interrupt enable</description>
              <bitOffset>4</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>P1</name>
              <description>P1 interrupt enable</description>
              <bitOffset>2</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>P0</name>
              <description>P0 interrupt enable</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
          </fields>
        </register>
        <!--ISR : Port n interrupt status register-->
        <register>
          <name>ISR</name>
          <description>Port n interrupt status register</description>
          <addressOffset>0x30</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>P15</name>
              <description>P15 interrupt status</description>
              <bitOffset>30</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>P14</name>
              <description>P14 interrupt status</description>
              <bitOffset>28</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>P13</name>
              <description>P13 interrupt status</description>
              <bitOffset>26</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>P12</name>
              <description>P12 interrupt status</description>
              <bitOffset>24</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>P11</name>
              <description>P11  interrupt status</description>
              <bitOffset>22</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>P10</name>
              <description>P10 interrupt status</description>
              <bitOffset>20</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>P9</name>
              <description>P9  interrupt status</description>
              <bitOffset>18</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>P8</name>
              <description>P8 interrupt status</description>
              <bitOffset>16</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>P7</name>
              <description>P7  interrupt status</description>
              <bitOffset>14</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>P6</name>
              <description>P6 interrupt status</description>
              <bitOffset>12</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>P5</name>
              <description>P5  interrupt status</description>
              <bitOffset>10</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>P4</name>
              <description>P4 interrupt status</description>
              <bitOffset>8</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>P3</name>
              <description>P3  interrupt status</description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>P2</name>
              <description>P2 interrupt status</description>
              <bitOffset>4</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>P1</name>
              <description>P1 interrupt status</description>
              <bitOffset>2</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>P0</name>
              <description>P0 interrupt status</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
          </fields>
        </register>
        <!--ICR : Port n interrupt control register-->
        <register>
          <name>ICR</name>
          <description>Port n interrupt control register</description>
          <addressOffset>0x34</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>P15</name>
              <description>P15 interrupt control</description>
              <bitOffset>30</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>P14</name>
              <description>P14 interrupt control</description>
              <bitOffset>28</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>P13</name>
              <description>P13 interrupt control</description>
              <bitOffset>26</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>P12</name>
              <description>P12 interrupt control</description>
              <bitOffset>24</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>P11</name>
              <description>P11  interrupt control</description>
              <bitOffset>22</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>P10</name>
              <description>P10 interrupt control</description>
              <bitOffset>20</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>P9</name>
              <description>P9  interrupt control</description>
              <bitOffset>18</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>P8</name>
              <description>P8 interrupt control</description>
              <bitOffset>16</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>P7</name>
              <description>P7  interrupt control</description>
              <bitOffset>14</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>P6</name>
              <description>P6 interrupt control</description>
              <bitOffset>12</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>P5</name>
              <description>P5  interrupt control</description>
              <bitOffset>10</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>P4</name>
              <description>P4 interrupt control</description>
              <bitOffset>8</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>P3</name>
              <description>P3  interrupt control</description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>P2</name>
              <description>P2 interrupt control</description>
              <bitOffset>4</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>P1</name>
              <description>P1 interrupt control</description>
              <bitOffset>2</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>P0</name>
              <description>P0 interrupt control</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <!--PB-->
    <peripheral derivedFrom="PA">
      <name>PB</name>
      <baseAddress>0x40001100</baseAddress>
    </peripheral>
    <!--PC-->
    <peripheral derivedFrom="PA">
      <name>PC</name>
      <baseAddress>0x40001200</baseAddress>
      <interrupt>
        <name>GPIOCD</name>
        <value>04</value>
      </interrupt>
    </peripheral>
    <!--PD-->
    <peripheral derivedFrom="PA">
      <name>PD</name>
      <baseAddress>0x40001300</baseAddress>
    </peripheral>
    <!--PE-->
    <peripheral derivedFrom="PA">
      <name>PE</name>
      <baseAddress>0x40001400</baseAddress>
      <interrupt>
        <name>GPIOE</name>
        <value>05</value>
      </interrupt>
    </peripheral>
    <!--PF-->
    <peripheral derivedFrom="PA">
      <name>PF</name>
      <baseAddress>0x40001500</baseAddress>
      <interrupt>
        <name>GPIOF</name>
        <value>06</value>
      </interrupt>
      <registers>
        <!--PLSR-->
        <register>
          <name>PLSR</name>
          <description>PORT F level select register </description>
          <addressOffset>0x38</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000007</resetMask>
          <fields>
            <field>
              <name>PF7LSB</name>
              <description>PORTF 7 Level Select bit</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PF6LSB</name>
              <description>PORTF 6 Level Select bit</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PF5LSB</name>
              <description>PORTF 5 Level Select bit</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <!--PCU-->
    <peripheral>
      <name>PCU</name>
      <version>1.0</version>
      <description>Port Control Mode Enable Register</description>
      <baseAddress>0x40001540</baseAddress>
      <size>32</size>
      <access>read-write</access>
      <addressBlock>
        <offset>0</offset>
        <size>0xAC0</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <!--USBCON: USB CONTROL Register-->
        <register>
          <name>USBCON</name>
          <description>USB CONTROL Register</description>
          <addressOffset>0x00</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000FFFF</resetMask>
        </register>
        <!-- PORTEN: Port Access Enable -->
        <register>
          <name>PORTEN</name>
          <description>Port Access Enable 0x15-&gt;0x51</description>
          <addressOffset>0xAB0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000FFFF</resetMask>
        </register>
      </registers>
    </peripheral>
    <!--FMC-->
    <peripheral>
      <name>FMC</name>
      <version>1.0</version>
      <description>FLASH MEMORY CONTROLLER</description>
      <groupName>FMC</groupName>
      <baseAddress>0x40000100</baseAddress>
      <size>32</size>
      <access>read-write</access>
      <addressBlock>
        <offset>0</offset>
        <size>0x180</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <!--MR : Port Access Enable-->
        <register>
          <name>MR</name>
          <description>Flash Memory Mode Select register</description>
          <addressOffset>0x04</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x01000000</resetValue>
          <fields>
            <field>
              <name>ACODE</name>
              <description>Access Code.
5A-&gt;A5 : Flash mode entry
A5-&gt;5A : Trim mode entry
81-&gt;28 : AMBA mode entry
66-&gt;99 : PROT mode entry
39-&gt;7D : test mode entry(hidden)</description>
              <bitOffset>0</bitOffset>
              <bitWidth>7</bitWidth>
            </field>
          </fields>
        </register>
        <!--CR : Flash Memory Control register-->
        <register>
          <name>CR</name>
          <description>Flash Memory Control register</description>
          <addressOffset>0x08</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x05000000</resetValue>
          <fields>
            <field>
              <name>LOCKSEL</name>
              <description>LOCK(read protection) access enable.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SELFPGM</name>
              <description>When this bit is set("1"), PGM/ERS/HVEN will be cleared automatically after WRBUSY falling edge. It also enable CPU wait control when HVEN bit is set(1)
(start of program or erase operation)It also affects to PMODE bit operation.
</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IFEN</name>
              <description>Info(OTP1/2/3) block enable</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BBLOCK</name>
              <description>Boot Block(1st 4KB) protection enable/disable from Mass(bulk) erase</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>MAS</name>
              <description>Mass(bulk) erase enable/disable</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SECT4K</name>
              <description>Sector 4K erase enable/disable</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SECT1K</name>
              <description>Sector 1K erase enable/disable</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PMODE</name>
              <description>PMODE enable/disable
(Flash Address path is connected with FMAR) PMODE only valid when SELFPGM bit was not set(when SELFPGM = 0)</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>WADCK</name>
              <description>Program/Erase address data latch clock enable/disable</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PGM</name>
              <description>Program mode enable/disable</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ERS</name>
              <description>Erase mode enable/disable</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HVEN</name>
              <description>High Voltage cycle enable/disable</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <!--AR : Flash Memory Address register-->
        <register>
          <name>AR</name>
          <description>Flash Memory Address register</description>
          <addressOffset>0x0c</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>FADDR</name>
              <description>Word(32-bit) base address : 64K-word address for 256KB Flash.
Auto Incremental after WADCK trigger (after latching of target address).</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <!--DR : Flash Memory Data register-->
        <register>
          <name>DR</name>
          <description>Flash Memory Data register</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>FDATA</name>
              <description>Word size(32-bit) data</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <!--BUSY : Flash Write Busy Status Register-->
        <register>
          <name>BUSY</name>
          <description>Flash Write Busy Status Register</description>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>WRBUSY</name>
              <description>Write Busy status bit 
FLBUSY bit goes high after set HVEN bit (in CTRL register).
FLBUSY bit goes low when WRBUSY becomes low after program(or erase) complete.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <!--CRC : Flash CRC16 check value-->
        <register>
          <name>CRC</name>
          <description>Flash CRC16 check value</description>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>CRC16</name>
              <description>CRC16 check value read register
polynomial: (1 + x5 + x12 + x16)
data width: 32 (the first serial bit is D[31])</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <!--CFG : Flash Memory Config Register-->
        <register>
          <name>CFG</name>
          <description>Flash Memory Config Register</description>
          <addressOffset>0x30</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00008200</resetValue>
          <fields>
            <field>
              <name>WTIDKY</name>
              <description>Write Identification Key. On writes, write 0x7858 to these bits, otherwise the write is ignored.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>WAIT</name>
              <description>This bits only be written in AMBA mode and MSB 16-bit (bit [31:16]) must be 0x7858
00 : flash access in 1 cycle (0-wait) /
01 : flash access in 2 cycles (1-wait) / 
10 : flash access in 3 cycles (2-wait) - default /
11, flash access in 4 cycles (3-wait)</description>
              <bitOffset>8</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>CRCINIT</name>
              <description>When this bit is set('1'), CRC register will be initialized
It should be reset again before read flash to generate CRC16 calculation
(Initial value of FMCRC is 0xFFFF)</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CRCEN</name>
              <description>CRC16 enable
CRC value will be calculated at every flash read timing</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <!--WPROT : Write Protection Register-->
        <register>
          <name>WPROT</name>
          <description>Write Protection Register</description>
          <addressOffset>0x34</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>WPROT</name>
              <description>Write protection
each 8 KB segments for whole memory address (needs 16 bits for 128KB flash)</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <!--LOCK : Flash LOCK register-->
        <register>
          <name>LOCK</name>
          <description>Flash LOCK register</description>
          <addressOffset>0x3c</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x000000ff</resetValue>
          <fields>
            <field>
              <name>RPROT</name>
              <description>Read protection
0x0000_00FF is Default. Any other value will lock falsh(enable read protection)
In user mode, 0xFF can not be written
To unlock, user must erase LOCK area of Flash next to MAS(bulk) erase
- 1st MAS(bult) erase and then erase LOCK area
- To unlock the flash, pin reset or power on reset required</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <!--DMAC0-->
    <peripheral>
      <name>DMAC0</name>
      <version>1.0</version>
      <description>FLASH MEMORY CONTROLLER</description>
      <groupName>DMAC</groupName>
      <baseAddress>0x40000400</baseAddress>
      <size>32</size>
      <access>read-write</access>
      <addressBlock>
        <offset>0</offset>
        <size>0x10</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <!--CR : DMA Channel n Control Register-->
        <register>
          <name>CR</name>
          <description>DMA Channel n Control Register</description>
          <addressOffset>0x00</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>TRANSCNT</name>
              <description>Number of DMA transfer remained
Required transfer number should be written before enable DMA transfer.
0 : DMA transfer is done.
N : N transfers are remained.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>12</bitWidth>
            </field>
            <field>
              <name>PERISEL</name>
              <description>Peripheral selction
N : Associated peripheral selection. 
Refer to DMA Peripheral connection table</description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>SIZE</name>
              <description>Bus transfer size.
00: DMA transfer is byte size transfer
01: DMA transfer is half word size transfer
10: DMA transfer is word size transfer
11: Reserved</description>
              <bitOffset>2</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>DIR</name>
              <description>Select transfer direction.
0: Transfer direction is from memory to peripheral. (TX)
1: Transfer direction is from peripheral to memory. (RX)</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <!--SR : DMA Channel n Status Register-->
        <register>
          <name>SR</name>
          <description>DMA Channel n Status Register</description>
          <addressOffset>0x04</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>EOT</name>
              <description>End of transfer.
0: Data to be transferred is existing. TRANSCNT shows non zero value 
1: All data is transferred. TRANSCNT shows now 0</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DMAEN</name>
              <description>DMA Enable
0: DMA is in stop or hold state
1: DMA is running or enabled</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <!--PAR : DMA Channel n Peripheral Address-->
        <register>
          <name>PAR</name>
          <description>DMA Channel n Peripheral Address</description>
          <addressOffset>0x08</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>PAR</name>
              <description>Target Peripheral address of transmit buffer or receive buffer.
Address is fixed address when each transfer is done.
If DIR is "0" this address is destination address of data transfer.
If DIR is "1", this address is source address of data transfer.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <!--MAR : DMA Channel n Memory Address-->
        <register>
          <name>MAR</name>
          <description>DMA Channel n Memory Address</description>
          <addressOffset>0x0c</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x20000000</resetValue>
          <fields>
            <field>
              <name>MAR</name>
              <description>Target memory address of data transfer.
Address is automatically incremented according to SIZE bits when each transfer is done.
If DIR is "0" this address is source address of data transfer.
If DIR is "1", this address is destination address of data transfer.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <!--DMAC1-->
    <peripheral derivedFrom="DMAC0">
      <name>DMAC1</name>
      <baseAddress>0x40000410</baseAddress>
    </peripheral>
    <!--DMAC2-->
    <peripheral derivedFrom="DMAC0">
      <name>DMAC2</name>
      <baseAddress>0x40000420</baseAddress>
    </peripheral>
    <!--DMAC3-->
    <peripheral derivedFrom="DMAC0">
      <name>DMAC3</name>
      <baseAddress>0x40000430</baseAddress>
    </peripheral>
    <!--WDT-->
    <peripheral>
      <name>WDT</name>
      <version>1.0</version>
      <description>WATCH-DOG TIMER</description>
      <groupName>WDT</groupName>
      <baseAddress>0x40001a00</baseAddress>
      <size>32</size>
      <access>read-write</access>
      <addressBlock>
        <offset>0</offset>
        <size>0x020</size>
        <usage>registers</usage>
      </addressBlock>
      <interrupt>
        <name>WDT</name>
        <value>02</value>
      </interrupt>
      <registers>
        <!--CR : Watch-dog Timer Control Register-->
        <register>
          <name>CR</name>
          <description>Watch-dog Timer Control Register</description>
          <addressOffset>0x00</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xffffffff</resetMask>
          <fields>
            <field>
              <name>WTIDKY</name>
              <description>Write Identification Key. On writes, write 0x5A69 to these bits, otherwise the write is ignored.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>RSTEN</name>
              <description>Watch-dog Timer Reset Enable bits</description>
              <bitOffset>10</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CNTEN</name>
              <description>Watch-dog Timer Counter Enable bits</description>
              <bitOffset>4</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>WINMIEN</name>
              <description>Watch-dog Timer Window Match Interrupt Enable bit</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>UNFIEN</name>
              <description>Watch-dog Timer Underflow Interrupt Enable bit</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CLKDIV</name>
              <description>Watch-dog Timer Clock Divider bits, The clock which is selected by PPCLKSR[0]</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <!--SR : Watch-dog Timer Status Register-->
        <register>
          <name>SR</name>
          <description>Watch-dog Timer Status Register</description>
          <addressOffset>0x04</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000080</resetValue>
          <resetMask>0x0000083</resetMask>
          <fields>
            <field>
              <name>DBGCNTEN</name>
              <description>Watch-dog Timer Counter Enable bit. When the core is halted in the debug mode. Note: This bit is cleared to "0b" only by POR reset.</description>
              <bitRange>[07:07]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>RUN_CORE_HALTED</name>
                  <description>The watch-dog timer counter continues even if the core is halted.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>STOP_CORE_HALTED</name>
                  <description>The watch-dog timer counter is stopped when the core is halted.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WINMIFLAG</name>
              <description>Watch-dog Timer Window Match Interrupt Flag bit</description>
              <bitRange>[01:01]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>WDT_WDM_IF_CLR</name>
                  <description>No request occurred</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WDT_WDM_IF_SET</name>
                  <description>Request occurred, This bit is cleared to '0' when write '1'.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>UNFIFLAG</name>
              <description>Watch-dog Timer Underflow Interrupt Flag bit</description>
              <bitRange>[00:00]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>WDT_UDF_IF_CLR</name>
                  <description>No request occurred</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WDT_UDF_IF_SET</name>
                  <description>Request occurred, This bit is cleared to '0' when write '1'.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <!--DR : Watch-dog Timer Data Register-->
        <register>
          <name>DR</name>
          <description>Watch-dog Timer Data Register</description>
          <addressOffset>0x08</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000fff</resetValue>
          <resetMask>0x00ffffff</resetMask>
          <fields>
            <field>
              <name>DATA</name>
              <description>Watch-dog Timer Data bits. The range is 0x000000 to 0xFFFFFF.</description>
              <bitRange>[23:00]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <!--CNT : Watch-dog Timer Counter Register-->
        <register>
          <name>CNT</name>
          <description>Watch-dog Timer Counter Register</description>
          <addressOffset>0x0c</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000fff</resetValue>
          <resetMask>0x00ffffff</resetMask>
          <fields>
            <field>
              <name>CNT</name>
              <description>Watch-dog Timer Counter bits.</description>
              <bitRange>[23:00]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <!--WINDR : Watch-dog Timer Window Data Register (Note: Once any value is written to this window data register, the register can't be changed until a system reset.)-->
        <register>
          <name>WINDR</name>
          <description>Watch-dog Timer Window Data Register (Note: Once any value is written to this window data register, the register can't be changed until a system reset.)</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00001fff</resetValue>
          <resetMask>0x00ffffff</resetMask>
          <fields>
            <field>
              <name>WDATA</name>
              <description>Watch-dog Timer Window Data bits. The range is 0x000000 to 0xFFFFFF.</description>
              <bitRange>[23:00]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <!--CNTR : Watch-dog Timer Counter Reload Register-->
        <register>
          <name>CNTR</name>
          <description>Watch-dog Timer Counter Reload Register</description>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <access>write-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000000ff</resetMask>
          <fields>
            <field>
              <name>CNTR</name>
              <description>Watch-dog Timer Counter Reload bits.</description>
              <bitRange>[07:00]</bitRange>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>RELOAD_WDTDR</name>
                  <description>Reload the WDTDR value to watch-dog timer counter and re-start. (Automatically cleared to "0x00" after operation)</description>
                  <value>0x6a</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UNLOAD_WDTDR</name>
                  <description>No effect</description>
                  <value>0x00</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <!--WT-->
    <peripheral>
      <name>WT</name>
      <version>1.0</version>
      <description>WATCH TIMER</description>
      <groupName>WT</groupName>
      <baseAddress>0x40002000</baseAddress>
      <size>32</size>
      <access>read-write</access>
      <addressBlock>
        <offset>0</offset>
        <size>0x010</size>
        <usage>registers</usage>
      </addressBlock>
      <interrupt>
        <name>WT</name>
        <value>12</value>
      </interrupt>
      <registers>
        <!--CR : Watch Timer Control Register-->
        <register>
          <name>CR</name>
          <description>Watch Timer Control Register</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000000bb</resetMask>
          <fields>
            <field>
              <name>WTEN</name>
              <description>Watch Timer Operation Enable bit</description>
              <bitRange>[07:07]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DISABLE_WT</name>
                  <description>Disable watch timer operation</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENABLE_WT</name>
                  <description>Enable watch timer operation</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WTINTV</name>
              <description>Watch Timer Interval Selection bits.</description>
              <bitRange>[05:04]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>WT_IF_INTERVAL_7</name>
                  <description>fWT/2^7</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WT_IF_INTERVAL_13</name>
                  <description>fWT/2^13</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WT_IF_INTERVAL_14</name>
                  <description>fWT/2^14</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WT_IF_INTERVAL_14_</name>
                  <description>fWT/(2^14x(WTDR value + 1))</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WTIEN</name>
              <description>Watch Timer Interrupt Enable bit</description>
              <bitRange>[03:03]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DISABLE_WT_INT</name>
                  <description>Disable watch timer interrupt</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENABLE_WT_INT</name>
                  <description>Enable watch timer interrupt</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WTIFLAG</name>
              <description>Watch Timer Interrupt Flag bit</description>
              <bitRange>[01:01]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>WT_IF_CLR</name>
                  <description>No request occurred</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WT_IF_SET</name>
                  <description>Request occurred, This bit is cleared to '0' when write '1'.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WTCLR</name>
              <description>Watch Timer Counter and Divider Clear bit</description>
              <bitRange>[00:00]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>LET_WT_CNT_BE</name>
                  <description>No effect</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CLEAR_WT_CNT</name>
                  <description>Clear the counter and divider (Automatically cleared to "0b" after operation)</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <!--DR : Watch Timer Data Register-->
        <register>
          <name>DR</name>
          <description>Watch Timer Data Register</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000fff</resetValue>
          <resetMask>0x00000fff</resetMask>
          <fields>
            <field>
              <name>WTDATA</name>
              <description>Watch Timer Data bits. The range is 0x001 to 0xFFF.</description>
              <bitRange>[11:00]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <!--CNT : Watch Timer Counter Register-->
        <register>
          <name>CNT</name>
          <description>Watch Timer Counter Register</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000fff</resetMask>
          <fields>
            <field>
              <name>CNT</name>
              <description>Watch Timer Counter bits.</description>
              <bitRange>[11:00]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <!--TIMER10-->
    <peripheral>
      <name>TIMER10</name>
      <version>1.0</version>
      <description>TIMER COUNTER 10/11/12</description>
      <groupName>TC</groupName>
      <baseAddress>0x40002100</baseAddress>
      <size>32</size>
      <access>read-write</access>
      <addressBlock>
        <offset>0</offset>
        <size>0x100</size>
        <usage>registers</usage>
      </addressBlock>
      <interrupt>
        <name>TIMER10</name>
        <value>07</value>
      </interrupt>
      <registers>
        <!--CR : Timer/Counter n Control Register-->
        <register>
          <name>CR</name>
          <description>Timer/Counter n Control Register</description>
          <addressOffset>0x00</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000f9ff</resetMask>
          <fields>
            <field>
              <name>TnEN</name>
              <description>Timer n Operation Enable bit</description>
              <bitRange>[15:15]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TnCLK</name>
              <description>Timer n Clock Selection bit (Note: This bit should be changed during TnEN bit is "0b".)</description>
              <bitRange>[14:14]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TnMS</name>
              <description>Timer n Operation Mode Selection bits (Note: These bits should be changed during TnEN bit is "0b".)</description>
              <bitRange>[13:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TnECE</name>
              <description>Timer n External Clock Edge Selection bit</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TnOPOL</name>
              <description>TnOUT Polarity Selection bit</description>
              <bitRange>[08:08]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TnCPOL</name>
              <description>Timer n Capture Polarity Selection bits</description>
              <bitRange>[07:06]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TnMIEN</name>
              <description>Timer n Match Interrupt Enable bit</description>
              <bitRange>[05:05]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TnCIEN</name>
              <description>Timer n Capture Interrupt Enable bit</description>
              <bitRange>[04:04]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TnMIFLAG</name>
              <description>Timer n Match Interrupt Flag bit</description>
              <bitRange>[03:03]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TnCIFLAG</name>
              <description>Timer n Capture Interrupt Flag bit</description>
              <bitRange>[02:02]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TnPAU</name>
              <description>Timer n Counter Temporary Pause Control bit</description>
              <bitRange>[01:01]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TnCLR</name>
              <description>Timer n Counter and Prescaler Clear bit</description>
              <bitRange>[00:00]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <!--ADR : Timer/Counter n A Data Register-->
        <register>
          <name>ADR</name>
          <description>Timer/Counter n A Data Register</description>
          <addressOffset>0x04</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0000ffff</resetValue>
          <resetMask>0x0000ffff</resetMask>
          <fields>
            <field>
              <name>ADATA</name>
              <description>Timer/Counter n A Data bits. The range is 0x0000 to 0xFFFF. Note: Do not write "0000H" in the TnADR register when PPG mode.</description>
              <bitRange>[15:00]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <!--BDR : Timer/Counter n B Data Register-->
        <register>
          <name>BDR</name>
          <description>Timer/Counter n B Data Register</description>
          <addressOffset>0x08</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0000ffff</resetValue>
          <resetMask>0x0000ffff</resetMask>
          <fields>
            <field>
              <name>BDATA</name>
              <description>Timer/Counter n B Data bits. The range is 0x0000 to 0xFFFF.</description>
              <bitRange>[15:00]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <!--CAPDR : Timer/Counter n Capture Data Register-->
        <register>
          <name>CAPDR</name>
          <description>Timer/Counter n Capture Data Register</description>
          <addressOffset>0x0c</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000ffff</resetMask>
          <fields>
            <field>
              <name>CAPD</name>
              <description>Timer/Counter n Capture Data bits.</description>
              <bitRange>[15:00]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <!--PREDR : Timer/Counter n Prescaler Data Register-->
        <register>
          <name>PREDR</name>
          <description>Timer/Counter n Prescaler Data Register</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000fff</resetValue>
          <resetMask>0x00000fff</resetMask>
          <fields>
            <field>
              <name>PRED</name>
              <description>Timer/Counter n Prescaler Data bits.</description>
              <bitRange>[11:00]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <!--CNT : Timer/Counter n Counter Register-->
        <register>
          <name>CNT</name>
          <description>Timer/Counter n Counter Register</description>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000ffff</resetMask>
          <fields>
            <field>
              <name>CNT</name>
              <description>Timer/Counter n Counter bits.</description>
              <bitRange>[15:00]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <!--TIMER11-->
    <peripheral derivedFrom="TIMER10">
      <name>TIMER11</name>
      <baseAddress>0x40002200</baseAddress>
      <interrupt>
        <name>TIMER11</name>
        <value>08</value>
      </interrupt>
    </peripheral>
    <!--TIMER12-->
    <peripheral derivedFrom="TIMER10">
      <name>TIMER12</name>
      <baseAddress>0x40002300</baseAddress>
      <interrupt>
        <name>TIMER12</name>
        <value>09</value>
      </interrupt>
    </peripheral>
    <!--TIMER13-->
    <peripheral derivedFrom="TIMER10">
      <name>TIMER13</name>
      <baseAddress>0x40002700</baseAddress>
      <interrupt>
        <name>TIMER13</name>
        <value>21</value>
      </interrupt>
    </peripheral>
    <!--TIMER14-->
    <peripheral derivedFrom="TIMER10">
      <name>TIMER14</name>
      <baseAddress>0x40002800</baseAddress>
      <interrupt>
        <name>TIMER14</name>
        <value>22</value>
      </interrupt>
    </peripheral>
    <!--TIMER15-->
    <peripheral derivedFrom="TIMER10">
      <name>TIMER15</name>
      <baseAddress>0x40002900</baseAddress>
      <interrupt>
        <name>TIMER15</name>
        <value>23</value>
      </interrupt>
    </peripheral>
    <!--TIMER16-->
    <peripheral derivedFrom="TIMER10">
      <name>TIMER16</name>
      <baseAddress>0x40002A00</baseAddress>
      <interrupt>
        <name>TIMER16</name>
        <value>24</value>
      </interrupt>
    </peripheral>
    <!--TIMER20-->
    <peripheral>
      <name>TIMER20</name>
      <version>1.0</version>
      <description>TIMER COUNTER 20/21</description>
      <groupName>TC</groupName>
      <baseAddress>0x40002500</baseAddress>
      <size>32</size>
      <access>read-write</access>
      <addressBlock>
        <offset>0</offset>
        <size>0x020</size>
        <usage>registers</usage>
      </addressBlock>
      <interrupt>
        <name>TIMER20</name>
        <value>15</value>
      </interrupt>
      <registers>
        <!--CR : Timer/Counter n Control Register-->
        <register>
          <name>CR</name>
          <description>Timer/Counter n Control Register</description>
          <addressOffset>0x00</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000ffff</resetMask>
          <fields>
            <field>
              <name>TnEN</name>
              <description>Timer n Operation Enable bit</description>
              <bitRange>[15:15]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TnCLK</name>
              <description>Timer n Clock Selection bit (Note: This bit should be changed during TnEN bit is "0b".)</description>
              <bitRange>[14:14]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TnMS</name>
              <description>Timer n Operation Mode Selection bits (Note: These bits should be changed during TnEN bit is "0b".)</description>
              <bitRange>[13:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TnECE</name>
              <description>Timer n External Clock Edge Selection bit</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TnOPOL</name>
              <description>TnOUT Polarity Selection bit</description>
              <bitRange>[08:08]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TnCPOL</name>
              <description>Timer n Capture Polarity Selection bits</description>
              <bitRange>[07:06]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TnMIEN</name>
              <description>Timer n Match Interrupt Enable bit</description>
              <bitRange>[05:05]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TnCIEN</name>
              <description>Timer n Capture Interrupt Enable bit</description>
              <bitRange>[04:04]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TnMIFLAG</name>
              <description>Timer n Match Interrupt Flag bit</description>
              <bitRange>[03:03]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TnCIFLAG</name>
              <description>Timer n Capture Interrupt Flag bit</description>
              <bitRange>[02:02]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TnPAU</name>
              <description>Timer n Counter Temporary Pause Control bit</description>
              <bitRange>[01:01]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TnCLR</name>
              <description>Timer n Counter and Prescaler Clear bit</description>
              <bitRange>[00:00]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <!--ADR : Timer/Counter n A Data Register-->
        <register>
          <name>ADR</name>
          <description>Timer/Counter n A Data Register</description>
          <addressOffset>0x04</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xffffffff</resetValue>
          <resetMask>0xffffffff</resetMask>
          <fields>
            <field>
              <name>ADATA</name>
              <description>Timer/Counter n A Data bits. The range is 0x00000000 to 0xFFFFFFFF. Note: Do not write "00000000H" in the TnADR register when PPG mode.</description>
              <bitRange>[31:00]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <!--BDR : Timer/Counter n B Data Register-->
        <register>
          <name>BDR</name>
          <description>Timer/Counter n B Data Register</description>
          <addressOffset>0x08</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xffffffff</resetValue>
          <resetMask>0xffffffff</resetMask>
          <fields>
            <field>
              <name>BDATA</name>
              <description>Timer/Counter n B Data bits. The range is 0x00000000 to 0xFFFFFFFF.</description>
              <bitRange>[31:00]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <!--CAPDR : Timer/Counter n Capture Data Register-->
        <register>
          <name>CAPDR</name>
          <description>Timer/Counter n Capture Data Register</description>
          <addressOffset>0x0c</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xffffffff</resetMask>
          <fields>
            <field>
              <name>CAPD</name>
              <description>Timer/Counter n Capture Data bits.</description>
              <bitRange>[31:00]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <!--PREDR : Timer/Counter n Prescaler Data Register-->
        <register>
          <name>PREDR</name>
          <description>Timer/Counter n Prescaler Data Register</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000fff</resetValue>
          <resetMask>0x00000fff</resetMask>
          <fields>
            <field>
              <name>PRED</name>
              <description>Timer/Counter n Prescaler Data bits.P</description>
              <bitRange>[11:00]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <!--CNT : Timer/Counter n Counter Register-->
        <register>
          <name>CNT</name>
          <description>Timer/Counter n Counter Register</description>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xffffffff</resetMask>
          <fields>
            <field>
              <name>CNT</name>
              <description>Timer/Counter n Counter bits.</description>
              <bitRange>[31:00]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <!--TIMER21-->
    <peripheral derivedFrom="TIMER20">
      <name>TIMER21</name>
      <baseAddress>0x40002600</baseAddress>
      <interrupt>
        <name>TIMER21</name>
        <value>16</value>
      </interrupt>
    </peripheral>
    <!--TIMER30-->
    <peripheral>
      <name>TIMER30</name>
      <version>1.0</version>
      <description>TIMER COUNTER 30</description>
      <groupName>TC</groupName>
      <baseAddress>0x40002400</baseAddress>
      <size>32</size>
      <access>read-write</access>
      <addressBlock>
        <offset>0</offset>
        <size>0x040</size>
        <usage>registers</usage>
      </addressBlock>
      <interrupt>
        <name>TIMER30</name>
        <value>13</value>
      </interrupt>
      <registers>
        <!--CR : Timer/Counter 30 Control Register-->
        <register>
          <name>CR</name>
          <description>Timer/Counter 30 Control Register</description>
          <addressOffset>0x00</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000ffff</resetMask>
          <fields>
            <field>
              <name>T30EN</name>
              <description>Timer 30 Operation Enable bit</description>
              <bitRange>[15:15]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DISABLE_T30</name>
                  <description>Disable timer 30 operation</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENABLE_T30</name>
                  <description>Enable timer 30 operation (Counter clear and start)</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>T30CLK</name>
              <description>Timer 30 Clock Selection bit (Note: This bit should be changed during T30EN bit is "0b".)</description>
              <bitRange>[14:14]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SELECT_INTERNAL_CLK</name>
                  <description>Select an internal prescaler clock</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SELECT_EXTERNAL_CLK</name>
                  <description>Select an external clock</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>T30MS</name>
              <description>Timer 30 Operation Mode Selection bits (Note: These bits should be changed during T30EN bit is "0b".)</description>
              <bitRange>[13:12]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INTERVAL_MODE</name>
                  <description>Interval mode (All match interrupts can occur)</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CAPTURE_MODE</name>
                  <description>Capture mode (The Period-match interrupt can occur)</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>BACK_TO_BACK_MODE</name>
                  <description>Back-to-back mode (All interrupts can occur)</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>T30ECE</name>
              <description>Timer 30 External Clock Edge Selection bit</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FORCA</name>
              <description>Timer 30 Output Mode Selection bit. This bit should be changed when the T30EN is "0b". Note: If this bit is changed on operation, it shall apply from the next period.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DLYEN</name>
              <description>Delay Time Insertion Enable bit</description>
              <bitRange>[09:09]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DLYPOS</name>
              <description>Delay Time Insertion Position</description>
              <bitRange>[08:08]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>T30CPOL</name>
              <description>Timer 30 Capture Polarity Selection bits</description>
              <bitRange>[07:06]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UPDT</name>
              <description>Data Reload Time Selection bits</description>
              <bitRange>[05:04]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PMOC</name>
              <description>Period Match Interrupt Occurrence Selection (Note: A period match counter is cleared as 0x00 when the T3nCLR bit is set or the PMOC[2:0] bits are changed.)</description>
              <bitRange>[03:01]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>T30CLR</name>
              <description>Timer 30 Counter and Prescaler Clear bit</description>
              <bitRange>[00:00]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>LET_T30_CNT_BE</name>
                  <description>No effect</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CLEAR_T30_CNT</name>
                  <description>Clear timer 30 counter and prescaler (Automatically cleared to "0b" after operation)</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <!--PDR : Timer/Counter 30 Period Data Register-->
        <register>
          <name>PDR</name>
          <description>Timer/Counter 30 Period Data Register</description>
          <addressOffset>0x04</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0000ffff</resetValue>
          <resetMask>0x0000ffff</resetMask>
          <fields>
            <field>
              <name>PDATA</name>
              <description>Timer/Counter 30 Period Data bits. The range is 0x0002 to 0xFFFF.</description>
              <bitRange>[15:00]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <!--ADR : Timer/Counter 30 A Data Register-->
        <register>
          <name>ADR</name>
          <description>Timer/Counter 30 A Data Register</description>
          <addressOffset>0x08</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0000ffff</resetValue>
          <resetMask>0x0000ffff</resetMask>
          <fields>
            <field>
              <name>ADATA</name>
              <description>Timer/Counter 30 A Data bits. The range is 0x0000 to 0xFFFF.</description>
              <bitRange>[15:00]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <!--BDR : Timer/Counter 30 B Data Register-->
        <register>
          <name>BDR</name>
          <description>Timer/Counter 30 B Data Register</description>
          <addressOffset>0x0c</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0000ffff</resetValue>
          <resetMask>0x0000ffff</resetMask>
          <fields>
            <field>
              <name>BDATA</name>
              <description>Timer/Counter 30 B Data bits. The range is 0x0000 to 0xFFFF.</description>
              <bitRange>[15:00]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <!--CDR : Timer/Counter 30 C Data Register-->
        <register>
          <name>CDR</name>
          <description>Timer/Counter 30 C Data Register</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0000ffff</resetValue>
          <resetMask>0x0000ffff</resetMask>
          <fields>
            <field>
              <name>CDATA</name>
              <description>Timer/Counter 30 C Data bits. The range is 0x0000 to 0xFFFF.</description>
              <bitRange>[15:00]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <!--CAPDR : Timer/Counter 30 Capture Data Register-->
        <register>
          <name>CAPDR</name>
          <description>Timer/Counter 30 Capture Data Register</description>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000ffff</resetMask>
          <fields>
            <field>
              <name>CAPD</name>
              <description>Timer/Counter 30 Capture Data bits.</description>
              <bitRange>[15:00]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <!--PREDR : Timer/Counter 30 Prescaler Data Register-->
        <register>
          <name>PREDR</name>
          <description>Timer/Counter 30 Prescaler Data Register</description>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000fff</resetValue>
          <resetMask>0x00000fff</resetMask>
          <fields>
            <field>
              <name>PRED</name>
              <description>Timer/Counter 30 Prescaler Data bits.</description>
              <bitRange>[11:00]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <!--CNT : Timer/Counter 30 Counter Register-->
        <register>
          <name>CNT</name>
          <description>Timer/Counter 30 Counter Register</description>
          <addressOffset>0x1c</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000ffff</resetMask>
          <fields>
            <field>
              <name>CNT</name>
              <description>Timer/Counter 30 Counter bits.</description>
              <bitRange>[15:00]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <!--OUTCR : Timer/Counter 30 Output Control Register-->
        <register>
          <name>OUTCR</name>
          <description>Timer/Counter 30 Output Control Register</description>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000ff77</resetMask>
          <fields>
            <field>
              <name>WTIDKY</name>
              <description>Write Identification Key. On writes, write 0xE06C to these bits, otherwise the write is ignored.</description>
              <bitRange>[31:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>POLB</name>
              <description>PWM30xB Output Polarity Selection bit</description>
              <bitRange>[15:15]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>POLA</name>
              <description>PWM30xA Output Polarity Selection bit</description>
              <bitRange>[14:14]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PABOE</name>
              <description>PWM30AB Output Enable bit</description>
              <bitRange>[13:13]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PBBOE</name>
              <description>PWM30BB Output Enable bit</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PCBOE</name>
              <description>PWM30CB Output Enable bit</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PAAOE</name>
              <description>PWM30AA Output Enable bit</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PBAOE</name>
              <description>PWM30BA Output Enable bit</description>
              <bitRange>[09:09]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PCAOE</name>
              <description>PWM30CA Output Enable bit</description>
              <bitRange>[08:08]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LVLAB</name>
              <description>Configure PWM30AB output When Disable</description>
              <bitRange>[06:06]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LVLBB</name>
              <description>Configure PWM30BB output When Disable</description>
              <bitRange>[05:05]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LVLCB</name>
              <description>Configure PWM30CB output When Disable</description>
              <bitRange>[04:04]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LVLAA</name>
              <description>Configure PWM30AA output When Disable</description>
              <bitRange>[02:02]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LVLBA</name>
              <description>Configure PWM30BA output When Disable</description>
              <bitRange>[01:01]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LVLCA</name>
              <description>Configure PWM30CA output When Disable</description>
              <bitRange>[00:00]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <!--DLY : Timer/Counter 30 PWM Output Delay Data Register-->
        <register>
          <name>DLY</name>
          <description>Timer/Counter 30 PWM Output Delay Data Register</description>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000003ff</resetMask>
          <fields>
            <field>
              <name>DLY</name>
              <description>Timer/Counter 30 PWM Delay Data bits. Delay time: DLY[9:0]/fT30</description>
              <bitRange>[09:00]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <!--INTCR : Timer/Counter 30 Interrupt Control Register-->
        <register>
          <name>INTCR</name>
          <description>Timer/Counter 30 Interrupt Control Register</description>
          <addressOffset>0x28</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000007f</resetMask>
          <fields>
            <field>
              <name>HIZIEN</name>
              <description>Timer 30 Output High-Impedance Interrupt Enable bit</description>
              <bitRange>[06:06]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>T30CIEN</name>
              <description>Timer 30 Capture Interrupt Enable bit</description>
              <bitRange>[05:05]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>T30BTIEN</name>
              <description>Timer 30 Bottom Interrupt Enable bit</description>
              <bitRange>[04:04]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>T30PMIEN</name>
              <description>Timer 30 Period Match Interrupt Enable bit</description>
              <bitRange>[03:03]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>T30AMIEN</name>
              <description>Timer 30 A-ch Match Interrupt Enable bit</description>
              <bitRange>[02:02]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>T30BMIEN</name>
              <description>Timer 30 B-ch Match Interrupt Enable bit</description>
              <bitRange>[01:01]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>T30CMIEN</name>
              <description>Timer 30 C-ch Match Interrupt Enable bit</description>
              <bitRange>[00:00]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <!--INTFLAG : Timer/Counter 30 Interrupt Flag Register-->
        <register>
          <name>INTFLAG</name>
          <description>Timer/Counter 30 Interrupt Flag Register</description>
          <addressOffset>0x2c</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000007f</resetMask>
          <fields>
            <field>
              <name>HIZIFLAG</name>
              <description>Timer 30 Output High-Impedance Interrupt Flag bit</description>
              <bitRange>[06:06]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>T30CIFLAG</name>
              <description>Timer 30 Capture Interrupt Flag bit</description>
              <bitRange>[05:05]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>T30BTIFLAG</name>
              <description>Timer 30 Bottom Interrupt Flag bit</description>
              <bitRange>[04:04]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>T30PMIFLAG</name>
              <description>Timer 30 Period Match Interrupt Flag bit</description>
              <bitRange>[03:03]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>T30AMIFLAG</name>
              <description>Timer 30 A-ch Match Interrupt Flag bit</description>
              <bitRange>[02:02]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>T30BMIFLAG</name>
              <description>Timer 30 B-ch Match Interrupt Flag bit</description>
              <bitRange>[01:01]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>T30CMIFLAG</name>
              <description>Timer 30 C-ch Match Interrupt Flag bit</description>
              <bitRange>[00:00]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <!--HIZCR : Timer/Counter 30 High-Impedance Control Register-->
        <register>
          <name>HIZCR</name>
          <description>Timer/Counter 30 High-Impedance Control Register</description>
          <addressOffset>0x30</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000097</resetMask>
          <fields>
            <field>
              <name>HIZEN</name>
              <description>PWM30xA/PWM30xB Output High-Impedance Enable bit</description>
              <bitRange>[07:07]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HIZSW</name>
              <description>High-Impedance Output Software Setting</description>
              <bitRange>[04:04]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HEDGE</name>
              <description>High-Impedance Edge Selection</description>
              <bitRange>[02:02]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HIZSTA</name>
              <description>High-Impedance Status</description>
              <bitRange>[01:01]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>HIZCLR</name>
              <description>High-Impedance Output Clear bit</description>
              <bitRange>[00:00]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <!--ADTCR : Timer/Counter 30 A/DC Trigger Control Register-->
        <register>
          <name>ADTCR</name>
          <description>Timer/Counter 30 A/DC Trigger Control Register</description>
          <addressOffset>0x34</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000001f</resetMask>
          <fields>
            <field>
              <name>T30BTTG</name>
              <description>Select Timer 30 Bottom for A/DC Trigger Signal Generator</description>
              <bitRange>[04:04]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>T30PMTG</name>
              <description>Select Timer 30 Period Match for A/DC Trigger Signal Generator</description>
              <bitRange>[03:03]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>T30AMTG</name>
              <description>Select Timer 30 A-ch Match for A/DC Trigger Signal Generator</description>
              <bitRange>[02:02]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>T30BMTG</name>
              <description>Select Timer 30 B-ch Match for A/DC Trigger Signal Generator</description>
              <bitRange>[01:01]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>T30CMTG</name>
              <description>Select Timer 30 C-ch Match for A/DC Trigger Signal Generator</description>
              <bitRange>[00:00]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <!--ADTDR : Timer/Counter 30 A/DC Trigger Generator Data Register-->
        <register>
          <name>ADTDR</name>
          <description>Timer/Counter 30 A/DC Trigger Generator Data Register</description>
          <addressOffset>0x38</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00003fff</resetMask>
          <fields>
            <field>
              <name>ADTDATA</name>
              <description>Timer/Counter 30 A/DC Trigger Generation Data bits.</description>
              <bitRange>[13:00]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <!--USART10-->
    <peripheral>
      <name>USART10</name>
      <version>1.0</version>
      <description>USART 10 (UART + SPI)</description>
      <groupName>USART</groupName>
      <baseAddress>0x40003800</baseAddress>
      <size>32</size>
      <access>read-write</access>
      <addressBlock>
        <offset>0</offset>
        <size>0x100</size>
        <usage>registers</usage>
      </addressBlock>
      <interrupt>
        <name>USART10</name>
        <value>11</value>
      </interrupt>
      <registers>
        <!--CR1 : Timer/Counter 30 A/DC Trigger Generator Data Register-->
        <register>
          <name>CR1</name>
          <description>USARTn Control Register 1</description>
          <addressOffset>0x00</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000ffff</resetMask>
          <fields>
            <field>
              <name>USTnMS</name>
              <description>USARTn Operation Mode Selection bits</description>
              <bitRange>[15:14]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>ASYNC</name>
                  <description>Asynchronous Mode (UART)</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SYNC</name>
                  <description>Synchronous Mode</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SPI</name>
                  <description>SPI mode</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>USTnP</name>
              <description>Selects Parity Generation and Check method (only UART mode)</description>
              <bitRange>[13:12]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_PARITY</name>
                  <description>No parity</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>EVEN</name>
                  <description>Even parity</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ODD</name>
                  <description>Odd parity</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>USTnS</name>
              <description>Selects the length of data bit in a frame when Asynchronous or Synchronous mode</description>
              <bitRange>[11:09]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>5BIT</name>
                  <description>5 bit</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>6BIT</name>
                  <description>6 bit</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>7BIT</name>
                  <description>7 bit</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>8BIT</name>
                  <description>8 bit</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>9BIT</name>
                  <description>9 bit</description>
                  <value>7</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ORDn</name>
              <description>Selects the first data bit to be transmitted (only SPI mode)</description>
              <bitRange>[08:08]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>LSB_FIRST</name>
                  <description>LSB-first</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>MSB_FIRST</name>
                  <description>MSB-first</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CPOLn</name>
              <description>Selects the clock polarity of ACK in synchronous or SPI mode</description>
              <bitRange>[07:07]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>CHANGE_AT_FALLING_EDGE</name>
                  <description>TXD Change @Rising Edge, RXD Change @Falling Edge</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CHANGE_AT_RISING_EDGE</name>
                  <description>TXD Change @Falling Edge, RXD Change @Rising Edge</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CPHAn</name>
              <description>(null)The CPOLn and this bit determine if data are sampled on the leading or trailing edge of SCK (only SPI mode)</description>
              <bitRange>[06:06]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SPL_STP</name>
                  <description>Sample / Setup</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>STP_SPL</name>
                  <description>Setup / Sample</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DRIEn</name>
              <description>Transmit Data Register Empty Interrupt Enable bit</description>
              <bitRange>[05:05]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TXCIEn</name>
              <description>Transmit Complete Interrupt Enable bit</description>
              <bitRange>[04:04]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RXCIEn</name>
              <description>Receive Complete Interrupt Enable bit</description>
              <bitRange>[03:03]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>WAKEIEn</name>
              <description>Asynchronous Wake-up Interrupt Enable bit in Deep Sleep Mode. When device is in deep sleep mode, if RXD goes to low level, an interrupt can be requested to wake-up system (only UART mode)</description>
              <bitRange>[02:02]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TXEn</name>
              <description>Enables the Transmitter unit</description>
              <bitRange>[01:01]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RXEn</name>
              <description>Enables the Receiver unit</description>
              <bitRange>[00:00]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <!--CR2 : Timer/Counter 30 A/DC Trigger Generator Data Register-->
        <register>
          <name>CR2</name>
          <description>USARTn Control Register 2</description>
          <addressOffset>0x04</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000003ff</resetMask>
          <fields>
            <field>
              <name>USTnEN</name>
              <description>(nActivate USARTn Block by supplyingull)</description>
              <bitRange>[09:09]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DBLSn</name>
              <description>Selects receiver sampling rate (only UART mode)</description>
              <bitRange>[08:08]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MASTERn</name>
              <description>Selects master or slave in SPI or Synchronous mode and controls the direction of SCK pin</description>
              <bitRange>[07:07]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LOOPSn</name>
              <description>Control the Loop Back mode of USARTn for test mode</description>
              <bitRange>[06:06]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DISSCKn</name>
              <description>In synchronous mode operation, selects the waveform of SCK output</description>
              <bitRange>[05:05]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>USTnSSEN</name>
              <description>This bit controls the SS pin operation (only SPI mode)</description>
              <bitRange>[04:04]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FXCHn</name>
              <description>SPI port function exchange control bit (only SPI mode)</description>
              <bitRange>[03:03]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>USTnSB</name>
              <description>Selects the length of stop bit in Asynchronous or Synchronous mode</description>
              <bitRange>[02:02]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>USTnTX8</name>
              <description>The ninth bit of data frame in Asynchronous or Synchronous mode of operation. Write this bit first before loading the USTnDR register</description>
              <bitRange>[01:01]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>USTnRX8</name>
              <description>The ninth bit of data frame in Asynchronous or Synchronous mode of operation. Read this bit first before reading the receive buffer (only UART mode)</description>
              <bitRange>[00:00]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <!--ST : USARTn Status Register-->
        <register>
          <name>ST</name>
          <description>USARTn Status Register</description>
          <addressOffset>0x0c</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000080</resetValue>
          <resetMask>0x000000f7</resetMask>
          <fields>
            <field>
              <name>DREn</name>
              <description>Transmit Data Register Empty Interrupt Flag</description>
              <bitRange>[07:07]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TXCn</name>
              <description>Transmit Complete Interrupt Flag</description>
              <bitRange>[06:06]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RXCn</name>
              <description>Receive Complete Interrupt Flag</description>
              <bitRange>[05:05]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>WAKEn</name>
              <description>Asynchronous Wake-up Interrupt Flag</description>
              <bitRange>[04:04]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DORn</name>
              <description>This bit is set if data OverRun occurs</description>
              <bitRange>[02:02]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>FEn</name>
              <description>This bit is set if the first stop bit of next character in the receive buffer is detected as '0'. This bit is valid until the receive buffer is read (only UART mode)</description>
              <bitRange>[01:01]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PEn</name>
              <description>This bit is set if the next character in the receive buffer has a Parity Error while parity is checked. This bit is valid until the receive buffer is read (only UART mode)</description>
              <bitRange>[00:00]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <!--BDR : USARTn Baud Rate Generation Register-->
        <register>
          <name>BDR</name>
          <description>USARTn Baud Rate Generation Register</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000FFF</resetValue>
          <resetMask>0x00000fff</resetMask>
          <fields>
            <field>
              <name>BDATA</name>
              <description>The value in this register is used to generate internal baud rate in UART mode or to generate SCK clock in SPI mode. To prevent malfunction, do not write '0' in UART mode and do not write '0' or '1' in synchronous or SPI mode.</description>
              <bitRange>[11:00]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <!--DR : USARTn Data Register-->
        <register>
          <name>DR</name>
          <description>USARTn Data Register</description>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000000ff</resetMask>
          <fields>
            <field>
              <name>DATA</name>
              <description>The USART Transmit buffer and Receive buffer share the same I/O address with this DATA register. The Transmit Data Buffer is the destination for data written to the USTnDR register. Reading the USTnDR register returns the contents of the Receive Buffer. Write to this register only when the DRE flag is set. In SPI master mode, the SCK clock is generated when data are written to this register.</description>
              <bitRange>[07:00]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <!--USART11-->
    <peripheral derivedFrom="USART10">
      <name>USART11</name>
      <baseAddress>0x40003900</baseAddress>
      <interrupt>
        <name>USART11</name>
        <value>17</value>
      </interrupt>
    </peripheral>
    <!--USART12-->
    <peripheral derivedFrom="USART10">
      <name>USART12</name>
      <baseAddress>0x40003a00</baseAddress>
      <interrupt>
        <name>USART12_13</name>
        <value>26</value>
      </interrupt>
    </peripheral>
    <!--USART13-->
    <peripheral derivedFrom="USART10">
      <name>USART13</name>
      <baseAddress>0x40003b00</baseAddress>
    </peripheral>
    <!-- UART0-->
    <peripheral>
      <name>UART0</name>
      <version>1.0</version>
      <description>UNIVERSAL ASYNCHRONOUS RECEIVER/TRANSMITTER</description>
      <groupName>UART</groupName>
      <baseAddress>0x40004000</baseAddress>
      <size>32</size>
      <access>read-write</access>
      <addressBlock>
        <offset>0</offset>
        <size>0x100</size>
        <usage>registers</usage>
      </addressBlock>
      <interrupt>
        <name>UART0</name>
        <value>19</value>
      </interrupt>
      <registers>
        <!-- RBR: Receive Buffer Register -->
        <register>
          <name>RBR</name>
          <description>Receive Buffer Register</description>
          <addressOffset>0x00</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>RBR</name>
              <description>recevied/transmit data</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <!-- THR: Transmit Data Hold Register -->
        <register>
          <name>THR</name>
          <description>Transmit Data Hold Register</description>
          <addressOffset>0x00</addressOffset>
          <size>32</size>
          <access>write-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>THR</name>
              <description>recevied/transmit data</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <!-- IER: UART Interrupt Enable Register -->
        <register>
          <name>IER</name>
          <description>UART Interrupt Enable Register</description>
          <addressOffset>0x04</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>DTXIEN</name>
              <description>DMA transmit done interrupt enable</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DRXIEN</name>
              <description>DMA Receiver line status interrupt enable</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RLSIE</name>
              <description>receiver line status interrupt enable</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>THREIE</name>
              <description>Transmit holding register empty interrupt enable</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DRIE</name>
              <description>Data receive interrupt enable</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <!-- IIR: UART Interrupt ID Register -->
        <register>
          <name>IIR</name>
          <description>UART Interrupt ID Register</description>
          <addressOffset>0x08</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>TXE</name>
              <description>Interrupt source ID</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IID</name>
              <description>Interrupt source ID</description>
              <bitOffset>1</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>IPEN</name>
              <description>Interrupt pending bit</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <!-- LCR: UART Line Control Register -->
        <register>
          <name>LCR</name>
          <description>UART Line Control Register</description>
          <addressOffset>0x0C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>BREAK</name>
              <description>BREAK</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>STICKP</name>
              <description>STICK</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PARITY</name>
              <description>PARITY</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PEN</name>
              <description>parity bit transfer enable</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>STOPBIT</name>
              <description>STOPBIT</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DLEN</name>
              <description>Data length in one transfer word</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
          </fields>
        </register>
        <!-- DCR: UART Data Control Register -->
        <register>
          <name>DCR</name>
          <description>UART Data Control Register</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>LBON</name>
              <description>Local loopback test mode enable</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RXINV</name>
              <description>Rx Data Inversion selection</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TXINV</name>
              <description>TX Data Inversion selection</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <!-- LSR: UART Line Status Register -->
        <register>
          <name>LSR</name>
          <description>UART Line Status Register</description>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000060</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>TEMT</name>
              <description>Transmit empty</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>THRE</name>
              <description>Transmit holding register empty</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BI</name>
              <description>break condition indication bit</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FE</name>
              <description>frame error</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>parity error</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OE</name>
              <description>overrun error</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DR</name>
              <description>Data recevied</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <!-- BDR: Baud rate Divisor Latch Register -->
        <register>
          <name>BDR</name>
          <description>Baud rate Divisor Latch Register</description>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>BDR</name>
              <description>baudrate setting</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <!-- BFR: Baud rate Fraction Counter Register -->
        <register>
          <name>BFR</name>
          <description>Baud rate Fraction Counter Register</description>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>BFR</name>
              <description>Fraction counter value</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <!-- IDTR: Inter-frame Delay Time Register -->
        <register>
          <name>IDTR</name>
          <description>Inter-frame Delay Time Register</description>
          <addressOffset>0x30</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>WAITVAL</name>
              <description>wait time is decied by this value</description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <!-- UART1-->
    <peripheral derivedFrom="UART0">
      <name>UART1</name>
      <baseAddress>0x40004100</baseAddress>
      <interrupt>
        <name>UART1</name>
        <value>20</value>
      </interrupt>
    </peripheral>
    <!--I2C0-->
    <peripheral>
      <name>I2C0</name>
      <version>1.0</version>
      <description>I2C 0</description>
      <groupName>I2C</groupName>
      <baseAddress>0x40004800</baseAddress>
      <size>32</size>
      <access>read-write</access>
      <addressBlock>
        <offset>0</offset>
        <size>0x100</size>
        <usage>registers</usage>
      </addressBlock>
      <interrupt>
        <name>I2C0</name>
        <value>10</value>
      </interrupt>
      <registers>
        <!--CR : I2Cn Control Register-->
        <register>
          <name>CR</name>
          <description>I2Cn Control Register</description>
          <addressOffset>0x00</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000000ff</resetMask>
          <fields>
            <field>
              <name>I2CnEN</name>
              <description>Activate I2Cn Block by supplying</description>
              <bitRange>[07:07]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TXDLYENBn</name>
              <description>I2CnSDHR Register Control bit</description>
              <bitRange>[06:06]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2CnIEN</name>
              <description>I2Cn Interrupt Enable bit</description>
              <bitRange>[05:05]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2CnIFLAG</name>
              <description>I2Cn Interrupt Flag bit. This bit is cleared when write any values in the I2CnST register.</description>
              <bitRange>[04:04]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ACKnEN</name>
              <description>Controls ACK signal generation at ninth SCL period. Notes) ACK signal is output (SDA = 0) for the following 3 cases. Where x = 0 and 1. 1. When received address packet equals to SLAx[6:0] bits in I2CnSARx register. 2. When received address packet equals to value 0x00 with GCALLn enabled. 3. When I2Cn operates as a receiver (master or slave)</description>
              <bitRange>[03:03]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>IMASTERn</name>
              <description>Represent Operation Mode of I2Cn</description>
              <bitRange>[02:02]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>STOPCn</name>
              <description>STOP Condition Generation When I2Cn is master.</description>
              <bitRange>[01:01]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STARTCn</name>
              <description>START Condition Generation When I2Cn is master.</description>
              <bitRange>[00:00]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <!--ST : I2Cn Status Register-->
        <register>
          <name>ST</name>
          <description>I2Cn Status Register</description>
          <addressOffset>0x04</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000000ff</resetMask>
          <fields>
            <field>
              <name>GCALLn</name>
              <description>This bit has different meaning depending on whether I2C is master or slave. When I2C is a master, this bit represents whether it received AACK (address ACK) from slave.</description>
              <bitRange>[07:07]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TENDn</name>
              <description>This bit is set when 1-byte of data is transferred completely.</description>
              <bitRange>[06:06]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STOPDn</name>
              <description>This bit is set when a STOP condition is detected.</description>
              <bitRange>[05:05]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SSELn</name>
              <description>This bit is set when I2C is addressed by other master.</description>
              <bitRange>[04:04]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MLOSTn</name>
              <description>This bit represents the result of bus arbitration in master mode.</description>
              <bitRange>[03:03]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BUSYn</name>
              <description>This bit reflects bus status.</description>
              <bitRange>[02:02]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TMODEn</name>
              <description>This bit is used to indicate whether I2C is transmitter or receiver.</description>
              <bitRange>[01:01]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>RXACKn</name>
              <description>This bit shows the state of ACK signal.</description>
              <bitRange>[00:00]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <!--SAR1 : I2Cn Slave Address Register 1-->
        <register>
          <name>SAR1</name>
          <description>I2Cn Slave Address Register 1</description>
          <addressOffset>0x08</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000000ff</resetMask>
          <fields>
            <field>
              <name>SLAn</name>
              <description>These bits configure the slave address 0 in slave mode.</description>
              <bitRange>[07:01]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GCALLnEN</name>
              <description>This bit decides whether I2Cn allows general call address 0 or not in I2Cn slave mode.</description>
              <bitRange>[00:00]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <!--SAR2 : I2Cn Slave Address Register 2-->
        <register>
          <name>SAR2</name>
          <description>I2Cn Slave Address Register 2</description>
          <addressOffset>0x0c</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000000ff</resetMask>
          <fields>
            <field>
              <name>SLAn</name>
              <description>These bits configure the slave address 1 in slave mode.</description>
              <bitRange>[07:01]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GCALLnEN</name>
              <description>This bit decides whether I2Cn allows general call address 1 or not in I2Cn slave mode.</description>
              <bitRange>[00:00]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <!--DR : I2Cn Data Register-->
        <register>
          <name>DR</name>
          <description>I2Cn Data Register</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000000ff</resetMask>
          <fields>
            <field>
              <name>DATA</name>
              <description>The I2CnDR Transmit buffer and Receive buffer share the same I/O address with this DATA register. The Transmit Data Buffer is the destination for data written to the I2CnDR register. Reading the I2CnDR register returns the contents of the Receive Buffer.</description>
              <bitRange>[07:00]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <!--SDHR : I2Cn SDA Hold Time Register-->
        <register>
          <name>SDHR</name>
          <description>I2Cn SDA Hold Time Register</description>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000001</resetValue>
          <resetMask>0x00000fff</resetMask>
          <fields>
            <field>
              <name>HLDT</name>
              <description>This register is used to control SDA output timing from the falling edge of SCL. Note that SDA is changed after tPCLK X (I2CnSDHR+2). In master mode, load half the value of I2CnSCLR to this register to make SDA change in the middle of SCL. In slave mode, configure this register regarding the frequency of SCL from master. The SDA is changed after tPCLK X (I2CnSDHR+2) in master mode. So, to insure operation in slave mode, the value tPCLK X (I2CnSDHR + 2) must be smaller than the period of SCL.</description>
              <bitRange>[11:00]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <!--SCLR : I2Cn SCL Low Period Register-->
        <register>
          <name>SCLR</name>
          <description>I2Cn SCL Low Period Register</description>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0000003f</resetValue>
          <resetMask>0x00000fff</resetMask>
          <fields>
            <field>
              <name>SCLL</name>
              <description>This register defines the low period of SCL in master mode. The base clock is PCLK and the period is calculated by the formula: tPCLK X (4 X I2CnSCLR + 2) where tPCLK is the period of PCLK.</description>
              <bitRange>[11:00]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <!--SCHR : I2Cn SCL High Period Register-->
        <register>
          <name>SCHR</name>
          <description>I2Cn SCL High Period Register</description>
          <addressOffset>0x1c</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0000003f</resetValue>
          <resetMask>0x00000fff</resetMask>
          <fields>
            <field>
              <name>SCLH</name>
              <description>This register defines the high period of SCL in master mode. The base clock is PCLK and the period is calculated by the formula: tPCLK X (4 X I2CnSCHR + 2) where tPCLK is the period of PCLK.</description>
              <bitRange>[11:00]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <!--I2C1-->
    <peripheral derivedFrom="I2C0">
      <name>I2C1</name>
      <baseAddress>0x40004900</baseAddress>
      <interrupt>
        <name>I2C1</name>
        <value>14</value>
      </interrupt>
    </peripheral>
    <!--I2C2-->
    <peripheral derivedFrom="I2C0">
      <name>I2C2</name>
      <baseAddress>0x40004A00</baseAddress>
      <interrupt>
        <name>I2C2</name>
        <value>25</value>
      </interrupt>
    </peripheral>
    <!--ADC-->
    <peripheral>
      <name>ADC</name>
      <version>1.0</version>
      <description>12-BIT A/D CONVERTER</description>
      <groupName>ADC</groupName>
      <baseAddress>0x40003000</baseAddress>
      <size>32</size>
      <access>read-write</access>
      <addressBlock>
        <offset>0</offset>
        <size>0x010</size>
        <usage>registers</usage>
      </addressBlock>
      <interrupt>
        <name>ADC</name>
        <value>18</value>
      </interrupt>
      <registers>
        <!--CR : A/D Converter Control Register-->
        <register>
          <name>CR</name>
          <description>A/D Converter Control Register</description>
          <addressOffset>0x00</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000bd3f</resetMask>
          <fields>
            <field>
              <name>ADCEN</name>
              <description>A/DC Module Enable bit (The A/DC is automatically disabled at power down mode)</description>
              <bitRange>[15:15]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DISABLE_ADC</name>
                  <description>Disable A/DC module operation</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENABLE_ADC</name>
                  <description>Enable A/DC module operation</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TRIG</name>
              <description>A/DC Trigger Signal Selection bits</description>
              <bitRange>[13:11]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>ADST</name>
                  <description>ADST</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>T10_A_MATCH</name>
                  <description>Timer 10 A-match signal</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>T11_A_MATCH</name>
                  <description>Timer 11 A-match signal</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>T12_A_MATCH</name>
                  <description>Timer 12 A-match signal</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>T30_SIGNAL</name>
                  <description>A/DC trigger signal from timer 30</description>
                  <value>4</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>REFSEL</name>
              <description>A/DC Reference Selection bit</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>VDD</name>
                  <description>Select analog power (VDD)</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AVREF</name>
                  <description>Select external reference (AVREF)</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ADST</name>
              <description>A/DC Conversion Start bit. This bit is automatically cleared to "0b" after operation</description>
              <bitRange>[08:08]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NONE</name>
                  <description>No effect</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>START_AD_CONVERSION</name>
                  <description>Trigger signal generation for conversion start</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ADCIEN</name>
              <description>A/DC Interrupt Enable bit</description>
              <bitRange>[05:05]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DISABLE_ADC_INT</name>
                  <description>Disable A/DC interrupt</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENABLE_ADC_INT</name>
                  <description>Enable A/DC interrupt</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ADCIFLAG</name>
              <description>A/DC Interrupt Flag bit</description>
              <bitRange>[04:04]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>ADC_IF_CLR</name>
                  <description>No request occurred</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ADC_IF_SET</name>
                  <description>Request occurred, This bit is cleared to '0' when write '1'.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ADSEL</name>
              <description>A/D Converter Channel Selection bits</description>
              <bitRange>[03:00]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>AN0</name>
                  <description>AN0</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AN1</name>
                  <description>AN1</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AN2</name>
                  <description>AN2</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AN3</name>
                  <description>AN3</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AN4</name>
                  <description>AN4</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AN5</name>
                  <description>AN5</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AN6</name>
                  <description>AN6</description>
                  <value>6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AN7</name>
                  <description>AN7</description>
                  <value>7</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AN8</name>
                  <description>AN8</description>
                  <value>8</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AN9</name>
                  <description>AN9</description>
                  <value>9</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AN10</name>
                  <description>AN10</description>
                  <value>10</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VDD18</name>
                  <description>VDD15</description>
                  <value>15</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <!--DR : A/D Converter Data Register-->
        <register>
          <name>DR</name>
          <description>A/D Converter Data Register</description>
          <addressOffset>0x04</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetMask>0x00000fff</resetMask>
          <fields>
            <field>
              <name>ADDATA</name>
              <description>A/D Converter Result Data bits</description>
              <bitRange>[11:00]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <!--PREDR : A/D Converter Prescaler Data Register-->
        <register>
          <name>PREDR</name>
          <description>A/D Converter Prescaler Data Register</description>
          <addressOffset>0x08</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0000000f</resetValue>
          <resetMask>0x0000001f</resetMask>
          <fields>
            <field>
              <name>PRED</name>
              <description>A/D Converter Prescaler Data bits.</description>
              <bitRange>[04:00]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <!--DAC-->
    <peripheral>
      <name>DAC</name>
      <version>1.0</version>
      <description>12-BIT D/A CONVERTER</description>
      <groupName>DAC</groupName>
      <baseAddress>0x40003450</baseAddress>
      <size>32</size>
      <access>read-write</access>
      <addressBlock>
        <offset>0x00</offset>
        <size>0x24</size>
        <usage>registers</usage>
      </addressBlock>
      <interrupt>
        <name>ADPCM_DAC</name>
        <value>27</value>
      </interrupt>
      <registers>
        <!--DR : D/A Converter Data Register-->
        <register>
          <name>DR</name>
          <description>D/A Converter Data Register</description>
          <addressOffset>0x00</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>DACDR</name>
              <description>D/A Converter Data (16-bit)
The DACDR[15:0] is a binary format.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <!--BR : D/A Converter Buffer Register-->
        <register>
          <name>BR</name>
          <description>D/A Converter Buffer Register</description>
          <addressOffset>0x04</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>DACBR</name>
              <description>D/A Converter Buffer Data (16-bit)
The DACBR[15:0] is a binary format.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <!--CR : D/A Converter Control Register-->
        <register>
          <name>CR</name>
          <description>D/A Converter Control Register</description>
          <addressOffset>0x08</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>REFSEL</name>
              <description>DAC Reference Selection
0:AVDD, 1: DAVREF Pin</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DACIE</name>
              <description>Enable or Disable D/AC Interrupt</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DACIFR</name>
              <description>When D/AC Interrupt occurs, this bit becomes '1'. The flag is cleared only by writing a '0' to the bit. So, the flag should be cleared by software. This interrupt is for a result that the DACDRH register automatically increments to "800xH" or decrements to "000xH".
Write '1' has no effect.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ADATID</name>
              <description>Automatically D/A Converter Data Increment/Decrement</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DACBC</name>
              <description>D/A Converter Buffer Clear</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FADFEN</name>
              <description>Decoder Result Output Data Fetch Enable</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DACRLDS</name>
              <description>D/A Converter Reload Selection. These bits select a reload signal to load data from D/AC data register to buffer.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DACEN</name>
              <description>D/A Converter Enable Bit</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <!--PGSR : Programmable Gain Control Register-->
        <register>
          <name>PGSR</name>
          <description>Programmable Gain Control Register</description>
          <addressOffset>0x0c</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>PSG</name>
              <description>Programmable Gain Selection</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <!--OFSCR : D/A Converter Offset Control Register-->
        <register>
          <name>OFSCR</name>
          <description>D/A Converter Offset Control Register</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>OFSEN</name>
              <description>D/AC Offset Control Enable Bit</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OFSDIR</name>
              <description>D/AC Offset Direction Selection Bit</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OFS</name>
              <description>D/AC Offset Value</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <!--ADPCM-->
    <peripheral>
      <name>ADPCM</name>
      <version>1.0</version>
      <description>ADPCM</description>
      <groupName>ADPCM</groupName>
      <baseAddress>0x40004700</baseAddress>
      <size>32</size>
      <access>read-write</access>
      <addressBlock>
        <offset>0</offset>
        <size>0x05c</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <!--DECCR: ADPCM Decoder Control Register-->
        <register>
          <name>DECCR</name>
          <description>A/D ADPCM Decoder Control Register</description>
          <addressOffset>0x00</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <fields>
            <field>
              <name>SPIEN</name>
              <description>ADPCM Interrupt Enable</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DFEIE</name>
              <description>Decoder FIFO Empty Interrupt Enable</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DMIE</name>
              <description>Decoder Match Interrupt Enable</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DFFF</name>
              <description>Decoder FIFO Full Flag</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DECEN</name>
              <description>Decoder Block Enable</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DIVS</name>
              <description>Decoder Initial Value Setting</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DCEN</name>
              <description>Decoder Counting Enable</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DCLKS</name>
              <description>Decoder Clock Select (fx/(2^(DCLKS+1)))</description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <!--DFIFOR: ADPCM Decoder FIFO Register-->
        <register>
          <name>DFIFOR</name>
          <description>ADPCM Decoder FIFO Register</description>
          <addressOffset>0x04</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <fields>
            <field>
              <name>DFIFOR</name>
              <description>Decoder FIFO Data. The data goes to the decoder FIFO (8-bytes length) if data are written in this register.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <!--DECDR: ADPCM Decoder Sampling Frequency Data Register-->
        <register>
          <name>DECDR</name>
          <description>ADPCM Decoder Sampling Frequency Data Register</description>
          <addressOffset>0x08</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <fields>
            <field>
              <name>DECDR</name>
              <description>Decoder Sampling Frequency Set Register. The sampling time (ts) is 1/(sampling frequency). The voice data get out every ts and interpolation data get out between every the voice data.
ex) data1, (data1+data2)/2, data2, (data2+data3)/2, -----.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <!--DBDLR: ADPCM Decoder Bundle Register-->
        <register>
          <name>DBDLR</name>
          <description>ADPCM Decoder Bundle Register</description>
          <addressOffset>0x0c</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <fields>
            <field>
              <name>DBDLR</name>
              <description>Decoder Bundle Size. This value should be greater than 6. If this value is "00", the bundle size is 256-bytes. This value should be same with encoder's bundle size</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <!--DODRL: ADPCM Decoder Result Output Low Register-->
        <register>
          <name>DODRL</name>
          <description>ADPCM Decoder Result Output Low Register</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <fields>
            <field>
              <name>DODRL</name>
              <description>Decoder Result Output Data Low Byte.
The DODR[15:0] is a binary format.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <!--DODRH: ADPCM Decoder Result Output High Register-->
        <register>
          <name>DODRH</name>
          <description>ADPCM Decoder Result Output High Register</description>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <fields>
            <field>
              <name>DODRH</name>
              <description>Decoder Result Output Data High Byte</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <!--FAFLAG: ADPCM Interrupt Flag Register-->
        <register>
          <name>FAFLAG</name>
          <description>ADPCM Interrupt Flag Register</description>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <fields>
            <field>
              <name>SFSTOP</name>
              <description>Stop the Serial Flash Interface for reading voice data</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>VPEDIFR</name>
              <description>When voice prompt end interrupt occurs, this bit becomes '1'. The flag is cleared only by writing a '0' to the bit. So, the flag should be cleared by software. Write '1' has no effect.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>VPTBLIFR</name>
              <description>When voice prompt table data receive end interrupt occurs, this bit becomes '1'. The flag is cleared only by writing a '0' to the bit. So, the flag should be cleared by software. Write '1' has no effect.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DFEIFR</name>
              <description>When FADPCM decoder FIFO empty interrupt occurs, this bit becomes '1'. The flag is cleared only by writing a '0' to the bit. So, the flag should be cleared by software. Write '1' has no effect.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DMIFR</name>
              <description>When FADPCM decoder match interrupt occurs, this bit becomes '1'. The flag is cleared only by writing a '0' to the bit. So, the flag should be cleared by software. Write '1' has no effect.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <!--VPCR: Voice Prompt Control Register-->
        <register>
          <name>VPCR</name>
          <description>Voice Prompt Control Register</description>
          <addressOffset>0x1c</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <fields>
            <field>
              <name>VPEDIE</name>
              <description>Voice Prompt End Interrupt Enable</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>VPTBLIE</name>
              <description>Voice Prompt Table Data Receive End Interrupt Enable</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SFRDST</name>
              <description>Serial Flash Data Read Start Signal</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SPICSS</name>
              <description>Enable SPI interface for serial flash</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>VPSDEC</name>
              <description>Voice Prompt Size Register Decrement Enable</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DTRS</name>
              <description>Enable Data Transfer from SPI</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ATRIGS</name>
              <description>Automatically Read Trigger Selection for SPI</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <!--SFDDNO: Serial Flash Dummy and Data Number-->
        <register>
          <name>SFDDNO</name>
          <description>Serial Flash Dummy and Data Number</description>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>DUMY</name>
              <description>The number of dummy for serial flash interface. The number of dummy is (n). Where n = 0, 1, 2, ----- and 15.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RDNO</name>
              <description>The number of data to read from a serial flash. The number of data to read is (n+1). Where n = 0, 1, 2, ----- and 7.
Ex) If n = 7, the voice prompt table data are 8-bytes to read from a serial flash.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <!--SFCMD: Serial Flash Command Register-->
        <register>
          <name>SFCMD</name>
          <description>Serial Flash Command Register</description>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>SFCMD</name>
              <description>Serial Flash Command Data.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <!--VPADDR1: Voice Prompt Address Register 1-->
        <register>
          <name>VPADDR1</name>
          <description>Voice Prompt Address Register 1</description>
          <addressOffset>0x28</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>VPAR</name>
              <description>Voice Prompt Address MSB-byte.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <!--VPADDR2: Voice Prompt Address Register 2-->
        <register>
          <name>VPADDR2</name>
          <description>Voice Prompt Address Register 2</description>
          <addressOffset>0x2c</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>VPAR</name>
              <description>Voice Prompt Address Mid-byte.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <!--VPADDR3: Voice Prompt Address Register 3-->
        <register>
          <name>VPADDR3</name>
          <description>Voice Prompt Address Register 3</description>
          <addressOffset>0x30</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>VPAR</name>
              <description>Voice Prompt Address LSB-byte.
The VPADDR[23:0] is the start address of a voice prompt or voice prompt table in a serial flash and can access up to 16M-bytes.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <!--VPSIZE1: Voice Prompt Size Register 1-->
        <register>
          <name>VPSIZE1</name>
          <description>Voice Prompt Size Register 1</description>
          <addressOffset>0x34</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>VPSZ</name>
              <description>Voice Prompt Size MSB-byte.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <!--VPSIZE2: Voice Prompt Size Register 2-->
        <register>
          <name>VPSIZE2</name>
          <description>Voice Prompt Size Register 2</description>
          <addressOffset>0x38</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>VPSZ</name>
              <description>Voice Prompt Size Mid-byte.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <!--VPSIZE3: Voice Prompt Size Register 3-->
        <register>
          <name>VPSIZE3</name>
          <description>Voice Prompt Size Register 3</description>
          <addressOffset>0x3c</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>VPSZ</name>
              <description>Voice Prompt Size LSB-byte.
The VPSIZE[23:0] is the size of a voice prompt to play continuously in a serial flash.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <!--VPINF1: Voice Prompt Inform Register 1-->
        <register>
          <name>VPINF1</name>
          <description>Voice Prompt Inform Register 1</description>
          <addressOffset>0x40</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>VPINF</name>
              <description>Voice Prompt Inform High-byte.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <!--VPINF2: Voice Prompt Inform Register 2-->
        <register>
          <name>VPINF2</name>
          <description>Voice Prompt Inform Register 2</description>
          <addressOffset>0x44</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>VPINF</name>
              <description>Voice Prompt Inform Low-byte.
The VPINF[15:0] is the voice prompt information.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <!--SPICR: SPI Control Register-->
        <register>
          <name>SPICR</name>
          <description>SPI Control Register</description>
          <addressOffset>0x50</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>SPIEN</name>
              <description>This bit controls the SPI operation</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FLSB</name>
              <description>This bit selects the data transmission sequence</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SPIMS</name>
              <description>This bit selects whether Master or Slave mode</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CPOL</name>
              <description>This two bits control the serial clock (SCK) mode. 
Clock polarity (CPOL) bit determine SCK's value at idle mode.
Clock phase (CPHA) bit determine if data are sampled on the leading or trailing edge of SCK.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CPHA</name>
              <description>This two bits control the serial clock (SCK) mode. 
Clock polarity (CPOL) bit determine SCK's value at idle mode.
Clock phase (CPHA) bit determine if data are sampled on the leading or trailing edge of SCK.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SPIDSCR</name>
              <description>These three bits select the SCK3 rate of the device configured as a master. When DSCR bit is written one, SCK3 will be doubled in master mode.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SPISCR</name>
              <description>These three bits select the SCK3 rate of the device configured as a master. When DSCR bit is written one, SCK3 will be doubled in master mode.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <!--SPIDR: SPI Data Register-->
        <register>
          <name>SPIDR</name>
          <description>SPI Data Register</description>
          <addressOffset>0x54</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>SPIDR</name>
              <description>SPI Data
hen it is written a byte to this data register, the SPI 3 will start an operation.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <!--SPISR: SPI Status Register-->
        <register>
          <name>SPISR</name>
          <description>SPI Status Register</description>
          <addressOffset>0x58</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>SPIIFR</name>
              <description>When SPI Interrupt occurs, this bit becomes '1'. IF SPI interrupt is enable, this bit is auto cleared by INT_ACK signal. And if SPI Interrupt is disable, this bit is cleared when the status register SPISR is read and then access (read/write) the data register SPIDR. Write '1' has no effect.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>WCOL</name>
              <description>This bit is set if any data are written to the data register SPIDR during transfer. This bit is cleared when the status register SPISR is read and then access (read/write) the data register SPIDR</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SS_HIGH</name>
              <description>When the SS pin is configured as input, if "HIGH" signal comes into the pin, this flag bit will be set.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FXCH</name>
              <description>SPI port function exchange control bit.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SPISSEN</name>
              <description>This bit controls the SS pin operation</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <!--CMP-->
    <peripheral>
      <name>CMP</name>
      <version>1.0</version>
      <description>COMPARATOR</description>
      <groupName>CMP</groupName>
      <baseAddress>0x40003420</baseAddress>
      <size>32</size>
      <access>read-write</access>
      <addressBlock>
        <offset>0</offset>
        <size>0x024</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <!--CR : Comparator 0 Control Register-->
        <register>
          <name>CMP0CR</name>
          <description>Comparator 0 Control Register</description>
          <addressOffset>0x00</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>HYSEN0</name>
              <description>Comparator Hysteresis Enable
0: Disable Hysteresis
1: Enable Hysteresis</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HYSSEL0</name>
              <description>Comparator Hysteresis Select
0: 5mV Hysteresis
1: 20mV Hysteresis</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>COMP0EN</name>
              <description>Comparator Enable bits
0: Disable Comparator
1: Enable Comparator</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>C0INNSEL</name>
              <description>Comparator Reference(input -) Selection bit
00: CREF0
01: BGR 1V
10: DAC OUT
11: CREF1</description>
              <bitOffset>4</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>C0INPSEL</name>
              <description>Comparator Input(input -) Selection bit
00: CP0
01: CP1B
10: CP1C
11: ADC MUX OUT</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
          </fields>
        </register>
        <!--CR : Comparator 1 Control Register-->
        <register>
          <name>CMP1CR</name>
          <description>Comparator 1 Control Register</description>
          <addressOffset>0x04</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>HYSEN1</name>
              <description>Comparator Hysteresis Enable
0: Disable Hysteresis
1: Enable Hysteresis</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HYSSEL1</name>
              <description>Comparator Hysteresis Select
0: 5mV Hysteresis
1: 20mV Hysteresis</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>COMP1EN</name>
              <description>Comparator Enable bits
0: Disable Comparator
1: Enable Comparator</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>C1INNSEL</name>
              <description>Comparator Reference(input -) Selection bit
00: CREF1
01: BGR 1V
10: DAC OUT
11: CREF0</description>
              <bitOffset>4</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>C0INPSEL</name>
              <description>Comparator Input(input -) Selection bit
00: CP1A
01: CP1B
10: CP1C
11: ADC MUX OUT</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
          </fields>
        </register>
        <!--DBNC : Comparator Debounce Register-->
        <register>
          <name>DBNC</name>
          <description>Comparator Debounce Register</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>DBINCTB</name>
              <description>Debounce time base counter
System clock/(DBNCTB *2) becomes shift clock of debounce logic
When DBNCTB is 0, system clock would be debounce clock.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>C1DBNC</name>
              <description>Debounce shift Selection
When it is 0x0, debounce function is disable
Shift number of debounce logic is (C1DBNC + 1) when C1DBNC is more than 1</description>
              <bitOffset>4</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>C0DBNC</name>
              <description>Debounce shift Selection
When it is 0x0, debounce function is disable
Shift number of debounce logic is (C1DBNC + 1) when C1DBNC is more than 1</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <!--ICON : Comparator Interrupt Control Register-->
        <register>
          <name>ICON</name>
          <description>Comparator Interrupt Control Register</description>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>TPOL1</name>
              <description>Comparator Trigger output polarity(to trigger other IP)
0: output normal (comparator out high activates trigger)
1: output inverted (XOR)</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TPOL0</name>
              <description>Comparator Trigger output polarity(to trigger other IP)
0: output normal (comparator out high activates trigger)
1: output inverted (XOR)</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IPOL1</name>
              <description>Comparator 1 interrupt polarity(level mode)
0: interrupt at comparator out high
1: interrupt at comparator out low</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IPOL0</name>
              <description>Comparator 0 interrupt polarity(level mode)
0: interrupt at comparator out high
1: interrupt at comparator out low</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>C1IMODE</name>
              <description>Comparator 1 Interrupt Flag bit.
00: level interrupt (by IPOL1)
01: rising edge interrupt
10: falling edge interrupt
11: both edge interrupt A/D Converter Prescaler Data bits.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>C0IMODE</name>
              <description>Comparator 0 Interrupt Flag bit.
00: level interrupt (by IPOL0)
01: rising edge interrupt
10: falling edge interrupt
11: both edge interrupt A/D Converter Prescaler Data bits.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
          </fields>
        </register>
        <!--IEN : Comparator Interrupt Enable Register-->
        <register>
          <name>IEN</name>
          <description>Comparator Interrupt Enable Register</description>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>C1IEN</name>
              <description>Comparator 1 Enable
0: Disable
1: Enable</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>C0IEN</name>
              <description>Comparator 0 Enable
0: Disable
1: Enable</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <!--IST : Comparator Interrupt Status Register-->
        <register>
          <name>IST</name>
          <description>Comparator Interrupt Status Register</description>
          <addressOffset>0x1C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>C1IRQ</name>
              <description>Comparator 1 interrupt Status
0: No Comparator Interrupt
1: Comparator Interrupt asserted</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>C0IRQ</name>
              <description>Comparator 0 interrupt Status
0: No Comparator Interrupt
1: Comparator Interrupt asserted</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <!--ICLR : Comparator Interrupt Clear Register-->
        <register>
          <name>ICLR</name>
          <description>Comparator Interrupt Clear Register</description>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>C1ICLR</name>
              <description>Comparator 1 Interrupt Clear (write "1" to clear C1IRQ)</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>C0ICLR</name>
              <description>Comparator 0 Interrupt Clear (write "1" to clear C0IRQ)</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <!--TOUCH-->
    <peripheral>
      <name>TOUCH</name>
      <version>1.0</version>
      <description>TOUCH</description>
      <groupName>TOUCH</groupName>
      <baseAddress>0x40003600</baseAddress>
      <size>32</size>
      <access>read-write</access>
      <addressBlock>
        <offset>0</offset>
        <size>0x188</size>
        <usage>registers</usage>
      </addressBlock>
      <interrupt>
        <name>TOUCH</name>
        <value>29</value>
      </interrupt>
      <registers>
        <!--SUM_CH0 : Touch Sensor Channel 0~23 Sum Register-->
        <register>
          <name>SUM_CH0</name>
          <description>Touch Sensor Channel 0~23 Sum Register</description>
          <addressOffset>0x00</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>SUM_CH_DATA</name>
              <description>Touch Sensor Channel n Sum or ADC Data</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <!--SUM_CH1 : Touch Sensor Channel 0~23 Sum Register-->
        <register>
          <name>SUM_CH1</name>
          <description>Touch Sensor Channel 0~23 Sum Register</description>
          <addressOffset>0x04</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>SUM_CH_DATA</name>
              <description>Touch Sensor Channel n Sum or ADC Data</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <!--SUM_CH2 : Touch Sensor Channel 0~23 Sum Register-->
        <register>
          <name>SUM_CH2</name>
          <description>Touch Sensor Channel 0~23 Sum Register</description>
          <addressOffset>0x08</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>SUM_CH_DATA</name>
              <description>Touch Sensor Channel n Sum or ADC Data</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <!--SUM_CH3 : Touch Sensor Channel 0~23 Sum Register-->
        <register>
          <name>SUM_CH3</name>
          <description>Touch Sensor Channel 0~23 Sum Register</description>
          <addressOffset>0x0c</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>SUM_CH_DATA</name>
              <description>Touch Sensor Channel n Sum or ADC Data</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <!--SUM_CH4 : Touch Sensor Channel 0~23 Sum Register-->
        <register>
          <name>SUM_CH4</name>
          <description>Touch Sensor Channel 0~23 Sum Register</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>SUM_CH_DATA</name>
              <description>Touch Sensor Channel n Sum or ADC Data</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <!--SUM_CH5 : Touch Sensor Channel 0~23 Sum Register-->
        <register>
          <name>SUM_CH5</name>
          <description>Touch Sensor Channel 0~23 Sum Register</description>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>SUM_CH_DATA</name>
              <description>Touch Sensor Channel n Sum or ADC Data</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <!--SUM_CH6 : Touch Sensor Channel 0~23 Sum Register-->
        <register>
          <name>SUM_CH6</name>
          <description>Touch Sensor Channel 0~23 Sum Register</description>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>SUM_CH_DATA</name>
              <description>Touch Sensor Channel n Sum or ADC Data</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <!--SUM_CH7 : Touch Sensor Channel 0~23 Sum Register-->
        <register>
          <name>SUM_CH7</name>
          <description>Touch Sensor Channel 0~23 Sum Register</description>
          <addressOffset>0x1c</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>SUM_CH_DATA</name>
              <description>Touch Sensor Channel n Sum or ADC Data</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <!--SUM_CH8 : Touch Sensor Channel 0~23 Sum Register-->
        <register>
          <name>SUM_CH8</name>
          <description>Touch Sensor Channel 0~23 Sum Register</description>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>SUM_CH_DATA</name>
              <description>Touch Sensor Channel n Sum or ADC Data</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <!--SUM_CH9 : Touch Sensor Channel 0~23 Sum Register-->
        <register>
          <name>SUM_CH9</name>
          <description>Touch Sensor Channel 0~23 Sum Register</description>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>SUM_CH_DATA</name>
              <description>Touch Sensor Channel n Sum or ADC Data</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <!--SUM_CH10 : Touch Sensor Channel 0~23 Sum Register-->
        <register>
          <name>SUM_CH10</name>
          <description>Touch Sensor Channel 0~23 Sum Register</description>
          <addressOffset>0x28</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>SUM_CH_DATA</name>
              <description>Touch Sensor Channel n Sum or ADC Data</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <!--SUM_CH11 : Touch Sensor Channel 0~23 Sum Register-->
        <register>
          <name>SUM_CH11</name>
          <description>Touch Sensor Channel 0~23 Sum Register</description>
          <addressOffset>0x2c</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>SUM_CH_DATA</name>
              <description>Touch Sensor Channel n Sum or ADC Data</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <!--SUM_CH12 : Touch Sensor Channel 0~23 Sum Register-->
        <register>
          <name>SUM_CH12</name>
          <description>Touch Sensor Channel 0~23 Sum Register</description>
          <addressOffset>0x30</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>SUM_CH_DATA</name>
              <description>Touch Sensor Channel n Sum or ADC Data</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <!--SUM_CH13 : Touch Sensor Channel 0~23 Sum Register-->
        <register>
          <name>SUM_CH13</name>
          <description>Touch Sensor Channel 0~23 Sum Register</description>
          <addressOffset>0x34</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>SUM_CH_DATA</name>
              <description>Touch Sensor Channel n Sum or ADC Data</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <!--SUM_CH14 : Touch Sensor Channel 0~23 Sum Register-->
        <register>
          <name>SUM_CH14</name>
          <description>Touch Sensor Channel 0~23 Sum Register</description>
          <addressOffset>0x38</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>SUM_CH_DATA</name>
              <description>Touch Sensor Channel n Sum or ADC Data</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <!--SUM_CH15 : Touch Sensor Channel 0~23 Sum Register-->
        <register>
          <name>SUM_CH15</name>
          <description>Touch Sensor Channel 0~23 Sum Register</description>
          <addressOffset>0x3c</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>SUM_CH_DATA</name>
              <description>Touch Sensor Channel n Sum or ADC Data</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <!--SUM_CH16 : Touch Sensor Channel 0~23 Sum Register-->
        <register>
          <name>SUM_CH16</name>
          <description>Touch Sensor Channel 0~23 Sum Register</description>
          <addressOffset>0x40</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>SUM_CH_DATA</name>
              <description>Touch Sensor Channel n Sum or ADC Data</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <!--SUM_CH17 : Touch Sensor Channel 0~23 Sum Register-->
        <register>
          <name>SUM_CH17</name>
          <description>Touch Sensor Channel 0~23 Sum Register</description>
          <addressOffset>0x44</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>SUM_CH_DATA</name>
              <description>Touch Sensor Channel n Sum or ADC Data</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <!--SUM_CH18 : Touch Sensor Channel 0~23 Sum Register-->
        <register>
          <name>SUM_CH18</name>
          <description>Touch Sensor Channel 0~23 Sum Register</description>
          <addressOffset>0x48</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>SUM_CH_DATA</name>
              <description>Touch Sensor Channel n Sum or ADC Data</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <!--SUM_CH19 : Touch Sensor Channel 0~23 Sum Register-->
        <register>
          <name>SUM_CH19</name>
          <description>Touch Sensor Channel 0~23 Sum Register</description>
          <addressOffset>0x4c</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>SUM_CH_DATA</name>
              <description>Touch Sensor Channel n Sum or ADC Data</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <!--SUM_CH20 : Touch Sensor Channel 0~23 Sum Register-->
        <register>
          <name>SUM_CH20</name>
          <description>Touch Sensor Channel 0~23 Sum Register</description>
          <addressOffset>0x50</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>SUM_CH_DATA</name>
              <description>Touch Sensor Channel n Sum or ADC Data</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <!--SUM_CH21 : Touch Sensor Channel 0~23 Sum Register-->
        <register>
          <name>SUM_CH21</name>
          <description>Touch Sensor Channel 0~23 Sum Register</description>
          <addressOffset>0x54</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>SUM_CH_DATA</name>
              <description>Touch Sensor Channel n Sum or ADC Data</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <!--SUM_CH22 : Touch Sensor Channel 0~23 Sum Register-->
        <register>
          <name>SUM_CH22</name>
          <description>Touch Sensor Channel 0~23 Sum Register</description>
          <addressOffset>0x58</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>SUM_CH_DATA</name>
              <description>Touch Sensor Channel n Sum or ADC Data</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <!--SUM_CH23 : Touch Sensor Channel 0~23 Sum Register-->
        <register>
          <name>SUM_CH23</name>
          <description>Touch Sensor Channel 0~23 Sum Register</description>
          <addressOffset>0x5c</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>SUM_CH_DATA</name>
              <description>Touch Sensor Channel n Sum or ADC Data</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <!--SCO0 : Touch Sensor Offset Capacitor Selection Register for CH0~23-->
        <register>
          <name>SCO0</name>
          <description>Touch Sensor Offset Capacitor Selection Register for CH0~23</description>
          <addressOffset>0x60</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>SCO</name>
              <description>Touch Sensor Offset Capacitor Selection
0_0000_0000b: 0pF
0_0000_0001b: 0.1pF
0_0000_0010b: 0.2pF
0_0000_0100b: 0.4pF
0_0000_1000b: 0.8pF
0_0001_0000b: 1.6pF
0_0010_0000b: 3.2pF
0_0100_0000b: 6.4pF
0_1000_0000b: 12.8pF
1_0000_0000b: 25.6pF
--
1_1111_1111b: 51.1pF</description>
              <bitOffset>0</bitOffset>
              <bitWidth>9</bitWidth>
            </field>
          </fields>
        </register>
        <!--SCO1 : Touch Sensor Offset Capacitor Selection Register for CH0~23-->
        <register>
          <name>SCO1</name>
          <description>Touch Sensor Offset Capacitor Selection Register for CH0~23</description>
          <addressOffset>0x64</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>SCO</name>
              <description>Touch Sensor Offset Capacitor Selection
0_0000_0000b: 0pF
0_0000_0001b: 0.1pF
0_0000_0010b: 0.2pF
0_0000_0100b: 0.4pF
0_0000_1000b: 0.8pF
0_0001_0000b: 1.6pF
0_0010_0000b: 3.2pF
0_0100_0000b: 6.4pF
0_1000_0000b: 12.8pF
1_0000_0000b: 25.6pF
--
1_1111_1111b: 51.1pF</description>
              <bitOffset>0</bitOffset>
              <bitWidth>9</bitWidth>
            </field>
          </fields>
        </register>
        <!--SCO2 : Touch Sensor Offset Capacitor Selection Register for CH0~23-->
        <register>
          <name>SCO2</name>
          <description>Touch Sensor Offset Capacitor Selection Register for CH0~23</description>
          <addressOffset>0x68</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>SCO</name>
              <description>Touch Sensor Offset Capacitor Selection
0_0000_0000b: 0pF
0_0000_0001b: 0.1pF
0_0000_0010b: 0.2pF
0_0000_0100b: 0.4pF
0_0000_1000b: 0.8pF
0_0001_0000b: 1.6pF
0_0010_0000b: 3.2pF
0_0100_0000b: 6.4pF
0_1000_0000b: 12.8pF
1_0000_0000b: 25.6pF
--
1_1111_1111b: 51.1pF</description>
              <bitOffset>0</bitOffset>
              <bitWidth>9</bitWidth>
            </field>
          </fields>
        </register>
        <!--SCO3 : Touch Sensor Offset Capacitor Selection Register for CH0~23-->
        <register>
          <name>SCO3</name>
          <description>Touch Sensor Offset Capacitor Selection Register for CH0~23</description>
          <addressOffset>0x6c</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>SCO</name>
              <description>Touch Sensor Offset Capacitor Selection
0_0000_0000b: 0pF
0_0000_0001b: 0.1pF
0_0000_0010b: 0.2pF
0_0000_0100b: 0.4pF
0_0000_1000b: 0.8pF
0_0001_0000b: 1.6pF
0_0010_0000b: 3.2pF
0_0100_0000b: 6.4pF
0_1000_0000b: 12.8pF
1_0000_0000b: 25.6pF
--
1_1111_1111b: 51.1pF</description>
              <bitOffset>0</bitOffset>
              <bitWidth>9</bitWidth>
            </field>
          </fields>
        </register>
        <!--SCO4 : Touch Sensor Offset Capacitor Selection Register for CH0~23-->
        <register>
          <name>SCO4</name>
          <description>Touch Sensor Offset Capacitor Selection Register for CH0~23</description>
          <addressOffset>0x70</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>SCO</name>
              <description>Touch Sensor Offset Capacitor Selection
0_0000_0000b: 0pF
0_0000_0001b: 0.1pF
0_0000_0010b: 0.2pF
0_0000_0100b: 0.4pF
0_0000_1000b: 0.8pF
0_0001_0000b: 1.6pF
0_0010_0000b: 3.2pF
0_0100_0000b: 6.4pF
0_1000_0000b: 12.8pF
1_0000_0000b: 25.6pF
--
1_1111_1111b: 51.1pF</description>
              <bitOffset>0</bitOffset>
              <bitWidth>9</bitWidth>
            </field>
          </fields>
        </register>
        <!--SCO5 : Touch Sensor Offset Capacitor Selection Register for CH0~23-->
        <register>
          <name>SCO5</name>
          <description>Touch Sensor Offset Capacitor Selection Register for CH0~23</description>
          <addressOffset>0x74</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>SCO</name>
              <description>Touch Sensor Offset Capacitor Selection
0_0000_0000b: 0pF
0_0000_0001b: 0.1pF
0_0000_0010b: 0.2pF
0_0000_0100b: 0.4pF
0_0000_1000b: 0.8pF
0_0001_0000b: 1.6pF
0_0010_0000b: 3.2pF
0_0100_0000b: 6.4pF
0_1000_0000b: 12.8pF
1_0000_0000b: 25.6pF
--
1_1111_1111b: 51.1pF</description>
              <bitOffset>0</bitOffset>
              <bitWidth>9</bitWidth>
            </field>
          </fields>
        </register>
        <!--SCO6 : Touch Sensor Offset Capacitor Selection Register for CH0~23-->
        <register>
          <name>SCO6</name>
          <description>Touch Sensor Offset Capacitor Selection Register for CH0~23</description>
          <addressOffset>0x78</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>SCO</name>
              <description>Touch Sensor Offset Capacitor Selection
0_0000_0000b: 0pF
0_0000_0001b: 0.1pF
0_0000_0010b: 0.2pF
0_0000_0100b: 0.4pF
0_0000_1000b: 0.8pF
0_0001_0000b: 1.6pF
0_0010_0000b: 3.2pF
0_0100_0000b: 6.4pF
0_1000_0000b: 12.8pF
1_0000_0000b: 25.6pF
--
1_1111_1111b: 51.1pF</description>
              <bitOffset>0</bitOffset>
              <bitWidth>9</bitWidth>
            </field>
          </fields>
        </register>
        <!--SCO7 : Touch Sensor Offset Capacitor Selection Register for CH0~23-->
        <register>
          <name>SCO7</name>
          <description>Touch Sensor Offset Capacitor Selection Register for CH0~23</description>
          <addressOffset>0x7c</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>SCO</name>
              <description>Touch Sensor Offset Capacitor Selection
0_0000_0000b: 0pF
0_0000_0001b: 0.1pF
0_0000_0010b: 0.2pF
0_0000_0100b: 0.4pF
0_0000_1000b: 0.8pF
0_0001_0000b: 1.6pF
0_0010_0000b: 3.2pF
0_0100_0000b: 6.4pF
0_1000_0000b: 12.8pF
1_0000_0000b: 25.6pF
--
1_1111_1111b: 51.1pF</description>
              <bitOffset>0</bitOffset>
              <bitWidth>9</bitWidth>
            </field>
          </fields>
        </register>
        <!--SCO8 : Touch Sensor Offset Capacitor Selection Register for CH0~23-->
        <register>
          <name>SCO8</name>
          <description>Touch Sensor Offset Capacitor Selection Register for CH0~23</description>
          <addressOffset>0x80</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>SCO</name>
              <description>Touch Sensor Offset Capacitor Selection
0_0000_0000b: 0pF
0_0000_0001b: 0.1pF
0_0000_0010b: 0.2pF
0_0000_0100b: 0.4pF
0_0000_1000b: 0.8pF
0_0001_0000b: 1.6pF
0_0010_0000b: 3.2pF
0_0100_0000b: 6.4pF
0_1000_0000b: 12.8pF
1_0000_0000b: 25.6pF
--
1_1111_1111b: 51.1pF</description>
              <bitOffset>0</bitOffset>
              <bitWidth>9</bitWidth>
            </field>
          </fields>
        </register>
        <!--SCO9 : Touch Sensor Offset Capacitor Selection Register for CH0~23-->
        <register>
          <name>SCO9</name>
          <description>Touch Sensor Offset Capacitor Selection Register for CH0~23</description>
          <addressOffset>0x84</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>SCO</name>
              <description>Touch Sensor Offset Capacitor Selection
0_0000_0000b: 0pF
0_0000_0001b: 0.1pF
0_0000_0010b: 0.2pF
0_0000_0100b: 0.4pF
0_0000_1000b: 0.8pF
0_0001_0000b: 1.6pF
0_0010_0000b: 3.2pF
0_0100_0000b: 6.4pF
0_1000_0000b: 12.8pF
1_0000_0000b: 25.6pF
--
1_1111_1111b: 51.1pF</description>
              <bitOffset>0</bitOffset>
              <bitWidth>9</bitWidth>
            </field>
          </fields>
        </register>
        <!--SCO10 : Touch Sensor Offset Capacitor Selection Register for CH0~23-->
        <register>
          <name>SCO10</name>
          <description>Touch Sensor Offset Capacitor Selection Register for CH0~23</description>
          <addressOffset>0x88</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>SCO</name>
              <description>Touch Sensor Offset Capacitor Selection
0_0000_0000b: 0pF
0_0000_0001b: 0.1pF
0_0000_0010b: 0.2pF
0_0000_0100b: 0.4pF
0_0000_1000b: 0.8pF
0_0001_0000b: 1.6pF
0_0010_0000b: 3.2pF
0_0100_0000b: 6.4pF
0_1000_0000b: 12.8pF
1_0000_0000b: 25.6pF
--
1_1111_1111b: 51.1pF</description>
              <bitOffset>0</bitOffset>
              <bitWidth>9</bitWidth>
            </field>
          </fields>
        </register>
        <!--SCO11 : Touch Sensor Offset Capacitor Selection Register for CH0~23-->
        <register>
          <name>SCO11</name>
          <description>Touch Sensor Offset Capacitor Selection Register for CH0~23</description>
          <addressOffset>0x8c</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>SCO</name>
              <description>Touch Sensor Offset Capacitor Selection
0_0000_0000b: 0pF
0_0000_0001b: 0.1pF
0_0000_0010b: 0.2pF
0_0000_0100b: 0.4pF
0_0000_1000b: 0.8pF
0_0001_0000b: 1.6pF
0_0010_0000b: 3.2pF
0_0100_0000b: 6.4pF
0_1000_0000b: 12.8pF
1_0000_0000b: 25.6pF
--
1_1111_1111b: 51.1pF</description>
              <bitOffset>0</bitOffset>
              <bitWidth>9</bitWidth>
            </field>
          </fields>
        </register>
        <!--SCO12 : Touch Sensor Offset Capacitor Selection Register for CH0~23-->
        <register>
          <name>SCO12</name>
          <description>Touch Sensor Offset Capacitor Selection Register for CH0~23</description>
          <addressOffset>0x90</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>SCO</name>
              <description>Touch Sensor Offset Capacitor Selection
0_0000_0000b: 0pF
0_0000_0001b: 0.1pF
0_0000_0010b: 0.2pF
0_0000_0100b: 0.4pF
0_0000_1000b: 0.8pF
0_0001_0000b: 1.6pF
0_0010_0000b: 3.2pF
0_0100_0000b: 6.4pF
0_1000_0000b: 12.8pF
1_0000_0000b: 25.6pF
--
1_1111_1111b: 51.1pF</description>
              <bitOffset>0</bitOffset>
              <bitWidth>9</bitWidth>
            </field>
          </fields>
        </register>
        <!--SCO13 : Touch Sensor Offset Capacitor Selection Register for CH0~23-->
        <register>
          <name>SCO13</name>
          <description>Touch Sensor Offset Capacitor Selection Register for CH0~23</description>
          <addressOffset>0x94</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>SCO</name>
              <description>Touch Sensor Offset Capacitor Selection
0_0000_0000b: 0pF
0_0000_0001b: 0.1pF
0_0000_0010b: 0.2pF
0_0000_0100b: 0.4pF
0_0000_1000b: 0.8pF
0_0001_0000b: 1.6pF
0_0010_0000b: 3.2pF
0_0100_0000b: 6.4pF
0_1000_0000b: 12.8pF
1_0000_0000b: 25.6pF
--
1_1111_1111b: 51.1pF</description>
              <bitOffset>0</bitOffset>
              <bitWidth>9</bitWidth>
            </field>
          </fields>
        </register>
        <!--SCO14 : Touch Sensor Offset Capacitor Selection Register for CH0~23-->
        <register>
          <name>SCO14</name>
          <description>Touch Sensor Offset Capacitor Selection Register for CH0~23</description>
          <addressOffset>0x98</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>SCO</name>
              <description>Touch Sensor Offset Capacitor Selection
0_0000_0000b: 0pF
0_0000_0001b: 0.1pF
0_0000_0010b: 0.2pF
0_0000_0100b: 0.4pF
0_0000_1000b: 0.8pF
0_0001_0000b: 1.6pF
0_0010_0000b: 3.2pF
0_0100_0000b: 6.4pF
0_1000_0000b: 12.8pF
1_0000_0000b: 25.6pF
--
1_1111_1111b: 51.1pF</description>
              <bitOffset>0</bitOffset>
              <bitWidth>9</bitWidth>
            </field>
          </fields>
        </register>
        <!--SCO15 : Touch Sensor Offset Capacitor Selection Register for CH0~23-->
        <register>
          <name>SCO15</name>
          <description>Touch Sensor Offset Capacitor Selection Register for CH0~23</description>
          <addressOffset>0x9c</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>SCO</name>
              <description>Touch Sensor Offset Capacitor Selection
0_0000_0000b: 0pF
0_0000_0001b: 0.1pF
0_0000_0010b: 0.2pF
0_0000_0100b: 0.4pF
0_0000_1000b: 0.8pF
0_0001_0000b: 1.6pF
0_0010_0000b: 3.2pF
0_0100_0000b: 6.4pF
0_1000_0000b: 12.8pF
1_0000_0000b: 25.6pF
--
1_1111_1111b: 51.1pF</description>
              <bitOffset>0</bitOffset>
              <bitWidth>9</bitWidth>
            </field>
          </fields>
        </register>
        <!--SCO16 : Touch Sensor Offset Capacitor Selection Register for CH0~23-->
        <register>
          <name>SCO16</name>
          <description>Touch Sensor Offset Capacitor Selection Register for CH0~23</description>
          <addressOffset>0xa0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>SCO</name>
              <description>Touch Sensor Offset Capacitor Selection
0_0000_0000b: 0pF
0_0000_0001b: 0.1pF
0_0000_0010b: 0.2pF
0_0000_0100b: 0.4pF
0_0000_1000b: 0.8pF
0_0001_0000b: 1.6pF
0_0010_0000b: 3.2pF
0_0100_0000b: 6.4pF
0_1000_0000b: 12.8pF
1_0000_0000b: 25.6pF
--
1_1111_1111b: 51.1pF</description>
              <bitOffset>0</bitOffset>
              <bitWidth>9</bitWidth>
            </field>
          </fields>
        </register>
        <!--SCO17 : Touch Sensor Offset Capacitor Selection Register for CH0~23-->
        <register>
          <name>SCO17</name>
          <description>Touch Sensor Offset Capacitor Selection Register for CH0~23</description>
          <addressOffset>0xa4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>SCO</name>
              <description>Touch Sensor Offset Capacitor Selection
0_0000_0000b: 0pF
0_0000_0001b: 0.1pF
0_0000_0010b: 0.2pF
0_0000_0100b: 0.4pF
0_0000_1000b: 0.8pF
0_0001_0000b: 1.6pF
0_0010_0000b: 3.2pF
0_0100_0000b: 6.4pF
0_1000_0000b: 12.8pF
1_0000_0000b: 25.6pF
--
1_1111_1111b: 51.1pF</description>
              <bitOffset>0</bitOffset>
              <bitWidth>9</bitWidth>
            </field>
          </fields>
        </register>
        <!--SCO18 : Touch Sensor Offset Capacitor Selection Register for CH0~23-->
        <register>
          <name>SCO18</name>
          <description>Touch Sensor Offset Capacitor Selection Register for CH0~23</description>
          <addressOffset>0xa8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>SCO</name>
              <description>Touch Sensor Offset Capacitor Selection
0_0000_0000b: 0pF
0_0000_0001b: 0.1pF
0_0000_0010b: 0.2pF
0_0000_0100b: 0.4pF
0_0000_1000b: 0.8pF
0_0001_0000b: 1.6pF
0_0010_0000b: 3.2pF
0_0100_0000b: 6.4pF
0_1000_0000b: 12.8pF
1_0000_0000b: 25.6pF
--
1_1111_1111b: 51.1pF</description>
              <bitOffset>0</bitOffset>
              <bitWidth>9</bitWidth>
            </field>
          </fields>
        </register>
        <!--SCO19 : Touch Sensor Offset Capacitor Selection Register for CH0~23-->
        <register>
          <name>SCO19</name>
          <description>Touch Sensor Offset Capacitor Selection Register for CH0~23</description>
          <addressOffset>0xac</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>SCO</name>
              <description>Touch Sensor Offset Capacitor Selection
0_0000_0000b: 0pF
0_0000_0001b: 0.1pF
0_0000_0010b: 0.2pF
0_0000_0100b: 0.4pF
0_0000_1000b: 0.8pF
0_0001_0000b: 1.6pF
0_0010_0000b: 3.2pF
0_0100_0000b: 6.4pF
0_1000_0000b: 12.8pF
1_0000_0000b: 25.6pF
--
1_1111_1111b: 51.1pF</description>
              <bitOffset>0</bitOffset>
              <bitWidth>9</bitWidth>
            </field>
          </fields>
        </register>
        <!--SCO20 : Touch Sensor Offset Capacitor Selection Register for CH0~23-->
        <register>
          <name>SCO20</name>
          <description>Touch Sensor Offset Capacitor Selection Register for CH0~23</description>
          <addressOffset>0xb0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>SCO</name>
              <description>Touch Sensor Offset Capacitor Selection
0_0000_0000b: 0pF
0_0000_0001b: 0.1pF
0_0000_0010b: 0.2pF
0_0000_0100b: 0.4pF
0_0000_1000b: 0.8pF
0_0001_0000b: 1.6pF
0_0010_0000b: 3.2pF
0_0100_0000b: 6.4pF
0_1000_0000b: 12.8pF
1_0000_0000b: 25.6pF
--
1_1111_1111b: 51.1pF</description>
              <bitOffset>0</bitOffset>
              <bitWidth>9</bitWidth>
            </field>
          </fields>
        </register>
        <!--SCO21 : Touch Sensor Offset Capacitor Selection Register for CH0~23-->
        <register>
          <name>SCO21</name>
          <description>Touch Sensor Offset Capacitor Selection Register for CH0~23</description>
          <addressOffset>0xb4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>SCO</name>
              <description>Touch Sensor Offset Capacitor Selection
0_0000_0000b: 0pF
0_0000_0001b: 0.1pF
0_0000_0010b: 0.2pF
0_0000_0100b: 0.4pF
0_0000_1000b: 0.8pF
0_0001_0000b: 1.6pF
0_0010_0000b: 3.2pF
0_0100_0000b: 6.4pF
0_1000_0000b: 12.8pF
1_0000_0000b: 25.6pF
--
1_1111_1111b: 51.1pF</description>
              <bitOffset>0</bitOffset>
              <bitWidth>9</bitWidth>
            </field>
          </fields>
        </register>
        <!--SCO22 : Touch Sensor Offset Capacitor Selection Register for CH0~23-->
        <register>
          <name>SCO22</name>
          <description>Touch Sensor Offset Capacitor Selection Register for CH0~23</description>
          <addressOffset>0xb8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>SCO</name>
              <description>Touch Sensor Offset Capacitor Selection
0_0000_0000b: 0pF
0_0000_0001b: 0.1pF
0_0000_0010b: 0.2pF
0_0000_0100b: 0.4pF
0_0000_1000b: 0.8pF
0_0001_0000b: 1.6pF
0_0010_0000b: 3.2pF
0_0100_0000b: 6.4pF
0_1000_0000b: 12.8pF
1_0000_0000b: 25.6pF
--
1_1111_1111b: 51.1pF</description>
              <bitOffset>0</bitOffset>
              <bitWidth>9</bitWidth>
            </field>
          </fields>
        </register>
        <!--SCO23 : Touch Sensor Offset Capacitor Selection Register for CH0~23-->
        <register>
          <name>SCO23</name>
          <description>Touch Sensor Offset Capacitor Selection Register for CH0~23</description>
          <addressOffset>0xbc</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>SCO</name>
              <description>Touch Sensor Offset Capacitor Selection
0_0000_0000b: 0pF
0_0000_0001b: 0.1pF
0_0000_0010b: 0.2pF
0_0000_0100b: 0.4pF
0_0000_1000b: 0.8pF
0_0001_0000b: 1.6pF
0_0010_0000b: 3.2pF
0_0100_0000b: 6.4pF
0_1000_0000b: 12.8pF
1_0000_0000b: 25.6pF
--
1_1111_1111b: 51.1pF</description>
              <bitOffset>0</bitOffset>
              <bitWidth>9</bitWidth>
            </field>
          </fields>
        </register>
        <!--CON : Touch Sensor Control Register-->
        <register>
          <name>CON</name>
          <description>Touch Sensor Control Register</description>
          <addressOffset>0x100</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>OSC_EN</name>
              <description>Oscillator Enable</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>BGR_EN</name>
              <description>Band Gap Reference Enable</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TS_IF</name>
              <description>Touch Sensor Interrupt Flag</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TS_RUN</name>
              <description>Touch Sensor Enable</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <!--MODE : Touch Sensor Mode Register-->
        <register>
          <name>MODE</name>
          <description>Touch Sensor Mode Register</description>
          <addressOffset>0x104</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000010</resetValue>
          <fields>
            <field>
              <name>SREF</name>
              <description>External Reference Offset Enable
0: Disable
1: Enable</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SC_GAIN</name>
              <description>Gain Calibration Capacitor Enable
0: Gain Calibration Capacitor Disable (Default)
1: Gain Calibration Capacitor Enable</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SAP</name>
              <description>Touch Sensor Selection
01: Touch Sensor mode Select (Default)
10: ADC. The result of ADC is stored only at SUM_CH0 register</description>
              <bitOffset>4</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PORT</name>
              <description>Port Configuration During Inactive Status
00: Input Floating
01: Output Low
10: Output High</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <!--SUM_CNT : Touch Sensor Sum Repeat Count Register-->
        <register>
          <name>SUM_CNT</name>
          <description>Touch Sensor Sum Repeat Count Register</description>
          <addressOffset>0x108</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000001</resetValue>
          <fields>
            <field>
              <name>TS_SUM_CNT</name>
              <description>Touch Sensor Sum Repeat Count</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <!--CH_SEL : Touch Sensor Channel Selection Register-->
        <register>
          <name>CH_SEL</name>
          <description>Touch Sensor Channel Selection Register</description>
          <addressOffset>0x10c</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>CH23_SEL</name>
              <description>Touch Sensor Channel Selection Register
0: Disable (Default)
1: Enable Touch Key</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CH22_SEL</name>
              <description>Touch Sensor Channel Selection Register
0: Disable (Default)
1: Enable Touch Key</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CH21_SEL</name>
              <description>Touch Sensor Channel Selection Register
0: Disable (Default)
1: Enable Touch Key</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CH20_SEL</name>
              <description>Touch Sensor Channel Selection Register
0: Disable (Default)
1: Enable Touch Key</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CH19_SEL</name>
              <description>Touch Sensor Channel Selection Register
0: Disable (Default)
1: Enable Touch Key</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CH18_SEL</name>
              <description>Touch Sensor Channel Selection Register
0: Disable (Default)
1: Enable Touch Key</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CH17_SEL</name>
              <description>Touch Sensor Channel Selection Register
0: Disable (Default)
1: Enable Touch Key</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CH16_SEL</name>
              <description>Touch Sensor Channel Selection Register
0: Disable (Default)
1: Enable Touch Key</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CH15_SEL</name>
              <description>Touch Sensor Channel Selection Register
0: Disable (Default)
1: Enable Touch Key</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CH14_SEL</name>
              <description>Touch Sensor Channel Selection Register
0: Disable (Default)
1: Enable Touch Key</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CH13_SEL</name>
              <description>Touch Sensor Channel Selection Register
0: Disable (Default)
1: Enable Touch Key</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CH12_SEL</name>
              <description>Touch Sensor Channel Selection Register
0: Disable (Default)
1: Enable Touch Key</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CH11_SEL</name>
              <description>Touch Sensor Channel Selection Register
0: Disable (Default)
1: Enable Touch Key</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CH10_SEL</name>
              <description>Touch Sensor Channel Selection Register
0: Disable (Default)
1: Enable Touch Key</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CH9_SEL</name>
              <description>Touch Sensor Channel Selection Register
0: Disable (Default)
1: Enable Touch Key</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CH8_SEL</name>
              <description>Touch Sensor Channel Selection Register
0: Disable (Default)
1: Enable Touch Key</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CH7_SEL</name>
              <description>Touch Sensor Channel Selection Register
0: Disable (Default)
1: Enable Touch Key</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CH6_SEL</name>
              <description>Touch Sensor Channel Selection Register
0: Disable (Default)
1: Enable Touch Key</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CH5_SEL</name>
              <description>Touch Sensor Channel Selection Register
0: Disable (Default)
1: Enable Touch Key</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CH4_SEL</name>
              <description>Touch Sensor Channel Selection Register
0: Disable (Default)
1: Enable Touch Key</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CH3_SEL</name>
              <description>Touch Sensor Channel Selection Register
0: Disable (Default)
1: Enable Touch Key</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CH2_SEL</name>
              <description>Touch Sensor Channel Selection Register
0: Disable (Default)
1: Enable Touch Key</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CH1_SEL</name>
              <description>Touch Sensor Channel Selection Register
0: Disable (Default)
1: Enable Touch Key</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CH0_SEL</name>
              <description>Touch Sensor Channel Selection Register
0: Disable (Default)
1: Enable Touch Key</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <!--SLP_CR : Touch Sensor Low Pass Filter Control Register-->
        <register>
          <name>SLP_CR</name>
          <description>Touch Sensor Low Pass Filter Control Register</description>
          <addressOffset>0x114</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000001</resetValue>
          <fields>
            <field>
              <name>SLP_C</name>
              <description>Capacitor Trimming for Input Low Pass Filter
000: 0pF
001: 4pF
010: 8pF
011: 12pF
100: 16pF
101: 20pF
110: 24pF
111: 28pF</description>
              <bitOffset>4</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SLP_R</name>
              <description>Resistor Trimming for Input Low Pass Filter
0000: Channel open
0001: 0k
0010: 5k
0100: 10k
1000: 20k
1110: 2.8k
0110: 3.3k
1010: 4.0k
1100: 6.7k</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <!--ADC_CH_SEL : ADC Channel Selection Register-->
        <register>
          <name>ADC_CH_SEL</name>
          <description>ADC Channel Selection Register</description>
          <addressOffset>0x118</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>CH23_SEL</name>
              <description>ADC Channel Selection
0: Disable (Default)
1: Enable</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CH22_SEL</name>
              <description>ADC Channel Selection
0: Disable (Default)
1: Enable</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CH21_SEL</name>
              <description>ADC Channel Selection
0: Disable (Default)
1: Enable</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CH20_SEL</name>
              <description>ADC Channel Selection
0: Disable (Default)
1: Enable</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CH19_SEL</name>
              <description>ADC Channel Selection
0: Disable (Default)
1: Enable</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CH18_SEL</name>
              <description>ADC Channel Selection
0: Disable (Default)
1: Enable</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CH17_SEL</name>
              <description>ADC Channel Selection
0: Disable (Default)
1: Enable</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CH16_SEL</name>
              <description>ADC Channel Selection
0: Disable (Default)
1: Enable</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CH15_SEL</name>
              <description>ADC Channel Selection
0: Disable (Default)
1: Enable</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CH14_SEL</name>
              <description>ADC Channel Selection
0: Disable (Default)
1: Enable</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CH13_SEL</name>
              <description>ADC Channel Selection
0: Disable (Default)
1: Enable</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CH12_SEL</name>
              <description>ADC Channel Selection
0: Disable (Default)
1: Enable</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CH11_SEL</name>
              <description>ADC Channel Selection
0: Disable (Default)
1: Enable</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CH10_SEL</name>
              <description>ADC Channel Selection
0: Disable (Default)
1: Enable</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CH9_SEL</name>
              <description>ADC Channel Selection
0: Disable (Default)
1: Enable</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CH8_SEL</name>
              <description>ADC Channel Selection
0: Disable (Default)
1: Enable</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CH7_SEL</name>
              <description>ADC Channel Selection
0: Disable (Default)
1: Enable</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CH6_SEL</name>
              <description>ADC Channel Selection
0: Disable (Default)
1: Enable</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CH5_SEL</name>
              <description>ADC Channel Selection
0: Disable (Default)
1: Enable</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CH4_SEL</name>
              <description>ADC Channel Selection
0: Disable (Default)
1: Enable</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CH3_SEL</name>
              <description>ADC Channel Selection
0: Disable (Default)
1: Enable</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CH2_SEL</name>
              <description>ADC Channel Selection
0: Disable (Default)
1: Enable</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CH1_SEL</name>
              <description>ADC Channel Selection
0: Disable (Default)
1: Enable</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CH0_SEL</name>
              <description>ADC Channel Selection
0: Disable (Default)
1: Enable</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <!--INTEG_CNT : Touch Sensor Sensing Integration Count Register-->
        <register>
          <name>INTEG_CNT</name>
          <description>Touch Sensor Sensing Integration Count Register</description>
          <addressOffset>0x11c</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000032</resetValue>
          <fields>
            <field>
              <name>TS_INTEG_CNT</name>
              <description>Touch Sensor Sensing Integration Count</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <!--FREQ_NUM : Touch Sensor Frequency Number Register-->
        <register>
          <name>FREQ_NUM</name>
          <description>Touch Sensor Frequency Number Register</description>
          <addressOffset>0x120</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x000000ff</resetValue>
          <fields>
            <field>
              <name>TS_FREQ_NUM</name>
              <description>Touch Sensor Frequency Number</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <!--FREQ_DEL : Touch Sensor Frequency Delta Register-->
        <register>
          <name>FREQ_DEL</name>
          <description>Touch Sensor Frequency Delta Register</description>
          <addressOffset>0x124</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>TS_FREQ_DEL</name>
              <description>Touch Sensor Frequency Delta Register</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <!--CLK_CFG : Touch Sensor Clock Configuration Register-->
        <register>
          <name>CLK_CFG</name>
          <description>Touch Sensor Clock Configuration Register</description>
          <addressOffset>0x128</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000030</resetValue>
          <fields>
            <field>
              <name>ACLKSEL</name>
              <description>ADC Clock Source Select
0: Touch Sensor Clock
1: System MCU Clock</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ACLKDIV</name>
              <description>ADC Clock Divider
000: OSCsys / 1 (48MHz)
001: OSCsys / 2 (24MHz)
010: OSCsys / 4 (12MHz)
011: OSCsys / 8 (6MHz, default)
100: OSCsys / 16
101: OSCsys / 32
110: OSCsys / 64
111: OSCsys / 128</description>
              <bitOffset>4</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TSCLKOE</name>
              <description>Divided Touch Sensor Clock Output Enable
0: Clock Output Disable (Default)
1: Clock Output Enable</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TSCLKDIV</name>
              <description>Touch Sensor Clock Divider
000: OSCts / 1 (27MHz)
001: OSCts / 2
010: OSCts / 4
011: OSCts / 8
100: OSCts / 16
101: OSCts / 32
110: OSCts / 64
111: OSCts / 128</description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <!--TRIM_OSC : Touch Sensor RING Oscillator Trimming Selection Register-->
        <register>
          <name>TRIM_OSC</name>
          <description>Touch Sensor RING Oscillator Trimming Selection Register</description>
          <addressOffset>0x12c</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x000000b8</resetValue>
          <fields>
            <field>
              <name>TRIM_OSC</name>
              <description>Touch Sensor RING Oscillator Trimming Selection
0x00: 44MHz (maximum)
0xB8: 27MHz (default)
0xFF: 6MHz (minimum)</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <!--TRIM_A_OSC : Touch Sensor RING Oscillator Trimming for ADC Register-->
        <register>
          <name>TRIM_A_OSC</name>
          <description>Touch Sensor RING Oscillator Trimming for ADC Register</description>
          <addressOffset>0x130</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x000000ff</resetValue>
          <fields>
            <field>
              <name>TRIM_A_OSC</name>
              <description>Touch Sensor RING Oscillator Trimming for ADC
0x00: 44MHz (maximum)
0xB8: 27MHz (default)
0xFF: 6MHz (minimum)</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <!--SCI : Touch Sensor Input Capacitor Selection Register-->
        <register>
          <name>SCI</name>
          <description>Touch Sensor Input Capacitor Selection Register</description>
          <addressOffset>0x134</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000034</resetValue>
          <fields>
            <field>
              <name>IBIAS_TRIM</name>
              <description>BGR Current Bias Control</description>
              <bitOffset>4</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SCI</name>
              <description>Touch Sensor Input Capacitor Selection
000: 1.2pF
001: 2.4pF
010: 3.6pF
011: 4.8pF
100: 6.0pF
101: 7.2pF
110: 8.4pF
111: 9.6pF</description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <!--SCC : Touch Sensor Conversion Capacitor Selection Register-->
        <register>
          <name>SCC</name>
          <description>Touch Sensor Conversion Capacitor Selection Register</description>
          <addressOffset>0x138</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000004</resetValue>
          <fields>
            <field>
              <name>SCC</name>
              <description>Touch Sensor Conversion Capacitor Selection
000: 2.4pF
001: 4.8pF
010: 7.2pF
011: 9.6pF
100: 12.0pF
101: 14.4pF
110: 16.8pF
111: 19.2pF</description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <!--SVREF : Touch Sensor VREF Resistor Selection Register-->
        <register>
          <name>SVREF</name>
          <description>Touch Sensor VREF Resistor Selection Register</description>
          <addressOffset>0x13c</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000004</resetValue>
          <fields>
            <field>
              <name>SVREF</name>
              <description>Touch Sensor VREF Resistor Selection 
0000: Open
0001: 2.5k
0010: 5k
0100: 10k
1000: 20k
1111: 1.3k</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <!--TAR : Touch Sensor Integration AMP Reset Register-->
        <register>
          <name>TAR</name>
          <description>Touch Sensor Integration AMP Reset Register</description>
          <addressOffset>0x140</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000020</resetValue>
          <fields>
            <field>
              <name>TAR</name>
              <description>Touch Sensor Integration AMP Reset Register</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <!--TRST : Touch Sensor Reset time of Sensing Register-->
        <register>
          <name>TRST</name>
          <description>Touch Sensor Reset time of Sensing Register</description>
          <addressOffset>0x144</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000003</resetValue>
          <fields>
            <field>
              <name>TRST</name>
              <description>Touch Sensor Reset time of Sensing</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <!--TDRV : Touch Sensor Sample time of Sensing Register-->
        <register>
          <name>TDRV</name>
          <description>Touch Sensor Sample time of Sensing Register</description>
          <addressOffset>0x148</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000003</resetValue>
          <fields>
            <field>
              <name>TDRV</name>
              <description>Touch Sensor Driving time of Sensing</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <!--TINT : Touch Sensor Integration time of Sensing Register-->
        <register>
          <name>TINT</name>
          <description>Touch Sensor Integration time of Sensing Register</description>
          <addressOffset>0x14c</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000014</resetValue>
          <fields>
            <field>
              <name>TINT</name>
              <description>Touch Sensor Integration time of Sensing</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <!--TD : Touch Sensor Differential AMP Sampling Register-->
        <register>
          <name>TD</name>
          <description>Touch Sensor Differential AMP Sampling Register</description>
          <addressOffset>0x150</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000020</resetValue>
          <fields>
            <field>
              <name>TD</name>
              <description>Touch Sensor Differential AMP Sampling</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <!--TWR : Touch Sensor Wait time Register-->
        <register>
          <name>TWR</name>
          <description>Touch Sensor Wait time Register</description>
          <addressOffset>0x154</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000010</resetValue>
          <fields>
            <field>
              <name>TWR</name>
              <description>Touch Sensor Wait Time</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <!--TLED : LED stable time Register-->
        <register>
          <name>TLED</name>
          <description>LED stable time Register</description>
          <addressOffset>0x158</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>TLED</name>
              <description>LED stable Time</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <!--LCD-->
    <peripheral>
      <name>LCD</name>
      <version>1.0</version>
      <description>LCD DRIVER/CONTROLLER</description>
      <groupName>LCD</groupName>
      <baseAddress>0x40005000</baseAddress>
      <size>32</size>
      <access>read-write</access>
      <addressBlock>
        <offset>0</offset>
        <size>0x030</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <!--CR : LCD Driver Control Register-->
        <register>
          <name>CR</name>
          <description>LCD Driver Control Register</description>
          <addressOffset>0x00</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000000ff</resetMask>
          <fields>
            <field>
              <name>IRSEL</name>
              <description>Internal LCD Bias Dividing Resistor Selection bits</description>
              <bitRange>[07:06]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>RLCD3</name>
                  <description>RLCD3: 105/105/80[kohm] @(1/2)/(1/3)/(1/4) bias</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RLCD1</name>
                  <description>RLCD1: 10/10/10[kohm] @(1/2)/(1/3)/(1/4) bias</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RLCD2</name>
                  <description>RLCD2: 66/66/50[kohm] @(1/2)/(1/3)/(1/4) bias</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RLCD4</name>
                  <description>RLCD4: 320/320/240[kohm] @(1/2)/(1/3)/(1/4) bias</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DBS</name>
              <description>LCD Duty and Bias Selection bits</description>
              <bitRange>[05:03]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DUTY8_BIAS4</name>
                  <description>1/8 duty, 1/4 bias</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DUTY6_BIAS4</name>
                  <description>1/6 duty, 1/4 bias</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DUTY5_BIAS3</name>
                  <description>1/5 duty, 1/3 bias</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DUTY4_BIAS3</name>
                  <description>1/4 duty, 1/3 bias</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DUTY3_BIAS3</name>
                  <description>1/3 duty, 1/3 bias</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DUTY3_BIAS2</name>
                  <description>1/3 duty, 1/2 bias</description>
                  <value>5</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>LCLK</name>
              <description>LCD Clock Selection bits (When fLCD = 32.768kHz)</description>
              <bitRange>[02:01]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>fLCD_128Hz</name>
                  <description>128Hz</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>fLCD_256Hz</name>
                  <description>256Hz</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>fLCD_512Hz</name>
                  <description>512Hz</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>fLCD_1024Hz</name>
                  <description>1024Hz</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DISP</name>
              <description>LCD Display Control bit</description>
              <bitRange>[00:00]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DISPLAY_OFF</name>
                  <description>Display off</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DISPLAY_ON</name>
                  <description>Normal display on</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <!--BCCR : LCD Automatic Bias and Contrast Control Register. Notes: 1. The above LCD contrast step is based on 1/3 bias with 66kohm RLCD and on 1/4 bias with 50kohm RLCD 2. The "LCD driver contrast control" is disabled during the LCDABC bit (LCD automatic bias) is set to "1b".-->
        <register>
          <name>BCCR</name>
          <description>LCD Automatic Bias and Contrast Control Register. Notes: 1. The above LCD contrast step is based on 1/3 bias with 66kohm RLCD and on 1/4 bias with 50kohm RLCD 2. The "LCD driver contrast control" is disabled during the LCDABC bit (LCD automatic bias) is set to "1b".</description>
          <addressOffset>0x04</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000172f</resetMask>
          <fields>
            <field>
              <name>LCDABC</name>
              <description>LCD Automatic Bias Control bit</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>LCD_AUTO_BIAS_OFF</name>
                  <description>LCD automatic bias is off</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LCD_AUTO_BIAS_ON</name>
                  <description>LCD automatic bias is on</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BMSEL</name>
              <description>"Bias Mode A" fsTime Selection bits</description>
              <bitRange>[10:08]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>000</name>
                  <description>"Bias Mode A" for 1-clock of fLCD</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>001</name>
                  <description>"Bias Mode A" for 2-clock of fLCD</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>010</name>
                  <description>"Bias Mode A" for 3-clock of fLCD</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>011</name>
                  <description>"Bias Mode A" for 4-clock of fLCD</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>100</name>
                  <description>"Bias Mode A" for 5-clock of fLCD</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>101</name>
                  <description>"Bias Mode A" for 6-clock of fLCD</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>110</name>
                  <description>"Bias Mode A" for 7-clock of fLCD</description>
                  <value>6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>111</name>
                  <description>"Bias Mode A" for 8-clock of fLCD</description>
                  <value>7</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>LCTEN</name>
              <description>LCD Driver Contrast Control bit</description>
              <bitRange>[05:05]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>0</name>
                  <description>Disable LCD driver contrast</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>1</name>
                  <description>Enable LCD driver contrast</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>VLCD</name>
              <description>VLC0 Voltage Control when the contrast is enabled</description>
              <bitRange>[03:00]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>0000</name>
                  <description>VDD x 16/31 step</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>0001</name>
                  <description>VDD x 16/30 step</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>0010</name>
                  <description>VDD x 16/29 step</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>0011</name>
                  <description>VDD x 16/28 step</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>0100</name>
                  <description>VDD x 16/27 step</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>0101</name>
                  <description>VDD x 16/26 step</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>0110</name>
                  <description>VDD x 16/25 step</description>
                  <value>6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>0111</name>
                  <description>VDD x 16/24 step</description>
                  <value>7</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>1000</name>
                  <description>VDD x 16/23 step</description>
                  <value>8</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>1001</name>
                  <description>VDD x 16/22 step</description>
                  <value>9</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>1010</name>
                  <description>VDD x 16/21 step</description>
                  <value>10</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>1011</name>
                  <description>VDD x 16/20 step</description>
                  <value>11</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>1100</name>
                  <description>VDD x 16/19 step</description>
                  <value>12</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>1101</name>
                  <description>VDD x 16/18 step</description>
                  <value>13</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>1110</name>
                  <description>VDD x 16/17 step</description>
                  <value>14</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>1111</name>
                  <description>VDD x 16/16 step</description>
                  <value>15</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <!--BSSR : LCD Bias Source Selection Register is 32-bit register.-->
        <register>
          <name>BSSR</name>
          <description>LCD Bias Source Selection Register is 32-bit register.</description>
          <addressOffset>0x0C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000003F0</resetMask>
          <fields>
            <field>
              <name>LCDDR</name>
              <description>LCD Driving Resistor for Bias Select</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LCDEPEN</name>
              <description>LCD External Bias Path Enable bit</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>VLC3EN</name>
              <description>Extenal Bias VLC3 Enable bit</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>VLC2EN</name>
              <description>Extenal Bias VLC2 Enable bit</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>VLC1EN</name>
              <description>Extenal Bias VLC1 Enable bit</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>VLC0EN</name>
              <description>Extenal Bias VLC0 Enable bit</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <!--DR0 : LCD Display Data Register 0-->
        <register>
          <name>DR0</name>
          <description>LCD Display Data Register 0</description>
          <addressOffset>0x10</addressOffset>
          <size>8</size>
          <access>read-write</access>
          <resetValue>0x00</resetValue>
          <resetMask>0xff</resetMask>
        </register>
        <!--DR1 : LCD Display Data Register 1-->
        <register>
          <name>DR1</name>
          <description>LCD Display Data Register 1</description>
          <addressOffset>0x11</addressOffset>
          <size>8</size>
          <access>read-write</access>
          <resetValue>0x00</resetValue>
          <resetMask>0xff</resetMask>
        </register>
        <!--DR2 : LCD Display Data Register 2-->
        <register>
          <name>DR2</name>
          <description>LCD Display Data Register 2</description>
          <addressOffset>0x12</addressOffset>
          <size>8</size>
          <access>read-write</access>
          <resetValue>0x00</resetValue>
          <resetMask>0xff</resetMask>
        </register>
        <!--DR3 : LCD Display Data Register 3-->
        <register>
          <name>DR3</name>
          <description>LCD Display Data Register 3</description>
          <addressOffset>0x13</addressOffset>
          <size>8</size>
          <access>read-write</access>
          <resetValue>0x00</resetValue>
          <resetMask>0xff</resetMask>
        </register>
        <!--DR4 : LCD Display Data Register 4-->
        <register>
          <name>DR4</name>
          <description>LCD Display Data Register 4</description>
          <addressOffset>0x14</addressOffset>
          <size>8</size>
          <access>read-write</access>
          <resetValue>0x00</resetValue>
          <resetMask>0xff</resetMask>
        </register>
        <!--DR5 : LCD Display Data Register 5-->
        <register>
          <name>DR5</name>
          <description>LCD Display Data Register 5</description>
          <addressOffset>0x15</addressOffset>
          <size>8</size>
          <access>read-write</access>
          <resetValue>0x00</resetValue>
          <resetMask>0xff</resetMask>
        </register>
        <!--DR6 : LCD Display Data Register 6-->
        <register>
          <name>DR6</name>
          <description>LCD Display Data Register 6</description>
          <addressOffset>0x16</addressOffset>
          <size>8</size>
          <access>read-write</access>
          <resetValue>0x00</resetValue>
          <resetMask>0xff</resetMask>
        </register>
        <!--DR7 : LCD Display Data Register 7-->
        <register>
          <name>DR7</name>
          <description>LCD Display Data Register 7</description>
          <addressOffset>0x17</addressOffset>
          <size>8</size>
          <access>read-write</access>
          <resetValue>0x00</resetValue>
          <resetMask>0xff</resetMask>
        </register>
        <!--DR8 : LCD Display Data Register 8-->
        <register>
          <name>DR8</name>
          <description>LCD Display Data Register 8</description>
          <addressOffset>0x18</addressOffset>
          <size>8</size>
          <access>read-write</access>
          <resetValue>0x00</resetValue>
          <resetMask>0xff</resetMask>
        </register>
        <!--DR9 : LCD Display Data Register 9-->
        <register>
          <name>DR9</name>
          <description>LCD Display Data Register 9</description>
          <addressOffset>0x19</addressOffset>
          <size>8</size>
          <access>read-write</access>
          <resetValue>0x00</resetValue>
          <resetMask>0xff</resetMask>
        </register>
        <!--DR10 : LCD Display Data Register 10-->
        <register>
          <name>DR10</name>
          <description>LCD Display Data Register 10</description>
          <addressOffset>0x1a</addressOffset>
          <size>8</size>
          <access>read-write</access>
          <resetValue>0x00</resetValue>
          <resetMask>0xff</resetMask>
        </register>
        <!--DR11 : LCD Display Data Register 11-->
        <register>
          <name>DR11</name>
          <description>LCD Display Data Register 11</description>
          <addressOffset>0x1b</addressOffset>
          <size>8</size>
          <access>read-write</access>
          <resetValue>0x00</resetValue>
          <resetMask>0xff</resetMask>
        </register>
        <!--DR12 : LCD Display Data Register 12-->
        <register>
          <name>DR12</name>
          <description>LCD Display Data Register 12</description>
          <addressOffset>0x1c</addressOffset>
          <size>8</size>
          <access>read-write</access>
          <resetValue>0x00</resetValue>
          <resetMask>0xff</resetMask>
        </register>
        <!--DR13 : LCD Display Data Register 13-->
        <register>
          <name>DR13</name>
          <description>LCD Display Data Register 13</description>
          <addressOffset>0x1d</addressOffset>
          <size>8</size>
          <access>read-write</access>
          <resetValue>0x00</resetValue>
          <resetMask>0xff</resetMask>
        </register>
        <!--DR14 : LCD Display Data Register 14-->
        <register>
          <name>DR14</name>
          <description>LCD Display Data Register 14</description>
          <addressOffset>0x1e</addressOffset>
          <size>8</size>
          <access>read-write</access>
          <resetValue>0x00</resetValue>
          <resetMask>0xff</resetMask>
        </register>
        <!--DR15 : LCD Display Data Register 15-->
        <register>
          <name>DR15</name>
          <description>LCD Display Data Register 15</description>
          <addressOffset>0x1f</addressOffset>
          <size>8</size>
          <access>read-write</access>
          <resetValue>0x00</resetValue>
          <resetMask>0xff</resetMask>
        </register>
        <!--DR16 : LCD Display Data Register 16-->
        <register>
          <name>DR16</name>
          <description>LCD Display Data Register 16</description>
          <addressOffset>0x20</addressOffset>
          <size>8</size>
          <access>read-write</access>
          <resetValue>0x00</resetValue>
          <resetMask>0xff</resetMask>
        </register>
        <!--DR17 : LCD Display Data Register 17-->
        <register>
          <name>DR17</name>
          <description>LCD Display Data Register 17</description>
          <addressOffset>0x21</addressOffset>
          <size>8</size>
          <access>read-write</access>
          <resetValue>0x00</resetValue>
          <resetMask>0xff</resetMask>
        </register>
        <!--DR18 : LCD Display Data Register 18-->
        <register>
          <name>DR18</name>
          <description>LCD Display Data Register 18</description>
          <addressOffset>0x22</addressOffset>
          <size>8</size>
          <access>read-write</access>
          <resetValue>0x00</resetValue>
          <resetMask>0xff</resetMask>
        </register>
        <!--DR19 : LCD Display Data Register 19-->
        <register>
          <name>DR19</name>
          <description>LCD Display Data Register 19</description>
          <addressOffset>0x23</addressOffset>
          <size>8</size>
          <access>read-write</access>
          <resetValue>0x00</resetValue>
          <resetMask>0xff</resetMask>
        </register>
        <!--DR20 : LCD Display Data Register 20-->
        <register>
          <name>DR20</name>
          <description>LCD Display Data Register 20</description>
          <addressOffset>0x24</addressOffset>
          <size>8</size>
          <access>read-write</access>
          <resetValue>0x00</resetValue>
          <resetMask>0xff</resetMask>
        </register>
        <!--DR21 : LCD Display Data Register 21-->
        <register>
          <name>DR21</name>
          <description>LCD Display Data Register 21</description>
          <addressOffset>0x25</addressOffset>
          <size>8</size>
          <access>read-write</access>
          <resetValue>0x00</resetValue>
          <resetMask>0xff</resetMask>
        </register>
        <!--DR22 : LCD Display Data Register 22-->
        <register>
          <name>DR22</name>
          <description>LCD Display Data Register 22</description>
          <addressOffset>0x26</addressOffset>
          <size>8</size>
          <access>read-write</access>
          <resetValue>0x00</resetValue>
          <resetMask>0xff</resetMask>
        </register>
        <!--DR23 : LCD Display Data Register 23-->
        <register>
          <name>DR23</name>
          <description>LCD Display Data Register 23</description>
          <addressOffset>0x27</addressOffset>
          <size>8</size>
          <access>read-write</access>
          <resetValue>0x00</resetValue>
          <resetMask>0xff</resetMask>
        </register>
        <!--DR24 : LCD Display Data Register 24-->
        <register>
          <name>DR24</name>
          <description>LCD Display Data Register 24</description>
          <addressOffset>0x28</addressOffset>
          <size>8</size>
          <access>read-write</access>
          <resetValue>0x00</resetValue>
          <resetMask>0xff</resetMask>
        </register>
        <!--DR25 : LCD Display Data Register 25-->
        <register>
          <name>DR25</name>
          <description>LCD Display Data Register 25</description>
          <addressOffset>0x29</addressOffset>
          <size>8</size>
          <access>read-write</access>
          <resetValue>0x00</resetValue>
          <resetMask>0xff</resetMask>
        </register>
        <!--DR26 : LCD Display Data Register 26-->
        <register>
          <name>DR26</name>
          <description>LCD Display Data Register 26</description>
          <addressOffset>0x2a</addressOffset>
          <size>8</size>
          <access>read-write</access>
          <resetValue>0x00</resetValue>
          <resetMask>0xff</resetMask>
        </register>
        <!--DR27 : LCD Display Data Register 27-->
        <register>
          <name>DR27</name>
          <description>LCD Display Data Register 27</description>
          <addressOffset>0x2b</addressOffset>
          <size>8</size>
          <access>read-write</access>
          <resetValue>0x00</resetValue>
          <resetMask>0xff</resetMask>
        </register>
      </registers>
    </peripheral>
    <!--LED-->
    <peripheral>
      <name>LED</name>
      <version>1.0</version>
      <description>LED DRIVER/CONTROLLER</description>
      <groupName>LED</groupName>
      <baseAddress>0x40006000</baseAddress>
      <size>32</size>
      <access>read-write</access>
      <addressBlock>
        <offset>0</offset>
        <size>0x044</size>
        <usage>registers</usage>
      </addressBlock>
      <interrupt>
        <name>LED</name>
        <value>28</value>
      </interrupt>
      <registers>
        <!--COMOE : COM Output Enable Register-->
        <register>
          <name>COMOE</name>
          <description>COM Output Enable Register</description>
          <addressOffset>0x00</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>COMOE4</name>
              <description>Port Mode Select4</description>
              <bitOffset>24</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>COMOE3</name>
              <description>Port Mode Select3</description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>COMOE2</name>
              <description>Port Mode Select2</description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>COMOE1</name>
              <description>Port Mode Select1</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <!--SEGOE : SEG Output Enable Register-->
        <register>
          <name>SEGOE</name>
          <description>SEG Output Enable Register</description>
          <addressOffset>0x04</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>SEGOE2</name>
              <description>Port Mode Select2</description>
              <bitOffset>8</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SEGOE1</name>
              <description>Port Mode Select1</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <!--PRESD : LED Prescaler Data Register-->
        <register>
          <name>PRESD</name>
          <description>LED Prescaler Data Register</description>
          <addressOffset>0x08</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>PRESD</name>
              <description>Pre-scale value of LED clock
LED Clock = fCLK/(PRESD + 1)
(fCLK is a selected input clock)</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <!--COMER : COM EnableRegister-->
        <register>
          <name>COMER</name>
          <description>COM EnableRegister</description>
          <addressOffset>0x0c</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>COM26</name>
              <description>Only Selected COM of COM0 and COM26 is active.</description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>COM25</name>
              <description>Only Selected COM of COM0 and COM26 is active.</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>COM24</name>
              <description>Only Selected COM of COM0 and COM26 is active.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>COM23</name>
              <description>Only Selected COM of COM0 and COM26 is active.</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>COM22</name>
              <description>Only Selected COM of COM0 and COM26 is active.</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>COM21</name>
              <description>Only Selected COM of COM0 and COM26 is active.</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>COM20</name>
              <description>Only Selected COM of COM0 and COM26 is active.</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>COM19</name>
              <description>Only Selected COM of COM0 and COM26 is active.</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>COM18</name>
              <description>Only Selected COM of COM0 and COM26 is active.</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>COM17</name>
              <description>Only Selected COM of COM0 and COM26 is active.</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>COM16</name>
              <description>Only Selected COM of COM0 and COM26 is active.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>COM15</name>
              <description>Only Selected COM of COM0 and COM26 is active.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>COM14</name>
              <description>Only Selected COM of COM0 and COM26 is active.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>COM13</name>
              <description>Only Selected COM of COM0 and COM26 is active.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>COM12</name>
              <description>Only Selected COM of COM0 and COM26 is active.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>COM11</name>
              <description>Only Selected COM of COM0 and COM26 is active.</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>COM10</name>
              <description>Only Selected COM of COM0 and COM26 is active.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>COM9</name>
              <description>Only Selected COM of COM0 and COM26 is active.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>COM8</name>
              <description>Only Selected COM of COM0 and COM26 is active.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>COM7</name>
              <description>Only Selected COM of COM0 and COM26 is active.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>COM6</name>
              <description>Only Selected COM of COM0 and COM26 is active.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>COM5</name>
              <description>Only Selected COM of COM0 and COM26 is active.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>COM4</name>
              <description>Only Selected COM of COM0 and COM26 is active.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>COM3</name>
              <description>Only Selected COM of COM0 and COM26 is active.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>COM2</name>
              <description>Only Selected COM of COM0 and COM26 is active.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>COM1</name>
              <description>Only Selected COM of COM0 and COM26 is active.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>COM0</name>
              <description>Only Selected COM of COM0 and COM26 is active.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <!--COMPWID : COM Pulse Width Control Register-->
        <register>
          <name>COMPWID</name>
          <description>COM Pulse Width Control Register</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>COMPWID</name>
              <description>COM Pulse Width Control bits
COM Width= LED CLK/(COMPWID + 1)
(LED CLK is Prescaler output clock)</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <!--DIMM0 : COM Dimming Control Register0-->
        <register>
          <name>DIMM0</name>
          <description>COM Dimming Control Register0</description>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>COMDIMM3</name>
              <description>COM3 Dimming Control bits
Dimmed COM Width = COM Width - Overlaptime - LEDCLK*COMDIMM3</description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>COMDIMM2</name>
              <description>COM2 Dimming Control bits
Dimmed COM Width = COM Width - Overlaptime- LEDCLK*COMDIMM2</description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>COMDIMM1</name>
              <description>COM1 Dimming Control bits
Dimmed COM Width = COM Width - Overlaptime - LEDCLK*COMDIMM1</description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>COMDIMM0</name>
              <description>COM0 Dimming Control bits
Dimmed COM Width = COM Width - Overlaptime - LEDCLK*COMDIMM0</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <!--DIMM1 : COM Dimming Control Register1-->
        <register>
          <name>DIMM1</name>
          <description>COM Dimming Control Register1</description>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>COMDIMM7</name>
              <description>COM7 Dimming Control bits
Dimmed COM Width = COM Width - Overlaptime - LEDCLK*COMDIMM7</description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>COMDIMM6</name>
              <description>COM6 Dimming Control bits
Dimmed COM Width = COM Width - Overlaptime - LEDCLK*COMDIMM6</description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>COMDIMM5</name>
              <description>COM5 Dimming Control bits
Dimmed COM Width = COM Width - Overlaptime - LEDCLK*COMDIMM5</description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>COMDIMM4</name>
              <description>COM4 Dimming Control bits
Dimmed COM Width = COM Width - Overlaptime - LEDCLK*COMDIMM4</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <!--DIMM2 : COM Dimming Control Register2-->
        <register>
          <name>DIMM2</name>
          <description>COM Dimming Control Register2</description>
          <addressOffset>0x1c</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>COMDIMM11</name>
              <description>COM11 Dimming Control bits
Dimmed COM Width = COM Width - Overlaptime - LEDCLK*COMDIMM11</description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>COMDIMM10</name>
              <description>COM10 Dimming Control bits
Dimmed COM Width = COM Width - Overlaptime - LEDCLK*COMDIMM10</description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>COMDIMM9</name>
              <description>COM9 Dimming Control bits
Dimmed COM Width = COM Width - Overlaptime - LEDCLK*COMDIMM9</description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>COMDIMM8</name>
              <description>COM8 Dimming Control bits
Dimmed COM Width = COM Width - Overlaptime - LEDCLK*COMDIMM8</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <!--DIMM3 : COM Dimming Control Register3-->
        <register>
          <name>DIMM3</name>
          <description>COM Dimming Control Register3</description>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>COMDIMM15</name>
              <description>COM15 Dimming Control bits
Dimmed COM Width = COM Width - Overlaptime - LEDCLK*COMDIMM15</description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>COMDIMM14</name>
              <description>COM14 Dimming Control bits
Dimmed COM Width = COM Width - Overlaptime - LEDCLK*COMDIMM14</description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>COMDIMM13</name>
              <description>COM13 Dimming Control bits
Dimmed COM Width = COM Width - Overlaptime - LEDCLK*COMDIMM13</description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>COMDIMM12</name>
              <description>COM12 Dimming Control bits
Dimmed COM Width = COM Width - Overlaptime - LEDCLK*COMDIMM12</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <!--DIMM4 : COM Dimming Control Register4-->
        <register>
          <name>DIMM4</name>
          <description>COM Dimming Control Register4</description>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>COMDIMM19</name>
              <description>COM19 Dimming Control bits
Dimmed COM Width = COM Width - Overlaptime - LEDCLK*COMDIMM19</description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>COMDIMM18</name>
              <description>COM18 Dimming Control bits
Dimmed COM Width = COM Width - Overlaptime - LEDCLK*COMDIMM18</description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>COMDIMM17</name>
              <description>COM17 Dimming Control bits
Dimmed COM Width = COM Width - Overlaptime - LEDCLK*COMDIMM17</description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>COMDIMM16</name>
              <description>COM16 Dimming Control bits
Dimmed COM Width = COM Width - Overlaptime - LEDCLK*COMDIMM16</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <!--DIMM5 : COM Dimming Control Register5-->
        <register>
          <name>DIMM5</name>
          <description>COM Dimming Control Register5</description>
          <addressOffset>0x28</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>COMDIMM23</name>
              <description>COM23 Dimming Control bits
Dimmed COM Width = COM Width - Overlaptime - LEDCLK*COMDIMM23</description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>COMDIMM22</name>
              <description>COM22 Dimming Control bits
Dimmed COM Width = COM Width - Overlaptime - LEDCLK*COMDIMM22</description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>COMDIMM21</name>
              <description>COM21 Dimming Control bits
Dimmed COM Width = COM Width - Overlaptime - LEDCLK*COMDIMM21</description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>COMDIMM20</name>
              <description>COM20 Dimming Control bits
Dimmed COM Width = COM Width - Overlaptime - LEDCLK*COMDIMM20</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <!--DIMM6 : COM Dimming Control Register6-->
        <register>
          <name>DIMM6</name>
          <description>COM Dimming Control Register0</description>
          <addressOffset>0x2C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>COMDIMM26</name>
              <description>COM26 Dimming Control bits
Dimmed COM Width = COM Width - Overlaptime - LEDCLK*COMDIMM26</description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>COMDIMM25</name>
              <description>COM25 Dimming Control bits
Dimmed COM Width = COM Width - Overlaptime - LEDCLK*COMDIMM25</description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>COMDIMM24</name>
              <description>COM24 Dimming Control bits
Dimmed COM Width = COM Width - Overlaptime - LEDCLK*COMDIMM24</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <!--STPD : LED STOP Duration Register-->
        <register>
          <name>STPD</name>
          <description>LED STOP Duration Register</description>
          <addressOffset>0x30</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>LEDSTPD</name>
              <description>LED STOP Duration Register (since LED Start)</description>
              <bitOffset>0</bitOffset>
              <bitWidth>20</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <!--SR : LED STATUS Register-->
        <register>
          <name>SR</name>
          <description>LED STATUS Register</description>
          <addressOffset>0x34</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000001</resetValue>
          <fields>
            <field>
              <name>MATCHF</name>
              <description>Flag to occur when LEDSTPD reg match with counter</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>LED_INT</name>
              <description>LED Interrupt Flag(in LED_INTE=1)</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>LED_INTE</name>
              <description>LED Interrupt Enable</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>LED_ENDF</name>
              <description>LED Operation End Flag</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <!--CON2 : LED Control Register2-->
        <register>
          <name>CON2</name>
          <description>LED Control Register2</description>
          <addressOffset>0x38</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>COM_SEGN</name>
              <description>COM &amp; SEG Share Pin Select</description>
              <bitOffset>4</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OVERLAP</name>
              <description>OVERLAP TIME Select</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OVERTS</name>
              <description>OVERLAP TIME Select</description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <!--CON2 : LED Control Register2-->
        <register>
          <name>CON1</name>
          <description>LED Control Register1</description>
          <addressOffset>0x3c</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>MD</name>
              <description>Mode Select</description>
              <bitOffset>2</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>LEDEN</name>
              <description>LED Enable</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>LEDST</name>
              <description>LED START, STOP Operation</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <!--CRC-->
    <peripheral>
      <name>CRC</name>
      <version>1.0</version>
      <description>CYCLIC REDUNDANCY CHECK AND CHECKSUM</description>
      <groupName>CRC</groupName>
      <baseAddress>0x40000300</baseAddress>
      <size>32</size>
      <access>read-write</access>
      <addressBlock>
        <offset>0</offset>
        <size>0x020</size>
        <usage>registers</usage>
      </addressBlock>
      <interrupt>
        <name>COMP_CRC</name>
        <value>31</value>
      </interrupt>
      <registers>
        <!--CR : CRC/Checksum Control Register.-->
        <register>
          <name>CR</name>
          <description>CRC/Checksum Control Register. Notes: 1. The CRCRLT register and the CRC/Checksum block should be initialized by writing "1b" to the RLTCLR bit before a new CRC/Checksum calculation. 2. The CRCRUN bit should be set to "1b" last time after setting appropriate values to the registers. 3. On the user mode, it will be calculated every writing data to the CRCIN register during CRCRUN==1. 4. On the user mode with SARINC==0, the block is finished by writing "0b" to the CRCRUN bit. 4. It is prohibited writing any data to the CRCIN register during CRCRUN==0. 5. The checksum is calculated by byte unit. Ex) On 0x34A7E991, CRCRLT = 0x34 + 0xA7 + 0xE9 + 0x91.</description>
          <addressOffset>0x00</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>CRCINTEN</name>
              <description>CRC interrupt enable bit</description>
              <bitRange>[09:09]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CRCINTF</name>
              <description>CRC interrupt flag bit</description>
              <bitRange>[08:08]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MODS</name>
              <description>User/Auto Mode Selection bit</description>
              <bitRange>[07:07]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RLTCLR</name>
              <description>CRC/Checksum Result Data Register (CRCRLT) Initialization bit</description>
              <bitRange>[06:06]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MDSEL</name>
              <description>CRC/Checksum Selection bit</description>
              <bitRange>[05:05]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>POLYS</name>
              <description>Polynomial Selection bit (CRC only)</description>
              <bitRange>[04:04]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FIRSTBS</name>
              <description>First Shifted-in Selection bit (CRC only)</description>
              <bitRange>[01:01]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CRCRUN</name>
              <description>CRC/Checksum Start Control and Busy bit</description>
              <bitRange>[00:00]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <!--IN : CRC/Checksum Input Data Register-->
        <register>
          <name>IN</name>
          <description>CRC/Checksum Input Data Register</description>
          <addressOffset>0x04</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
        </register>
        <!--RLT : CRC/Checksum Result Data Register-->
        <register>
          <name>RLT</name>
          <description>CRC/Checksum Result Data Register</description>
          <addressOffset>0x08</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0000ffff</resetValue>
        </register>
        <!--INIT : CRC/Checksum Initial Data Register-->
        <register>
          <name>INIT</name>
          <description>CRC/Checksum Initial Data Register</description>
          <addressOffset>0x0c</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
        </register>
      </registers>
    </peripheral>
    <!--USB-->
    <peripheral>
      <name>USB</name>
      <version>1.0</version>
      <description>USB</description>
      <groupName>USB</groupName>
      <baseAddress>0x50000000</baseAddress>
      <size>32</size>
      <access>read-write</access>
      <addressBlock>
        <offset>0</offset>
        <size>0xe04</size>
        <usage>registers</usage>
      </addressBlock>
      <interrupt>
        <name>USB</name>
        <value>30</value>
      </interrupt>
      <registers>
        <!--GOTGCTL : Control and Status Register -->
        <register>
          <name>GOTGCTL</name>
          <description>Interrupt Source Mask Register</description>
          <addressOffset>0x00</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>MultValIdBC</name>
              <description>Multi Valued ID pin (MultValIdBC)</description>
              <bitOffset>22</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <!--GOTGINT : Interrupt Register-->
        <register>
          <name>GOTGINT</name>
          <description>Interrupt Register</description>
          <addressOffset>0x04</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>MultValIpChng</name>
              <description>This bit when set indicates that there is a change in the value of at least one ACA pin value.</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <!--GAHBCFG : AHB Configuration Register-->
        <register>
          <name>GAHBCFG</name>
          <description>AHB Configuration Register</description>
          <addressOffset>0x08</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>InvDescEndianes</name>
              <description>Invert Descriptor Endianess (InvDescEndianess)</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>AHBSingle</name>
              <description>AHB Single Support (AHBSingle)
This bit when programmed supports Single transfers for the remaining data in a transfer when the core is operating in DMA mode.</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>NotiAllDmaWrit</name>
              <description>Notify All Dma Write Transactions (NotiAllDmaWrit)
This bit is programmed to enable the System DMA Done functionality for all the DMA write Transactions corresponding to the Channel/Endpoint. This bit is valid only when GAHBCFG.RemMemSupp is set to 1.</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RemMemSupp</name>
              <description>Remote Memory Support (RemMemSupp)
This bit is programmed to enable the functionality to wait for the system DMA Done Signal for the DMA Write Transfers.</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DMAEn</name>
              <description>DMA Enable (DMAEn)</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>HbstLen</name>
              <description>Burst Length/Type (HbstLen)</description>
              <bitOffset>1</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GlblIntrMsk</name>
              <description>Global Interrupt Mask (GlblIntrMsk)
The application uses this bit to mask or unmask the interrupt line assertion to itself. Irrespective of this bit's setting, the interrupt status registers are updated by the controller.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <!--GUSBCFG : USB Configuration Register-->
        <register>
          <name>GUSBCFG</name>
          <description>USB Configuration Register</description>
          <addressOffset>0x0c</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>CorruptTxPkt</name>
              <description>Corrupt Tx packet (CorruptTxPkt)
This bit is for debug purposes only. Never Set this bit to 1. The application should always write 1'b0 to this bit.</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PHYSel</name>
              <description>USB 1.1 Full-Speed Serial Transceiver Select (PHYSel)</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FSIntf</name>
              <description>Full-Speed Serial Interface Select (FSIntf)
The application uses this bit to select either a unidirectional or bidirectional USB 1.1 full-speed serial transceiver interface.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ToutCal</name>
              <description>FS Timeout Calibration (ToutCal)
The number of PHY clocks that the application programs in this field is added to the full-speed interpacket timeout duration in the core to account for any additional delays introduced by the PHY. This can be required, because the delay introduced by the PHY in generating the linestate condition can vary from one PHY to another.
The USB standard timeout value for full-speed operation is 16 to 18 (inclusive) bit times. The application must program this field based on the speed of enumeration. The number of bit times added per PHY clock are as follows:
Full-speed operation:
-One 48-MHz PHY clock = 0.25 bit times</description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <!--GRSTCTL : Reset Register-->
        <register>
          <name>GRSTCTL</name>
          <description>Reset Register</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>AHBIdle</name>
              <description>AHB Master Idle (AHBIdle)
Indicates that the AHB Master State Machine is in the IDLE condition.</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DMAReq</name>
              <description>DMA Request Signal (DMAReq)
Indicates that the DMA request is in progress. Used for debug</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TxFNum</name>
              <description>TxFIFO Number (TxFNum)
This is the FIFO number that must be flushed using the TxFIFO Flush bit. This field must not be changed until the core clears the TxFIFO Flush bit.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TxFFlsh</name>
              <description>TxFIFO Flush (TxFFlsh)
This bit selectively flushes a single or all transmit FIFOs, but cannot do so If the core is in the midst of a transaction.
The application must write this bit only after checking that the core is neither writing to the TxFIFO nor reading from the TxFIFO.
Verify using these registers:
-ReadNAK Effective Interrupt ensures the core is not reading from the FIFO
-WriteGRSTCTL.AHBIdle ensures the core is not writing anything to the FIFO.
Flushing is normally recommended when FIFOs are reconfigured or when switching between Shared FIFO and Dedicated Transmit FIFO operation. FIFO flushing is also recommended during device endpoint disable. The application must wait until the core clears this bit before performing any operations. This bit takes eight clocks to clear, using the slower clock of phy_clk or hclk.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RxFFlsh</name>
              <description>RxFIFO Flush (RxFFlsh)
The application can flush the entire RxFIFO using this bit, but must first ensure that the core is not in the middle of a transaction.
The application must only write to this bit after checking that the controller is neither reading from the RxFIFO nor writing to the RxFIFO.
The application must wait until the bit is cleared before performing any other operations. This bit requires eight clocks (slowest of PHY or AHB clock) to clear.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PIUFSSftRst</name>
              <description>PIU FS Dedicated Controller Soft Reset (PIUFSSftRst)
Resets the PIU FS Dedicated Controller
All module state machines in FS Dedicated Controller of PIU are reset to the IDLE state. Used to reset the FS Dedicated controller in PIU in case of any PHY Errors like Loss of activity or Babble Error resulting in the PHY remaining in RX state for more than one frame boundary.
This is a self clearing bit and core clears this bit after all the necessary logic is reset in the core.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CSftRst</name>
              <description>Core Soft Reset (CSftRst)
Resets the hclk and phy_clock domains as follows:
+ Clears the interrupts and all the CSR registers except the following register bits:
-PCGCCTL.RstPdwnModule
-PCGCCTL.GateHclk
-PCGCCTL.PwrClmp
-PCGCCTL.StopPPhyLPwrClkSelclk
-GUSBCFG.PhyLPwrClkSel
-GUSBCFG.FSIntf
-GGPIO
-GPWRDN
-HCFG.FSLSPclkSel
-DCFG.DevSpd
-DCTL.SftDiscon
+ All module state machines
+ All module state machines (except the AHB Slave Unit) are reset to the IDLE state, and all the transmit FIFOs and the receive FIFO are flushed.
+ Any transactions on the AHB Master are terminated as soon as possible, after gracefully completing the last data phase of an AHB transfer. Any transactions on the USB are terminated immediately.
+ When Hibernation feature is enabled, the PMU module is not reset by the Core Soft Reset.
The application can write to this bit any time it wants to reset the core. This is a self-clearing bit and the core clears this bit after all the necessary logic is reset in the core, which can take several clocks, depending on the current state of the core. Once this bit is cleared software must wait at least 3 PHY clocks before doing any access to the PHY domain (synchronization delay). Software must also must check that bit 31 of this register is 1 (AHB Master is IDLE) before starting any operation.
Typically software reset is used during software development and also when you dynamically change the PHY selection bits in the USB configuration registers listed above. When you change the PHY, the corresponding clock for the PHY is selected and used in the PHY domain. Once a new clock is selected, the PHY domain has to be reset for proper operation.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <!--GINTSTS : Interrupt Register-->
        <register>
          <name>GINTSTS</name>
          <description>Interrupt Register</description>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>WkUpInt</name>
              <description>Resume/Remote Wakeup Detected Interrupt (WkUpInt)
Wakeup Interrupt during Suspend(L2) or LPM(L1) state.
+ During Suspend(L2):
-This interrupt is asserted only when Host Initiated Resume is detected on USB.
For more information, see 'Partial Power-Down and Clock Gating Programming Model' in the Programming Guide.
+ During LPM(L1):
-This interrupt is asserted for either Host Initiated Resume or Device Initiated Remote Wakeup on USB.
For more information, see 'LPM Entry and Exit Programming Model' in the Programming Guide.</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>LPM_Int</name>
              <description>LPM Transaction Received Interrupt (LPM_Int). This interrupt is asserted when the device receives an LPM transaction and responds with a non-ERRORed response. Has completed LPM transactions for the programmed number of times (GLPMCFG.RetryCnt).</description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ResetDet</name>
              <description>Reset detected Interrupt (ResetDet)
In Device mode, this interrupt is asserted when a reset is detected on the USB in partial power-down mode when the device is in Suspend.</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FetSusp</name>
              <description>Data Fetch Suspended (FetSusp)
This interrupt is valid only in DMA mode. This interrupt indicates that the core has stopped fetching data for IN endpoints due to the unavailability of TxFIFO space or Request Queue space. This interrupt is used by the application for an endpoint mismatch algorithm.
For example, after detecting an endpoint mismatch, the application:
+ Sets a Global non-periodic IN NAK handshake
+ Disables In endpoints
+ Flushes the FIFO
+ Determines the token sequence from the IN Token Sequence Learning Queue
+ Re-enables the endpoints
+ Clears the Global non-periodic IN NAK handshake
If the Global non-periodic IN NAK is cleared, the core has not yet fetched data for the IN endpoint, and the IN token is received. The core generates an 'IN token received when FIFO empty' interrupt. The OTG Then sends the host a NAK response. To avoid this scenario, the application can check the GINTSTS.FetSusp interrupt, which ensures that the FIFO is full before clearing a Global NAK handshake.
Alternatively, the application can mask the IN token received when FIFO empty interrupt when clearing a Global IN NAK handshake.</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OEPInt</name>
              <description>OUT Endpoints Interrupt (OEPInt)
The controller sets this bit to indicate that an interrupt is pending on one of the OUT endpoints of the core (in Device mode). The application must read the Device All Endpoints Interrupt (DAINT) register to determine the exact number of the OUT endpoint on which the interrupt occurred, and then read the corresponding Device OUT Endpoint-n Interrupt (DOEPINTn) register to determine the exact cause of the interrupt. The application must clear the appropriate status bit in the corresponding DOEPINTn register to clear this bit.</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>IEPInt</name>
              <description>IN Endpoints Interrupt (IEPInt)
The core sets this bit to indicate that an interrupt is pending on one of the IN endpoints of the core (in Device mode). The application must read the Device All Endpoints Interrupt (DAINT) register to determine the exact number of the IN endpoint on Device IN Endpoint-n Interrupt (DIEPINTn) register to determine the exact cause of the interrupt. The application must clear the appropriate status bit in the corresponding DIEPINTn register to clear this bit.</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EPMis</name>
              <description>Endpoint Mismatch Interrupt (EPMis)
Note: This interrupt is valid only in shared FIFO operation.
Indicates that an IN token has been received for a non-periodic endpoint, but the data for another endpoint is present in the top of the Non-periodic Transmit FIFO and the IN endpoint mismatch count programmed by the application has expired.</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RstrDoneInt</name>
              <description>Restore Done Interrupt (RstrDoneInt)
The controller sets this bit to indicate that the restore command after Hibernation was completed by the core.
The controller continues from Suspended state into the mode dictated by PCGCCTL.RestoreMode field.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EOPF</name>
              <description>End of Periodic Frame Interrupt (EOPF)
Indicates that the period specified in the Periodic Frame Interval field of the Device Configuration register (DCFG.PerFrInt) has been reached in the current microframe.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ISOOutDrop</name>
              <description>Isochronous OUT Packet Dropped Interrupt (ISOOutDrop)
The controller sets this bit when it fails to write an isochronous OUT packet into the RxFIFO because the RxFIFO does not have enough space to accommodate a maximum packet size packet for the isochronous OUT endpoint.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EnumDone</name>
              <description>Mode: Device only
Enumeration Done (EnumDone)
The core sets this bit to indicate that speed enumeration is complete. The application must read the Device Status (DSTS) register to obtain the enumerated speed.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>USBRst</name>
              <description>USB Reset (USBRst)
The controller sets this bit to indicate that a reset is detected on the USB.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>USBSusp</name>
              <description>USB Suspend (USBSusp)
The controller sets this bit to indicate that a suspend was detected on the USB. The controller enters the Suspended state when there is no activity on the linestate signal for an extended period of time.</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ErlySusp</name>
              <description>Early Suspend (ErlySusp)
The controller sets this bit to indicate that an Idle state has been detected on the USB for 3 ms.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GOUTNakEff</name>
              <description>Global OUT NAK Effective (GOUTNakEff)
Indicates that the Set Global OUT NAK bit in the Device Control register (DCTL.SGOUTNak), Set by the application, has taken effect in the core. This bit can be cleared by writing the Clear Global OUT NAK bit in the Device Control register (DCTL.CGOUTNak).</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GINNakEff</name>
              <description>Global IN Non-periodic NAK Effective (GINNakEff)
Indicates that the Set Global Non-periodic IN NAK bit in the Device Control register (DCTL.SGNPInNak) set by the application, has taken effect in the core. That is, the core has sampled the Global IN NAK bit Set by the application. This bit can be cleared by clearing the Clear Global Non-periodic IN NAK bit in the Device Control register (DCTL.CGNPInNak). This interrupt does not necessarily mean that a NAK handshake is sent out on the USB. The STALL bit takes precedence over the NAK bit.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RxFLvl</name>
              <description>RxFIFO Non-Empty (RxFLvl)
Indicates that there is at least one packet pending to be read from the RxFIFO.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>Sof</name>
              <description>Start of (micro)Frame (Sof)
In Device mode, the controller sets this bit to indicate that an SOF token has been received on the USB. The application can read the Device Status register to get the current (micro)Frame number. This interrupt is seen only when the core is operating at FS. This bit can be set only by the core and the application must write 1 to clear it.
Note: This register may return 1'b1 if read immediately after power-on reset. If the register bit reads 1'b1 immediately after power-on reset, it does not indicate that an SOF has been received. The read value of this interrupt is valid only after a valid connection between host and device is established. If the bit is set after power on reset the application can clear the bit.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <!--GINTMSK : Interrupt Mask Register-->
        <register>
          <name>GINTMSK</name>
          <description>Interrupt Mask Register</description>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>WkUpIntMsk</name>
              <description>Resume/Remote Wakeup Detected Interrupt Mask (WkUpIntMsk)
The WakeUp bit is used for LPM state wake up in a way similar to that of wake up in suspend state.</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>LPM_IntMsk</name>
              <description>LPM Transaction Received Interrupt (LPM_Int)
LPM Transaction received interrupt Mask</description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FetSuspMsk</name>
              <description>Data Fetch Suspended Mask (FetSuspMsk)</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OEPIntMsk</name>
              <description>Mode: Device only
OUT Endpoints Interrupt Mask (OEPIntMsk)</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>IEPIntMsk</name>
              <description>Mode: Device only
IN Endpoints Interrupt Mask (IEPIntMsk)</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EPMisMsk</name>
              <description>Mode: Device only
Endpoint Mismatch Interrupt Mask (EPMisMsk)</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RstrDoneIntMsk</name>
              <description>Restore Done Interrupt Mask (RstrDoneIntMsk)</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EOPFMsk</name>
              <description>Mode: Device only
End of Periodic Frame Interrupt Mask (EOPFMsk)</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ISOOutDropMsk</name>
              <description>Mode: Device only
Isochronous OUT Packet Dropped Interrupt Mask (ISOOutDropMsk)</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EnumDoneMsk</name>
              <description>Mode: Device only
Enumeration Done Mask (EnumDoneMsk)</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>USBRstMsk</name>
              <description>Mode: Device only
USB Reset Mask (USBRstMsk)</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>USBSuspMsk</name>
              <description>Mode: Device only
USB Suspend Mask (USBSuspMsk)</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ErlySuspMsk</name>
              <description>Mode: Device only
Early Suspend Mask (ErlySuspMsk)</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GOUTNakEffMsk</name>
              <description>Mode: Device only
Global OUT NAK Effective Mask (GOUTNakEffMsk)</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GINNakEffMsk</name>
              <description>Mode: Device only,
Global Non-periodic IN NAK Effective Mask (GINNakEffMsk)</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RxFLvlMsk</name>
              <description>Receive FIFO Non-Empty Mask (RxFLvlMsk)</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SofMsk</name>
              <description>Start of (micro)Frame Mask (SofMsk)</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OTGIntMsk</name>
              <description>OTG Interrupt Mask (OTGIntMsk)</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <!--GRXSTSR : Receive Status Debug Read Register-->
        <register>
          <name>GRXSTSR</name>
          <description>Receive Status Debug Read Register</description>
          <addressOffset>0x1c</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>FN</name>
              <description>Mode: Device only
Frame Number (FN)
This is the least significant 4 bits of the (micro)Frame number in which the packet is received on the USB. This field is supported only when isochronous OUT endpoints are supported.</description>
              <bitOffset>21</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PktSts</name>
              <description>Packet Status (PktSts)
Indicates the status of the received packet</description>
              <bitOffset>17</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>DPID</name>
              <description>Data PID (DPID)
Indicates the Data PID of the received OUT data packet</description>
              <bitOffset>15</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>BCnt</name>
              <description>Byte Count (BCnt)
Indicates the byte count of the received data packet.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>11</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>EPNum</name>
              <description>Endpoint Number (EPNum)
Indicates the endpoint number to which the current received packet belongs.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <!--GRXSTSP : Receive Status Read/Pop Register-->
        <register>
          <name>GRXSTSP</name>
          <description>Receive Status Read/Pop Register</description>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>FN</name>
              <description>Mode: Device only
Frame Number (FN)
This is the least significant 4 bits of the (micro)Frame number in which the packet is received on the USB. This field is supported only when isochronous OUT endpoints are supported.</description>
              <bitOffset>21</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PktSts</name>
              <description>Packet Status (PktSts)
Indicates the status of the received packet</description>
              <bitOffset>17</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>DPID</name>
              <description>Data PID (DPID)
Indicates the Data PID of the received OUT data packet</description>
              <bitOffset>15</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>BCnt</name>
              <description>Byte Count (BCnt)
Indicates the byte count of the received data packet.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>11</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>EPNum</name>
              <description>Endpoint Number (EPNum)
Indicates the endpoint number to which the current received packet belongs.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <!--GRXFSIZ : Receive FIFO Size Register-->
        <register>
          <name>GRXFSIZ</name>
          <description>Receive FIFO Size Register</description>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RxFDep</name>
              <description>RxFIFO Depth (RxFDep)
This value is in terms of 32-bit words.
+ Minimum value is 16
+ Maximum value is 32,768
The power-on reset value of this register is specified as the Largest Rx Data FIFO Depth during configuration.
You can write a new value in this field. Programmed values must not exceed the power-on value.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>11</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <!--GNPTXFSIZ : Non-periodic Transmit FIFO Size Register-->
        <register>
          <name>GNPTXFSIZ</name>
          <description>Non-periodic Transmit FIFO Size Register</description>
          <addressOffset>0x28</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>INEPTxF0Dep</name>
              <description>IN Endpoint TxFIFO 0 Depth (INEPTxF0Dep)
This value is in terms of 32-bit words.
+ Minimum value is 16
+ Maximum value is 32,768
The application can write a new value in this field. Programmed values must not exceed the power-on value set in coreConsultant. The power-on reset value of this field is specified during coreConsultant configuration as Largest IN Endpoint FIFO 0 Depth 
(parameter OTG_TX_DINEP_DFIFO_DEPTH_0).</description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>INEPTxF0StAddr</name>
              <description>IN Endpoint FIFO0 Transmit RAM Start Address(INEPTxF0StAddr)
This field contains the memory start address for IN Endpoint Transmit FIFO# 0.
Programmed values must not exceed the power-on value.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <!--GSNPSID : Synopsys ID Register-->
        <register>
          <name>GSNPSID</name>
          <description>Synopsys ID Register</description>
          <addressOffset>0x40</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>SynopsysID</name>
              <description>Release number of the controller being used currently.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <!--GHWCFG1 : User HW Config1 Register-->
        <register>
          <name>GHWCFG1</name>
          <description>User HW Config1 Register</description>
          <addressOffset>0x44</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>EpDir</name>
              <description>This 32-bit field uses two bits per endpoint to determine the endpoint direction.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <!--GHWCFG2 : User HW Config2 Register-->
        <register>
          <name>GHWCFG2</name>
          <description>User HW Config2 Register</description>
          <addressOffset>0x48</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>DynFifoSizing</name>
              <description>Dynamic FIFO Sizing Enabled (DynFifoSizing)</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>NumDevEps</name>
              <description>Number of Device Endpoints (NumDevEps)
Indicates the number of device endpoints supported by the core.
The range of this field is 0-4.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>FSPhyType</name>
              <description>Full-Speed PHY Interface Type (FSPhyType)</description>
              <bitOffset>8</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <!--GHWCFG3 : User HW Config3 Register-->
        <register>
          <name>GHWCFG3</name>
          <description>User HW Config3 Register</description>
          <addressOffset>0x4c</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>DfifoDepth</name>
              <description>DFIFO Depth (DfifoDepth - EP_LOC_CNT)
This value is in terms of 32-bit words.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>LPMMode</name>
              <description>LPM mode specified for Mode of Operation.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>BCSupport</name>
              <description>This bit indicates the controller support for Battery Charger.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RstType</name>
              <description>Reset Style for Clocked always Blocks in RTL (RstType)</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PktSizeWidth</name>
              <description>Width of Packet Size Counters (PktSizeWidth)</description>
              <bitOffset>4</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>XferSizeWidth</name>
              <description>Width of Transfer Size Counters (XferSizeWidth)</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <!--GHWCFG4 : User HW Config4 Register-->
        <register>
          <name>GHWCFG4</name>
          <description>User HW Config4 Register</description>
          <addressOffset>0x50</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>DescDMA</name>
              <description>Scatter/Gather DMA configuration
+ 1'b0: Non Dynamic configuration
+ 1'b1: Dynamic configuration
</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>DescDMAEnable</name>
              <description>Scatter/Gather DMA configuration
+ 1'b0: Non-Scatter/Gather DMA configuration
+ 1'b1: Scatter/Gather DMA configuration</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>INEps</name>
              <description>Number of Device Mode IN Endpoints Including Control Endpoints (INEps)</description>
              <bitOffset>26</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>NumCtlEps</name>
              <description>Number of Device Mode Control Endpoints in Addition to Endpoint 0 (NumCtlEps)</description>
              <bitOffset>16</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>Hibernation</name>
              <description>Enable Hibernation (Hibernation)</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>AhbFreq</name>
              <description>Minimum AHB Frequency Less Than 60 MHz (AhbFreq)</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PartialPwrDn</name>
              <description>Enable Partial Power Down (PartialPwrDn)</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>NumDevPerioEps</name>
              <description>Number of Device Mode Periodic IN Endpoints (NumDevPerioEps)</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <!--GLPMCFG : LPM Config Register-->
        <register>
          <name>GLPMCFG</name>
          <description>LPM Config Register</description>
          <addressOffset>0x54</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RestoreSlpSts</name>
              <description>LPM Restore Sleep Status (LPM_RestoreSlpSts)
When the application power gates the core (Partial Power Down / Hibernation) the application needs to program this bit to restore the LPM status in the core.
The application needs to program this bit, during restore process, based on whether it had decided to go into Shallow Sleep (Clock Gating Only) or Deep Sleep (Power Gating) based on the BESL value received from the Host</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>LPM_EnBESL</name>
              <description>LPM Enable BESL (LPM_EnBESL)</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>LPM_RetryCnt_Sts</name>
              <description>LPM Retry Count Status (LPM_RetryCnt_Sts)
Number of LPM Host Retries still remaining to be transmitted for the current LPM sequence.</description>
              <bitOffset>25</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>LPM_Retry_Cnt</name>
              <description>LPM Retry Count (LPM_Retry_Cnt)
Number of additional LPM retries that the HOST would perform if the Device Response was an ERROR until a valid device response is received (STALL/NYET/ACK).</description>
              <bitOffset>21</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>L1ResumeOK</name>
              <description>Sleep State Resume OK (L1ResumeOK)
Indicates that the application or host can start resume from Sleep state. This bit is valid in LPM sleep (L1) state. It is set in sleep mode after a delay of 50 micro sec (TL1Residency). The bit is reset when SlpSts is 0.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SlpSts</name>
              <description>Port Sleep Status (SlpSts)
This bit is set as long as a Sleep condition is present on the USB bus.
The core enters the Sleep state when an ACK response is sent to an LPM transaction and the expiry of timer TL1TokenRetry.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CoreL1Res</name>
              <description>LPM response (CoreL1Res)
The response of the core to LPM transaction received is reflected in these two bits.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>HIRD_Thres</name>
              <description>BESL/HIRD Threshold (HIRD_Thres)</description>
              <bitOffset>8</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EnblSlpM</name>
              <description>Enable utmi_sleep_n (EnblSlpM)
The application uses this bit to control utmi_sleep_n assertion to the PHY in the L1 state.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>bRemoteWake</name>
              <description>RemoteWakeEnable (bRemoteWake)
This field is read only. It is updated with the Received LPM Token bRemoteWake bmAttribute when an ACK/NYET/STALL response is sent to an LPM transaction.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>HIRD</name>
              <description>Host-Initiated Resume Duration (HIRD)</description>
              <bitOffset>2</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>AppL1Res</name>
              <description>LPM response programmed by application (AppL1Res)</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>LPMCap</name>
              <description>The application uses this bit to control the controller LPM capabilities. If the core operates as a non-LPM-capable host, it cannot request the connected device/hub to activate LPM mode. If the core operates as a non-LPM-capable device, it cannot respond to any LPM transactions.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <!--GPWRDN : Global Power Down register-->
        <register>
          <name>GPWRDN</name>
          <description>Global Power Down register</description>
          <addressOffset>0x58</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>MultValIdBC</name>
              <description>MultValIdBC
Battery Charger ACA inputs </description>
              <bitOffset>24</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>BsessVld</name>
              <description>B Session Valid (BsessVld)
This field reflects the B session valid status signal from the PHY.</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>LineState</name>
              <description>LineState
This field indicates the current linestate on USB as seen by the PMU module.</description>
              <bitOffset>19</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>StsChngIntMsk</name>
              <description>StsChngIntMsk
Mask for StsChng Interrupt</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>StsChngInt</name>
              <description>Status Change Interrupt (StsChngInt)
This field indicates a status change in either the IDDIG or BsessVld signal.</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ConnDetMsk</name>
              <description>ConnDetMsk
Mask for ConnectDet interrupt</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ConnectDet</name>
              <description>ConnectDet
This field indicates that a new connect has been detected</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DisconnectDetectMsk</name>
              <description>DisconnectDetectMsk
Mask For DisconnectDetect Interrupt</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DisconnectDetect</name>
              <description>DisconnectDetect
This field indicates that Disconnect has been detected by the PMU. This field generates an interrupt. After detecting disconnect during hibernation the application must not restore the core, but instead start the initialization process.</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ResetDetMsk</name>
              <description>ResetDetMsk
Mask for ResetDetected interrupt</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ResetDetected</name>
              <description>ResetDetected
This field indicates that Reset has been detected by the PMU module. This field generates an interrupt.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>LineStageChangeMsk</name>
              <description>LineStageChangeMsk
Mask for LineStateChange interrupt.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>LnStsChng</name>
              <description>Line State Change (LnStsChng)
This interrupt is asserted when there is a Linestate Change detected by the PMU. The application should read GPWRDN.Linestate to determine the current linestate on USB.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PwrDnSwtch</name>
              <description>Power Down Switch (PwrDnSwtch)
This bit indicates to the controller whether the VDD switch is in ON/OFF state.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PwrDnRst_n</name>
              <description>Power Down ResetN (PwrDnRst_n)
The application must program this bit to reset the core during the Hibernation exit process.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PwrDnClmp</name>
              <description>Power Down Clamp (PwrDnClmp)
The application must program this bit to enable or disable the clamps to all the outputs of the core module to prevent the corruption of other active logic.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>Restore</name>
              <description>Restore
The application should program this bit to enable or disable restore mode from the PMU module.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PMUActv</name>
              <description>PMU Active (PMUActv)
This is bit is to enable or disable the PMU logic.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PMUIntSel</name>
              <description>PMU Interrupt Select (PMUIntSel)
A write to this bit with 1'b1 enables the PMU to generate interrupts to the application. During this state all interrupts from the DWC_usb11_device_core module are blocked to the application.
Note: This bit must be set to 1'b1 before the core is put into hibernation.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <!--GDFIFOCFG : Global DFIFO Configuration Register-->
        <register>
          <name>GDFIFOCFG</name>
          <description>Global DFIFO Configuration Register</description>
          <addressOffset>0x5c</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>EPInfoBaseAddr</name>
              <description>EPInfoBaseAddr
This field provides the start address of the EP info controller</description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GDFIFOCfg</name>
              <description>GDFIFOCfg
This field is for dynamic programming of the DFIFO Size. This value takes effect only when the application programs a non zero value to this register. The value programmed must conform to the guidelines described in 'FIFO RAM Allocation'. The core does not have any corrective logic if the FIFO sizes are programmed incorrectly.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <!--DIEPTXF1 : Device IN Endpoint Transmit FIFO Size Register i-->
        <register>
          <name>DIEPTXF1</name>
          <description>Device IN Endpoint Transmit FIFO Size Register i</description>
          <addressOffset>0x13c</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>INEPnTxFDep</name>
              <description>IN Endpoint TxFIFO Depth (INEPnTxFDep)
This value is in terms of 32-bit words.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>12</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>INEPnTxFStAddr</name>
              <description>IN Endpoint FIFOn Transmit RAM Start Address (INEPnTxFStAddr)
This field contains the memory start address for IN endpoint Transmit FIFOn (0&lt;n&lt; = 15). The power-on reset value of this register is specified as the Largest Rx Data FIFO Depth. Programmed values must not exceed the power-on value.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <!--DIEPTXF2 : Device IN Endpoint Transmit FIFO Size Register i-->
        <register>
          <name>DIEPTXF2</name>
          <description>Device IN Endpoint Transmit FIFO Size Register i</description>
          <addressOffset>0x140</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>INEPnTxFDep</name>
              <description>IN Endpoint TxFIFO Depth (INEPnTxFDep)
This value is in terms of 32-bit words.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>12</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>INEPnTxFStAddr</name>
              <description>IN Endpoint FIFOn Transmit RAM Start Address (INEPnTxFStAddr)
This field contains the memory start address for IN endpoint Transmit FIFOn (0&lt;n&lt; = 15). The power-on reset value of this register is specified as the Largest Rx Data FIFO Depth. Programmed values must not exceed the power-on value.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <!--DIEPTXF3 : Device IN Endpoint Transmit FIFO Size Register i-->
        <register>
          <name>DIEPTXF3</name>
          <description>Device IN Endpoint Transmit FIFO Size Register i</description>
          <addressOffset>0x144</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>INEPnTxFDep</name>
              <description>IN Endpoint TxFIFO Depth (INEPnTxFDep)
This value is in terms of 32-bit words.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>12</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>INEPnTxFStAddr</name>
              <description>IN Endpoint FIFOn Transmit RAM Start Address (INEPnTxFStAddr)
This field contains the memory start address for IN endpoint Transmit FIFOn (0&lt;n&lt; = 15). The power-on reset value of this register is specified as the Largest Rx Data FIFO Depth. Programmed values must not exceed the power-on value.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <!--DIEPTXF4 : Device IN Endpoint Transmit FIFO Size Register i-->
        <register>
          <name>DIEPTXF4</name>
          <description>Device IN Endpoint Transmit FIFO Size Register i</description>
          <addressOffset>0x148</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>INEPnTxFDep</name>
              <description>IN Endpoint TxFIFO Depth (INEPnTxFDep)
This value is in terms of 32-bit words.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>12</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>INEPnTxFStAddr</name>
              <description>IN Endpoint FIFOn Transmit RAM Start Address (INEPnTxFStAddr)
This field contains the memory start address for IN endpoint Transmit FIFOn (0&lt;n&lt; = 15). The power-on reset value of this register is specified as the Largest Rx Data FIFO Depth. Programmed values must not exceed the power-on value.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <!--DCFG : Device Configuration Register-->
        <register>
          <name>DCFG</name>
          <description>Device Configuration Register</description>
          <addressOffset>0x800</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>ResValid</name>
              <description>Resume Validation Period (ResValid)
This field is effective only when DCFG.Ena32KhzSusp is set. It will control the resume period when the core resumes from suspend. The core counts for ResValid number of clock cycles to detect a valid resume when this is set</description>
              <bitOffset>26</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PerSchIntvl</name>
              <description>Periodic Scheduling Interval (PerSchIntvl)
PerSchIntvl must be programmed for Scatter/Gather DMA mode.
This field specifies the amount of time the Internal DMA engine must allocate for fetching periodic IN endpoint data. Based on the number of periodic endpoints, this value must be specified as 25,50 or 75% of (micro)frame.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DescDMA</name>
              <description>Enable Scatter/gather DMA in device mode (DescDMA).
When the Scatter/Gather DMA option selected during configuration of the RTL, the application can Set this bit during initialization to enable the Scatter/Gather DMA operation.</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ErraticIntMsk</name>
              <description>Erratic Error Interrupt Mask</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EnDevOutNak</name>
              <description>Enable Device OUT NAK (EnDevOutNak)
This bit enables setting NAK for Bulk OUT endpoints after the transfer is completed for Device mode Descriptor DMA</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PerFrInt</name>
              <description>Periodic Frame Interval (PerFrInt)
Indicates the time within a (micro)frame at which the application must be notified using the End Of Periodic Frame Interrupt. This can be used to determine If all the isochronous traffic for that (micro)frame is complete.</description>
              <bitOffset>11</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DevAddr</name>
              <description>Device Address (DevAddr)
The application must program this field after every SetAddress control command.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>7</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>Ena32KhzSusp</name>
              <description>Enable 32 KHz Suspend mode (Ena32KhzSusp)
As FS PHY interface is chosen, when this bit is set, the core expects that the PHY clock during Suspend is switched from 48 MHz to 32 KHz.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>NZStsOUTHShk</name>
              <description>Non-Zero-Length Status OUT Handshake (NZStsOUTHShk)
The application can use this field to select the handshake the core sends on receiving a nonzero-length data packet during the OUT transaction of a control transfer's Status stage.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DevSpd</name>
              <description>Device Speed (DevSpd)
Indicates the speed at which the application requires the core to enumerate, or the maximum speed the application can support. However, the actual bus speed is determined only after the connect sequence is completed, and is based on the speed of the USB host to which the core is connected.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <!--DCTL : Device Control Register-->
        <register>
          <name>DCTL</name>
          <description>Device Control Register</description>
          <addressOffset>0x804</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>DeepSleepBESLReject</name>
              <description>DeepSleepBESLReject
When enabled Core rejects LPM request with HIRD value greater than HIRD threshold programmed. NYET response is sent for LPM tokens with HIRD value greater than HIRD threshold. By default, the Deep Sleep BESL Reject feature is disabled.</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EnContOnBNA</name>
              <description>Enable Continue on BNA (EnContOnBNA)
This bit enables the core to continue on BNA for Bulk OUT endpoints. With this feature enabled, when a Bulk OUT endpoint receives a BNA interrupt the core starts processing the descriptor that caused the BNA interrupt after the endpoint re-enables the endpoint.</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>NakOnBble</name>
              <description>NAK on Babble Error (NakOnBble)
Set NAK automatically on babble (NakOnBble). The core sets NAK automatically for the endpoint on which babble is received.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>IgnrFrmNum</name>
              <description>Ignore Frame number for Isochronous End points (IgnrFrmNum)
Do not program IgnrFrmNum bit to 1'b1 when the core is operating in threshold mode.
When this bit is enabled, there must be only one packet per descriptor.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GMC</name>
              <description>Global Multi Count (GMC)
GMC must be programmed only once after initialization. This field indicates the number of packets to be serviced for that end point before moving to the next end point. It is only for non-periodic endpoints.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PWROnPrgDone</name>
              <description>Power-On Programming Done (PWROnPrgDone)
The application uses this bit to indicate that register programming is completed after a wake-up from Power Down mode.</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CGOUTNak</name>
              <description>Clear Global OUT NAK (CGOUTNak)
A write to this field clears the Global OUT NAK.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SGOUTNak</name>
              <description>Set Global OUT NAK (SGOUTNak)
A write to this field sets the Global OUT NAK. The application uses this bit to send a NAK handshake on all OUT endpoints. The application must set the this bit only after making sure that the Global OUT NAK Effective bit in the Core Interrupt Register (GINTSTS.GOUTNakEff) is cleared.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CGNPInNak</name>
              <description>Clear Global Non-periodic IN NAK (CGNPInNak)
A write to this field clears the Global Non-periodic IN NAK.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SGNPInNak</name>
              <description>Set Global Non-periodic IN NAK (SGNPInNak)
A write to this field sets the Global Non-periodic IN NAK.The application uses this bit to send a NAK handshake on all non-periodic IN endpoints. The core can also Set this bit when a timeout condition is detected on a non-periodic endpoint in shared FIFO operation. The application must Set this bit only after making sure that the Global IN NAK Effective bit in the Core Interrupt Register (GINTSTS.GINNakEff) is cleared</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TstCtl</name>
              <description>Test Control (TstCtl)</description>
              <bitOffset>4</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GOUTNakSts</name>
              <description>Global OUT NAK Status (GOUTNakSts)</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>GNPINNakSts</name>
              <description>Global Non-periodic IN NAK Status (GNPINNakSts)</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>SftDiscon</name>
              <description>Soft Disconnect (SftDiscon)
The application uses this bit to signal the controller to do a soft disconnect. As long as this bit is Set, the host does not see that the device is connected, and the device does not receive signals on the USB. The core stays in the disconnected state until the application clears this bit.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RmtWkUpSig</name>
              <description>Remote Wakeup Signaling (RmtWkUpSig)
When the application sets this bit, the core initiates remote signaling to wake up the USB host. The application must Set this bit to instruct the core to exit the Suspend state. As specified in the USB 2.0 specification, the application must clear this bit 1-15 ms after setting it.
Remote Wakeup Signaling (RmtWkUpSig) When LPM is enabled, In L1 state the behavior of this bit is as follows: When the application sets this bit, the core initiates L1 remote signaling to wake up the USB host. The application must set this bit to instruct the core to exit the Sleep state. As specified in the LPM specification, the hardware will automatically clear this bit after a time of 50 micro sec (TL1DevDrvResume) after set by application. Application should not set this bit when GLPMCFG bRemoteWake from the previous LPM transaction was zero.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <!--DSTS : Device Status Register-->
        <register>
          <name>DSTS</name>
          <description>Device Status Register</description>
          <addressOffset>0x808</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>DevLnSts</name>
              <description>Device Line Status (DevLnSts)
Indicates the current logic level USB data lines</description>
              <bitOffset>22</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SOFFN</name>
              <description>Number of the Received SOF (SOFFN)
Note: This register may return a non-zero value if read immediately after power-on reset. In case the register bit reads non-zero immediately after power-on reset, it does not indicate that SOF has been received from the host. The read value of this interrupt is valid only after a valid connection between host and device is established.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>14</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ErrticErr</name>
              <description>Erratic Error (ErrticErr)
The core sets this bit to report any erratic errors due to PHY error). Because of erratic errors, the controller goes into Suspended state and an interrupt is generated to the application with Early Suspend bit of the Core Interrupt register (GINTSTS.ErlySusp). If the early suspend is asserted due to an erratic error, the application can only perform a soft disconnect recover.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EnumSpd</name>
              <description>Enumerated Speed (EnumSpd)
Indicates the speed at which the controller has come up after speed detection through a chirp sequence.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SuspSts</name>
              <description>Suspend Status (SuspSts)
In Device mode, this bit is set as long as a Suspend condition is detected on the USB. The core enters the Suspended state when there is no activity on the phy_line_state_i signal for an extended period of time. The core comes out of the suspend</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <!--DIEPMSK : Device IN Endpoint Common Interrupt Mask Register-->
        <register>
          <name>DIEPMSK</name>
          <description>Device IN Endpoint Common Interrupt Mask Register</description>
          <addressOffset>0x810</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>NAKMsk</name>
              <description>NAK interrupt Mask (NAKMsk)</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>BNAInIntrMsk</name>
              <description>BNA interrupt Mask (BNAInIntrMsk)</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TxfifoUndrnMsk</name>
              <description>Fifo Underrun Mask (TxfifoUndrnMsk)</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>INEPNakEffMsk</name>
              <description>IN Endpoint NAK Effective Mask (INEPNakEffMsk)</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>INTknEPMisMsk</name>
              <description>IN Token received with EP Mismatch Mask (INTknEPMisMsk)</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>INTknTXFEmpMsk</name>
              <description>IN Token Received When TxFIFO Empty Mask (INTknTXFEmpMsk)</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TimeOUTMsk</name>
              <description>Timeout Condition Mask (TimeOUTMsk) (Non-isochronous endpoints)</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>AHBErrMsk</name>
              <description>AHB Error Mask (AHBErrMsk)</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EPDisbldMsk</name>
              <description>Endpoint Disabled Interrupt Mask (EPDisbldMsk)</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>XferComplMsk</name>
              <description>Transfer Completed Interrupt Mask (XferComplMsk)</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <!--DOEPMSK : Device OUT Endpoint Common Interrupt Mask Register-->
        <register>
          <name>DOEPMSK</name>
          <description>Device OUT Endpoint Common Interrupt Mask Register</description>
          <addressOffset>0x814</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>NYETMsk</name>
              <description>NYET interrupt Mask (NYETMsk)</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>NAKMsk</name>
              <description>NAK interrupt Mask (NAKMsk)</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>BbleErrMsk</name>
              <description>Babble Error interrupt Mask (BbleErrMsk)</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>BnaOutIntrMsk</name>
              <description>BNA interrupt Mask (BnaOutIntrMsk)</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OutPktErrMsk</name>
              <description>OUT Packet Error Mask (OutPktErrMsk)</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>Back2BackSETup</name>
              <description>Back-to-Back SETUP Packets Received Mask (Back2BackSETup)
Applies to control OUT endpoints only.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>StsPhseRcvdMsk</name>
              <description>Status Phase Received Mask (StsPhseRcvdMsk)
Applies to control OUT endpoints only.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OUTTknEPdisMsk</name>
              <description>OUT Token Received when Endpoint Disabled Mask (OUTTknEPdisMsk)
Applies to control OUT endpoints only.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SetUPMsk</name>
              <description>SETUP Phase Done Mask (SetUPMsk)
Applies to control endpoints only.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>AHBErrMsk</name>
              <description>AHB Error (AHBErrMsk)</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EPDisbldMsk</name>
              <description>Endpoint Disabled Interrupt Mask (EPDisbldMsk)</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>XferComplMsk</name>
              <description>Transfer Completed Interrupt Mask (XferComplMsk)</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <!--DAINT : Device All Endpoints Interrupt Register-->
        <register>
          <name>DAINT</name>
          <description>Device All Endpoints Interrupt Register</description>
          <addressOffset>0x818</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>OutEPInt4</name>
              <description>OUT Endpoint 4 Interrupt Bit</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OutEPInt3</name>
              <description>OUT Endpoint 3 Interrupt Bit</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OutEPInt2</name>
              <description>OUT Endpoint 2 Interrupt Bit</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OutEPInt1</name>
              <description>OUT Endpoint 1 Interrupt Bit</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OutEPInt0</name>
              <description>OUT Endpoint 0 Interrupt Bit</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>InEpInt4</name>
              <description>IN Endpoint 4 Interrupt Bit</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>InEpInt3</name>
              <description>IN Endpoint 3 Interrupt Bit</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>InEpInt2</name>
              <description>IN Endpoint 2 Interrupt Bit</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>InEpInt1</name>
              <description>IN Endpoint 1 Interrupt Bit</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>InEpInt0</name>
              <description>IN Endpoint 0 Interrupt Bit</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <!--DAINTMSK : Device All Endpoints Interrupt Mask Register-->
        <register>
          <name>DAINTMSK</name>
          <description>Device All Endpoints Interrupt Mask Register</description>
          <addressOffset>0x81c</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>OutEPMak4</name>
              <description>OUT Endpoint 4 Interrupt mask Bit</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OutEPMak3</name>
              <description>OUT Endpoint 3 Interrupt mask Bit</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OutEPMak2</name>
              <description>OUT Endpoint 2 Interrupt mask Bit</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OutEPMak1</name>
              <description>OUT Endpoint 1 Interrupt mask Bit</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OutEPMak0</name>
              <description>OUT Endpoint 0 Interrupt mask Bit</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>InEpMsk4</name>
              <description>IN Endpoint 4 Interrupt mask Bit</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>InEpMsk3</name>
              <description>IN Endpoint 3 Interrupt mask Bit</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>InEpMsk2</name>
              <description>IN Endpoint 2 Interrupt mask Bit</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>InEpMsk1</name>
              <description>IN Endpoint 1 Interrupt mask Bit</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>InEpMsk0</name>
              <description>IN Endpoint 0 Interrupt mask Bit</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <!--DTHRCTL : Device Threshold Control Register-->
        <register>
          <name>DTHRCTL</name>
          <description>Device Threshold Control Register</description>
          <addressOffset>0x830</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>ArbPrkEn</name>
              <description>Arbiter Parking Enable (ArbPrkEn)
This bit controls internal DMA arbiter parking for IN endpoints. When thresholding is enabled and this bit is Set to one, Then the arbiter parks on the IN endpoint for which there is a token received on the USB. This is done to avoid getting into underrun conditions. By Default the parking is enabled.</description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RxThrLen</name>
              <description>Receive Threshold Length (RxThrLen)
This field specifies Receive thresholding size in DWORDS. This field also specifies the amount of data received on the USB before the core can start transmitting on the AHB. The threshold length has to be at least eight DWORDS. The recommended value for ThrLen is to be the same as the programmed AHB Burst Length (GAHBCFG.HbstLen).</description>
              <bitOffset>17</bitOffset>
              <bitWidth>9</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RxThrEn</name>
              <description>Receive Threshold Enable (RxThrEn)
When this bit is set, the core enables thresholding in the receive direction.
Note: We recommends that you do not enable RxThrEn, because it may cause issues in the RxFIFO especially during error conditions such as RxError and Babble.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>AHBThrRatio</name>
              <description>AHB Threshold Ratio (AHBThrRatio)
These bits define the ratio between the AHB threshold and the MAC threshold for the transmit path only. The AHB threshold always remains less than or equal to the USB threshold, because this does not increase overhead. Both the AHB and the MAC threshold must be DWORD-aligned. The application needs to program TxThrLen and the AHBThrRatio to make the AHB Threshold value DWORD aligned. If the AHB threshold value is not DWORD aligned, the core might not behave correctly. When programming the TxThrLen and AHBThrRatio, the application must ensure that the minimum AHB threshold value does not go below 8 DWORDS to meet the USB turnaround time requirements.</description>
              <bitOffset>11</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TxThrLen</name>
              <description>Transmit Threshold Length (TxThrLen)
This field specifies Transmit thresholding size in DWORDS. This also forms the MAC threshold and specifies the amount of data in bytes to be in the corresponding endpoint transmit FIFO, before the core can start transmit on the USB. The threshold length has to be at least eight DWORDS when the value of AHBThrRatio is 2'h00. In case the AHBThrRatio is non zero the application needs to ensure that the AHB Threshold value does not go below the recommended eight DWORD. This field controls both isochronous and non-isochronous IN endpoint thresholds. The recommended value for ThrLen is to be the same as the programmed AHB Burst Length (GAHBCFG.HbstLen).</description>
              <bitOffset>2</bitOffset>
              <bitWidth>9</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ISOThrEn</name>
              <description>ISO IN Endpoints Threshold Enable. (ISOThrEn) When this bit is Set, the core enables thresholding for isochronous IN endpoints.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>NonISOThrEn</name>
              <description>Non-ISO IN Endpoints Threshold Enable. (NonISOThrEn)
When this bit is Set, the core enables thresholding for Non Isochronous IN endpoints.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <!--DIEPEMPMSK : Device IN Endpoint FIFO Empty Interrupt Mask Register-->
        <register>
          <name>DIEPEMPMSK</name>
          <description>Device IN Endpoint FIFO Empty Interrupt Mask Register</description>
          <addressOffset>0x834</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>InEpTxfEmpMsk</name>
              <description>IN EP Tx FIFO Empty Interrupt Mask Bits (InEpTxfEmpMsk)
These bits acts as mask bits for DIEPINTn.TxFEmp interrupt, one bit per IN Endpoint:
Bit 0 for IN EP 0, bit 4 for IN EP 4</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <!--DIEPCTL0 : Device Control IN Endpoint 0 Control Register-->
        <register>
          <name>DIEPCTL0</name>
          <description>Device Control IN Endpoint 0 Control Register</description>
          <addressOffset>0x900</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>EPEna</name>
              <description>When Scatter/Gather DMA mode is enabled, for IN endpoints this bit indicates that the descriptor structure and data buffer with data ready to transmit is setup.</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EPDis</name>
              <description>Endpoint Disable (EPDis)
The application sets this bit to stop transmitting data on an endpoint, even before the transfer for that endpoint is complete. The application must wait for the Endpoint Disabled interrupt before treating the endpoint as disabled. The core clears this bit before setting the Endpoint Disabled Interrupt. The application must Set this bit only if Endpoint Enable is already set for this endpoint.</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SNAK</name>
              <description>Set NAK (SNAK) A write to this bit sets the NAK bit for the endpoint. Using this bit, the application can control the transmission of NAK handshakes on an endpoint. The core can also set this bit for an endpoint after a SETUP packet is received on that endpoint.</description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CNAK</name>
              <description>Clear NAK (CNAK) A write to this bit clears the NAK bit for the endpoint.</description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TxFNum</name>
              <description>TxFIFO Number (TxFNum)</description>
              <bitOffset>22</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>Stall</name>
              <description>TxFIFO Number (TxFNum)</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EPType</name>
              <description>Endpoint Type (EPType)</description>
              <bitOffset>18</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>NAKSts</name>
              <description>NAK Status (NAKSts)</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>USBActEP</name>
              <description>USB Active Endpoint (USBActEP)
This bit is always SET to 1, indicating that control endpoint 0 is always active in all configurations and interfaces.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MPS</name>
              <description>Maximum Packet Size (MPS)
Applies to IN and OUT endpoints.
The application must program this field with the maximum packet size for the current logical endpoint.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <!--DIEPINT0 : Device IN Endpoint 0 Interrupt Register-->
        <register>
          <name>DIEPINT0</name>
          <description>Device IN Endpoint 0 Interrupt Register</description>
          <addressOffset>0x908</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>NYETIntrpt</name>
              <description>NYET Interrupt (NYETIntrpt)
The core generates this interrupt when a NYET response is transmitted for a non isochronous OUT endpoint.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>NAKIntrpt</name>
              <description>NAK Interrupt (NAKInterrupt)
The core generates this interrupt when a NAK is transmitted or received by the device. &lt;brIn case of isochronous IN endpoints the interrupt gets generated when a zero length packet is transmitted due to un-availability of data in the TXFifo.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>BbleErr</name>
              <description>NAK Interrupt (BbleErr)
The core generates this interrupt when babble is received for the endpoint.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>BNAIntr</name>
              <description>BNA (Buffer Not Available) Interrupt (BNAIntr)
The core generates this interrupt when the descriptor accessed is not ready for the Core to process, such as DMA done.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TxfifoUndrn</name>
              <description>Fifo Underrun (TxfifoUndrn)
Applies to IN endpoints only.
The core generates this interrupt when it detects a transmit FIFO underrun condition in threshold mode for this endpoint.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TxFEmp</name>
              <description>Transmit FIFO Empty (TxFEmp)
This bit is valid only for IN Endpoints
This interrupt is asserted when the TxFIFO for this endpoint is either half or completely empty. The half or completely empty status is determined by the TxFIFO Empty Level bit in the Core AHB Configuration register (GAHBCFG.NPTxFEmpLvl)).</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>INEPNakEff</name>
              <description>IN Endpoint NAK Effective (INEPNakEff)
Applies to periodic IN endpoints only.
This bit can be cleared when the application clears the IN endpoint NAK by writing to DIEPCTLn.CNAK.
This interrupt indicates that the core has sampled the NAK bit
Set (either by the application or by the core).
The interrupt indicates that the IN endpoint NAK bit Set by the application has taken effect in the core.
This interrupt does not guarantee that a NAK handshake is sent on the USB. A STALL bit takes priority over a NAK bit.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>INTknEPMis</name>
              <description>IN Token Received with EP Mismatch (INTknEPMis)
Applies to non-periodic IN endpoints only.
Indicates that the data in the top of the non-periodic TxFIFO belongs to an endpoint other than the one for which the IN token was received. This interrupt is asserted on the endpoint for which the IN token was received.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>INTknTXFEmp</name>
              <description>IN Token Received When TxFIFO is Empty (INTknTXFEmp)
Applies to non-periodic IN endpoints only.
Indicates that an IN token was received when the associated TxFIFO (periodic/non-periodic) was empty. This interrupt is asserted on the endpoint for which the IN token was received.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>AHBErr</name>
              <description>AHB Error (AHBErr)
Applies to IN and OUT endpoints.
This is generated only in Internal DMA mode when there is an AHB error during an AHB read/write. The application can read the corresponding endpoint DMA address register to get the error address.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EPDisbld</name>
              <description>Endpoint Disabled Interrupt (EPDisbld)
Applies to IN and OUT endpoints.
This bit indicates that the endpoint is disabled per the application's request.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>XferCompl</name>
              <description>Transfer Completed Interrupt (XferCompl)
Applies to IN and OUT endpoints.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <!--DIEPDMA0 : Device IN Endpoint 0 DMA Address Register-->
        <register>
          <name>DIEPDMA0</name>
          <description>Device IN Endpoint 0 DMA Address Register</description>
          <addressOffset>0x914</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>DMAAddr</name>
              <description>DMAAddr
This field indicates the base pointer for the descriptor list.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <!--DTXFSTS0 : Device IN Endpoint Transmit FIFO Status Register 0-->
        <register>
          <name>DTXFSTS0</name>
          <description>Device IN Endpoint Transmit FIFO Status Register 0</description>
          <addressOffset>0x918</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>INEPTxFSpcAvail</name>
              <description>IN Endpoint TxFIFO Space Avail (INEPTxFSpcAvail)
Indicates the amount of free space available in the Endpoint TxFIFO.
Values are in terms of 32-bit words.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <!--DIEPDMAB0 : Device IN Endpoint 16 Buffer Address Register-->
        <register>
          <name>DIEPDMAB0</name>
          <description>Device IN Endpoint 16 Buffer Address Register</description>
          <addressOffset>0x91c</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>DMABufferAddr</name>
              <description>Holds the current buffer address.This register is updated as and when the data transfer for the corresponding end point is in progress.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <!--DIEPCTL1 : Device Control IN Endpoint 0 Control Register-->
        <register>
          <name>DIEPCTL1</name>
          <description>Device Control IN Endpoint 1 Control Register</description>
          <addressOffset>0x920</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>EPEna</name>
              <description>Endpoint Enable (EPEna)
Applies to IN and OUT endpoints.</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EPDis</name>
              <description>Endpoint Disable (EPDis)
Applies to IN and OUT endpoints.
The application sets this bit to stop transmitting/receiving data on an endpoint, even before the transfer for that endpoint is complete. The application must wait for the Endpoint Disabled interrupt before treating the endpoint as disabled. The core clears this bit before setting the Endpoint Disabled interrupt. The application must set this bit only if Endpoint Enable is already set for this endpoint.</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SNAK</name>
              <description>Set NAK (SNAK)
A write to this bit sets the NAK bit for the endpoint.
Using this bit, the application can control the transmission of NAK handshakes on an endpoint. The core can also Set this bit for an endpoint after a SETUP packet is received on that endpoint.</description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>CNAK</name>
              <description>Clear NAK (CNAK)
A write to this bit clears the NAK bit for the endpoint.</description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>TxFNum</name>
              <description>TxFIFO Number (TxFNum)
Dedicated FIFO Operation: These bits specify the FIFO number associated with this endpoint. Each active IN endpoint must be programmed to a separate FIFO number. This field is valid only for IN endpoints.</description>
              <bitOffset>22</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>Stall</name>
              <description>STALL Handshake (Stall)
Applies to non-control, non-isochronous IN and OUT endpoints only.
The application sets this bit to stall all tokens from the USB host to this endpoint. If a NAK bit, Global Non-periodic IN NAK, or Global OUT NAK is set along with this bit, the STALL bit takes priority. Only the application can clear this bit, never the core.
Applies to control endpoints only.
The application can only set this bit, and the core clears it, when a SETUP token is received for this endpoint. If a NAK bit, Global Non-periodic IN NAK, or Global OUT NAK is set along with this bit, the STALL bit takes priority. Irrespective of this bit's setting, the core always responds to SETUP data packets with an ACK handshake.</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EPType</name>
              <description>Endpoint Type (EPType) This is the transfer type supported by this logical endpoint.</description>
              <bitOffset>18</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>NAKSts</name>
              <description>NAK Status (NAKSts)</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>DPID</name>
              <description>Endpoint Data PID (DPID)
Applies to interrupt/bulk IN and OUT endpoints only.
Contains the PID of the packet to be received or transmitted on this endpoint. The application must program the PID of the first packet to be received or transmitted on this endpoint, after the endpoint is activated. The applications use the SetD1PID and SetD0PID fields of this register to program either DATA0 or DATA1 PID.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>USBActEP</name>
              <description>USB Active Endpoint (USBActEP)
Indicates whether this endpoint is active in the current configuration and interface. The core clears this bit for all endpoints (other than EP 0) after detecting a USB reset. After receiving the SetConfiguration and SetInterface commands, the application must program endpoint registers accordingly and set this bit.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>MPS</name>
              <description>Maximum Packet Size (MPS)
The application must program this field with the maximum packet size for the current logical endpoint. This value is in bytes.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>11</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <!--DIEPINT1 : Device IN Endpoint 0 Interrupt Register-->
        <register>
          <name>DIEPINT1</name>
          <description>Device IN Endpoint 1 Interrupt Register</description>
          <addressOffset>0x928</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>NYETIntrpt</name>
              <description>NYET Interrupt (NYETIntrpt)
The core generates this interrupt when a NYET response is transmitted for a non isochronous OUT endpoint.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>NAKIntrpt</name>
              <description>NAK Interrupt (NAKInterrupt)
The core generates this interrupt when a NAK is transmitted or received by the device. In case of isochronous IN endpoints the interrupt gets generated when a zero length packet is transmitted due to un-availability of data in the TXFifo.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>BbleErr</name>
              <description>NAK Interrupt (BbleErr)
The core generates this interrupt when babble is received for the endpoint.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>BNAIntr</name>
              <description>BNA (Buffer Not Available) Interrupt (BNAIntr)
The core generates this interrupt when the descriptor accessed is not ready for the Core to process, such as Host busy or DMA done.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TxfifoUndrn</name>
              <description>Fifo Underrun (TxfifoUndrn)
Applies to IN endpoints Only
This bit is valid only If thresholding is enabled. The core generates this interrupt when it detects a transmit FIFO underrun condition for this endpoint.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TxFEmp</name>
              <description>Transmit FIFO Empty (TxFEmp)
This bit is valid only for IN endpoints
This interrupt is asserted when the TxFIFO for this endpoint is either half or completely empty. The half or completely empty status is determined by the TxFIFO Empty Level bit in the Core AHB Configuration register (GAHBCFG.NPTxFEmpLvl)).</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>INEPNakEff</name>
              <description>IN Endpoint NAK Effective (INEPNakEff)
Applies to periodic IN endpoints only.
This bit can be cleared when the application clears the IN endpoint NAK by writing to DIEPCTLn.CNAK.
This interrupt indicates that the core has sampled the NAK bit
Set (either by the application or by the core). The interrupt indicates that the IN endpoint NAK bit Set by the application has taken effect in the core.
This interrupt does not guarantee that a NAK handshake is sent on the USB. A STALL bit takes priority over a NAK bit.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>INTknEPMis</name>
              <description>IN Token Received with EP Mismatch (INTknEPMis)
Applies to non-periodic IN endpoints only.
Indicates that the data in the top of the non-periodic TxFIFO belongs to an endpoint other than the one for which the IN token was received. This interrupt is asserted on the endpoint for which the IN token was received.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>INTknTXFEmp</name>
              <description>IN Token Received When TxFIFO is Empty (INTknTXFEmp)
Applies to non-periodic IN endpoints only.
Indicates that an IN token was received when the associated TxFIFO (periodic/non-periodic) was empty. This interrupt is asserted on the endpoint for which the IN token was received.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>AHBErr</name>
              <description>AHB Error (AHBErr)
Applies to IN and OUT endpoints.
This is generated only in Internal DMA mode when there is an AHB error during an AHB read/write. The application can read the corresponding endpoint DMA address register to get the error address.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EPDisbld</name>
              <description>Endpoint Disabled Interrupt (EPDisbld)
Applies to IN and OUT endpoints.
This bit indicates that the endpoint is disabled per the application's request.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>XferCompl</name>
              <description>Transfer Completed Interrupt (XferCompl)
Applies to IN and OUT endpoints.
+ When Scatter/Gather DMA mode is enabled
-For IN endpoint this field indicates that the requested data from the descriptor is moved from external system memory to internal FIFO.
-For OUT endpoint this field indicates that the requested data from the internal FIFO is moved to external system memory. This interrupt is generated only when the corresponding endpoint descriptor is closed, and the IOC bit for the corresponding descriptor is set.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <!--DIEPDMA1 : Device IN Endpoint 0 DMA Address Register-->
        <register>
          <name>DIEPDMA1</name>
          <description>Device IN Endpoint 1 DMA Address Register</description>
          <addressOffset>0x934</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>DMAAddr</name>
              <description>Holds the start address of the external memory for storing or fetching endpoint data.
Note: For control endpoints, this field stores control OUT data packets as well as SETUP transaction data packets. When more than three SETUP packets are received back-to-back, the SETUP data packet in the memory is overwritten.
This register is incremented on every AHB transaction. The application can give only a DWORD-aligned address.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <!--DTXFSTS1 : Device IN Endpoint Transmit FIFO Status Register 0-->
        <register>
          <name>DTXFSTS1</name>
          <description>Device IN Endpoint Transmit FIFO Status Register 1</description>
          <addressOffset>0x938</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>INEPTxFSpcAvail</name>
              <description>IN Endpoint TxFIFO Space Avail (INEPTxFSpcAvail)
Indicates the amount of free space available in the Endpoint TxFIFO.
Values are in terms of 32-bit words.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <!--DIEPDMAB1 : Device IN Endpoint 16 Buffer Address Register-->
        <register>
          <name>DIEPDMAB1</name>
          <description>Device IN Endpoint 16 Buffer Address Register</description>
          <addressOffset>0x93c</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>DMABufferAddr</name>
              <description>Holds the current buffer address. This register is updated as and when the data transfer for the corresponding end point is in progress.
This register is present only in Scatter/Gather DMA mode. Otherwise this field is reserved.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <!--DIEPCTL2 : Device Control IN Endpoint 0 Control Register-->
        <register>
          <name>DIEPCTL2</name>
          <description>Device Control IN Endpoint 1 Control Register</description>
          <addressOffset>0x940</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>EPEna</name>
              <description>Endpoint Enable (EPEna)
Applies to IN and OUT endpoints.</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EPDis</name>
              <description>Endpoint Disable (EPDis)
Applies to IN and OUT endpoints.
The application sets this bit to stop transmitting/receiving data on an endpoint, even before the transfer for that endpoint is complete. The application must wait for the Endpoint Disabled interrupt before treating the endpoint as disabled. The core clears this bit before setting the Endpoint Disabled interrupt. The application must set this bit only if Endpoint Enable is already set for this endpoint.</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SNAK</name>
              <description>Set NAK (SNAK)
A write to this bit sets the NAK bit for the endpoint.
Using this bit, the application can control the transmission of NAK handshakes on an endpoint. The core can also Set this bit for an endpoint after a SETUP packet is received on that endpoint.</description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>CNAK</name>
              <description>Clear NAK (CNAK)
A write to this bit clears the NAK bit for the endpoint.</description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>TxFNum</name>
              <description>TxFIFO Number (TxFNum)
Dedicated FIFO Operation: These bits specify the FIFO number associated with this endpoint. Each active IN endpoint must be programmed to a separate FIFO number. This field is valid only for IN endpoints.</description>
              <bitOffset>22</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>Stall</name>
              <description>STALL Handshake (Stall)
Applies to non-control, non-isochronous IN and OUT endpoints only.
The application sets this bit to stall all tokens from the USB host to this endpoint. If a NAK bit, Global Non-periodic IN NAK, or Global OUT NAK is set along with this bit, the STALL bit takes priority. Only the application can clear this bit, never the core.
Applies to control endpoints only.
The application can only set this bit, and the core clears it, when a SETUP token is received for this endpoint. If a NAK bit, Global Non-periodic IN NAK, or Global OUT NAK is set along with this bit, the STALL bit takes priority. Irrespective of this bit's setting, the core always responds to SETUP data packets with an ACK handshake.</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EPType</name>
              <description>Endpoint Type (EPType) This is the transfer type supported by this logical endpoint.</description>
              <bitOffset>18</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>NAKSts</name>
              <description>NAK Status (NAKSts)</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>DPID</name>
              <description>Endpoint Data PID (DPID)
Applies to interrupt/bulk IN and OUT endpoints only.
Contains the PID of the packet to be received or transmitted on this endpoint. The application must program the PID of the first packet to be received or transmitted on this endpoint, after the endpoint is activated. The applications use the SetD1PID and SetD0PID fields of this register to program either DATA0 or DATA1 PID.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>USBActEP</name>
              <description>USB Active Endpoint (USBActEP)
Indicates whether this endpoint is active in the current configuration and interface. The core clears this bit for all endpoints (other than EP 0) after detecting a USB reset. After receiving the SetConfiguration and SetInterface commands, the application must program endpoint registers accordingly and set this bit.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>MPS</name>
              <description>Maximum Packet Size (MPS)
The application must program this field with the maximum packet size for the current logical endpoint. This value is in bytes.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>11</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <!--DIEPINT2 : Device IN Endpoint 0 Interrupt Register-->
        <register>
          <name>DIEPINT2</name>
          <description>Device IN Endpoint 1 Interrupt Register</description>
          <addressOffset>0x948</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>NYETIntrpt</name>
              <description>NYET Interrupt (NYETIntrpt)
The core generates this interrupt when a NYET response is transmitted for a non isochronous OUT endpoint.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>NAKIntrpt</name>
              <description>NAK Interrupt (NAKInterrupt)
The core generates this interrupt when a NAK is transmitted or received by the device. In case of isochronous IN endpoints the interrupt gets generated when a zero length packet is transmitted due to un-availability of data in the TXFifo.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>BbleErr</name>
              <description>NAK Interrupt (BbleErr)
The core generates this interrupt when babble is received for the endpoint.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>BNAIntr</name>
              <description>BNA (Buffer Not Available) Interrupt (BNAIntr)
The core generates this interrupt when the descriptor accessed is not ready for the Core to process, such as Host busy or DMA done.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TxfifoUndrn</name>
              <description>Fifo Underrun (TxfifoUndrn)
Applies to IN endpoints Only
This bit is valid only If thresholding is enabled. The core generates this interrupt when it detects a transmit FIFO underrun condition for this endpoint.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TxFEmp</name>
              <description>Transmit FIFO Empty (TxFEmp)
This bit is valid only for IN endpoints
This interrupt is asserted when the TxFIFO for this endpoint is either half or completely empty. The half or completely empty status is determined by the TxFIFO Empty Level bit in the Core AHB Configuration register (GAHBCFG.NPTxFEmpLvl)).</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>INEPNakEff</name>
              <description>IN Endpoint NAK Effective (INEPNakEff)
Applies to periodic IN endpoints only.
This bit can be cleared when the application clears the IN endpoint NAK by writing to DIEPCTLn.CNAK.
This interrupt indicates that the core has sampled the NAK bit
Set (either by the application or by the core). The interrupt indicates that the IN endpoint NAK bit Set by the application has taken effect in the core.
This interrupt does not guarantee that a NAK handshake is sent on the USB. A STALL bit takes priority over a NAK bit.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>INTknEPMis</name>
              <description>IN Token Received with EP Mismatch (INTknEPMis)
Applies to non-periodic IN endpoints only.
Indicates that the data in the top of the non-periodic TxFIFO belongs to an endpoint other than the one for which the IN token was received. This interrupt is asserted on the endpoint for which the IN token was received.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>INTknTXFEmp</name>
              <description>IN Token Received When TxFIFO is Empty (INTknTXFEmp)
Applies to non-periodic IN endpoints only.
Indicates that an IN token was received when the associated TxFIFO (periodic/non-periodic) was empty. This interrupt is asserted on the endpoint for which the IN token was received.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>AHBErr</name>
              <description>AHB Error (AHBErr)
Applies to IN and OUT endpoints.
This is generated only in Internal DMA mode when there is an AHB error during an AHB read/write. The application can read the corresponding endpoint DMA address register to get the error address.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EPDisbld</name>
              <description>Endpoint Disabled Interrupt (EPDisbld)
Applies to IN and OUT endpoints.
This bit indicates that the endpoint is disabled per the application's request.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>XferCompl</name>
              <description>Transfer Completed Interrupt (XferCompl)
Applies to IN and OUT endpoints.
+ When Scatter/Gather DMA mode is enabled
-For IN endpoint this field indicates that the requested data from the descriptor is moved from external system memory to internal FIFO.
-For OUT endpoint this field indicates that the requested data from the internal FIFO is moved to external system memory. This interrupt is generated only when the corresponding endpoint descriptor is closed, and the IOC bit for the corresponding descriptor is set.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <!--DIEPDMA2 : Device IN Endpoint 0 DMA Address Register-->
        <register>
          <name>DIEPDMA2</name>
          <description>Device IN Endpoint 1 DMA Address Register</description>
          <addressOffset>0x954</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>DMAAddr</name>
              <description>Holds the start address of the external memory for storing or fetching endpoint data.
Note: For control endpoints, this field stores control OUT data packets as well as SETUP transaction data packets. When more than three SETUP packets are received back-to-back, the SETUP data packet in the memory is overwritten.
This register is incremented on every AHB transaction. The application can give only a DWORD-aligned address.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <!--DTXFSTS2 : Device IN Endpoint Transmit FIFO Status Register 0-->
        <register>
          <name>DTXFSTS2</name>
          <description>Device IN Endpoint Transmit FIFO Status Register 1</description>
          <addressOffset>0x958</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>INEPTxFSpcAvail</name>
              <description>IN Endpoint TxFIFO Space Avail (INEPTxFSpcAvail)
Indicates the amount of free space available in the Endpoint TxFIFO.
Values are in terms of 32-bit words.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <!--DIEPDMAB2 : Device IN Endpoint 16 Buffer Address Register-->
        <register>
          <name>DIEPDMAB2</name>
          <description>Device IN Endpoint 16 Buffer Address Register</description>
          <addressOffset>0x95c</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>DMABufferAddr</name>
              <description>Holds the current buffer address. This register is updated as and when the data transfer for the corresponding end point is in progress.
This register is present only in Scatter/Gather DMA mode. Otherwise this field is reserved.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <!--DIEPCTL3 : Device Control IN Endpoint 3 Control Register-->
        <register>
          <name>DIEPCTL3</name>
          <description>Device Control IN Endpoint 1 Control Register</description>
          <addressOffset>0x960</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>EPEna</name>
              <description>Endpoint Enable (EPEna)
Applies to IN and OUT endpoints.</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EPDis</name>
              <description>Endpoint Disable (EPDis)
Applies to IN and OUT endpoints.
The application sets this bit to stop transmitting/receiving data on an endpoint, even before the transfer for that endpoint is complete. The application must wait for the Endpoint Disabled interrupt before treating the endpoint as disabled. The core clears this bit before setting the Endpoint Disabled interrupt. The application must set this bit only if Endpoint Enable is already set for this endpoint.</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SNAK</name>
              <description>Set NAK (SNAK)
A write to this bit sets the NAK bit for the endpoint.
Using this bit, the application can control the transmission of NAK handshakes on an endpoint. The core can also Set this bit for an endpoint after a SETUP packet is received on that endpoint.</description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>CNAK</name>
              <description>Clear NAK (CNAK)
A write to this bit clears the NAK bit for the endpoint.</description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>TxFNum</name>
              <description>TxFIFO Number (TxFNum)
Dedicated FIFO Operation: These bits specify the FIFO number associated with this endpoint. Each active IN endpoint must be programmed to a separate FIFO number. This field is valid only for IN endpoints.</description>
              <bitOffset>22</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>Stall</name>
              <description>STALL Handshake (Stall)
Applies to non-control, non-isochronous IN and OUT endpoints only.
The application sets this bit to stall all tokens from the USB host to this endpoint. If a NAK bit, Global Non-periodic IN NAK, or Global OUT NAK is set along with this bit, the STALL bit takes priority. Only the application can clear this bit, never the core.
Applies to control endpoints only.
The application can only set this bit, and the core clears it, when a SETUP token is received for this endpoint. If a NAK bit, Global Non-periodic IN NAK, or Global OUT NAK is set along with this bit, the STALL bit takes priority. Irrespective of this bit's setting, the core always responds to SETUP data packets with an ACK handshake.</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EPType</name>
              <description>Endpoint Type (EPType) This is the transfer type supported by this logical endpoint.</description>
              <bitOffset>18</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>NAKSts</name>
              <description>NAK Status (NAKSts)</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>DPID</name>
              <description>Endpoint Data PID (DPID)
Applies to interrupt/bulk IN and OUT endpoints only.
Contains the PID of the packet to be received or transmitted on this endpoint. The application must program the PID of the first packet to be received or transmitted on this endpoint, after the endpoint is activated. The applications use the SetD1PID and SetD0PID fields of this register to program either DATA0 or DATA1 PID.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>USBActEP</name>
              <description>USB Active Endpoint (USBActEP)
Indicates whether this endpoint is active in the current configuration and interface. The core clears this bit for all endpoints (other than EP 0) after detecting a USB reset. After receiving the SetConfiguration and SetInterface commands, the application must program endpoint registers accordingly and set this bit.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>MPS</name>
              <description>Maximum Packet Size (MPS)
The application must program this field with the maximum packet size for the current logical endpoint. This value is in bytes.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>11</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <!--DIEPINT3 : Device IN Endpoint 3 Interrupt Register-->
        <register>
          <name>DIEPINT3</name>
          <description>Device IN Endpoint 1 Interrupt Register</description>
          <addressOffset>0x968</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>NYETIntrpt</name>
              <description>NYET Interrupt (NYETIntrpt)
The core generates this interrupt when a NYET response is transmitted for a non isochronous OUT endpoint.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>NAKIntrpt</name>
              <description>NAK Interrupt (NAKInterrupt)
The core generates this interrupt when a NAK is transmitted or received by the device. In case of isochronous IN endpoints the interrupt gets generated when a zero length packet is transmitted due to un-availability of data in the TXFifo.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>BbleErr</name>
              <description>NAK Interrupt (BbleErr)
The core generates this interrupt when babble is received for the endpoint.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>BNAIntr</name>
              <description>BNA (Buffer Not Available) Interrupt (BNAIntr)
The core generates this interrupt when the descriptor accessed is not ready for the Core to process, such as Host busy or DMA done.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TxfifoUndrn</name>
              <description>Fifo Underrun (TxfifoUndrn)
Applies to IN endpoints Only
This bit is valid only If thresholding is enabled. The core generates this interrupt when it detects a transmit FIFO underrun condition for this endpoint.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TxFEmp</name>
              <description>Transmit FIFO Empty (TxFEmp)
This bit is valid only for IN endpoints
This interrupt is asserted when the TxFIFO for this endpoint is either half or completely empty. The half or completely empty status is determined by the TxFIFO Empty Level bit in the Core AHB Configuration register (GAHBCFG.NPTxFEmpLvl)).</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>INEPNakEff</name>
              <description>IN Endpoint NAK Effective (INEPNakEff)
Applies to periodic IN endpoints only.
This bit can be cleared when the application clears the IN endpoint NAK by writing to DIEPCTLn.CNAK.
This interrupt indicates that the core has sampled the NAK bit
Set (either by the application or by the core). The interrupt indicates that the IN endpoint NAK bit Set by the application has taken effect in the core.
This interrupt does not guarantee that a NAK handshake is sent on the USB. A STALL bit takes priority over a NAK bit.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>INTknEPMis</name>
              <description>IN Token Received with EP Mismatch (INTknEPMis)
Applies to non-periodic IN endpoints only.
Indicates that the data in the top of the non-periodic TxFIFO belongs to an endpoint other than the one for which the IN token was received. This interrupt is asserted on the endpoint for which the IN token was received.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>INTknTXFEmp</name>
              <description>IN Token Received When TxFIFO is Empty (INTknTXFEmp)
Applies to non-periodic IN endpoints only.
Indicates that an IN token was received when the associated TxFIFO (periodic/non-periodic) was empty. This interrupt is asserted on the endpoint for which the IN token was received.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>AHBErr</name>
              <description>AHB Error (AHBErr)
Applies to IN and OUT endpoints.
This is generated only in Internal DMA mode when there is an AHB error during an AHB read/write. The application can read the corresponding endpoint DMA address register to get the error address.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EPDisbld</name>
              <description>Endpoint Disabled Interrupt (EPDisbld)
Applies to IN and OUT endpoints.
This bit indicates that the endpoint is disabled per the application's request.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>XferCompl</name>
              <description>Transfer Completed Interrupt (XferCompl)
Applies to IN and OUT endpoints.
+ When Scatter/Gather DMA mode is enabled
-For IN endpoint this field indicates that the requested data from the descriptor is moved from external system memory to internal FIFO.
-For OUT endpoint this field indicates that the requested data from the internal FIFO is moved to external system memory. This interrupt is generated only when the corresponding endpoint descriptor is closed, and the IOC bit for the corresponding descriptor is set.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <!--DIEPDMA3 : Device IN Endpoint 3 DMA Address Register-->
        <register>
          <name>DIEPDMA3</name>
          <description>Device IN Endpoint 1 DMA Address Register</description>
          <addressOffset>0x974</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>DMAAddr</name>
              <description>Holds the start address of the external memory for storing or fetching endpoint data.
Note: For control endpoints, this field stores control OUT data packets as well as SETUP transaction data packets. When more than three SETUP packets are received back-to-back, the SETUP data packet in the memory is overwritten.
This register is incremented on every AHB transaction. The application can give only a DWORD-aligned address.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <!--DTXFSTS3 : Device IN Endpoint Transmit FIFO Status Register 3-->
        <register>
          <name>DTXFSTS3</name>
          <description>Device IN Endpoint Transmit FIFO Status Register 1</description>
          <addressOffset>0x978</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>INEPTxFSpcAvail</name>
              <description>IN Endpoint TxFIFO Space Avail (INEPTxFSpcAvail)
Indicates the amount of free space available in the Endpoint TxFIFO.
Values are in terms of 32-bit words.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <!--DIEPDMAB3 : Device IN Endpoint 16 Buffer Address Register-->
        <register>
          <name>DIEPDMAB3</name>
          <description>Device IN Endpoint 16 Buffer Address Register</description>
          <addressOffset>0x97c</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>DMABufferAddr</name>
              <description>Holds the current buffer address. This register is updated as and when the data transfer for the corresponding end point is in progress.
This register is present only in Scatter/Gather DMA mode. Otherwise this field is reserved.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <!--DIEPCTL4 : Device Control IN Endpoint 4 Control Register-->
        <register>
          <name>DIEPCTL4</name>
          <description>Device Control IN Endpoint 4 Control Register</description>
          <addressOffset>0x980</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>EPEna</name>
              <description>Endpoint Enable (EPEna)
Applies to IN and OUT endpoints.</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EPDis</name>
              <description>Endpoint Disable (EPDis)
Applies to IN and OUT endpoints.
The application sets this bit to stop transmitting/receiving data on an endpoint, even before the transfer for that endpoint is complete. The application must wait for the Endpoint Disabled interrupt before treating the endpoint as disabled. The core clears this bit before setting the Endpoint Disabled interrupt. The application must set this bit only if Endpoint Enable is already set for this endpoint.</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SNAK</name>
              <description>Set NAK (SNAK)
A write to this bit sets the NAK bit for the endpoint.
Using this bit, the application can control the transmission of NAK handshakes on an endpoint. The core can also Set this bit for an endpoint after a SETUP packet is received on that endpoint.</description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>CNAK</name>
              <description>Clear NAK (CNAK)
A write to this bit clears the NAK bit for the endpoint.</description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>TxFNum</name>
              <description>TxFIFO Number (TxFNum)
Dedicated FIFO Operation: These bits specify the FIFO number associated with this endpoint. Each active IN endpoint must be programmed to a separate FIFO number. This field is valid only for IN endpoints.</description>
              <bitOffset>22</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>Stall</name>
              <description>STALL Handshake (Stall)
Applies to non-control, non-isochronous IN and OUT endpoints only.
The application sets this bit to stall all tokens from the USB host to this endpoint. If a NAK bit, Global Non-periodic IN NAK, or Global OUT NAK is set along with this bit, the STALL bit takes priority. Only the application can clear this bit, never the core.
Applies to control endpoints only.
The application can only set this bit, and the core clears it, when a SETUP token is received for this endpoint. If a NAK bit, Global Non-periodic IN NAK, or Global OUT NAK is set along with this bit, the STALL bit takes priority. Irrespective of this bit's setting, the core always responds to SETUP data packets with an ACK handshake.</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EPType</name>
              <description>Endpoint Type (EPType) This is the transfer type supported by this logical endpoint.</description>
              <bitOffset>18</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>NAKSts</name>
              <description>NAK Status (NAKSts)</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>DPID</name>
              <description>Endpoint Data PID (DPID)
Applies to interrupt/bulk IN and OUT endpoints only.
Contains the PID of the packet to be received or transmitted on this endpoint. The application must program the PID of the first packet to be received or transmitted on this endpoint, after the endpoint is activated. The applications use the SetD1PID and SetD0PID fields of this register to program either DATA0 or DATA1 PID.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>USBActEP</name>
              <description>USB Active Endpoint (USBActEP)
Indicates whether this endpoint is active in the current configuration and interface. The core clears this bit for all endpoints (other than EP 0) after detecting a USB reset. After receiving the SetConfiguration and SetInterface commands, the application must program endpoint registers accordingly and set this bit.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>MPS</name>
              <description>Maximum Packet Size (MPS)
The application must program this field with the maximum packet size for the current logical endpoint. This value is in bytes.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>11</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <!--DIEPINT4 : Device IN Endpoint 4 Interrupt Register-->
        <register>
          <name>DIEPINT4</name>
          <description>Device IN Endpoint 4 Interrupt Register</description>
          <addressOffset>0x988</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>NYETIntrpt</name>
              <description>NYET Interrupt (NYETIntrpt)
The core generates this interrupt when a NYET response is transmitted for a non isochronous OUT endpoint.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>NAKIntrpt</name>
              <description>NAK Interrupt (NAKInterrupt)
The core generates this interrupt when a NAK is transmitted or received by the device. In case of isochronous IN endpoints the interrupt gets generated when a zero length packet is transmitted due to un-availability of data in the TXFifo.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>BbleErr</name>
              <description>NAK Interrupt (BbleErr)
The core generates this interrupt when babble is received for the endpoint.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>BNAIntr</name>
              <description>BNA (Buffer Not Available) Interrupt (BNAIntr)
The core generates this interrupt when the descriptor accessed is not ready for the Core to process, such as Host busy or DMA done.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TxfifoUndrn</name>
              <description>Fifo Underrun (TxfifoUndrn)
Applies to IN endpoints Only
This bit is valid only If thresholding is enabled. The core generates this interrupt when it detects a transmit FIFO underrun condition for this endpoint.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TxFEmp</name>
              <description>Transmit FIFO Empty (TxFEmp)
This bit is valid only for IN endpoints
This interrupt is asserted when the TxFIFO for this endpoint is either half or completely empty. The half or completely empty status is determined by the TxFIFO Empty Level bit in the Core AHB Configuration register (GAHBCFG.NPTxFEmpLvl)).</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>INEPNakEff</name>
              <description>IN Endpoint NAK Effective (INEPNakEff)
Applies to periodic IN endpoints only.
This bit can be cleared when the application clears the IN endpoint NAK by writing to DIEPCTLn.CNAK.
This interrupt indicates that the core has sampled the NAK bit
Set (either by the application or by the core). The interrupt indicates that the IN endpoint NAK bit Set by the application has taken effect in the core.
This interrupt does not guarantee that a NAK handshake is sent on the USB. A STALL bit takes priority over a NAK bit.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>INTknEPMis</name>
              <description>IN Token Received with EP Mismatch (INTknEPMis)
Applies to non-periodic IN endpoints only.
Indicates that the data in the top of the non-periodic TxFIFO belongs to an endpoint other than the one for which the IN token was received. This interrupt is asserted on the endpoint for which the IN token was received.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>INTknTXFEmp</name>
              <description>IN Token Received When TxFIFO is Empty (INTknTXFEmp)
Applies to non-periodic IN endpoints only.
Indicates that an IN token was received when the associated TxFIFO (periodic/non-periodic) was empty. This interrupt is asserted on the endpoint for which the IN token was received.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>AHBErr</name>
              <description>AHB Error (AHBErr)
Applies to IN and OUT endpoints.
This is generated only in Internal DMA mode when there is an AHB error during an AHB read/write. The application can read the corresponding endpoint DMA address register to get the error address.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EPDisbld</name>
              <description>Endpoint Disabled Interrupt (EPDisbld)
Applies to IN and OUT endpoints.
This bit indicates that the endpoint is disabled per the application's request.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>XferCompl</name>
              <description>Transfer Completed Interrupt (XferCompl)
Applies to IN and OUT endpoints.
+ When Scatter/Gather DMA mode is enabled
-For IN endpoint this field indicates that the requested data from the descriptor is moved from external system memory to internal FIFO.
-For OUT endpoint this field indicates that the requested data from the internal FIFO is moved to external system memory. This interrupt is generated only when the corresponding endpoint descriptor is closed, and the IOC bit for the corresponding descriptor is set.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <!--DIEPDMA4 : Device IN Endpoint 4 DMA Address Register-->
        <register>
          <name>DIEPDMA4</name>
          <description>Device IN Endpoint 4 DMA Address Register</description>
          <addressOffset>0x994</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>DMAAddr</name>
              <description>Holds the start address of the external memory for storing or fetching endpoint data.
Note: For control endpoints, this field stores control OUT data packets as well as SETUP transaction data packets. When more than three SETUP packets are received back-to-back, the SETUP data packet in the memory is overwritten.
This register is incremented on every AHB transaction. The application can give only a DWORD-aligned address.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <!--DTXFSTS4 : Device IN Endpoint Transmit FIFO Status Register 4-->
        <register>
          <name>DTXFSTS4</name>
          <description>Device IN Endpoint Transmit FIFO Status Register 4</description>
          <addressOffset>0x998</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>INEPTxFSpcAvail</name>
              <description>IN Endpoint TxFIFO Space Avail (INEPTxFSpcAvail)
Indicates the amount of free space available in the Endpoint TxFIFO.
Values are in terms of 32-bit words.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <!--DIEPDMAB4 : Device IN Endpoint 16 Buffer Address Register-->
        <register>
          <name>DIEPDMAB4</name>
          <description>Device IN Endpoint 16 Buffer Address Register</description>
          <addressOffset>0x99c</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>DMABufferAddr</name>
              <description>Holds the current buffer address. This register is updated as and when the data transfer for the corresponding end point is in progress.
This register is present only in Scatter/Gather DMA mode. Otherwise this field is reserved.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <!--DOEPCTL0 : Device Control OUT Endpoint 0 Control Register-->
        <register>
          <name>DOEPCTL0</name>
          <description>Device Control OUT Endpoint 0 Control Register</description>
          <addressOffset>0xb00</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>EPEna</name>
              <description>Endpoint Enable (EPEna)
+ When Scatter/Gather DMA mode is enabled, for OUT endpoints this bit indicates that the descriptor structure and data buffer to receive data is setup.
+ The core clears this bit before setting any of the following interrupts on this endpoint:
-SETUP Phase Done
-Endpoint Disabled
-Transfer Completed
Note: This bit must be set for the core to transfer SETUP data packets into memory.</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EPDis</name>
              <description>Endpoint Disable (EPDis)
The application cannot disable control OUT endpoint 0.</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SNAK</name>
              <description>Set NAK (SNAK)
A write to this bit sets the NAK bit for the endpoint. Using this bit, the application can control the transmission of NAK handshakes on an endpoint. The core can also set bit on a Transfer Completed interrupt, or after a SETUP is received on the endpoint.</description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>CNAK</name>
              <description>Clear NAK (CNAK)
A write to this bit clears the NAK bit for the endpoint.</description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>Stall</name>
              <description>STALL Handshake (Stall)
The application can only set this bit, and the core clears it, when a SETUP token is received for this endpoint. If a NAK bit or Global OUT NAK is Set along with this bit, the STALL bit takes priority. Irrespective of this bit's setting, the core always responds to SETUP data packets with an ACK handshake.</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>Snp</name>
              <description>Snoop Mode (Snp)
This bit configures the endpoint to Snoop mode. In Snoop mode, the core does not check the correctness of OUT packets before transferring them to application memory.</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EPType</name>
              <description>Endpoint Type (EPType)
Hardcoded to 2'b00 for control.</description>
              <bitOffset>18</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>NAKSts</name>
              <description>NAK Status (NAKSts)
Indicates the following:
+1'b0: The core is transmitting non-NAK handshakes based on the FIFO status.
+1'b1: The core is transmitting NAK handshakes on this endpoint.
When either the application or the core sets this bit, the core stops receiving data, even If there is space in the RxFIFO to accommodate the incoming packet. Irrespective of this bit's setting, the core always responds to SETUP data packets with an ACK handshake.</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>USBActEP</name>
              <description>USB Active Endpoint (USBActEP)
This bit is always set to 1, indicating that a control endpoint 0 is always active in all configurations and interfaces.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>MPS</name>
              <description>Maximum Packet Size (MPS)
The maximum packet size for control OUT endpoint 0 is the same as what is programmed in control IN Endpoint 0.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <!--DOEPINT0 : Device Control OUT Endpoint 0 Control Register-->
        <register>
          <name>DOEPINT0</name>
          <description>Device OUT Endpoint 0 Interrupt Register</description>
          <addressOffset>0xb08</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>NYETIntrpt</name>
              <description>NYET Interrupt (NYETIntrpt)
The core generates this interrupt when a NYET response is transmitted for a non isochronous OUT endpoint.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>NAKIntrpt</name>
              <description>NAK Interrupt (NAKInterrupt)
The core generates this interrupt when a NAK is transmitted or received by the device. In case of isochronous IN endpoints the interrupt gets generated when a zero length packet is transmitted due to un-availability of data in the TXFifo.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>BbleErr</name>
              <description>NAK Interrupt (BbleErr)
The core generates this interrupt when babble is received for the endpoint.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>BNAIntr</name>
              <description>BNA (Buffer Not Available) Interrupt (BNAIntr)
The core generates this interrupt when the descriptor accessed is not ready for the core to process, such as Host busy or DMA done.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OutPktErr</name>
              <description>OUT Packet Error (OutPktErr)
Applies to OUT endpoints Only
This interrupt is valid only when thresholding is enabled.
This interrupt is asserted when the core detects an overflow or a CRC error for non-Isochronous OUT packet.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>Back2BackSETup</name>
              <description>Back-to-Back SETUP Packets Received (Back2BackSETup)
Applies to Control OUT endpoints only.
This bit indicates that the core has received more than three back-to-back SETUP packets for this particular endpoint. For information about handling this interrupt,</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>StsPhseRcvd</name>
              <description>Status Phase Received for Control Write (StsPhseRcvd)
This interrupt is valid only for Control OUT endpoints.
This interrupt is generated only after the core has transferred all the data that the host has sent during the data phase of a control write transfer, to the system memory buffer.
The interrupt indicates to the application that the host has switched from data phase to the status phase of a Control Write transfer. The application can use this interrupt to ACK or STALL the Status phase, after it has decoded the data phase.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OUTTknEPdis</name>
              <description>OUT Token Received When Endpoint Disabled (OUTTknEPdis)
Applies only to control OUT endpoints.
Indicates that an OUT token was received when the endpoint was not yet enabled. This interrupt is asserted on the endpoint for which the OUT token was received.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SetUp</name>
              <description>SETUP Phase Done (SetUp)
Applies to control OUT endpoints only.
Indicates that the SETUP phase for the control endpoint is complete and no more back-to-back SETUP packets were received for the current control transfer. On this interrupt, the application can decode the received SETUP data packet.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>AHBErr</name>
              <description>AHB Error (AHBErr)
Applies to IN and OUT endpoints.
This is generated when there is an AHB error during an AHB read/write. The application can read the corresponding endpoint DMA address register to get the error address.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EPDisbld</name>
              <description>Endpoint Disabled Interrupt (EPDisbld)
Applies to IN and OUT endpoints.
This bit indicates that the endpoint is disabled per the application's request.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>XferCompl</name>
              <description>Transfer Completed Interrupt (XferCompl)
Applies to IN and OUT endpoints.
+ For IN endpoint this field indicates that the requested data from the descriptor is moved from external system memory to internal FIFO.
+ For OUT endpoint this field indicates that the requested data from the internal FIFO is moved to external system memory. This interrupt is generated only when the corresponding endpoint descriptor is closed, and the IOC bit for the corresponding descriptor is Set.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <!--DOEPDMA0 : Device OUT Endpoint 0 DMA Address Register-->
        <register>
          <name>DOEPDMA0</name>
          <description>Device OUT Endpoint 0 DMA Address Register</description>
          <addressOffset>0xb14</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>DMAAddr</name>
              <description>Holds the start address of the external memory for storing or fetching endpoint data.
Note: For control endpoints, this field stores control OUT data packets as well as SETUP transaction data packets. When more than three SETUP packets are received back-to-back, the SETUP data packet in the memory is overwritten.
This register is incremented on every AHB transaction. The application can give only a DWORD-aligned address. When Scatter/Gather DMA mode is enabled, this field indicates the base pointer for the descriptor list.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <!--DOEPDMAB0 : Device OUT Endpoint 16 Buffer Address Register-->
        <register>
          <name>DOEPDMAB0</name>
          <description>Device OUT Endpoint 16 Buffer Address Register</description>
          <addressOffset>0xb1c</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>DMABufferAddr</name>
              <description>Holds the current buffer address. This register is updated as and when the data transfer for the corresponding end point is in progress. This register is present only in Scatter/Gather DMA mode. Otherwise this field is reserved.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <!--DOEPCTL1 : Device Control OUT Endpoint 1 Control Register-->
        <register>
          <name>DOEPCTL1</name>
          <description>Device Control OUT Endpoint 1 Control Register</description>
          <addressOffset>0xb20</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>EPEna</name>
              <description>Endpoint Enable (EPEna)
Applies to IN and OUT endpoints.
+ For IN endpoints this bit indicates that the descriptor structure and data buffer with data ready to transmit is setup.
+ For OUT endpoint it indicates that the descriptor structure and data buffer to receive data is setup.
The core clears this bit before setting any of the following interrupts on this endpoint:
+ SETUP Phase Done
+ Endpoint Disabled
+ Transfer Completed
Note: For control endpoints in DMA mode, this bit must be set to be able to transfer SETUP data packets in memory.</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EPDis</name>
              <description>Endpoint Disable (EPDis)
Applies to IN and OUT endpoints.
The application sets this bit to stop transmitting/receiving data on an endpoint, even before the transfer for that endpoint is complete. The application must wait for the Endpoint Disabled interrupt before treating the endpoint as disabled. The core clears this bit before setting the Endpoint Disabled interrupt. The application must set this bit only if Endpoint Enable is already set for this endpoint.</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SetD1PID</name>
              <description>Set DATA1 PID (SetD1PID)
+ Applies to interrupt and bulk IN and OUT endpoints only.
+ Writing to this field sets the Endpoint Data PID (DPID) field in this register to DATA1.
Values:
+ 0x0 (DISABLED): Disables Set DATA1 PID or Do not force Odd Frame
+ 0x1 (ENABLED): Set Endpoint Data PID to DATA1 or Sets EO_FrNum field to odd (micro)frame</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>SetD0PID</name>
              <description>Set DATA0 PID (SetD0PID)
+ Applies to interrupt/bulk IN and OUT endpoints only.
+ Writing to this field sets the Endpoint Data PID (DPID) field in this register to DATA0.
Values:
+ 0x0 (DISABLED): Disables Set DATA0 PID or Do not force Even Frame
+ 0x1 (ENABLED): Set Endpoint Data PID to DATA0 or Sets EO_FrNum field to odd (micro)frame</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>SNAK</name>
              <description>Set NAK (SNAK)
A write to this bit sets the NAK bit for the endpoint.
Using this bit, the application can control the transmission of NAK handshakes on an endpoint. The core can also set this bit for an endpoint after a SETUP packet is received on that endpoint.</description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>CNAK</name>
              <description>Clear NAK (CNAK) A write to this bit clears the NAK bit for the endpoint.</description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>Stall</name>
              <description>STALL Handshake (Stall)
Applies to non-control, non-isochronous IN and OUT endpoints only.
The application sets this bit to stall all tokens from the USB host to this endpoint. If a NAK bit, Global Non-periodic IN NAK, or Global OUT NAK is set along with this bit, the STALL bit takes priority. Only the application can clear this bit, never the core.
Applies to control endpoints only.
The application can only set this bit, and the core clears it, when a SETUP token is received for this endpoint. If a NAK bit, Global Non-periodic IN NAK, or Global OUT NAK is set along with this bit, the STALL bit takes priority. Irrespective of this bit's setting, the core always responds to SETUP data packets with an ACK handshake.</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>Snp</name>
              <description>Snoop Mode (Snp)
Applies to OUT endpoints only.
This bit configures the endpoint to Snoop mode. In Snoop mode, the core does not check the correctness of OUT packets before transferring them to application memory.</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EPType</name>
              <description>Endpoint Type (EPType)
This is the transfer type supported by this logical endpoint.
+ 2'b00: Control
+ 2'b01: Isochronous
+ 2'b10: Bulk
+ 2'b11: Interrupt</description>
              <bitOffset>18</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>NAKSts</name>
              <description>NAK Status (NAKSts)
Indicates the following:
+ 1'b0: The core is transmitting non-NAK handshakes based on the FIFO status.
+ 1'b1: The core is transmitting NAK handshakes on this endpoint.
When either the application or the core sets this bit:
+ The core stops receiving any data on an OUT endpoint, even if there is space in the RxFIFO to accommodate the incoming packet.
+ For non-isochronous IN endpoints: The core stops transmitting any data on an IN endpoint, even if there data is available in the TxFIFO.
+ For isochronous IN endpoints: The core sends out a zero-length data packet, even if there data is available in the TxFIFO.
Irrespective of this bit's setting, the core always responds to SETUP data packets with an ACK handshake.</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>DPID</name>
              <description>Endpoint Data PID (DPID)
Applies to interrupt/bulk IN and OUT endpoints only.
Contains the PID of the packet to be received or transmitted on this endpoint. The application must program the PID of the first packet to be received or transmitted on this endpoint, after the endpoint is activated. The applications use the SetD1PID and SetD0PID fields of this register to program either DATA0 or DATA1 PID.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>USBActEP</name>
              <description>USB Active Endpoint (USBActEP)
Indicates whether this endpoint is active in the current configuration and interface. The core clears this bit for all endpoints (other than EP 0) after detecting a USB reset. After receiving the SetConfiguration and SetInterface commands, the application must program endpoint registers accordingly and set this bit.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>MPS</name>
              <description>Maximum Packet Size (MPS)
The application must program this field with the maximum packet size for the current logical endpoint. This value is in bytes.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>11</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <!--DOEPINT1 : Device Control OUT Endpoint 1 Control Register-->
        <register>
          <name>DOEPINT1</name>
          <description>Device OUT Endpoint 1 Interrupt Register</description>
          <addressOffset>0xb28</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>NYETIntrpt</name>
              <description>NYET Interrupt (NYETIntrpt)
The core generates this interrupt when a NYET response is transmitted for a non isochronous OUT endpoint.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>NAKIntrpt</name>
              <description>NAK Interrupt (NAKInterrupt)
The core generates this interrupt when a NAK is transmitted or received by the device.
In case of isochronous IN endpoints the interrupt gets generated when a zero length packet is transmitted due to un-availability of data in the TXFifo.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>BbleErr</name>
              <description>NAK Interrupt (BbleErr)
The core generates this interrupt when babble is received for the endpoint.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PktDrpSts</name>
              <description>Packet Drop Status (PktDrpSts)
This bit indicates to the application that an ISOC OUT packet has been dropped. This bit does not have an associated mask bit and does not generate an interrupt.
Dependency: This bit is valid in non Scatter/Gather DMA mode when periodic transfer interrupt feature is selected.</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>BNAIntr</name>
              <description>BNA (Buffer Not Available) Interrupt (BNAIntr)
This bit is valid only when Scatter/Gather DMA mode is enabled.
The core generates this interrupt when the descriptor accessed is not ready for the Core to process, such as Host busy or DMA done</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OutPktErr</name>
              <description>OUT Packet Error (OutPktErr)
Applies to OUT endpoints Only
This interrupt is valid only when thresholding is enabled. This interrupt is asserted when the core detects an overflow or a CRC error for non-Isochronous OUT packet.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>Back2BackSETup</name>
              <description>Back-to-Back SETUP Packets Received (Back2BackSETup)
Applies to Control OUT endpoints only.
This bit indicates that the core has received more than three back-to-back SETUP packets for this particular endpoint. For information about handling this interrupt,</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>StsPhseRcvd</name>
              <description>Status Phase Received for Control Write (StsPhseRcvd)
This interrupt is valid only for Control OUT endpoints.
This interrupt is generated only after the core has transferred all the data that the host has sent during the data phase of a control write transfer, to the system memory buffer.
The interrupt indicates to the application that the host has switched from data phase to the status phase of a Control Write transfer. The application can use this interrupt to ACK or STALL the Status phase, after it has decoded the data phase. This is applicable only in Case of Scatter Gather DMA mode.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OUTTknEPdis</name>
              <description>OUT Token Received When Endpoint Disabled (OUTTknEPdis)
Applies only to control OUT endpoints.
Indicates that an OUT token was received when the endpoint was not yet enabled. This interrupt is asserted on the endpoint for which the OUT token was received.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SetUp</name>
              <description>SETUP Phase Done (SetUp)
Applies to control OUT endpoints only.
Indicates that the SETUP phase for the control endpoint is complete and no more back-to-back SETUP packets were received for the current control transfer. On this interrupt, the application can decode the received SETUP data packet.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>AHBErr</name>
              <description>AHB Error (AHBErr)
Applies to IN and OUT endpoints.
This is generated only in Internal DMA mode when there is an AHB error during an AHB read/write. The application can read the corresponding endpoint DMA address register to get the error address.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EPDisbld</name>
              <description>Endpoint Disabled Interrupt (EPDisbld)
Applies to IN and OUT endpoints.
This bit indicates that the endpoint is disabled per the application's request.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>XferCompl</name>
              <description>Transfer Completed Interrupt (XferCompl)
Applies to IN and OUT endpoints.
+ When Scatter/Gather DMA mode is enabled
-For IN endpoint this field indicates that the requested data from the descriptor is moved from external system memory to internal FIFO.
-For OUT endpoint this field indicates that the requested data from the internal FIFO is moved to external system memory. This interrupt is generated only when the corresponding endpoint descriptor is closed, and the IOC bit for the corresponding descriptor is Set.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <!--DOEPDMA1 : Device OUT Endpoint 1 DMA Address Register-->
        <register>
          <name>DOEPDMA1</name>
          <description>Device OUT Endpoint 1 DMA Address Register</description>
          <addressOffset>0xb34</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>DMAAddr</name>
              <description>Holds the start address of the external memory for storing or fetching endpoint data.
Note: For control endpoints, this field stores control OUT data packets as well as SETUP transaction data packets. When more than three SETUP packets are received back-to-back, the SETUP data packet in the memory is overwritten.
This register is incremented on every AHB transaction. The application can give only a DWORD-aligned address.
+ When Scatter/Gather DMA mode is enabled, this field indicates the base pointer for the descriptor list.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <!--DOEPDMAB1 : Device OUT Endpoint 16 Buffer Address Register-->
        <register>
          <name>DOEPDMAB1</name>
          <description>Device OUT Endpoint 16 Buffer Address Register</description>
          <addressOffset>0xb3c</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>DMABufferAddr</name>
              <description>Holds the current buffer address.This register is updated as and when the data transfer for the corresponding end point is in progress.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <!--DOEPCTL2 : Device Control OUT Endpoint 2 Control Register-->
        <register>
          <name>DOEPCTL2</name>
          <description>Device Control OUT Endpoint 2 Control Register</description>
          <addressOffset>0xb40</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>EPEna</name>
              <description>Endpoint Enable (EPEna)
Applies to IN and OUT endpoints.
+ For IN endpoints this bit indicates that the descriptor structure and data buffer with data ready to transmit is setup.
+ For OUT endpoint it indicates that the descriptor structure and data buffer to receive data is setup.
The core clears this bit before setting any of the following interrupts on this endpoint:
+ SETUP Phase Done
+ Endpoint Disabled
+ Transfer Completed
Note: For control endpoints in DMA mode, this bit must be set to be able to transfer SETUP data packets in memory.</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EPDis</name>
              <description>Endpoint Disable (EPDis)
Applies to IN and OUT endpoints.
The application sets this bit to stop transmitting/receiving data on an endpoint, even before the transfer for that endpoint is complete. The application must wait for the Endpoint Disabled interrupt before treating the endpoint as disabled. The core clears this bit before setting the Endpoint Disabled interrupt. The application must set this bit only if Endpoint Enable is already set for this endpoint.</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SetD1PID</name>
              <description>Set DATA1 PID (SetD1PID)
+ Applies to interrupt and bulk IN and OUT endpoints only.
+ Writing to this field sets the Endpoint Data PID (DPID) field in this register to DATA1.
Values:
+ 0x0 (DISABLED): Disables Set DATA1 PID or Do not force Odd Frame
+ 0x1 (ENABLED): Set Endpoint Data PID to DATA1 or Sets EO_FrNum field to odd (micro)frame</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>SetD0PID</name>
              <description>Set DATA0 PID (SetD0PID)
+ Applies to interrupt/bulk IN and OUT endpoints only.
+ Writing to this field sets the Endpoint Data PID (DPID) field in this register to DATA0.
Values:
+ 0x0 (DISABLED): Disables Set DATA0 PID or Do not force Even Frame
+ 0x1 (ENABLED): Set Endpoint Data PID to DATA0 or Sets EO_FrNum field to odd (micro)frame</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>SNAK</name>
              <description>Set NAK (SNAK)
A write to this bit sets the NAK bit for the endpoint.
Using this bit, the application can control the transmission of NAK handshakes on an endpoint. The core can also set this bit for an endpoint after a SETUP packet is received on that endpoint.</description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>CNAK</name>
              <description>Clear NAK (CNAK) A write to this bit clears the NAK bit for the endpoint.</description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>Stall</name>
              <description>STALL Handshake (Stall)
Applies to non-control, non-isochronous IN and OUT endpoints only.
The application sets this bit to stall all tokens from the USB host to this endpoint. If a NAK bit, Global Non-periodic IN NAK, or Global OUT NAK is set along with this bit, the STALL bit takes priority. Only the application can clear this bit, never the core.
Applies to control endpoints only.
The application can only set this bit, and the core clears it, when a SETUP token is received for this endpoint. If a NAK bit, Global Non-periodic IN NAK, or Global OUT NAK is set along with this bit, the STALL bit takes priority. Irrespective of this bit's setting, the core always responds to SETUP data packets with an ACK handshake.</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>Snp</name>
              <description>Snoop Mode (Snp)
Applies to OUT endpoints only.
This bit configures the endpoint to Snoop mode. In Snoop mode, the core does not check the correctness of OUT packets before transferring them to application memory.</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EPType</name>
              <description>Endpoint Type (EPType)
This is the transfer type supported by this logical endpoint.
+ 2'b00: Control
+ 2'b01: Isochronous
+ 2'b10: Bulk
+ 2'b11: Interrupt</description>
              <bitOffset>18</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>NAKSts</name>
              <description>NAK Status (NAKSts)
Indicates the following:
+ 1'b0: The core is transmitting non-NAK handshakes based on the FIFO status.
+ 1'b1: The core is transmitting NAK handshakes on this endpoint.
When either the application or the core sets this bit:
+ The core stops receiving any data on an OUT endpoint, even if there is space in the RxFIFO to accommodate the incoming packet.
+ For non-isochronous IN endpoints: The core stops transmitting any data on an IN endpoint, even if there data is available in the TxFIFO.
+ For isochronous IN endpoints: The core sends out a zero-length data packet, even if there data is available in the TxFIFO.
Irrespective of this bit's setting, the core always responds to SETUP data packets with an ACK handshake.</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>DPID</name>
              <description>Endpoint Data PID (DPID)
Applies to interrupt/bulk IN and OUT endpoints only.
Contains the PID of the packet to be received or transmitted on this endpoint. The application must program the PID of the first packet to be received or transmitted on this endpoint, after the endpoint is activated. The applications use the SetD1PID and SetD0PID fields of this register to program either DATA0 or DATA1 PID.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>USBActEP</name>
              <description>USB Active Endpoint (USBActEP)
Indicates whether this endpoint is active in the current configuration and interface. The core clears this bit for all endpoints (other than EP 0) after detecting a USB reset. After receiving the SetConfiguration and SetInterface commands, the application must program endpoint registers accordingly and set this bit.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>MPS</name>
              <description>Maximum Packet Size (MPS)
The application must program this field with the maximum packet size for the current logical endpoint. This value is in bytes.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>11</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <!--DOEPINT2 : Device Control OUT Endpoint 2 Control Register-->
        <register>
          <name>DOEPINT2</name>
          <description>Device OUT Endpoint 2 Interrupt Register</description>
          <addressOffset>0xb48</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>NYETIntrpt</name>
              <description>NYET Interrupt (NYETIntrpt)
The core generates this interrupt when a NYET response is transmitted for a non isochronous OUT endpoint.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>NAKIntrpt</name>
              <description>NAK Interrupt (NAKInterrupt)
The core generates this interrupt when a NAK is transmitted or received by the device.
In case of isochronous IN endpoints the interrupt gets generated when a zero length packet is transmitted due to un-availability of data in the TXFifo.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>BbleErr</name>
              <description>NAK Interrupt (BbleErr)
The core generates this interrupt when babble is received for the endpoint.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PktDrpSts</name>
              <description>Packet Drop Status (PktDrpSts)
This bit indicates to the application that an ISOC OUT packet has been dropped. This bit does not have an associated mask bit and does not generate an interrupt.
Dependency: This bit is valid in non Scatter/Gather DMA mode when periodic transfer interrupt feature is selected.</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>BNAIntr</name>
              <description>BNA (Buffer Not Available) Interrupt (BNAIntr)
This bit is valid only when Scatter/Gather DMA mode is enabled.
The core generates this interrupt when the descriptor accessed is not ready for the Core to process, such as Host busy or DMA done</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OutPktErr</name>
              <description>OUT Packet Error (OutPktErr)
Applies to OUT endpoints Only
This interrupt is valid only when thresholding is enabled. This interrupt is asserted when the core detects an overflow or a CRC error for non-Isochronous OUT packet.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>Back2BackSETup</name>
              <description>Back-to-Back SETUP Packets Received (Back2BackSETup)
Applies to Control OUT endpoints only.
This bit indicates that the core has received more than three back-to-back SETUP packets for this particular endpoint. For information about handling this interrupt,</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>StsPhseRcvd</name>
              <description>Status Phase Received for Control Write (StsPhseRcvd)
This interrupt is valid only for Control OUT endpoints.
This interrupt is generated only after the core has transferred all the data that the host has sent during the data phase of a control write transfer, to the system memory buffer.
The interrupt indicates to the application that the host has switched from data phase to the status phase of a Control Write transfer. The application can use this interrupt to ACK or STALL the Status phase, after it has decoded the data phase. This is applicable only in Case of Scatter Gather DMA mode.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OUTTknEPdis</name>
              <description>OUT Token Received When Endpoint Disabled (OUTTknEPdis)
Applies only to control OUT endpoints.
Indicates that an OUT token was received when the endpoint was not yet enabled. This interrupt is asserted on the endpoint for which the OUT token was received.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SetUp</name>
              <description>SETUP Phase Done (SetUp)
Applies to control OUT endpoints only.
Indicates that the SETUP phase for the control endpoint is complete and no more back-to-back SETUP packets were received for the current control transfer. On this interrupt, the application can decode the received SETUP data packet.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>AHBErr</name>
              <description>AHB Error (AHBErr)
Applies to IN and OUT endpoints.
This is generated only in Internal DMA mode when there is an AHB error during an AHB read/write. The application can read the corresponding endpoint DMA address register to get the error address.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EPDisbld</name>
              <description>Endpoint Disabled Interrupt (EPDisbld)
Applies to IN and OUT endpoints.
This bit indicates that the endpoint is disabled per the application's request.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>XferCompl</name>
              <description>Transfer Completed Interrupt (XferCompl)
Applies to IN and OUT endpoints.
+ When Scatter/Gather DMA mode is enabled
-For IN endpoint this field indicates that the requested data from the descriptor is moved from external system memory to internal FIFO.
-For OUT endpoint this field indicates that the requested data from the internal FIFO is moved to external system memory. This interrupt is generated only when the corresponding endpoint descriptor is closed, and the IOC bit for the corresponding descriptor is Set.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <!--DOEPDMA2 : Device OUT Endpoint 2 DMA Address Register-->
        <register>
          <name>DOEPDMA2</name>
          <description>Device OUT Endpoint 2 DMA Address Register</description>
          <addressOffset>0xb54</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>DMAAddr</name>
              <description>Holds the start address of the external memory for storing or fetching endpoint data.
Note: For control endpoints, this field stores control OUT data packets as well as SETUP transaction data packets. When more than three SETUP packets are received back-to-back, the SETUP data packet in the memory is overwritten.
This register is incremented on every AHB transaction. The application can give only a DWORD-aligned address.
+ When Scatter/Gather DMA mode is enabled, this field indicates the base pointer for the descriptor list.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <!--DOEPDMAB2 : Device OUT Endpoint 16 Buffer Address Register-->
        <register>
          <name>DOEPDMAB2</name>
          <description>Device OUT Endpoint 16 Buffer Address Register</description>
          <addressOffset>0xb5c</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>DMABufferAddr</name>
              <description>Holds the current buffer address.This register is updated as and when the data transfer for the corresponding end point is in progress.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <!--DOEPCTL3 : Device Control OUT Endpoint 3 Control Register-->
        <register>
          <name>DOEPCTL3</name>
          <description>Device Control OUT Endpoint 3 Control Register</description>
          <addressOffset>0xb60</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>EPEna</name>
              <description>Endpoint Enable (EPEna)
Applies to IN and OUT endpoints.
+ For IN endpoints this bit indicates that the descriptor structure and data buffer with data ready to transmit is setup.
+ For OUT endpoint it indicates that the descriptor structure and data buffer to receive data is setup.
The core clears this bit before setting any of the following interrupts on this endpoint:
+ SETUP Phase Done
+ Endpoint Disabled
+ Transfer Completed
Note: For control endpoints in DMA mode, this bit must be set to be able to transfer SETUP data packets in memory.</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EPDis</name>
              <description>Endpoint Disable (EPDis)
Applies to IN and OUT endpoints.
The application sets this bit to stop transmitting/receiving data on an endpoint, even before the transfer for that endpoint is complete. The application must wait for the Endpoint Disabled interrupt before treating the endpoint as disabled. The core clears this bit before setting the Endpoint Disabled interrupt. The application must set this bit only if Endpoint Enable is already set for this endpoint.</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SetD1PID</name>
              <description>Set DATA1 PID (SetD1PID)
+ Applies to interrupt and bulk IN and OUT endpoints only.
+ Writing to this field sets the Endpoint Data PID (DPID) field in this register to DATA1.
Values:
+ 0x0 (DISABLED): Disables Set DATA1 PID or Do not force Odd Frame
+ 0x1 (ENABLED): Set Endpoint Data PID to DATA1 or Sets EO_FrNum field to odd (micro)frame</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>SetD0PID</name>
              <description>Set DATA0 PID (SetD0PID)
+ Applies to interrupt/bulk IN and OUT endpoints only.
+ Writing to this field sets the Endpoint Data PID (DPID) field in this register to DATA0.
Values:
+ 0x0 (DISABLED): Disables Set DATA0 PID or Do not force Even Frame
+ 0x1 (ENABLED): Set Endpoint Data PID to DATA0 or Sets EO_FrNum field to odd (micro)frame</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>SNAK</name>
              <description>Set NAK (SNAK)
A write to this bit sets the NAK bit for the endpoint.
Using this bit, the application can control the transmission of NAK handshakes on an endpoint. The core can also set this bit for an endpoint after a SETUP packet is received on that endpoint.</description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>CNAK</name>
              <description>Clear NAK (CNAK) A write to this bit clears the NAK bit for the endpoint.</description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>Stall</name>
              <description>STALL Handshake (Stall)
Applies to non-control, non-isochronous IN and OUT endpoints only.
The application sets this bit to stall all tokens from the USB host to this endpoint. If a NAK bit, Global Non-periodic IN NAK, or Global OUT NAK is set along with this bit, the STALL bit takes priority. Only the application can clear this bit, never the core.
Applies to control endpoints only.
The application can only set this bit, and the core clears it, when a SETUP token is received for this endpoint. If a NAK bit, Global Non-periodic IN NAK, or Global OUT NAK is set along with this bit, the STALL bit takes priority. Irrespective of this bit's setting, the core always responds to SETUP data packets with an ACK handshake.</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>Snp</name>
              <description>Snoop Mode (Snp)
Applies to OUT endpoints only.
This bit configures the endpoint to Snoop mode. In Snoop mode, the core does not check the correctness of OUT packets before transferring them to application memory.</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EPType</name>
              <description>Endpoint Type (EPType)
This is the transfer type supported by this logical endpoint.
+ 2'b00: Control
+ 2'b01: Isochronous
+ 2'b10: Bulk
+ 2'b11: Interrupt</description>
              <bitOffset>18</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>NAKSts</name>
              <description>NAK Status (NAKSts)
Indicates the following:
+ 1'b0: The core is transmitting non-NAK handshakes based on the FIFO status.
+ 1'b1: The core is transmitting NAK handshakes on this endpoint.
When either the application or the core sets this bit:
+ The core stops receiving any data on an OUT endpoint, even if there is space in the RxFIFO to accommodate the incoming packet.
+ For non-isochronous IN endpoints: The core stops transmitting any data on an IN endpoint, even if there data is available in the TxFIFO.
+ For isochronous IN endpoints: The core sends out a zero-length data packet, even if there data is available in the TxFIFO.
Irrespective of this bit's setting, the core always responds to SETUP data packets with an ACK handshake.</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>DPID</name>
              <description>Endpoint Data PID (DPID)
Applies to interrupt/bulk IN and OUT endpoints only.
Contains the PID of the packet to be received or transmitted on this endpoint. The application must program the PID of the first packet to be received or transmitted on this endpoint, after the endpoint is activated. The applications use the SetD1PID and SetD0PID fields of this register to program either DATA0 or DATA1 PID.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>USBActEP</name>
              <description>USB Active Endpoint (USBActEP)
Indicates whether this endpoint is active in the current configuration and interface. The core clears this bit for all endpoints (other than EP 0) after detecting a USB reset. After receiving the SetConfiguration and SetInterface commands, the application must program endpoint registers accordingly and set this bit.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>MPS</name>
              <description>Maximum Packet Size (MPS)
The application must program this field with the maximum packet size for the current logical endpoint. This value is in bytes.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>11</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <!--DOEPINT3 : Device Control OUT Endpoint 3 Control Register-->
        <register>
          <name>DOEPINT3</name>
          <description>Device OUT Endpoint 3 Interrupt Register</description>
          <addressOffset>0xb68</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>NYETIntrpt</name>
              <description>NYET Interrupt (NYETIntrpt)
The core generates this interrupt when a NYET response is transmitted for a non isochronous OUT endpoint.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>NAKIntrpt</name>
              <description>NAK Interrupt (NAKInterrupt)
The core generates this interrupt when a NAK is transmitted or received by the device.
In case of isochronous IN endpoints the interrupt gets generated when a zero length packet is transmitted due to un-availability of data in the TXFifo.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>BbleErr</name>
              <description>NAK Interrupt (BbleErr)
The core generates this interrupt when babble is received for the endpoint.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PktDrpSts</name>
              <description>Packet Drop Status (PktDrpSts)
This bit indicates to the application that an ISOC OUT packet has been dropped. This bit does not have an associated mask bit and does not generate an interrupt.
Dependency: This bit is valid in non Scatter/Gather DMA mode when periodic transfer interrupt feature is selected.</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>BNAIntr</name>
              <description>BNA (Buffer Not Available) Interrupt (BNAIntr)
This bit is valid only when Scatter/Gather DMA mode is enabled.
The core generates this interrupt when the descriptor accessed is not ready for the Core to process, such as Host busy or DMA done</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OutPktErr</name>
              <description>OUT Packet Error (OutPktErr)
Applies to OUT endpoints Only
This interrupt is valid only when thresholding is enabled. This interrupt is asserted when the core detects an overflow or a CRC error for non-Isochronous OUT packet.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>Back2BackSETup</name>
              <description>Back-to-Back SETUP Packets Received (Back2BackSETup)
Applies to Control OUT endpoints only.
This bit indicates that the core has received more than three back-to-back SETUP packets for this particular endpoint. For information about handling this interrupt,</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>StsPhseRcvd</name>
              <description>Status Phase Received for Control Write (StsPhseRcvd)
This interrupt is valid only for Control OUT endpoints.
This interrupt is generated only after the core has transferred all the data that the host has sent during the data phase of a control write transfer, to the system memory buffer.
The interrupt indicates to the application that the host has switched from data phase to the status phase of a Control Write transfer. The application can use this interrupt to ACK or STALL the Status phase, after it has decoded the data phase. This is applicable only in Case of Scatter Gather DMA mode.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OUTTknEPdis</name>
              <description>OUT Token Received When Endpoint Disabled (OUTTknEPdis)
Applies only to control OUT endpoints.
Indicates that an OUT token was received when the endpoint was not yet enabled. This interrupt is asserted on the endpoint for which the OUT token was received.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SetUp</name>
              <description>SETUP Phase Done (SetUp)
Applies to control OUT endpoints only.
Indicates that the SETUP phase for the control endpoint is complete and no more back-to-back SETUP packets were received for the current control transfer. On this interrupt, the application can decode the received SETUP data packet.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>AHBErr</name>
              <description>AHB Error (AHBErr)
Applies to IN and OUT endpoints.
This is generated only in Internal DMA mode when there is an AHB error during an AHB read/write. The application can read the corresponding endpoint DMA address register to get the error address.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EPDisbld</name>
              <description>Endpoint Disabled Interrupt (EPDisbld)
Applies to IN and OUT endpoints.
This bit indicates that the endpoint is disabled per the application's request.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>XferCompl</name>
              <description>Transfer Completed Interrupt (XferCompl)
Applies to IN and OUT endpoints.
+ When Scatter/Gather DMA mode is enabled
-For IN endpoint this field indicates that the requested data from the descriptor is moved from external system memory to internal FIFO.
-For OUT endpoint this field indicates that the requested data from the internal FIFO is moved to external system memory. This interrupt is generated only when the corresponding endpoint descriptor is closed, and the IOC bit for the corresponding descriptor is Set.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <!--DOEPDMA3 : Device OUT Endpoint 3 DMA Address Register-->
        <register>
          <name>DOEPDMA3</name>
          <description>Device OUT Endpoint 3 DMA Address Register</description>
          <addressOffset>0xb74</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>DMAAddr</name>
              <description>Holds the start address of the external memory for storing or fetching endpoint data.
Note: For control endpoints, this field stores control OUT data packets as well as SETUP transaction data packets. When more than three SETUP packets are received back-to-back, the SETUP data packet in the memory is overwritten.
This register is incremented on every AHB transaction. The application can give only a DWORD-aligned address.
+ When Scatter/Gather DMA mode is enabled, this field indicates the base pointer for the descriptor list.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <!--DOEPDMAB3 : Device OUT Endpoint 16 Buffer Address Register-->
        <register>
          <name>DOEPDMAB3</name>
          <description>Device OUT Endpoint 16 Buffer Address Register</description>
          <addressOffset>0xb7c</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>DMABufferAddr</name>
              <description>Holds the current buffer address.This register is updated as and when the data transfer for the corresponding end point is in progress.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <!--DOEPCTL4 : Device Control OUT Endpoint 4 Control Register-->
        <register>
          <name>DOEPCTL4</name>
          <description>Device Control OUT Endpoint 4 Control Register</description>
          <addressOffset>0xb80</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>EPEna</name>
              <description>Endpoint Enable (EPEna)
Applies to IN and OUT endpoints.
+ For IN endpoints this bit indicates that the descriptor structure and data buffer with data ready to transmit is setup.
+ For OUT endpoint it indicates that the descriptor structure and data buffer to receive data is setup.
The core clears this bit before setting any of the following interrupts on this endpoint:
+ SETUP Phase Done
+ Endpoint Disabled
+ Transfer Completed
Note: For control endpoints in DMA mode, this bit must be set to be able to transfer SETUP data packets in memory.</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EPDis</name>
              <description>Endpoint Disable (EPDis)
Applies to IN and OUT endpoints.
The application sets this bit to stop transmitting/receiving data on an endpoint, even before the transfer for that endpoint is complete. The application must wait for the Endpoint Disabled interrupt before treating the endpoint as disabled. The core clears this bit before setting the Endpoint Disabled interrupt. The application must set this bit only if Endpoint Enable is already set for this endpoint.</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SetD1PID</name>
              <description>Set DATA1 PID (SetD1PID)
+ Applies to interrupt and bulk IN and OUT endpoints only.
+ Writing to this field sets the Endpoint Data PID (DPID) field in this register to DATA1.
Values:
+ 0x0 (DISABLED): Disables Set DATA1 PID or Do not force Odd Frame
+ 0x1 (ENABLED): Set Endpoint Data PID to DATA1 or Sets EO_FrNum field to odd (micro)frame</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>SetD0PID</name>
              <description>Set DATA0 PID (SetD0PID)
+ Applies to interrupt/bulk IN and OUT endpoints only.
+ Writing to this field sets the Endpoint Data PID (DPID) field in this register to DATA0.
Values:
+ 0x0 (DISABLED): Disables Set DATA0 PID or Do not force Even Frame
+ 0x1 (ENABLED): Set Endpoint Data PID to DATA0 or Sets EO_FrNum field to odd (micro)frame</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>SNAK</name>
              <description>Set NAK (SNAK)
A write to this bit sets the NAK bit for the endpoint.
Using this bit, the application can control the transmission of NAK handshakes on an endpoint. The core can also set this bit for an endpoint after a SETUP packet is received on that endpoint.</description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>CNAK</name>
              <description>Clear NAK (CNAK) A write to this bit clears the NAK bit for the endpoint.</description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>Stall</name>
              <description>STALL Handshake (Stall)
Applies to non-control, non-isochronous IN and OUT endpoints only.
The application sets this bit to stall all tokens from the USB host to this endpoint. If a NAK bit, Global Non-periodic IN NAK, or Global OUT NAK is set along with this bit, the STALL bit takes priority. Only the application can clear this bit, never the core.
Applies to control endpoints only.
The application can only set this bit, and the core clears it, when a SETUP token is received for this endpoint. If a NAK bit, Global Non-periodic IN NAK, or Global OUT NAK is set along with this bit, the STALL bit takes priority. Irrespective of this bit's setting, the core always responds to SETUP data packets with an ACK handshake.</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>Snp</name>
              <description>Snoop Mode (Snp)
Applies to OUT endpoints only.
This bit configures the endpoint to Snoop mode. In Snoop mode, the core does not check the correctness of OUT packets before transferring them to application memory.</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EPType</name>
              <description>Endpoint Type (EPType)
This is the transfer type supported by this logical endpoint.
+ 2'b00: Control
+ 2'b01: Isochronous
+ 2'b10: Bulk
+ 2'b11: Interrupt</description>
              <bitOffset>18</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>NAKSts</name>
              <description>NAK Status (NAKSts)
Indicates the following:
+ 1'b0: The core is transmitting non-NAK handshakes based on the FIFO status.
+ 1'b1: The core is transmitting NAK handshakes on this endpoint.
When either the application or the core sets this bit:
+ The core stops receiving any data on an OUT endpoint, even if there is space in the RxFIFO to accommodate the incoming packet.
+ For non-isochronous IN endpoints: The core stops transmitting any data on an IN endpoint, even if there data is available in the TxFIFO.
+ For isochronous IN endpoints: The core sends out a zero-length data packet, even if there data is available in the TxFIFO.
Irrespective of this bit's setting, the core always responds to SETUP data packets with an ACK handshake.</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>DPID</name>
              <description>Endpoint Data PID (DPID)
Applies to interrupt/bulk IN and OUT endpoints only.
Contains the PID of the packet to be received or transmitted on this endpoint. The application must program the PID of the first packet to be received or transmitted on this endpoint, after the endpoint is activated. The applications use the SetD1PID and SetD0PID fields of this register to program either DATA0 or DATA1 PID.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>USBActEP</name>
              <description>USB Active Endpoint (USBActEP)
Indicates whether this endpoint is active in the current configuration and interface. The core clears this bit for all endpoints (other than EP 0) after detecting a USB reset. After receiving the SetConfiguration and SetInterface commands, the application must program endpoint registers accordingly and set this bit.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>MPS</name>
              <description>Maximum Packet Size (MPS)
The application must program this field with the maximum packet size for the current logical endpoint. This value is in bytes.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>11</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <!--DOEPINT4 : Device Control OUT Endpoint 4 Control Register-->
        <register>
          <name>DOEPINT4</name>
          <description>Device OUT Endpoint 4 Interrupt Register</description>
          <addressOffset>0xb88</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>NYETIntrpt</name>
              <description>NYET Interrupt (NYETIntrpt)
The core generates this interrupt when a NYET response is transmitted for a non isochronous OUT endpoint.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>NAKIntrpt</name>
              <description>NAK Interrupt (NAKInterrupt)
The core generates this interrupt when a NAK is transmitted or received by the device.
In case of isochronous IN endpoints the interrupt gets generated when a zero length packet is transmitted due to un-availability of data in the TXFifo.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>BbleErr</name>
              <description>NAK Interrupt (BbleErr)
The core generates this interrupt when babble is received for the endpoint.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PktDrpSts</name>
              <description>Packet Drop Status (PktDrpSts)
This bit indicates to the application that an ISOC OUT packet has been dropped. This bit does not have an associated mask bit and does not generate an interrupt.
Dependency: This bit is valid in non Scatter/Gather DMA mode when periodic transfer interrupt feature is selected.</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>BNAIntr</name>
              <description>BNA (Buffer Not Available) Interrupt (BNAIntr)
This bit is valid only when Scatter/Gather DMA mode is enabled.
The core generates this interrupt when the descriptor accessed is not ready for the Core to process, such as Host busy or DMA done</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OutPktErr</name>
              <description>OUT Packet Error (OutPktErr)
Applies to OUT endpoints Only
This interrupt is valid only when thresholding is enabled. This interrupt is asserted when the core detects an overflow or a CRC error for non-Isochronous OUT packet.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>Back2BackSETup</name>
              <description>Back-to-Back SETUP Packets Received (Back2BackSETup)
Applies to Control OUT endpoints only.
This bit indicates that the core has received more than three back-to-back SETUP packets for this particular endpoint. For information about handling this interrupt,</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>StsPhseRcvd</name>
              <description>Status Phase Received for Control Write (StsPhseRcvd)
This interrupt is valid only for Control OUT endpoints.
This interrupt is generated only after the core has transferred all the data that the host has sent during the data phase of a control write transfer, to the system memory buffer.
The interrupt indicates to the application that the host has switched from data phase to the status phase of a Control Write transfer. The application can use this interrupt to ACK or STALL the Status phase, after it has decoded the data phase. This is applicable only in Case of Scatter Gather DMA mode.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OUTTknEPdis</name>
              <description>OUT Token Received When Endpoint Disabled (OUTTknEPdis)
Applies only to control OUT endpoints.
Indicates that an OUT token was received when the endpoint was not yet enabled. This interrupt is asserted on the endpoint for which the OUT token was received.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SetUp</name>
              <description>SETUP Phase Done (SetUp)
Applies to control OUT endpoints only.
Indicates that the SETUP phase for the control endpoint is complete and no more back-to-back SETUP packets were received for the current control transfer. On this interrupt, the application can decode the received SETUP data packet.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>AHBErr</name>
              <description>AHB Error (AHBErr)
Applies to IN and OUT endpoints.
This is generated only in Internal DMA mode when there is an AHB error during an AHB read/write. The application can read the corresponding endpoint DMA address register to get the error address.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EPDisbld</name>
              <description>Endpoint Disabled Interrupt (EPDisbld)
Applies to IN and OUT endpoints.
This bit indicates that the endpoint is disabled per the application's request.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>XferCompl</name>
              <description>Transfer Completed Interrupt (XferCompl)
Applies to IN and OUT endpoints.
+ When Scatter/Gather DMA mode is enabled
- For IN endpoint this field indicates that the requested data from the descriptor is moved from external system memory to internal FIFO.
-For OUT endpoint this field indicates that the requested data from the internal FIFO is moved to external system memory. This interrupt is generated only when the corresponding endpoint descriptor is closed, and the IOC bit for the corresponding descriptor is Set.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <!--DOEPDMA4 : Device OUT Endpoint 4 DMA Address Register-->
        <register>
          <name>DOEPDMA4</name>
          <description>Device OUT Endpoint 4 DMA Address Register</description>
          <addressOffset>0xb94</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>DMAAddr</name>
              <description>Holds the start address of the external memory for storing or fetching endpoint data.
Note: For control endpoints, this field stores control OUT data packets as well as SETUP transaction data packets. When more than three SETUP packets are received back-to-back, the SETUP data packet in the memory is overwritten.
This register is incremented on every AHB transaction. The application can give only a DWORD-aligned address.
+ When Scatter/Gather DMA mode is enabled, this field indicates the base pointer for the descriptor list.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <!--DOEPDMAB4 : Device OUT Endpoint 16 Buffer Address Register-->
        <register>
          <name>DOEPDMAB4</name>
          <description>Device OUT Endpoint 16 Buffer Address Register</description>
          <addressOffset>0xb9c</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>DMABufferAddr</name>
              <description>Holds the current buffer address.This register is updated as and when the data transfer for the corresponding end point is in progress.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <!--PCGCCTL : Power and Clock Gating Control Register-->
        <register>
          <name>PCGCCTL</name>
          <description>Power and Clock Gating Control Register</description>
          <addressOffset>0xe00</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RestoreValue</name>
              <description>Restore Value (RestoreValue)
When Hibernation mode is enabled, the RestoreValue needs to be be read at SAVE_POINT to store in non-volatile memory and at RESTORE_POINT restored before PCGCCTL.EssRegRestored field is set.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>18</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EssRegRestored</name>
              <description>Essential Register Values Restored (EssRegRestored)
A write of one into this field indicates that register values of essential registers have been restored. For definition of essential registers, refer programming flow section for Hibernation.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RestoreMode</name>
              <description>Restore Mode (RestoreMode)
The application should program this bit to specify the restore mode during RESTORE POINT before programming PCGCCTL.EssRegRest bit is set.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>L1Suspended</name>
              <description>L1 Deep Sleep
Indicates that the PHY is in deep sleep when in L1 state.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PhySleep</name>
              <description>PHY In Sleep
Indicates that the PHY is in Sleep State.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>Enbl_L1Gating</name>
              <description>Enable Sleep Clock Gating
If this bit is set, core internal clock gating is enabled sleep state if utmi_l1_suspend_n cannot be asserted by the core.
The PHY clock will not be gated in sleep state if Enbl_L1Gating is not set.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RstPdwnModule</name>
              <description>Reset Power-Down Modules (RstPdwnModule)
This bit is valid only in Partial Power-Down mode.
+ The application sets this bit when the power is turned off.
+ The application clears this bit after the power is turned on and the PHY clock is up.
Note: The R/W of all core registers are possible only when this bit is set to 1b0.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PwrClmp</name>
              <description>Power Clamp (PwrClmp)
This bit is valid only in Partial Power-Down mode
+ The application sets this bit before the power is turned off to clamp the signals between the power-on modules and the power-off modules.
+ The application clears the bit to disable the clamping before the power is turned on.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GateHclk</name>
              <description>Gate Hclk (GateHclk)
+ The application sets this bit to gate hclk to modules other than the AHB Slave and Master and wakeup logic when the USB is suspended or the session is not valid.
+ The application clears this bit when the USB is resumed or a new session starts.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>StopPclk</name>
              <description>Stop Pclk (StopPclk)
+ The application sets this bit to stop the PHY clock (phy_clk) when the USB is suspended, the session is not valid, or the device is disconnected.
+ The application clears this bit when the USB is resumed or a new session starts.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
  </peripherals>
</device>