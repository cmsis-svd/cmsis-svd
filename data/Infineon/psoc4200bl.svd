<?xml version="1.0" encoding="utf-8"?>
<!-- Generator version: 1.6.0.417 -->
<device schemaVersion="1.3" xmlns:xs="http://www.w3.org/2001/XMLSchema-instance" xs:noNamespaceSchemaLocation="CMSIS-SVD.xsd">
  <vendor>Cypress Semiconductor</vendor>
  <vendorID>Cypress</vendorID>
  <name>psoc4200bl</name>
  <series>PSoC4200BL</series>
  <version>1.0</version>
  <description>PSoC4200BL</description>
  <licenseText>Copyright 2016-2020 Cypress Semiconductor Corporation\n
    SPDX-License-Identifier: Apache-2.0\n
\n
    Licensed under the Apache License, Version 2.0 (the "License");\n
    you may not use this file except in compliance with the License.\n
    You may obtain a copy of the License at\n
\n
      http://www.apache.org/licenses/LICENSE-2.0\n
\n
    Unless required by applicable law or agreed to in writing, software\n
    distributed under the License is distributed on an "AS IS" BASIS,\n
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n
    See the License for the specific language governing permissions and\n
    limitations under the License.</licenseText>
  <cpu>
    <name>CM0</name>
    <revision>r0p1</revision>
    <endian>little</endian>
    <mpuPresent>false</mpuPresent>
    <fpuPresent>false</fpuPresent>
    <vtorPresent>0</vtorPresent>
    <nvicPrioBits>2</nvicPrioBits>
    <vendorSystickConfig>0</vendorSystickConfig>
  </cpu>
  <addressUnitBits>8</addressUnitBits>
  <width>32</width>
  <resetValue>0x00000000</resetValue>
  <resetMask>0xFFFFFFFF</resetMask>
  <peripherals>
    <peripheral>
      <name>PERI</name>
      <description>Peripheral Interconnect</description>
      <baseAddress>0x40010000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>65536</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>DIV_CMD</name>
          <description>Divider command register</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xFFFF</resetValue>
          <resetMask>0xC000FFFF</resetMask>
          <fields>
            <field>
              <name>SEL_DIV</name>
              <description>(SEL_TYPE, SEL_DIV) specifies the divider on which the command (DISABLE/ENABLE) is performed.
 
If SEL_DIV is '63' and 'SEL_TYPE' is '3' (default/reset value), no divider is specified and no clock signal(s) are generated.</description>
              <bitRange>[5:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SEL_TYPE</name>
              <description>Specifies the divider type of the divider on which the command is performed:
0: 8.0 (integer) clock dividers.
1: 16.0 (integer) clock dividers.
2: 16.5 (fractional) clock dividers.
3: 24.5 (fractional) clock dividers.</description>
              <bitRange>[7:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PA_SEL_DIV</name>
              <description>(PA_SEL_TYPE, PA_SEL_DIV) pecifies the divider to which phase alignment is performed for the clock enable command. Any enabled divider can be used as reference. This allows all dividers to be aligned with each other, even when they are enabled at different times.
 
If PA_SEL_DIV is '63' and 'PA_SEL_TYPE' is '3', 'clk_hf' is used as reference.</description>
              <bitRange>[13:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PA_SEL_TYPE</name>
              <description>Specifies the divider type of the divider to which phase alignment is performed for the clock enable command:
0: 8.0 (integer) clock dividers.
1: 16.0 (integer) clock dividers.
2: 16.5 (fractional) clock dividers.
3: 24.5 (fractional) clock dividers.</description>
              <bitRange>[15:14]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DISABLE</name>
              <description>Clock divider disable command (mutually exlusive with ENABLE). SW sets this field to '1' and HW sets this field to '0'.
 
The SEL_DIV and SEL_TYPE fields specify which divider is to be disabled.
 
The HW sets the DISABLE field to '0' immediately and the HW sets the DIV_XXX_CTL.EN field of the divider to '0' immediately.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ENABLE</name>
              <description>Clock divider enable command (mutually exclusive with DISABLE). Typically, SW sets this field to '1' to enable a divider and HW sets this field to '0' to indicate that divider enabling has completed. When a divider is enabled, its integer and fractional (if present) counters are initialized to '0'. If a divider is to be re-enabled using different integer and fractional divider values, the SW should follow these steps:
0: Disable the divider using the DIV_CMD.DISABLE field.
1: Configure the divider's DIV_XXX_CTL register.
2: Enable the divider using the DIV_CMD_ENABLE field.
 
The SEL_DIV and SEL_TYPE fields specify which divider is to be enabled. The enabled divider may be phase aligned to either 'clk_hf' (typical usage) or to ANY enabled divider.
 
The PA_SEL_DIV and P_SEL_TYPE fields specify the reference divider.
 
The HW sets the ENABLE field to '0' when the enabling is performed and the HW set the DIV_XXX_CTL.EN field of the divider to '1' when the enabling is performed. Note that enabling with phase alignment to a low frequency divider takes time. E.g. To align to a divider that generates a clock of 'clk_hf'/n (with n being the integer divider value INT_DIV+1), up to n cycles may be required to perform alignment. Phase alignment to 'clk_hf' takes affect immediately. SW can set this field to '0' during phase alignment to abort the enabling process.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>64</dim>
          <dimIncrement>4</dimIncrement>
          <name>PCLK_CTL[%s]</name>
          <description>Programmable clock control register</description>
          <addressOffset>0x100</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xFF</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>SEL_DIV</name>
              <description>Specifies one of the dividers of the divider type specified by SEL_TYPE.
 
If SEL_DIV is '63' and 'SEL_TYPE' is '3' (default/reset value), no divider is specified and no clock control signal(s) are generated.
 
When transitioning a clock between two out of phase dividers, spurious clock control signals may be generated for one 'clk_hf' cycle during this transition. These clock control signals may cause a single clock period that is smaller than any of the two divider periods. To prevent these spurious clock signals, the clock multiplexer can be disconnected (SEL_DIV is '63' and 'SEL_TYPE' is '3') for a transition time that is larger than the smaller of the two divider periods.</description>
              <bitRange>[5:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SEL_TYPE</name>
              <description>Specifies divider type:
0: 8.0 (integer) clock dividers.
1: 16.0 (integer) clock dividers.
2: 16.5 (fractional) clock dividers.
3: 24.5 (fractional) clock dividers.</description>
              <bitRange>[7:6]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>64</dim>
          <dimIncrement>4</dimIncrement>
          <name>DIV_8_CTL[%s]</name>
          <description>Divider control register (for 8.0 divider)</description>
          <addressOffset>0x200</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF01</resetMask>
          <fields>
            <field>
              <name>EN</name>
              <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
 
Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>INT8_DIV</name>
              <description>Integer division by (1+INT8_DIV). Allows for integer divisions in the range [1, 256]. Note: this type of divider does NOT allow for a fractional division.
 
For the generation of a divided clock, the integer division range is restricted to [2, 256].
 
For the generation of a 50/50 percent duty cycle digital divided clock, the integer division range is resticited to even numbers in the range [2, 256]. The generation of a 50/50  percent duty cycle analog divided clock has no restrictions.
 
Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
              <bitRange>[15:8]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>64</dim>
          <dimIncrement>4</dimIncrement>
          <name>DIV_16_CTL[%s]</name>
          <description>Divider control register (for 16.0 divider)</description>
          <addressOffset>0x300</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFF01</resetMask>
          <fields>
            <field>
              <name>EN</name>
              <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
 
Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>INT16_DIV</name>
              <description>Integer division by (1+INT16_DIV). Allows for integer divisions in the range [1, 65,536]. Note: this type of divider does NOT allow for a fractional division.
 
For the generation of a divided clock, the integer division range is restricted to [2, 65,536].
 
For the generation of a 50/50 percent duty cycle digital divided clock, the integer division range is restricted to even numbers in the range [2, 65,536]. The generation of a 50/50  percent duty cycle analog divided clock has no restrictions.
 
Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
              <bitRange>[23:8]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>64</dim>
          <dimIncrement>4</dimIncrement>
          <name>DIV_16_5_CTL[%s]</name>
          <description>Divider control register (for 16.5 divider)</description>
          <addressOffset>0x400</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFF9</resetMask>
          <fields>
            <field>
              <name>EN</name>
              <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
 
Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>FRAC5_DIV</name>
              <description>Fractional division by (FRAC5_DIV/32). Allows for fractional divisions in the range [0, 31/32]. Note that fractional division results in clock jitter as some clock periods may be 1 'clk_hf' cycle longer than other clock periods.
 
Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
              <bitRange>[7:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INT16_DIV</name>
              <description>Integer division by (1+INT16_DIV). Allows for integer divisions in the range [1, 65,536]. Note: combined with fractional division, this divider type allows for a division in the range [1, 65,536 31/32] in 1/32 increments.
 
For the generation of a divided clock, the division range is restricted to [2, 65,536 31/32].
 
For the generation of a 50/50 percent duty cycle divided clock, the  division range is restricted to [2, 65,536].
 
Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
              <bitRange>[23:8]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>63</dim>
          <dimIncrement>4</dimIncrement>
          <name>DIV_24_5_CTL[%s]</name>
          <description>Divider control register (for 24.5 divider)</description>
          <addressOffset>0x500</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFF9</resetMask>
          <fields>
            <field>
              <name>EN</name>
              <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
 
Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>FRAC5_DIV</name>
              <description>Fractional division by (FRAC5_DIV/32). Allows for fractional divisions in the range [0, 31/32]. Note that fractional division results in clock jitter as some clock periods may be 1 'clk_hf' cycle longer than other clock periods.
 
Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
              <bitRange>[7:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INT24_DIV</name>
              <description>Integer division by (1+INT24_DIV). Allows for integer divisions in the range [1, 16,777,216]. Note: combined with fractional division, this divider type allows for a division in the range [1, 16,777,216 31/32] in 1/32 increments.
 
For the generation of a divided clock, the integer division range is restricted to [2, 16,777,216 31/32].
 
For the generation of a 50/50 percent duty cycle divided clock, the  division range is restricted to [2, 16,777,216].
 
Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
              <bitRange>[31:8]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TR_CTL</name>
          <description>Trigger control register</description>
          <addressOffset>0x600</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xC0FF0F7F</resetMask>
          <fields>
            <field>
              <name>TR_SEL</name>
              <description>Specifies the activated trigger when TR_ACT is '1'. TR_OUT specifies whether the activated trigger is an input trigger or output trigger to the trigger multiplexer. During activation (TR_ACT is '1'), SW should not modify this register field. If the specified trigger is not present, the trigger activation has no effect.</description>
              <bitRange>[6:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TR_GROUP</name>
              <description>Specifies the trigger group.</description>
              <bitRange>[11:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TR_COUNT</name>
              <description>Amount of cycles a specific trigger is activated. During activation (TR_ACT is '1'), HW decrements this field to '0' using a cycle counter. During activation, SW should not modify this register field. A value of 255 is a special case: HW does NOT decrement this field to '0' and trigger activation is under direct control of TR_ACT: when TR_ACT is '1' the trigger is activated and when TR_ACT is '0' the trigger is deactivated.</description>
              <bitRange>[23:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TR_OUT</name>
              <description>Specifies whether trigger activation is for a specific input or ouput trigger of the trigger multiplexer. Activation of a specific input trigger, will result in activation of all output triggers that have the specific input trigger selected through their TR_OUT_CTL.SEL  field. Activation of a specific output trigger, will result in activation of the specified TR_SEL output trigger only.
'0': TR_SEL selection and trigger activation is for an input trigger to the trigger multiplexer.
'1': TR_SEL selection and trigger activation is for an output trigger from the trigger multiplexer.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TR_ACT</name>
              <description>SW sets this field to '1' by to activate (set to '1') a trigger as identified by TR_SEL and TR_OUT for TR_COUNT cycles. HW sets this field to '0' when the cycle counter is decremented to '0'. Note: a TR_COUNT value of 255 is a special case and trigger activation is under direct control of the TR_ACT field (the counter is not decremented).</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <cluster>
          <dim>16</dim>
          <dimIncrement>512</dimIncrement>
          <name>TR_GROUP[%s]</name>
          <description>Peripheral Interconnect trigger group control registers</description>
          <addressOffset>0x00002000</addressOffset>
          <register>
            <dim>128</dim>
            <dimIncrement>4</dimIncrement>
            <name>TR_OUT_CTL[%s]</name>
            <description>Trigger control register</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x7F</resetMask>
            <fields>
              <field>
                <name>SEL</name>
                <description>Specifies input trigger. This field is typically set during the setup of a chip use case scenario. Changing this field while activated triggers are present on the input triggers may result in unpredictable behavior. Note that input trigger 0 (default value) is typically connected to a constant signal level of '0', and as a result will not cause HW activation of the output trigger.</description>
                <bitRange>[6:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
      </registers>
    </peripheral>
    <peripheral>
      <name>HSIOM</name>
      <description>High Speed IO Matrix (HSIOM)</description>
      <baseAddress>0x40020000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>16384</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <cluster>
          <dim>7</dim>
          <dimIncrement>256</dimIncrement>
          <name>PRT[%s]</name>
          <description>HSIOM port registers</description>
          <addressOffset>0x00000000</addressOffset>
          <register>
            <name>PORT_SEL</name>
            <description>Port selection register</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>IO0_SEL</name>
                <description>Selects connection for IO pad 0 route.</description>
                <bitRange>[3:0]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>GPIO</name>
                    <description>SW controlled GPIO.</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>GPIO_DSI</name>
                    <description>SW controlled 'out', DSI controlled 'oe_n'.</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DSI_DSI</name>
                    <description>DSI controlled 'out' and 'oe_n'.</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DSI_GPIO</name>
                    <description>DSI controlled 'out', SW controlled 'oe_n'.</description>
                    <value>3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CSD_SENSE</name>
                    <description>CSD sense connection (analog mode)</description>
                    <value>4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CSD_SHIELD</name>
                    <description>CSD shield connection (analog mode)</description>
                    <value>5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>AMUXA</name>
                    <description>AMUXBUS A connection.</description>
                    <value>6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>AMUXB</name>
                    <description>AMUXBUS B connection. This mode is also used for CSD GPIO charging.  When CSD GPIO charging is enabled in CSD_CONTROL, 'oe_n' is connected to '!csd_charge' signal (and IO pad is also still connected to AMUXBUS B).</description>
                    <value>7</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACT_0</name>
                    <description>Chip specific Active source 0 connection.</description>
                    <value>8</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACT_1</name>
                    <description>Chip specific Active source 1 connection.</description>
                    <value>9</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACT_2</name>
                    <description>Chip specific Active source 2 connection.</description>
                    <value>10</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACT_3</name>
                    <description>Chip specific Active source 3 connection.</description>
                    <value>11</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>LCD_COM</name>
                    <description>LCD common connection. This mode provides DeepSleep functionality  (provided that the LCD block is enabled and properly configured).</description>
                    <value>12</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>LCD_SEG</name>
                    <description>LCD segment connection. This mode provides DeepSleep functionality  (provided that the LCD block is enabled and properly configured).</description>
                    <value>13</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DS_2</name>
                    <description>Chip specific DeepSleep source 2 connection.</description>
                    <value>14</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DS_3</name>
                    <description>Chip specific DeepSleep source 3 connection.</description>
                    <value>15</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>IO1_SEL</name>
                <description>Selects connection for IO pad 1 route.</description>
                <bitRange>[7:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>IO2_SEL</name>
                <description>Selects connection for IO pad 2 route.</description>
                <bitRange>[11:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>IO3_SEL</name>
                <description>Selects connection for IO pad 3 route.</description>
                <bitRange>[15:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>IO4_SEL</name>
                <description>Selects connection for IO pad 4 route.</description>
                <bitRange>[19:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>IO5_SEL</name>
                <description>Selects connection for IO pad 5 route.</description>
                <bitRange>[23:20]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>IO6_SEL</name>
                <description>Selects connection for IO pad 6 route.</description>
                <bitRange>[27:24]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>IO7_SEL</name>
                <description>Selects connection for IO pad 7 route.</description>
                <bitRange>[31:28]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
        <register>
          <name>PUMP_CTL</name>
          <description>Pump control</description>
          <addressOffset>0x2000</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x80000001</resetMask>
          <fields>
            <field>
              <name>CLOCK_SEL</name>
              <description>Clock select:
'0': External clock.
'1': Internal clock (deprecated).</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ENABLED</name>
              <description>Pump enabled:
'0': Disabled.
'1': Enabled.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>8</dim>
          <dimIncrement>4</dimIncrement>
          <name>AMUX_SPLIT_CTL[%s]</name>
          <description>AMUX splitter cell control</description>
          <addressOffset>0x2100</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x77</resetMask>
          <fields>
            <field>
              <name>SWITCH_AA_SL</name>
              <description>T-switch control for Left AMUXBUSA switch:
'0': switch open.
'1': switch closed.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SWITCH_AA_SR</name>
              <description>T-switch control for Right AMUXBUSA switch:
'0': switch open.
'1': switch closed.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SWITCH_AA_S0</name>
              <description>T-switch control for AMUXBUSA vssa/ground switch:
'0': switch open.
'1': switch closed.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SWITCH_BB_SL</name>
              <description>T-switch control for Left AMUXBUSB switch.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SWITCH_BB_SR</name>
              <description>T-switch control for Right AMUXBUSB switch.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SWITCH_BB_S0</name>
              <description>T-switch control for AMUXBUSB vssa/ground switch.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>TST</name>
      <description>Test Subsystem</description>
      <baseAddress>0x40030000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>65536</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>MODE</name>
          <description>Test Mode Control Register</description>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xC0000004</resetMask>
          <fields>
            <field>
              <name>SWD_CONNECTED</name>
              <description>0: SWD not active
1: SWD activated (Line Reset &amp; Connect sequence passed)
(Note: this bit replaces TST_CTRL.SWD_CONNECTED and is present in all M0S8 products except TSG4)</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>POR_BYPASS</name>
              <description>This bit is set during POR bypass mode.  When this bit is set, the BootROM will not yield execution to the FLASH image (same function as setting TEST_MODE bit below).</description>
              <bitRange>[30:30]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>TEST_MODE</name>
              <description>0: Normal operation mode
1: Test mode (any test mode)
Setting this bit will prevent BootROM from yielding execution to Flash image.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>GPIO</name>
      <description>GPIO port control/configuration</description>
      <baseAddress>0x40040000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>16384</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <cluster>
          <dim>7</dim>
          <dimIncrement>256</dimIncrement>
          <name>PRT[%s]</name>
          <description>GPIO port registers</description>
          <addressOffset>0x00000000</addressOffset>
          <register>
            <name>DR</name>
            <description>Port output data register</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>DATA0</name>
                <description>IO pad 0 output data.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DATA1</name>
                <description>IO pad 1 output data.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DATA2</name>
                <description>IO pad 2 output data.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DATA3</name>
                <description>IO pad 3 output data.</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DATA4</name>
                <description>IO pad 4 output data.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DATA5</name>
                <description>IO pad 5 output data.</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DATA6</name>
                <description>IO pad 6 output data.</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DATA7</name>
                <description>IO pad 7 output data.</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>PS</name>
            <description>Port IO pad state register</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1FF</resetMask>
            <fields>
              <field>
                <name>DATA0</name>
                <description>IO pad 0 state:
1: Logic high, if the pin voltage is above the input buffer threshold, logic high.
0: Logic low, if the pin voltage is below that threshold, logic low.
If the drive mode for the pin is set to high Z Analog, the pin state will read 0 independent of the voltage on the pin.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>DATA1</name>
                <description>IO pad 1 state.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>DATA2</name>
                <description>IO pad 2 state.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>DATA3</name>
                <description>IO pad 3 state.</description>
                <bitRange>[3:3]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>DATA4</name>
                <description>IO pad 4 state.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>DATA5</name>
                <description>IO pad 5 state.</description>
                <bitRange>[5:5]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>DATA6</name>
                <description>IO pad 6 state.</description>
                <bitRange>[6:6]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>DATA7</name>
                <description>IO pad 7 state.</description>
                <bitRange>[7:7]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>FLT_DATA</name>
                <description>Reads of this register return the logical state of the filtered pin.</description>
                <bitRange>[8:8]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>PC</name>
            <description>Port configuration register</description>
            <addressOffset>0x8</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFBFFFFFF</resetMask>
            <fields>
              <field>
                <name>DM0</name>
                <description>The GPIO drive mode for IO pad 0.
Note: when initializing IO's that are connected to a live bus (such as I2C), make sure the HSIOM is properly configured (HSIOM_PRT_SELx) before turning the IO on here to avoid producing glitches on the bus.</description>
                <bitRange>[2:0]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>OFF</name>
                    <description>Mode 0 (analog mode): Output buffer off (high Z). Input buffer off.</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>INPUT</name>
                    <description>Mode 1: Output buffer off (high Z). Input buffer on.</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>0_PU</name>
                    <description>Mode 2: Strong pull down ('0'), weak/resistive pull up (PU). Input buffer on.</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>PD_1</name>
                    <description>Mode 3: Weak/resistive pull down (PD), strong pull up ('1'). Input buffer on.</description>
                    <value>3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>0_Z</name>
                    <description>Mode 4: Strong pull down ('0'), open drain (pull up off). Input buffer on.</description>
                    <value>4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Z_1</name>
                    <description>Mode 5: Open drain (pull down off), strong pull up ('1'). Input buffer on.</description>
                    <value>5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>0_1</name>
                    <description>Mode 6: Strong pull down ('0'), strong pull up ('1'). Input buffer on.</description>
                    <value>6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>PD_PU</name>
                    <description>Mode 7: Weak/resistive pull down (PD), weak/resistive pull up (PU). Input buffer on.</description>
                    <value>7</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DM1</name>
                <description>The GPIO drive mode for IO pad 1.</description>
                <bitRange>[5:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DM2</name>
                <description>The GPIO drive mode for IO pad 2.</description>
                <bitRange>[8:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DM3</name>
                <description>The GPIO drive mode for IO pad 3.</description>
                <bitRange>[11:9]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DM4</name>
                <description>The GPIO drive mode for IO pad 4.</description>
                <bitRange>[14:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DM5</name>
                <description>The GPIO drive mode for IO pad 5.</description>
                <bitRange>[17:15]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DM6</name>
                <description>The GPIO drive mode for IO pad 6.</description>
                <bitRange>[20:18]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DM7</name>
                <description>The GPIO drive mode for IO pad 7.</description>
                <bitRange>[23:21]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PORT_VTRIP_SEL</name>
                <description>The GPIO cells include a VTRIP_SEL signal to alter the input buffer voltage. Note: this bit is ignored for SIO ports, the VTRIP_SEL settings in the SIO register are used instead (a separate VTRIP_SEL is provided for each pin pair).
0: input buffer functions as a CMOS input buffer.
1: input buffer functions as a LVTTL input buffer.</description>
                <bitRange>[24:24]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PORT_SLOW</name>
                <description>This field controls the output edge rate of all pins on the port:
'0': fast.
'1': slow.</description>
                <bitRange>[25:25]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PORT_HYST_TRIM</name>
                <description>This field is used to improve the hysteresis (to 10 percent of vddio) of the selectable trip point input buffer. The voltage reference comes from the VREFGEN block and is only available when using the VREFGEN block:
'0': &lt;= 2.2 V input signaling Voltage.
'1': &gt; 2.2 V input signaling Voltage.</description>
                <bitRange>[27:27]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PORT_SLEW_CTL</name>
                <description>Slew control. Only used in the O_Z drive mode (mode 4: strong pull down, open drain): This field is intended for I2C functionality. See BROS 001-70428 for more details.</description>
                <bitRange>[29:28]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>PORT_SLEW_CTL_0</name>
                    <description>HS mode (100pf &lt; Cb &lt; 400pF, 1.71&lt;VDDD&lt;5.5, Vext&gt;3.0)
FS mode (10pf&lt;Cb&lt;400pf,1.71&lt;VDDD&lt;5.5) (20-160ns)</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>PORT_SLEW_CTL_1</name>
                    <description>HS mode (Cb&lt;100pf,1.71&lt;VDDD&lt;5.5,Vext&gt;2.8,F=1.7MHz) (10-80ns)
FS+ Mode (Vext&gt;2.8,1.71&lt;VDDD&lt;5.5) (20-120ns)</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>PORT_SLEW_CTL_2</name>
                    <description>HS mode (100pf&lt;Cb&lt;400pf, 1.71&lt;VDDD&lt;5.5,Vext&lt;3.3) (20-160ns)</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>PORT_SLEW_CTL_3</name>
                    <description>HS mode (Cb&lt;100pf,1.71&lt;VDDD&lt;5.5,Vext&lt;=2.8,F=1.7MHz) (10-80ns)
FS+ mode (Vext&lt;=2.8,1.71&lt;VDDD&lt;5.5) (20-120ns)</description>
                    <value>3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PORT_IB_MODE_SEL</name>
                <description>This field selects the input buffer reference. The size (1 or 2 bits) and functionality is dependent on the IO cell.
For GPIOv2 IO cells, bit PORT_IB_MODE_SEL[1] is not used (GPIOv2 IO cell replaces GPIO IO cell):
'0'/'2': CMOS input buffer (PORT_VTRIP_SEL is '0'), LVTTL input buffer (PORT_VTRIP_SEL is '1')
'1'/'3': vcchib.
For GPIO_OVTv2 and SIOv2 IO cells:
'0': CMOS input buffer (PORT_VTRIP_SEL is '0'), LVTTL input buffer (PORT_VTRIP_SEL is '1')
'1': vcchib.
'2': OVT.
'3': Reference (possibly from reference generator cell).
For SIO IO cell, this field is present but not used as the SIO IO cell does not provide input buffer mode select functionality (SIOv2 IO cell will replace SIO IO cell, as soon as it is available).</description>
                <bitRange>[31:30]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_CFG</name>
            <description>Port interrupt configuration register</description>
            <addressOffset>0xC</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1FFFFF</resetMask>
            <fields>
              <field>
                <name>EDGE0_SEL</name>
                <description>Sets which edge will trigger an IRQ for IO pad 0.</description>
                <bitRange>[1:0]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>DISABLE</name>
                    <description>Disabled</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>RISING</name>
                    <description>Rising edge</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>FALLING</name>
                    <description>Falling edge</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>BOTH</name>
                    <description>Both rising and falling edges</description>
                    <value>3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>EDGE1_SEL</name>
                <description>Sets which edge will trigger an IRQ for IO pad 1.</description>
                <bitRange>[3:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EDGE2_SEL</name>
                <description>Sets which edge will trigger an IRQ for IO pad 2.</description>
                <bitRange>[5:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EDGE3_SEL</name>
                <description>Sets which edge will trigger an IRQ for IO pad 3.</description>
                <bitRange>[7:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EDGE4_SEL</name>
                <description>Sets which edge will trigger an IRQ for IO pad 4.</description>
                <bitRange>[9:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EDGE5_SEL</name>
                <description>Sets which edge will trigger an IRQ for IO pad 5.</description>
                <bitRange>[11:10]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EDGE6_SEL</name>
                <description>Sets which edge will trigger an IRQ for IO pad 6.</description>
                <bitRange>[13:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EDGE7_SEL</name>
                <description>Sets which edge will trigger an IRQ for IO pad 7.</description>
                <bitRange>[15:14]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>FLT_EDGE_SEL</name>
                <description>Same for the glitch filtered pin (selected by FLT_SELECT).</description>
                <bitRange>[17:16]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>DISABLE</name>
                    <description>Disabled</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>RISING</name>
                    <description>Rising edge</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>FALLING</name>
                    <description>Falling edge</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>BOTH</name>
                    <description>Both rising and falling edges</description>
                    <value>3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>FLT_SEL</name>
                <description>Selects which pin is routed through the 50ns glitch filter to provide a glitch-safe interrupt.</description>
                <bitRange>[20:18]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR</name>
            <description>Port interrupt status register</description>
            <addressOffset>0x10</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1FF01FF</resetMask>
            <fields>
              <field>
                <name>DATA0</name>
                <description>Interrupt pending on IO pad 0. Firmware writes 1 to clear the interrupt.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DATA1</name>
                <description>Interrupt pending on IO pad 1. Firmware writes 1 to clear the interrupt.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DATA2</name>
                <description>Interrupt pending on IO pad 2. Firmware writes 1 to clear the interrupt.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DATA3</name>
                <description>Interrupt pending on IO pad 3. Firmware writes 1 to clear the interrupt.</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DATA4</name>
                <description>Interrupt pending on IO pad 4. Firmware writes 1 to clear the interrupt.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DATA5</name>
                <description>Interrupt pending on IO pad 5. Firmware writes 1 to clear the interrupt.</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DATA6</name>
                <description>Interrupt pending on IO pad 6. Firmware writes 1 to clear the interrupt.</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DATA7</name>
                <description>Interrupt pending on IO pad 7. Firmware writes 1 to clear the interrupt.</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>FLT_DATA</name>
                <description>Deglitched interrupt pending (selected by FLT_SELECT).</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PS_DATA0</name>
                <description>`</description>
                <bitRange>[16:16]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PS_DATA1</name>
                <description>N/A</description>
                <bitRange>[17:17]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PS_DATA2</name>
                <description>N/A</description>
                <bitRange>[18:18]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PS_DATA3</name>
                <description>N/A</description>
                <bitRange>[19:19]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PS_DATA4</name>
                <description>N/A</description>
                <bitRange>[20:20]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PS_DATA5</name>
                <description>N/A</description>
                <bitRange>[21:21]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PS_DATA6</name>
                <description>N/A</description>
                <bitRange>[22:22]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PS_DATA7</name>
                <description>N/A</description>
                <bitRange>[23:23]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PS_FLT_DATA</name>
                <description>This is a duplicate of the contents of the PS register, provided here to allow reading of both pin state and interrupt state of the port in a single read operation.</description>
                <bitRange>[24:24]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SIO</name>
            <description>Port SIO configuration register</description>
            <addressOffset>0x14</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>PAIR_VREG01_EN</name>
                <description>Selects output buffer mode:
0: unregulated output buffer
1: regulated output buffer</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PAIR_IBUF01_SEL</name>
                <description>Selects input buffer mode:
0: singled ended input buffer
1: differential input buffer</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PAIR_VTRIP01_SEL</name>
                <description>Selects trip-point of input buffer. In single ended input buffer mode (IBUF01_SEL = '0'):
0: input buffer functions as a CMOS input buffer.
1: input buffer functions as a LVTTL input buffer.
In differential input buffer mode (IBUF01_SEL = '1')
'0': trip-point is 0.5*Vddio or 0.5*Voh (depends on VREF_SEL/VOH_SEL)
'1': trip-point is 0.4*Vddio or 1.0*Vref  (depends on VREF_SEL)

Please refer to s8iom0s8 BROS 001-70428, section 4.2.7  for more details.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PAIR_VREF01_SEL</name>
                <description>Selects reference voltage Vref for trip-point of input buffer:
0: trip-point reference of SRSS internal referece Vref (1.2V)
1: trip-point reference of SRSS internal referece Vref (1.2V)
2: trip-point reference of AMUXBUS_A
3: trip-point reference of AMUXBUS_B

Please refer to s8iom0s8 BROS 001-70428, section 4.2.7 for more details.</description>
                <bitRange>[4:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PAIR_VOH01_SEL</name>
                <description>Selects regulated Voh output level and trip point of input buffer for a specific SIO pin pair. Voh depends on the selected reference voltage (VREF_SEL). 
0: Voh = 1*reference; e.g. reference at 1.2V -&gt; Voh = 1.2V 
1: Voh = 1.25*reference; e.g. reference at 1.2V -&gt; Voh = 1.5V
2: Voh = 1.49*reference; e.g. reference at 1.2V -&gt; Voh = ~1.8V
3: Voh = 1.67*reference; e.g. reference at 1.2V -&gt; Voh = 2V
4: Voh = 2.08*reference; e.g. reference at 1.2V -&gt; Voh = 2.5V
5: Voh = 2.5*reference; e.g. reference at 1.2V -&gt; Voh = 3V
6: Voh = 2.78*reference; e.g. reference at 1.2V -&gt; Voh = ~3.3V
7: Voh = 4.16*reference; e.g. reference at 1.2V -&gt; Voh = 5.0V
Note: The upper value on VOH is limited to Vddio - 400mV</description>
                <bitRange>[7:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PAIR_VREG23_EN</name>
                <description>See corresponding definition for IO pads 2 and 3.</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PAIR_IBUF23_SEL</name>
                <description>See corresponding definition for IO pads 2 and 3.</description>
                <bitRange>[9:9]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PAIR_VTRIP23_SEL</name>
                <description>See corresponding definition for IO pads 2 and 3.</description>
                <bitRange>[10:10]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PAIR_VREF23_SEL</name>
                <description>See corresponding definition for IO pads 2 and 3.</description>
                <bitRange>[12:11]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PAIR_VOH23_SEL</name>
                <description>See corresponding definition for IO pads 2 and 3.</description>
                <bitRange>[15:13]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PAIR_VREG45_EN</name>
                <description>See corresponding definition for IO pads 4 and 5.</description>
                <bitRange>[16:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PAIR_IBUF45_SEL</name>
                <description>See corresponding definition for IO pads 4 and 5.</description>
                <bitRange>[17:17]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PAIR_VTRIP45_SEL</name>
                <description>See corresponding definition for IO pads 4 and 5.</description>
                <bitRange>[18:18]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PAIR_VREF45_SEL</name>
                <description>See corresponding definition for IO pads 4 and 5.</description>
                <bitRange>[20:19]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PAIR_VOH45_SEL</name>
                <description>See corresponding definition for IO pads 4 and 5.</description>
                <bitRange>[23:21]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PAIR_VREG67_EN</name>
                <description>See corresponding definition for IO pads 6 and 7.</description>
                <bitRange>[24:24]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PAIR_IBUF67_SEL</name>
                <description>See corresponding definition for IO pads 6 and 7.</description>
                <bitRange>[25:25]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PAIR_VTRIP67_SEL</name>
                <description>See corresponding definition for IO pads 6 and 7.</description>
                <bitRange>[26:26]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PAIR_VREF67_SEL</name>
                <description>See corresponding definition for IO pads 6 and 7.</description>
                <bitRange>[28:27]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PAIR_VOH67_SEL</name>
                <description>See corresponding definition for IO pads 6 and 7.</description>
                <bitRange>[31:29]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>PC2</name>
            <description>Port configuration register 2</description>
            <addressOffset>0x18</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>INP_DIS0</name>
                <description>Disables the input buffer for IO pad 0 independent of the port control drive mode (PC.DM). This bit should be set when analog signals are present on the pin and PC.DM != 0 is required to use the output driver.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>INP_DIS1</name>
                <description>Disables the input buffer for IO pad 1.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>INP_DIS2</name>
                <description>Disables the input buffer for IO pad 2.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>INP_DIS3</name>
                <description>Disables the input buffer for IO pad 3.</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>INP_DIS4</name>
                <description>Disables the input buffer for IO pad 4.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>INP_DIS5</name>
                <description>Disables the input buffer for IO pad 5.</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>INP_DIS6</name>
                <description>Disables the input buffer for IO pad 6.</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>INP_DIS7</name>
                <description>Disables the input buffer for IO pad 7.</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DR_SET</name>
            <description>Port output data set register</description>
            <addressOffset>0x40</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>DATA</name>
                <description>IO pad i:
'0': Output state DR.DATA[i] not affected.
'1': Output state DR.DATA[i] set to '1'.</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DR_CLR</name>
            <description>Port output data clear register</description>
            <addressOffset>0x44</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>DATA</name>
                <description>IO pad i:
'0': Output state DR.DATA[i] not affected.
'1': Output state DR.DATA[i] set to '0'.</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DR_INV</name>
            <description>Port output data invert register</description>
            <addressOffset>0x48</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>DATA</name>
                <description>IO pad i:
'0': Output state DR.DATA[i] not affected.
'1': Output state DR.DATA[i] inverted ('0' =&gt; '1', '1' =&gt; '0').</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>VREFGEN</name>
            <description>Reference generator configuration register</description>
            <addressOffset>0x80</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x11F</resetMask>
            <fields>
              <field>
                <name>REF_SEL</name>
                <description>Reference selection. A reference Voltage vinref is created using a Voltage vddio:
'0': vinref = (0 * 13 + 184)/600 * vddio = 184/600 * vddio.
'1': vinref = (1 * 13 + 184)/600 * vddio = 197/600 * vddio.
'2': vinref = (2 * 13 + 184)/600 * vddio = 210/600 * vddio.
...
'31': vinref = (31 * 13 + 184)/600 * vddio = 587/600 * vddio.</description>
                <bitRange>[4:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VREFGEN_EN</name>
                <description>Reference generator enable:
'0': Disabled.
'1': Enabled.</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
        <register>
          <name>INTR_CAUSE</name>
          <description>Interrupt port cause register</description>
          <addressOffset>0x1000</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PORT_INT</name>
              <description>Each IO port has an associated bit field in this register. The bit field reflects the IO port's interrupt line (bit field i reflects 'gpio_interrupts[i]' for IO port i). The register is used when the system uses a shared/combined interrupt line 'gpio_interrupt'. The SW ISR reads the register to deternine which IO port(s) is responsible for the shared/combined interrupt line 'gpio_interrupt'. Once, the IO port(s) is determined, the IO port's INTR register is read to determine the IO pad(s) in the IO port that caused the interrupt.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>CORE</name>
      <description>SRSSv2 Registers (Power, Clock, Reset)</description>
      <baseAddress>0x400B0000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>65536</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>PWR_CONTROL</name>
          <description>Power Mode Control</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x81000000</resetValue>
          <resetMask>0xBB80003F</resetMask>
          <fields>
            <field>
              <name>POWER_MODE</name>
              <description>Current power mode of the device.  Note that this field cannot be read in all power modes on actual silicon.</description>
              <bitRange>[3:0]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>RESET</name>
                  <description>RESET state</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ACTIVE</name>
                  <description>ACTIVE state</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SLEEP</name>
                  <description>SLEEP state</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DEEP_SLEEP</name>
                  <description>DEEP_SLEEP state</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HIBERNATE</name>
                  <description>HIBERNATE state</description>
                  <value>4</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DEBUG_SESSION</name>
              <description>Indicates whether a debug session is active (CDBGPWRUPREQ signal is 1)</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_SESSION</name>
                  <description>No debug session active</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SESSION_ACTIVE</name>
                  <description>Debug session is active</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>LPM_READY</name>
              <description>Indicates whether the low power mode regulators are ready to enter DEEPSLEEP or HIBERNATE mode.  
0: If DEEPSLEEP or HIBERNATE mode is requested, device will enter SLEEP mode.  When low power regulators are ready, device will automatically enter the originally requested mode.
1: Normal operation.  DEEPSLEEP and HIBERNATE work as described.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>EXT_VCCD</name>
              <description>Should be set by firmware if Vccd is provided externally (on Vccd pin).  Setting this bit turns off the active regulator and will lead to system reset (PBOD) unless both Vddd and Vccd pins are supplied externally.</description>
              <bitRange>[23:23]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HVMON_ENABLE</name>
              <description>0: HV State Monitoring is disabled
1: HV State Monitoring is automatically enable by sleep controller</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HVMON_RELOAD</name>
              <description>Firmware writes 1 to reload HV State in hibernate shadow copy.  Hardware clears this bit after reload was successful.  Wait at least 9 cycles after writing/recalling NVL before reloading the HVMON.</description>
              <bitRange>[25:25]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FIMO_DISABLE</name>
              <description>This bit is asserted during the boot process
0: Forces IMO to operate at 12MHz, ignore its frequency and trim settings and operate independent on its external references.
1: Turns IMO into normal operational mode</description>
              <bitRange>[27:27]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HIBERNATE_DISABLE</name>
              <description>0: Normal operation, HIBERNATE works as described
1: HIBERNATE bit is ignored, Hibernate mode is permanently disabled (part will go to DeepSleep instead.
Note: This bit is a write-once bit until the next reset.</description>
              <bitRange>[28:28]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LFCLK_SHORT</name>
              <description>Short Vcclfclk and Vccdpslp power rails in DeepSleep power mode.  This mode selection affects the accuracy specifications of the ILO oscillator due to supply noise.  See Data Sheet for more details.
0: Do not short power domains
1: Short power domains</description>
              <bitRange>[29:29]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HIBERNATE</name>
              <description>Selects between HIBERNATE/DEEPSLEEP modes when Cortex-M0 enters low power mode (SleepDeep).  Note: this bit is ignored when HIBERNATE_DISABLE=1.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DEEP_SLEEP</name>
                  <description>Enter DeepSleep mode when CPU asserts SLEEPDEEP signal</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HIBERNATE</name>
                  <description>Enter Hibernate mode when CPU asserts SLEEPDEEP signal</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>PWR_INTR</name>
          <description>Power System Interrupt Register</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x2</resetMask>
          <fields>
            <field>
              <name>LVD</name>
              <description>Indicates an Low Voltage Detect interrupt</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PWR_INTR_MASK</name>
          <description>Power System Interrupt Mask Register</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x2</resetMask>
          <fields>
            <field>
              <name>LVD</name>
              <description>1: Propagate interrupt to CPU</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PWR_KEY_DELAY</name>
          <description>Power System Key&amp;Delay Register</description>
          <addressOffset>0xC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x30C</resetValue>
          <resetMask>0x3FF</resetMask>
          <fields>
            <field>
              <name>WAKEUP_HOLDOFF</name>
              <description>Delay (in 12MHz IMO clock cycles) to wait for references to settle on wakeup from hibernate/deepsleep.  PBOD is ignored and system does not resume until this delay expires. Note that the same delay on POR is hard-coded.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PWR_PWRSYS_CONFIG</name>
          <description>Power System Trim and Configuration</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x200</resetValue>
          <resetMask>0x300</resetMask>
          <fields>
            <field>
              <name>HIB_TEST_EN</name>
              <description>Bias control for the DSBOD/HBOD. (engineering only)
0: low power biasing
1: turbo biasing</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HIB_TEST_REP</name>
              <description>When set the enhanced replica load regulation circuit is enabled.  When clear, the enhancments are disabled at the cost of higher current.  (engineering only)</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PWR_BG_CONFIG</name>
          <description>Bandgap Trim and Configuration</description>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x701FF</resetMask>
          <fields>
            <field>
              <name>BG_DFT_EN</name>
              <description>Enables DFT capability for Bandgap.  (engineering only)</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BG_DFT_VREF_SEL</name>
              <description>ADFT mux select for Reference System characterization (engineering only).  Select a voltage reference to output on adft_bg_ref
0=vgnd
1=vref_fast[0]
2=vref_fast[1]
3=vref_fast[2]
4=vref_fast[3]
5=vref_fast[4]
6=vref_fast[5]
7=vref_fast[6]
8=vref_fast[7]
9=vref[0]
10=vref[1]
11=vref[2]
12=vctat
13=iref_dft (see BG_DFT_ICORE_SEL)
14=imo_iref (current)
15=inl_imoref (voltage)</description>
              <bitRange>[4:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BG_DFT_CORE_SEL</name>
              <description>ADFT mux select for Bandgap characterization (engineering only).  Selects which BG core signal to output on adft_bg_core
0=BG core voltage selected by BG_DFT_VCORE_SEL (mux2out)
1=BG core current selected by BG_DFT_ICORE_SEL (mux1out)</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BG_DFT_ICORE_SEL</name>
              <description>ADFT mux select for Bandgap characterization (engineering only). Selects a BG core current to output on mux1out
0=iptat (current
1=ictat (current)
2=inl_cross_over detect (voltage)
3=iref9p6u_dft (dedicated output for DFT)
Also selects a currect for iref_dft (when BG_DFT_VREF_SEL=13)
0=iref2p4u[1]
1=iptat2p4u[7]
2=iref_imo (9.6uA current output from IMO IBG)
3=iref3u_dft (dedicated output for DFT)</description>
              <bitRange>[7:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BG_DFT_VCORE_SEL</name>
              <description>ADFT mux select for Bandgap characterization (engineering only). Selects a BG core voltage to output on mux2out
0=vout
1=vgnd</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>VREF_EN</name>
              <description>Reference voltage enable.  Each bit enables a reference voltage used by a peripheral:
vref[0] = 1 enables SRSS.VREF[0] to 1.024V
vref[1] = 1 enables SRSS.VREF[1] to 1.024V
vref[2] = 1 enables SRSS.VREF[2] to 1.2V

These references require 40us to settle after enabling them and 30us to settle after wakng from DeepSleep.</description>
              <bitRange>[18:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PWR_VMON_CONFIG</name>
          <description>Voltage Monitoring Trim and Configuration</description>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3FF</resetMask>
          <fields>
            <field>
              <name>LVD_EN</name>
              <description>Enable Low Voltage Detect circuit.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LVD_SEL</name>
              <description>Threshold selection for Low Voltage Detect circuit.  Disable the LVD (LVD_EN=0) before changing the threshold.  Threshold variation is +/- 2.5 percent from these typical voltage choices:
0: 1.7500 V
1: 1.8000 V
2: 1.9000 V
3: 2.0000 V
4: 2.1000 V
5: 2.2000 V
6: 2.3000 V
7: 2.4000 V
8: 2.5000 V
9: 2.6000 V
10: 2.7000 V
11: 2.8000 V
12: 2.9000 V
13: 3.0000 V
14: 3.2000 V
15: 4.5000 V</description>
              <bitRange>[4:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>VMON_DDFT_SEL</name>
              <description>DDFT mux select for HVPOR, PBOD, and LVD circuits  (engineering only).  Selects a signal to output on adft_vmon
0: 0
1: pbod_out
2: Pulse Strecher output of pbod Monitor
3: hvpbod_out
4: Pulse Strecher output of hvpbod Monitor
5: lvi_out
6: Pulse Strecher output of lvi Monitor
7: 0</description>
              <bitRange>[7:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>VMON_ADFT_SEL</name>
              <description>ADFT mux select for HVPOR, PBOD, and LVD circuits  (engineering only).  Selects a signal to output on adft_vmon
0: Hi-Z
1: Comparator Input of pbod Monitor
2: Comparator Input of hvpbod Monitor
3: Comparator Input of lvi Monitor</description>
              <bitRange>[9:8]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PWR_DFT_SELECT</name>
          <description>Power DFT Mode Selection Register</description>
          <addressOffset>0x1C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x3880000</resetValue>
          <resetMask>0xFFDFFFFF</resetMask>
          <fields>
            <field>
              <name>TVMON1_SEL</name>
              <description>Select source for PWRSYS ADFT output #1:
0: not connected (default)
1: vnwell
2: vccq
3: vccd_sw
4: vcclfclk
5: vcchib
6: vccdpslp
7: vccqr</description>
              <bitRange>[2:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TVMON2_SEL</name>
              <description>Select source for PWRSYS ADFT output #2:
0: not connected (default)
1: not connected
2: Boot Reference biasn
3: Boot Reference nprot
4: DO NOT USE.  Unsafely diode couples vccd_sw to bootref 800mV reference.
5: Boot Reference 800mv
6: not connected
7: not connected</description>
              <bitRange>[5:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BYPASS</name>
              <description>Forces regulator into bypass mode.  Disables active mode regulator and allows most switches and other regulators to be manually controlled though other bits in this register..</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ACTIVE_EN</name>
              <description>Force active regulator on.  Only works when BYPASS=1.  Intended for characterization and testing.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ACTIVE_INRUSH_DIS</name>
              <description>Force disable of active regulator inrush current limiter.  Only works when BYPASS=1.  Intended for characterization and testing.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LPCOMP_DIS</name>
              <description>When set disables the LPCOMP.  Only do this when the LPCOMP outputs are properly bypassed using the POWER_UP_* bits and also PWR_DFT_KEY.DFT_MODE=1.  Only works when BYPASS=1.  Intended for LPCOMP testing.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BLEED_EN</name>
              <description>When set enables bleeder cells on various switched power nets to accelerate discharge during retention testing.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>IPOR_EN</name>
              <description>Force IPOR_EN signal high.  Only works when BYPASS=1.  Intended for IPOR/HVPOR IDDQ testing.  You must bypass the IO cells using PWR_DFT_KEY.IO_DISABLE_BYPASS and .KEY16 before setting this bit.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>POWER_UP_RAW_BYP</name>
              <description>When set, the LPCOMP output is controllable by POWER_UP_RAW_CTL.  Only works when BYPASS=1.  Intended for testing quiet regulator delayline, active regulator, and hibernate/deepsleep regulator.</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>POWER_UP_RAW_CTL</name>
              <description>Value to force onto power_up_raw_hv.  Only works when POWER_UP_RAW_BYP=1.</description>
              <bitRange>[13:13]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DEEPSLEEP_EN</name>
              <description>Force DeepSleep Regulator on.  Only works when BYPASS=1.  Intended for DeepSleep Regulator IDDQ testing.</description>
              <bitRange>[14:14]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RSVD_BYPASS</name>
              <description>N/A</description>
              <bitRange>[15:15]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>NWELL_OPEN</name>
              <description>Force switch between Vnwell and Vcchib open.  Only works when BYPASS=1.  Intended for IDDQ testing.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HIBERNATE_OPEN</name>
              <description>Force switch between Vcchib and Vccdpslp open.  Only works when BYPASS=1, PWR_DFT_KEY.KEY16 is set to the key, and PWR_DFT_KEY.DFT_MODE=1.  Intended for IDDQ testing.</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DEEPSLEEP_OPEN</name>
              <description>Force switch between Vccdpslp and Vccd open.  Only works when BYPASS=1.  Intended for IDDQ testing.</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>QUIET_OPEN</name>
              <description>Force switch between Vccq and Vccdpslp open.  Only works when BYPASS=1.  Intended for IDDQ testing.</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LFCLK_OPEN</name>
              <description>Force switch between Vcclfclk and Vccdpslp open.  Only works when BYPASS=1.  Intended for IDDQ testing.</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>QUIET_EN</name>
              <description>Force Vccq regulator on/off.  Only works when BYPASS=1.  Intended for IDDQ testing.</description>
              <bitRange>[22:22]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BREF_EN</name>
              <description>Enables the boot reference currents.  Do not clear this bit unless he active regulator, quiet regulator, or LPCOMP are bypassed.  Only works when BYPASS=1.  Intended for characterization and testing.</description>
              <bitRange>[23:23]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BREF_OUTEN</name>
              <description>Enables the output stage of the LDO reference selector. Do not clear this bit when the active regulator is operating.  Only works when BYPASS=1.  Intended for characterization and testing.</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BREF_REFSW</name>
              <description>Controls the power system reference source
0: boot reference
1: Low voltage bandgap (LVBG)
Using the LVBG reference improves PSRR. Only works when BYPASS=1.  Intended for characterization and testing.</description>
              <bitRange>[25:25]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BREF_TESTMODE</name>
              <description>Puts the bootref in testmode.  Intended for characterization and testing.</description>
              <bitRange>[26:26]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>NWELL_DIS</name>
              <description>Controls the vnwell level during deep sleep and hibernate.  When set, the nwell regulator is disabled.  When this bit is set, the Vnwell  rail will be shorted to Vcchib rail (nwell_short).</description>
              <bitRange>[27:27]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HVMON_DFT_OVR</name>
              <description>Overrides the trim values coming from NVLatches to the values stored in the HV Monitor.  Allows char &amp; test of the NVLatches without disturbing trims.</description>
              <bitRange>[28:28]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>IMO_REFGEN_DIS</name>
              <description>Disables the IMO reference generator to allow testing the current references.  A side-effect of setting this bit is that the SRSS outputs vbias_ptat and vbias_casc_ptat are shorted to vccq.</description>
              <bitRange>[29:29]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>POWER_UP_ACTIVE</name>
              <description>When set, forces pwrgood=1 for active regulator.  Combined with POWER_UP_RAW_CTL=0, this gives full control on this input for characterization and testing.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>POWER_UP_HIBDPSLP</name>
              <description>When set, forces pwrg_actdig=1 for hibernate/deepsleep circuits.  Combined with POWER_UP_RAW_CTL=0, this gives full control on this input for characterization and testing.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PWR_DDFT_SELECT</name>
          <description>Digital DFT Select</description>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>DDFT1_SEL</name>
              <description>Signal select for ddft1 output:
0: wakeup_a
1: ipor_reset
2: hbod_reset_raw_n
3: lpcomp_dis
4: power_up_delayed
5: awake
6: hvmon_out_of_sync
7: pbod_reset
8: hvbod_reset
9: lpm_ready
10: io_disable_req_lv (excluding por_force_in_hv)
11: bootref_en</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DDFT2_SEL</name>
              <description>Signal select for ddft2 output:
0: act_power_en_a
1: power_up_raw
2: act_power_good_a
3: fastrefs_valid
4: vmon
5: bootref_outen
6: bootref_refsw
7: active_inrush_dis
8: awake
9: hvpor_reset_n
10: lpcomp_dis
11: wakeup_a
12: vmon_valid
13: block_rst_awake
14: slpholdreq_n
15: io_disable_delayed</description>
              <bitRange>[7:4]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PWR_DFT_KEY</name>
          <description>DFT Safety Override</description>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1FFFFF</resetMask>
          <fields>
            <field>
              <name>KEY16</name>
              <description>This field must be set to 0xE4C5 for any of the other fields in this register to have effect and for scan_mode to be allowed.  When this fields has any other value, all other fields in this register are ignored and assumed to be 0 by the hardware, and scan_mode is ignored inside the power generation system.  It is assumed that this register will always be set to 0xE4C5 before entering scan.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HBOD_OFF_AWAKE</name>
              <description>Forces the output of the HBOD to be blocked (ignored) while in Active or Sleep mode (i.e. when under the umbrella of PBOD).</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BODS_OFF</name>
              <description>Forces all outputs of BOD detectors to be ignored, effectively disabling all brown-out detection.  Can be used in conjunction with DDFT to test the detectors without triggering reset.</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DFT_MODE</name>
              <description>Enable DfT modes other than the above.  Currently gates power_up comparator for characterization.</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>IO_DISABLE_BYPASS</name>
              <description>Bypasses the IO disable logic for testing the delay-line that is part of the glitch-free IO reset circuitry.  Internally, prevents the outputs from getting disabled (io_disable_req_hv=0) and blocks resets (io_disable_ack_hv=0).  The delay-line continues to function and can be routed to DDFT for testing.</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>VMON_PD</name>
              <description>Disables the VMON block, which includes PBOD, HVBOD, and LVD circuits.  Set BODS_OFF=1 in a previous write cycle to prevent an unintended reset.</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PWR_BOD_KEY</name>
          <description>BOD Detection Key</description>
          <addressOffset>0x28</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>KEY16</name>
              <description>To detect brown-outs firmware should do this on boot:
1. Set key= KEY16
2. Set KEY16= 0x3A71
3. If key==0x3A71 this was a brown-out event.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PWR_STOP</name>
          <description>STOP Mode Register</description>
          <addressOffset>0x2C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x8003FFFF</resetMask>
          <fields>
            <field>
              <name>TOKEN</name>
              <description>Contains a 8-bit token that is retained through a STOP/WAKEUP sequence that can be used by firmware to differentiate WAKEUP from a general RESET event.  Note that waking up from STOP using XRES will reset this register.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UNLOCK</name>
              <description>This byte must be set to 0x3A for FREEZE or STOP fields to operate.  Any other value in this register will cause FREEZE/STOP to have no effect, except as noted in the FREEZE description.</description>
              <bitRange>[15:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>POLARITY</name>
              <description>0: WAKEUP=0 will wakeup the part from STOP
1: WAKEUP=1 will wakeup the part from STOP</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FREEZE</name>
              <description>Firmware sets this bit to freeze the configuration, mode and state of all GPIOs and SIOs in the system.  Two identical write cycles are required to freeze the IO explicitly.  The first cycle instructs DEEPSLEEP and HIBERNATE peripherals whether they can override upcoming freeze command(s).  UNLOCK setting does not affect this.  If firmware writes FREEZE=1 and STOP=0, peripherals can override the freeze and remain functional according to their configuration.  If firmware writes FREEZE=1 and STOP=1, peripherals cannot override the next freeze command.  The second write cycle freezes the IO if UNLOCK is set and the peripheral does not override the freeze.  While FREEZE=1, peripherals will automatically freeze according to the override directive when entering DEEPSLEEP or HIBERNATE, regardless of the UNLOCK setting.</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STOP</name>
              <description>Firmware sets this bit to enter STOP mode.  Both UNLOCK and FREEZE must have been set correctly in a previous write operation.  Otherwise, writes to this bit will affect the freeze override but will not actually set the STOP bit.  The system will enter STOP mode immediately after writing to this bit and will wakeup only in response to XRES or WAKEUP event.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CLK_SELECT</name>
          <description>Clock Select Register</description>
          <addressOffset>0x100</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3FFFFF</resetMask>
          <fields>
            <field>
              <name>DIRECT_SEL</name>
              <description>Selects a source for HFCLK (when HFCLK_SEL=0) and DSI_IN[0].
Note that not all products support all clock sources.  Selecting a clock source that is not supported will result in undefined behavior.
Note that using DSI_OUT[3:0] as HFCLK source will also result in undefined behavior.  These values are available strictly to provide a clock in DSI_IN[0].</description>
              <bitRange>[2:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>IMO</name>
                  <description>IMO - Internal R/C Oscillator</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>EXTCLK</name>
                  <description>EXTCLK - External Clock Pin</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ECO</name>
                  <description>ECO - External-Crystal Oscillator (Crystal external, Oscilator internal)</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DSI0</name>
                  <description>DSI_OUT[0]</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DSI1</name>
                  <description>DSI_OUT[1]</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DSI2</name>
                  <description>DSI_OUT[2]</description>
                  <value>6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DSI3</name>
                  <description>DSI_OUT[3]</description>
                  <value>7</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DBL_SEL</name>
              <description>Selects a source the input of EXCO PLL1, if supported.  
Note that not all products support all clock sources.  Selecting a clock source that is not supported will result in undefined behavior.
Note: this is called DBL_SEL for legacy reasons, and cannot be changed without breaking collateral for multiple existing products.</description>
              <bitRange>[5:3]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>IMO</name>
                  <description>IMO - Internal R/C Oscillator</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>EXTCLK</name>
                  <description>EXTCLK - External Clock Pin</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ECO</name>
                  <description>ECO - External-Crystal Oscillator (Crystal external, Oscilator internal)</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DSI0</name>
                  <description>DSI_OUT[0]</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DSI1</name>
                  <description>DSI_OUT[1]</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DSI2</name>
                  <description>DSI_OUT[2]</description>
                  <value>6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DSI3</name>
                  <description>DSI_OUT[3]</description>
                  <value>7</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PLL_SEL</name>
              <description>Selects a source the input of EXCO PLL0, if supported.  
Note that not all products support all clock sources.  Selecting a clock source that is not supported will result in undefined behavior.
Note: this is called PLL_SEL for legacy reasons, and cannot be changed without breaking collateral for multiple existing products.</description>
              <bitRange>[8:6]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>IMO</name>
                  <description>IMO - Internal R/C Oscillator</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>EXTCLK</name>
                  <description>EXTCLK - External Clock Pin</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ECO</name>
                  <description>ECO - External-Crystal Oscillator (Crystal external, Oscilator internal)</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DPLL</name>
                  <description>DPLL - DPLL Output</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DSI0</name>
                  <description>DSI_OUT[0]</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DSI1</name>
                  <description>DSI_OUT[1]</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DSI2</name>
                  <description>DSI_OUT[2]</description>
                  <value>6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DSI3</name>
                  <description>DSI_OUT[3]</description>
                  <value>7</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DPLLIN_SEL</name>
              <description>Selects a source for the input of DPLL.
Note that not all products support all clock sources.  Selecting a clock source that is not supported will result in undefined behavior.</description>
              <bitRange>[11:9]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>IMO</name>
                  <description>IMO - Internal R/C Oscillator</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>EXTCLK</name>
                  <description>EXTCLK - External Clock Pin</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ECO</name>
                  <description>ECO - External-Crystal Oscillator (Crystal external, Oscilator internal)</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DSI0</name>
                  <description>DSI_OUT[0]</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DSI1</name>
                  <description>DSI_OUT[1]</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DSI2</name>
                  <description>DSI_OUT[2]</description>
                  <value>6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DSI3</name>
                  <description>DSI_OUT[3]</description>
                  <value>7</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DPLLREF_SEL</name>
              <description>Selects a source for the reference (tracking) input of DPLL:
0: DSI_OUT[0]
1: DSI_OUT[1]
2: DSI_OUT[2]
3: DSI_OUT[3]</description>
              <bitRange>[13:12]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DSI0</name>
                  <description>DSI_OUT[0]</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DSI1</name>
                  <description>DSI_OUT[1]</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DSI2</name>
                  <description>DSI_OUT[2]</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DSI3</name>
                  <description>DSI_OUT[3]</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WDT_LOCK</name>
              <description>Prohibits writing to WDT_* registers and CLK_ILO register when not equal 0.  Requires at least two different writes to unlock.
Note that this field is 2 bits to force multiple writes only.  It represents only a single write protect signal protecting all WATCHDOG registers at the same time.</description>
              <bitRange>[15:14]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_CHG</name>
                  <description>No effect</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CLR0</name>
                  <description>Clears bit 0</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CLR1</name>
                  <description>Clears bit 1</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SET01</name>
                  <description>Sets both bits 0 and 1</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>HFCLK_SEL</name>
              <description>Selects the source for HFCLK.</description>
              <bitRange>[17:16]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DIRECT_SEL</name>
                  <description>Source selected by DIRECT_SEL</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DBL</name>
                  <description>Output of DBL (Doubler) - Selects output of EXCO PLL1 if supported.  
Note that not all products support all clock sources.  Selecting a clock source that is not supported will result in undefined behavior.
Note: this is called DBL for legacy reasons, and cannot be changed without breaking collateral for multiple existing products.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PLL</name>
                  <description>Output of PLL -  Selects output of EXCO PLL0 if supported.  
Note that not all products support all clock sources.  Selecting a clock source that is not supported will result in undefined behavior.
Note: this is called PLL for legacy reasons, and cannot be changed without breaking collateral for multiple existing products.</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>HALF_EN</name>
              <description>This bit impact products using CPUSSv1 only.  It has no effect on products using CPUSSv2.
FLASH Wait-state selection.  This must be set to 1 when clk_sys is set to a frequency greater than 24MHz.
0: Access FLASH using 0 wait-states.  Only use this setting when HFCLK is &lt;=24MHz.
1: Access FLASH using 1 wait-state.  Safe to use this setting for any clock frequency.</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SYSCLK_DIV</name>
              <description>SYSCLK Pre-Scaler Value.</description>
              <bitRange>[21:19]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_DIV</name>
                  <description>SYSCLK= HFCLK/1</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIV_BY_2</name>
                  <description>SYSCLK= HFCLK/2</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIV_BY_4</name>
                  <description>SYSCLK= HFCLK/4</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIV_BY_8</name>
                  <description>SYSCLK= HFCLK/8</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIV_BY_16</name>
                  <description>SYSCLK= HFCLK/16</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIV_BY_32</name>
                  <description>SYSCLK= HFCLK/32</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIV_BY_64</name>
                  <description>SYSCLK= HFCLK/64</description>
                  <value>6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIV_BY_128</name>
                  <description>SYSCLK= HFCLK/128</description>
                  <value>7</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>CLK_ILO_CONFIG</name>
          <description>ILO Configuration</description>
          <addressOffset>0x104</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x6</resetValue>
          <resetMask>0x80000007</resetMask>
          <fields>
            <field>
              <name>PD_MODE</name>
              <description>Power down mode.  Note: this bit must always be set to 0 and never changed.  Behavior is undefined when set to 1.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SLEEP</name>
                  <description>Sleep (faster startup - enables pulsegen block)</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>COMA</name>
                  <description>Coma (slower startup)</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TURBO</name>
              <description>Turbo mode for faster startup from coma power down.  Leave this bit at the default setting for normal operation.  Engineering only.
0: turbo disabled
1: turbo enabled</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SATBIAS</name>
              <description>PFET bias.  Leave this bit at the default setting for normal operation.  Engineering only.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SATURATED</name>
                  <description>Enable saturated PFET bias</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SUBTHRESHOLD</name>
                  <description>Enable subthreshold PFET bias</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ENABLE</name>
              <description>Master enable for ILO oscillator</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CLK_IMO_CONFIG</name>
          <description>IMO Configuration</description>
          <addressOffset>0x108</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x80800000</resetValue>
          <resetMask>0xFFC00000</resetMask>
          <fields>
            <field>
              <name>FLASHPUMP_SEL</name>
              <description>Selects operating source for SPCIF Timer/Flash Pump clock.</description>
              <bitRange>[22:22]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>GND</name>
                  <description>No clock, connect to gnd</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CLK36</name>
                  <description>Use 36MHz oscillator</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>EN_FASTBIAS</name>
              <description>Forces the FIMO's fast bias circuits to remain powered (engineering only).  This bit must be cleared by BootROM after FIMO is no longer required.</description>
              <bitRange>[23:23]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TEST_FASTBIAS</name>
              <description>Forces the IMO into FIMO mode (engineering only).  Only works when EN_FASTBIAS=1.</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PUMP_SEL</name>
              <description>N/A</description>
              <bitRange>[27:25]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>GND</name>
                  <description>No clock, connect to gnd</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>IMO</name>
                  <description>Use main IMO output</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DBL</name>
                  <description>Use doubler output</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CLK36</name>
                  <description>Use 36MHz oscillator.  Note: always set EN_CLK36 when selecting this value for PUMP_SEL.  Flash program/erase operations will set EN_CLK36=0 when PUMP_SEL!=CLK36. This selection is ONLY valid for PSoC4A-BLE.</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>FF1</name>
                  <description>Use divided clock FF1</description>
                  <value>4</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TEST_USB_MODE</name>
              <description>Forces IMO into locking mode.  Engineering only.
1: Software can write FSOFFSET, OFFSET, and GAIN settings for characterization.  Hardware updates to these registers are not blocked, so disable peripheral updates if they are not desired.
0: Normal operation.  IMO operates in either normal or locking mode, depending on settings for the selected external locking peripheral.</description>
              <bitRange>[28:28]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EN_CLK36</name>
              <description>Enables 36MHz secondary oscillator that can be used for Pump or Flash Pump.  Note:  Since there are two consumers of the 36MHz clock, care should be taken when clearing this bit. The correct procedure for clearing this bit is:
1. Disable interrupts
2. Check if both FLASHPUMP_SEL&lt;&gt;1 and PUMP_SEL&lt;&gt;3
3. If so, set EN_CLK36=0
4. Enable interrupts</description>
              <bitRange>[29:29]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EN_CLK2X</name>
              <description>Enables main oscillator doubler circuit that can be used for TSS Charge Pumps.  This circuit is not available to generate any digital clocks.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ENABLE</name>
              <description>Master enable for IMO oscillator.  Clearing this bit will disable the IMO but not disconnect it from the power rail.  This bit can also be used during IDDQ testing.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CLK_IMO_SPREAD</name>
          <description>IMO Spread Spectrum Configuration</description>
          <addressOffset>0x10C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xF0001F1F</resetMask>
          <fields>
            <field>
              <name>SS_VALUE</name>
              <description>Current offset value for spread spectrum modulation.  IMO supports values 0..16.  Step size is determined by SS_RANGE.  Value is encoded in proper thermometric format for IMO in hardware.  Value can be modified in firmware only when SS_MODE=0.</description>
              <bitRange>[4:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SS_MAX</name>
              <description>Maximum counter value for spread spectrum.  Counter will count from 0..SS_MAX..0 and keep repeating this indefinitely.  Only works when SS_MODE=1.</description>
              <bitRange>[12:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SS_RANGE</name>
              <description>N/A</description>
              <bitRange>[29:28]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>M1</name>
                  <description>0 .. -1 percent</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>M2</name>
                  <description>0 .. -2 percent</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>M4</name>
                  <description>0 .. -4 percent</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SS_MODE</name>
              <description>Spread Spectrum Mode.</description>
              <bitRange>[31:30]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>OFF</name>
                  <description>Off, do not change SS_VALUE</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>TRIANGLE</name>
                  <description>Modulate using triangle wave (see SS_MAX)</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LFSR</name>
                  <description>Modulate using pseudo random sequence (using LFSR)</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DSI</name>
                  <description>Take value directly from DSI (synchronized by divided clock FF1)</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>CLK_DFT_SELECT</name>
          <description>Clock DFT Mode Selection Register</description>
          <addressOffset>0x110</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3F3F</resetMask>
          <fields>
            <field>
              <name>DFT_SEL1</name>
              <description>Select signal for DFT output #1.</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NC</name>
                  <description>Disabled - output is not connected</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ILO</name>
                  <description>ILO output</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WCO</name>
                  <description>WCO output</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>IMO</name>
                  <description>IMO primary output</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ECO</name>
                  <description>ECO output</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PLL</name>
                  <description>PLL output</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DPLL_OUT</name>
                  <description>DPLL output</description>
                  <value>6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DPLL_REF</name>
                  <description>DPLL reference input</description>
                  <value>7</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DBL</name>
                  <description>DBL output</description>
                  <value>8</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>IMO2X</name>
                  <description>IMO 2x Clock Output</description>
                  <value>9</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>IMO36</name>
                  <description>IMO 36MHz Clock Output</description>
                  <value>10</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HFCLK</name>
                  <description>HFCLK</description>
                  <value>11</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LFCLK</name>
                  <description>LFCLK</description>
                  <value>12</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SYSCLK</name>
                  <description>SYSCLK</description>
                  <value>13</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>EXTCLK</name>
                  <description>EXTCLK</description>
                  <value>14</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HALFSYSCLK</name>
                  <description>0 - removed</description>
                  <value>15</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DFT_DIV1</name>
              <description>DFT Output Divide Down.</description>
              <bitRange>[5:4]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_DIV</name>
                  <description>Direct Output</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIV_BY_2</name>
                  <description>Divide by 2</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIV_BY_4</name>
                  <description>Divide by 4</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIV_BY_8</name>
                  <description>Divide by 8</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DFT_SEL2</name>
              <description>Select signal for DFT output #2.</description>
              <bitRange>[11:8]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NC</name>
                  <description>Disabled - output is not connected</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ILO</name>
                  <description>ILO output</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WCO</name>
                  <description>WCO output</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>IMO</name>
                  <description>IMO primary output</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ECO</name>
                  <description>ECO output</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PLL</name>
                  <description>PLL output</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DPLL_OUT</name>
                  <description>DPLL output</description>
                  <value>6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DPLL_REF</name>
                  <description>DPLL reference input</description>
                  <value>7</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DBL</name>
                  <description>DBL output</description>
                  <value>8</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>IMO2X</name>
                  <description>IMO 2x Clock Output</description>
                  <value>9</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>IMO36</name>
                  <description>IMO 36MHz Clock Output</description>
                  <value>10</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HFCLK</name>
                  <description>HFCLK</description>
                  <value>11</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LFCLK</name>
                  <description>LFCLK</description>
                  <value>12</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SYSCLK</name>
                  <description>SYSCLK</description>
                  <value>13</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>EXTCLK</name>
                  <description>EXTCLK</description>
                  <value>14</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HALFSYSCLK</name>
                  <description>0 - removed</description>
                  <value>15</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DFT_DIV2</name>
              <description>DFT Output Divide Down.</description>
              <bitRange>[13:12]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_DIV</name>
                  <description>Direct Output</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIV_BY_2</name>
                  <description>Divide by 2</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIV_BY_4</name>
                  <description>Divide by 4</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIV_BY_8</name>
                  <description>Divide by 8</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>WDT_CTRLOW</name>
          <description>Watchdog Counters 0/1</description>
          <addressOffset>0x200</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WDT_CTR0</name>
              <description>Current value of WDT Counter 0</description>
              <bitRange>[15:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>WDT_CTR1</name>
              <description>Current value of WDT Counter 1</description>
              <bitRange>[31:16]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>WDT_CTRHIGH</name>
          <description>Watchdog Counter 2</description>
          <addressOffset>0x204</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WDT_CTR2</name>
              <description>Current value of WDT Counter 2</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>WDT_MATCH</name>
          <description>Watchdog counter match values</description>
          <addressOffset>0x208</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WDT_MATCH0</name>
              <description>Match value for Watchdog Counter 0</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>WDT_MATCH1</name>
              <description>Match value for Watchdog Counter 1</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>WDT_CONFIG</name>
          <description>Watchdog Counters Configuration</description>
          <addressOffset>0x20C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xDF010F0F</resetMask>
          <fields>
            <field>
              <name>WDT_MODE0</name>
              <description>Watchdog Counter Action on Match (WDT_CTR0=WDT_MATCH0).</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NOTHING</name>
                  <description>Do nothing</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INT</name>
                  <description>Assert WDT_INTx</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RESET</name>
                  <description>Assert WDT Reset</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INT_THEN_RESET</name>
                  <description>Assert WDT_INTx, assert WDT Reset after 3rd unhandled interrupt</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WDT_CLEAR0</name>
              <description>Clear Watchdog Counter when WDT_CTR0=WDT_MATCH0. In other words WDT_CTR0 divides LFCLK by (WDT_MATCH0+1).
0: Free running counter
1: Clear on match</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>WDT_CASCADE0_1</name>
              <description>Cascade Watchdog Counters 0,1.  Counter 1 increments the cycle after WDT_CTR0=WDT_MATCH0.
0: Independent counters
1: Cascaded counters</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>WDT_MODE1</name>
              <description>Watchdog Counter Action on Match (WDT_CTR1=WDT_MATCH1).</description>
              <bitRange>[9:8]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NOTHING</name>
                  <description>Do nothing</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INT</name>
                  <description>Assert WDT_INTx</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RESET</name>
                  <description>Assert WDT Reset</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INT_THEN_RESET</name>
                  <description>Assert WDT_INTx, assert WDT Reset after 3rd unhandled interrupt</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WDT_CLEAR1</name>
              <description>Clear Watchdog Counter when WDT_CTR1=WDT_MATCH1. In other words WDT_CTR1 divides LFCLK by (WDT_MATCH1+1).
0: Free running counter
1: Clear on match</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>WDT_CASCADE1_2</name>
              <description>Cascade Watchdog Counters 1,2.  Counter 2 increments the cycle after WDT_CTR1=WDT_MATCH1.  It is allowed to cascade all three WDT counters.
0: Independent counters
1: Cascaded counters.  When cascading all three counters, WDT_CLEAR1 must be 1.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>WDT_MODE2</name>
              <description>Watchdog Counter 2 Mode.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NOTHING</name>
                  <description>Free running counter with no interrupt requests</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INT</name>
                  <description>Free running counter with interrupt request when a specified bit in CTR2 toggles (see WDT_BITS2)</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WDT_BITS2</name>
              <description>Bit to observe for WDT_INT2:
0: Assert when bit0 of WDT_CTR2 toggles (one int every tick)
..
31: Assert when bit31 of WDT_CTR2 toggles (one int every 2^31 ticks)</description>
              <bitRange>[28:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LFCLK_SEL</name>
              <description>N/A</description>
              <bitRange>[31:30]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>WDT_CONTROL</name>
          <description>Watchdog Counters Control</description>
          <addressOffset>0x210</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xF0F0F</resetMask>
          <fields>
            <field>
              <name>WDT_ENABLE0</name>
              <description>Enable Counter 0
0: Counter is disabled (not clocked)
1: Counter is enabled (counting up)
Note: This field takes considerable time (up to 3 LFCLK cycles) to take effect.  It must not be changed more than once in that period.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>WDT_ENABLED0</name>
              <description>Indicates actual state of counter.  May lag WDT_ENABLE0 by up to 3 LFCLK cycles.  After changing WDT_ENABLE0, do not enter DEEPSLEEP mode until this field acknowledges the change.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>WDT_INT0</name>
              <description>WDT Interrupt Request.  This bit is set by hardware as configured by this registers.  This bit must be cleared by firmware.  Clearing this bit also prevents Reset from happening when WDT_MODEx=3.  After W1C, WDT_CONTROL must be read for the hardware to internally remove the clear flag.  Failure to do this may result in missing the next interrupt.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>WDT_RESET0</name>
              <description>Resets counter 0 back to 0000.  Hardware will reset this bit after counter was reset.  This will take several LFCLK cycles to take effect.  Wait until the reset completes before enabling the WDT.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>WDT_ENABLE1</name>
              <description>Enable Counter 1
0: Counter is disabled (not clocked)
1: Counter is enabled (counting up)
Note: This field takes considerable time (up to 3 LFCLK cycles) to take effect.  It must not be changed more than once in that period.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>WDT_ENABLED1</name>
              <description>Indicates actual state of counter.  May lag WDT_ENABLE1 by up to 3 LFCLK cycles.  After changing WDT_ENABLE1, do not enter DEEPSLEEP mode until this field acknowledges the change.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>WDT_INT1</name>
              <description>WDT Interrupt Request.  This bit is set by hardware as configured by this registers.  This bit must be cleared by firmware.  Clearing this bit also prevents Reset from happening when WDT_MODEx=3.  After W1C, WDT_CONTROL must be read for the hardware to internally remove the clear flag.  Failure to do this may result in missing the next interrupt.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>WDT_RESET1</name>
              <description>Resets counter 1 back to 0000.  Hardware will reset this bit after counter was reset.  This will take several LFCLK cycles to take effect.  Wait until the reset completes before enabling the WDT.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>WDT_ENABLE2</name>
              <description>Enable Counter 2
0: Counter is disabled (not clocked)
1: Counter is enabled (counting up)
Note: This field takes considerable time (up to 3 LFCLK cycles) to take effect.  It must not be changed more than once in that period.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>WDT_ENABLED2</name>
              <description>Indicates actual state of counter.  May lag WDT_ENABLE2 by up to 3 LFCLK cycles.  After changing WDT_ENABLE2, do not enter DEEPSLEEP mode until this field acknowledges the change.</description>
              <bitRange>[17:17]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>WDT_INT2</name>
              <description>WDT Interrupt Request.  This bit is set by hardware as configured by this registers.  This bit must be cleared by firmware.  Clearing this bit also prevents Reset from happening when WDT_MODEx=3.  After W1C, WDT_CONTROL must be read for the hardware to internally remove the clear flag.  Failure to do this may result in missing the next interrupt.</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>WDT_RESET2</name>
              <description>Resets counter 2 back to 0000_0000.  Hardware will reset this bit after counter was reset.  This will take several LFCLK cycles to take effect.  Wait until the reset completes before enabling the WDT.</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RES_CAUSE</name>
          <description>Reset Cause Observation Register</description>
          <addressOffset>0x300</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>RESET_WDT</name>
              <description>A WatchDog Timer reset has occurred since last power cycle.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESET_DSBOD</name>
              <description>This field is deprecated and will always read 0.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESET_LOCKUP</name>
              <description>This field is deprecated and will always read 0.  Cortex-M0 LOCKUP is no longer a reset source.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESET_PROT_FAULT</name>
              <description>A protection violation occurred that requires a RESET.  This includes, but is not limited to, hitting a debug breakpoint while in Privileged Mode.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESET_SOFT</name>
              <description>Cortex-M0 requested a system reset through it's SYSRESETREQ.  This can be done via a debugger probe or in firmware.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESET_HVBOD</name>
              <description>This field is deprecated and will always read 0.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESET_PBOD</name>
              <description>This field is deprecated and will always read 0.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESET_XRES</name>
              <description>This field is deprecated and will always read 0.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PWR_PWRSYS_TRIM1</name>
          <description>Power System Trim Register</description>
          <addressOffset>0xFF00</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>HIB_BIAS_TRIM</name>
              <description>Current reference trim.  This is internally overridden to 3'b010 for startup during POR and STOP wakeup.  Afterward, it uses this setting for hibernate and sleep.</description>
              <bitRange>[2:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BOD_TURBO_THRESH</name>
              <description>BOD Turbo Threshold Control
0 Turbo Threshold is set to 100mV above BOD trip point
1 Turbo Threshold is set to 50mV above BOD trip point</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BOD_TRIM_TRIP</name>
              <description>BOD trip point trim.  BOD_TRIM_TRIP[2] is ignored and controlled by hardware directly.
0X00: Default trim setting
0X01: Default trim setting - 30mV
0X10: Default trim setting + 30mV
0X11: Invalid Setting (Do Not Use)
1X00: Default trim setting + 90mV
1X01: Default trim setting + 60mV
1X10: Default trim setting + 120mV
1X11: Invalid Setting (Do Not Use)</description>
              <bitRange>[7:4]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PWR_PWRSYS_TRIM2</name>
          <description>Power System Trim Register</description>
          <addressOffset>0xFF04</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x33</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>LFCLK_TRIM_LOAD</name>
              <description>Current load trim capability
00= Min current load capability
11= Max current load capability</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LFCLK_TRIM_VOLTAGE</name>
              <description>Output voltage trim
00= default 
01= Trim lfclk by -50mV
10= Trim lfclk by +50mV
11= illegal</description>
              <bitRange>[3:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DPSLP_TRIM_LOAD</name>
              <description>Current load trim capability
00= Min current load capability
11= Max current load capability</description>
              <bitRange>[5:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DPSLP_TRIM_LEAKAGE</name>
              <description>Enable Vcchib pass gate leakage control</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DPSLP_TRIM_VOLTAGE</name>
              <description>Raise output voltage
1= regulator hibernate 200mV higher
0= nominal 1.4-1.6V range</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PWR_PWRSYS_TRIM3</name>
          <description>Power System Trim Register</description>
          <addressOffset>0xFF08</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xF9</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>NWELL_TRIM</name>
              <description>Vnwell (nwell regulator) trim
[0]: Vcchib + nhv(0.6V -1V)
[1]: Vcchib + nlowvt(0.4 -0.8V)
[2]: Vcchib + nhvnat(0.1-0.3)</description>
              <bitRange>[2:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>QUIET_TRIM</name>
              <description>Vccq (quiet regulator) trim</description>
              <bitRange>[7:3]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PWR_PWRSYS_TRIM4</name>
          <description>Power System Trim Register</description>
          <addressOffset>0xFF0C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x4</resetValue>
          <resetMask>0x3F</resetMask>
          <fields>
            <field>
              <name>HIB_TRIM_NWELL</name>
              <description>Vnwell Leakage control
00= smart nwell regulation
01= regulate nwell to constant voltage. 
10= regulate nwell to vcchib + nfet diode
11= regulate nwell to vcchib + nfet diode</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HIB_TRIM_LEAKAGE</name>
              <description>Enable Vcchib pass gate leakage control</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HIB_TRIM_VOLTAGE</name>
              <description>Elevate output voltage
1= regulator hibernate 200mV higher 
0= nominal 1.4-1.6V range</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HIB_TRIM_REFERENCE</name>
              <description>Hibernate Reference trim
10=Trim reference by -27mV
01=Trim reference by +27mV
00= no trim</description>
              <bitRange>[5:4]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PWR_BG_TRIM1</name>
          <description>Bandgap Trim Register</description>
          <addressOffset>0xFF10</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x43</resetValue>
          <resetMask>0x7F</resetMask>
          <fields>
            <field>
              <name>INL_TRIM_MAIN</name>
              <description>Bandgap nonlinear current trim for curvature correction (main current reference).</description>
              <bitRange>[2:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INL_CROSS_MAIN</name>
              <description>Bandgap INL cross-over point control for centering curve at 30C (main current reference).</description>
              <bitRange>[6:3]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PWR_BG_TRIM2</name>
          <description>Bandgap Trim Register</description>
          <addressOffset>0xFF14</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x8</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>VCTAT_SLOPE</name>
              <description>Output slope setting controls. The slope of the voltage with temperature varies from ~0 percent to ~15 percent from the value at 55C over the temperature range -40C to 150C based on control signal settings 0 to 15</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>VCTAT_VOLTAGE</name>
              <description>Output voltage absolute trim (LSBs).  MSB is in VCTAT_VOLTAGE_MSB field.</description>
              <bitRange>[5:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>VCTAT_ENABLE</name>
              <description>Enable VCTAT block</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>VCTAT_VOLTAGE_MSB</name>
              <description>Output voltage absolute trim (MSB)</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PWR_BG_TRIM3</name>
          <description>Bandgap Trim Register</description>
          <addressOffset>0xFF18</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x5F</resetValue>
          <resetMask>0x7F</resetMask>
          <fields>
            <field>
              <name>INL_TRIM_IMO</name>
              <description>IMO Irefgen nonlinear current trim for curvature correction.</description>
              <bitRange>[2:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INL_CROSS_IMO</name>
              <description>IMO Irefgen INL cross-over point control for centering curve at 30C.</description>
              <bitRange>[6:3]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PWR_BG_TRIM4</name>
          <description>Bandgap Trim Register</description>
          <addressOffset>0xFF1C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x20</resetValue>
          <resetMask>0x3F</resetMask>
          <fields>
            <field>
              <name>ABS_TRIM_IMO</name>
              <description>IMO-irefgen output current magnitude trim</description>
              <bitRange>[5:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PWR_BG_TRIM5</name>
          <description>Bandgap Trim Register</description>
          <addressOffset>0xFF20</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x20</resetValue>
          <resetMask>0x3F</resetMask>
          <fields>
            <field>
              <name>TMPCO_TRIM_IMO</name>
              <description>IMO-irefgen output current temperature co-efficient trim</description>
              <bitRange>[5:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CLK_ILO_TRIM</name>
          <description>ILO Trim Register</description>
          <addressOffset>0xFF24</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x38</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>TRIM</name>
              <description>Trim bits to control frequency
0: Minimum frequency
15: Maximum frequency</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>COARSE_TRIM</name>
              <description>Adjusts the bias in the event of high current after fab.  Leave these bits at the default setting for normal operation.:
Bias trim:
bit3=0: Normal Mode
bit3=1:Low Current Mode

Resistor Trim (Short R to gnd):
bit2=0: Normal Mode
bit2=1: Short R/4
bit1=0: Unshort R/2
bit1=1: Normal Mode (Short R/2)
bit0=0: Unshort R/4
bit0=1: Normal Mode (Short 3R/4)</description>
              <bitRange>[7:4]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CLK_IMO_TRIM1</name>
          <description>IMO Trim Register</description>
          <addressOffset>0xFF28</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x80</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>OFFSET</name>
              <description>Frequency trim bits.  These bits are determined at manufacturing time for each FREQ setting (IMO_TRIM2) and stored in SFLASH.  

This field is hardware updated when the IMO locks to an external source.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CLK_IMO_TRIM2</name>
          <description>IMO Trim Register</description>
          <addressOffset>0xFF2C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x19</resetValue>
          <resetMask>0x3F</resetMask>
          <fields>
            <field>
              <name>FREQ</name>
              <description>Frequency to be selected (default 24MHz).  Frequencies can be selected from 3..48MHz. When changing this field approriate values for IMO_CLK_TRIM1, PWR_BG_TRIM4 and PWR_BG_TRIM5 must be selected from trim tables determined at manufacturing time and stored in SFLASH.  This process is documented in the SAS under 'Clocks - Selecting IMO Frequency'.   For encoding of this field a lookup table is required, where the frequency increases in 1MHz steps in the regions listed below.  Unspecified values have undefined behavior.  A complete lookup table is in BROS 001-59652 Sec 4.2.2.    
[3-12] =&gt; [3MHz-12MHz]
[14-25] =&gt; [13MHz-24MHz]
[27-35] =&gt; [25MHz-33MHz]
[37-43] =&gt; [34MHz-40MHz]
[46-53] =&gt; [41MHz-48MHz]</description>
              <bitRange>[5:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CLK_IMO_TRIM3</name>
          <description>IMO Trim Register</description>
          <addressOffset>0xFF30</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xF</resetMask>
          <fields>
            <field>
              <name>TRIM_CLK36</name>
              <description>Trim bits for 36MHz oscillator.  Typically stored in SFLASH and copied here on boot.</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CLK_IMO_TRIM4</name>
          <description>IMO Trim Register</description>
          <addressOffset>0xFF34</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>GAIN</name>
              <description>Gain for IMO.  Typically stored in SFLASH and copied here on boot.  Only used when locking IMO to an external source (USB mode or WCO DPLL), or when CLK_IMO_CONFIG.TEST_USB_MODE=1.  

Locking is initiated by the external peripheral providing the clock source (UDB or WCO). When locking is not enabled, the actual IMO gain is forced to a setting of 0.

SRSS directly supports a single locking peripheral. Two peripherals are supported when EXCO is included, selected with the OSCINTF_CTL.PORT_SEL register.</description>
              <bitRange>[4:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FSOFFSET</name>
              <description>Fine Scale offset, providing two additional LSB bits to CLK_IMO_TRIM1.OFFSET when IMO is locking to an external source.  

Updated by hardware when locking is enabled.  Can be updated by software when TEST_USB_MODE=1, otherwise writes are ignored.</description>
              <bitRange>[7:5]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PWR_RSVD_TRIM</name>
          <description>N/A</description>
          <addressOffset>0xFF38</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xF</resetMask>
          <fields>
            <field>
              <name>RSVD_TRIM</name>
              <description>N/A</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>CPUSS</name>
      <description>CPU Subsystem</description>
      <baseAddress>0x40100000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>4096</size>
        <usage>registers</usage>
      </addressBlock>
      <interrupt>
        <name>ioss_interrupts_gpio_0</name>
        <description>GPIO P0</description>
        <value>0</value>
      </interrupt>
      <interrupt>
        <name>ioss_interrupts_gpio_1</name>
        <description>GPIO P1</description>
        <value>1</value>
      </interrupt>
      <interrupt>
        <name>ioss_interrupts_gpio_2</name>
        <description>GPIO P2</description>
        <value>2</value>
      </interrupt>
      <interrupt>
        <name>ioss_interrupts_gpio_3</name>
        <description>GPIO P3</description>
        <value>3</value>
      </interrupt>
      <interrupt>
        <name>ioss_interrupts_gpio_4</name>
        <description>GPIO P4</description>
        <value>4</value>
      </interrupt>
      <interrupt>
        <name>ioss_interrupts_gpio_5</name>
        <description>GPIO P5</description>
        <value>5</value>
      </interrupt>
      <interrupt>
        <name>ioss_interrupt_gpio</name>
        <description>GPIO All Ports</description>
        <value>6</value>
      </interrupt>
      <interrupt>
        <name>lpcomp_interrupt</name>
        <description>LPCOMP trigger interrupt</description>
        <value>7</value>
      </interrupt>
      <interrupt>
        <name>srss_interrupt_wdt</name>
        <description>WDT</description>
        <value>8</value>
      </interrupt>
      <interrupt>
        <name>scb_0_interrupt</name>
        <description>SCB #0</description>
        <value>9</value>
      </interrupt>
      <interrupt>
        <name>scb_1_interrupt</name>
        <description>SCB #1</description>
        <value>10</value>
      </interrupt>
      <interrupt>
        <name>pass_0_interrupt_ctbs</name>
        <description>CTBm Interrupt (all CTBms)</description>
        <value>11</value>
      </interrupt>
      <interrupt>
        <name>bless_interrupt</name>
        <description>BLE SubSystem Interrupt</description>
        <value>12</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupt_spcif</name>
        <description>SPCIF interrupt</description>
        <value>13</value>
      </interrupt>
      <interrupt>
        <name>srss_interrupt_pwr</name>
        <description>SRSS LVD interrupt</description>
        <value>14</value>
      </interrupt>
      <interrupt>
        <name>pass_0_interrupt_sar</name>
        <description>SAR</description>
        <value>15</value>
      </interrupt>
      <interrupt>
        <name>csd_interrupt</name>
        <description>CSD #0 (Primarily Capsense)</description>
        <value>16</value>
      </interrupt>
      <interrupt>
        <name>tcpwm_interrupts_0</name>
        <description>TCPWM #0, Counter #0</description>
        <value>17</value>
      </interrupt>
      <interrupt>
        <name>tcpwm_interrupts_1</name>
        <description>TCPWM #0, Counter #1</description>
        <value>18</value>
      </interrupt>
      <interrupt>
        <name>tcpwm_interrupts_2</name>
        <description>TCPWM #0, Counter #2</description>
        <value>19</value>
      </interrupt>
      <interrupt>
        <name>tcpwm_interrupts_3</name>
        <description>TCPWM #0, Counter #3</description>
        <value>20</value>
      </interrupt>
      <interrupt>
        <name>udb_interrupts_5</name>
        <description />
        <value>21</value>
      </interrupt>
      <interrupt>
        <name>udb_interrupts_6</name>
        <description />
        <value>22</value>
      </interrupt>
      <interrupt>
        <name>udb_interrupts_7</name>
        <description />
        <value>23</value>
      </interrupt>
      <interrupt>
        <name>udb_interrupts_0</name>
        <description />
        <value>24</value>
      </interrupt>
      <interrupt>
        <name>udb_interrupts_1</name>
        <description />
        <value>25</value>
      </interrupt>
      <interrupt>
        <name>udb_interrupts_2</name>
        <description />
        <value>26</value>
      </interrupt>
      <interrupt>
        <name>udb_interrupts_3</name>
        <description />
        <value>27</value>
      </interrupt>
      <interrupt>
        <name>udb_interrupts_4</name>
        <description />
        <value>28</value>
      </interrupt>
      <interrupt>
        <name>udb_interrupts_5</name>
        <description />
        <value>29</value>
      </interrupt>
      <interrupt>
        <name>udb_interrupts_6</name>
        <description />
        <value>30</value>
      </interrupt>
      <interrupt>
        <name>udb_interrupts_7</name>
        <description />
        <value>31</value>
      </interrupt>
      <registers>
        <register>
          <name>CONFIG</name>
          <description>Configuration register</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1</resetMask>
          <fields>
            <field>
              <name>VECT_IN_RAM</name>
              <description>0': Vector Table is located at 0x0000:0000 in flash
'1': Vector Table is located at 0x2000:0000 in SRAM
Note that vectors for RESET and FAULT are always fetched from ROM. Value in flash/RAM is ignored for these vectors.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SYSREQ</name>
          <description>SYSCALL control register</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x30000000</resetValue>
          <resetMask>0xF800FFFF</resetMask>
          <fields>
            <field>
              <name>SYSCALL_COMMAND</name>
              <description>Opcode of the system call being requested.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DIS_RESET_VECT_REL</name>
              <description>Disable Reset Vector fetch relocation:
'0': CPU accesses to locations 0x0000:0000 - 0x0000:0007 are redirected to ROM.
'1': CPU accesses to locations 0x0000:0000 - 0x0000:0007 are made to flash.
Note that this field defaults to '0' on reset, ensuring actual reset vector fetches are always made to ROM. Note that this field does not affect DAP accesses. Flash DfT routines may set this bit to '1' to enable uninhibited read-back of programmed data in the first flash page.</description>
              <bitRange>[27:27]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PRIVILEGED</name>
              <description>Indicates whether the system is in privileged ('1') or user mode ('0'). Only CPU SW executing from ROM can set this field to '1' when ROM_ACCESS_EN is '1' (the CPU is executing a SystemCall NMI interrupt handler). Any other write to this field sets is to '0'. This field is used as the AHB-Lite hprot[1] signal to implement Cypress proprietary user/privileged modes. These modes are used to enable/disable access to specific MMIO registers and memory regions.</description>
              <bitRange>[28:28]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ROM_ACCESS_EN</name>
              <description>Indicates that executing from Boot ROM is enabled. HW sets this field to '1', on reset or when the SystemCall NMI vector is fetched from Boot ROM. HW sets this field to '0', when the CPU is NOT executing from either Boot or System ROM. This bit is used for debug purposes only.</description>
              <bitRange>[29:29]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>HMASTER_0</name>
              <description>Indicates the source of the write access to the SYSREQ register.
'0': CPU write access.
'1': DAP write access.
HW sets this field when the SYSREQ register is written to and SYSCALL_REQ is '0' (the last time it is set is when SW sets SYSCALL_REQ from '0' to '1').</description>
              <bitRange>[30:30]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SYSCALL_REQ</name>
              <description>CPU/DAP writes a '1' to this field to request a SystemCall. The HMASTER_0 field indicates the source of the write access. Setting this field to '1' immediate results in a NMI. The SystemCall NMI interrupt handler sets this field to '0' after servicing the request.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SYSARG</name>
          <description>SYSARG control register</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SYSCALL_ARG</name>
              <description>Argument to System Call specified in SYSREQ. Semantics of argument depends on system call made. Typically a pointer to a parameter block.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PROTECTION</name>
          <description>Protection control register</description>
          <addressOffset>0xC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xF</resetValue>
          <resetMask>0xC000000F</resetMask>
          <fields>
            <field>
              <name>PROTECTION_MODE</name>
              <description>Current protection mode; this field is available as a global signal everywhere in the system. Writes to this field are ignored when PROTECTION_LOCK is '1':
0b1xxx: BOOT
0b01xx: KILL
0b001x: PROTECTED
0b0001: OPEN
0b0000: VIRGIN (also used for DEAD mode, but then FLASH_LOCK is also set)</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FLASH_LOCK</name>
              <description>Setting this bit will force SPCIF.ADDRESS.AXA to be ignored, which prevents SM Flash from being erased or overwritten. It is used to indicate the DEAD protection mode. Writes to this field are ignored when PROTECTION_LOCK is '1'</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PROTECTION_LOCK</name>
              <description>Setting this field will block (ignore) any further writes to the PROTECTION_MODE field in this register. Once '1', this field cannot be cleared.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PRIV_ROM</name>
          <description>ROM privilege register</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3FF00FF</resetMask>
          <fields>
            <field>
              <name>BROM_PROT_LIMIT</name>
              <description>Indicates the limit where the privileged area of the Boot ROM partition starts in increments of 256 Bytes.
'0':  Entire Boot ROM is Privileged.
'1':  First 256 Bytes are User accessable.
...
BROM_PROT_LIMIT &gt;= 'Boot ROM partition capacity': Entire Boot ROM partition is user mode accessible.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SROM_PROT_LIMIT</name>
              <description>Indicates the limit where the privileged area of System ROM partition starts in increments of 256 Bytes. The limit is wrt. the start of the ROM memory (start of the Boot ROM partition).
SROM_PROT_LIMIT * 256 Byte &lt;= 'Boot ROM partition capacity':  Entire System ROM is Privileged.
SROM_PROT_LIMIT * 256 Byte &gt; 'Boot ROM partition capacity':  First SROM_PROT_LIMIT * 256 - 'Boot ROM partition capacity' Bytes are User accessable.
...
SROM_PROT_LIMIT &gt;= 'ROM capacity': Entire System ROM is user mode accessible.</description>
              <bitRange>[25:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PRIV_RAM</name>
          <description>RAM privilege register</description>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1FF</resetMask>
          <fields>
            <field>
              <name>RAM_PROT_LIMIT</name>
              <description>Indicates the limit where the privileged area of SRAM starts in increments of 256 Bytes.
'0':  Entire SRAM is Privileged.
'1':  First 256 Bytes are User accessable.

Any number larger than the size of the SRAM indicates that the entire SRAM is user mode accessible.</description>
              <bitRange>[8:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PRIV_FLASH</name>
          <description>ROM privilege register</description>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x7FF</resetMask>
          <fields>
            <field>
              <name>FLASH_PROT_LIMIT</name>
              <description>Indicates the limit where the privileged area of flash starts in increments of 256 Bytes.
'0':  Entire flash is Privileged.
'1':  First 256 Bytes are User accessable.

Any number larger than the size of the flash indicates that the entire flash is user mode accessible. Note that SuperVisory rows are always User accessable.

If FLASH_PROT_LIMIT defines a non-empty privileged area, the boot ROM will assume that a system call table exists at the beginning of the Flash privileged area and use it for all SystemCalls made using SYSREQ.</description>
              <bitRange>[10:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>WOUNDING</name>
          <description>Wounding register</description>
          <addressOffset>0x1C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x7770000</resetMask>
          <fields>
            <field>
              <name>RAM_WOUND</name>
              <description>Indicates the amount of accessible RAM 0 memory capacitty in this part. The value in this field is effectively write-once (it is only possible to set bits, not clear them). The remainder portion of SRAM is not accessible and will return an AHB-Lite bus error.
'0': entire memory accessible
'1': first 1/2 of the memory accessible
'2': first 1/4 of the memory accessible
'3': first 1/8 of the memory accessible
'4': first 1/16 of the memory accessible
'5': first 1/32 of the memory accessible
'6': first 1/64 of the memory accessible
'7': first 1/128 of the memory accessible</description>
              <bitRange>[18:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FLASH_WOUND</name>
              <description>Indicates the amount of accessible flash in this part. The value in this field is effectively write-once (it is only possible to set bits, not clear them). The remainder portion of flash is not accessible and will return an AHB-Lite bus error.
'0': entire memory accessible
'1': first 1/2 of the memory accessible
'2': first 1/4 of the memory accessible
'3': first 1/8 of the memory accessible
'4': first 1/16 of the memory accessible
'5': first 1/32 of the memory accessible
'6': first 1/64 of the memory accessible
'7': first 1/128 of the memory accessible (used for the DEAD protection mode)</description>
              <bitRange>[22:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RAM1_WOUND</name>
              <description>Wounding of RAM 1 (see description of RAM_WOUND).</description>
              <bitRange>[26:24]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INT_SEL</name>
          <description>Interrupt multiplexer select register</description>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DSI</name>
              <description>Specifies interrupt source:
'0': Fixed Function.
'1': DSI.
When changing the source of a specific interrupt, it is advised to temporarily disable the interrupt using the CM0 NVIC's CLRENA and SETENA interrupt enable clear and set registers to prevent a spurious interrupt activation. In addition, the CM0 NVIC's CLRPEND interrupt pending clear register should be used clear a pending interrupt before re-enabling the interrupt.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INT_MODE</name>
          <description>DSI interrupt pulse mode register</description>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DSI_INT_PULSE</name>
              <description>Specifies DSI interrupt format:
'0': level sensitive; i.e. no pulse generator.
'1': pulse generator on rising edge.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>NMI_MODE</name>
          <description>DSI NMI pulse mode register</description>
          <addressOffset>0x28</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1</resetMask>
          <fields>
            <field>
              <name>DSI_NMI_PULSE</name>
              <description>Specifies DSI NMI format:
'0': level sensitive; i.e. no pulse generator.
'1': pulse generator on rising edge.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>FLASH_CTL</name>
          <description>FLASH control register</description>
          <addressOffset>0x30</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x30113</resetMask>
          <fields>
            <field>
              <name>FLASH_WS</name>
              <description>Amount of ROM wait states:
'0': 0 wait states (fast flash: [0, 24] MHz system frequency, slow flash: [0, 16] MHz system frequency)
'1': 1 wait state (fast flash: [24, 48] MHz system frequency, slow flash: [16, 32] MHz system frequency)
'2': 2 wait states (slow flash: [32, 48] MHz system frequency)
'3': undefined</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PREF_EN</name>
              <description>Prefetch enable:
'0': disabled. This is a desirable seeting when FLASH_WS is '0' or when predictable execution behavior is required.
'1': enabled.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FLASH_INVALIDATE</name>
              <description>1': Invalidates the content of the flash controller's buffers.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ARB</name>
              <description>Arbitration policy:
'0': CPU has priority
'1': DW/DMA has priority
'2': Roundrobin
'3': Roundrobin - sticky</description>
              <bitRange>[17:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ROM_CTL</name>
          <description>ROM control register</description>
          <addressOffset>0x34</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1</resetMask>
          <fields>
            <field>
              <name>ROM_WS</name>
              <description>Amount of ROM wait states:
'0': 0 wait states. Use this setting for newer, faster ROM design. Use this setting for older, slower ROM design and frequencies in the range [0, 24] MHz.
'1': 1 wait state. Use this setting for older, slower ROM design and frequencies in the range &lt;24, 48] MHz.

CPUSSv2 supports two types of ROM memory: an older, slower design (operating at up to 24 MHz) and a newer, faster design (operating at up to 48 MHz). The older design requires 1 wait state for frequencies above 24 MHz. The newer design never requires wait states. All chips after Street Fighter will use the newer design. As a result, all chips after Street Fighter can always use 0 wait states.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RAM_CTL</name>
          <description>RAM control register</description>
          <addressOffset>0x38</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x30000</resetMask>
          <fields>
            <field>
              <name>ARB</name>
              <description>Arbitration policy:
'0': CPU has priority
'1': DW/DMA has priority
'2': Roundrobin
'3': Roundrobin - sticky</description>
              <bitRange>[17:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_CTL</name>
          <description>DMA controller register</description>
          <addressOffset>0x3C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x30000</resetMask>
          <fields>
            <field>
              <name>ARB</name>
              <description>Arbitration policy:
'0': CPU has priority
'1': DW/DMA has priority
'2': Roundrobin
'3': Roundrobin - sticky</description>
              <bitRange>[17:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PRIV_RAM1</name>
          <description>RAM 1 privilege register</description>
          <addressOffset>0xA0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x1FF</resetValue>
          <resetMask>0x1FF</resetMask>
          <fields>
            <field>
              <name>RAM_PROT_LIMIT</name>
              <description>See description of PRIV_RAM.RAM_PROT_LIMIT. Note that the reset value is 0x1ff, indicating that the complete RAM 1 memory capacity is User accessable.</description>
              <bitRange>[8:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RAM1_CTL</name>
          <description>RAM 1 control register</description>
          <addressOffset>0xA4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x30000</resetMask>
          <fields>
            <field>
              <name>ARB</name>
              <description>Arbitration policy (for RAM controller 1):
'0': CPU has priority
'1': DW/DMA has priority
'2': Roundrobin
'3': Roundrobin - sticky</description>
              <bitRange>[17:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>24</dim>
          <dimIncrement>4</dimIncrement>
          <name>SL_CTL[%s]</name>
          <description>Slave control register</description>
          <addressOffset>0x100</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x30000</resetMask>
          <fields>
            <field>
              <name>ARB</name>
              <description>Arbitration policy:
'0': CPU priority
'1': DMA priority
'2': Roundrobin
'3': Roundrobin - sticky</description>
              <bitRange>[17:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>SPCIF</name>
      <description>Flash Control Interface</description>
      <baseAddress>0x40110000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>65536</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>GEOMETRY</name>
          <description>Flash/NVL geometry information</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x80000000</resetMask>
          <fields>
            <field>
              <name>FLASH</name>
              <description>Regular flash capacity in 256 Byte multiples (chip dependent). If multiple flash macros are present, this field provides the flash capacity of all flash macros together:
'0': 256 Bytes.
'1': 2*256 Bytes.
...
'65535': 65536*256 Bytes.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SFLASH</name>
              <description>Supervisory flash capacity in 256 Byte multiples (chip dependent). If multiple flash macros are present, this field provides the supervisory flash capacity of all flash macros together:
'0': 256 Bytes.
'1': 2*256 Bytes.
...
'15': 16*256 Bytes.</description>
              <bitRange>[19:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>NUM_FLASH</name>
              <description>Number of flash macros (chip dependent):
'0': 1 flash macro
'1': 2 flash macros
'2': 3 flash macros
'3': 4 flash macros</description>
              <bitRange>[21:20]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>FLASH_ROW</name>
              <description>Page size in 64 Byte multiples (chip dependent):
'0': 64 byte
'1': 128 byte
'2': 192 byte
'3': 256 byte

The page size is used to detemine the number of Bytes in a page for Flash page based operations (e.g. PGM_PAGE).

Note: the field name FLASH_ROW is misleading, as this field specifies the number of Bytes in a page, rather than the number of Bytes in a row. In a single plane flash macro architecture, a page consists of a single row. However, in a multi plane flash macro architecture, a page consists of multiple rows from different planes.</description>
              <bitRange>[23:22]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>NVL</name>
              <description>NVLatch size in Byte multiples (chip dependent):
'0': 0 Bytes
'1': 1 Byte
...
'127': 127 Bytes</description>
              <bitRange>[30:24]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DE_CPD_LP</name>
              <description>0': SRAM busy wait loop has not been copied.
'1': Busy wait loop has been written into SRAM.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>NVL_WR_DATA</name>
          <description>NVL write data register</description>
          <addressOffset>0x1C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>DATA</name>
              <description>Data to be written to NVLatch array</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR</name>
          <description>SPCIF interrupt request register</description>
          <addressOffset>0x7F0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1</resetMask>
          <fields>
            <field>
              <name>TIMER</name>
              <description>Timer counter value reaches '0'. Set to '1', when event is detected. Write INTR field with '1', to clear bit. Write INTR_SET field with '1', to set bit.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_SET</name>
          <description>SPCIF interrupt set request register</description>
          <addressOffset>0x7F4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1</resetMask>
          <fields>
            <field>
              <name>TIMER</name>
              <description>Write INTR_SET field with '1' to set corresponding INTR field.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_MASK</name>
          <description>SPCIF interrupt mask register</description>
          <addressOffset>0x7F8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1</resetMask>
          <fields>
            <field>
              <name>TIMER</name>
              <description>Mask for corresponding field in INTR register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_MASKED</name>
          <description>SPCIF interrupt masked request register</description>
          <addressOffset>0x7FC</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1</resetMask>
          <fields>
            <field>
              <name>TIMER</name>
              <description>Logical and of corresponding request and mask fields.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>TCPWM</name>
      <description>Timer/Counter/PWM</description>
      <baseAddress>0x40200000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>65536</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>CTRL</name>
          <description>TCPWM control register 0.</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>COUNTER_ENABLED</name>
              <description>Counter enables for counters 0 up to CNT_NR-1.
'0': counter disabled.
'1': counter enabled.
Counter static configuration information (e.g. CTRL.MODE, all TR_CTRL0, TR_CTRL1, and TR_CTRL2 register fields) should only be modified when the counter is disabled. When a counter is disabled, command and status information associated to the counter is cleared by HW, this includes:
- the associated counter triggers in the CMD register are set to '0'.
- the counter's interrupt cause fields in counter's INTR register.
- the counter's status fields in counter's STATUS register..
- the counter's trigger outputs ('tr_overflow', 'tr_underflow' and 'tr_compare_match').
- the counter's line outputs ('line_out' and 'line_compl_out').</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CMD</name>
          <description>TCPWM command register.</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>COUNTER_CAPTURE</name>
              <description>Counters SW capture trigger. When written with '1', a capture trigger is generated and the HW sets the field to '0' when the SW trigger has taken effect. It should be noted that the HW operates on the counter frequency. If the counter is disabled through CTRL.COUNTER_ENABLED, the field is immediately set to '0'.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>COUNTER_RELOAD</name>
              <description>Counters SW reload trigger. For HW behavior, see COUNTER_CAPTURE field.</description>
              <bitRange>[15:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>COUNTER_STOP</name>
              <description>Counters SW stop trigger. For HW behavior, see COUNTER_CAPTURE field.</description>
              <bitRange>[23:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>COUNTER_START</name>
              <description>Counters SW start trigger. For HW behavior, see COUNTER_CAPTURE field.</description>
              <bitRange>[31:24]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_CAUSE</name>
          <description>TCPWM Counter interrupt cause register.</description>
          <addressOffset>0xC</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>COUNTER_INT</name>
              <description>Counters interrupt signal active. If the counter is disabled through CTRL.COUNTER_ENABLED, the associated interrupt field is immediately set to '0'.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <cluster>
          <dim>4</dim>
          <dimIncrement>64</dimIncrement>
          <name>CNT[%s]</name>
          <description>Timer/Counter/PWM Counter Module</description>
          <addressOffset>0x00000100</addressOffset>
          <register>
            <name>CTRL</name>
            <description>Counter control register</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x737FF0F</resetMask>
            <fields>
              <field>
                <name>AUTO_RELOAD_CC</name>
                <description>Specifies switching of the CC and buffered CC values. This field has a function in TIMER, PWM, PWM_DT and PWM_PR modes.
Timer mode:
'0': never switch.
'1': switch on a compare match event.
PWM, PWM_DT, PWM_PR modes: 
'0: never switch.
'1': switch on a terminal count event with an actively pending switch event.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>AUTO_RELOAD_PERIOD</name>
                <description>Specifies switching of the PERIOD and buffered PERIOD values. This field has a function in PWM, PWM_DT and PWM_PR modes.
'0': never switch.
'1': switch on a terminal count event with and actively pending siwtch event.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PWM_SYNC_KILL</name>
                <description>Specifies asynchronous/synchronous kill behavior:
'1': synchronous kill mode: the kill event disables the 'dt_line_out' and 'dt_line_compl_out' signals till the next terminal count event (synchronous kill). In synchronous kill mode, STOP_EDGE should  be RISING_EDGE.
'0': asynchronous kill mode: the kill event only disables the 'dt_line_out' and 'dt_line_compl_out' signals when present. In asynchronous kill mode, STOP_EDGE should be NO_EDGE_DET. 

This field has a function in PWM and PWM_DT modes only. This field is only used when PWM_STOP_ON_KILL is '0'.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PWM_STOP_ON_KILL</name>
                <description>Specifies whether the counter stops on a kill events:
'0': kill event does NOT stop counter.
'1': kill event stops counter.

This field has a function in PWM, PWM_DT and PWM_PR modes only.</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>GENERIC</name>
                <description>Generic 8-bit control field. In PWM_DT mode, this field is used to determine the dead time: amount of dead time cycles in the counter clock domain. In all other modes, the lower 3 bits of this field determine pre-scaling of the selected counter clock.</description>
                <bitRange>[15:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>UP_DOWN_MODE</name>
                <description>Determines counter direction.</description>
                <bitRange>[17:16]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>COUNT_UP</name>
                    <description>Count up (to PERIOD). An overflow event is generated when the counter reaches PERIOD. A terminal count event is generated when the counter reaches PERIOD.</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>COUNT_DOWN</name>
                    <description>Count down (to '0'). An underflow event is generated when the counter reaches '0'. A terminal count event is generated when the counter reaches '0'.</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>COUNT_UPDN1</name>
                    <description>Count up (to PERIOD), then count down (to '0'). An overflow event is generated when the counter reaches PERIOD. An underflow event is generated when the counter reaches '0'. A terminal count event is generated when the counter reaches '0'.</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>COUNT_UPDN2</name>
                    <description>Count up (to PERIOD), then count down (to '0'). An overflow event is generated when the counter reaches PERIOD. An underflow event is generated when the counter reaches '0'. A terminal count event is generated when the counter reaches '0' AND when the counter reaches PERIOD (this counter direction can be used for PWM functionality with asymmetrical updates).</description>
                    <value>3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>ONE_SHOT</name>
                <description>When '0', counter runs continuous. When '1', counter is turned off by hardware when a terminal count event is generated.</description>
                <bitRange>[18:18]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>QUADRATURE_MODE</name>
                <description>In QUAD mode selects quadrature encoding mode (X1/X2/X4).
In PWM, PWM_DT and PWM_PR modes, these two bits can be used to invert 'dt_line_out' and 'dt_line_compl_out'.  Inversion is the last step in generation of 'dt_line_out' and 'dt_line_compl_out'; i.e. a disabled output line 'dt_line_out' has the value QUADRATURE_MODE[0] and a disabled output line 'dt_line_compl_out' has the value QUADRATURE_MODE[1].</description>
                <bitRange>[21:20]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>X1</name>
                    <description>X1 encoding (QUAD mode)</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>X2</name>
                    <description>X2 encoding (QUAD mode)</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>X4</name>
                    <description>X4 encoding (QUAD mode)</description>
                    <value>2</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>MODE</name>
                <description>Counter mode.</description>
                <bitRange>[26:24]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>TIMER</name>
                    <description>Timer mode</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CAPTURE</name>
                    <description>Capture mode</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>QUAD</name>
                    <description>Quadrature encoding mode</description>
                    <value>3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>PWM</name>
                    <description>Pulse width modulation (PWM) mode</description>
                    <value>4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>PWM_DT</name>
                    <description>PWM with deadtime insertion mode</description>
                    <value>5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>PWM_PR</name>
                    <description>Pseudo random pulse width modulation</description>
                    <value>6</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>STATUS</name>
            <description>Counter status register</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x8000FF01</resetMask>
            <fields>
              <field>
                <name>DOWN</name>
                <description>When '0', counter is counting up. When '1', counter is counting down. In QUAD mode, this field indicates the direction of the latest counter change: '0' when last incremented and '1' when last decremented.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>GENERIC</name>
                <description>Generic 8-bit counter field. In PWM_DT mode, this counter is used for dead time insertion. In all other modes, this counter is used for pre-scaling the selected counter clock. PWM_DT mode can NOT use prescaled clock functionality.</description>
                <bitRange>[15:8]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>RUNNING</name>
                <description>When '0', the counter is NOT running. When '1', the counter is running.</description>
                <bitRange>[31:31]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>COUNTER</name>
            <description>Counter count register</description>
            <addressOffset>0x8</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFF</resetMask>
            <fields>
              <field>
                <name>COUNTER</name>
                <description>16-bit counter value. It is advised to not write to this field when the counter is running.</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CC</name>
            <description>Counter compare/capture register</description>
            <addressOffset>0xC</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0xFFFF</resetValue>
            <resetMask>0xFFFF</resetMask>
            <fields>
              <field>
                <name>CC</name>
                <description>In CAPTURE mode, captures the counter value. In other modes, compared to counter value.</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CC_BUFF</name>
            <description>Counter buffered compare/capture register</description>
            <addressOffset>0x10</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0xFFFF</resetValue>
            <resetMask>0xFFFF</resetMask>
            <fields>
              <field>
                <name>CC</name>
                <description>Additional buffer for counter CC register.</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>PERIOD</name>
            <description>Counter period register</description>
            <addressOffset>0x14</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0xFFFF</resetValue>
            <resetMask>0xFFFF</resetMask>
            <fields>
              <field>
                <name>PERIOD</name>
                <description>Period value: upper value of the counter. When the counter should count for n cycles, this field should be set to n-1.</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>PERIOD_BUFF</name>
            <description>Counter buffered period register</description>
            <addressOffset>0x18</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0xFFFF</resetValue>
            <resetMask>0xFFFF</resetMask>
            <fields>
              <field>
                <name>PERIOD</name>
                <description>Additional buffer for counter PERIOD register.</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>TR_CTRL0</name>
            <description>Counter trigger control register 0</description>
            <addressOffset>0x20</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x10</resetValue>
            <resetMask>0xFFFFF</resetMask>
            <fields>
              <field>
                <name>CAPTURE_SEL</name>
                <description>Selects one of the 16 input triggers as a capture trigger. Input trigger 0 is always '0' and input trigger 1 is always '1'. Input trigger 2 is the first external trigger line (tcpwm.tr_in[0]).

In the PWM, PWM_DT and PWM_PR modes this trigger is used to switch the values if the compare and period registers with their buffer counterparts.</description>
                <bitRange>[3:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>COUNT_SEL</name>
                <description>Selects one of the 16 input triggers as a count trigger. In QUAD mode, this is the first phase (phi A). Default setting selects input trigger 1, which is always '1'.</description>
                <bitRange>[7:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RELOAD_SEL</name>
                <description>Selects one of the 16 input triggers as a reload trigger. In QUAD mode, this is the index or revolution pulse. In this mode, it will update the counter with the value in the TCPWM_CNTn_PERIOD register.</description>
                <bitRange>[11:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>STOP_SEL</name>
                <description>Selects one of the 16 input triggers as a stop trigger. In PWM, PWM_DT and PWM_PR modes, this is the kill trigger. In these modes, the kill trigger is used to either temporarily block the PWM outputs (PWM_STOP_ON_KILL is '0') or stop the functionality (PWM_STOP_ON_KILL is '1'). For the PWM and PWM_DT modes, the blocking of the output signals can be  asynchronous (STOP_EDGE should be NO_EDGE_DET) in which case the blocking is as long as the trigger is '1' or synchronous (STOP_EDGE should be RISING_EDGE) in which case it extends till the next terminal count event.</description>
                <bitRange>[15:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>START_SEL</name>
                <description>Selects one of the 16 input triggers as a start trigger. In QUAD mode, this is the second phase (phi B).</description>
                <bitRange>[19:16]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>TR_CTRL1</name>
            <description>Counter trigger control register 1</description>
            <addressOffset>0x24</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x3FF</resetValue>
            <resetMask>0x3FF</resetMask>
            <fields>
              <field>
                <name>CAPTURE_EDGE</name>
                <description>A capture event will copy the counter value into the CC register.</description>
                <bitRange>[1:0]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>RISING_EDGE</name>
                    <description>Rising edge. Any rising edge generates an event.</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>FALLING_EDGE</name>
                    <description>Falling edge. Any falling edge generates an event.</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>BOTH_EDGES</name>
                    <description>Rising AND falling edge. Any odd amount of edges generates an event.</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>NO_EDGE_DET</name>
                    <description>No edge detection, use trigger as is.</description>
                    <value>3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>COUNT_EDGE</name>
                <description>A counter event will increase or decrease the counter by '1'.</description>
                <bitRange>[3:2]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>RISING_EDGE</name>
                    <description>Rising edge. Any rising edge generates an event.</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>FALLING_EDGE</name>
                    <description>Falling edge. Any falling edge generates an event.</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>BOTH_EDGES</name>
                    <description>Rising AND falling edge. Any odd amount of edges generates an event.</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>NO_EDGE_DET</name>
                    <description>No edge detection, use trigger as is.</description>
                    <value>3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RELOAD_EDGE</name>
                <description>A reload event will initialize the counter. When counting up, the counter is initialized to '0'. When counting down, the counter is initialized with PERIOD.</description>
                <bitRange>[5:4]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>RISING_EDGE</name>
                    <description>Rising edge. Any rising edge generates an event.</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>FALLING_EDGE</name>
                    <description>Falling edge. Any falling edge generates an event.</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>BOTH_EDGES</name>
                    <description>Rising AND falling edge. Any odd amount of edges generates an event.</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>NO_EDGE_DET</name>
                    <description>No edge detection, use trigger as is.</description>
                    <value>3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>STOP_EDGE</name>
                <description>A stop event, will stop the counter; i.e. it will no longer be running. Stopping will NOT disable the counter.</description>
                <bitRange>[7:6]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>RISING_EDGE</name>
                    <description>Rising edge. Any rising edge generates an event.</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>FALLING_EDGE</name>
                    <description>Falling edge. Any falling edge generates an event.</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>BOTH_EDGES</name>
                    <description>Rising AND falling edge. Any odd amount of edges generates an event.</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>NO_EDGE_DET</name>
                    <description>No edge detection, use trigger as is.</description>
                    <value>3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>START_EDGE</name>
                <description>A start event will start the counter; i.e. the counter will become running. Starting does NOT enable the counter. A start event will not initialize the counter whereas the reload event does.</description>
                <bitRange>[9:8]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>RISING_EDGE</name>
                    <description>Rising edge. Any rising edge generates an event.</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>FALLING_EDGE</name>
                    <description>Falling edge. Any falling edge generates an event.</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>BOTH_EDGES</name>
                    <description>Rising AND falling edge. Any odd amount of edges generates an event.</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>NO_EDGE_DET</name>
                    <description>No edge detection, use trigger as is.</description>
                    <value>3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>TR_CTRL2</name>
            <description>Counter trigger control register 2</description>
            <addressOffset>0x28</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x3F</resetValue>
            <resetMask>0x3F</resetMask>
            <fields>
              <field>
                <name>CC_MATCH_MODE</name>
                <description>Determines the effect of a compare match event (COUNTER equals CC register) on the 'line_out' output signals.  Note that INVERT is especially useful for center aligned pulse width modulation.
To generate a duty cycle of 0 percent, the counter CC register should be set to '0'. For a 100 percent duty cycle, the counter CC register should be set to larger than the counter PERIOD register.</description>
                <bitRange>[1:0]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>SET</name>
                    <description>Set to '1'</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CLEAR</name>
                    <description>Set to '0'</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>INVERT</name>
                    <description>Invert</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>NO_CHANGE</name>
                    <description>No Change</description>
                    <value>3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OVERFLOW_MODE</name>
                <description>Determines the effect of a counter overflow event (COUNTER reaches PERIOD) on the 'line_out' output signals.</description>
                <bitRange>[3:2]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>SET</name>
                    <description>Set to '1'</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CLEAR</name>
                    <description>Set to '0'</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>INVERT</name>
                    <description>Invert</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>NO_CHANGE</name>
                    <description>No Change</description>
                    <value>3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>UNDERFLOW_MODE</name>
                <description>Determines the effect of a counter underflow event (COUNTER reaches '0') on the 'line_out' output signals.</description>
                <bitRange>[5:4]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>SET</name>
                    <description>Set to '1'</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CLEAR</name>
                    <description>Set to '0'</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>INVERT</name>
                    <description>Invert</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>NO_CHANGE</name>
                    <description>No Change</description>
                    <value>3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR</name>
            <description>Interrupt request register.</description>
            <addressOffset>0x30</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x3</resetMask>
            <fields>
              <field>
                <name>TC</name>
                <description>Terminal count event. Set to '1', when event is detected. Write with '1' to clear bit.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CC_MATCH</name>
                <description>Counter matches CC register event. Set to '1', when event is detected. Write with '1' to clear bit.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_SET</name>
            <description>Interrupt set request register.</description>
            <addressOffset>0x34</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x3</resetMask>
            <fields>
              <field>
                <name>TC</name>
                <description>Write with '1' to set corresponding bit in interrupt request register.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CC_MATCH</name>
                <description>Write with '1' to set corresponding bit in interrupt request register.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_MASK</name>
            <description>Interrupt mask register.</description>
            <addressOffset>0x38</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x3</resetMask>
            <fields>
              <field>
                <name>TC</name>
                <description>Mask bit for corresponding bit in interrupt request register.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CC_MATCH</name>
                <description>Mask bit for corresponding bit in interrupt request register.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_MASKED</name>
            <description>Interrupt masked request register</description>
            <addressOffset>0x3C</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x3</resetMask>
            <fields>
              <field>
                <name>TC</name>
                <description>Logical and of corresponding request and mask bits.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>CC_MATCH</name>
                <description>Logical and of corresponding request and mask bits.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
        </cluster>
      </registers>
    </peripheral>
    <peripheral>
      <name>SCB0</name>
      <description>Serial Communications Block (SPI/UART/I2C)</description>
      <headerStructName>SCB</headerStructName>
      <baseAddress>0x40240000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>65536</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>CTRL</name>
          <description>Generic control register.</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x300000F</resetValue>
          <resetMask>0x83031F0F</resetMask>
          <fields>
            <field>
              <name>OVS</name>
              <description>N/A</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EC_AM_MODE</name>
              <description>Internally clocked mode ('0') or externally clocked mode ('1') address matching (I2C) or selection (SPI). In internally clocked mode, the serial interface protocols run off the peripheral clock. In externally clocked mode, the serial interface protocols run off the clock as provided by the serial interface. Externally clocked mode is only used for synchronous serial interface protocols (SPI and I2C) in slave mode. In SPI mode, only Motorola submode (all Motorola modes: 0, 1, 2, 3) is supported.

In UART mode this field should be '0'.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EC_OP_MODE</name>
              <description>Internally clocked mode ('0') or externally clocked mode ('1') operation. In internally clocked mode, the serial interface protocols run off the peripheral clock. In externally clocked mode, the serial interface protocols run off the clock as provided by the serial interface. Externally clocked operation mode is only used for synchronous serial interface protocols (SPI and I2C) in slave mode AND EZ mode. In SPI mode, only Motorola submode (all Motorola modes: 0, 1, 2, 3) is supported. The maximum SPI slave, EZ mode bitrate is 48 Mbps (transmission and IO delays outside the IP will degrade the effective bitrate).

In UART mode this field should be '0'.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EZ_MODE</name>
              <description>Non EZ mode ('0') or EZ mode ('1'). In EZ mode, a meta protocol is applied to the serial interface protocol. This meta protocol adds meaning to the data frames transferred by the serial interface protocol: a data frame can represent a memory address, a write memory data element or a read memory data element. EZ mode is only used for synchronous serial interface protocols: SPI and I2C. In SPI mode, only Motorola submode (all Motorola modes: 0, 1, 2, 3) is supported and the transmitter should use continuous data frames; i.e. data frames mot seperated by slave deselection. This mode is only applicable to slave functionality. In EZ mode, the slave can read from and write to an addressable memory structure of 32 bytes. In EZ mode, data frames should 8-bit in size and should be transmitted and received with the Most Significant Bit (MSB) first.

In UART mode this field should be '0'.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BYTE_MODE</name>
              <description>Determines the number of bits per FIFO data element:
'0': 16-bit FIFO data elements.
'1': 8-bit FIFO data elements. This mode doubles the amount of FIFO entries, but  TX_CTRL.DATA_WIDTH and RX_CTRL.DATA_WIDTH are restricted to [0, 7].</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CMD_RESP_MODE</name>
              <description>Determines CMD_RESP mode of operation:
'0': CMD_RESP mode disabled.
'1': CMD_RESP mode enabled (also requires EC_AM_MODE and EC_OP_MODE to be set to '1').</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ADDR_ACCEPT</name>
              <description>Determines whether a received matching address is accepted in the RX FIFO ('1') or not ('0').

In I2C mode, this field is used to allow the slave to put the received slave address or general call address in the RX FIFO. Note that a received matching address is put in the RX FIFO when ADDR_ACCEPT is '1' for both I2C read and write transfers.

In multi-processor UART receiver mode, this field is used to allow the receiver to put the received address in the RX FIFO. Note: non-matching addresses are never put in the RX FIFO.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BLOCK</name>
              <description>Only used in externally clocked mode. If the externally clocked logic and the MMIO SW accesses to EZ memory coincide/collide, this bit determines whether a SW access should block and result in bus wait states ('BLOCK is 1') or not (BLOCK is '0'). IF BLOCK is '0' and the accesses collide, MMIO read operations return 0xffff:ffff and MMIO write operations are ignored. Colliding accesses are registered as interrupt causes: field BLOCKED of MMIO registers INTR_TX and INTR_RX.</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MODE</name>
              <description>N/A</description>
              <bitRange>[25:24]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>I2C</name>
                  <description>Inter-Integrated Circuits (I2C) mode.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SPI</name>
                  <description>Serial Peripheral Interface (SPI) mode.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UART</name>
                  <description>Universal Asynchronous Receiver/Transmitter (UART) mode.</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ENABLED</name>
              <description>IP enabled ('1') or not ('0'). The proper order in which to initialize the IP is as follows:
- Program protocol specific information using SPI_CTRL, UART_CTRL (and UART_TX_CTRL and UART_RX_CTRL) or I2C_CTRL. This includes selection of a submode, master/slave functionality and transmitter/receiver functionality when applicable.
- Program generic transmitter (TX_CTRL) and receiver (RX_CTRL) information. This includes enabling of the transmitter and receiver functionality.
- Program transmitter FIFO (TX_FIFO_CTRL) and receiver FIFO (RX_FIFO_CTRL) information.
- Program CTRL to enable IP, select the specific operation mode and oversampling factor.
When the IP is enabled, no control information should be changed. Changes should be made AFTER disabling the IP, e.g. to modify the operation mode (from I2C to SPI) or to go from externally to internally clocked. The change takes effect after the IP is re-enabled. Note that disabling the IP will cause re-initialization of the design and associated state is lost (e.g. FIFO content).</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>STATUS</name>
          <description>Generic status register.</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>EC_BUSY</name>
              <description>Inidicates whether the externally clocked logic is potentially accessing the EZ memory (this is only possible in EZ mode). This bit can be used by SW to determine whether it is safe to issue a SW access to the EZ memory (without bus wait states (a blocked SW access) or bus errors being generated). Note that the INTR_TX.BLOCKED and INTR_RX.BLOCKED interrupt causes are used to indicate whether a SW access was actually blocked by externally clocked logic.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CMD_RESP_CTRL</name>
          <description>Command/response control register.</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1FF01FF</resetMask>
          <fields>
            <field>
              <name>BASE_RD_ADDR</name>
              <description>I2C/SPI read base address for CMD_RESP mode. Address is used by a I2C CMD_RESP mode read transfer (CTRL.MODE is I2C) or a SPI CMD_RESP mode read transfer (CTRL.MODE is SPI): at the start of a read transfer BASE_RD_ADDR is copied to CMD_RESP_STATUS.CURR_RD_ADDR. This field should not be modified during ongoing bus transfers.</description>
              <bitRange>[8:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BASE_WR_ADDR</name>
              <description>I2C/SPI read base address for CMD_RESP mode. Address is used by a I2C CMD_RESP mode write transfer (CTRL.MODE is I2C) or a SPI CMD_RESP mode write transfer (CTRL.MODE is SPI): at the start of a write transfer BASE_WE_ADDR is copied to CMD_RESP_STATUS.CURR_WR_ADDR. This field should not be modified during ongoing bus transfers.</description>
              <bitRange>[24:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CMD_RESP_STATUS</name>
          <description>Command/response status register.</description>
          <addressOffset>0xC</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>CURR_RD_ADDR</name>
              <description>I2C/SPI read current address for CMD_RESP mode. HW increments the field after a read access to the memory buffer. However, when the last memory buffer address is reached, the address is NOT incremented (but remains at the maximim memory buffer address). 

The field is used to determine how many bytes have been read (# bytes = CURR_RD_ADDR - CMD_RESP_CTRL.BASE_RD_ADDR). 

This field is reliable during when there is no bus transfer. This field is potentially unreliable when there is a bus transfer bus transfer: when CMD_RESP_EC_BUSY is '0', the field is reliable.</description>
              <bitRange>[8:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>CURR_WR_ADDR</name>
              <description>I2C/SPI write current address for CMD_RESP mode. HW increments the field after a read access to the memory buffer. However, when the last memory buffer address is reached, the address is NOT incremented (but remains at the maximim memory buffer address).

The field is used to determine how many bytes have been written (# bytes = CURR_WR_ADDR - CMD_RESP_CTRL.BASE_WR_ADDR).

This field is reliable during when there is no bus transfer. This field is potentially unreliable when there is a bus transfer bus transfer: when CMD_RESP_EC_BUSY is '0', the field is reliable.</description>
              <bitRange>[24:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>CMD_RESP_EC_BUS_BUSY</name>
              <description>Indicates whether there is an ongoing bus transfer to the IP.
'0': no ongoing bus transfer.
'1': ongoing bus transferr.

For SPI, the field is '1' when the slave is selected.

For I2C, the field is set to '1' at a I2C START/RESTART. In case of an address match, the  field is set to '0' on a I2C STOP. In case of NO address match, the field is set to '0' after the failing address match.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>CMD_RESP_EC_BUSY</name>
              <description>Indicates whether the CURR_RD_ADDR and CURR_WR_ADDR fields in this register are reliable (when CMD_RESP_EC_BUSY is '0') or not reliable (when CMD_RESP_EC_BUSY is '1'). Note:
- When there is no ongoing bus transfer, CMD_RESP_EC_BUSY is '0' (reliable).
- When there is a ongoing bus transfer, CMD_RESP_EC_BUSY is '0' (reliable), when the CURR_RD_ADDR and CURR_WR_ADDR are not being updated by the HW.
- When there is a ongoing bus transfer, CMD_RESP_EC_BUSY is '1' (not reliable), when the CURR_RD_ADDR or CURR_WR_ADDR are being updated by the HW. 
   Note that this update lasts one I2C clock cycle, or two SPI clock cycles.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SPI_CTRL</name>
          <description>SPI control register.</description>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x3000000</resetValue>
          <resetMask>0x8F010F3F</resetMask>
          <fields>
            <field>
              <name>CONTINUOUS</name>
              <description>Continuous SPI data transfers enabled ('1') or not ('0'). This field is used in master mode. In slave mode, both continuous and non-continuous SPI data transfers are supported independent of this field.

When continuous transfers are enabled individual data frame transfers are not necessarily seperated by slave deselection (as indicated by the level or pulse on the SELECT line): if the TX FIFO has multiple data frames, data frames are send out without slave deselection.

When continuous transfers are not enabled individual data frame transfers are always seperated by slave deselection: independent of the availability of TX FIFO data frames, data frames are send out with slave deselection.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SELECT_PRECEDE</name>
              <description>Only used in SPI Texas Instruments' submode.

When '1', the data frame start indication is a pulse on the SELECT line that precedes the transfer of the first data frame bit.

When '0', the data frame start indication is a pulse on the SELECT line that coincides with the transfer of the first data frame bit.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CPHA</name>
              <description>Only applicable in SPI Motorola submode. Indicates the clock phase. This field, together with the CPOL field, indicates when MOSI data is driven and MISO data is captured:
- Motorola mode 0. CPOL is '0', CPHA is '0': MOSI  is driven on a falling edge of SCLK. MISO is captured on a rising edge of SCLK.
- Motorola mode 1. CPOL is '0', CPHA is '1': MOSI  is driven on a rising edge of SCLK. MISO is captured on a falling edge of SCLK.
- Motorola mode 2. CPOL is '1', CPHA is '0': MOSI  is driven on a rising edge of SCLK. MISO is captured on a falling edge of SCLK.
- Motorola mode 3. CPOL is '1', CPHA is '1': MOSI  is driven on a falling edge of SCLK. MISO is captured on a rising edge of SCLK.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CPOL</name>
              <description>Indicates the clock polarity. Only used in SPI Motorola submode. This field, together with the CPHA field, indicates when MOSI data is driven and MISO data is captured:
- CPOL is '0': SCLK is '0' when not transmitting data.
- CPOL is '1': SCLK is '1' when not transmitting data.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LATE_MISO_SAMPLE</name>
              <description>Changes the SCLK edge on which MISO is captured. Only used in master mode.

When '0', the default applies (for Motorola as determined by CPOL and CPHA, for Texas Instruments on the falling edge of SCLK and for National Semiconductors on the rising edge of SCLK). 

When '1', the alternate clock edge is used (which comes half a SPI SCLK period later). Late sampling addresses the round trip delay associated with transmitting SCLK from the master to the slave and transmitting MISO from the slave to the master.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SCLK_CONTINUOUS</name>
              <description>Only applicable in master mode. 
'0': SCLK is generated, when the SPI master is enabled and data is transmitted.
'1': SCLK is generated, when the SPI master is enabled. This mode is useful for slave devices that use SCLK for functional operation other than just SPI functionality.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SSEL_POLARITY0</name>
              <description>Slave select polarity. SSEL_POLARITY0 applies to the outgoing SPI slave select signal 0 (master mode) and to the incoming SPI slave select signal (slave mode). only SPI_SELECT[0] is used in slave mode.
For Motorola and National Semiconductors submodes: 
'0': slave select is low/'0' active.
'1': slave select is high/'1' active.
For Texas Istruments submode:
'0': high/'1' active precede/coincide pulse.
'1': low/'0' active precede/coincide pulse.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SSEL_POLARITY1</name>
              <description>Slave select polarity. SSEL_POLARITY1 applies to the outgoing SPI slave select signal 1 (master mode).</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SSEL_POLARITY2</name>
              <description>Slave select polarity. SSEL_POLARITY2 applies to the outgoing SPI slave select signal 2 (master mode).</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SSEL_POLARITY3</name>
              <description>Slave select polarity. SSEL_POLARITY3 applies to the outgoing SPI slave select signal 3 (master mode).</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LOOPBACK</name>
              <description>Local loopback control (does NOT affect the information on the pins). Only used in master mode. Not used in National Semiconductors submode.
'0': the SPI master MISO line 'spi_miso_in' is connected to the SPI MISO pin.
'1': the SPI master MISO line 'spi_miso_in' is connected to the SPI master MOSI line 'spi_mosi_out'. In other words, in loopback mode the SPI master receives on MISO what it transmits on MOSI.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MODE</name>
              <description>N/A</description>
              <bitRange>[25:24]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SPI_MOTOROLA</name>
                  <description>SPI Motorola submode. In master mode, when not transmitting data (SELECT is inactive), SCLK is stable at CPOL. In slave mode, when not selected, SCLK is ignored; i.e. it can be either stable or clocking. In master mode, when there is no data to transmit (TX FIFO is empty), SELECT is inactive.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SPI_TI</name>
                  <description>SPI Texas Instruments submode. In master mode, when not transmitting data, SCLK is stable at '0'. In slave mode, when not selected, SCLK is ignored; i.e. it can be either stable or clocking. In master mode, when there is no data to transmit (TX FIFO is empty), SELECT is inactive; i.e. no pulse is generated.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SPI_NS</name>
                  <description>SPI National Semiconducturs submode. In master mode, when not transmitting data, SCLK is stable at '0'. In slave mode, when not selected, SCLK is ignored; i.e. it can be either stable or clocking. In master mode, when there is no data to transmit (TX FIFO is empty), SELECT is inactive.</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SLAVE_SELECT</name>
              <description>Selects one of the four outgoing SPI slave select signals:
- 0: Slave 0, SPI_SELECT[0].
- 1: Slave 1, SPI_SELECT[1].
- 2: Slave 2, SPI_SELECT[2].
- 3: Slave 3, SPI_SELECT[3].
Only used in master mode. The IP should be disabled when changes are made to this field.
only SPI_SELECT[0] is used in slave mode.</description>
              <bitRange>[27:26]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MASTER_MODE</name>
              <description>Master ('1') or slave ('0') mode. In master mode, transmission will commence on availability of data frames in the TX FIFO. In slave mode, when selected and there is no data frame in the TX FIFO, the slave will transmit all '1's. In both master and slave modes, received data frames will be lost if the RX FIFO is full.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SPI_STATUS</name>
          <description>SPI status register.</description>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>BUS_BUSY</name>
              <description>SPI bus is busy. The bus is considered busy ('1') during an ongoing transaction. For Motorola and National submodes, the busy bit is '1', when the slave selection (low active) is activated. For TI submode, the busy bit is '1' from the time the preceding/coinciding slave select (high active) is activated for the first transmitted data frame, till the last MOSI/MISO bit of the last data frame is transmitted.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SPI_EC_BUSY</name>
              <description>Inidicates whether the externally clocked logic is potentially accessing the EZ memory and/or updating BASE_ADDR or CURR_ADDR (this is only possible in EZ mode). This bit can be used by SW to determine whether BASE_ADDR and CURR_ADDR are reliable.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>CURR_EZ_ADDR</name>
              <description>SPI current EZ address. Current address pointer. This field is only reliable in internally clocked mode. In externally clocked mode the field may be unreliable (during an ongoing transfer when SPI_EC_BUSY is '1'), as clock domain synchronization is not performed in the design.</description>
              <bitRange>[15:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>BASE_EZ_ADDR</name>
              <description>SPI base EZ address. Address as provided by a SPI write transfer. This field is only reliable in internally clocked mode. In externally clocked mode the field may be unreliable, as clock domain synchronization is not performed in the design.</description>
              <bitRange>[23:16]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UART_CTRL</name>
          <description>UART control register.</description>
          <addressOffset>0x40</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x3000000</resetValue>
          <resetMask>0x3010000</resetMask>
          <fields>
            <field>
              <name>LOOPBACK</name>
              <description>Local loopback control (does NOT affect the information on the pins). When '0', the transmitter TX line 'uart_tx_out' is connected to the TX pin and the receiver RX line 'uart_rx_in' is connected to the RX pin. When '1', the transmitter TX line 'uart_tx_out' is connected to the receiver RX line 'uart_rx_in'. A similar connections scheme is followed for 'uart_rts_out' and 'uart_cts_in'.

This allows a SCB UART transmitter to communicate with its receiver counterpart.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MODE</name>
              <description>N/A</description>
              <bitRange>[25:24]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>UART_STD</name>
                  <description>Standard UART submode.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UART_SMARTCARD</name>
                  <description>SmartCard (ISO7816) submode. Support for negative acknowledgement (NACK) on the receiver side and retransmission on the transmitter side.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UART_IRDA</name>
                  <description>Infrared Data Association (IrDA) submode. Return to Zero modulation scheme. In this mode, the oversampling factor should be 16, that is OVS is 15.</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>UART_TX_CTRL</name>
          <description>UART transmitter control register.</description>
          <addressOffset>0x44</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x2</resetValue>
          <resetMask>0x137</resetMask>
          <fields>
            <field>
              <name>STOP_BITS</name>
              <description>Stop bits. STOP_BITS + 1 is the duration of the stop period in terms of halve bit periods. Valid range is [1, 7]; i.e. a stop period should last at least one bit period.</description>
              <bitRange>[2:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PARITY</name>
              <description>Parity bit. When '0', the transmitter generates an even parity. When '1', the transmitter generates an odd parity. Only applicable in standard UART and SmartCard submodes.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PARITY_ENABLED</name>
              <description>Parity generation enabled ('1') or not ('0'). Only applicable in standard UART submodes. In SmartCard submode, parity generation is always enabled through hardware. In IrDA submode, parity generation is always disabled through hardware</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RETRY_ON_NACK</name>
              <description>When '1', a data frame is retransmitted when a negative acknowledgement is received. Only applicable to the SmartCard submode.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UART_RX_CTRL</name>
          <description>UART receiver control register.</description>
          <addressOffset>0x48</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xA0002</resetValue>
          <resetMask>0xF3777</resetMask>
          <fields>
            <field>
              <name>STOP_BITS</name>
              <description>Stop bits. STOP_BITS + 1 is the duration of the stop period in terms of halve bit periods. Valid range is [1, 7]; i.e. a stop period should last at least one bit period. If STOP_BITS is '1', stop bits error detection is NOT performed. If STOP_BITS is in [2, 7], stop bits error detection is performed and the associated interrupt cause INTR_RX.FRAME_ERROR is set to '1' if an error is detected. In other words, the receiver supports data frames with a 1 bit period stop bit sequence, but requires at least 1.5 bit period stop bit sequences to detect errors. This limitation is due to possible transmitter and receiver clock skew that prevents the design from doing reliable stop bit detection for short (1 bit bit period) stop bit sequences. Note that in case of a stop bits error, the successive data frames may get lost as the receiver needs to resynchronize its start bit detection. The amount of lost data frames depends on both the amount of stop bits, the idle ('1') time between data frames and the data frame value.</description>
              <bitRange>[2:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PARITY</name>
              <description>Parity bit. When '0', the receiver expects an even parity. When '1', the receiver expects an odd parity. Only applicable in standard UART and SmartCard submodes.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PARITY_ENABLED</name>
              <description>Parity checking enabled ('1') or not ('0'). Only applicable in standard UART submode. In SmartCard submode, parity checking is always enabled through hardware. In IrDA submode, parity checking is always disabled through hardware.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>POLARITY</name>
              <description>Inverts incoming RX line signal 'uart_rx_in'. Inversion is after local loopback. This functionality is intended for IrDA receiver functionality.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DROP_ON_PARITY_ERROR</name>
              <description>Behaviour when a parity check fails. When '0', received data is send to the RX FIFO. When '1', received data is dropped and lost. Only applicable in standard UART and SmartCard submodes (negatively acknowledged SmartCard data frames may be dropped with this field).</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DROP_ON_FRAME_ERROR</name>
              <description>Behaviour when an error is detected in a start or stop period. When '0', received data is send to the RX FIFO. When '1', received data is dropped and lost.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MP_MODE</name>
              <description>Multi-processor mode. When '1', multi-processor mode is enabled. In this mode, RX_CTRL.DATA_WIDTH should indicate a 9-bit data frame. In multi-processor mode, the 9th received bit of a data frame seperates addresses (bit is '1') from data (bit is '0'). A received address is matched with RX_MATCH.DATA and RX_MATCH.MASK. In the case of a match, subsequent received data are sent to the RX FIFO. In the case of NO match, subsequent received data are dropped.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LIN_MODE</name>
              <description>Only applicable in standard UART submode. When '1', the receiver performs break detection and baud rate detection on the incoming data. First, break detection counts the amount of bit periods that have a line value of '0'. BREAK_WIDTH specifies the minum required amount of bit periods. Successful break detection sets the INTR_RX.BREAK_DETECT interrupt cause to '1'. Second, baud rate detection counts the amount of peripheral clock periods that are use to receive the synchronization byte (0x55; least significant bit first). The count is available through UART_RX_STATUS.BR_COUNTER. Successful baud rate detection sets the INTR_RX.BAUD_DETECT interrupt cause to '1' (BR_COUNTER is reliable). This functionality is used to synchronize/refine the receiver clock to the transmitter clock. The receiver software can use the BR_COUNTER value to set the right IP clock (from the programmable clock IP) to guarantee successful receipt of the first LIN data frame (Protected Identifier Field) after the synchronization byte.</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SKIP_START</name>
              <description>Only applicable in standard UART submode. When '1', the receiver skips start bit detection for the first received data frame. Instead, it synchronizes on the first received data frame bit, which should be a '1'. This functionality is intended for wake up from DeepSleep when receiving a data frame. The transition from idle ('1') to START ('0') on the RX line is used to wake up the CPU. The transition detection (and the associated wake up functionality) is performed by the GPIO2 IP. The woken up CPU will enable the SCB's UART receiver functionality. Once enabled, it is assumed that the START bit is ongoing (the CPU wakeup and SCB enable time should be less than the START bit period). The SCB will synchronize to a '0' to '1' transition, which indicates the first data frame bit is received (first data frame bit should be '1'). After synchronization to the first data frame bit, the SCB will resume normal UART functionality: subsequent data frames will be synchronized on the receipt of a START bit.</description>
              <bitRange>[13:13]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BREAK_WIDTH</name>
              <description>Break width. BREAK_WIDTH + 1 is the minimum width in bit periods of a break. During a break the transmitted/received line value is '0'. This feature is useful for standard UART submode and LIN submode ('break field' detection). Once, the break is detected, the INTR_RX.BREAK_DETECT bit is set to '1'. Note that break detection precedes baud rate detection, which is used to synchronize/refine the receiver clock to the transmitter clock. As a result, break detection operates with an unsynchronized/unrefined receiver clock. Therefore, the receiver's definition of a bit period is imprecise and the setting of this field should take this imprecision into account. The LIN standard also accounts for this imprecision: a LIN start bit followed by 8 data bits allows for up to 9 consecutive '0' bit periods during regular transmission, whereas the LIN break detection should be at least 13 consecutive '0' bit periods. This provides for a margin of 4 bit periods. Therefore, the default value of this field is set to 10, representing a minimal break field with of 10+1 = 11 bit periods; a value in between the 9 consecutive bit periods of a regular transmission and the 13 consecutive bit periods of a break field. This provides for slight imprecisions of the receiver clock wrt. the transmitter clock. There should not be a need to program this field to any value other than its default value.</description>
              <bitRange>[19:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UART_RX_STATUS</name>
          <description>UART receiver status register.</description>
          <addressOffset>0x4C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>BR_COUNTER</name>
              <description>Amount of peripheral clock periods that constitute the transmission of a 0x55 data frame (sent least signficant bit first) as determined by the receiver. BR_COUNTER / 8 is the amount of peripheral clock periods that constitute a bit period. This field has valid data when INTR_RX.BAUD_DETECT is set to '1'.</description>
              <bitRange>[11:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UART_FLOW_CTRL</name>
          <description>UART flow control register</description>
          <addressOffset>0x50</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x30100FF</resetMask>
          <fields>
            <field>
              <name>TRIGGER_LEVEL</name>
              <description>Trigger level. When the receiver FIFO has less entries than the amount of this field, a Ready To Send (RTS) output signal 'uart_rts_out' is activated. By setting this field to '0', flow control is effectively SW disabled (may be useful for debug purposes).</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RTS_POLARITY</name>
              <description>Polarity of the RTS output signal 'uart_rts_out':
'0': RTS is low/'0' active; 'uart_rts_out' is '0' when active and 'uart_rts_out' is '1' when inactive.
'1': RTS is high/'1' active; 'uart_rts_out' is '1' when active and 'uart_rts_out' is '0' when inactive.

During IP reset (Hibernate system power mode), 'uart_rts_out' is '1'. This represents an inactive state assuming a low/'0' active polarity.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CTS_POLARITY</name>
              <description>Polarity of the CTS input signal 'uart_cts_in':
'0': CTS is low/'0' active; 'uart_cts_in' is '0' when active and 'uart_cts_in' is '1' when inactive.
'1': CTS is high/'1' active; 'uart_cts_in' is '1' when active and 'uart_cts_in' is '0' when inactive.</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CTS_ENABLED</name>
              <description>Enable use of CTS input signal 'uart_cts_in' by the UART transmitter:
'0': Disabled. The UART transmitter ignores 'uart_cts_in', and transmits when a data frame is available for transmission in the TX FIFO or the TX shift register.
'1': Enabled. The UART transmitter uses 'uart_cts_in' to qualify the transmission of data. It transmits when 'uart_cts_in' is active and a data frame is available for transmission in the TX FIFO or the TX shift register.

If UART_CTRL.LOOPBACK is '1', 'uart_cts_in' is connected to 'uart_rts_out' in the IP (both signals are subjected to signal polarity changes as indicated by RTS_POLARITY and CTS_POLARITY).</description>
              <bitRange>[25:25]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I2C_CTRL</name>
          <description>I2C control register.</description>
          <addressOffset>0x60</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xFB88</resetValue>
          <resetMask>0xC001FBFF</resetMask>
          <fields>
            <field>
              <name>HIGH_PHASE_OVS</name>
              <description>Serial I2C interface high phase oversampling factor. HIGH_PHASE_OVS + 1 peripheral clock periods constitute the high phase of a bit period. The valid range is [5, 15] with input signal median filtering and [4, 15] without input signal median filtering.

The field is only used in master mode. In slave mode, the field is NOT used. However, there is a frequency requirement for the IP clock wrt. the regular interface (IF) high time to guarantee functional correct behavior. With input signal median filtering, the IF high time should be &gt;= 6 IP clock cycles and &lt;= 16 IP clock cycles. Without input signal median filtering, the IF high time should be &gt;= 5 IP clock cycles and &lt;= 16 IP clock cycles.</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LOW_PHASE_OVS</name>
              <description>Serial I2C interface low phase oversampling factor. LOW_PHASE_OVS + 1 peripheral clock periods constitute the low phase of a bit period. The valid range is [7, 15] with input signal median filtering and [6, 15] without input signal median filtering. 

The field is only used in master mode. In slave mode, the field is NOT used. However, there is a frequency requirement for the IP clock wrt. the regular (no stretching) interface (IF) low time to guarantee functional correct behavior. With input signal median filtering, the IF low time should be &gt;= 8 IP clock cycles and &lt;= 16 IP clock cycles. Without input signal median filtering, the IF low time should be &gt;= 7 IP clock cycles and &lt;= 16 IP clock cycles.</description>
              <bitRange>[7:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>M_READY_DATA_ACK</name>
              <description>When '1', a received data element by the master is immediately ACK'd when the receiver FIFO is not full.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>M_NOT_READY_DATA_NACK</name>
              <description>When '1', a received data element byte the master is immediately NACK'd when the receiver FIFO is full. When '0', clock stretching is used instead (till the receiver FIFO is no longer full).</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>S_GENERAL_IGNORE</name>
              <description>When '1', a received general call slave address is immediately NACK'd (no ACK or clock stretching) and treated as a non matching slave address. This is useful for slaves that do not need any data supplied within the general call structure.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>S_READY_ADDR_ACK</name>
              <description>When '1', a received (matching) slave address is immediately ACK'd when the receiver FIFO is not full. In EZ mode, this field should be set to '1'.</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>S_READY_DATA_ACK</name>
              <description>When '1', a received data element by the slave is immediately ACK'd when the receiver FIFO is not full. In EZ mode, this field should be set to '1'.</description>
              <bitRange>[13:13]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>S_NOT_READY_ADDR_NACK</name>
              <description>For internally clocked logic (EC_AM is '0' and EC_OP is '0') on an address match or general call address (and S_GENERAL_IGNORE is '0'). Only used when:
- EC_AM is '0', EC_OP is '0' and non EZ mode.
Functionality is as follows:
- 1: a received (matching) slave address is immediately NACK'd when the receiver FIFO is full.
- 0: clock stretching is performed (till the receiver FIFO is no longer full). 

For externally clocked logic (EC_AM is '1') on an address match or general call address (and S_GENERAL_IGNORE is '0'). Only used when (NOT used when EC_AM is '1' and EC_OP is '1' and address match and EZ mode):
- EC_AM is '1' and EC_OP is '0'.
- EC_AM is '1' and general call address match.
- EC_AM is '1' and non EZ mode.
Functionality is as follows:
- 1: a received (matching or general) slave address is always immediately NACK'd. There are two possibilities: 1). the internally clocked logic is enabled (we are in Active system power mode) and it handles the rest of the current transfer. In this case the I2C master will not observe the NACK. 2). the internally clocked logic is not enabled (we are in DeepSleep system power mode). In this case the I2C master will observe the NACK and may retry the transfer in the future (which gives the internally clocked logic the time to wake up from DeepSleep system power mode). 
- 0: clock stretching is performed (till the internally clocked logic takes over). The internally clocked logic will handle the ongoing transfer as soon as it is enabled.</description>
              <bitRange>[14:14]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>S_NOT_READY_DATA_NACK</name>
              <description>For internally clocked logic only. Only used when:
- non EZ mode.
Functionality is as follows:
- 1: a received data element byte the slave is immediately NACK'd when the receiver FIFO is full.
- 0: clock stretching is performed (till the receiver FIFO is no longer full).</description>
              <bitRange>[15:15]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LOOPBACK</name>
              <description>Local loopback control (does NOT affect the information on the pins). Only applicable in master/slave mode. When '0', the I2C SCL and SDA lines are connected to the I2C SCL and SDA pins. When '1', I2C SCL and SDA lines are routed internally in the peripheral, and as a result unaffected by other I2C devices. This allows a SCB I2C peripheral to address itself.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SLAVE_MODE</name>
              <description>Slave mode enabled ('1') or not ('0').</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MASTER_MODE</name>
              <description>Master mode enabled ('1') or not ('0'). Note that both master and slave modes can be enabled at the same time. This allows the IP to address itself.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I2C_STATUS</name>
          <description>I2C status register.</description>
          <addressOffset>0x64</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x31</resetMask>
          <fields>
            <field>
              <name>BUS_BUSY</name>
              <description>I2C bus is busy. The bus is considered busy ('1'), from the time a START is detected or from the time the SCL line is '0'. The bus is considered idle ('0'), from the time a STOP is detected. If the IP is disabled, BUS_BUSY is '0'. After enabling the IP, it takes time for the BUS_BUSY to detect a busy bus. This time is the maximum high time of the SCL line. For a 100 kHz interface frequency, this maximum high time may last roughly 5 us (half a bit period).

For single master systems, BUS_BUSY does not have to be used to detect an idle bus before a master starts a transfer using I2C_M_CMD.M_START (no bus collisions).

For multi-master systems, BUS_BUSY can be used to detect an idle bus before a master starts a transfer using I2C_M_CMD.M_START_ON_IDLE (to prevent bus collisions).</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>I2C_EC_BUSY</name>
              <description>Inidicates whether the externally clocked logic is potentially accessing the EZ memory and/or updating BASE_EZ_ADDR or CURR_EZ_ADDR (this is only possible in EZ mode). This bit can be used by SW to determine whether BASE_EZ_ADDR and CURR_EZ_ADDR are reliable.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>S_READ</name>
              <description>I2C slave read transfer ('1') or I2C slave write transfer ('0'). When the I2C slave is inactive/idle or receiving START, REPEATED START, STOP or an address, this field is '0''.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>M_READ</name>
              <description>I2C master read transfer ('1') or I2C master write transfer ('0'). When the I2C master is inactive/idle or transmitting START, REPEATED START, STOP or an address, this field is '0''.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>CURR_EZ_ADDR</name>
              <description>I2C slave current EZ address. Current address pointer. This field is only reliable in internally clocked mode. In externally clocked mode the field may be unreliable (during an ongoing transfer when I2C_EC_BUSY is '1'), as clock domain synchronization is not performed in the design.</description>
              <bitRange>[15:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>BASE_EZ_ADDR</name>
              <description>I2C slave base EZ address. Address as provided by an I2C write transfer. This field is only reliable in internally clocked mode. In externally clocked mode the field may be unreliable, as clock domain synchronization is not performed in the design.</description>
              <bitRange>[23:16]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I2C_M_CMD</name>
          <description>I2C master command register.</description>
          <addressOffset>0x68</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1F</resetMask>
          <fields>
            <field>
              <name>M_START</name>
              <description>When '1', transmit a START or REPEATED START. Whether a START or REPEATED START is transmitted depends on the state of the master state machine. A START is only transmitted when the master state machine is in the default state. A REPEATED START is transmitted when the master state machine is not in the default state, but is working on an ongoing transaction. The REPEATED START can only be transmitted after a NACK or ACK has been received for a transmitted data element or after a NACK has been transmitted for a received data element. When this action is performed, the hardware sets this field to '0'.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>M_START_ON_IDLE</name>
              <description>When '1', transmit a START as soon as the bus is idle (I2C_STATUS.BUS_BUSY is '0', note that BUSY has a default value of '0'). For bus idle detection the hardware relies on STOP detection. As a result, bus idle detection is only functional after at least one I2C bus transfer has been detected on the bus (default/reset value of BUSY is '0') . A START is only transmitted when the master state machine is in the default state. When this action is performed, the hardware sets this field to '0'.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>M_ACK</name>
              <description>When '1', attempt to transmit an acknowledgement (ACK). When this action is performed, the hardware sets this field to '0'.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>M_NACK</name>
              <description>When '1', attempt to transmit a negative acknowledgement (NACK). When this action is performed, the hardware sets this field to '0'.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>M_STOP</name>
              <description>When '1', attempt to transmit a STOP. When this action is performed, the hardware sets this field to '0'. 
 I2C_M_CMD.M_START has a higher priority than this command: in situations where both a STOP and a REPEATED START could be transmitted, M_START takes precedence over M_STOP.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I2C_S_CMD</name>
          <description>I2C slave command register.</description>
          <addressOffset>0x6C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3</resetMask>
          <fields>
            <field>
              <name>S_ACK</name>
              <description>When '1', attempt to transmit an acknowledgement (ACK). When this action is performed, the hardware sets this field to '0'. In EZ mode, this field should be set to '0' (it is only to be used in non EZ mode).</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>S_NACK</name>
              <description>When '1', attempt to transmit a negative acknowledgement (NACK). When this action is performed, the hardware sets this field to '0'.  In EZ mode, this field should be set to '0' (it is only to be used in non EZ mode). This command has a higher priority than I2C_S_CMD.S_ACK, I2C_CTRL.S_READY_ADDR_ACK or I2C_CTRL.S_READY_DATA_ACK.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I2C_CFG</name>
          <description>I2C configuration register.</description>
          <addressOffset>0x70</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x2A1013</resetValue>
          <resetMask>0x303F1313</resetMask>
          <fields>
            <field>
              <name>SDA_IN_FILT_TRIM</name>
              <description>Trim bits for 'i2c_sda_in' 50 ns filter. See s8i2cs BROS (001-59539) for more details on the trim bit values.</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SDA_IN_FILT_SEL</name>
              <description>Selection of 'i2c_sda_in' filter delay:
'0': 0 ns.
'1: 50 ns (filter enabled).</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SCL_IN_FILT_TRIM</name>
              <description>Trim bits for 'i2c_scl_in' 50 ns filter. See s8i2cs BROS (001-59539) for more details on the trim bit values. With s8iom0s8v1p2 I/Os, trim bits should be programmed to 3 to suppress glitches below 50ns.</description>
              <bitRange>[9:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SCL_IN_FILT_SEL</name>
              <description>Selection of 'i2c_scl_in' filter delay:
'0': 0 ns.
'1: 50 ns (filter enabled).</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SDA_OUT_FILT0_TRIM</name>
              <description>Trim bits for 'i2c_sda_out' 50 ns filter 0. See s8i2cs BROS (001-59539) for more details on the trim bit values.</description>
              <bitRange>[17:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SDA_OUT_FILT1_TRIM</name>
              <description>Trim bits for 'i2c_sda_out' 50 ns filter 1. See s8i2cs BROS (001-59539) for more details on the trim bit values.</description>
              <bitRange>[19:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SDA_OUT_FILT2_TRIM</name>
              <description>Trim bits for 'i2c_sda_out' 50 ns filter 2. See s8i2cs BROS (001-59539) for more details on the trim bit values.</description>
              <bitRange>[21:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SDA_OUT_FILT_SEL</name>
              <description>Selection of cumulative 'i2c_sda_out' filter delay:
'0': 0 ns.
'1': 50 ns (filter 0 enabled).
'2': 100 ns (filters 0 and 1 enabled).
'3': 150 ns (filters 0, 1 and 2 enabled).</description>
              <bitRange>[29:28]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TX_CTRL</name>
          <description>Transmitter control register.</description>
          <addressOffset>0x200</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x107</resetValue>
          <resetMask>0x10F</resetMask>
          <fields>
            <field>
              <name>DATA_WIDTH</name>
              <description>Dataframe width. DATA_WIDTH + 1 is the amount of bits in a transmitted data frame. This number does not include start, parity and stop bits. For UART mode, the valid range is [3, 8]. For SPI, the valid range is [3, 15]. For I2C the only valid value is 7.</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MSB_FIRST</name>
              <description>Least significant bit first ('0') or most significant bit first ('1'). For I2C, this field should be '1'.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TX_FIFO_CTRL</name>
          <description>Transmitter FIFO control register.</description>
          <addressOffset>0x204</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x300FF</resetMask>
          <fields>
            <field>
              <name>TRIGGER_LEVEL</name>
              <description>Trigger level. When the transmitter FIFO has less entries than the number of this field, a transmitter trigger event INTR_TX.TRIGGER is generated.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLEAR</name>
              <description>When '1', the transmitter FIFO and transmitter shift register are cleared/invalidated. Invalidation will last for as long as this field is '1'. If a quick clear/invalidation is required, the field should be set to '1' and be followed by a set to '0'. If a clear/invalidation is required for an extended time period, the field should be set to '1' during the complete time period.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FREEZE</name>
              <description>When '1', hardware reads from the transmitter FIFO do not remove FIFO entries. Freeze will not advance the TX FIFO read pointer.</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TX_FIFO_STATUS</name>
          <description>Transmitter FIFO status register.</description>
          <addressOffset>0x208</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFF81FF</resetMask>
          <fields>
            <field>
              <name>USED</name>
              <description>Amount of entries in the transmitter FIFO. The value of this field ranges from 0 to FF_DATA_NR (EZ_DATA_NR/2).</description>
              <bitRange>[8:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SR_VALID</name>
              <description>Indicates whether the TX shift registers holds a valid data frame ('1') or not ('0'). The shift register can be considered the top of the TX FIFO (the data frame is not included in the USED field of the TX FIFO). The shift register is a working register and holds the data frame that is currently transmitted (when the protocol state machine is transmitting a data frame) or the data frame that is tranmitted next (when the protocol state machine is not transmitting a data frame).</description>
              <bitRange>[15:15]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>RD_PTR</name>
              <description>FIFO read pointer: FIFO location from which a data frame is read by the hardware.</description>
              <bitRange>[23:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>WR_PTR</name>
              <description>FIFO write pointer: FIFO location at which a new data frame is written.</description>
              <bitRange>[31:24]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TX_FIFO_WR</name>
          <description>Transmitter FIFO write register.</description>
          <addressOffset>0x240</addressOffset>
          <size>32</size>
          <access>write-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>DATA</name>
              <description>Data frame written into the transmitter FIFO. Behavior is similar to that of a PUSH operation. Note that when CTRL.BYTE_MODE is '1', only DATA[7:0] are used.

A write to a full TX FIFO sets INTR_TX.OVERFLOW to '1'.</description>
              <bitRange>[15:0]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RX_CTRL</name>
          <description>Receiver control register.</description>
          <addressOffset>0x300</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x107</resetValue>
          <resetMask>0x30F</resetMask>
          <fields>
            <field>
              <name>DATA_WIDTH</name>
              <description>Dataframe width. DATA_WIDTH + 1 is the expected amount of bits in received data frame. This number does not include start, parity and stop bits. For UART mode, the valid range is [3, 8]. For SPI, the valid range is [3, 15]. For I2C the only valid value is 7. In EZ mode (for both SPI and I2C), the only valid value is 7.</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MSB_FIRST</name>
              <description>Least significant bit first ('0') or most significant bit first ('1'). For I2C, this field should be '1'.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MEDIAN</name>
              <description>Median filter. When '1', a digital 3 taps median filter is performed on input interface lines. This filter should reduce the susceptability to errors. However, its requires higher oversampling values. For UART IrDA submode, this field should always be '1'.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RX_FIFO_CTRL</name>
          <description>Receiver FIFO control register.</description>
          <addressOffset>0x304</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x300FF</resetMask>
          <fields>
            <field>
              <name>TRIGGER_LEVEL</name>
              <description>Trigger level. When the receiver FIFO has more entries than the number of this field, a receiver trigger event INTR_RX.TRIGGER is generated.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLEAR</name>
              <description>When '1', the receiver FIFO and receiver shift register are cleared/invalidated. Invalidation will last for as long as this field is '1'. If a quick clear/invalidation is required, the field should be set to '1' and be followed by a set to '0'. If a clear/invalidation is required for an extended time period, the field should be set to '1' during the complete time period.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FREEZE</name>
              <description>When '1', hardware writes to the receiver FIFO have no effect. Freeze will not advance the RX FIFO write pointer.</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RX_FIFO_STATUS</name>
          <description>Receiver FIFO status register.</description>
          <addressOffset>0x308</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFF81FF</resetMask>
          <fields>
            <field>
              <name>USED</name>
              <description>Amount of entries in the receiver FIFO. The value of this field ranges from 0 to FF_DATA_NR (EZ_DATA_NR/2).</description>
              <bitRange>[8:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SR_VALID</name>
              <description>Indicates whether the RX shift registers holds a (partial) valid data frame ('1') or not ('0'). The shift register can be considered the bottom of the RX FIFO (the data frame is not included in the USED field of the RX FIFO). The shift register is a working register and holds the data frame that is currently being received (when the protocol state machine is receiving a data frame).</description>
              <bitRange>[15:15]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>RD_PTR</name>
              <description>FIFO read pointer: FIFO location from which a data frame is read.</description>
              <bitRange>[23:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>WR_PTR</name>
              <description>FIFO write pointer: FIFO location at which a new data frame is written by the hardware.</description>
              <bitRange>[31:24]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RX_MATCH</name>
          <description>Slave address and mask register.</description>
          <addressOffset>0x310</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF00FF</resetMask>
          <fields>
            <field>
              <name>ADDR</name>
              <description>Slave device address.

In UART multi-processor mode, all 8 bits are used.

In I2C slave mode, only bits 7 down to 1 are used. This reflects the organization of the first transmitted byte in a I2C transfer: the first 7 bits represent the address of the addressed slave, and the last 1 bit is a read/write indicator ('0': write, '1': read).</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MASK</name>
              <description>Slave device address mask. This field is a mask that specifies which of the ADDR field bits in the ADDR field take part in the matching of the slave address: MATCH = ((ADDR &amp; MASK) == ('slave address' &amp; MASK)).</description>
              <bitRange>[23:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RX_FIFO_RD</name>
          <description>Receiver FIFO read register.</description>
          <addressOffset>0x340</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>DATA</name>
              <description>Data read from the receiver FIFO. Reading a data frame will remove the data frame from the FIFO; i.e. behavior is similar to that of a POP operation. Note that when CTRL.BYTE_MODE is '1', only DATA[7:0] are used.

This register has a side effect when read by software: a data frame is removed from the FIFO. This may be undesirable during debug; i.e. a read during debug should NOT have a side effect. To this end, the IP uses the AHB-Lite 'hmaster[0]' input signal. When this signal is '1' in the address cycle of a bus transfer, a read transfer will not have a side effect. As a result, a read from this register will not remove a data frame from the FIFO. As a result, a read from this register behaves as a read from the SCB_RX_FIFO_RD_SILENT register.

A read from an empty RX FIFO sets INTR_RX.UNDERFLOW to '1'.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RX_FIFO_RD_SILENT</name>
          <description>Receiver FIFO read register.</description>
          <addressOffset>0x344</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>DATA</name>
              <description>Data read from the receiver FIFO. Reading a data frame will NOT remove the data frame from the FIFO; i.e. behavior is similar to that of a PEEK operation. Note that when CTRL.BYTE_MODE is '1', only DATA[7:0] are used.

A read from an empty RX FIFO sets INTR_RX.UNDERFLOW to '1'.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_CAUSE</name>
          <description>Active clocked interrupt signal register</description>
          <addressOffset>0xE00</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3F</resetMask>
          <fields>
            <field>
              <name>M</name>
              <description>Master interrupt active ('interrupt_master'): INTR_M_MASKED != 0.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>S</name>
              <description>Slave interrupt active ('interrupt_slave'): INTR_S_MASKED != 0.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>TX</name>
              <description>Transmitter interrupt active ('interrupt_tx'): INTR_TX_MASKED != 0.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>RX</name>
              <description>Receiver interrupt active ('interrupt_rx'): INTR_RX_MASKED != 0.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>I2C_EC</name>
              <description>Externally clock I2C interrupt active ('interrupt_i2c_ec'): INTR_I2C_EC_MASKED != 0.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SPI_EC</name>
              <description>Externally clocked SPI interrupt active ('interrupt_spi_ec'): INTR_SPI_EC_MASKED != 0.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_I2C_EC</name>
          <description>Externally clocked I2C interrupt request register</description>
          <addressOffset>0xE80</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xF</resetMask>
          <fields>
            <field>
              <name>WAKE_UP</name>
              <description>Wake up request. Active on incoming slave request (with address match).

Only used when EC_AM is '1'.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EZ_STOP</name>
              <description>STOP detection. Activated on the end of a every transfer (I2C STOP).

Only available for a slave request with an address match, in EZ and CMD_RESP modes, when EC_OP is '1'.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EZ_WRITE_STOP</name>
              <description>STOP detection after a write transfer occurred. Activated on the end of a write transfer (I2C STOP). This event is an indication that a buffer memory location has been written to. For EZ mode: a  transfer that only writes the base address does NOT activate this event. 

Only available for a slave request with an address match, in EZ and CMD_RESP modes, when EC_OP is '1'.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EZ_READ_STOP</name>
              <description>STOP detection after a read transfer occurred. Activated on the end of a read transfer (I2C STOP). This event is an indication that a buffer memory location has been read from.

Only available for a slave request with an address match, in EZ and CMD_RESP modes, when EC_OP is '1'.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_I2C_EC_MASK</name>
          <description>Externally clocked I2C interrupt mask register</description>
          <addressOffset>0xE88</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xF</resetMask>
          <fields>
            <field>
              <name>WAKE_UP</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EZ_STOP</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EZ_WRITE_STOP</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EZ_READ_STOP</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_I2C_EC_MASKED</name>
          <description>Externally clocked I2C interrupt masked register</description>
          <addressOffset>0xE8C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xF</resetMask>
          <fields>
            <field>
              <name>WAKE_UP</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>EZ_STOP</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>EZ_WRITE_STOP</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>EZ_READ_STOP</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_SPI_EC</name>
          <description>Externally clocked SPI interrupt request register</description>
          <addressOffset>0xEC0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xF</resetMask>
          <fields>
            <field>
              <name>WAKE_UP</name>
              <description>Wake up request. Active on incoming slave request when externally clocked selection is '1'.

Only used when EC_AM is '1'.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EZ_STOP</name>
              <description>STOP detection. Activated on the end of a every transfer (SPI deselection).

Only available in EZ and CMD_RESP mode and when EC_OP is '1'.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EZ_WRITE_STOP</name>
              <description>STOP detection after a write transfer occurred. Activated on the end of a write transfer (SPI deselection). This event is an indication that a buffer memory location has been written to. For EZ mode: a  transfer that only writes the base address does NOT activate this event. 

Only used in EZ and CMD_RESP modes and when EC_OP is '1'.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EZ_READ_STOP</name>
              <description>STOP detection after a read transfer occurred. Activated on the end of a read transfer (SPI deselection). This event is an indication that a buffer memory location has been read from.

Only used in EZ and CMD_RESP modes and when EC_OP is '1'.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_SPI_EC_MASK</name>
          <description>Externally clocked SPI interrupt mask register</description>
          <addressOffset>0xEC8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xF</resetMask>
          <fields>
            <field>
              <name>WAKE_UP</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EZ_STOP</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EZ_WRITE_STOP</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EZ_READ_STOP</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_SPI_EC_MASKED</name>
          <description>Externally clocked SPI interrupt masked register</description>
          <addressOffset>0xECC</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xF</resetMask>
          <fields>
            <field>
              <name>WAKE_UP</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>EZ_STOP</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>EZ_WRITE_STOP</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>EZ_READ_STOP</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_M</name>
          <description>Master interrupt request register.</description>
          <addressOffset>0xF00</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x317</resetMask>
          <fields>
            <field>
              <name>I2C_ARB_LOST</name>
              <description>I2C master lost arbitration: the value driven by the master on the SDA line is not the same as the value observed on the SDA line.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_NACK</name>
              <description>I2C master negative acknowledgement. Set to '1', when the master receives a NACK (typically after the master transmitted the slave address or TX data).</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_ACK</name>
              <description>I2C master acknowledgement. Set to '1', when the master receives a ACK (typically after the master transmitted the slave address or TX data).</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_STOP</name>
              <description>I2C master STOP. Set to '1', when the master has transmitted a STOP.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_BUS_ERROR</name>
              <description>I2C master bus error (unexpected detection of START or STOP condition).</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SPI_DONE</name>
              <description>SPI master transfer done event: all data frames in the transmit FIFO are sent and the transmit FIFO and shift register are empty.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_M_SET</name>
          <description>Master interrupt set request register</description>
          <addressOffset>0xF04</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x317</resetMask>
          <fields>
            <field>
              <name>I2C_ARB_LOST</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_NACK</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_ACK</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_STOP</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_BUS_ERROR</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SPI_DONE</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_M_MASK</name>
          <description>Master interrupt mask register.</description>
          <addressOffset>0xF08</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x317</resetMask>
          <fields>
            <field>
              <name>I2C_ARB_LOST</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_NACK</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_ACK</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_STOP</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_BUS_ERROR</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SPI_DONE</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_M_MASKED</name>
          <description>Master interrupt masked request register</description>
          <addressOffset>0xF0C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x317</resetMask>
          <fields>
            <field>
              <name>I2C_ARB_LOST</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>I2C_NACK</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>I2C_ACK</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>I2C_STOP</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>I2C_BUS_ERROR</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SPI_DONE</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_S</name>
          <description>Slave interrupt request register.</description>
          <addressOffset>0xF40</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFF</resetMask>
          <fields>
            <field>
              <name>I2C_ARB_LOST</name>
              <description>I2C slave lost arbitration: the value driven on the SDA line is not the same as the value observed on the SDA line (while the SCL line is '1'). This should not occur, it represents erroneous I2C bus behavior. In case of lost arbitration, the I2C slave state machine abort the ongoing transfer. The Firmware may decide to clear the TX and RX FIFOs in case of this error.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_NACK</name>
              <description>I2C slave negative acknowledgement received. Set to '1', when the slave receives a NACK (typically after the slave transmitted TX data).</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_ACK</name>
              <description>I2C slave acknowledgement received. Set to '1', when the slave receives a ACK (typically after the slave transmitted TX data).</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_WRITE_STOP</name>
              <description>I2C STOP event for I2C write transfer intended for this slave (address matching is performed). Set to '1', when STOP or REPEATED START event is detected. The REPEATED START event is included in this interrupt cause such that the I2C transfers separated by a REPEATED START can be distinguished and potentially treated separately by the Firmware. Note that the second I2C transfer (after a REPEATED START) may be to a different slave address.

In non EZ mode, the event is detected on any I2C write transfer intended for this slave. Note that a I2C write address intended for the slave (address is matching and a it is a write transfer) will result in a I2C_WRITE_STOP event independent of whether the I2C address is ACK'd or NACK'd.

In EZ mode, the event is detected only on I2C write transfers that have EZ data written to the memory structure (an I2C write transfer that only communicates an I2C address and EZ address, will not result in this event being detected).</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_STOP</name>
              <description>I2C STOP event for I2C (read or write) transfer intended for this slave (address matching is performed). Set to '1', when STOP or REPEATED START event is detected. The REPEATED START event is included in this interrupt cause such that the I2C transfers separated by a REPEATED START can be distinguished and potentially treated separately by the Firmware. Note that the second I2C transfer (after a REPEATED START) may be to a different slave address.

The event is detected on any I2C transfer intended for this slave. Note that a I2C address intended for the slave (address is matching) will result in a I2C_STOP event independent of whether the I2C address is ACK'd or NACK'd.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_START</name>
              <description>I2C slave START received. Set to '1', when START or REPEATED START event is detected.

In the case of externally clocked address matching (CTRL.EC_AM_MODE is '1') AND clock stretching is performed (till the internally clocked logic takes over) (I2C_CTRL.S_NOT_READY_ADDR_NACK is '0'), this field is NOT set. The Firmware should use INTR_S_EC.WAKE_UP, INTR_S.I2C_ADDR_MATCH and INTR_S.I2C_GENERAL.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_ADDR_MATCH</name>
              <description>I2C slave matching address received. If CTRL.ADDR_ACCEPT, the received address (including the R/W bit) is available in the RX FIFO. In the case of externally clocked address matching (CTRL.EC_AM_MODE is '1') and internally clocked operation (CTRL.EC_OP_MODE is '0'), this field is set when the event is detected.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_GENERAL</name>
              <description>I2C slave general call address received.  If CTRL.ADDR_ACCEPT, the received address 0x00 (including the R/W bit) is available in the RX FIFO.   In the case of externally clocked address matching (CTRL.EC_AM_MODE is '1') and internally clocked operation (CTRL.EC_OP_MODE is '0'), this field is set when the event is detected.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_BUS_ERROR</name>
              <description>I2C slave bus error (unexpected detection of START or STOP condition). This should not occur, it represents erroneous I2C bus behavior. In case of a bus error, the I2C slave state machine abort the ongoing transfer. The Firmware may decide to clear the TX and RX FIFOs in case of this error.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SPI_EZ_WRITE_STOP</name>
              <description>SPI slave deselected after a write EZ SPI transfer occurred.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SPI_EZ_STOP</name>
              <description>SPI slave deselected after any EZ SPI transfer occurred.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SPI_BUS_ERROR</name>
              <description>SPI slave deselected at an unexpected time in the SPI transfer. The Firmware may decide to clear the TX and RX FIFOs in case of this error.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_S_SET</name>
          <description>Slave interrupt set request register.</description>
          <addressOffset>0xF44</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFF</resetMask>
          <fields>
            <field>
              <name>I2C_ARB_LOST</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_NACK</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_ACK</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_WRITE_STOP</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_STOP</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_START</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_ADDR_MATCH</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_GENERAL</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_BUS_ERROR</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SPI_EZ_WRITE_STOP</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SPI_EZ_STOP</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SPI_BUS_ERROR</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_S_MASK</name>
          <description>Slave interrupt mask register.</description>
          <addressOffset>0xF48</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFF</resetMask>
          <fields>
            <field>
              <name>I2C_ARB_LOST</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_NACK</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_ACK</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_WRITE_STOP</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_STOP</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_START</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_ADDR_MATCH</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_GENERAL</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_BUS_ERROR</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SPI_EZ_WRITE_STOP</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SPI_EZ_STOP</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SPI_BUS_ERROR</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_S_MASKED</name>
          <description>Slave interrupt masked request register</description>
          <addressOffset>0xF4C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFF</resetMask>
          <fields>
            <field>
              <name>I2C_ARB_LOST</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>I2C_NACK</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>I2C_ACK</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>I2C_WRITE_STOP</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>I2C_STOP</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>I2C_START</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>I2C_ADDR_MATCH</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>I2C_GENERAL</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>I2C_BUS_ERROR</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SPI_EZ_WRITE_STOP</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SPI_EZ_STOP</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SPI_BUS_ERROR</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_TX</name>
          <description>Transmitter interrupt request register.</description>
          <addressOffset>0xF80</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x7F3</resetMask>
          <fields>
            <field>
              <name>TRIGGER</name>
              <description>Less entries in the TX FIFO than the value specified by TX_FIFO_CTRL. 

Only used in FIFO mode.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>NOT_FULL</name>
              <description>TX FIFO is not full. Dependent on CTRL.BYTE_MODE: (FF_DATA_NR = EZ_DATA_NR/2)
BYTE_MODE is '0': # entries != FF_DATA_NR/2.
BYTE_MODE is '1': # entries != FF_DATA_NR.

Only used in FIFO mode.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EMPTY</name>
              <description>TX FIFO is empty; i.e. it has 0 entries.

Only used in FIFO mode.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OVERFLOW</name>
              <description>Attempt to write to a full TX FIFO.

Only used in FIFO mode.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UNDERFLOW</name>
              <description>Attempt to read from an empty TX FIFO. This happens when the IP is ready to transfer data and EMPTY is '1'.

Only used in FIFO mode.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BLOCKED</name>
              <description>AHB-Lite write transfer can not get access to the EZ memory (EZ data access), due to an externally clocked EZ access. This may happen when STATUS.EC_BUSY is '1'.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UART_NACK</name>
              <description>UART transmitter received a negative acknowledgement in SmartCard mode. Set to '1', when event is detected. Write with '1' to clear bit.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UART_DONE</name>
              <description>UART transmitter done event. This happens when the IP is done transferring all data in the TX FIFO; i.e. EMPTY is '1'. Set to '1', when event is detected. Write with '1' to clear bit.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UART_ARB_LOST</name>
              <description>UART lost arbitration: the value driven on the TX line is not the same as the value observed on the RX line. This condition event is usefull when transmitter and receiver share a TX/RX line. This is the case in LIN or SmartCard modes. Set to '1', when event is detected. Write with '1' to clear bit.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_TX_SET</name>
          <description>Transmitter interrupt set request register</description>
          <addressOffset>0xF84</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x7F3</resetMask>
          <fields>
            <field>
              <name>TRIGGER</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>NOT_FULL</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EMPTY</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OVERFLOW</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UNDERFLOW</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BLOCKED</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UART_NACK</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UART_DONE</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UART_ARB_LOST</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_TX_MASK</name>
          <description>Transmitter interrupt mask register.</description>
          <addressOffset>0xF88</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x7F3</resetMask>
          <fields>
            <field>
              <name>TRIGGER</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>NOT_FULL</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EMPTY</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OVERFLOW</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UNDERFLOW</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BLOCKED</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UART_NACK</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UART_DONE</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UART_ARB_LOST</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_TX_MASKED</name>
          <description>Transmitter interrupt masked request register</description>
          <addressOffset>0xF8C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x7F3</resetMask>
          <fields>
            <field>
              <name>TRIGGER</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>NOT_FULL</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>EMPTY</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>OVERFLOW</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>UNDERFLOW</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>BLOCKED</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>UART_NACK</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>UART_DONE</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>UART_ARB_LOST</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_RX</name>
          <description>Receiver interrupt request register.</description>
          <addressOffset>0xFC0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFED</resetMask>
          <fields>
            <field>
              <name>TRIGGER</name>
              <description>More entries in the RX FIFO than the value specified by TRIGGER_LEVEL in SCB_RX_FIFO_CTL.

Only used in FIFO mode.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>NOT_EMPTY</name>
              <description>RX FIFO is not empty.

Only used in FIFO mode.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FULL</name>
              <description>RX FIFO is full. Note that received data frames are lost when the RX FIFO is full. Dependent on CTRL.BYTE_MODE: (FF_DATA_NR = EZ_DATA_NR/2)
BYTE_MODE is '0': # entries == FF_DATA_NR/2.
BYTE_MODE is '1': # entries == FF_DATA_NR.

Only used in FIFO mode.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OVERFLOW</name>
              <description>Attempt to write to a full RX FIFO. Note: in I2C mode, the OVERFLOW is set when a data frame is received and the RX FIFO is full, independent of whether it is ACK'd or NACK'd.

Only used in FIFO mode.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UNDERFLOW</name>
              <description>Attempt to read from an empty RX FIFO.

Only used in FIFO mode.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BLOCKED</name>
              <description>AHB-Lite read transfer can not get access to the EZ memory (EZ_DATA accesses), due to an externally clocked EZ access. This may happen when STATUS.EC_BUSY is '1'.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FRAME_ERROR</name>
              <description>Frame error in received data frame. Set to '1', when event is detected. Write with '1' to clear bit. This can be either a start or stop bit(s) error:
Start bit error: after the detection of the beginning of a start bit period (RX line changes from '1' to '0'), the middle of the start bit period is sampled erroneously (RX line is '1').  Note: a start bit error is detected BEFORE a data frame is received.
Stop bit error: the RX line is sampled as '0', but a '1' was expected. Note: a stop bit error may result in failure to receive successive data frame(s). Note: a stop bit error is detected AFTER a data frame is received.

A stop bit error is detected after a data frame is received, and the UART_RX_CTL.DROP_ON_FRAME_ERROR field specifies whether the received frame is dropped or send to the RX FIFO. If UART_RX_CTL.DROP_ON_FRAME_ERROR is '1', the received data frame is dropped. If UART_RX_CTL.DROP_ON_FRAME_ERROR is '0', the received data frame is send to the RX FIFO. Note that Firmware can only identify the erroneous data frame in the RX FIFO if it is fast enough to read the data frame before the hardware writes a next data frame into the RX FIFO; i.e. the RX FIFO does not have error flags to tag erroneous data frames.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PARITY_ERROR</name>
              <description>Parity error in received data frame. Set to '1', when event is detected. Write with '1' to clear bit. If UART_RX_CTL.DROP_ON_PARITY_ERROR is '1', the received frame is dropped. If UART_RX_CTL.DROP_ON_PARITY_ERROR is '0', the received frame is send to the RX FIFO. In SmartCard submode, negatively acknowledged data frames generate a parity error. Note that Firmware can only identify the erroneous data frame in the RX FIFO if it is fast enough to read the data frame before the hardware writes a next data frame into the RX FIFO.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BAUD_DETECT</name>
              <description>LIN baudrate detection is completed.  The receiver software uses the UART_RX_STATUS.BR_COUNTER value to set the right IP clock (from the programmable clock IP) to guarantee successful receipt of the first LIN data frame (Protected Identifier Field) after the synchronization byte. Set to '1', when event is detected. Write with '1' to clear bit.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BREAK_DETECT</name>
              <description>Break detection is successful: the line is '0' for UART_RX_CTRL.BREAK_WIDTH + 1 bit period. Can occur at any time to address unanticipated break fields; i.e. 'break-in-data' is supported. This feature is supported for the UART standard and LIN submodes. For the UART standard submodes, ongoing receipt of data frames is NOT affected; i.e. Firmware is expected to take the proper action. For the LIN submode, possible ongoing receipt of a data frame is stopped and the (partially) received data frame is dropped and baud rate detection is started. Set to '1', when event is detected. Write with '1' to clear bit.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_RX_SET</name>
          <description>Receiver interrupt set request register.</description>
          <addressOffset>0xFC4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFED</resetMask>
          <fields>
            <field>
              <name>TRIGGER</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>NOT_EMPTY</name>
              <description>Write with '1' to set corresponding bit in interrupt status register.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FULL</name>
              <description>Write with '1' to set corresponding bit in interrupt status register.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OVERFLOW</name>
              <description>Write with '1' to set corresponding bit in interrupt status register.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UNDERFLOW</name>
              <description>Write with '1' to set corresponding bit in interrupt status register.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BLOCKED</name>
              <description>Write with '1' to set corresponding bit in interrupt status register.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FRAME_ERROR</name>
              <description>Write with '1' to set corresponding bit in interrupt status register.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PARITY_ERROR</name>
              <description>Write with '1' to set corresponding bit in interrupt status register.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BAUD_DETECT</name>
              <description>Write with '1' to set corresponding bit in interrupt status register.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BREAK_DETECT</name>
              <description>Write with '1' to set corresponding bit in interrupt status register.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_RX_MASK</name>
          <description>Receiver interrupt mask register.</description>
          <addressOffset>0xFC8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFED</resetMask>
          <fields>
            <field>
              <name>TRIGGER</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>NOT_EMPTY</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FULL</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OVERFLOW</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UNDERFLOW</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BLOCKED</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FRAME_ERROR</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PARITY_ERROR</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BAUD_DETECT</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BREAK_DETECT</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_RX_MASKED</name>
          <description>Receiver interrupt masked request register</description>
          <addressOffset>0xFCC</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFED</resetMask>
          <fields>
            <field>
              <name>TRIGGER</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>NOT_EMPTY</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>FULL</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>OVERFLOW</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>UNDERFLOW</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>BLOCKED</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>FRAME_ERROR</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>PARITY_ERROR</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>BAUD_DETECT</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>BREAK_DETECT</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral derivedFrom="SCB0">
      <name>SCB1</name>
      <baseAddress>0x40250000</baseAddress>
    </peripheral>
    <peripheral>
      <name>CSD0</name>
      <description>Capsense Controller</description>
      <headerStructName>CSD</headerStructName>
      <baseAddress>0x40280000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>65536</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>ID</name>
          <description>ID &amp; Revision Number</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x1E0E1</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ID</name>
              <description>the ID of CSD peripheral is 0xE0E1</description>
              <bitRange>[15:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>REVISION</name>
              <description>the version number is 0x0001</description>
              <bitRange>[31:16]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR</name>
          <description>CSD Interrupt Request Register</description>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1</resetMask>
          <fields>
            <field>
              <name>CSD</name>
              <description>The CSD IRQ bit is set.  Firmware must clear this bit as part of the interrupt handler.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_SET</name>
          <description>CSD Interrupt set register</description>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1</resetMask>
          <fields>
            <field>
              <name>CSD</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PWM</name>
          <description>CSD PWM Register</description>
          <addressOffset>0x1C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3F</resetMask>
          <fields>
            <field>
              <name>PWM_COUNT</name>
              <description>The length of the modulation pulse in clk_csd2 cycles.</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PWM_SEL</name>
              <description>The mode of the PWM modulator</description>
              <bitRange>[5:4]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>OFF</name>
                  <description>The PWM modulator is OFF and has no effect</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>FIXED_HIGH</name>
                  <description>The PWM modulator changes the low phase of csd_sense to a fixed length (used for negative charge transfer).</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>FIXED_LOW</name>
                  <description>The PWM modulator changes the high phase of csd_sense to a fixed length (used for positive charge transfer).</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>LCD</name>
      <description>LCD Controller Block</description>
      <baseAddress>0x402A0000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>65536</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>ID</name>
          <description>ID &amp; Revision</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x1F0F0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ID</name>
              <description>the ID of LCD controller peripheral is 0xF0F0</description>
              <bitRange>[15:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>REVISION</name>
              <description>the version number is 0x0001</description>
              <bitRange>[31:16]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DIVIDER</name>
          <description>LCD Divider Register</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SUBFR_DIV</name>
              <description>Input clock frequency divide value, to generate the 1/4 sub-frame period. The sub-frame period is  4*(SUBFR_DIV+1) cycles long.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DEAD_DIV</name>
              <description>Length of the dead time period in cycles.  When set to  zero, no dead time period exists.</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CONTROL</name>
          <description>LCD Configuration Register</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x80000F7F</resetMask>
          <fields>
            <field>
              <name>LS_EN</name>
              <description>Low speed (LS) generator enable
1: enable
0: disable</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HS_EN</name>
              <description>High speed (HS) generator enable
1: enable
0: disable</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LCD_MODE</name>
              <description>HS/LS Mode selection</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>LS</name>
                  <description>Select Low Speed (32kHz) Generator (Works in Active, Sleep and DeepSleep power modes).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HS</name>
                  <description>Select High Speed (system clock) Generator (Works in Active and Sleep power modes only).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TYPE</name>
              <description>LCD driving waveform type configuration.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>TYPE_A</name>
                  <description>Type A - Each frame addresses each COM pin only once with a balanced (DC=0) waveform.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>TYPE_B</name>
                  <description>Type B - Each frame addresses each COM pin twice in sequence with a positive and negative waveform that together are balanced (DC=0).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>OP_MODE</name>
              <description>Driving mode configuration</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>PWM</name>
                  <description>PWM Mode</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CORRELATION</name>
                  <description>Digital Correlation Mode</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BIAS</name>
              <description>PWM bias selection</description>
              <bitRange>[6:5]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>HALF</name>
                  <description>1/2 Bias</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>THIRD</name>
                  <description>1/3 Bias</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>FOURTH</name>
                  <description>1/4 Bias (not supported by LS generator)</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>FIFTH</name>
                  <description>1/5 Bias (not supported by LS generator)</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>COM_NUM</name>
              <description>The number of COM connections minus 2. So:
0: 2 COM's
1: 3 COM's
...
13: 15 COM's
14: 16 COM's
15: undefined</description>
              <bitRange>[11:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LS_EN_STAT</name>
              <description>LS enable status bit.  This bit is a copy of LS_EN that is synchronized to the low speed clock domain and back to the system clock domain. Firmware can use this bit to observe whether LS_EN has taken effect in the low speed clock domain.  Firmware should never change the configuration for the LS generator without ensuring this bit is 0.
The following procedure should be followed to disable the LS generator:
1. If LS_EN=0 we are done.  Exit the procedure.
2. Check that LS_EN_STAT=1.  If not, wait until it is. This will catch the case of a recent enable (LS_EN=1) that has not taken effect yet.
3. Set LS_EN=0.
4. Wait until LS_EN_STAT=0.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>8</dim>
          <dimIncrement>4</dimIncrement>
          <name>DATA0[%s]</name>
          <description>LCD Pin Data Registers</description>
          <addressOffset>0x100</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DATA</name>
              <description>Bits [4i+3:4i] represent the pin data for pin [i] for COMS 1-4 (COM1 is lsb).</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>8</dim>
          <dimIncrement>4</dimIncrement>
          <name>DATA1[%s]</name>
          <description>LCD Pin Data Registers</description>
          <addressOffset>0x200</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DATA</name>
              <description>Bits [4i+3:4i] represent the pin data for pin [i] for COMS 5-8 (COM5 is lsb).</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>8</dim>
          <dimIncrement>4</dimIncrement>
          <name>DATA2[%s]</name>
          <description>LCD Pin Data Registers</description>
          <addressOffset>0x300</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DATA</name>
              <description>Bits [4i+3:4i] represent the pin data for pin [i] for COMS 9-12 (COM9 is lsb).</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>8</dim>
          <dimIncrement>4</dimIncrement>
          <name>DATA3[%s]</name>
          <description>LCD Pin Data Registers</description>
          <addressOffset>0x400</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DATA</name>
              <description>Bits [4i+3:4i] represent the pin data for pin [i] for COMS 13-16 (COM13 is lsb).</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>LPCOMP</name>
      <description>Low Power Comparators</description>
      <baseAddress>0x402B0000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>65536</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>ID</name>
          <description>ID &amp; Revision</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x1E0E0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ID</name>
              <description>the ID of LPCOMP peripheral is 0xE0E0</description>
              <bitRange>[15:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>REVISION</name>
              <description>the version number is 0x0001</description>
              <bitRange>[31:16]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CONFIG</name>
          <description>LPCOMP Configuration Register</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x33FFFF</resetMask>
          <fields>
            <field>
              <name>MODE1</name>
              <description>Operating mode for the comparator</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SLOW</name>
                  <description>Slow operating mode (uses less power, &lt;50uA)</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>FAST</name>
                  <description>Fast operating mode (uses more power, &lt;400uA)</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ULP</name>
                  <description>Ultra low power operting mode (uses ~2-4uA)</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>HYST1</name>
              <description>Add 10mV hysteresis to the comparator
- 0: Enable Hysteresis
- 1: Disable Hysteresis</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FILTER1</name>
              <description>N/A</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INTTYPE1</name>
              <description>Sets which edge will trigger an IRQ</description>
              <bitRange>[5:4]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DISABLE</name>
                  <description>Disabled, no interrupts will be detected</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RISING</name>
                  <description>Rising edge</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>FALLING</name>
                  <description>Falling edge</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>BOTH</name>
                  <description>Both rising and falling edges</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>OUT1</name>
              <description>Current output value of the comparator.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>ENABLE1</name>
              <description>Enable comparator #1</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MODE2</name>
              <description>Operating mode for the comparator</description>
              <bitRange>[9:8]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SLOW</name>
                  <description>Slow operating mode (uses less power, &lt;50uA)</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>FAST</name>
                  <description>Fast operating mode (uses more power, &lt;400uA)</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ULP</name>
                  <description>Ultra low power operting mode (uses ~2-4uA)</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>HYST2</name>
              <description>Add 10mV hysteresis to the comparator
- 0: Enable Hysteresis
- 1: Disable Hysteresis</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FILTER2</name>
              <description>N/A</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INTTYPE2</name>
              <description>Sets which edge will trigger an IRQ</description>
              <bitRange>[13:12]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DISABLE</name>
                  <description>Disabled, no interrupts will be detected</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RISING</name>
                  <description>Rising edge</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>FALLING</name>
                  <description>Falling edge</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>BOTH</name>
                  <description>Both rising and falling edges</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>OUT2</name>
              <description>Current output value of the comparator.</description>
              <bitRange>[14:14]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>ENABLE2</name>
              <description>Enable comparator #2</description>
              <bitRange>[15:15]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DSI_BYPASS1</name>
              <description>Opamp1 bypass comparator output synchronization for DSI output: 0=synchronize (level or pulse), 1=bypass (output async)
Note that in DeepSleep mode this bit needs to be set to observe the DSI output on the dedicated pin.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DSI_LEVEL1</name>
              <description>Opamp1 comparator DSI (trigger) out level : 0=pulse, 1=level</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DSI_BYPASS2</name>
              <description>Opamp2 bypass comparator output synchronization for DSI output: 0=synchronize (level or pulse), 1=bypass (output async)
Note that in DeepSleep mode this bit needs to be set to observe the DSI output on the dedicated pin.</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DSI_LEVEL2</name>
              <description>Opamp2 comparator DSI (trigger) out level : 0=pulse, 1=level</description>
              <bitRange>[21:21]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR</name>
          <description>LPCOMP Interrupt request register</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3</resetMask>
          <fields>
            <field>
              <name>COMP1</name>
              <description>Comparator 1 Interrupt: hardware sets this interrupt when comparator 0 triggers. Write with '1' to clear bit.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>COMP2</name>
              <description>Comparator 2 Interrupt: hardware sets this interrupt when comparator 0 triggers. Write with '1' to clear bit.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_SET</name>
          <description>LPCOMP Interrupt set register</description>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3</resetMask>
          <fields>
            <field>
              <name>COMP1</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>COMP2</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_MASK</name>
          <description>LPCOMP Interrupt request mask</description>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3</resetMask>
          <fields>
            <field>
              <name>COMP1_MASK</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>COMP2_MASK</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_MASKED</name>
          <description>LPCOMP Interrupt request masked</description>
          <addressOffset>0x1C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3</resetMask>
          <fields>
            <field>
              <name>COMP1_MASKED</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>COMP2_MASKED</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TRIM1</name>
          <description>LPCOMP Trim Register</description>
          <addressOffset>0xFF00</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1F</resetMask>
          <fields>
            <field>
              <name>COMP1_TRIMA</name>
              <description>Trim A for Comparator #1</description>
              <bitRange>[4:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TRIM2</name>
          <description>LPCOMP Trim Register</description>
          <addressOffset>0xFF04</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1F</resetMask>
          <fields>
            <field>
              <name>COMP1_TRIMB</name>
              <description>Trim B for Comparator #1</description>
              <bitRange>[4:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TRIM3</name>
          <description>LPCOMP Trim Register</description>
          <addressOffset>0xFF08</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1F</resetMask>
          <fields>
            <field>
              <name>COMP2_TRIMA</name>
              <description>Trim A for Comparator #2</description>
              <bitRange>[4:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TRIM4</name>
          <description>LPCOMP Trim Register</description>
          <addressOffset>0xFF0C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1F</resetMask>
          <fields>
            <field>
              <name>COMP2_TRIMB</name>
              <description>Trim B for Comparator #2</description>
              <bitRange>[4:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>BLE</name>
      <description>Bluetooth Low Energy Subsystem</description>
      <baseAddress>0x402E0000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>65536</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <cluster>
          <name>BLERD</name>
          <description>#REF!</description>
          <addressOffset>0x00000000</addressOffset>
          <register>
            <name>CFG1</name>
            <description>Generic configure register.</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0xBA40</resetValue>
            <resetMask>0xFFFF</resetMask>
            <fields>
              <field>
                <name>RX_DATA_INVERSE</name>
                <description>Invert demodulation receiving data,high active</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TX_DATA_INVERSE</name>
                <description>invert modulation transmit data, high active</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>AGC_DISABLE</name>
                <description>1: disabel the AGC, the LNA+TIA and CBPF gain are given based on bits [15:11] of reg0.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RF_PLL_DIRECT</name>
                <description>program channel freqency as direct frequency mode. high active.
When RF_PLL_DIRECT = 1, RF = reg0x10[11:0] Mhz.
When RF_PLL_DIRECT = 0, RF = 2402 + 2*reg7[5:0] Mhz.</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CLKGATING_DISABLE</name>
                <description>1. disable the clock gating logic golbally. Indepenedent of any other cnditions. None of the clocks can be gated when this bit is set.
0: clock gating logic is enabled, the logic in clk_gen will determine which clocks are to be gated.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EN_BR_CLK</name>
                <description>1: enable brclk output</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ADC_IQ_INVERSE</name>
                <description>1: swap ADC I, Q path</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TX_PA_RAMP_MODE</name>
                <description>1:ramp to PA gain which given txpa_gain in 2dB steps, starting from min gain.
0: ramp to PA gin which given in txpa_gain in one short from min gain</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RADIO_STANDALONE</name>
                <description>1: radio standalone without link layer controller in SoC, Tx command from reg0x10[13] and RX command from reg0x10[12]</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ADC_DC_CAPTURE_EN</name>
                <description>1: ADC DC capture enable</description>
                <bitRange>[9:9]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>BURNIN_CLK_EN</name>
                <description>burn in function mode 
1: digital main clock from clk_core. 
0: digital main clock from HardIP</description>
                <bitRange>[10:10]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CBPF_GAIN</name>
                <description>CBPF manually gain setting when AGC is disabled by asserting bit[2]. This gain is truly reflective of the voltage gain across the CBPF and is determined by the ratio of resisters
11: 15dB, 10: 12dB, 01: 3dB, 00: 0dB</description>
                <bitRange>[12:11]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>LNA_GAIN</name>
                <description>LNA+TIA manual gain setting when AGC is disabled by asserting bit[2]. The gain obtained is a function of the LNA gm as well as the TIA feedback resister.
000: VLG
001: LG
010: MH 
011: IHG
100: HG
101: VHG
110, 111: Illegal Value</description>
                <bitRange>[15:13]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CFG2</name>
            <description>Generic configure register.</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x200</resetValue>
            <resetMask>0xFFFF</resetMask>
            <fields>
              <field>
                <name>DAC_REG_DATA</name>
                <description>DAC input from this register when CFG2_DAC_DFT_EN =1 and dft_mode = 2'b00</description>
                <bitRange>[9:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DAC_DFT_MODE</name>
                <description>DAC DFT mode definition
00: DAC input from dac_reg_data[9:0]
01: DAC input as 12Mhz increased value
10: DAC input as 1MHz Sine Wave
11: DAC input as 4MHz SIN wave</description>
                <bitRange>[11:10]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DAC_DFT_EN</name>
                <description>1: DAC DFT mode enable</description>
                <bitRange>[12:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ADC_DFT_MODE</name>
                <description>ADC DFT mode selection (Available on Atlantis TC only)
00: 3 sample I path data to read_i_adc_1. 3 sample Q path data to read_q_adc_2.
10: discard LSB both I and Q path data. 2 bytes I and Q path data to read_iq_adc with 6MHz updat
11: discard LSB both I and Q path data. 2 bytes I and Q path data to read_iq_adc with 3MHz updat</description>
                <bitRange>[14:13]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ADC_DFT_EN</name>
                <description>1: ADC DFT enable</description>
                <bitRange>[15:15]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MODEM</name>
            <description>modem configuration</description>
            <addressOffset>0x8</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x1068</resetValue>
            <resetMask>0xFFFF</resetMask>
            <fields>
              <field>
                <name>NARROW_SPD</name>
                <description>set alpha value for dC offset tracking speed in narrow mode
00: dc value times 1
01: dc value times 2
10: dc value times 3
11: dc value times 4</description>
                <bitRange>[1:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>WIDE_SPD</name>
                <description>demodulation alpha value for DC offset tracking in wide speed
00: dc value times 8
01: dc value times 10
10: dc value times 12
11: dc value times 14</description>
                <bitRange>[3:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RST_CNT2_SEL</name>
                <description>soft reset condition selection, 0: 32bits all ''0'/'1', 1: 16bits all '0'/'1'</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RESET2_EN</name>
                <description>demodulation soft reset enable, 0: diable, 1: enable soft reset</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DC_PARAM</name>
                <description>demodulation frequency deviation selection
00: 320K, 01: 350K, 10: 400K, 11:430K</description>
                <bitRange>[7:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>IMREJ_BYPASS</name>
                <description>bypass image filter in demoulation</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ADC_FULL_SWING_DETECT_EN</name>
                <description>1: select new AGC methodology with ADC full swing detection</description>
                <bitRange>[9:9]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DC_SCALING_EN</name>
                <description>1: DC scaling is enabled in the Demodulator. The Scaling happens when CBPF gain changes.</description>
                <bitRange>[10:10]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ADC_PWR_EST_EN</name>
                <description>1: power estimation for ADC output is enabled.</description>
                <bitRange>[11:11]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>LOAD_PREV_GAIN_EN</name>
                <description>1: load previous RX packet gain setting at first gain change step
0: not load previous RX packet gain.</description>
                <bitRange>[12:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>READ_DC_OFFSET_SEL</name>
                <description>1: read back of analog DC CAL result.
0: read back of DC capture in digital</description>
                <bitRange>[13:13]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ADCDFT_SEL</name>
                <description>1: ADC DFT capture data after image filter
0: ADC DFT capture data before image filter</description>
                <bitRange>[14:14]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CW_MODE</name>
                <description>1: modulation continue wave output</description>
                <bitRange>[15:15]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>FSM</name>
            <description>RFCTRL state information</description>
            <addressOffset>0xC</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0xC010</resetValue>
            <resetMask>0xFFFF</resetMask>
            <fields>
              <field>
                <name>XO_AMP_DETECT</name>
                <description>1: XO is oscillating reached 60 percent ampitude. 
0: XO is no oscillating or not reached 60 percent ampitude. BLERD_BB_XO[1] determines fast or normal charge. From MXIE(BLERF designer) confimation, XO within 50ppm needs 2 times of XO detection
BLERD_BB_XO[1]     XO_amp_detect      XO stable
           1                         320us                  640us
           0                        1120us                 2.24ms</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>LSLDO_OK</name>
                <description>1: LS LDO powered up</description>
                <bitRange>[1:1]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>LFLDO_OK</name>
                <description>1: LF LDO powered up</description>
                <bitRange>[2:2]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>FCAL_PASS_DETECT</name>
                <description>TX balun power detector, 
1: Frequency calibration has passed.
0: Frequency calibration has failed</description>
                <bitRange>[3:3]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>ISO_ENABLE</name>
                <description>monitor isolation cell enable signal
1: isolation cell enabled.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>RX_STATE</name>
                <description>RFCTRL RX state
000: RX Off
001: RX Regulator Powerup
010: RX Baseband and IF Powerup
011: DC Calibration
100: RX Wait for PLL settling
101: RX ADC DC value capture
110: RX Receive ON
111: non existing RX FSM</description>
                <bitRange>[7:5]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>TX_STATE</name>
                <description>RFCTRL TX state
000: TX Off
001: TX Regulator Powerup
010: TX Baseband Powerup
011: KV Calibration
100: TX PLL Settling
101: TX Ready
110, 111: non existing TX FSM</description>
                <bitRange>[10:8]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>SY_STATE</name>
                <description>RFCTRL SYNTH state
000: SY off,    
001: SY Regulator power up, 
010: SY VCO pup up
011: SY LO path power up, 
100: Frequency calibration, 
101: PLL setting. 
110: PLL locked
111: non existing SY FSM</description>
                <bitRange>[13:11]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>STATE</name>
                <description>RFCTRL major state, 
00: sleep mode, 
11: idle mode, 
10: TX mode, 
01: RX mode</description>
                <bitRange>[15:14]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DBUS</name>
            <description>RFCTRL mode transition control</description>
            <addressOffset>0x10</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x4992</resetValue>
            <resetMask>0xFFFF</resetMask>
            <fields>
              <field>
                <name>RF_FREQ</name>
                <description>When CFG1_RF_PLL_DIRECT=1, RF frequency is direct program from DBUS register [11:0]</description>
                <bitRange>[11:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DIRECT_RXEN</name>
                <description>When cfg1_radio_standalone =1, debus_direct_rxen replace dbus_rx_en</description>
                <bitRange>[12:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DIRECT_TXEN</name>
                <description>When cfg1_radio_standalone =1, debus_direct_rxen replace dbus_rx_en</description>
                <bitRange>[13:13]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ISOLATE_N</name>
                <description>force isolation cell enable of analog / digital boundary. low active</description>
                <bitRange>[14:14]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>XTAL_ENABLE</name>
                <description>crystal enable. High active</description>
                <bitRange>[15:15]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CFGCTRL</name>
            <description>RFCTRL running configuration</description>
            <addressOffset>0x14</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x18</resetValue>
            <resetMask>0x8FFF</resetMask>
            <fields>
              <field>
                <name>DSM_MODE</name>
                <description>Cfgctrl_dsm_mode[4]: 
1'b0: Third order PLL is used in TX mode, this is not effective in RX mode
1'b1: First order PLL is used in TX mode, this is not effective in RX mode

Cfgctrl_dsm_mode[3:2]
The following bits determine the DSM mode in TX
00: Input dither but no initial condition for DSM
01: Input dither and initial condition to DSM.
10: No input dither and initial condition
11: No input dither but initial condition is given

Cfgctrl_dsm_mode[1:0]
The following bits determine the DSM mode in RX
00: Input dither but no initial condition for DSM
01: Input dither and initial condition to DSM.
10: No input dither and initial condition
11: No input dither but initial condition is given</description>
                <bitRange>[4:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>IGNORE_FRAC</name>
                <description>0: Do not ignore fractional part in DSM (Frac-N PLL).
1: Ignore the fractional part in DSM (Int-N PLL).</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DCCAL_RERUN</name>
                <description>1: DC CAL is forced to run  when cfgctrl_testmode_en = 1</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DCCAL_MODE</name>
                <description>0: RX DC offset calibration in run normal mode
1: RX DC offset calibration is run in slow mode. Here each step in calibration is given double time compared to the normal mode</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RCCAL_RERUN</name>
                <description>1: RC-cal force to rerun when cfgctrl_testmode_en = 1</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RCCAL_MODE</name>
                <description>0: normal mode
1: slow mode, The timer for each setp in calibration is doubled with normal mode</description>
                <bitRange>[9:9]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>KVCAL_RERUN</name>
                <description>1: FCAL will be force rerun when cfgctrl_testmode_en = 1</description>
                <bitRange>[10:10]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>FCAL_RERUN</name>
                <description>1: KVCAL will be force rerun when cfgctrl_testmode_en = 1</description>
                <bitRange>[11:11]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TESTMODE_EN</name>
                <description>1: enables the test mode feature of RFCTRL</description>
                <bitRange>[15:15]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>RSSI</name>
            <description>RX envelpe detector and RSSI value</description>
            <addressOffset>0x18</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x7F7F</resetMask>
            <fields>
              <field>
                <name>PREFILT</name>
                <description>RSSI value before the filter in thd digital, 0 represents -85dBm</description>
                <bitRange>[6:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>POSTFILT</name>
                <description>RSSI value after the filter in digital, 0 represents -85dBm</description>
                <bitRange>[14:8]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>RMAP</name>
            <description>BG LDO bypass mode</description>
            <addressOffset>0x24</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFF</resetMask>
            <fields>
              <field>
                <name>BB_BYPASS</name>
                <description>N/A</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>KVCAL</name>
            <description>KVCAL running configuration</description>
            <addressOffset>0x28</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x640</resetValue>
            <resetMask>0xFFF</resetMask>
            <fields>
              <field>
                <name>DAC_STEP</name>
                <description>This values tells by what value should the DAC be offset from the mid-code, when the KVCAL is running.
00 : 512 (1MHz deviation).
01: 376  (0.75 Mhz deviation).
10: 256 (0.5 Mhz deviation)
11 : 128 (0.25 Mhz deviation</description>
                <bitRange>[1:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RUN_DURATION</name>
                <description>This values tells by what value duration when FCAL is running.
00 : 25us.
01: 33.375us
10: 50us
11 : 100us</description>
                <bitRange>[3:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EXP_FREQ_DIFF</name>
                <description>This expected difference in KVCAL configuration counts(100 counts for an ideal modulalation path gain)</description>
                <bitRange>[11:4]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CFG_1_FCAL</name>
            <description>FCAL running configure 5_6</description>
            <addressOffset>0x2C</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x387</resetValue>
            <resetMask>0x3FFF</resetMask>
            <fields>
              <field>
                <name>COARSE_FRAMES_6</name>
                <description>numbere of frames to run for the calibration 6th coarse bit</description>
                <bitRange>[6:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>COARSE_FRAMES_7</name>
                <description>numbere of frames to run for the calibration 7th coarse bit</description>
                <bitRange>[13:7]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CFG_2_FCAL</name>
            <description>FCAL running configure 7_2</description>
            <addressOffset>0x30</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x387</resetValue>
            <resetMask>0x3FFF</resetMask>
            <fields>
              <field>
                <name>COARSE_FRAMES_4</name>
                <description>numbere of frames to run for the calibration 4th coarse bit</description>
                <bitRange>[6:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>COARSE_FRAMES_5</name>
                <description>numbere of frames to run for the calibration 5th coarse bit</description>
                <bitRange>[13:7]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CFG_3_FCAL</name>
            <description>FCAL running configure 3_4</description>
            <addressOffset>0x34</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x387</resetValue>
            <resetMask>0x3FFF</resetMask>
            <fields>
              <field>
                <name>COARSE_FRAMES_2</name>
                <description>numbere of frames to run for the calibration 2nd coarse bit</description>
                <bitRange>[6:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>COARSE_FRAMES_3</name>
                <description>numbere of frames to run for the calibration 3rd coarse bit</description>
                <bitRange>[13:7]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CFG_4_FCAL</name>
            <description>FCAL running configure 0_1</description>
            <addressOffset>0x38</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x387</resetValue>
            <resetMask>0x3FFF</resetMask>
            <fields>
              <field>
                <name>COARSE_FRAMES_0</name>
                <description>numbere of frames to run for the calibration 0th coarse bit</description>
                <bitRange>[6:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>COARSE_FRAMES_1</name>
                <description>numbere of frames to run for the calibration 1st coarse bit</description>
                <bitRange>[13:7]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CFG_5_FCAL</name>
            <description>FCAL running framer fine</description>
            <addressOffset>0x3C</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x78E</resetValue>
            <resetMask>0x7FF</resetMask>
            <fields>
              <field>
                <name>FINE_FRAMES</name>
                <description>numbere of frames to run for all the calibration of all the Fine bits</description>
                <bitRange>[6:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CNT_SEL</name>
                <description>select which count should be reflected in the FCAL_DBG_2 and FCAL_DBG_3 registers
4'd1: FCAL 7th Coarse bit calibration
4'd2: FCAL 6th Coarse bit calibration
4'd3: FCAL 5th Coarse bit calibration
4'd4: FCAL 4th Coarse bit calibration
4'd5: FCAL 3rd Coarse bit calibration
4'd6: FCAL 2nd Coarse bit calibration
4'd7: FCAL 1st Coarse bit calibration
4'd8: FCAL 0th Coarse bit calibration
4'd9: FCAL 3rd Fine bit calibration
4'd10: FCAL 2nd Fine bit calibration
4'd11: FCAL 1st Fine bit calibration
4'd12: FCAL 0th Fine bit calibration
4'd13: VCO Open loop count
4'd14: KVCAL Observed Count
4'd15: KVCAL Gain
Default: Gives zero output</description>
                <bitRange>[10:7]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CFG_6_FCAL</name>
            <description>FCAL running VCO OL</description>
            <addressOffset>0x40</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x200</resetValue>
            <resetMask>0x7FFF</resetMask>
            <fields>
              <field>
                <name>FRAMES_VCO_OL</name>
                <description>Number of frames to run  in VCO openloop Characterization .
If bit[12] 'fcal_drift_check_en' is asserted, then this field indicates for how many frames the FCAL drift has to be measured</description>
                <bitRange>[10:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VCO_OL_ENBL</name>
                <description>1:enable vco openloop characterization</description>
                <bitRange>[11:11]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DRIFT_CHECK_EN</name>
                <description>enables the FCAL drift check, This needs to be set prior to the TX burst being programmed as it affects the timing sequence.
Ensure that FB buffer has not been powered down such that the FCAL counter is left alive. This requires a cahgne to reg0xcc[5] to be set to 0 (disable FB buffer power save). This needs to be set piror to placing the part in TX mode</description>
                <bitRange>[12:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DRIFT_CHECK</name>
                <description>00: start drift check when the TX driver is powered up
01: start drift check measurement 100us after TX driver is power ed up
10: start drift check measurement 200us after the TX driver is powered up
11: start drift check measurement 300us after the TX drive is powered up</description>
                <bitRange>[14:13]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>FCAL_TEST</name>
            <description>FCAL test mode configuration</description>
            <addressOffset>0x44</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x7FFF</resetMask>
            <fields>
              <field>
                <name>FINE</name>
                <description>force fine bits output of the FCAL engine when test_mode is set</description>
                <bitRange>[3:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>COARSE</name>
                <description>force coarse bits output of the FCAL engine when test_mode is set</description>
                <bitRange>[11:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>MODE</name>
                <description>force the coarse and fine bits of FCAL output enable, high active</description>
                <bitRange>[12:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CNT_POLARITY</name>
                <description>1: Inverts the polarity of the FCAL counter output coming in to the RFCTRL</description>
                <bitRange>[13:13]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>LOOP_POLARITY</name>
                <description>1: Inverts the polarity of the FCAL loop. In this mode the DCAP code is decreased if observed count is greater than target count.
0: This is normal FCAL loop, where DCAP code is increased if the observed count is greater than target_count</description>
                <bitRange>[14:14]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>TEST</name>
            <description>RCCAL and procmon test configuration</description>
            <addressOffset>0x48</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x7FFF</resetMask>
            <fields>
              <field>
                <name>KVCAL_GAIN</name>
                <description>this code is forced as the KV_CAL code when  when test_kvcal_mode = 1</description>
                <bitRange>[6:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>KVCAL_MODE</name>
                <description>1: KV-CAL code is forced to the given code</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>FRCCAL_CODE</name>
                <description>this code is forced as the RC_CAL code when test_frccal_mode = 1</description>
                <bitRange>[12:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>FRCCAL_MODE</name>
                <description>1: RC-CAL code is forced to the given code</description>
                <bitRange>[13:13]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>FRCCAL_POLARITY</name>
                <description>1: invert RC CAL polarity.</description>
                <bitRange>[14:14]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>FPD_TEST</name>
            <description>LDOs test</description>
            <addressOffset>0x4C</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x3F9D</resetMask>
            <fields>
              <field>
                <name>BB_FPUP_XO_BUF_ALL</name>
                <description>1: forcefully powers down all the buffers in XO if cfgctrl_testmode_en = 1</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>BB_XO_BUF_ADC</name>
                <description>1: forcefully powers down xo buffer to ADC if cfgctrl_testmode_en = 1</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>BB_XO_BUF_SY</name>
                <description>1: forcefully powers down xo buffer to synth if cfgctrl_testmode_en = 1</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>BB_RCCAL_BLOCK</name>
                <description>1: forcefully powers down the RC CAL block if cfgctrl_testmode_en = 1</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>FAST_CHARGE</name>
                <description>1: force power the fast charge bit for LDO Lopath if cfgctrl_testmode_en = 1</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SY_LDOVCO</name>
                <description>1: force power down SY LDOVCO if cfgctrl_testmode_en = 1</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SY_LDOLOPATH</name>
                <description>1: force power down SY LDO LOPATH  if cfgctrl_testmode_en = 1</description>
                <bitRange>[9:9]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SY_LDOFFFB</name>
                <description>1: force power down SY LDO LOFFFB if cfgctrl_testmode_en = 1</description>
                <bitRange>[10:10]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>BALUN_HFLDO</name>
                <description>1: Balun HF LDO is forced power down if cfgctrl_testmode_en = 1</description>
                <bitRange>[11:11]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>BALUN_CTUNE</name>
                <description>1: force powerdown Balun Ctune block if cfgctrl_testmode_en = 1</description>
                <bitRange>[12:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>FPUP_ALL</name>
                <description>1: This is used to force powerup the blocks controlled by this register. Fpd has higher precedence over force_powerup if cfgctrl_testmode_en = 1</description>
                <bitRange>[13:13]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SY</name>
            <description>SY test configuration 1</description>
            <addressOffset>0x50</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFF7</resetMask>
            <fields>
              <field>
                <name>TEST_FPD_IBIAS</name>
                <description>SY IBIAS block is forced powered down, if this bit is set and cfgctrl_testmode_en = 1</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TEST_FPD_VCO</name>
                <description>SY VCO block is forced powered down, if this bit is set and RF_TST_EN = 1</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TEST_FPD_DIV2</name>
                <description>SY high speed divider block is forced powered down, if this bit is set and cfgctrl_testmode_en = 1</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TEST_FPD_LOPATHDIVN</name>
                <description>SY LOpath DIVN buffer is forced powered down, if this bit is set and cfgctrl_testmode_en = 1</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TEST_FPD_DIV2_BUF</name>
                <description>SY LOpath FCAL buffer is forced powered down, if this bit is set and cfgctrl_testmode_en = 1</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TEST_FPD_DIVN</name>
                <description>SY DIVN block is forced powered down, if this bit is set and cfgctrl_testmode_en = 1</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TEST_FPD_FCAL</name>
                <description>SY FCAL counter is forced powered down, if this bit is set and cfgctrl_testmode_en = 1</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TEST_FPD_CPLPF</name>
                <description>SY CP and LPF are forced powered down, if this bit is set and cfgctrl_testmode_en = 1</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TEST_FPD_LOPATHTX</name>
                <description>SY LOpath TX buffer is forced powered down, if this bit is set and cfgctrl_testmode_en = 1</description>
                <bitRange>[9:9]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TEST_FPD_DIV2_DRV</name>
                <description>the TX powersave bit si force to zero if this bit is asserted and and cfgctrl_testmode_en = 1</description>
                <bitRange>[10:10]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TEST_FPD_TX_POWERSAVE</name>
                <description>The fcal amp is forced powered down, if this bit is asserted and cfgctrl_testmode_en = 1</description>
                <bitRange>[11:11]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TEST_FPD_FCAL_AMP</name>
                <description>The fcal amp is forced powered down, if this bit is asserted and cfgctrl_testmode_en = 1</description>
                <bitRange>[12:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TEST_FPD_OPENLOOP</name>
                <description>The loop_freeze is forced low if this bit is asserted and cfgctrl_testmode_en = 1</description>
                <bitRange>[13:13]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TEST_FPD_LOOP_FREEZE</name>
                <description>1: loop freeze is forced low if cfgctrl_testmode_en = 1</description>
                <bitRange>[14:14]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TEST_FPUP_ALL</name>
                <description>1: all the blocks in SY are forced power up if cfgctrl_testmode_en = 1</description>
                <bitRange>[15:15]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>TEST2_SY</name>
            <description>SY test configuration 2</description>
            <addressOffset>0x54</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFEF</resetMask>
            <fields>
              <field>
                <name>ICP_CODE</name>
                <description>ICP code will be programmed with these bits.</description>
                <bitRange>[3:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>FPD_DSM_RUN</name>
                <description>DSM run signal is de-asserted if this bit si set and rfctrl_testmode_en = 1</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>FORCE_DSM_RUN</name>
                <description>DSM_run signal is asserted if this bit is set and rfctrl_testmode_en = 1</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>FORCE_DSM_FRAC</name>
                <description>1: Force the MSB 8bit of the DSM fractional part with Reg[15-8]. The LSB bits should be 0.
0: DSM fractional bits will be driven by Timing Engine</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DSM_FRAC</name>
                <description>fore bits for  DSM fractional bits if test2_sy_force_dsm_frac=1</description>
                <bitRange>[15:8]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>TX</name>
            <description>transmit test configuration</description>
            <addressOffset>0x58</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1FF</resetMask>
            <fields>
              <field>
                <name>TEST_FPD_IBIAS</name>
                <description>1: forced power down TX ibias if rfctrl_testmode_en = 1</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TEST_FPD_DAC</name>
                <description>1: forced power down TX DAC if rfctrl_testmode_en = 1</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TEST_FPD_LPF</name>
                <description>1: forced power down TX LPF if rfctrl_testmode_en = 1</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TEST_FPD_DRIVER</name>
                <description>1: forced power down TX driver if rfctrl_testmode_en = 1</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TEST_FPD_PREDRIVER</name>
                <description>1: forced power down TX pre-drive if rfctrl_testmode_en = 1</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TEST_FPD_FN_TXEN</name>
                <description>the modulator control signal f_n_txen is deasswerted, if this bit is set and rfctrl_testmode_en = 1</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TEST_FPD_KVM_NFDEV</name>
                <description>modulator will not enable negative 1Mhz frequency deviation mode, if this bit is set and rfctrl_testmdoe_en = 1</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TEST_FPD_KVM_PFDEV</name>
                <description>modulator will not enable positive 1Mhz frequency deviation mode, if this bit is set and rfctrl_testmdoe_en = 1</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TEST_FPUP_TX_ALL</name>
                <description>force powerup all the TX blocks if rfctrl_testmode_en = 1</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>RX</name>
            <description>RX test configuration</description>
            <addressOffset>0x5C</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1FFF</resetMask>
            <fields>
              <field>
                <name>TEST_FPD_IBIAS</name>
                <description>1:force power down RX IBIAS block if this bit is set and rfctrl_testmode_en = 1</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TEST_FPD_ADC_ICORE</name>
                <description>1:force power down RX ADC I Core block is force powerdown if this bit is set and rfctrl_testmode_en = 1</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TEST_FPD_ADC_IREFGEN</name>
                <description>1:force power donw RX ADC IREF generation lock,if this bit is set and rfctrl_testmode_en = 1</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TEST_FPD_ADC_QCORE</name>
                <description>1:force power down RX ADC Q Core block is force powerdown if this bit is set and rfctrl_testmode_en = 1</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TEST_FPD_ADC_QREFGEN</name>
                <description>1:force power donw RX ADC QREF generation lock,if this bit is set and rfctrl_testmode_en = 1</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TEST_FPD_BPF</name>
                <description>1:force power down RX BPF, if this bit is set and rfctrl_testmode_en = 1</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TEST_FPD_TIA</name>
                <description>1:force power down RX TIA if this bit is set and rfctrl_testmode_en = 1</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TEST_FPD_MIXER_LO</name>
                <description>1:force power down RX MIXER LO block if this bit is set and rfctrl_testmode_en = 1</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TEST_FPD_MIXER_RF</name>
                <description>1: force power down RX MIXER RF block if rfctrl_testmode_en = 1.</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TEST_FPD_LNA</name>
                <description>1: force power down RX LNA if this bit is set and rfctrl_testmode_en = 1</description>
                <bitRange>[9:9]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TEST_FPD_LNA_HIZ</name>
                <description>1:LNA HIZ signal is deasserted, if this bit is set and rfctrl_testmode_en = 1</description>
                <bitRange>[10:10]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TEST_FPD_FN_RXEN</name>
                <description>1:the demodulator control signal f_n_rxen is deasserted if this bit is set and rfctrl_tesmode_en=1</description>
                <bitRange>[11:11]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TEST_FPUP_RX_ALL</name>
                <description>1:force powerup all RX blocks,if this bit is set and rfctrl_testmode_en = 1</description>
                <bitRange>[12:12]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DIAG1</name>
            <description>RF diagnostics configuration 1</description>
            <addressOffset>0x60</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x1</resetValue>
            <resetMask>0x3FF</resetMask>
            <fields>
              <field>
                <name>DISABLE</name>
                <description>1: diagnaositcs for all blocks are disabled
0: diagnostics are enabled at global level. The diagnostics for each block is controlled by a corresponding block level diag_enable signal</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CODE</name>
                <description>global diagnositic code, this is given to all the blocks. The block wihich has the diagnostics enabled will decode this code</description>
                <bitRange>[4:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SEL</name>
                <description>N/A</description>
                <bitRange>[9:5]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>IM</name>
            <description>inject monitor configuration</description>
            <addressOffset>0x64</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x21</resetValue>
            <resetMask>0xFFFF</resetMask>
            <fields>
              <field>
                <name>DIAG_MON_DISABLE</name>
                <description>1:globally disable the monitor</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DIAG_MONI_CODE</name>
                <description>monitor code, this determines from lock how the monitor is being driven:
Code     moni_p                    moni_n
4'd 1      dac_outp                  gnd
4'd 2      lpf_out                      gnd
4'd 4      I  TIA out_p                I  TIA out_n
4'd 5     Q TIA out_p               Q TIA out_n
4'd 6      I  CBPF out_p            I  CBPF out_n
4'd 7     Q CBPF out_p           Q CBPF out_n
4'd 8      I  CBPF out_p            Q CBPF out_n
4'd 9     Q CBPF out_p            I  CBPF out_n
4'd0, 4'd3, 4'd10, 4'd11, 4'd12, 4'd13, 4'd14, 4'd15: unused</description>
                <bitRange>[4:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DIAG_INJ_DISABLE</name>
                <description>1:globally disable the injection</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DIAG_INJ_CODE</name>
                <description>injection code. This determines for which block the injection enabled
Code:       inj_p                    inj_n
4'h1:        vin_lpf                 unused
4'd 4         I TIA in_p            I TIA in_n
4'd 5        Q TIA in_p          Q TIA in_n
4'd 6         I TIA in_p           Q TIA in_n
4'd 7         Q TIA in_p          I TIA in_n
4'd 8         I ADC in_p          I ADC in_n
4'd 9        Q ADC in_p        Q ADC in_n
4'h0, 4'd2, 4'd2, 4'd10, 4'd11, 4'd12, 4'd13, 4'd14, 4'd15 are unused</description>
                <bitRange>[9:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DIAG_LOOPBACK</name>
                <description>1: This will be used to monitor various outputs in the chip and inject them to on-chip ADC
0: no monitor to injection loopback</description>
                <bitRange>[10:10]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DIAG_BUMP</name>
                <description>diag bump code
im_diag_bump[3:2]
2'b00: Mon OTA ref. voltage is 0.9V
2'b01: Mon OTA ref: vlotage is 1.0V
2'b10: Mon OTA ref: vlotage is 1.1V
2'b11: Mon OTA ref: vlotage is 0.8V
im_diag_bump[1:0]
2'b00: Inj OTA ref. voltage is 0.9V
2'b01: Inj OTA ref: vlotage is 1.0V
2'b10: Inj OTA ref: vlotage is 1.1V
2'b11: Inj OTA ref: vlotage is 0.8V</description>
                <bitRange>[14:11]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DIAG_RESV</name>
                <description>N/A</description>
                <bitRange>[15:15]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>LDO_BYPASS</name>
            <description>LDOs bypass configuration</description>
            <addressOffset>0x68</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFF</resetMask>
            <fields>
              <field>
                <name>SYLDOVCO</name>
                <description>1: Synth LDO_VCO is bypassed. It should not be enable if line voltage is more than 2.1V. This bit should not toggle in scan mode</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SYLDOLOPATH</name>
                <description>1: Synth LDO_LOPATH  is bypassed. It should not be enable if line voltage is more than 2.1V. This bit should not toggle in scan mode</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SYLDOFFFB</name>
                <description>1: Synth LDO_FFFB is bypassed. It should not be enable if line voltage is more than 2.1V. This bit should not toggle in scan mode</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>HFLDO</name>
                <description>1: BB SY HF LDO is bypassed. It should not be enable if line voltage is more than 2.1V. This bit should not toggle in scan mode</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RESV_LDOBP</name>
                <description>N/A</description>
                <bitRange>[15:4]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>LDO</name>
            <description>bump bit for LDOs Atlantis</description>
            <addressOffset>0x6C</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFF</resetMask>
            <fields>
              <field>
                <name>BUMP_BALUM_HF</name>
                <description>3'd0: HF LDO output is 1.800V
3'd1: HF LDO output is 1.846V
3'd2: HF LDO output is 1.894V
3'd3: HF LDO output is 1.946V
3'd4: HF LDO output is 2.000V
3'd5: HF LDO output is 1.649V
3'd6: HF LDO output is 1.701V
3'd7: HF LDO output is 1.756V</description>
                <bitRange>[2:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>BUMP_SY_VCO</name>
                <description>2'd0: VCO LDO outputs are 1.413V
2'd1: VCO LDO outputs are 1.494V
2'd2: VCO LDO outputs are 1.329V
2'd3: VCO LDO outputs are 1.371V</description>
                <bitRange>[4:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>BUMP_SY_LOPATH</name>
                <description>2'd0: LOPATH LDO outputs are 1.762V
2'd1: LOPATH LDO outputs are 1.861V
2'd2: LOPATH LDO outputs are 1.673V
2'd3: LOPATH LDO outputs are 1.716V</description>
                <bitRange>[6:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>BUMP_SY_LHV</name>
                <description>2'd0: HV LDO outputs are 1.894V
2'd1: HV LDO outputs are 2.000V
2'd2: HV LDO outputs are 1.800V
2'd3: HV LDO outputs are 1.846V</description>
                <bitRange>[8:7]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>BUMP_SY_FFFB</name>
                <description>3'd0: FF and FB LDO outputs are 1.800V
3'd1: FF and FB LDO outputs are 1.846V
3'd2: FF and FB LDO outputs are 1.894V
3'd3: FF and FB LDO outputs are 1.946V
3'd4: FF and FB LDO outputs are 2.000V
3'd5: FF and FB LDO outputs are 1.649V
3'd6: FF and FB LDO outputs are 1.701V
3'd7: FF and FB LDO outputs are 1.756V</description>
                <bitRange>[11:9]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>REV_LDO</name>
                <description>received for feature</description>
                <bitRange>[15:12]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>BB_BUMP1</name>
            <description>bump bit for LDOs BB,TXRX</description>
            <addressOffset>0x70</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xDFFF</resetMask>
            <fields>
              <field>
                <name>REFCORE_VDD</name>
                <description>2'd0: Bumps the Ibias current of Refcore to 10u
2'd1: Bumps the Ibias current of Refcore to 9.1u
2'd2: Bumps the Ibias current of Refcore to 11.1u
2'd3: Bumps the Ibias current of Refcore to 12.5u</description>
                <bitRange>[1:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>V2I_REG</name>
                <description>Bit[4]
1: Error amp quiescent current is 5u
0: Error amp quiescent current is 10u

Bit[3:2]
2'd0: V2I LDO output is 1.8V
2'd1: V2I LDO output is 1.85V
2'd2: V2I LDO output is 1.9V
2'd3: V2I LDO output is 1.75V</description>
                <bitRange>[4:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>LFLDO</name>
                <description>3'd0: XO LDO output is 1.894V; BB LDO output is 1.800V
3'd1: XO LDO output is 1.946V; BB LDO output is 1.846V
3'd2: XO LDO output is 2.000V; BB LDO output is 1.894V
3'd3: XO LDO output is 2.000V; BB LDO output is 1.946V
3'd4: XO LDO output is 1.701V; BB LDO output is 1.649V
3'd5: XO LDO output is 1.756V; BB LDO output is 1.649V 
3'd6: XO LDO output is 1.800V; BB LDO output is 1.701V
3'd7: XO LDO output is 1.846V; BB LDO output is 1.756V</description>
                <bitRange>[7:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>LSLDO</name>
                <description>3'd0: LS LDO output is 1.708V
3'd1: LS LDO output is 1.747V
3'd2: LS LDO output is 1.802V
3'd3: LS LDO output is 1.849V
3'd4: LS LDO output is 1.904V
3'd5: LS LDO output is 1.552V
3'd6: LS LDO output is 1.591V
3'd7: LS LDO output is 1.650V</description>
                <bitRange>[10:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>REV_BBBUMP</name>
                <description>N/A</description>
                <bitRange>[12:11]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>FORCE_BGSTARTUP</name>
                <description>1: force BG start u\p</description>
                <bitRange>[14:14]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>FPD_REFORCE</name>
                <description>1: Force Power down for refcore</description>
                <bitRange>[15:15]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>BB_BUMP2</name>
            <description>BB bump configuration</description>
            <addressOffset>0x74</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFF</resetMask>
            <fields>
              <field>
                <name>V2I_RCAL</name>
                <description>Bit[4]
1: Error amp quiescent current is 5u
0: Error amp quiescent current is 10u

Bit[3:0]
4'd0: Trims the RCAL current by 0 percent
4'd1: Trims the RCAL current by -2.5 percent
4'd2: Trims the RCAL current by -5 percent
4'd3: Trims the RCAL current by -7.5 percent
4'd4: Trims the RCAL current by -10 percent
4'd5: Trims the BGR current by -12.5 percent
4'd6: Trims the BGR current by -15 percent
4'd7: Trims the BGR current by -17.5 percent
4'd8: Trims the BGR current by 20 percent
4'd9: Trims the BGR current by 17.5 percent
4'd10: Trims the BGR current by 15 percent
4'd11: Trims the BGR current by 12.5 percent
4'd12: Trims the BGR current by 10 percent
4'd13: Trims the BGR current by 7.5 percent
4'd14: Trims the BGR current by 5 percent
4'd15: Trims the BGR current by 2.5 percent</description>
                <bitRange>[4:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>V2I</name>
                <description>Bit[9]
1: Error amp quiescent current is 5u
0: Error amp quiescent current is 10u

Bit[8:5]
4'd0: Trims the BGR current by 0 percent
4'd1: Trims the BGR current by -2.5 percent
4'd2: Trims the BGR current by -5 percent
4'd3: Trims the BGR current by -7.5 percent
4'd4: Trims the BGR current by -10 percent
4'd5: Trims the BGR current by -12.5 percent
4'd6: Trims the BGR current by -15 percent
4'd7: Trims the BGR current by -17.5 percent
4'd8: Trims the BGR current by 20 percent
4'd9: Trims the BGR current by 17.5 percent
4'd10: Trims the BGR current by 15 percent
4'd11: Trims the BGR current by 12.5 percent
4'd12: Trims the BGR current by 10 percent
4'd13: Trims the BGR current by 7.5 percent
4'd14: Trims the BGR current by 5 percent
4'd15: Trims the BGR current by 2.5 percent</description>
                <bitRange>[9:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VBG_TRIM</name>
                <description>3'd0: Trims the Bandgap voltage by 0 percent
3'd1: Trims the Bandgap voltage by 1.6 percent
3'd2: Trims the Bandgap voltage by 3.2 percent
3'd3: Trims the Bandgap voltage by 4.8 percent
3'd4: Trims the Bandgap voltage by 6.4 percent
3'd5: Trims the Bandgap voltage by -4.8 percent
3'd6: Trims the Bandgap voltage by -3.2 percent
3'd7: Trims the Bandgap voltage by -1.6 percent</description>
                <bitRange>[12:10]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SY_IBIAS</name>
                <description>3'b1xx: RCAL current bumped
3'b0xx: BG current bumped.
2'bxx: reperesent current bump
    01: +12.5 percent, 00: 0 percent, 11: -12.5 percent, 10:-25 percent</description>
                <bitRange>[15:13]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>BB_XO</name>
            <description>BB bump configuration 1</description>
            <addressOffset>0x78</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFF</resetMask>
            <fields>
              <field>
                <name>DIS_XOCORE_SUPFILT</name>
                <description>Enables/Disables the supply filter of the XO core.
1: Disabled
0: Enabled</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EN_RE_FASTSTART</name>
                <description>Enables/Disables the RC faststart block in the XO. When enabled, this block provides a surge current at xo startup to reduce the settling time of the XO.
1: RC Fast start in XO is enabled
0: RC Fast start in XO is disabled</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EN_CURMEAS</name>
                <description>This bit is used to force startup of the positive feedback loop in the amplitude detect block of the XO.
1'd1 : startup forced
1'd0 : Normal startup</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EN_AMPDET_CURMEAS</name>
                <description>This bit can be used to disable all the caps on both X1 node and X2 node.
1'd0 : Caps Enabled
1'd1 : Caps disabled.
Even when all the caps are disabled, due to finite on/off ratio of the caps, the cap on both X1 and X2 node is still 3.69pF</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EN_AMPDET_FASTSTART</name>
                <description>This bit is used to force startup of the vtnbyr circuit in the biasgen_and_reg block of the XO.
1'd1 : startup forced
1'd0 : Normal startup</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CTRL_RC_FASTSTART_RES</name>
                <description>Controls the time constant with which the surge current from rc_faststart block decays down to zero.
2'd0 : 387us
2'd1 : 309us
2'd2 : 232us
2'd3 : 464us</description>
                <bitRange>[6:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CTRL_VDDL_XO</name>
                <description>Controls the value of supply filter resistance in the xo core. This in turn controls the supply voltage at which the core runs.
3'd0 : 0.769k
3'd1 : 0.877k
3'd2 : 1.023k
3'd3 : 1.152k
3'd4 : 1.413k
3'd5 : 1.537k
3'd6 : 0.376k
3'd7 : 0.559k</description>
                <bitRange>[9:7]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CTRL_VDDL_XB</name>
                <description>Controls the value of supply filter resistance in the inverter chain. This in turn controls the supply voltage at which the inverter chain runs.
3'd0 : 1.028k
3'd1 : 1.172k
3'd2 : 1.367k
3'd3 : 1.540k
3'd4 : 1.889k
3'd5 : 2.055k
3'd6 : 0.503k
3'd7 : 0.747k</description>
                <bitRange>[12:10]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CTRL_RPREF</name>
                <description>Controls the reference voltage fed as input to the regulators which generate vdd_xo and vdd_xb.
2'd0 : 1.289V
2'd1 : 1.227V
2'd2 : 1.164V
2'd3 : 1.382V</description>
                <bitRange>[14:13]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>REV_BB_XO</name>
                <description>N/A</description>
                <bitRange>[15:15]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>BB_XO_CAPTRIM</name>
            <description>BB bump configuration 2</description>
            <addressOffset>0x7C</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x2D6A</resetValue>
            <resetMask>0xFFFF</resetMask>
            <fields>
              <field>
                <name>X2</name>
                <description>Bits 7-0 together control cap on X2 node.
Bits 6-0 : Fine Control
Value of 6-0 : Cap Value
7'd0 : 3.6900pF
7'd1 : 3.7911pF
7'd2 : 3.8922pF
.
.
.
7'd127 : 16.4280pF
Bit 7 : Coarse control
1'd0 : No additional cap turned on
1'd1 : Additional cap of 8.1pF turned on</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>X1</name>
                <description>Bits 15-8 together control cap on X1 node.
Bits 14-8 : Fine Control
Value of 14-8 : Cap Value
7'd0 : 3.6900pF
7'd1 : 3.7911pF
7'd2 : 3.8922pF
.
.
.
7'd127 : 16.4280pF
Bit 15 : Coarse control
1'd0 : No additional cap turned on
1'd1 : Additional cap of 8.1pF turned on</description>
                <bitRange>[15:8]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SY_BUMP1</name>
            <description>SY bump bits configuration 1</description>
            <addressOffset>0x80</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x505</resetValue>
            <resetMask>0xFFFF</resetMask>
            <fields>
              <field>
                <name>VCO</name>
                <description>Bump bits for SY VCO block.
Rt VCO (2 bits)  - sy_bump1_vco [3:2]
00 ~ 50 Ohms
01 ~ 30 Ohms
10 ~ 22 Ohms
11 ~ 16 Ohms
and Rb VCO (2 bits) - sy_bump1_vco[1:0]
00 ~ 58 Ohms
01 ~ 39 Ohms
10 ~ 22 Ohms
11 ~ 16 Ohms</description>
                <bitRange>[3:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>LOFB_POWERSAVE</name>
                <description>1: enable powersave for LOFB buffer
0: disable powersave for LOFB buffer
This is spare bit in s8blerf_ver2 inside design</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>IBIAS_LOPATH</name>
                <description>bump bits for clkbias in lopath
bump     clk bias pM           clk bias nM
0 0        vddo-vgsp              vgsn
0 1        vddlo-vgsp-100m    vgsn+100m
1 0        vddlo-vgsp-200m    vgsn+200m
1 1        vddlo-vgsp-400m    vgsn+400m</description>
                <bitRange>[6:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>LDOLO_FORCE_STARTUP</name>
                <description>1: force start-up of the VT/R circuit in VCOLOPATH LCO
0: no force start-up</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>LOPATH</name>
                <description>Bump bits for LO path bulk bias. Goes to DIVN/FCAL/LOPATH for bumps. 2 bits for pBulk [3:2] and 2 bits for Divn/Fcal pBulk[1:0].
bump         pBulk
  0  0         vddx-380mV
  0   1        vddx-320mV
  1   0        vddx-440mV
  1   1        vddx</description>
                <bitRange>[11:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PDCPLPF</name>
                <description>Bump for PD CP and LPF blocks.[2:0] is used to get range of -20 percentto +15 percent in 5 percent steps.
ICP_BUMP[2:0]          ICP
 1 0 0                             -20 percent
 1 0 1                             -15 percent
 1 1 0                             -10 percent
 1 1 1                             -05 percent
 0 0 0                              00 percent
 0 0 1                              05 percent
 0 1 0                              10 percent
 0 1 1                              15 percent.</description>
                <bitRange>[15:12]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SY_BUMP2</name>
            <description>SY bump bits configuration 2</description>
            <addressOffset>0x84</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFF</resetMask>
            <fields>
              <field>
                <name>FCAL_BIAS_SEL</name>
                <description>VCTRL bias voltage is selected based on these bits.
Code[1:0]  fcal_bias
    00           Vddvco/2
    01           Vddvco/2 +  5.6 percent(+100mV)
    10           Vddvco/2 -  2.8 percent(-050mV) 
    11           Vddvco/2 -  5.6 percent(-100mV)</description>
                <bitRange>[1:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ACAP_BIAS_SEL</name>
                <description>ACAP bias voltage is selected based on these bits.
Code[1:0]  acapbias
    00           630mV
    01           700mV
    10           560mV 
    11           595mV</description>
                <bitRange>[3:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ICP_XFACTOR</name>
                <description>sy_bump2_icp_xfactor[1]: enable power save for SY FB buffers in TXPOWERSAVE mode, high active
sy_bump2_icp_xfactor[0]: HSDIV2 is put in self oscillation mode, this can be used to find out the process corner of the chip, high active</description>
                <bitRange>[5:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ICP_OFFSET</name>
                <description>Bump bits to set the offset pulse width in RX mode
Code[1:0]  delay
00: 2.45ns
01: 1.75ns
10: 1.3ns
11: 25ps</description>
                <bitRange>[7:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CLKNC_MODE</name>
                <description>Control the NC_clock_mux.
0: The NC clock is given from DIVN once openloop is made low.
1: The NC clock is always connected to Crystal clock</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PUP_MON</name>
                <description>1:Test mode to monitor buffered 1x output on the injmon buffer</description>
                <bitRange>[9:9]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VCTRL_PULLDN</name>
                <description>1: Test mode to pull down for noise simulation</description>
                <bitRange>[10:10]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VMOD_PULLDN</name>
                <description>1: Pull down control for the modulating port</description>
                <bitRange>[11:11]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RST_DLY</name>
                <description>Bumping the reset (up+down) delay.
Code[1:0]  delay
00: 500ps
01: 424ps
10: 350ps
11: 300ps</description>
                <bitRange>[13:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PDCP_OFFSET</name>
                <description>Bump for the bias voltage of the 8x node.
sel[1:0]   R2    Vbp
00         38.5k   925mV  (Default)
01         43.0k   925mV+108mV
10         31.9k   925mV-158mV
11         35.2k   925mV-080mV</description>
                <bitRange>[15:14]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>TX_BUMP1</name>
            <description>transmit bump configuration 1</description>
            <addressOffset>0x88</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0xD030</resetValue>
            <resetMask>0xFFFF</resetMask>
            <fields>
              <field>
                <name>TX_DRIVER</name>
                <description>Driver bias current selection bump bit
tx_bump1_tx_driver[3]   Driver bias current
tx_bump1_tx_driver[2]   PTAT current selection

Additional Class AB driver bias voltage bump related to Tx_bump2_drv_ab_vbias[3:0]</description>
                <bitRange>[3:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SY_RST_DLY_TX</name>
                <description>Bumping the reset (up+down) delay.
Code[1:0]  delay
00 500ps
01 424ps
10 350ps
11 300ps</description>
                <bitRange>[5:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TX_LPF</name>
                <description>Bump bits for TX LPF op-amp reference voltage [3:2] 
00   Bumps the opamp ref voltage to 400mV
01   Bumps the opamp ref voltage to 450mV 
10   Bumps the opamp ref voltage to 300mV
11   Bumps the opamp ref voltage to 350mVBump bits for TX LPF op-amp bias current
[1:0]
00   Bumps the opamp bias current  to 10u
01   Bumps the opamp bias current  to 12.5u
10   Bumps the opamp bias current  to 8.3u
11   Bumps the opamp bias current  to 7.7u</description>
                <bitRange>[9:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TX_VTXREF_PROG</name>
                <description>TX Modulation port varactor vtxref bias voltage bump settings
0000  Sets  vtxref value to 100mV
0001  Sets  vtxref value to 150mV
0010  Sets  vtxref value to 200mV
0011  Sets  vtxref value to 250mV
0100  Sets  vtxref value to 300mV
0101  Sets  vtxref value to 350mV
0110  Sets  vtxref value to 400mV
0111  Sets  vtxref value to 450mV
1000  Sets  vtxref value to 500mV
1001  Sets  vtxref value to 550mV
1010  Sets  vtxref value to 600mV
1011 ~ 1111: unused</description>
                <bitRange>[13:10]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SY_DIVN_TXPOWERSAVE</name>
                <description>Divn power save bits
pup      freeze   txpowersave&lt;1:0&gt; PupBlocks
  0     0        X          X      NONE
  1     0        X          X     ALL          
  1     1        0          0       ALL       
  1     1        0          1       ALL-D2
  1     1        1          0       ALL-D2-D1
  1     1        1          1       ALL-D2-D1-Buf</description>
                <bitRange>[15:14]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>TX_BUMP2</name>
            <description>transmit bump configuration 2</description>
            <addressOffset>0x8C</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0xE338</resetValue>
            <resetMask>0xFFFF</resetMask>
            <fields>
              <field>
                <name>DRV_AB_VBIAS</name>
                <description>Bias voltage for the class-AB driver with tx_bump1_tx_driver[1:0]=00
Tx_bump2_drv_ab_vbias[3:0] Vbias_AB , mV
0000                                                    571.224
0001                                                   604.508
0010                                                   626.357
0011                                                   641.856
0100                                                   656.04
0101                                                   667.096
0110                                                   678.775
0111                                                   688.005
1000                                                   698.817
1001                                                   707.272
1010                                                   718.103
1011                                                   726.411
1100                                                   737.995
1101                                                   746.708
1110                                                   759.919
1111                                                   769.735</description>
                <bitRange>[3:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DRV_VCASCH</name>
                <description>Programs the driver cascode gate bias voltage

Tx_bump2_drv_vcasch[1:0] Driver cascode bias voltage
00 Vdd_driver - 0.3V
01 Vdd_driver - 0.2V
10 Vdd_driver - 0.1V
11 Vdd_driver</description>
                <bitRange>[5:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SY_LDOBGREF_EN</name>
                <description>Enables a bandgap (low temp coeff) for the 
00 None
01 VCO ldo
10 LOPATH ldo
11 VCO+LOPATH ldo</description>
                <bitRange>[7:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SY_ICP_OFFSET_TX</name>
                <description>Bump bits to set the offset pulse width in TX mode 
Code[1:0]  xfactor
00 : 2.45ns
01 : 1.75ns
10 : 1.3ns
11 : 25ps</description>
                <bitRange>[9:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DAC_RES</name>
                <description>TX DAC load resistor bump settings
0000  DAC output resistor bump by -20 percent
0001  DAC output resistor bump by -17.5 percent
0010  DAC output resistor bump by -15 percent
0011  DAC output resistor bump by -12.5 percent
0100  DAC output resistor bump by -10 percent
0101  DAC output resistor bump by -7.5 percent
0110  DAC output resistor bump by -5 percent
0111  DAC output resistor bump by -2.5 percent
1000  DAC output resistor bump by 0 percent
1001  DAC output resistor bump by 2.5 percent
1010  DAC output resistor bump by 5 percent
1011  DAC output resistor bump by 7.5 percent
1100  DAC output resistor bump by 10 percent
1101  DAC output resistor bump by 12.5 percent
1110  DAC output resistor bump by 15 percent
1111  DAC output resistor bump by 17.5 percent</description>
                <bitRange>[13:10]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SY_CP_TXPOWERSAVE</name>
                <description>Charge pump power save bits
pup freeze   txpowersave&lt;1:0&gt; PupBlocks
  0         0     X     X     NONE
  1         0     X      X     ALL          
  1         1     0      0      ALL       
  1         1     0      1      ALL-8x CP
  1         1     1      0     ALL-8x-1x CP
  1         1     1      1     ALL-buffer</description>
                <bitRange>[15:14]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>RX_BUMP1</name>
            <description>receiver bump configuration 1</description>
            <addressOffset>0x90</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0xCA00</resetValue>
            <resetMask>0xFFFF</resetMask>
            <fields>
              <field>
                <name>TIA</name>
                <description>3'b0xx: TIA CM ref voltage 850mV for iref bias current 8.5uA.
3'b1xx: TIA CM ref voltage 850mV for iref bias current 10uA.
3'bx00: TIA OTA CMFB tail current 69uA (Bias current 8.5uA).
3'bx01: TIA OTA CMFB tail current 78uA (Bias current 8.5uA).
3'bx10: TIA OTA CMFB tail current 86uA (Bias current 8.5uA).
3'bx11: TIA OTA CMFB tail current 95uA (Bias current 8.5uA).</description>
                <bitRange>[2:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CBPF</name>
                <description>3'b0xx: CBPF CM ref voltage 850mV and 1V for 1st stage and 2nd stage
resp. for irefbg 8.5uA.
3'b1xx: CBPF CM ref voltage 850mV and 1V for 1st stage and 2nd stage
resp. for irefbg 10uA.
3'bxx0: CBPF OTA1 CMFB tail current 17.27uA (Bias current 8.5uA).
3'bxx1: CBPF OTA1 CMFB tail current 21.58uA (Bias current 8.5uA).
3'bx0x: CBPF OTA2 CMFB tail current 17.27uA (Bias current 8.5uA).
3'bx1x: CBPF OTA2 CMFB tail current 21.58uA (Bias current 8.5uA).</description>
                <bitRange>[5:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>IF_OFFSET_CALDAC</name>
                <description>Bit Setting Offset DAC LSB
00            132.4nA
01            150.8nA
10            118.0nA
11            106.5nA</description>
                <bitRange>[7:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>MIXER_VBIAS_SW</name>
                <description>Bump bits for Mixer VBIAS switch
Mixer Bias Programmability
01 TIA CM + 0.38V
00 TIA CM + 0.3V
11 TIA CM + 0.255V
10 TIA CM + 0.17V</description>
                <bitRange>[9:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>MIXER</name>
                <description>bump bits to control LNA gate bias voltage in RX mode
01      0.5V
00      0.4V
11      0.3V
10      0.2V</description>
                <bitRange>[11:10]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>LNA</name>
                <description>rx_bump1_lna[3]
1: enables the HG and LG LNA section's cascode biases to be alive independent of whether LNA is HG or LG mode. This enables fast transition from LG to HG in AGC events
rx_bump1_lna[2]
1: forces pull donwn of inputs of LNA (post AC coupling) if LNA is powered up in Hi-Z mode to ensure good isolation during DC offset calibration of Receiver chain
rx_bump1_lna[1]
1: Boost the LNA bias current ot HP equivalent (1.5mA current penalty) if LNA gain is at 101 (66dB setting) and this bit is set. this boosts sensitivity by 2-3dB but the hit in the current consumption is only at 66dB gain setting. so average current comsumption in field should not be impacted much but a 2dB boost in sensitivity is seen
rx_bump1_lna[0]
1: Forces the TIA to have lower feedback resistor to aviode EVM degratation in the TIA dut to complex filter distortion caused by I/Q cross talk if feedback resistors is high in the TIA</description>
                <bitRange>[15:12]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>RX_BUMP2</name>
            <description>receiver bump configuration 2</description>
            <addressOffset>0x94</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x8CE</resetValue>
            <resetMask>0xFFFF</resetMask>
            <fields>
              <field>
                <name>LNA_IBIAS</name>
                <description>Bump bits for PTAT bias currents of LNA (Default is 00). Play with these to enable Low Power and Ultra Low Power modes in the LNA.
01 IBias+15 percent
00 IBias+0 percent (Default)
11 IBias-25 percent
10 IBias-50 percent</description>
                <bitRange>[1:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TIA_IBIAS</name>
                <description>Bump bits for RCAL bias currents of the TIA and the CBPF amplifiers (Default is 11 for current saving).
01 IBias+15 percent
00 IBias+0 percent
11 IBias-15 percent (Default)
10 IBias-20 percent</description>
                <bitRange>[3:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CBPF_IBIAS</name>
                <description>Bump bits for BGR bias currents of Offset Calibration DAC (Default is 00)
01 IBias+15 percent
00 IBias_0 percent (Default)
11 IBias-15 percent
10 IBias-20 percent</description>
                <bitRange>[5:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>IF_CM_IBIAS</name>
                <description>Bump bits for Common mode setting currents of the TIA and the CBPF amplifiers (Default is 11 for current saving).
01 IBias+15 percent
00 IBias+0 percent
11 IBias-15 percent (Default)
10 IBias-20 percent</description>
                <bitRange>[7:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CBPF_HIZ_ENABLE</name>
                <description>Setting this bit to 1 configures the CBPF output as hi-Z enabling independent ADC testing with the injection system</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>COMPLEX_DISABLE</name>
                <description>setting this bit to disables the complex operation for the band pass filter configuring it as two low pass filters</description>
                <bitRange>[9:9]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SY_R2HIGHMODE</name>
                <description>Enables a higher R2 mode for loop stabilization with low Kv and debug mode.
0 - 40 kohms
1 - 60 kohms</description>
                <bitRange>[10:10]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SY_HILINEARITYR2_MODE</name>
                <description>Switches the RX mode between settings used in TX vs a higher linearity setting.
0 - Use same as TX
1 - Use alternative bias for RX. Effective only in RX mode. This is don't care in TX mode</description>
                <bitRange>[11:11]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SY_LOWKVAMODE</name>
                <description>Enables a lower Kv/2 mode
0 - 70 MHz/V
1 - 45 MHz/V</description>
                <bitRange>[12:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SY_LOWKVMMODE</name>
                <description>Enables a lower Kv/2 mode
0 - 10 MHz/V
1 - 5 MHz/V</description>
                <bitRange>[13:13]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>REV_RX_BUMP2</name>
                <description>N/A</description>
                <bitRange>[15:14]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ADC_BUMP1</name>
            <description>ADC1 bump configuration</description>
            <addressOffset>0x98</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x24</resetValue>
            <resetMask>0xFFFF</resetMask>
            <fields>
              <field>
                <name>I_REF</name>
                <description>Bump bits for the channel-I reference voltage. (2's complement interpretation) Every bit changes the reference voltage by 10mV. See the above table</description>
                <bitRange>[2:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>Q_REF</name>
                <description>Bump bits for the channel-Q reference voltage. (2's complement interpretation) Every bit changes the reference voltage by 10mV. 
100 610 mV
000 650 mV
011 680 mV</description>
                <bitRange>[5:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>IBG_CAL</name>
                <description>Bump bits for the preamp's bias current.
X00 + 0  percent ( Ibias - 0 uA)
X01 +25  percent ( Ibias - 12.5 uA)
X10 - 50  percent ( Ibias - 5 uA)
X11 - 25  percent ( Ibias - 7.5 uA)</description>
                <bitRange>[8:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>LOOPDLY</name>
                <description>Loop delay control in SAR return path. 
00 Min delay
11 Max delay</description>
                <bitRange>[10:9]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>LOOPDLY4X_EN</name>
                <description>Loop delay increment by 4x in SAR return path 
0 Delay determined by loopdly[1:0] 
1 4x the delay dictated by the said bit</description>
                <bitRange>[11:11]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>LOWPOWER</name>
                <description>rCurrent reduction mode in the reference generator.  
0  No bump
1 50 percent bump</description>
                <bitRange>[12:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>OPAMP_BYPASS</name>
                <description>Bypass op-amp and diode connect reference generator's servo loop 
0  Op-amp enabled
1 Op-amp bypassed</description>
                <bitRange>[13:13]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>BWCTRL</name>
                <description>Reference generator's bandwidth boost by injecting current in the output arm. 
Injection Current :
00           0 uA
01           20 uA
10           40 uA
11           60 uA</description>
                <bitRange>[15:14]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ADC_BUMP2</name>
            <description>ADC 2 bump configuration</description>
            <addressOffset>0x9C</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x4</resetValue>
            <resetMask>0xFFFF</resetMask>
            <fields>
              <field>
                <name>CYCLE_B2_DELAY</name>
                <description>Enable redundant conversion cycle at b2 position. 
0 Enabled
1 Disabled</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CYCLE_B5_DELAY</name>
                <description>Enable redundant conversion cycle at b5 position.
0 Disabled
1 Enabled</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DUTCYCLE_25</name>
                <description>Clock duty cycle control 
0 50  percent time for track phase  &amp; 50  percent  time for convert phase
1 25  percent time for track phase &amp; 75  percent  time for convert phase</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>METADET_EN</name>
                <description>Enable meta detection</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>IBUMP</name>
                <description>0: 6dB attenuation in CBPF gain only at lowest gain setting to improve the Max signal level the receiver can tolarate
Note: in order to chare the tub width with AGC disabled, this back off mode is effective only with AGC profile set to rev** mode. This is in reg0xa4[3] which needs to be set to '0' for rev** profile</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PREAMP_SOURCECTRL_N</name>
                <description>Disconnect source coupled node of the preamp during track phase. 
0 Functionality enabled
1 Functionality disabled</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PREAMP_GAINCTRL_N</name>
                <description>Enable preamp's low/high gain modes over conversion cycle.
0 Functionality enabled
1 Functionality disabled</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SHORT_INPUT</name>
                <description>Put the ADC in idle channel mode. Inputs are shorted to locally generated 1V signal.
0 Normal operation
1 Idle channel mode</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RETURN_SKEW</name>
                <description>Delaying the sampling clock from the comparator wrt to the data. 
000 Min delay
111 Max delay</description>
                <bitRange>[10:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>IQSWAP</name>
                <description>Swaps the I and Q channel Vbg/R for ref.gen
0 No swap
1 Enable swapping</description>
                <bitRange>[11:11]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PREAMP_BWCTRL</name>
                <description>Bandwidth bump bits for the preamp. Each bit connects a 5fF cap to the output nodes. No cap is connected by default</description>
                <bitRange>[13:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>REV_ADC_BUMP2</name>
                <description>[1] -- not used
[0] - Enable clean Vdd for the cascodes &amp; op-amp in refgen. The clean Vdd supplied through the diag. ( Diag code = 0101 for channel I and Diag code =1101 for channel Q). Default connection to the internal Vdd</description>
                <bitRange>[15:14]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>BALUN</name>
            <description>BALUN bump configuration</description>
            <addressOffset>0xA0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x3</resetValue>
            <resetMask>0xFFFF</resetMask>
            <fields>
              <field>
                <name>BUMP_RX_CTUNE</name>
                <description>Programmable bits to change tuning capacitance in the Balun primary side in RX operation
Balun_bump_tx_ctune[3:0] Ctune, fF
0000                                           42.5
0001                                           48.8
0010                                           55.1
0011                                           61.4
0100                                           67.7
0101                                           74
0110                                           80.3
0111                                           86.6
1000                                           92.9
1001                                           99.2
1010                                           105.5
1011                                           111.8
1100                                           118.1
1101                                           124.4
1110                                           130.7
1111                                           137</description>
                <bitRange>[3:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>BUMP_TX_CTUNE</name>
                <description>Programmable bits to change tuning capacitance in the Balun primary side in TX operation
Balun_bump_tx_ctune[3:0] Ctune, fF
0000                                           42.5
0001                                           48.8
0010                                           55.1
0011                                           61.4
0100                                           67.7
0101                                           74
0110                                           80.3
0111                                           86.6
1000                                           92.9
1001                                           99.2
1010                                           105.5
1011                                           111.8
1100                                           118.1
1101                                           124.4
1110                                           130.7
1111                                           137</description>
                <bitRange>[7:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>BUMP_VTUNE</name>
                <description>resereved for feature</description>
                <bitRange>[10:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>BUMP_RTUNE</name>
                <description>resereved for feature</description>
                <bitRange>[12:11]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>REV_BALUN</name>
                <description>resereved for feature</description>
                <bitRange>[15:13]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CTR1</name>
            <description>RFCTRL control timing 1</description>
            <addressOffset>0xA4</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x31C0</resetValue>
            <resetMask>0xFFFF</resetMask>
            <fields>
              <field>
                <name>VCO_WARMUP_TIME</name>
                <description>vco warm up time, 1: 10us, 0: 5us</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PLL_SETTLING_TIME</name>
                <description>PLL setting time
00: 25us, 01: 30us, 10: 40us, 11:50us</description>
                <bitRange>[2:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TX_FREEZE_TIME</name>
                <description>tx freeze time
00: 30us, 01: 40us, 10: 50us, 11: 25us</description>
                <bitRange>[4:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TX_PREDRV_TIME</name>
                <description>PA predrive pup time, 
1:powered up after LDO, 0: powered up after KVCAL</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TX_MODSTART_TIME</name>
                <description>this controls the time between the PUP_TX_DRIVER going high and when f_n_txen is asserted.
00: 0us, 01: 1us, 10: 2us, 11, 3us</description>
                <bitRange>[7:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TX_DF2_SEL</name>
                <description>0: DF2 Max frequency deviation as 224KHz
1: DF2 Max frequency deviation as 242KHz</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ADC_FULL_SWING_MONI_EN</name>
                <description>when ctr1_adc_full_swing_moni_en is set and ctr1_dbg_select is 2'b11. ADC full swing detection can be monitored in debug pin</description>
                <bitRange>[9:9]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DBG_SELECT</name>
                <description>00: demod soft reset / AGC reset,
01: AGC FSM MSB and f_n_rxen
10: gain decrease and gain increase.
11: ADC full swing detection and ADC saturation detected signal</description>
                <bitRange>[11:10]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RX_DC_FREEZE_EN</name>
                <description>demodulation soft reset to DC cancellation enabled, high active</description>
                <bitRange>[12:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RX_ENV_FREEZE_EN</name>
                <description>demodulation soft reset to frequency tracking enabled, high active</description>
                <bitRange>[13:13]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>AGC_RST_DLY</name>
                <description>00: 0.25us delay; 01: 1.25us delay, 10: 2.25us delay, 11: 3.25us delay</description>
                <bitRange>[15:14]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>AGC</name>
            <description>AGC timing conifguration</description>
            <addressOffset>0xA8</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x25FF</resetValue>
            <resetMask>0xFFFF</resetMask>
            <fields>
              <field>
                <name>RST_EN</name>
                <description>1: AGC soft reset enable</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CHECK_SAT_EN</name>
                <description>1: quick check saturated ADC
0: mearue ADC power at fixed period</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SAT_CHK_TIM</name>
                <description>ADC saturated detection timing
0: 3 12MHz clock;1:3 12MHz clock;</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>GAIN_MAPPING_MODE</name>
                <description>0: Atlantis TC rev** gaim mapping
1: Atlantis TC revA gain mapping</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>GAIN_SAT_THRES</name>
                <description>ADC saturated detection threshold for doing a fast transition
00: 0dBm; 01: 1dBm; 10: 2dBm, 11: 3dBm</description>
                <bitRange>[5:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PWR_MEAS_TIM</name>
                <description>AGC power measurement time
11: 1us, 10: 0.75us, 01: 0.5us, 00:0.25us</description>
                <bitRange>[7:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>GAIN_STABLE_TIM</name>
                <description>gain stable time after gain assignment.
1 represents one 12Mhz clock</description>
                <bitRange>[12:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>START_WAIT_TIM</name>
                <description>start AGC waiting time when RFCTRL set AGC enable
1 represents 1us, base 1us</description>
                <bitRange>[15:13]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>THRSHD1</name>
            <description>AGC step threshold 1</description>
            <addressOffset>0xAC</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x3C2C</resetValue>
            <resetMask>0x3F3F</resetMask>
            <fields>
              <field>
                <name>AGC60_66</name>
                <description>threshold gain changge from 66dB to60dB</description>
                <bitRange>[5:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>AGC66_60</name>
                <description>threshold gain changge from 60dB to 48dB</description>
                <bitRange>[13:8]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>THRSHD2</name>
            <description>AGC step threshold 2</description>
            <addressOffset>0xB0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x3B2A</resetValue>
            <resetMask>0x3F3F</resetMask>
            <fields>
              <field>
                <name>AGC48_60</name>
                <description>threshold gain changge from 60dB to48dB</description>
                <bitRange>[5:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>AGC60_48</name>
                <description>threshold gain changge from 48dB to 60dB</description>
                <bitRange>[13:8]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>THRSHD3</name>
            <description>AGC step threshold 3</description>
            <addressOffset>0xB4</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x3B2C</resetValue>
            <resetMask>0x3F3F</resetMask>
            <fields>
              <field>
                <name>AGC36_48</name>
                <description>threshold gain changge from 48dB to 36dB</description>
                <bitRange>[5:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>AGC48_36</name>
                <description>threshold gain changge from 366dB to 48dB</description>
                <bitRange>[13:8]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>THRSHD4</name>
            <description>AGC step threshold 4</description>
            <addressOffset>0xB8</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x3C2B</resetValue>
            <resetMask>0x3F3F</resetMask>
            <fields>
              <field>
                <name>AGC18_36</name>
                <description>threshold gain changge from 36dB to 18dB</description>
                <bitRange>[5:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>AGC36_18</name>
                <description>threshold gain changge from 18dB to 36dB</description>
                <bitRange>[13:8]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>THRSHD5</name>
            <description>AGC step threshold 5</description>
            <addressOffset>0xBC</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x3E26</resetValue>
            <resetMask>0x3F3F</resetMask>
            <fields>
              <field>
                <name>AGC0_18</name>
                <description>threshold for gain change from 18dB to 0dB</description>
                <bitRange>[5:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>AGC18_0</name>
                <description>threshold for gain change from 0dB to 18dB</description>
                <bitRange>[13:8]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DC</name>
            <description>ADC I/Q DC compensate value</description>
            <addressOffset>0xC0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFF</resetMask>
            <fields>
              <field>
                <name>COMP_Q_CODE</name>
                <description>this code is removed from the ADC I output.
This field can be progamrmed to remove systematci DC offset</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>COMP_I_CODE</name>
                <description>this code is removed from the ADC Q output.
This field can be progamrmed to remove systematci DC offset</description>
                <bitRange>[15:8]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>IQMIS</name>
            <description>IQ mismatch correction value</description>
            <addressOffset>0xC4</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFF</resetMask>
            <fields>
              <field>
                <name>IQCOMP_QVAL</name>
                <description>I-component of the IQ mismatch correction</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>IQCOMP_IVAL</name>
                <description>Q-component of the IQ mismatch correction</description>
                <bitRange>[15:8]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DCCAL</name>
            <description>DC CAL and setting</description>
            <addressOffset>0xC8</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x7FFF</resetMask>
            <fields>
              <field>
                <name>TEST_IBITS</name>
                <description>this value is driven to DCCAL Icode if the DCCA: test mode enabled</description>
                <bitRange>[5:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TEST_QBITS</name>
                <description>this value is driven to DCCAL Qcode if the DCCA: test mode enabled</description>
                <bitRange>[11:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TEST_MODE</name>
                <description>enable the DCCAL test mode</description>
                <bitRange>[12:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TEST_Q_POLARITY</name>
                <description>1: inverts the polarity of DCCAL Q code</description>
                <bitRange>[13:13]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TEST_I_POLARITY</name>
                <description>1: inverts the polarity of DCCAL I code</description>
                <bitRange>[14:14]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>RCCAL</name>
            <description>TX LPF and TIA/CBPF RC code</description>
            <addressOffset>0xCC</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x1A10</resetValue>
            <resetMask>0xFBFF</resetMask>
            <fields>
              <field>
                <name>CODE_RX</name>
                <description>force RC code for TIA/CBPF under test mode</description>
                <bitRange>[4:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CODE_TX</name>
                <description>force RC code for TX LPF under test mode</description>
                <bitRange>[9:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SOFTRST_POWER_DIFF</name>
                <description>soft reset power change detection, 1: 12dB, 0:6dB</description>
                <bitRange>[11:11]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SOFTRST_EN_TOSTR</name>
                <description>soft reset is enabled to STR block</description>
                <bitRange>[12:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SOFTRST_EN_TODIFF</name>
                <description>soft reset is enable to diffdet block</description>
                <bitRange>[13:13]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>AGC_GAIN_INC_TIMES_THRES</name>
                <description>AGC gain increase requirement wait times:
00: respose for 1st gain increase request
01: respone for 2nd gain increase request
10: respons for 3rd gain increase request
11: respons for 4th gain increase request</description>
                <bitRange>[15:14]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DSM1</name>
            <description>DSM freeze code 1</description>
            <addressOffset>0xD0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0xD964</resetValue>
            <resetMask>0xFFFF</resetMask>
            <fields>
              <field>
                <name>INDX_CODE3</name>
                <description>index at which DSM code should be freezed when fection value = 3/24</description>
                <bitRange>[3:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>INDX_CODE2</name>
                <description>index at which DSM code should be freezed when fection value = 2/24</description>
                <bitRange>[7:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>INDX_CODE1</name>
                <description>index at which DSM code should be freezed when fection value = 1/24</description>
                <bitRange>[11:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>INDX_CODE0</name>
                <description>index at which DSM code should be freezed when fection value = 0</description>
                <bitRange>[15:12]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DSM2</name>
            <description>DSM freeze code 2</description>
            <addressOffset>0xD4</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x54C1</resetValue>
            <resetMask>0xFFFF</resetMask>
            <fields>
              <field>
                <name>INDX_CODE7</name>
                <description>index at which DSM code should be freezed when fection value = 7/24</description>
                <bitRange>[3:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>INDX_CODE6</name>
                <description>index at which DSM code should be freezed when fection value = 6/24</description>
                <bitRange>[7:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>INDX_CODE5</name>
                <description>index at which DSM code should be freezed when fection value = 5/24</description>
                <bitRange>[11:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>INDX_CODE4</name>
                <description>index at which DSM code should be freezed when fection value = 4/24</description>
                <bitRange>[15:12]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DSM3</name>
            <description>DSM freeze code 3</description>
            <addressOffset>0xD8</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0xAAA5</resetValue>
            <resetMask>0xFFFF</resetMask>
            <fields>
              <field>
                <name>INDX_CODE11</name>
                <description>index at which DSM code should be freezed when fection value = 11/24</description>
                <bitRange>[3:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>INDX_CODE10</name>
                <description>index at which DSM code should be freezed when fection value = 10/24</description>
                <bitRange>[7:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>INDX_CODE9</name>
                <description>index at which DSM code should be freezed when fection value = 9/24</description>
                <bitRange>[11:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>INDX_CODE8</name>
                <description>index at which DSM code should be freezed when fection value = 8/24</description>
                <bitRange>[15:12]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DSM4</name>
            <description>DSM freeze code 4</description>
            <addressOffset>0xDC</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x8911</resetValue>
            <resetMask>0xFFFF</resetMask>
            <fields>
              <field>
                <name>INDX_CODE15</name>
                <description>index at which DSM code should be freezed when fection value = 15/24</description>
                <bitRange>[3:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>INDX_CODE14</name>
                <description>index at which DSM code should be freezed when fection value = 14/24</description>
                <bitRange>[7:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>INDX_CODE13</name>
                <description>index at which DSM code should be freezed when fection value = 13/24</description>
                <bitRange>[11:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>INDX_CODE12</name>
                <description>index at which DSM code should be freezed when fection value = 12/24</description>
                <bitRange>[15:12]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DSM5</name>
            <description>DSM freeze code 5</description>
            <addressOffset>0xE0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x9D37</resetValue>
            <resetMask>0xFFFF</resetMask>
            <fields>
              <field>
                <name>INDX_CODE19</name>
                <description>index at which DSM code should be freezed when fection value = 19/24</description>
                <bitRange>[3:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>INDX_CODE18</name>
                <description>index at which DSM code should be freezed when fection value = 18/24</description>
                <bitRange>[7:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>INDX_CODE17</name>
                <description>index at which DSM code should be freezed when fection value = 17/24</description>
                <bitRange>[11:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>INDX_CODE16</name>
                <description>index at which DSM code should be freezed when fection value = 16/24</description>
                <bitRange>[15:12]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DSM6</name>
            <description>DSM freeze code 6</description>
            <addressOffset>0xE4</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x788C</resetValue>
            <resetMask>0xFFFF</resetMask>
            <fields>
              <field>
                <name>INDX_CODE23</name>
                <description>index at which DSM code should be freezed when fection value = 23/24</description>
                <bitRange>[3:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>INDX_CODE22</name>
                <description>index at which DSM code should be freezed when fection value = 22/24</description>
                <bitRange>[7:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>INDX_CODE21</name>
                <description>index at which DSM code should be freezed when fection value = 21/24</description>
                <bitRange>[11:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>INDX_CODE20</name>
                <description>index at which DSM code should be freezed when fection value = 20/24</description>
                <bitRange>[15:12]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MONI</name>
            <description>agc gain and pup signal monitor</description>
            <addressOffset>0xE8</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0xBC00</resetValue>
            <resetMask>0xFFFF</resetMask>
            <fields>
              <field>
                <name>PUP_SIG</name>
                <description>block pup up signals monitor.
10: iso_eanble
9: balum LDO power up, high active
8: SY bias power up, high active
7. SY VCO pup up, high active
6: TX bias pup up, high active
5. TX DAC pup up, high active
4: TX LPF pup up, high active
3. TX driver pup up, high active
2: RX LNA pup up, high active
1. RX CBPF pup up, high active
0: RX ADC ICORE pup, high active</description>
                <bitRange>[10:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>CBPF_CODE</name>
                <description>cbpf gain code read back</description>
                <bitRange>[12:11]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>LNA_CODE</name>
                <description>lna gain code read back</description>
                <bitRange>[15:13]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DBG_BB</name>
            <description>RX offcal and RC cal code</description>
            <addressOffset>0xEC</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFF</resetMask>
            <fields>
              <field>
                <name>RX_OFFSET_Q_CODE</name>
                <description>when modem_read_dc_offset_sel = 1, RX DCCAL Q path can be read through this field.
When modem_read_dc_offset_sel = 0, RC DC offset capture Q code can be read through this field
rx offsetcal Q code can be read through this field if modem_read_dc_offset_sel = 0</description>
                <bitRange>[7:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>RX_OFFSET_I_CODE</name>
                <description>when modem_read_dc_offset_sel = 1, RX DCCAL I path can be read through this field.
When modem_read_dc_offset_sel = 0, RC DC offset capture I code can be read through this field
rx offsetcal Q code can be read through this field if modem_read_dc_offset_sel = 0</description>
                <bitRange>[15:8]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DBG_1</name>
            <description>FCAL coarse / fine code is reflected in this field</description>
            <addressOffset>0xF0</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x808</resetValue>
            <resetMask>0x7FFF</resetMask>
            <fields>
              <field>
                <name>FCAL_FINE_CODE</name>
                <description>The FCAL fine code is reflected in this field</description>
                <bitRange>[3:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>FCAL_COARSE_CODE</name>
                <description>The FCAL coars code is reflected in this field</description>
                <bitRange>[11:4]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>FCAL_DONE</name>
                <description>1: indicates when frequency calibration is done</description>
                <bitRange>[12:12]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>KVCAL_DONE</name>
                <description>1: indicates TX KV calibration is done for current packet</description>
                <bitRange>[13:13]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>DCCAL_DONE</name>
                <description>1: indicates RX DC calibration is done for current packet</description>
                <bitRange>[14:14]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DBG_2</name>
            <description>FCAL countere value ate the end of 7th bit (MSB)</description>
            <addressOffset>0xF4</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFF</resetMask>
            <fields>
              <field>
                <name>FCAL_CNT_LSB</name>
                <description>the dbg_fcal_cnt_sel value, the 16 LSB bits of the corresponding debug counter is pouplated in this register
[6:0] is kvcal_gain when select kvcal_gain</description>
                <bitRange>[15:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DBG_3</name>
            <description>VCO OL count read out (MSB)</description>
            <addressOffset>0xF8</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFC0F</resetMask>
            <fields>
              <field>
                <name>FCAL_CNT_MSB</name>
                <description>the dbg_fcal_cnt_sel value, the 4 MSB bits of the corresponding debug counter is pouplated in this register</description>
                <bitRange>[3:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>RD_RCCAL_CODE</name>
                <description>RCCAL code read out through register</description>
                <bitRange>[14:10]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>RD_RCCAL_DONE</name>
                <description>RCCAL done indictor</description>
                <bitRange>[15:15]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>READ_IQ_1</name>
            <description>I&amp;Q Path ADC Data</description>
            <addressOffset>0x100</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>ADC_1</name>
                <description>read out I&amp;Q path ADC data, first 16bits of I and Qcombination of 63bits</description>
                <bitRange>[31:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>READ_IQ_2</name>
            <description>I&amp;Q Path ADC Data</description>
            <addressOffset>0x104</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>ADC_2</name>
                <description>read out I&amp;Q path ADC data, second 16bits of I and Qcombination of 63bits</description>
                <bitRange>[31:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>READ_IQ_3</name>
            <description>I&amp;Q Path ADC Data</description>
            <addressOffset>0x108</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>ADC_3</name>
                <description>read out I&amp;Q path ADC data, third 16bits of I and Qcombination of 63bits</description>
                <bitRange>[31:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>READ_IQ_4</name>
            <description>I&amp;Q Path ADC Data</description>
            <addressOffset>0x10C</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>ADC_4</name>
                <description>read out I&amp;Q path ADC data, fourth 15bits of I and Qcombination of 63bits</description>
                <bitRange>[31:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
        </cluster>
        <cluster>
          <name>BLELL</name>
          <description>Bluetooth Low Energy Link Layer</description>
          <addressOffset>0x00001000</addressOffset>
          <register>
            <name>COMMAND_REGISTER</name>
            <description>Instruction Register</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <access>write-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>COMMAND</name>
                <description>N/A</description>
                <bitRange>[7:0]</bitRange>
                <access>write-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>EVENT_INTR</name>
            <description>Event(Interrupt) status and Clear register</description>
            <addressOffset>0x8</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x7F</resetMask>
            <fields>
              <field>
                <name>ADV_INTR</name>
                <description>Advertiser interrupt. If bit is set to 1, it indicates an event occurred in the advertising procedure. The source of the event needs to be read from the ADV_INTR register.  
This bit is cleared, when firmware clears ALL interrupts by writing to the ADV_INTR register.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>SCAN_INTR</name>
                <description>Scanner interrupt.  If bit is set to 1, it indicates an event occurred in the scanning procedure. The source of the event needs to be read from the SCAN_INTR register.   
This bit is cleared, when firmware clears ALL interrupts by writing to the SCAN_INTR register.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>INIT_INTR</name>
                <description>Initiator interrupt.  If bit is set to 1, it indicates an event occurred in the initiating procedure. The source of the event needs to be read from the INIT_INTR register.   
This bit is cleared, when firmware clears ALL interrupts by writing to the INIT_INTR register.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>CONN_INTR</name>
                <description>Connection interrupt.  If bit is set to 1, it indicates an event occurred in the connection operation. This interrupt is aggregation of interrupts for all the connections. The source of the event for the specific connection, needs to be read from the CONN_INTR register specific to the connection. This bit is cleared, when firmware clears ALL interrupts by writing to the CONN_INTR register.</description>
                <bitRange>[3:3]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>SM_INTR</name>
                <description>Read: Sleep-mode-exit interrupt. This bit is set, when link layer hardware exits from sleep mode. 
Write: Clear sleep-mode-exit interrupt. Write to the register with this bit set to 1, clears the interrupt source.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DSM_INTR</name>
                <description>Read: Deep sleep mode exit interrupt. This bit is set, when link layer hardware exits from deep sleep mode. 
Write: Clear deep sleep mode exit interrupt. Write to the register with this bit set to 1, clears the interrupt source.</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ENC_INTR</name>
                <description>Encryption module interrupt.</description>
                <bitRange>[6:6]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>EVENT_ENABLE</name>
            <description>Event indications enable.</description>
            <addressOffset>0x10</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x7F</resetMask>
            <fields>
              <field>
                <name>ADV_INT_EN</name>
                <description>Advertiser interrupt enable.
1 - enable advertiser procedure to interrupt the firmware.
0 - disable advertiser procedure interrupt to firmware.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SCN_INT_EN</name>
                <description>Scanner interrupt enable.
1 - enable scan procedure to interrupt the firmware.
0 - disable scan procedure interrupt to firmware.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>INIT_INT_EN</name>
                <description>Initiator interrupt enable.
1 - enable initiator procedure to interrupt the firmware.
0 - disable initiator procedure interrupt to firmware.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CONN_INT_EN</name>
                <description>Connection interrupt enable. 
1 - enable connection procedure to interrupt the firmware.
0 - disable connection procedure interrupt to firmware.</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SM_INT_EN</name>
                <description>Sleep-mode-exit interrupt enable.  
1 - enable sleep mode exit event to interrupt the firmware.
0 - disable sleep mode exit interrupt to firmware.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DSM_INT_EN</name>
                <description>Deep Sleep-mode-exit interrupt enable.  
1 - enable deep sleep mode exit event to interrupt the firmware.
0 - disable deep sleep mode exit interrupt to firmware.</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ENC_INT_EN</name>
                <description>Encryption module interrupt enable.  
1 - Enable encryption module interrupt to firmware.
0 - disable encryption module interrupt to firmware.</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ADV_PARAMS</name>
            <description>Advertising parameters register.</description>
            <addressOffset>0x18</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0xE0</resetValue>
            <resetMask>0x85FF</resetMask>
            <fields>
              <field>
                <name>TX_ADDR</name>
                <description>Device own address type. 
1 - Address type is random. 
0 - Address type is public.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ADV_TYPE</name>
                <description>The Advertising type is used to determine the packet type that is used for advertising when advertising is enabled. 
0x0 - Connectable undirected advertising. (adv_ind) 
0x1 - Connectable directed advertising (adv_direct_ind). 
0x2 - Discoverable undirected advertising (adv_discover_ind) 
0x3 - Non connectable undirected advertising (adv_nonconn_ind).</description>
                <bitRange>[2:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ADV_FILT_POLICY</name>
                <description>Advertising filter policy. The set of devices that the advertising procedure uses for device filtering is called the White List. 
0x0 - Allow scan request from any device, allow connect request from any device. 
0x1 - Allow scan request from devices in white list only, allow connect request from any device. 
0x2 - Allow scan request from any device, allow connect request from devices in white list only. 
0x3 - Allow scan request from devices in white list only, allow connect request from devices in white list only.</description>
                <bitRange>[4:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ADV_CHANNEL_MAP</name>
                <description>Advertising channel map indicates the advertising channels used for advertising. By setting the bit, corresponding channel is enabled for use. Atleast one channel bit should be set.  
7 - enable channel 39. 
6 - enable channel 38. 
5 - enable channel 37.</description>
                <bitRange>[7:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RX_ADDR</name>
                <description>Peer addresses type. This is the Direct_Address_type field programmed, only if ADV_DIRECT_IND type is sent.
1 - Rx addr type is random.
0 - Rx addr type is public</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ADV_LOW_DUTY_CYCLE</name>
                <description>This bit field is used to specify to the Controller the Low Duty Cycle connectable directed advertising variant being used.
1 - Low Duty Cycle Connectable Directed Advertising.
0 - High Duty Cycle Connectable Directed Advertising.</description>
                <bitRange>[10:10]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RCV_TX_ADDR</name>
                <description>Transmit address field of the received packet extracted from the receive packet. This field is used by firmware to report peer_addr_type parameter in the connection complete event.</description>
                <bitRange>[15:15]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ADV_INTERVAL_TIMEOUT</name>
            <description>Advertising interval register.</description>
            <addressOffset>0x1C</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x20</resetValue>
            <resetMask>0x7FFF</resetMask>
            <fields>
              <field>
                <name>ADV_INTERVAL</name>
                <description>Range:  0x0020 to 0x4000 (For ADV_IND) 
0x00A0 to 0x4000 (For ADV_SCAN_IND and NONCONN_IND) 
Invalid for ADV_DIRECT_IND 
Time = N * 0.625 msec 
Time Range: 20 ms to 10.24 sec. 
For directed advertising, firmware programs the default value of 1.28 seconds.</description>
                <bitRange>[14:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ADV_INTR</name>
            <description>Advertising interrupt status and Clear register</description>
            <addressOffset>0x20</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1FF</resetMask>
            <fields>
              <field>
                <name>ADV_STRT_INTR</name>
                <description>If this bit is set it indicates a new advertising event started after interval expiry.
Write to the register with this bit set to 1, clears the interrupt source.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ADV_CLOSE_INTR</name>
                <description>If this bit is set it indicates current advertising event is closed.
Write to the register with this bit set to 1, clears the interrupt source.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ADV_TX_INTR</name>
                <description>If this bit is set it indicates ADV packet is transmitted. 
Write to the register with this bit set to 1, clears the interrupt source.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SCAN_RSP_TX_INTR</name>
                <description>If this bit is set it indicates scan response packet transmitted in response to previous scan request packet received.
Write to the register with this bit set to 1, clears the interrupt source.</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SCAN_REQ_RX_INTR</name>
                <description>If this bit is set it indicates scan request packet received.
Write to the register with this bit set to 1, clears the interrupt source.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CONN_REQ_RX_INTR</name>
                <description>If this bit is set it indicates connect request packet is received.
Write to the register with this bit set to 1, clears the interrupt source.</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SLV_CONNECTED</name>
                <description>If this bit is set it indicates that connection is created as slave. 
Write to the register with this bit set to 1, clears the interrupt source.</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ADV_TIMEOUT</name>
                <description>If this bit is set it indicates that the directed advertising event has timed out after 1.28 seconds. Applicable in adv_direct_ind advertising. 
Write to the register with this bit set to 1, clears the interrupt source.</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ADV_ON</name>
                <description>Advertiser procedure is ON in hardware. Indicates that advertiser procedure is ON in hardware.
1 - ON
0 - OFF</description>
                <bitRange>[8:8]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ADV_NEXT_INSTANT</name>
            <description>Advertising next instant.</description>
            <addressOffset>0x24</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFF</resetMask>
            <fields>
              <field>
                <name>ADV_NEXT_INSTANT</name>
                <description>Shows the next start of advertising event with reference to the internal reference clock.</description>
                <bitRange>[15:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SCAN_INTERVAL</name>
            <description>Scan Interval Register</description>
            <addressOffset>0x28</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x10</resetValue>
            <resetMask>0xFFFF</resetMask>
            <fields>
              <field>
                <name>SCAN_INTERVAL</name>
                <description>Scan interval register. Interval between two consecutive scanning events. Firmware sets the scanning interval value to this register before issuing start scan command.
Range: 0x0004 to 0x4000 
Default: 0x0010 (10 ms) 
Time = N * 0.625 msec  
Time Range: 2.5 msec to 10.24 sec.</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SCAN_WINDOW</name>
            <description>Scan window Register</description>
            <addressOffset>0x2C</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x10</resetValue>
            <resetMask>0xFFFF</resetMask>
            <fields>
              <field>
                <name>SCAN_WINDOW</name>
                <description>Duration of scan in a scanning event, which should be less than or equal to scan interval value. Firmware sets the scan window value to this register before issuing start scan command.
Range: 0x0004 to 0x4000 
Default: 0x0010 (10 ms) 
Time = N * 0.625 msec  
Time Range: 2.5 msec to 10.24 sec.</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SCAN_PARAM</name>
            <description>Scanning parameters register</description>
            <addressOffset>0x30</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x3F</resetMask>
            <fields>
              <field>
                <name>TX_ADDR</name>
                <description>Device's own address type. 
1 - addr type is random. 
0 - addr type is public.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SCAN_TYPE</name>
                <description>0x00 - passive scanning.(default) 
0x01 - active scanning. 
0x10 - RFU 
0x11 - RFU</description>
                <bitRange>[2:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SCAN_FILT_POLICY</name>
                <description>The scanner filter policy determines how the scanner processes advertising packets. 
0x00 - Accept advertising packets from any device. 
0x01 - Accept advertising packets from only devices in the whitelist. 
0x10 - RFU 
0x11 - RFU 
Adv_direct_ind packets which are not addressed to this device are ignored.</description>
                <bitRange>[4:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DUP_FILT_EN</name>
                <description>Filter duplicate packets.
1- Duplicate filtering enabled. 
0- Duplicate filtering not enabled.
This field is derived from the LE_set_scan_enable command.</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SCAN_INTR</name>
            <description>Scan interrupt status and Clear register</description>
            <addressOffset>0x38</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x11F</resetMask>
            <fields>
              <field>
                <name>SCAN_STRT_INTR</name>
                <description>If this bit is set it indicates scan window is opened.
Write to the register with this bit set to 1, clears the interrupt source.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SCAN_CLOSE_INTR</name>
                <description>If this bit is set it indicates scan window is closed.
Write to the register with this bit set to 1, clears the interrupt source.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SCAN_TX_INTR</name>
                <description>If this bit is set it indicates scan request packet is transmitted. 
Write to the register with this bit set to 1, clears the interrupt source.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ADV_RX_INTR</name>
                <description>If this bit is set it indicates ADV packet received. Firmware can read the content of the packet from the INIT_SCN_ADV_RX_FIFO.
Write to the register with this bit set to 1, clears the interrupt source.
This interrupt is generated while active/passive scanning upon receiving adv packets.</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SCAN_RSP_RX_INTR</name>
                <description>If this bit is set it indicates SCAN_RSP packet is received. Firmware can read the content of the packet from the INIT_SCN_ADV_RX_FIFO.
Write to the register with this bit set to 1, clears the interrupt source. 
NOTE: This interrupt is generated while active scanning upon receiving scan response packet.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SCAN_ON</name>
                <description>Scan procedure status. 
1 - scan procedure is active. 
0 - scan procedure is not active.</description>
                <bitRange>[8:8]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SCAN_NEXT_INSTANT</name>
            <description>Advertising next instant.</description>
            <addressOffset>0x3C</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFF</resetMask>
            <fields>
              <field>
                <name>NEXT_SCAN_INSTANT</name>
                <description>Shows the instant with respect to internal reference clock of resolution 625 us at which next scanning  event begins.</description>
                <bitRange>[15:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INIT_INTERVAL</name>
            <description>Initiator Interval Register</description>
            <addressOffset>0x40</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFF</resetMask>
            <fields>
              <field>
                <name>INIT_SCAN_INTERVAL</name>
                <description>Initiator interval register. Firmware sets the initiator's scanning interval value to this regis-ter before issuing create connection command. Interval between two consecutive scanning events.
Range: 0x0004 to 0x4000 
Time = N * 0.625 msec  
Time Range: 2.5 msec to 10.24 sec.</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INIT_WINDOW</name>
            <description>Initiator window Register</description>
            <addressOffset>0x44</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFF</resetMask>
            <fields>
              <field>
                <name>INIT_SCAN_WINDOW</name>
                <description>Duration of scan in a scanning event, which should be less than or equal to scan interval value. Firmware sets the scan window value to this register before issuing create connection command.
Range: 0x0004 to 0x4000 
Time = N * 0.625 msec  
Time Range: 2.5 msec to 10.24 sec.</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INIT_PARAM</name>
            <description>Initiator parameters register</description>
            <addressOffset>0x48</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xB</resetMask>
            <fields>
              <field>
                <name>TX_ADDR</name>
                <description>Device' own address type. 
1 - addr type is random. 
0 - addr type is public.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RX_ADDR__RX_TX_ADDR</name>
                <description>Peer address type.
The rx_addr field is updated by the receiver with the address type of the received connectable advertising packet.
1 - addr type is random. 
0 - addr type is public.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>INIT_FILT_POLICY</name>
                <description>The Initiator_Filter_Policy is used to determine whether the White List is used or not.
0 - White list is not used to determine which advertiser to connect to. Instead the Peer_Address_Type and Peer Address fields are used to specify the address type and address of the advertising device to connect to.
1 - White list is used to determine the advertising device to connect to.
Peer_Address_Type and Peer_Address fields are ignored when whitelist is used.</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INIT_INTR</name>
            <description>Scan interrupt status and Clear register</description>
            <addressOffset>0x50</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x17</resetMask>
            <fields>
              <field>
                <name>INIT_INTERVAL_EXPIRE_INTR</name>
                <description>If this bit is set it indicates initiator scan window has started.
Write to the register with this bit set to 1, clears the interrupt source.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>INIT_CLOSE_WINDOW_INR</name>
                <description>If this bit is set it indicates initiator scan window has finished.
Write to the register with this bit set to 1, clears the interrupt source.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>INIT_TX_START_INTR</name>
                <description>If this bit is set it indicates initiator packet (CONREQ) transmission has started.
Write to the register with this bit set to 1, clears the interrupt source.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>MASTER_CONN_CREATED</name>
                <description>If this bit is set it indicates connection is created as master. 
Write to the register with this bit set to 1, clears the interrupt source.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INIT_NEXT_INSTANT</name>
            <description>Initiator next instant.</description>
            <addressOffset>0x54</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFF</resetMask>
            <fields>
              <field>
                <name>INIT_NEXT_INSTANT</name>
                <description>Shows the instant with respect to internal reference clock of resolution 625 us at which next initiator scanning event begins.</description>
                <bitRange>[15:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DEVICE_RAND_ADDR_L</name>
            <description>Lower 16 bit random address of the device.</description>
            <addressOffset>0x58</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFF</resetMask>
            <fields>
              <field>
                <name>DEVICE_RAND_ADDR_L</name>
                <description>Lower 16 bit of 48-bit random address of the device.</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DEVICE_RAND_ADDR_M</name>
            <description>Middle 16 bit random address of the device.</description>
            <addressOffset>0x5C</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFF</resetMask>
            <fields>
              <field>
                <name>DEVICE_RAND_ADDR_M</name>
                <description>Middle 16 bit of 48-bit random address of the device.</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DEVICE_RAND_ADDR_H</name>
            <description>Higher 16 bit random address of the device.</description>
            <addressOffset>0x60</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFF</resetMask>
            <fields>
              <field>
                <name>DEVICE_RAND_ADDR_H</name>
                <description>Higher 16 bit of 48-bit random address of the device.</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>PEER_ADDR_L</name>
            <description>Lower 16 bit address of the peer device.</description>
            <addressOffset>0x68</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFF</resetMask>
            <fields>
              <field>
                <name>PEER_ADDR_L</name>
                <description>Lower 16 bit of 48-bit address of the peer device.</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>PEER_ADDR_M</name>
            <description>Middle 16 bit address of the peer device.</description>
            <addressOffset>0x6C</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFF</resetMask>
            <fields>
              <field>
                <name>PEER_ADDR_M</name>
                <description>Middle 16 bit of 48-bit address of the peer device.</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>PEER_ADDR_H</name>
            <description>Higher 16 bit address of the peer device.</description>
            <addressOffset>0x70</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFF</resetMask>
            <fields>
              <field>
                <name>PEER_ADDR_H</name>
                <description>Higher 16 bit of 48-bit address of the peer device.
The peer address registers are used for multiple purposes. The register is written by firmware to provide the peer address to be used for a hardware procedure. When firmware reads the register, it reads back peer address values updated by hardware. 

While doing directed Advertising, the firmware writes the peer address of the device specified by the Di-rect_Address parameter of the LE_Set_Advertising_Parameters command. 

While device is configured as an initiator without white list filtering, the peer address specified in the peer_address field of the create connection command is programmed into this register, which is used by hard-ware procedures.

While device is configured as an initiator and white list is enabled, firmware can read this register to get the address of the peer device from which connectable ADV packet was received and to which the connection is created. 

When a connection is created as a slave, the firmware can read this register to get the address of the peer de-vice to which connection is created.</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>WL_ADDR_TYPE</name>
            <description>whitelist address type</description>
            <addressOffset>0x78</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>WL_ADDR_TYPE</name>
                <description>8 address type bits corresponding to the device address stored.
1 - Address type is random.
0 - Address type is public.</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>WL_ENABLE</name>
            <description>whitelist valid entry bit</description>
            <addressOffset>0x7C</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>WL_ENABLE</name>
                <description>Stores the valid entry bit corresponding to each of the eight device address stored in the whitelist.
1 - White list entry is Valid
0 - White list entry is Invalid</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>TRANSMIT_WINDOW_OFFSET</name>
            <description>Transmit window offset</description>
            <addressOffset>0x80</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFF</resetMask>
            <fields>
              <field>
                <name>TX_WINDOW_OFFSET</name>
                <description>This is used to determine the first anchor point for the master transmission, from the time of connection creation.
Range: This shall be a multiple of 1.25 ms in the range of 0 ms to connInterval value.</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>TRANSMIT_WINDOW_SIZE</name>
            <description>Transmit window size</description>
            <addressOffset>0x84</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>TX_WINDOW_SIZE</name>
                <description>window_size along with the window_offset is used to calculate the first connection point anchor point for the master.
This shall be a multiple of 1.25 ms in the range of 1.25 ms to the lesser of 10 ms and (connInterval - 1.25 ms).
Values range from 0 to 10 ms.</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DATA_CHANNELS_L0</name>
            <description>Data channel map 0 (lower word)</description>
            <addressOffset>0x88</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFF</resetMask>
            <fields>
              <field>
                <name>DATA_CHANNELS_L0</name>
                <description>This register field indicates which of the data channels are in use. This stores the information for the lower 16 (15:0) data channel indices.
'1' indicates the corresponding data channel is used and '0' indicates the channel is unused.</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DATA_CHANNELS_M0</name>
            <description>Data channel map 0 (middle word)</description>
            <addressOffset>0x8C</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFF</resetMask>
            <fields>
              <field>
                <name>DATA_CHANNELS_M0</name>
                <description>This register field indicates which of the data channels are in use. This stores the information for the middle 16 (32:16) data channel indices.
'1' indicates the corresponding data channel is used and '0' indicates the channel is unused.</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DATA_CHANNELS_H0</name>
            <description>Data channel map 0 (upper word)</description>
            <addressOffset>0x90</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1F</resetMask>
            <fields>
              <field>
                <name>DATA_CHANNELS_H0</name>
                <description>This register field indicates which of the data channels are in use. This stores the information for the upper 5 (36:32) data channel indices.
'1' indicates the corresponding data channel is used and '0' indicates the channel is unused.
Note: The Data channel map 0 and data channel map 1 are two sets of channel maps stored, common for all the connections. At any given time, only two maps can be maintained and the connections will use one of the two sets as indicated by the channel map index field in the CE_CNFG_STS registers specific to the link. Firmware must also manage to update this field along with the map.</description>
                <bitRange>[4:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DATA_CHANNELS_L1</name>
            <description>Data channel map 1 (lower word)</description>
            <addressOffset>0x98</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFF</resetMask>
            <fields>
              <field>
                <name>DATA_CHANNELS_L1</name>
                <description>This register field indicates which of the data channels are in use. This stores the information for the lower 16 (15:0) data channel indices.
'1' indicates the corresponding data channel is used and '0' indicates the channel is unused.</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DATA_CHANNELS_M1</name>
            <description>Data channel map 1 (middle word)</description>
            <addressOffset>0x9C</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFF</resetMask>
            <fields>
              <field>
                <name>DATA_CHANNELS_M1</name>
                <description>This register field indicates which of the data channels are in use. This stores the information for the middle 16 (32:16) data channel indices.
'1' indicates the corresponding data channel is used and '0' indicates the channel is unused.</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DATA_CHANNELS_H1</name>
            <description>Data channel map 1 (upper word)</description>
            <addressOffset>0xA0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1F</resetMask>
            <fields>
              <field>
                <name>DATA_CHANNELS_H1</name>
                <description>This register field indicates which of the data channels are in use. This stores the information for the upper 5 data channel indices.
'1' indicates the corresponding data channel is used and '0' indicates the channel is unused.
Note: The Data channel map 0 and data channel map 1 are two sets of channel maps stored, common for all the connections. At any given time, only two maps can be maintained and the connections will use one of the two sets as indicated by the channel map index field in the CE_CNFG_STS registers specific to the link. Firmware must also manage to update this field along with the map.</description>
                <bitRange>[4:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CONN_INTR</name>
            <description>Connection interrupt status and Clear register</description>
            <addressOffset>0xA8</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFF</resetMask>
            <fields>
              <field>
                <name>CONN_CLOSED</name>
                <description>If this bit is set it indicates that the link is disconnected.
If this bit is written with 1, it clears the connection updated interrupt.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CONN_ESTB</name>
                <description>If this bit is set it indicates that the connection has been established. The bit is also set when a connection update procedure is complet-ed, at the start of the first anchor point with the updated parameters.
If this bit is written with 1, it clears the connection established interrupt.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>MAP_UPDT_DONE</name>
                <description>If this bit is set it indicates that the channel map update is completed at the instant specified by the firmware.
If this bit is written with 1, it clears the map update done interrupt.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>START_CE</name>
                <description>If this bit is set it indicates that the connection event started interrupt has happened.
If this bit is written with 1, it clears the connection event started interrupt.</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CLOSE_CE</name>
                <description>If this bit is set it indicates that the connection event closed interrupt has happened.
If this bit is written with 1, it clears the connection event closed interrupt.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CE_TX_ACK</name>
                <description>If this bit is set it indicates that the connection event transmission acknowledgement is received for the previous non-empty packet transmitted.
If this bit is written with 1, it clears the ce transmission acknowledgement       interrupt.</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CE_RX</name>
                <description>If this bit is set it indicates that a packet is received in the connection event.
If this bit is written with 1, it clears the connection event received interrupt.</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CON_UPDT_DONE</name>
                <description>This bit is set when the last connection event with previous connec-tion parameters is reached.  The bit is set immediately after the re-ceive operation at the anchor point of the last connection event.
If this bit is written with 1, it clears the connection updated interrupt.</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DISCON_STATUS</name>
                <description>Reason for disconnect - indicates the reason the link is disconnected by hardware.
001 - connection failed to be established
010 - supervision timeout 
011 - kill connection by host
100 - kill connection after ACK transmitted
101 - PDU response timer expired</description>
                <bitRange>[10:8]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>RX_PDU_STATUS</name>
                <description>Status of PDU received. This information is valid along with receive interrupt.
xx1 - Bad Packet (packet with CRC error)
000 - empty PDU
010 -  new data (non-empty) PDU
110 - Duplicate Packet</description>
                <bitRange>[13:11]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PING_TIMER_EXPIRD_INTR</name>
                <description>If this is set, it indicates that ping timer has expired.</description>
                <bitRange>[14:14]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PING_NEARLY_EXPIRD_INTR</name>
                <description>If this is set, it indicates that ping timer has nearly expired.</description>
                <bitRange>[15:15]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CONN_STATUS</name>
            <description>Connection channel status</description>
            <addressOffset>0xAC</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xF000</resetMask>
            <fields>
              <field>
                <name>RECEIVE_PACKET_COUNT</name>
                <description>This field stores the count for the number of receive packets in the receive FIFO that are still not ready by firmware.
The counter value is incremented by hardware for every good packet it stores in the FIFO.
After firmware reads a packet, it decrements the counter by issuing the PACKET_RECEIVED command from the commander.</description>
                <bitRange>[15:12]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CONN_INDEX</name>
            <description>Connection Index register</description>
            <addressOffset>0xB0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFF</resetMask>
            <fields>
              <field>
                <name>CONN_INDEX</name>
                <description>This field is used to index the multiple connections existing. Range is 0 to maximum number of connections supported.
For a single connection device, conn_index is 0.</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>WAKEUP_CONFIG</name>
            <description>Wakeup configuration</description>
            <addressOffset>0xB8</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFCFF</resetMask>
            <fields>
              <field>
                <name>OSC_STARTUP_DELAY</name>
                <description>Oscillator stabilization/startup delay. This is in X.Y for-mat where X is in terms of number of BT slots (625 us) and Y is in terms of number of clock periods of 16KHz clock input, required for RF oscillator to stabilize the clock output to the controller on its output pin, after oscillator is turned ON. In this period the clock is as-sumed to be unstable, and so the controller does not turn on the clock to internal logic till this period is over. This means, the wake up from deep sleep mode must account for this delay before the wakeup instant.
Osc_startup_delay[7:5]  is  number of slots(625us)
Osc_startup_delay[4:0 is number of clock periods of 16KHz clock
(Warning: Min. value of Osc_startup_delay [4:0] sup-ported is 1 and Max. value is 9. Therefore programma-ble range is 1 to 9)</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DSM_OFFSET_TO_WAKEUP_INSTANT</name>
                <description>Number of 'slots' before the wake up instant before which the hardware needs to exit from deep sleep mode. The slot is of 0.625ms period. This is a onetime configuration field, which is used every time hardware does an auto-wakeup before the next wakeup instant.</description>
                <bitRange>[15:10]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>WAKEUP_CONTROL</name>
            <description>Wakeup control</description>
            <addressOffset>0xC0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFF</resetMask>
            <fields>
              <field>
                <name>WAKEUP_INSTANT</name>
                <description>Instant, with reference to the internal 16-bit clock reference, at which the hardware must wakeup from deep sleep mode. This is calculated by firmware based on the next closest instant where a controller operation is required (like advertiser/scanner).  Firmware reads the next instant of the procedures in the corresponding *_NEXT_INSTANT registers. This value is used only when hardware auto wakeup from deep sleep mode is enabled in the clock control register.
Note: it is recommended to program wakeup_instant such a way that the actual instant to wakeup shall be at least two counts (two slots of 625 us) ahead of reference clock when entering DSM. The actual instant to wakeup is 'wakeup_instant - dsm_offset_to_wakeup_instant - osc_startup_delay, and it shall be greater than 'reference clock + 2'</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CLOCK_CONFIG</name>
            <description>Clock control</description>
            <addressOffset>0xC4</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x80</resetValue>
            <resetMask>0xD7FF</resetMask>
            <fields>
              <field>
                <name>ADV_CLK_GATE_EN</name>
                <description>Advertiser block clock gate enable. 1 - enable, 0 -  disable.
Enables gating of clock to the advertiser module (llh_adv) in hardware. If 1, the sleep mode logic can control the clock gate to shutdown/wakeup the clock to the module. If 0, the logic has no control and clock to the module is always turned ON.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SCAN_CLK_GATE_EN</name>
                <description>Scan block clock gate enable. 1 - enable, 0 -  disable.
Enables gating of clock to the scanner module (llh_scan) in hardware. If 1, the sleep mode logic can control the clock gate to shutdown/wakeup the clock to the module. If 0, the logic has no control and clock to the module is always turned ON.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>INIT_CLK_GATE_EN</name>
                <description>Initiator block clock gate enable. 1 - enable, 0 -  disable.
Enables gating of clock to the initiator module (llh_init). If 1, the sleep mode logic can control the clock gate to shutdown/wakeup the clock to the module. If 0, the logic has no control and clock to the module is always turned ON.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CONN_CLK_GATE_EN</name>
                <description>Connection block clock gate enable. 1 - enable, 0 -  disable.
Enables gating of clock to the connection module (llh_connch_top) in hardware. If 1, the sleep mode logic can control the clock gate to shutdown/wakeup the clock to the engine. If 0, the logic has no control and clock to the module is always turned ON.</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CORECLK_GATE_EN</name>
                <description>Core clock gate enable. 1 - enable, 0 -  disable.
Enables gating of clock to the llh_core module in hard-ware. If 1, the sleep mode/deep sleep mode logic can control the clock gate to shutdown/wakeup the clock to the module. If 0, the logic has no control and clock is always turned ON.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SYSCLK_GATE_EN</name>
                <description>Sysclk gate enable. 1- enable, 0 - disable.
Enables clock gating of system clock input to the link layer. If 1, it enables the DSM logic to control the clock gate for system clock input from pin.  If 0, the DSM logic has no control and the system clock is always ON.</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PHY_CLK_GATE_EN</name>
                <description>Digital PHY clock enable. 1- enable, 0-disable.
Enable the Digital PHY to shutdown the clock. When 1, it indicates that controller has an upcoming activity so PHY clock must be turned ON. When 0, it indicates inactivity in the controller.</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>LLH_IDLE</name>
                <description>Indicates if hardware is doing any transmit/receive operation. This information is used by firmware to decide to program the hardware into deep sleep mode.
1 - LL hardware is idle.
0 - LL hardware is busy. In this case LL hardware will not enter deep sleep mode, even if firmware gives an enter DSM command. (In this situation hardware generates dsm exit interrupt to inform firmware that DSM entry was not successful).</description>
                <bitRange>[7:7]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>LPO_CLK_FREQ_SEL</name>
                <description>Clock frequency select. 0 - 32KHz, 1 - 32.768KHz.
Base frequency of the sleep_clk input used for generat-ing the internal reference clock of approximate 16Khz frequency.</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>LPO_SEL_EXTERNAL</name>
                <description>Select external sleep clock. 1 - External clock, 0 - inter-nal generated clock.
The field is used to select either the low power clock in-put on sleep_clk input pin(of frequency 16.384KHz) di-rectly to run the DSM logic or to use the internal gener-ated reference clock(of 16KHz) for the same.</description>
                <bitRange>[9:9]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SM_AUTO_WKUP_EN</name>
                <description>Enable sleep mode auto wakeup enable. 1- enable, 0 - disable.
Enables hardware to automatically wakeup from sleep mode at the instant = wakeup_instant - sm_offset_to_wakeup_instant. The wakeup_insant is the field in the wakeup control register described earlier. The sm_offset_to_wakeup_instant value is the field described in the wakeup configuration register.</description>
                <bitRange>[10:10]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SM_INTR_EN</name>
                <description>Enable SM exit interrupt. 1 - enable, 0 - disable.
Enables hardware to generate an interrupt while exiting sleep mode - irrespective of whether it is initiated by hardware or firmware. The interrupt is captured and stored till it gets cleared. Disabling this bit mask the sleep mode exit event from hardware &amp; firmware.</description>
                <bitRange>[12:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SLEEP_MODE_EN</name>
                <description>Enable sleep mode. 1 - enable, 0 - disable.
Enables hardware to control sleep mode operation.</description>
                <bitRange>[14:14]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DEEP_SLEEP_MODE_EN</name>
                <description>Enable deep sleep mode. 1 - enable, 0 - disable.
Enables hardware logic related to deep sleep mode to control the deep sleep mode operation. If disabled, the related logic is not executed and hardware cannot enter deep sleep mode.</description>
                <bitRange>[15:15]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>TIM_COUNTER_L</name>
            <description>Reference Clock</description>
            <addressOffset>0xC8</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFF</resetMask>
            <fields>
              <field>
                <name>TIM_REF_CLOCK</name>
                <description>16-bit internal reference clock. The clock is a free run-ning clock, incremented by a 0.625ms periodic pulse. It is used as a reference clock to derive all the timing required as per protocol.</description>
                <bitRange>[15:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>POC_REG__TIM_CONTROL</name>
            <description>BLE Time Control</description>
            <addressOffset>0xD8</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xF8</resetMask>
            <fields>
              <field>
                <name>BB_CLK_FREQ_MINUS_1</name>
                <description>LLH clock configuration. The clock frequency of the clock input to this design is configured in this register. This is used to derive a 1MHz clock.</description>
                <bitRange>[7:3]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ADV_TX_DATA_FIFO</name>
            <description>Advertising data transmit FIFO. Access ADVCH_TX_FIFO.</description>
            <addressOffset>0xE0</addressOffset>
            <size>32</size>
            <access>write-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFF</resetMask>
            <fields>
              <field>
                <name>ADV_TX_DATA</name>
                <description>IO mapped FIFO of depth 16 (2 byte wide), to store ADV data of maximum length 31 bytes for transmitting. Firmware writes consecutive words by writing to the same address location.
Note: ADV_TX_DATA_FIFO and ADV_SCN_RSP_TX_FIFO shares same physical FIFO of depth 32. 16 locations for each FIFO are allocated.</description>
                <bitRange>[15:0]</bitRange>
                <access>write-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ADV_SCN_RSP_TX_FIFO</name>
            <description>Advertising  scan response data transmit FIFO. Access ADVCH_TX_FIFO.</description>
            <addressOffset>0xE8</addressOffset>
            <size>32</size>
            <access>write-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFF</resetMask>
            <fields>
              <field>
                <name>SCAN_RSP_DATA</name>
                <description>IO mapped FIFO of depth 16 (2 byte wide), to store scan response data of maximum length 31 bytes for transmitting. Firmware writes consecutive words by writing to the same location.
Note: ADV_TX_DATA_FIFO and ADV_SCN_RSP_TX_FIFO shares same physical FIFO of depth 32. 16 locations for each FIFO are allocated.</description>
                <bitRange>[15:0]</bitRange>
                <access>write-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INIT_SCN_ADV_RX_FIFO</name>
            <description>advertising scan response data receive data FIFO. Access ADVRX_FIFO.</description>
            <addressOffset>0xF8</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFF</resetMask>
            <fields>
              <field>
                <name>ADV_SCAN_RSP_RX_DATA</name>
                <description>IO mapped FIFO of depth 64, to store ADV and SCAN_RSP header and payload received by the scanner. The RSSI value at the time of reception of this packet is also stored. Firmware reads from the same address to read out consecutive words of data.
Note: The 16 bit header is first loaded to the advertise channel data receive FIFO followed by the payload data and then 16 bit RSSI.</description>
                <bitRange>[15:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CONN_INTERVAL</name>
            <description>Connection Interval</description>
            <addressOffset>0x100</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFF</resetMask>
            <fields>
              <field>
                <name>CONNECTION_INTERVAL</name>
                <description>The value configured in this register determines the spacing be-tween the connection events. 
This shall be a multiple of 1.25 ms in the range of 7.5 ms to 4.0 s.</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SUP_TIMEOUT</name>
            <description>Supervision timeout</description>
            <addressOffset>0x104</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFF</resetMask>
            <fields>
              <field>
                <name>SUPERVISION_TIMEOUT</name>
                <description>This field defines the maximum time between two received Data packet PDUs before the connection is considered lost. 
This shall be a multiple of 10 ms in the range of 100 ms to 32.0 s and it shall be larger than (1+connSlaveLatency)*connInterval.</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SLAVE_LATENCY</name>
            <description>Slave Latency</description>
            <addressOffset>0x108</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFF</resetMask>
            <fields>
              <field>
                <name>SLAVE_LATENCY</name>
                <description>The value configured in this field defines the number of consecutive connection events that the slave device is not required to listen for master.
The value of connSlaveLatency should not cause a Supervision Timeout.
This shall be an integer in the range of 0 to ((connSupervision Timeout/connInterval)-1). connSlaveLatency shall also be less than 500.</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CE_LENGTH</name>
            <description>Connection event length</description>
            <addressOffset>0x10C</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFF</resetMask>
            <fields>
              <field>
                <name>CONNECTION_EVENT_LENGTH</name>
                <description>N/A</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>PDU_ACCESS_ADDR_L_REGISTER</name>
            <description>Access address (lower)</description>
            <addressOffset>0x110</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFF</resetMask>
            <fields>
              <field>
                <name>PDU_ACCESS_ADDRESS_LOWER_BITS</name>
                <description>This field defines the lower 16 bits of the access address for each Link layer connection between any two devices.</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>PDU_ACCESS_ADDR_H_REGISTER</name>
            <description>Access address (upper)</description>
            <addressOffset>0x114</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFF</resetMask>
            <fields>
              <field>
                <name>PDU_ACCESS_ADDRESS_HIGHER_BITS</name>
                <description>This field defines the higher 16 bits of the access address for each Link layer connection between any two devices.</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CONN_CE_INSTANT</name>
            <description>Connection event instant</description>
            <addressOffset>0x118</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFF</resetMask>
            <fields>
              <field>
                <name>CE_INSTANT</name>
                <description>This is the value of the free running Connection Event counter when the new parameters of 'connection update' and/or 'Channel map update' will be effective.
Range : 0x0000 to 0xFFFF</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CE_CNFG_STS_REGISTER</name>
            <description>connection configuration &amp; status register</description>
            <addressOffset>0x11C</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xF5FF</resetMask>
            <fields>
              <field>
                <name>DATA_LIST_INDEX_LAST_ACK_INDEX</name>
                <description>Data list index for start/resume. This field must be valid along with data_list_head_up and indicate the transmit packet buffer index at which the data is loaded.
The default number of buffers in the IP is 5,but may be customized for a customer. The buffers are in-dexed 0 to 4.
Hardware will start the next data transmission from the index indicated by this field.</description>
                <bitRange>[3:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DATA_LIST_HEAD_UP</name>
                <description>Update the first packet buffer index ready for transmis-sion to start/resume data transfer after a pause.
The bit must be toggled every time the firmware needs to indicate the start/resume. This requires a read modify write operation.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>MAS_SLV</name>
                <description>mas_slv  bit set to '1' indicates that device is confi-gured as a master or a slave.
1 - master, 
0 - slave.</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>MD</name>
                <description>MD bit set to '1' indicates device has more data to be sent.</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>MAP_INDEX__CURR_INDEX</name>
                <description>Written by firmware to select the map index to be used by hardware for this connection. 
1 - use channel map register set 1. 
0 - use channel map register set 0.
When firmware reads this field, it returns the current map index being used in hardware.</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PAUSE_DATA</name>
                <description>Pause data. 
1 - pause data, 
0 - do not pause.
Pause the data transfer on the connection. The current_pdu_index in hardware does not move to next in-dex until pause_data is cleared.</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CONN_ACTIVE</name>
                <description>This bit is '1' whenever the connection is active.</description>
                <bitRange>[10:10]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>CURRENT_PDU_INDEX</name>
                <description>The index of the transmit packet buffer that is currently in transmission/waiting for transmission.</description>
                <bitRange>[15:12]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>NEXT_CE_INSTANT</name>
            <description>Next connection event instant</description>
            <addressOffset>0x120</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFF</resetMask>
            <fields>
              <field>
                <name>NEXT_CE_INSTANT</name>
                <description>16-bit internal reference clock value at which the next connection event will occur on a connection. The connection index register must be programmed with index of the connection, before reading the register.</description>
                <bitRange>[15:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CONN_CE_COUNTER</name>
            <description>connection event counter</description>
            <addressOffset>0x124</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFF</resetMask>
            <fields>
              <field>
                <name>CONNECTION_EVENT_COUNTER</name>
                <description>This is the free running counter, connEventCounter as defined by Bluetooth spec.
Firmware will read the instantaneous Event counter from this register, during connection update and channel map update procedure. Firmware will use this value to calculate the instant from which the new parameters (for connection update and channel map update) will be effective.</description>
                <bitRange>[15:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DATA_LIST_SENT_UPDATE__STATUS</name>
            <description>data list sent update and status</description>
            <addressOffset>0x128</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x9F</resetMask>
            <fields>
              <field>
                <name>LIST_INDEX__TX_SENT_3_0</name>
                <description>Write:Indicates the buffer index for which the SENT bit is being updated by firmware.
The default number of buffers in the IP is 5. The index range is 0-4.

Read: Reads TX_SENT[3:0].
The bits in this field indicate the status of the SENT bit in the hard-ware for each packet buffer. The bit values are
1 - queued
0 - no packet / packet ack received by hardware 
Example1: If the read value is : 0x03, then packets in buffer 0 and buffer 1 are in the queue to be transmitted. All the other FIFOs are empty or hardware has cleared them after receiving acknowledgement.</description>
                <bitRange>[3:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TX_SENT_4</name>
                <description>Read: Reads TX_SENT[4].
The bits in this field indicate the status of the SENT bit in the hard-ware for each packet buffer. The bit values are
1 - queued
0 - no packet / packet ack received by hardware 
Example1: If the read value is : 0x03, then packets in buffer 0 and buffer 1 are in the queue to be transmitted. All the other FIFOs are empty or hardware has cleared them after receiving acknowledgement.
NOTE:
The SENT status bit and ACK status bit have to be taken together to understand the meaning of packet status. The table below describes how the two bits are sequentially updated by either hardware/firmware to complete one data transmission.
SENT ACK  Description
0         0      Buffer is empty. No packet is queued in the buffer
1         0      Packet is queued by firmware.
1         1      Packet is transmitted by hardware. Hardware is waiting for acknowledgement.
0         1      Hardware has received ACK. Firmware has not yet processed the ACK.
0         0      Firmware has processed the ack. The buffer is again empty.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>SET_CLEAR</name>
                <description>Write: Used to set the SENT bit in hardware for the selected packet buffer.
1 - packet queued
When firmware has a packet to send, firmware first loads the next available packet buffer. Then the hardware SENT bit is set by writing 1 to this bit field along with the list_index field that identified the buffer index.  This indicates that a packet has been queued in the data buffer for sending. This packet is now ready to be transmitted. 
The SENT bit in hardware is cleared by hardware only when it has received an acknowledgement from the remote device. 
Firmware typically does not clear the bit. However, It only clears the bit on its own if it needs to 'flush' a packet from the buffer, without waiting to receive acknowledgement from the remote device, firmware clears BIT7 along with the list_index specified.</description>
                <bitRange>[7:7]</bitRange>
                <access>write-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DATA_LIST_ACK_UPDATE__STATUS</name>
            <description>data list ack update and status</description>
            <addressOffset>0x12C</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x9F</resetMask>
            <fields>
              <field>
                <name>LIST_INDEX__TX_ACK_3_0</name>
                <description>Write: Indicates the buffer index for which the ACK bit is being updated by firmware.
The default number of buffers in the IP is 5. The index range is 0-4.

Read: Reads TX_ACK[3:0]
If a particular bit is set, then the packet in the selected buffer has been transmitted (at least once) by the hardware and hardware is waiting for acknowledgement. 
Example1 : If the read value is : 0x03, then packets in FIFO-0 and FIFO-1 are acknowledged by the remote device. These acknowledgements are pending to be processed by firmware.
Example2 : If the read value is : 0x02, then packet FIFO-1 is acknowledged by the remote device. This acknowledgement is pending to be processed by firmware.</description>
                <bitRange>[3:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TX_ACK_4</name>
                <description>Reads TX_ACK[4]
If a particular bit is set, then the packet in the selected buffer has been transmitted (at least once) by the hardware and hardware is waiting for acknowledgement. 
Example1 : If the read value is : 0x03, then packets in FIFO-0 and FIFO-1 are acknowledged by the remote device. These acknowledgements are pending to be processed by firmware.
Example2 : If the read value is : 0x02, then packet FIFO-1 is acknowledged by the remote device. This acknowledgement is pending to be processed by firmware.
NOTE:
The SENT status bit and ACK status bit have to be taken together to understand the meaning of packet status. The table below describes how the two bits are sequentially updated by either hardware/firmware to complete one data transmission.
SENT ACK  Description
0         0      Buffer is empty. No packet is queued in the buffer
1         0      Packet is queued by firmware.
1         1      Packet is transmitted by hardware. Hardware is waiting for acknowledgement.
0         1      Hardware has received ACK. Firmware has not yet processed the ACK.
0         0      Firmware has processed the ack. The buffer is again empty.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>SET_CLEAR</name>
                <description>Write: Firmware uses the field to clear and ACK bit in the hardware to indicate that the acknowledgement for the transmit packet has been received and processed by firmware.
Firmware clears the ACK bit in the hardware by writing in this register only after the acknowledgement is processed successfully by firmware.
For clearing ack for a packet transmitted in fifo-index : '3', firm-ware will write '3' in the 'list-index' field and set this bit (BIT7) to 0. 
This is the indication that the corresponding packet buffer identi-fied by List-Index is cleared of previous transmission and can be re-used for another packet from now on.
The ACK bit in hardware is set by hardware when it has success-fully transmitted a packet.</description>
                <bitRange>[7:7]</bitRange>
                <access>write-only</access>
              </field>
            </fields>
          </register>
          <register>
            <dim>5</dim>
            <dimIncrement>4</dimIncrement>
            <name>DATA_MEM_DESCRIPTOR[%s]</name>
            <description>Data buffer descriptor 0 to 4</description>
            <addressOffset>0x140</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x7F</resetMask>
            <fields>
              <field>
                <name>LLID</name>
                <description>N/A</description>
                <bitRange>[1:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DATA_LENGTH</name>
                <description>This field indicates the length of the data packet.
Range 0x0 to 0xF.</description>
                <bitRange>[6:2]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>WINDOW_WIDEN_INTVL</name>
            <description>Window widen for interval</description>
            <addressOffset>0x160</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0xA</resetValue>
            <resetMask>0xFFF</resetMask>
            <fields>
              <field>
                <name>WINDOW_WIDEN_INTVL</name>
                <description>This value defines the increased listening time for the slave.
The window widening  shall be smaller than ((connInterval/2)-T_IFS us)
This value is calculated by firmware based on the drift, the connec-tion interval value. The value is the unit widening value for one con-nection interval duration. In case of slave latency, this value is accu-mulated till the next anchor point at which the slave will listen.</description>
                <bitRange>[11:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>WINDOW_WIDEN_WINOFF</name>
            <description>Window widen for offset</description>
            <addressOffset>0x164</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0xA</resetValue>
            <resetMask>0xFFF</resetMask>
            <fields>
              <field>
                <name>WINDOW_WIDEN_WINOFF</name>
                <description>This field stores the additional number of microseconds the slave must extend its listening window to listen for a master packet. This value is calculated based on the window offset value. This is used at connection setup directly. During connection setup, this value is added with window_widen_intvl register value to calculate the win-dow widening size.</description>
                <bitRange>[11:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>LE_RF_TEST_MODE</name>
            <description>Direct Test Mode control</description>
            <addressOffset>0x170</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFF</resetMask>
            <fields>
              <field>
                <name>TEST_FREQUENCY</name>
                <description>N = (F - 2402) / 2
Range: 0x00 - 0x27. Frequency Range : 2402 MHz to 2480 MHz</description>
                <bitRange>[5:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TEST_TYPE</name>
                <description>1 - DTM test ON
0 - DTM test OFF</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PKT_PAYLOAD</name>
                <description>N/A</description>
                <bitRange>[9:7]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TEST_LENGTH</name>
                <description>N/A</description>
                <bitRange>[15:10]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DTM_RX_PKT_COUNT</name>
            <description>Direct Test Mode receive packet count</description>
            <addressOffset>0x174</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFF</resetMask>
            <fields>
              <field>
                <name>RX_PACKET_COUNT</name>
                <description>Number of packets received in receive test mode.</description>
                <bitRange>[15:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>TXRX_HOP</name>
            <description>Channel Address register</description>
            <addressOffset>0x188</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x7F7F</resetMask>
            <fields>
              <field>
                <name>HOP_CH_TX</name>
                <description>Transmit channel index. Channel index on which previous packet is transmitted.</description>
                <bitRange>[6:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>HOP_CH_RX</name>
                <description>Receive channel index. Channel index on which previous packet is received.</description>
                <bitRange>[14:8]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>TX_RX_ON_DELAY</name>
            <description>Transmit/Receive data delay</description>
            <addressOffset>0x190</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFF</resetMask>
            <fields>
              <field>
                <name>RXON_DELAY</name>
                <description>Receive delay - Delay from start of receive to expected first bit of receive packet at the controller. Used to control the turn on time of radio to optimize on power. The delay is in resolution of 1 microsecond.</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TXON_DELAY</name>
                <description>Transmit delay - Delay from start of transmit to transmission of first bit on air. It is used to control the T_IFS. The delay is in resolution of 1 microsecond.</description>
                <bitRange>[15:8]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DEV_PUB_ADDR_L</name>
            <description>Device public address lower register</description>
            <addressOffset>0x1C0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x3412</resetValue>
            <resetMask>0xFFFF</resetMask>
            <fields>
              <field>
                <name>DEV_PUB_ADDR_L</name>
                <description>Lower 16 bit of 48-bit public address of the device.</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DEV_PUB_ADDR_M</name>
            <description>Device public address middle register</description>
            <addressOffset>0x1C4</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x56</resetValue>
            <resetMask>0xFFFF</resetMask>
            <fields>
              <field>
                <name>DEV_PUB_ADDR_M</name>
                <description>Middle 16 bit of 48-bit public address of the device.</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DEV_PUB_ADDR_H</name>
            <description>Device public address higher register</description>
            <addressOffset>0x1C8</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFF</resetMask>
            <fields>
              <field>
                <name>DEV_PUB_ADDR_H</name>
                <description>Higher 16 bit of 48-bit public address of the device.</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ADV_CH_TX_POWER</name>
            <description>Advetising channel transmit power</description>
            <addressOffset>0x1CC</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x874F</resetValue>
            <resetMask>0xFFFF</resetMask>
            <fields>
              <field>
                <name>ADV_TRANSMIT_POWER</name>
                <description>Size: 1 Octet (signed integer)
Range: -20 &lt;= N &lt;= 10
Units: dBm
Accuracy: +/- 4 dBm   in general.
In implementation this is a radio specific value.</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>OFFSET_TO_FIRST_INSTANT</name>
            <description>Offset to first instant</description>
            <addressOffset>0x1D0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x6</resetValue>
            <resetMask>0xFFFF</resetMask>
            <fields>
              <field>
                <name>OFFSET_TO_FIRST_EVENT</name>
                <description>The offset w.r.t the internal reference clock at which instant the first event occurs.
This register will give flexibility to the firmware to position the con-nection at a desired point with respect to the internal free running clock. It is optional to be updated by firmware. This is not updated in the current firmware.</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ADV_CONFIG</name>
            <description>Advertiser configuration register</description>
            <addressOffset>0x1D4</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x20FF</resetValue>
            <resetMask>0xF9FF</resetMask>
            <fields>
              <field>
                <name>ADV_STRT_EN</name>
                <description>Enable advertising event start interrupt.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ADV_CLS_EN</name>
                <description>Enable advertising event stop interrupt.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ADV_TX_EN</name>
                <description>Enable adv packet transmitted interrupt.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SCN_RSP_TX_EN</name>
                <description>Enable scan response packet transmitted interrupt.</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ADV_SCN_REQ_RX_EN</name>
                <description>Enable scan request packet received interrupt.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ADV_CONN_REQ_RX_EN</name>
                <description>Enable connect request packet received interrupt.</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SLV_CONNECTED_EN</name>
                <description>Enable slave connected interrupt.</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ADV_TIMEOUT_EN</name>
                <description>Enable adv_timeout interrupt. Applicable in adv_direct_ind advertising.</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ADV_RAND_DISABLE</name>
                <description>Disable randomization of adv interval. When disabled, interval is same as programmed in adv_interval register.</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ADV_PKT_INTERVAL</name>
                <description>Time between the beginning of two consecutive advertising PDU's.
Time = N * 0.625 msec
Time Range: &lt;=10msec.</description>
                <bitRange>[15:11]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SCAN_CONFIG</name>
            <description>Scan configuration register</description>
            <addressOffset>0x1D8</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0xE01F</resetValue>
            <resetMask>0xE81F</resetMask>
            <fields>
              <field>
                <name>SCN_STRT_EN</name>
                <description>Enable scan event start interrupt.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SCN_CLOSE_EN</name>
                <description>Enable scan event close interrupt.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SCN_TX_EN</name>
                <description>Enable scan request packet transmitted interrupt.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ADV_RX_EN</name>
                <description>Enable adv packet received interrupt .</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SCN_RSP_RX_EN</name>
                <description>Enable scan_rsp packet received  interrupt .</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>BACKOFF_ENABLE</name>
                <description>Enable random backoff feature in scanner.
1 - enable
0 - disable</description>
                <bitRange>[11:11]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SCAN_CHANNEL_MAP</name>
                <description>Advertising channels that are enabled for scanning operation.
Bit 15: setting 1 - enables channel 39 for use.
Bit 14: setting 1 - enables channel 38 for use.
Bit 13: setting 1 - enables channel 37 for use.</description>
                <bitRange>[15:13]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INIT_CONFIG</name>
            <description>Initiator configuration register</description>
            <addressOffset>0x1DC</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xE017</resetMask>
            <fields>
              <field>
                <name>INIT_STRT_EN</name>
                <description>Enable Initiator event start interrupt.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>INIT_CLOSE_EN</name>
                <description>Enable Initiator event close interrupt.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CONN_REQ_TX_EN</name>
                <description>Enables connection request packet transmission start interrupt.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CONN_CREATED</name>
                <description>Enable master connection created interrupt</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>INIT_CHANNEL_MAP</name>
                <description>Advertising channels that are enabled for initiator scanning operation.
Bit 15: setting 1 - enables channel 39 for use.
Bit 14: setting 1 - enables channel 38 for use.
Bit 13: setting 1 - enables channel 37 for use.</description>
                <bitRange>[15:13]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CONN_CONFIG</name>
            <description>Connection configuration register</description>
            <addressOffset>0x1E0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0xE11F</resetValue>
            <resetMask>0xF9FF</resetMask>
            <fields>
              <field>
                <name>RX_PKT_LIMIT</name>
                <description>Defines a limit for the number of Rx packets that can be re-ceived by the LLH. Default maximum value is 0xF.Minimum value shall be '1' or no packet will be stored in the Rx FIFO.</description>
                <bitRange>[3:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RX_INTR_THRESHOLD</name>
                <description>This register field allows setting a threshold for the packet received interrupt to the firmware.
For example if the value programmed is
0x2 - then HW will generate interrupt only on receiving the second packet. 
In any case if the received number of packets in a conn event is less than the threshold or there are still packets (less than threshold) pending in the Rx FIFO, HW will generate the interrupt at the ce_close.
Min value possible is 1. Max value depends on the Rx FIFO capacity.</description>
                <bitRange>[7:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>MD_BIT_CLEAR</name>
                <description>This register field indicates whether the MD (More Data) bit needs to be controlled by 'software' or, 'hardware and soft-ware logic combined'.
1 - MD bit is exclusively controlled by software, ie based on status of CE_CNFG_STS_REGISTER[6] - md bit.
0 - MD Bit in the transmitted pdu is controlled by software and hardware logic. MD bit is set in transmitted packet, only if the software has set the md bit in CE_CNFG_STS_REGISTER[6] and either of the following conditions is true,
a) If there are packets queued for transmission.
b) If there is an acknowledgement awaited from the remote side for the packet transmitted.</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DSM_SLOT_VARIANCE</name>
                <description>This bit configures the DSM slot counting mode.
0 - The DSM slot count variance with respect to actual time is less than 1 slot
1 - The DSM slot count variance with respect to actual time is more than 1 slot &amp;less that 2 slots</description>
                <bitRange>[11:11]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SLV_MD_CONFIG</name>
                <description>This bit is set to configure the MD bit control when IUT is in slave role.
1 - MD bit will be decided on packet pending status
0 - MD bit will be decided on packet queued in next buffer status
This bit has effect only when 'CONN_CONFIG.md_bit_ctr' bit is not set .</description>
                <bitRange>[12:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EXTEND_CU_TX_WIN</name>
                <description>This bit is used to enable/disable extending the additional rx window on slave side during connection update in event of packet miss at the update instant.
1 - Enable
0 - Disable</description>
                <bitRange>[13:13]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>MASK_SUTO_AT_UPDT</name>
                <description>This bit is used to enable/disable masking of internal hardware supervision timeout trigger when switching from old connection parameters to new parameters. 
1 - Enable
0 - Disable</description>
                <bitRange>[14:14]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CONN_REQ_1SLOT_EARLY</name>
                <description>This bit is used to enable extension of the Conn Request to arbiter to 1 slot early. When enabled the request length is 2 slots.
1 - Enable
0 - Disable</description>
                <bitRange>[15:15]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CONN_CH_TX_POWER</name>
            <description>Connection channel transmit power</description>
            <addressOffset>0x1E4</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFF</resetMask>
            <fields>
              <field>
                <name>CONNCH_TRANSMIT_POWER</name>
                <description>Transmit power to be used for all packets transmitted on the connection channel.</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CONN_PARAM1</name>
            <description>Connection parameter 1</description>
            <addressOffset>0x1E8</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFF</resetMask>
            <fields>
              <field>
                <name>SCA_PARAM</name>
                <description>Sleep Clock Accuracy</description>
                <bitRange>[2:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>HOP_INCREMENT_PARAM</name>
                <description>Hop increment for connection channel.</description>
                <bitRange>[7:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CRC_INIT_L</name>
                <description>This field defines the lower byte (7:0) of the CRC initialization vector.</description>
                <bitRange>[15:8]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CONN_PARAM2</name>
            <description>Connection parameter 2</description>
            <addressOffset>0x1EC</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFF</resetMask>
            <fields>
              <field>
                <name>CRC_INIT_H</name>
                <description>This field defines the upper two bytes (23:8) of the CRC initialization vector.</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CONN_INTR_MASK</name>
            <description>Connection Interrupt mask</description>
            <addressOffset>0x1F0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xC3FF</resetMask>
            <fields>
              <field>
                <name>CONN_CL_INT_EN</name>
                <description>If this bit is set connection closed interrupt is enabled.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CONN_ESTB_INT_EN</name>
                <description>If this bit is set connection establishment interrupt is enabled.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>MAP_UPDT_INT_EN</name>
                <description>If this bit is set, channel map update interrupt is enabled.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>START_CE_INT_EN</name>
                <description>If this bit is set connection event start interrupt is enabled</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CLOSE_CE_INT_EN</name>
                <description>If this bit is set connection event closed interrupt is enabled.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CE_TX_ACK_INT_EN</name>
                <description>If this bit is set transmission acknowledgement interrupt is enabled: 
This interrupt is generated to indicate to the firmware that a non-empty packet transmitted is successfully acknowledged by the remote device.
For negative acknowledgements from remote device, this interrupt indication is not generated.</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CE_RX_INT_EN</name>
                <description>If this bit is set interrupt is enabled for reception of packet in a connection event.</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CONN_UPDATE_INTR_EN</name>
                <description>If this bit is set connection update interrupt is enabled.</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RX_GOOD_PDU_INT_EN</name>
                <description>If this bit is set packet receive good pdu interrupt is enabled. Effective only when bit 6 is set.</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RX_BAD_PDU_INT_EN</name>
                <description>If this bit is set packet receive bad pdu interrupt is enabled. Effective only when bit 6 is set.</description>
                <bitRange>[9:9]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PING_TIMER_EXPIRD_INTR</name>
                <description>If this bit is set ping timer expired interrupt is enabled.</description>
                <bitRange>[14:14]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PING_NEARLY_EXPIRD_INTR</name>
                <description>If this bit is set ping timer nearly expired interrupt is enabled</description>
                <bitRange>[15:15]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SLAVE_TIMING_CONTROL</name>
            <description>slave timing control</description>
            <addressOffset>0x1F4</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0xBE96</resetValue>
            <resetMask>0xFFFF</resetMask>
            <fields>
              <field>
                <name>SLAVE_TIME_SET_VAL</name>
                <description>Programmable adjust value to the clock counter when slave is connected</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SLAVE_TIME_ADJ_VAL</name>
                <description>Timing adjust value. The internal micro second counter is adjusted to this value whenever slave receives a good access address match at connection anchor point. This will ensure the slave gets synchronized to master timing.</description>
                <bitRange>[15:8]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>RECEIVE_TRIG_CTRL</name>
            <description>Receive trigger control</description>
            <addressOffset>0x1F8</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF3F</resetMask>
            <fields>
              <field>
                <name>ACC_TRIGGER_THRESHOLD</name>
                <description>Access address match threshold value. Number of bits of ac-cess address that should match with the expected access ad-dress to trigger an access code match. 

Max value : 32  (for 32-bit access address)
Lower values may be programmed for bad radios or channels but care must be taken to ensure there are no 'false' matches due to reduced number of bits required to match.</description>
                <bitRange>[5:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ACC_TRIGGER_TIMEOUT</name>
                <description>If access address match does not occur then within this time from the start of receive operation, the receive operation times out and stops.  An internal counter value of 1usec resolution is continuously compared with the value programmed.
Max value :0xFF</description>
                <bitRange>[15:8]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DPLL_CONFIG</name>
            <description>DPLL &amp; CY Correlator configuration register</description>
            <addressOffset>0x258</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x92E0</resetValue>
            <resetMask>0xFFFF</resetMask>
            <fields>
              <field>
                <name>DPLL_CORREL_CONFIG</name>
                <description>If CY_CORREL_EN is 0:
[2:0] Read pointer correction on DPLL overflow. Optimal setting is 0x4.
[6:4] Minimum distance from Rd ptr to Wr ptr to start read in DPLL. Optimal setting is 0x6.
[11:8] Sets lower water mark for DPLL. Optimal setting is 0x2.
[15:12] Sets upper water mark for DPLL. Optimal setting is 0x9.

If CY_CORREL_EN is 1:
[11:0] CY correl Access address compare mask for LSB 12 bits. Ideal value is 0xFFF
[15:12] CY correl maximum number of allowed mismatched bits in access address. Ideal value is 0x0.</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>WHITELIST_BASE_ADDR</name>
            <description>Whitelist base address</description>
            <addressOffset>0x340</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFF</resetMask>
            <fields>
              <field>
                <name>WL_BASE_ADDR</name>
                <description>Device address values written to white list memory are written as 16-bit wide address.</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CONN_UPDATE_NEW_INTERVAL</name>
            <description>Connection update new interval</description>
            <addressOffset>0x3A4</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFF</resetMask>
            <fields>
              <field>
                <name>CONN_UPDT_INTERVAL</name>
                <description>This register will have the new connection interval that the hardware will use after the connection update instant. Before the instant, the connection interval in the register CONN_INTERVAL will be used by hardware.</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CONN_UPDATE_NEW_LATENCY</name>
            <description>Connection update new latency</description>
            <addressOffset>0x3A8</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFF</resetMask>
            <fields>
              <field>
                <name>CONN_UPDT_SLV_LATENCY</name>
                <description>This register will have the new slave latency parameter that the hardware will use after the connection update instant. Before the instant, the connection interval in the register SLAVE_LATENCY will be used by hardware.</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CONN_UPDATE_NEW_SUP_TO</name>
            <description>Connection update new supervision timeout</description>
            <addressOffset>0x3AC</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFF</resetMask>
            <fields>
              <field>
                <name>CONN_UPDT_SUP_TO</name>
                <description>This register will have the new supervision timeout that the hardware will use after the connection update instant. Before the instant, the connection interval in the register SUP_TIMEOUT will be used by hardware.</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CONN_UPDATE_NEW_SL_INTERVAL</name>
            <description>Connection update new Slave Latency X Conn interval Value</description>
            <addressOffset>0x3B0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFF</resetMask>
            <fields>
              <field>
                <name>SL_CONN_INTERVAL_VAL</name>
                <description>This register will have the new Slave Latency * Conn Interval value that the hardware will use after the connection update instant. Before the instant, the connection interval in the register SL_CONN_INTERVAL will be used by hardware.</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CONN_REQ_WORD0</name>
            <description>Connection request address word 0</description>
            <addressOffset>0x3C0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFF</resetMask>
            <fields>
              <field>
                <name>ACCESS_ADDR_LOWER</name>
                <description>This field defines the lower 16 bits of the access address that is to be sent in the connect request packet of the initiator.</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CONN_REQ_WORD1</name>
            <description>Connection request address word 1</description>
            <addressOffset>0x3C4</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFF</resetMask>
            <fields>
              <field>
                <name>ACCESS_ADDR_UPPER</name>
                <description>This field defines the upper16 bits of the access address that is to be sent in the connect request packet of the initiator.</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CONN_REQ_WORD2</name>
            <description>Connection request address word 2</description>
            <addressOffset>0x3C8</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFF</resetMask>
            <fields>
              <field>
                <name>TX_WINDOW_SIZE_VAL</name>
                <description>window_size along with the window_offset is used to calculate the first connection point anchor point for the master.
This shall be a multiple of 1.25 ms in the range of 1.25 ms to the lesser of 10 ms and (connInterval - 1.25 ms).
Values range from 0 to 10 ms.</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CRC_INIT_LOWER</name>
                <description>This field defines the lower byte [7:0] of the CRC initialization value.</description>
                <bitRange>[15:8]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CONN_REQ_WORD3</name>
            <description>Connection request address word 3</description>
            <addressOffset>0x3CC</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFF</resetMask>
            <fields>
              <field>
                <name>CRC_INIT_UPPER</name>
                <description>This field defines the upper byte [23:8] of the CRC initialization value that is to be sent in the connect request packet of the initiator.</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CONN_REQ_WORD4</name>
            <description>Connection request address word 4</description>
            <addressOffset>0x3D0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFF</resetMask>
            <fields>
              <field>
                <name>TX_WINDOW_OFFSET</name>
                <description>This is used to determine the anchor point for the master transmission.
Range: This shall be a multiple of 1.25 ms in the range of 0 ms to connInterval value.</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CONN_REQ_WORD5</name>
            <description>Connection request address word 5</description>
            <addressOffset>0x3D4</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFF</resetMask>
            <fields>
              <field>
                <name>CONNECTION_INTERVAL_VAL</name>
                <description>The value configured in this register determines the spacing between the connection events.
This shall be a multiple of 1.25 ms in the range of 7.5 ms to 4.0 s.</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CONN_REQ_WORD6</name>
            <description>Connection request address word 6</description>
            <addressOffset>0x3D8</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFF</resetMask>
            <fields>
              <field>
                <name>SLAVE_LATENCY_VAL</name>
                <description>The value configured in this field defines the number of consecutive connection events that the slave device is not required to listen for master. The value of connSlaveLatency should not cause a Supervision Timeout. This shall be an integer in the range of                                               0 to ((connSupervision Timeout/connInterval)-1). connSlaveLatency shall also be less than 500.</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CONN_REQ_WORD7</name>
            <description>Connection request address word 7</description>
            <addressOffset>0x3DC</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFF</resetMask>
            <fields>
              <field>
                <name>SUPERVISION_TIMEOUT_VAL</name>
                <description>This field defines the maximum time between two received Data packet PDUs before the connection is considered lost.
This shall be a multiple of 10 ms in the range of 100 ms to 32.0 s and it shall be larger than (1+connSlaveLatency)*connInterval.</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CONN_REQ_WORD8</name>
            <description>Connection request address word 8</description>
            <addressOffset>0x3E0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFF</resetMask>
            <fields>
              <field>
                <name>DATA_CHANNELS_LOWER</name>
                <description>This register field indicates which of the data channels are in use. This stores the information for the lower 16 (15:0) data channel indices.
1' indicates the corresponding data channel is used and '0' indicates the channel is unused.</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CONN_REQ_WORD9</name>
            <description>Connection request address word 9</description>
            <addressOffset>0x3E4</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFF</resetMask>
            <fields>
              <field>
                <name>DATA_CHANNELS_MID</name>
                <description>This register field indicates which of the data channels are in use. This stores the information for the middle 16 (31:16) data channel indices.
'1' indicates the corresponding data channel is used and '0' indicates the channel is unused.</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CONN_REQ_WORD10</name>
            <description>Connection request address word 10</description>
            <addressOffset>0x3E8</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1F</resetMask>
            <fields>
              <field>
                <name>DATA_CHANNELS_UPPER</name>
                <description>This register field indicates which of the data channels are in use. This stores the information for the upper 5 (36:32) data channel indices.
'1' indicates the corresponding data channel is used and '0' indicates the channel is unused.</description>
                <bitRange>[4:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CONN_REQ_WORD11</name>
            <description>Connection request address word 11</description>
            <addressOffset>0x3EC</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>HOP_INCREMENT_2</name>
                <description>This field is used for the data channel selection process.</description>
                <bitRange>[4:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SCA_2</name>
                <description>This field defines the sleep clock accuracies given in ppm.</description>
                <bitRange>[7:5]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>PACKET_COUNTER0</name>
            <description>Packet counter 0</description>
            <addressOffset>0x400</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFF</resetMask>
            <fields>
              <field>
                <name>PACKET_COUNTER_LOWER</name>
                <description>Lower 16-bits of the packet counter value passed as part of Nonce for the packet to be encrypted.</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>PACKET_COUNTER1</name>
            <description>Packet counter 1</description>
            <addressOffset>0x404</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFF</resetMask>
            <fields>
              <field>
                <name>PACKET_COUNTER_MIDDLE</name>
                <description>Middle 16-bits of the packet counter value passed as part of Nonce for the packet to be encrypted.</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>PACKET_COUNTER2</name>
            <description>Packet counter 2</description>
            <addressOffset>0x408</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>PACKET_COUNTER_UPPER</name>
                <description>Upper 8 bits of the packet counter value passed as part of Nonce for the packet to be encrypted.</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>IV_MASTER0</name>
            <description>Master Initialization Vector 0</description>
            <addressOffset>0x410</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFF</resetMask>
            <fields>
              <field>
                <name>IV_MASTER_LOWER</name>
                <description>This is the lower 16-bits of the IVm field, which contains the master's portion of the initialization vector.</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>IV_MASTER1</name>
            <description>Master Initialization Vector 1</description>
            <addressOffset>0x414</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFF</resetMask>
            <fields>
              <field>
                <name>IV_MASTER_UPPER</name>
                <description>This is the upper 16-bits of the IVm field, which contains the master's portion of the initialization vector.</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>IV_SLAVE0</name>
            <description>Slave Initialization Vector 0</description>
            <addressOffset>0x418</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFF</resetMask>
            <fields>
              <field>
                <name>IV_SLAVE_LOWER</name>
                <description>This is the lower 16-bits of the IVs field, which contains the slave's portion of the initialization vector.</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>IV_SLAVE1</name>
            <description>Slave Initialization Vector 1</description>
            <addressOffset>0x41C</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFF</resetMask>
            <fields>
              <field>
                <name>IV_SLAVE_UPPER</name>
                <description>This is the upper 16-bits of the IVs field, which contains the slave's portion of the initialization vector.</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <dim>8</dim>
            <dimIncrement>4</dimIncrement>
            <name>ENC_KEY[%s]</name>
            <description>Encryption Key register 0-7</description>
            <addressOffset>0x420</addressOffset>
            <size>32</size>
            <access>write-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFF</resetMask>
            <fields>
              <field>
                <name>ENC_KEY</name>
                <description>The encryption key / session key which is used in ECB encryption, CCM encryption and CCM decryption.</description>
                <bitRange>[15:0]</bitRange>
                <access>write-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DATA0</name>
            <description>Input / Output Data register</description>
            <addressOffset>0x440</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFF</resetMask>
            <fields>
              <field>
                <name>DATA0</name>
                <description>Write: Bytes 1 and 0 of the input plain text to be encrypted.
Read: Bytes 1 and 0 of the decrypted plain text/ encrypted text.</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DATA1</name>
            <description>Input / Output Data register</description>
            <addressOffset>0x444</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFF</resetMask>
            <fields>
              <field>
                <name>DATA1</name>
                <description>Write: Bytes 3 and 2 of the input plain text to be encrypted.
Read: Bytes 3 and 2 of the decrypted plain text/ encrypted text.</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DATA2</name>
            <description>Input / Output Data register</description>
            <addressOffset>0x448</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFF</resetMask>
            <fields>
              <field>
                <name>DATA2</name>
                <description>Write: Bytes 5 and 4 of the input plain text to be encrypted.
Read: Bytes 5 and 4 of the decrypted plain text/ encrypted text.</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DATA3</name>
            <description>Input / Output Data register</description>
            <addressOffset>0x44C</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFF</resetMask>
            <fields>
              <field>
                <name>DATA3</name>
                <description>Write: Bytes 7 and 6 of the input plain text to be encrypted.
Read: Bytes 7 and 6 of the decrypted plain text/ encrypted text.</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DATA4</name>
            <description>Input / Output Data register</description>
            <addressOffset>0x450</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFF</resetMask>
            <fields>
              <field>
                <name>DATA4</name>
                <description>Write: Bytes 9 and 8 of the input plain text to be encrypted.
Read: Bytes 9 and 8 of the decrypted plain text/ encrypted text.</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DATA5</name>
            <description>Input / Output Data register</description>
            <addressOffset>0x454</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFF</resetMask>
            <fields>
              <field>
                <name>DATA5</name>
                <description>Write: Bytes 11 and 10 of the input plain text to be encrypted.
Read: Bytes 11 and 10 of the decrypted plain text/ encrypted text.</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DATA6</name>
            <description>Input / Output Data register</description>
            <addressOffset>0x458</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFF</resetMask>
            <fields>
              <field>
                <name>DATA6</name>
                <description>Write: Bytes 13 and 12 of the input plain text to be encrypted.
Read: Bytes 13 and 12 of the decrypted plain text/ encrypted text.</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DATA7</name>
            <description>Input / Output Data register</description>
            <addressOffset>0x45C</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFF</resetMask>
            <fields>
              <field>
                <name>DATA7</name>
                <description>Write: Bytes 15 and 14 of the input plain text to be encrypted.
Read: Bytes 15 and 14 of the decrypted plain text/ encrypted text.</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DATA8</name>
            <description>Input / Output Data register</description>
            <addressOffset>0x460</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFF</resetMask>
            <fields>
              <field>
                <name>DATA8</name>
                <description>Write: Bytes 17 and 16 of the input plain text to be encrypted.
Read: Bytes 17 and 16 of the decrypted plain text/ encrypted text.</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DATA9</name>
            <description>Input / Output Data register</description>
            <addressOffset>0x464</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFF</resetMask>
            <fields>
              <field>
                <name>DATA9</name>
                <description>Write: Bytes 19 and 18 of the input plain text to be encrypted.
Read: Bytes 19 and 18 of the decrypted plain text/ encrypted text.</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DATA10</name>
            <description>Input / Output Data register</description>
            <addressOffset>0x468</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFF</resetMask>
            <fields>
              <field>
                <name>DATA10</name>
                <description>Write: Bytes 21 and 20 of the input plain text to be encrypted.
Read: Bytes 21 and 20 of the decrypted plain text/ encrypted text.</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DATA11</name>
            <description>Input / Output Data register</description>
            <addressOffset>0x46C</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFF</resetMask>
            <fields>
              <field>
                <name>DATA11</name>
                <description>Write: Bytes 23 and 22 of the input plain text to be encrypted.
Read: Bytes 23 and 22 of the decrypted plain text/ encrypted text.</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DATA12</name>
            <description>Input / Output Data register</description>
            <addressOffset>0x470</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFF</resetMask>
            <fields>
              <field>
                <name>DATA12</name>
                <description>Write: Bytes 25 and 24 of the input plain text to be encrypted.
Read: Bytes 25 and 24 of the decrypted plain text/ encrypted text.</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DATA13</name>
            <description>Input / Output Data register</description>
            <addressOffset>0x474</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>DATA13</name>
                <description>Write: Byte 26 of the input plain text to be encrypted.
Read: Byte 26 of the decrypted plain text/ encrypted text.</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MIC_IN0</name>
            <description>MIC input register</description>
            <addressOffset>0x478</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFF</resetMask>
            <fields>
              <field>
                <name>MIC_IN_LOWER</name>
                <description>This is the lower 16-bits of the MIC field used for CCM decryption.</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MIC_IN1</name>
            <description>MIC input register</description>
            <addressOffset>0x47C</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFF</resetMask>
            <fields>
              <field>
                <name>MIC_IN_UPPER</name>
                <description>This is the upper 16-bits of the MIC field used for CCM decryption.</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MIC_OUT0</name>
            <description>MIC output register</description>
            <addressOffset>0x480</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFF</resetMask>
            <fields>
              <field>
                <name>MIC_OUT_LOWER</name>
                <description>This is the lower 16-bits of the MIC generated during CCM encryption.</description>
                <bitRange>[15:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MIC_OUT1</name>
            <description>MIC output register</description>
            <addressOffset>0x484</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFF</resetMask>
            <fields>
              <field>
                <name>MIC_OUT_UPPER</name>
                <description>This is the lower 16-bits of the MIC generated during CCM encryption.</description>
                <bitRange>[15:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ENC_PARAMS</name>
            <description>Encryption Parameter register</description>
            <addressOffset>0x488</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>DATA_PDU_HEADER</name>
                <description>LLID of the packet.</description>
                <bitRange>[1:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PAYLOAD_LENGTH</name>
                <description>Length of the input data.</description>
                <bitRange>[6:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DIRECTION</name>
                <description>The directionBit shall be set to '1' for Data Channel PDUs sent by the master and set to '0' for Data Channel PDUs sent by the slave.</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ENC_CONFIG</name>
            <description>Encryption Configuration</description>
            <addressOffset>0x490</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x7</resetMask>
            <fields>
              <field>
                <name>START_PROC</name>
                <description>1 Start the AES processing</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ECB_CCM</name>
                <description>0 - CCM
1 - ECB</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DEC_ENC</name>
                <description>Decryption/Encryption
0 - Encrypt
1 - Decrypt</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ENC_INTR_EN</name>
            <description>Encryption Interrupt enable</description>
            <addressOffset>0x498</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x7</resetMask>
            <fields>
              <field>
                <name>AUTH_PASS_INTR_EN</name>
                <description>Authentication interrupt enable
0 - Disable
1 - Enable</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ECB_PROC_INTR_EN</name>
                <description>ECB processed interrupt enable
0 - Disable
1 - Enable</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CCM_PROC_INTR_EN</name>
                <description>CCM processed interupt enable
0 - Disable
1 - Enable</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ENC_INTR</name>
            <description>Encryption Interrupt status and clear register</description>
            <addressOffset>0x4A0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xF</resetMask>
            <fields>
              <field>
                <name>AUTH_PASS_INTR</name>
                <description>Authentication interrupt.
0x1- indicates MIC matched
0x0 -indicated MIC mismatched
Writing 1 to this register clears the interrupt.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ECB_PROC_INTR</name>
                <description>ECB processed interrupt.
Writing 1 to this register clears the interrupt.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CCM_PROC_INTR</name>
                <description>CCM processed interrupt.
Writing 1 to this register clears the interrupt</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>IN_DATA_CLEAR</name>
                <description>Clears the input data. Used for Zero padding of encryption for less than block sized data.</description>
                <bitRange>[3:3]</bitRange>
                <access>write-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CONN_TXMEM_BASE_ADDR</name>
            <description>Connection TX memory base address</description>
            <addressOffset>0x600</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFF</resetMask>
            <fields>
              <field>
                <name>CONN_TX_MEM_BASE_ADDR</name>
                <description>Data values written to Tx memory are written as 16-bit wide data.</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CONN_RXMEM_BASE_ADDR</name>
            <description>Connection RX memory base address</description>
            <addressOffset>0x800</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFF</resetMask>
            <fields>
              <field>
                <name>CONN_RX_MEM_BASE_ADDR</name>
                <description>Data values written to Rx memory are written as 16-bit wide data</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>PDU_RESP_TIMER</name>
            <description>PDU response timer</description>
            <addressOffset>0xA04</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFF</resetMask>
            <fields>
              <field>
                <name>PDU_RESP_TIME_VAL</name>
                <description>This register is loaded with the count value to monitor the time to get a response for a PDU from peer device.
Firmware starts the timer by issuing the command, RESP_TIMER_ON, after it has queued a PDU for transmission, that requires a response. 
If a response is received, firmware stops and clears the timer by issuing the command RESP_TIMER_OFF.
If this timer expires, it results in hardware closing the connection and triggering a conn_closed interrupt.
The discon_status field in the Connection status register is set with the appropriate reason.
Units : Milliseconds.
Resolution : 1.25 ms</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>NEXT_RESP_TIMER_EXP</name>
            <description>Next response timeout instant</description>
            <addressOffset>0xA08</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFF</resetMask>
            <fields>
              <field>
                <name>NEXT_RESPONSE_INSTANT</name>
                <description>This field defines the clock instant at which the next PDU response timeout event will occur on a connection.
This is with reference to the 16-bit internal reference clock.</description>
                <bitRange>[15:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>NEXT_SUP_TO</name>
            <description>Next supervision timeout instant</description>
            <addressOffset>0xA0C</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFF</resetMask>
            <fields>
              <field>
                <name>NEXT_TIMEOUT_INSTANT</name>
                <description>This field defines the clock instant at which the next connection supervision timeout event will occur on a connection
This is with reference to the 16-bit internal reference clock.</description>
                <bitRange>[15:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>LLH_FEATURE_CONFIG</name>
            <description>Feature enable</description>
            <addressOffset>0xA10</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x2</resetValue>
            <resetMask>0x3</resetMask>
            <fields>
              <field>
                <name>QUICK_TRANSMIT</name>
                <description>Quick transmit feature in slave latency is enabled by setting this bit.
When slave latency is enabled, this feature enables the slave to transmit in the immediate connection interval,  in case required, instead of waiting till the end of slave latency</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SL_DSM_EN</name>
                <description>Enable/Disable Slave Latency Period DSM.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>WIN_MIN_STEP_SIZE</name>
            <description>Window minimum step size</description>
            <addressOffset>0xA14</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x2064</resetValue>
            <resetMask>0xFFFF</resetMask>
            <fields>
              <field>
                <name>STEPDN</name>
                <description>After receiving 2 consecutive good packets the reference window is gradually decremented by step down size until it reaches window minimum. The unit is in microseconds</description>
                <bitRange>[3:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>STEPUP</name>
                <description>If packets are missed, the reference window is gradually increased by step up size, until it receives 2 consecutive good packets. The unit is in microseconds</description>
                <bitRange>[7:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>WINDOW_MIN_FW</name>
                <description>Minimum window interval value programmed by firmware. While the slave receive window is decremented, the windows_min_fw sets the lowest value of the window widen value to ensure packets are not missed. The unit is in microseconds.</description>
                <bitRange>[15:8]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SLV_WIN_ADJ</name>
            <description>Slave window adjustment</description>
            <addressOffset>0xA18</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x10</resetValue>
            <resetMask>0x7FF</resetMask>
            <fields>
              <field>
                <name>SLV_WIN_ADJ</name>
                <description>Window Adjust value. This value is added to the calculated slave window widening value to be used as final window widen value.</description>
                <bitRange>[10:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SL_CONN_INTERVAL</name>
            <description>Slave Latency X Conn Interval Value</description>
            <addressOffset>0xA1C</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFF</resetMask>
            <fields>
              <field>
                <name>SL_CONN_INTERVAL_VAL</name>
                <description>This field defines the (SL*CI) product for the ongoing connection. This value is used in calculation of next connection instant during slave latency.</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>LE_PING_TIMER_ADDR</name>
            <description>LE Ping connection timer address</description>
            <addressOffset>0xA20</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFF</resetMask>
            <fields>
              <field>
                <name>CONN_PING_TIMER_ADDR</name>
                <description>The register used to configure the LE Au-thenticated payload Timeout (LE APTO) which is the Maximum amount of time specified between packets authenticated by a MIC.
This value of ping timer is in the order of 10ms, valid range 0x1 ~ 0xFFFF</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>LE_PING_TIMER_OFFSET</name>
            <description>LE Ping connection timer offset</description>
            <addressOffset>0xA24</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFF</resetMask>
            <fields>
              <field>
                <name>CONN_PING_TIMER_OFFSET</name>
                <description>The value of ping timer nearly expired offset in the order of 10ms, valid range 0x0 ~ 0xFFFF. This is the time period after which the ping timer nearly expired interrupt is generated.</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>LE_PING_TIMER_NEXT_EXP</name>
            <description>LE Ping timer next expiry instant</description>
            <addressOffset>0xA28</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFF</resetMask>
            <fields>
              <field>
                <name>CONN_PING_TIMER_NEXT_EXP</name>
                <description>The value of ping timer next expiry instant in the terms of native clock value (least 16 bit value of the 17 bit ping counter).
 This together with CONN_PING_TIMER_NEXT_EXP_WRAP will provide the correct status of ping timer duration.</description>
                <bitRange>[15:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>LE_PING_TIMER_WRAP_COUNT</name>
            <description>LE Ping Timer wrap count</description>
            <addressOffset>0xA2C</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFF</resetMask>
            <fields>
              <field>
                <name>CONN_SEC_CURRENT_WRAP</name>
                <description>This register holds the current position of the Ping timer.</description>
                <bitRange>[15:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>TX_EN_EXT_DELAY</name>
            <description>Transmit enable extension delay</description>
            <addressOffset>0xE00</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x5</resetValue>
            <resetMask>0x1F</resetMask>
            <fields>
              <field>
                <name>TXEN_EXT_DELAY</name>
                <description>Transmit enable extension delay. This is to extend the active state (high) of rif_tx_en signal after the last bit is sent out from LLH. The unit is in microsecond and the supported range is 00 - 31 us.</description>
                <bitRange>[4:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>TX_RX_SYNTH_DELAY</name>
            <description>Transmit/Receive enable delay</description>
            <addressOffset>0xE04</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFF</resetMask>
            <fields>
              <field>
                <name>RX_EN_DELAY</name>
                <description>The delay used to assert rif_rx_en, Rx_tRamp micro-seconds, ahead of first bit of the expected rx_data, which can be used to turn on the Radio receiver.
The value to be programmed to the Rx_en_delay [7:0] = rx_on_delay - Rx_tRamp
rx_on_delay[7:0] = TX_RX_ON_DELAY[7:0])
Rx_tRamp = Radio receiver rampup time</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TX_EN_DELAY</name>
                <description>The delay used to assert rif_tx_en exactly Tx_tRamp micro-seconds ahead of the first bit of the tx_data, which can be used to turn on the Radio transmitter.
The value to be programmed to the Tx_en_delay [7:0] = tx_on_delay - Tx_tRamp
tx_on_delay[7:0] = TX_RX_ON_DELAY[15:8])
Tx_tRamp = Radio transmitter ramp_up</description>
                <bitRange>[15:8]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
        <cluster>
          <name>BLESS</name>
          <description>Bluetooth Low Energy Subsystem Miscellaneous</description>
          <addressOffset>0x0000F000</addressOffset>
          <register>
            <name>WCO_CONFIG</name>
            <description>WCO Configuration Register</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x470002</resetValue>
            <resetMask>0x80FF0007</resetMask>
            <fields>
              <field>
                <name>LPM_EN</name>
                <description>Force block into Low Power Mode:
0: Do not force low power mode (LPM) on
1: Force low power mode (LPM) on</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>LPM_AUTO</name>
                <description>Automatically control low power mode (only relevant when LPM_EN=0):
0: Do not enter low power mode (LPM) in DeepSleep
1: Enter low power mode (LPM) in DeepSleep
This bit is not functional and should be set to 0,
While entering System Deepsleep Mode, do the following before executing WFI
IOW BLESS.WCO_TRIM.XGM = 3'b010
IOW BLESS.WCO_TRIM.LPM_GM = 2'b10
IOW BLESS.WCO_CONFIG.LPM_EN = 1'b1
While existing from System Deepsleep Mode, do the following before executing ISR
IOW BLESS.WCO_CONFIG.LPM_EN = 1'b0
IOW BLESS.WCO_TRIM.XGM = 3'b001
IOW BLESS.WCO_TRIM.LPM_GM = 2'b01</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EXT_INPUT_EN</name>
                <description>Disables the load resistor and allows external clock input for pad_xin</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ENBUS</name>
                <description>Test Mode Control bits
enbus[7] - N/A
enbus[6] - 1=enable both primary Beta Multipliers
enbus[5] - N/A
enbus[4] - 1=enable digital oscillator detect
enbus[3] - Load Resistor Control
enbus[2] - Load Resistor Control
enbus[1] - Load Resistor Control
enbus[0] - Load Resistor Control</description>
                <bitRange>[23:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ENABLE</name>
                <description>Master enable for WCO oscillator</description>
                <bitRange>[31:31]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>WCO_STATUS</name>
            <description>WCO Status Register</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1</resetMask>
            <fields>
              <field>
                <name>OUT_BLNK_A</name>
                <description>Indicates that WCO clock has transitioned- This bit is intended for Test Mode Only and is not a reliable indicator.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>RF_CONFIG</name>
            <description>Radio configuration register</description>
            <addressOffset>0x60</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xCFF1</resetMask>
            <fields>
              <field>
                <name>RF_ENABLE</name>
                <description>Enables the RF oscillator band gap.
1: band gap is enabled
0: band gap is disabled</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DDFT_MUX_CFG1</name>
                <description>dbg_mux_pin1 selection, combine with BLERD and BLESS
4'h0 dbg_pin_mux_1_rd (RD output)
4'h1 rxclk (RD output)
4'h2 bpktctl_to_rd (RD input)
4'h3 dbus_rx_en (llh_cy_asic output)
4'h4 hw_clk_en (pwr_ctrl_top)
4'h5 clk_switch_to_sysclk (pwr_ctrl_top)
4'h6 ll_clk_en_sync (LL global clock enable from BLESS reg synced)
4'h7 dsm_entry_stat (llh_cy_asic output)
4'h8 ll_dsm_xo_on (LL in DSM, RD XO enabled)
4'h9 ll_dsm_xo_off (LL in DSM, RD XO disabled)
4'hf  delayed_bg_en (m0s8bless_misc_dpslp_top output vs LS to s8blerf)</description>
                <bitRange>[7:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DDFT_MUX_CFG2</name>
                <description>dbg_mux_pin2 selection, combine with BLERD and BLESS
4'h0 dbg_pin_mux_2_rd
4'h1 rxdata (RD output)
4'b2 ll_decode_rx_data (llh_cy_asic output)
4'h3 dbus_tx_en (llh_cy_asic output)
4'h4 fw_clk_en (pwr_ctrl_top output)
4'h5 interrupt_ll_n (llh_cy_asic output)
4'h6 ll_st_sm (llh is in SM )
4'h7 ll_st_dsm (llh is in DSM)
4'he clk_gate_en_xtal (RD eco xtal clock gater enable)
4'hf bb_xo_amp_detect_dft_mux (RD output)</description>
                <bitRange>[11:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>BPKTCTL_FW</name>
                <description>FW drives BLERD bpktctl if this register bit 15 enabled</description>
                <bitRange>[14:14]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>BPKTCTL_FW_DRIVE</name>
                <description>Enabled FW drives BLERD bpkctl for radio standalone testing</description>
                <bitRange>[15:15]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>XTAL_CLK_DIV_CONFIG</name>
            <description>Crystal clock divider configuration register</description>
            <addressOffset>0x64</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xF</resetMask>
            <fields>
              <field>
                <name>SYSCLK_DIV</name>
                <description>System clock pre-divider value. The 24 MHz crystal clock is divided to generate the system clock.
0: NO_DIV:   SYSCLK= XTALCLK/1
1: DIV_BY_2: SYSCLK= XTALCLK/2
2: DIV_BY_4: SYSCLK= XTALCLK/4
3: DIV_BY_8: SYSCLK= XTALCLK/8</description>
                <bitRange>[1:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>LLCLK_DIV</name>
                <description>Link Layer clock pre-divider value. The 24 MHz crystal clock is divided to generate the Link Layer clock.
0: NO_DIV:   LLCLK= XTALCLK/1
1: DIV_BY_2: LLCLK= XTALCLK/2
2: DIV_BY_4: LLCLK= XTALCLK/4
3: DIV_BY_8: LLCLK= XTALCLK/8</description>
                <bitRange>[3:2]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>LL_DSM_INTR_STAT</name>
            <description>Link Layer interrupt status register</description>
            <addressOffset>0x68</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x103</resetMask>
            <fields>
              <field>
                <name>DSM_ENTERED_INTR</name>
                <description>On a firmware request to LL to enter into state machine, working on LF clock, LL transitions into Deep Sleep Mode and asserts this interrupt. The interrupt can be cleared by writing one into this location.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DSM_EXITED_INTR</name>
                <description>On a firmware request to LL to exit from Deep Sleep Mode, working on LF clock, LL transitions from Deep Sleep Mode and asserts this interrupt when the Deep Sleep clock gater is turned ON. The interrupt can be cleared by writing one into this location.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>XTAL_ON_INTR</name>
                <description>enabled crystal stable signal rising edge interrupt. The interrupt can be cleared by writing one into this location.</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>LL_DSM_CTRL</name>
            <description>Link Layer state machine control register</description>
            <addressOffset>0x6C</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0xE</resetValue>
            <resetMask>0xF</resetMask>
            <fields>
              <field>
                <name>DSM_EXIT</name>
                <description>When the Link Layer is in Deep Sleep Mode, firmware can set this bit to wake the Link Layer.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DSM_ENTERED_INTR_MASK</name>
                <description>Masks the DSM Entered Interrupt, when disabled.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DSM_EXITED_INTR_MASK</name>
                <description>Masks the DSM Exited Interrupt, when disabled.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>XTAL_ON_INTR_MASK</name>
                <description>Masks the Crystal Stable Interrupt, when disabled.</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>LL_CLK_EN</name>
            <description>Link Layer primary clock enable</description>
            <addressOffset>0x70</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x2</resetValue>
            <resetMask>0x3</resetMask>
            <fields>
              <field>
                <name>CLK_EN</name>
                <description>Set this bit 1 to enable the clock to Link Layer.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CY_CORREL_EN</name>
                <description>Set this bit 1 to enable Cypress Correlator logic to bypass MT logic</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>LF_CLK_CTRL</name>
            <description>BLESS LF clock control</description>
            <addressOffset>0x74</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1</resetMask>
            <fields>
              <field>
                <name>DISABLE_LF_CLK</name>
                <description>When set to 1, gates the LF clock input to the Link Layer. Ths is done for extended DSM mode where the DSM state machine needs to be forzen to prevent a default auto exit.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>WCO_TRIM</name>
            <description>WCO Trim Register</description>
            <addressOffset>0xF00</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x11</resetValue>
            <resetMask>0x37</resetMask>
            <fields>
              <field>
                <name>XGM</name>
                <description>Amplifier GM setting
0x0 - 3370 nA
0x1 - 2620 nA
0x2 - 2250 nA
0x3 - 1500 nA
0x4 - 1870 nA
0x5 - 1120 nA
0x6 -  750 nA
0x7 -      0 nA</description>
                <bitRange>[2:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>LPM_GM</name>
                <description>GM setting for LPM (bandwidth = DC/ms)</description>
                <bitRange>[5:4]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
      </registers>
    </peripheral>
    <peripheral>
      <name>CTBM0</name>
      <description>Continuous Time Block Mini</description>
      <headerStructName>CTBM</headerStructName>
      <baseAddress>0x40300000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>65536</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>CTB_CTRL</name>
          <description>global CTB and power control</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xC0000000</resetMask>
          <fields>
            <field>
              <name>DEEPSLEEP_ON</name>
              <description>- 0: CTB IP disabled off during DeepSleep power mode
- 1: CTB IP remains enabled during DeepSleep power mode (if ENABLED=1)</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ENABLED</name>
              <description>- 0: CTB IP disabled (put analog in power down, open all switches)
- 1: CTB IP enabled</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>OA_RES0_CTRL</name>
          <description>Opamp0 and resistor0 control</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xBF7</resetMask>
          <fields>
            <field>
              <name>OA0_PWR_MODE</name>
              <description>Opamp0 power level</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>OFF</name>
                  <description>Off</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LOW</name>
                  <description>Low compensation setting (smallest cap, highest GBW). For gain=10: PM=60deg @ Cload=50pF for the output to pin driver and 10pF for the internal only driver</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>MEDIUM</name>
                  <description>Medium compensation setting. For gain=4: PM=60deg @ Cload=50pF for the output to pin driver and 10pF for the internal only driver.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HIGH</name>
                  <description>Highest compensation (largest cap, lowest GBW). For gain=1: PM=60deg @ Cload=50pF for the output to pin driver and 10pF for the internal only driver</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>OA0_DRIVE_STR_SEL</name>
              <description>Opamp0 output strenght select 0=1x, 1=10x</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OA0_COMP_EN</name>
              <description>Opamp0 comparator enable</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OA0_HYST_EN</name>
              <description>Opamp0 hysteresis enable (10mV)</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OA0_BYPASS_DSI_SYNC</name>
              <description>Opamp0 bypass comparator output synchronization for DSI (trigger) output: 0=synchronize (level or pulse), 1=bypass (output async)</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OA0_DSI_LEVEL</name>
              <description>Opamp0 comparator DSI (trigger) out level : 
0=pulse, each time an edge is detected (see OA0_COMPINT) a pulse is sent out on DSI
1=level,  DSI output is a synchronized version of the comparator output</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OA0_COMPINT</name>
              <description>Opamp0 comparator edge detect for interrupt and pulse mode of DSI (trigger)</description>
              <bitRange>[9:8]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DISABLE</name>
                  <description>Disabled, no interrupts will be detected</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RISING</name>
                  <description>Rising edge</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>FALLING</name>
                  <description>Falling edge</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>BOTH</name>
                  <description>Both rising and falling edges</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>OA0_PUMP_EN</name>
              <description>Opamp0 pump enable</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>OA_RES1_CTRL</name>
          <description>Opamp1 and resistor1 control</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xBF7</resetMask>
          <fields>
            <field>
              <name>OA1_PWR_MODE</name>
              <description>Opamp1 power level: see description of OA0_PWR_MODE</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OA1_DRIVE_STR_SEL</name>
              <description>Opamp1 output strenght select 0=1x, 1=10x</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OA1_COMP_EN</name>
              <description>Opamp1 comparator enable</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OA1_HYST_EN</name>
              <description>Opamp1 hysteresis enable (10mV)</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OA1_BYPASS_DSI_SYNC</name>
              <description>Opamp1 bypass comparator output synchronization for DSI output: 0=synchronize, 1=bypass</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OA1_DSI_LEVEL</name>
              <description>Opamp1 comparator DSI (trigger) out level : 
0=pulse, each time an edge is detected (see OA1_COMPINT) a pulse is sent out on DSI
1=level,  DSI output is a synchronized version of the comparator output</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OA1_COMPINT</name>
              <description>Opamp1 comparator edge detect for interrupt and pulse mode of DSI (trigger)</description>
              <bitRange>[9:8]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DISABLE</name>
                  <description>Disabled, no interrupts will be detected</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RISING</name>
                  <description>Rising edge</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>FALLING</name>
                  <description>Falling edge</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>BOTH</name>
                  <description>Both rising and falling edges</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>OA1_PUMP_EN</name>
              <description>Opamp1 pump enable</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>COMP_STAT</name>
          <description>Comparator status</description>
          <addressOffset>0xC</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x10001</resetMask>
          <fields>
            <field>
              <name>OA0_COMP</name>
              <description>Opamp0 current comparator status</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>OA1_COMP</name>
              <description>Opamp1 current comparator status</description>
              <bitRange>[16:16]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR</name>
          <description>Interrupt request register</description>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3</resetMask>
          <fields>
            <field>
              <name>COMP0</name>
              <description>Comparator 0 Interrupt: hardware sets this interrupt when comparator 0 triggers. Write with '1' to clear bit.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>COMP1</name>
              <description>Comparator 1 Interrupt: hardware sets this interrupt when comparator 1 triggers. Write with '1' to clear bit.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_SET</name>
          <description>Interrupt request set register</description>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3</resetMask>
          <fields>
            <field>
              <name>COMP0_SET</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>COMP1_SET</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_MASK</name>
          <description>Interrupt request mask</description>
          <addressOffset>0x28</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3</resetMask>
          <fields>
            <field>
              <name>COMP0_MASK</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>COMP1_MASK</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_MASKED</name>
          <description>Interrupt request masked</description>
          <addressOffset>0x2C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3</resetMask>
          <fields>
            <field>
              <name>COMP0_MASKED</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>COMP1_MASKED</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DFT_CTRL</name>
          <description>Was 'Analog DfT controls', now used as Risk Mitigation bits (RMP)</description>
          <addressOffset>0x30</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x80000007</resetMask>
          <fields>
            <field>
              <name>DFT_MODE</name>
              <description>this bit is combined with bit 31, to form RMP[3:0], it must always be written with '3' for correct operation.</description>
              <bitRange>[2:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DFT_EN</name>
              <description>this bit is combined with the 3 bits 2:0, to form RMP[3:0]</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>OA0_SW</name>
          <description>Opamp0 switch control</description>
          <addressOffset>0x80</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x24410D</resetMask>
          <fields>
            <field>
              <name>OA0P_A00</name>
              <description>Opamp0 positive terminal amuxbusa</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OA0P_A20</name>
              <description>Opamp0 positive terminal P0</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OA0P_A30</name>
              <description>Opamp0 positive terminal ctbbus0</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OA0M_A11</name>
              <description>Opamp0 negative terminal P1</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OA0M_A81</name>
              <description>Opamp0 negative terminal Opamp0 output</description>
              <bitRange>[14:14]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OA0O_D51</name>
              <description>Opamp0 output sarbus0 (ctbbus2 in CTB)</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OA0O_D81</name>
              <description>Opamp0 output switch to short 1x with 10x drive</description>
              <bitRange>[21:21]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>OA0_SW_CLEAR</name>
          <description>Opamp0 switch control clear</description>
          <addressOffset>0x84</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x24410D</resetMask>
          <fields>
            <field>
              <name>OA0P_A00</name>
              <description>see corresponding bit in OA0_SW</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OA0P_A20</name>
              <description>see corresponding bit in OA0_SW</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OA0P_A30</name>
              <description>see corresponding bit in OA0_SW</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OA0M_A11</name>
              <description>see corresponding bit in OA0_SW</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OA0M_A81</name>
              <description>see corresponding bit in OA0_SW</description>
              <bitRange>[14:14]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OA0O_D51</name>
              <description>see corresponding bit in OA0_SW</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OA0O_D81</name>
              <description>see corresponding bit in OA0_SW</description>
              <bitRange>[21:21]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>OA1_SW</name>
          <description>Opamp1 switch control</description>
          <addressOffset>0x88</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x2C4113</resetMask>
          <fields>
            <field>
              <name>OA1P_A03</name>
              <description>Opamp1 positive terminal amuxbusb</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OA1P_A13</name>
              <description>Opamp1 positive terminal P5</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OA1P_A43</name>
              <description>Opamp1 positive terminal ctbbus1</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OA1M_A22</name>
              <description>Opamp1 negative terminal P4</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OA1M_A82</name>
              <description>Opamp1 negative terminal Opamp1 output</description>
              <bitRange>[14:14]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OA1O_D52</name>
              <description>Opamp1 output sarbus0 (ctbbus2 in CTB)</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OA1O_D62</name>
              <description>Opamp1 output sarbus1 (ctbbus3 in CTB)</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OA1O_D82</name>
              <description>Opamp1 output switch to short 1x with 10x drive</description>
              <bitRange>[21:21]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>OA1_SW_CLEAR</name>
          <description>Opamp1 switch control clear</description>
          <addressOffset>0x8C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x2C4113</resetMask>
          <fields>
            <field>
              <name>OA1P_A03</name>
              <description>see corresponding bit in OA1_SW</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OA1P_A13</name>
              <description>see corresponding bit in OA1_SW</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OA1P_A43</name>
              <description>see corresponding bit in OA1_SW</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OA1M_A22</name>
              <description>see corresponding bit in OA1_SW</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OA1M_A82</name>
              <description>see corresponding bit in OA1_SW</description>
              <bitRange>[14:14]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OA1O_D52</name>
              <description>see corresponding bit in OA1_SW</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OA1O_D62</name>
              <description>see corresponding bit in OA1_SW</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OA1O_D82</name>
              <description>see corresponding bit in OA1_SW</description>
              <bitRange>[21:21]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CTB_SW_HW_CTRL</name>
          <description>CTB bus switch control</description>
          <addressOffset>0xC0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xC</resetMask>
          <fields>
            <field>
              <name>P2_HW_CTRL</name>
              <description>for P22, D51 (dsi_out[2])</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>P3_HW_CTRL</name>
              <description>for P33, D52, D62 (dsi_out[3])</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CTB_SW_STATUS</name>
          <description>CTB bus switch control status</description>
          <addressOffset>0xC4</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x70000000</resetMask>
          <fields>
            <field>
              <name>OA0O_D51_STAT</name>
              <description>see OA0O_D51 bit in OA0_SW</description>
              <bitRange>[28:28]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>OA1O_D52_STAT</name>
              <description>see OA1O_D52 bit in OA1_SW</description>
              <bitRange>[29:29]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>OA1O_D62_STAT</name>
              <description>see OA1O_D62 bit in OA1_SW</description>
              <bitRange>[30:30]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>OA0_OFFSET_TRIM</name>
          <description>Opamp0 trim control</description>
          <addressOffset>0xF00</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3F</resetMask>
          <fields>
            <field>
              <name>OA0_OFFSET_TRIM</name>
              <description>Opamp0 offset trim</description>
              <bitRange>[5:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>OA0_SLOPE_OFFSET_TRIM</name>
          <description>Opamp0 trim control</description>
          <addressOffset>0xF04</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3F</resetMask>
          <fields>
            <field>
              <name>OA0_SLOPE_OFFSET_TRIM</name>
              <description>Opamp0 slope offset drift trim</description>
              <bitRange>[5:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>OA0_COMP_TRIM</name>
          <description>Opamp0 trim control</description>
          <addressOffset>0xF08</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3</resetMask>
          <fields>
            <field>
              <name>OA0_COMP_TRIM</name>
              <description>Opamp 0 Compensation Capacitor Trim</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>OA1_OFFSET_TRIM</name>
          <description>Opamp1 trim control</description>
          <addressOffset>0xF0C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3F</resetMask>
          <fields>
            <field>
              <name>OA1_OFFSET_TRIM</name>
              <description>Opamp1 offset trim</description>
              <bitRange>[5:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>OA1_SLOPE_OFFSET_TRIM</name>
          <description>Opamp1 trim control</description>
          <addressOffset>0xF10</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3F</resetMask>
          <fields>
            <field>
              <name>OA1_SLOPE_OFFSET_TRIM</name>
              <description>Opamp1 slope offset drift trim</description>
              <bitRange>[5:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>OA1_COMP_TRIM</name>
          <description>Opamp1 trim control</description>
          <addressOffset>0xF14</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3</resetMask>
          <fields>
            <field>
              <name>OA1_COMP_TRIM</name>
              <description>Opamp 1 Compensation Capacitor Trim</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral derivedFrom="CTBM0">
      <name>CTBM1</name>
      <baseAddress>0x40310000</baseAddress>
    </peripheral>
    <peripheral>
      <name>SAR0</name>
      <description>SAR ADC with Sequencer</description>
      <headerStructName>SAR</headerStructName>
      <baseAddress>0x403A0000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>65536</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>CTRL</name>
          <description>Analog control register.</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x10000000</resetValue>
          <resetMask>0xFB1FEEF0</resetMask>
          <fields>
            <field>
              <name>VREF_SEL</name>
              <description>SARADC internal VREF selection.</description>
              <bitRange>[6:4]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>VREF0</name>
                  <description>VREF0 from PRB (VREF buffer on)</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VREF1</name>
                  <description>VREF1 from PRB (VREF buffer on)</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VREF2</name>
                  <description>VREF2 from PRB (VREF buffer on)</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VREF_AROUTE</name>
                  <description>VREF from AROUTE (VREF buffer on)</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VBGR</name>
                  <description>1.024V from BandGap (VREF buffer on)</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VREF_EXT</name>
                  <description>External precision Vref direct from a pin (low impedance path).</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VDDA_DIV_2</name>
                  <description>Vdda/2  (VREF buffer on)</description>
                  <value>6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VDDA</name>
                  <description>Vdda.</description>
                  <value>7</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>VREF_BYP_CAP_EN</name>
              <description>VREF bypass cap enable for when VREF buffer is on</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>NEG_SEL</name>
              <description>SARADC internal NEG selection for Single ended conversion</description>
              <bitRange>[11:9]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>VSSA_KELVIN</name>
                  <description>NEG input of SARADC is connected to 'vssa_kelvin', gives more precision around zero. Note this opens both SARADC internal switches, therefore use this value to insert a break-before-make cycle on those switches when SWITCH_DISABLE is high.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ART_VSSA</name>
                  <description>NEG input of SARADC is connected to VSSA in AROUTE close to the SARADC</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>P1</name>
                  <description>NEG input of SARADC is connected to P1 pin of SARMUX</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>P3</name>
                  <description>NEG input of SARADC is connected to P3 pin of SARMUX</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>P5</name>
                  <description>NEG input of SARADC is connected to P5 pin of SARMUX</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>P7</name>
                  <description>NEG input of SARADC is connected to P7 pin of SARMUX</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ACORE</name>
                  <description>NEG input of SARADC is connected to an ACORE in AROUTE</description>
                  <value>6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VREF</name>
                  <description>NEG input of SARADC is shorted with VREF input of SARADC.</description>
                  <value>7</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SAR_HW_CTRL_NEGVREF</name>
              <description>Hardware control: 0=only firmware control, 1=hardware control masked by firmware setting for VREF to NEG switch.</description>
              <bitRange>[13:13]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PWR_CTRL_VREF</name>
              <description>VREF buffer low power mode.</description>
              <bitRange>[15:14]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NORMAL_PWR</name>
                  <description>normal power (default), bypass cap, max clk_sar is 18MHz.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HALF_PWR</name>
                  <description>deprecated</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>THIRD_PWR</name>
                  <description>Invalid for PSoC4A, otherwise 2X power, no bypass cap, max clk_sar is 1.8MHz</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>QUARTER_PWR</name>
                  <description>deprecated</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SPARE</name>
              <description>Spare controls, not yet designated, for late changes done with an ECO</description>
              <bitRange>[19:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BOOSTPUMP_EN</name>
              <description>SARADC internal pump: 0=disabled: pump output is VDDA, 1=enabled: pump output is boosted.</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ICONT_LV</name>
              <description>SARADC low power mode.</description>
              <bitRange>[25:24]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NORMAL_PWR</name>
                  <description>normal power (default), max clk_sar is 18MHz.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HALF_PWR</name>
                  <description>1/2 power mode, max clk_sar is 9MHz.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>MORE_PWR</name>
                  <description>1.333 power mode, max clk_sar is 18MHz.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>QUARTER_PWR</name>
                  <description>1/4 power mode, max clk_sar is 4.5MHz.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DEEPSLEEP_ON</name>
              <description>- 0: SARMUX IP disabled off during DeepSleep power mode
- 1: SARMUX IP remains enabled during DeepSleep power mode (if ENABLED=1)</description>
              <bitRange>[27:27]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DSI_SYNC_CONFIG</name>
              <description>- 0: bypass clock domain synchronisation of the DSI config signals.
- 1: synchronize the DSI config signals to peripheral clock domain.</description>
              <bitRange>[28:28]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DSI_MODE</name>
              <description>SAR sequencer takes configuration from DSI signals (note this also has the same effect as SWITCH_DISABLE==1)
- 0: Normal mode, SAR sequencer operates according to CHAN_EN enables and CHAN_CONFIG channel configurations
- 1: CHAN_EN, INJ_START_EN and channel configurations in CHAN_CONFIG and INJ_CHAN_CONFIG are ignored</description>
              <bitRange>[29:29]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SWITCH_DISABLE</name>
              <description>Disable SAR sequencer from enabling routing switches (note DSI and firmware can always close switches independent of this control)
- 0: Normal mode, SAR sequencer changes switches according to pin address in channel configurations
- 1: Switches disabled, SAR sequencer does not enable any switches, it is the responsibility of the firmware or UDBs (through DSI) to set the switches to route the signal to be converted through the SARMUX</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ENABLED</name>
              <description>Before enabling always make sure the SAR is idle (STATUS.BUSY==0)
- 0: SAR IP disabled (put analog in power down and stop clocks), also can clear FW_TRIGGER and INJ_START_EN (if not tailgaiting) on write.
- 1: SAR IP enabled.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SAMPLE_CTRL</name>
          <description>Sample control register.</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x80008</resetValue>
          <resetMask>0x800F00FF</resetMask>
          <fields>
            <field>
              <name>SUB_RESOLUTION</name>
              <description>Conversion resolution for channels that have sub-resolution enabled (RESOLUTION=1) (otherwise resolution is 12-bit).</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>8B</name>
                  <description>8-bit.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>10B</name>
                  <description>10-bit.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>LEFT_ALIGN</name>
              <description>Left align data in data[15:0], default data is right aligned in data[11:0], with sign extension to 16 bits if the channel is differential.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SINGLE_ENDED_SIGNED</name>
              <description>Output data from a single ended conversion as a signed value</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>UNSIGNED</name>
                  <description>Default: result data is unsigned (zero extended if needed)</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SIGNED</name>
                  <description>result data is signed (sign extended if needed)</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DIFFERENTIAL_SIGNED</name>
              <description>Output data from a differential conversion as a signed value</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>UNSIGNED</name>
                  <description>result data is unsigned (zero extended if needed)</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SIGNED</name>
                  <description>Default: result data is signed (sign extended if needed)</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>AVG_CNT</name>
              <description>Averaging Count for channels that have over sampling enabled (AVG_EN). A channel will be sampled back to back (1&lt;&lt;(AVG_CNT+1)) = [2..256] times before the result is stored and the next enabled channel is sampled (1st order accumulate and dump filter).
If shifting is not enabled (AVG_SHIFT=0) then the result is forced to shift right so that is fits in 16 bits, so right shift is done by max(0,AVG_CNT-3).</description>
              <bitRange>[6:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>AVG_SHIFT</name>
              <description>Averaging shifting: after averaging the result is shifted right to fit in the sample resolution. For averaging the sample resolution is the highest resolution allowed by wounding.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CONTINUOUS</name>
              <description>- 0: Wait for next FW_TRIGGER (one shot) or hardware (DSI) trigger (e.g. from TPWM for periodic triggering) before scanning enabled channels.
- 1: Continuously scan enabled channels, ignore triggers.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DSI_TRIGGER_EN</name>
              <description>- 0: firmware trigger only: disable hardware (DSI) trigger.
- 1: enable hardware (DSI) trigger (e.g. from TCPWM, GPIO or UDB).</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DSI_TRIGGER_LEVEL</name>
              <description>- 0: DSI trigger signal is a pulse input, a positive edge detected on the DSI trigger signal triggers a new scan.
- 1: DSI trigger signal is a level input, as long as the DSI trigger signal remains high the SAR will do continuous scans.</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DSI_SYNC_TRIGGER</name>
              <description>- 0: bypass clock domain synchronisation of the DSI trigger signal.
- 1: synchronize the DSI trigger signal to the SAR clock domain, if needed an edge detect is done in the peripheral clock domain.</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EOS_DSI_OUT_EN</name>
              <description>Enable to output EOS_INTR to DSI. When enabled each time EOS_INTR is set by the hardware also a pulse is send on the dsi_eos signal.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SAMPLE_TIME01</name>
          <description>Sample time specification ST0 and ST1</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x40004</resetValue>
          <resetMask>0x3FF03FF</resetMask>
          <fields>
            <field>
              <name>SAMPLE_TIME0</name>
              <description>Sample time0 (aperture) in ADC clock cycles. Note that actual sample time is half a clock less than specified here. The minimum sample time is 194ns, which is 3.5 cycles (4 in this field) with an 18MHz clock. Minimum legal value in this register is 2.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SAMPLE_TIME1</name>
              <description>Sample time1</description>
              <bitRange>[25:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SAMPLE_TIME23</name>
          <description>Sample time specification ST2 and ST3</description>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x40004</resetValue>
          <resetMask>0x3FF03FF</resetMask>
          <fields>
            <field>
              <name>SAMPLE_TIME2</name>
              <description>Sample time2</description>
              <bitRange>[9:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SAMPLE_TIME3</name>
              <description>Sample time3</description>
              <bitRange>[25:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RANGE_THRES</name>
          <description>Global range detect threshold register.</description>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RANGE_LOW</name>
              <description>Low threshold for range detect.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RANGE_HIGH</name>
              <description>High threshold for range detect.</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RANGE_COND</name>
          <description>Global range detect mode register.</description>
          <addressOffset>0x1C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xC0000000</resetMask>
          <fields>
            <field>
              <name>RANGE_COND</name>
              <description>Range condition select.</description>
              <bitRange>[31:30]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BELOW</name>
                  <description>result &lt; RANGE_LOW</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INSIDE</name>
                  <description>RANGE_LOW &lt;= result &lt; RANGE_HIGH</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ABOVE</name>
                  <description>RANGE_HIGH &lt;= result</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>OUTSIDE</name>
                  <description>result &lt; RANGE_LOW || RANGE_HIGH &lt;= result</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>CHAN_EN</name>
          <description>Enable bits for the channels</description>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>CHAN_EN</name>
              <description>Channel enable. 
- 0: the corresponding channel is disabled.
- 1: the corresponding channel is enabled, it will be included in the next scan.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>START_CTRL</name>
          <description>Start control register (firmware trigger).</description>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1</resetMask>
          <fields>
            <field>
              <name>FW_TRIGGER</name>
              <description>When firmware writes a 1 here it will trigger the next scan of enabled channels, hardware clears this bit when the scan started with this trigger is completed. If scanning continuously the trigger is ignored and hardware clears this bit after the next scan is done. This bit is also cleared when the SAR is disabled.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DFT_CTRL</name>
          <description>DFT control register.</description>
          <addressOffset>0x30</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x2</resetValue>
          <resetMask>0xBF7F0003</resetMask>
          <fields>
            <field>
              <name>DLY_INC</name>
              <description>DFT control: Control for delay circuits on sampling phase, =1 doubes the non-overlap delay</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HIZ</name>
              <description>DFT control for getting higher input impedance, must be 1 (0 is deprecated)</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DFT_INC</name>
              <description>DFT control for preamp inputs</description>
              <bitRange>[19:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DFT_OUTC</name>
              <description>DFT control for preamp outputs</description>
              <bitRange>[22:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SEL_CSEL_DFT</name>
              <description>Usage 1: DFT bits for DAC array
Usage 2: For [0]=1 (when dcen=0): Delay timing for latch enable increased by 20 percent
[1]=1: comparator preamp power level increased by 25 percent</description>
              <bitRange>[27:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EN_CSEL_DFT</name>
              <description>Mux select signal for DAC control</description>
              <bitRange>[28:28]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DCEN</name>
              <description>Delay Control Enable for latch.
- 0: doubles the latch enable time.
- 1: normal latch enable time (default).</description>
              <bitRange>[29:29]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ADFT_OVERRIDE</name>
              <description>During deepsleep/ hibernate mode keep SARMUX active, i.e. do not open all switches (disconnect), to be used for ADFT</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>16</dim>
          <dimIncrement>4</dimIncrement>
          <name>CHAN_CONFIG[%s]</name>
          <description>Channel configuration register.</description>
          <addressOffset>0x80</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x80003777</resetMask>
          <fields>
            <field>
              <name>PIN_ADDR</name>
              <description>Address of the pin to be sampled by this channel. If differential is enabled then PIN_ADDR[0] is ignored and considered to be 0, i.e. PIN_ADDR points to the even pin of a pin pair. For differential the even pin of the pair is connected to Vplus and the odd pin of the pair is connected to Vminus.</description>
              <bitRange>[2:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PORT_ADDR</name>
              <description>Address of the port that contains the pin to be sampled by this channel.</description>
              <bitRange>[6:4]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SARMUX</name>
                  <description>SARMUX pins.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CTB0</name>
                  <description>CTB0</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CTB1</name>
                  <description>CTB1</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CTB2</name>
                  <description>CTB2</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CTB3</name>
                  <description>CTB3</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AROUTE_VIRT2</name>
                  <description>AROUTE virtual port2 (VPORT2)</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AROUTE_VIRT1</name>
                  <description>AROUTE virtual port1 (VPORT1)</description>
                  <value>6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SARMUX_VIRT</name>
                  <description>SARMUX virtual port (VPORT0)</description>
                  <value>7</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DIFFERENTIAL_EN</name>
              <description>Differential enable for this channel.
- 0: The voltage on the addressed pin is measured (Single-ended) and the resulting value is stored in the corresponding data register.
- 1: The differential voltage on the addressed pin pair is measured and the resulting value is stored in the corresponding data register. (PIN_ADDR[0] is ignored).</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESOLUTION</name>
              <description>Resolution for this channel.  When AVG_EN is set this bit is ignored and always a 12-bit resolution (or highest resolution allowed by wounding) is used for this channel.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>MAXRES</name>
                  <description>The maximum resolution is used for this channel (maximum resolution depends on wounding).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SUBRES</name>
                  <description>The resolution specified by SUB_RESOLUTION in the SAR_SAMPLE_CTRL register is used for this channel.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>AVG_EN</name>
              <description>Averaging enable for this channel. If set the AVG_CNT and AVG_SHIFT settings are used for sampling the addressed pin(s)</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SAMPLE_TIME_SEL</name>
              <description>Sample time select: select which of the 4 global sample times to use for this channel</description>
              <bitRange>[13:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DSI_OUT_EN</name>
              <description>DSI data output enable for this channel.
- 0: the conversion result for this channel is only stored in the channel data register and the corresponding CHAN_DATA_VALID bit is set.
- 1: the conversion result for this channel is stored in the channel data register and the corresponding CHAN_DATA_VALID bit is set. The same data (same formating), together with the channel number, is sent out on the DSI communication channel for processing in UDBs.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>16</dim>
          <dimIncrement>4</dimIncrement>
          <name>CHAN_WORK[%s]</name>
          <description>Channel working data register</description>
          <addressOffset>0x100</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x80000000</resetMask>
          <fields>
            <field>
              <name>WORK</name>
              <description>SAR conversion working data of the channel. The data is written here right after sampling this channel.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>CHAN_WORK_VALID_MIR</name>
              <description>mirror bit of corresponding bit in SAR_CHAN_WORK_VALID register</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>16</dim>
          <dimIncrement>4</dimIncrement>
          <name>CHAN_RESULT[%s]</name>
          <description>Channel result data register</description>
          <addressOffset>0x180</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xE0000000</resetMask>
          <fields>
            <field>
              <name>RESULT</name>
              <description>SAR conversion result of the channel. The data is copied here from the WORK field after all enabled channels in this scan have been sampled.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SATURATE_INTR_MIR</name>
              <description>mirror bit of corresponding bit in SAR_SATURATE_INTR register</description>
              <bitRange>[29:29]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>RANGE_INTR_MIR</name>
              <description>mirror bit of corresponding bit in SAR_RANGE_INTR register</description>
              <bitRange>[30:30]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>CHAN_RESULT_VALID_MIR</name>
              <description>mirror bit of corresponding bit in SAR_CHAN_RESULT_VALID register</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CHAN_WORK_VALID</name>
          <description>Channel working data register valid bits</description>
          <addressOffset>0x200</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>CHAN_WORK_VALID</name>
              <description>If set the corresponding WORK data is valid, i.e. was already sampled during the current scan.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CHAN_RESULT_VALID</name>
          <description>Channel result data register valid bits</description>
          <addressOffset>0x204</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>CHAN_RESULT_VALID</name>
              <description>If set the corresponding RESULT data is valid, i.e. was sampled during the last scan.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>STATUS</name>
          <description>Current status of internal SAR registers (mostly for debug)</description>
          <addressOffset>0x208</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xC000001F</resetMask>
          <fields>
            <field>
              <name>CUR_CHAN</name>
              <description>current channel being sampled (channel 16 indicates the injection channel), only valid if BUSY.</description>
              <bitRange>[4:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SW_VREF_NEG</name>
              <description>the current switch status, including DSI and sequencer controls, of the switch in the SARADC that shorts NEG with VREF input (see NEG_SEL).</description>
              <bitRange>[30:30]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>BUSY</name>
              <description>If high then the SAR is busy with a conversion. This bit is always high when CONTINUOUS is set. Firmware should wait for this bit to be low before putting the SAR in power down.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>AVG_STAT</name>
          <description>Current averaging status (for debug)</description>
          <addressOffset>0x20C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF0FFFFF</resetMask>
          <fields>
            <field>
              <name>CUR_AVG_ACCU</name>
              <description>the current value of the averaging accumulator</description>
              <bitRange>[19:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>CUR_AVG_CNT</name>
              <description>the current value of the averaging counter. Note that the value shown is updated after the sampling time and therefore runs ahead of the accumulator update.</description>
              <bitRange>[31:24]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR</name>
          <description>Interrupt request register.</description>
          <addressOffset>0x210</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>EOS_INTR</name>
              <description>End Of Scan Interrupt: hardware sets this interrupt after completing a scan of all the enabled channels. Write with '1' to clear bit.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OVERFLOW_INTR</name>
              <description>Overflow Interrupt: hardware sets this interrupt when it sets a new EOS_INTR while that bit was not yet cleared by the firmware. Write with '1' to clear bit.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FW_COLLISION_INTR</name>
              <description>Firmware Collision Interrupt: hardware sets this interrupt when FW_TRIGGER is asserted while the SAR is BUSY. Raising this interrupt is delayed to when the scan caused by the FW_TRIGGER has been completed, i.e. not when the preceeding scan with which this trigger collided is completed. When this interrupt is set it implies that the channels were sampled later than was intended (jitter). Write with '1' to clear bit.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DSI_COLLISION_INTR</name>
              <description>DSI Collision Interrupt: hardware sets this interrupt when the DSI trigger signal is asserted while the SAR is BUSY. Raising this interrupt is delayed to when the scan caused by the DSI trigger has been completed, i.e. not when the preceeding scan with which this trigger collided is completed. When this interrupt is set it implies that the channels were sampled later than was intended (jitter). Write with '1' to clear bit.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INJ_EOC_INTR</name>
              <description>Injection End of Conversion Interrupt: hardware sets this interrupt after completing the conversion for the injection channel (irrespective of if tailgating was used). Write with '1' to clear bit.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INJ_SATURATE_INTR</name>
              <description>Injection Saturation Interrupt: hardware sets this interrupt if an injection conversion result (before averaging) is either 0x000 or 0xFFF (for 12-bit resolution), this is an indication that the ADC likely saturated. Write with '1' to clear bit.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INJ_RANGE_INTR</name>
              <description>Injection Range detect Interrupt: hardware sets this interrupt if the injection conversion result (after averaging) met the condition specified by the SAR_RANGE registers. Write with '1' to clear bit.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INJ_COLLISION_INTR</name>
              <description>Injection Collision Interrupt: hardware sets this interrupt when the injection trigger signal is asserted (INJ_START_EN==1 &amp;&amp; INJ_TAILGATING==0) while the SAR is BUSY. Raising this interrupt is delayed to when the sampling of the injection channel has been completed, i.e. not when the preceeding scan with which this trigger collided is completed. When this interrupt is set it implies that the injection channel was sampled later than was intended. Write with '1' to clear bit.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_SET</name>
          <description>Interrupt set request register</description>
          <addressOffset>0x214</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>EOS_SET</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OVERFLOW_SET</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FW_COLLISION_SET</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DSI_COLLISION_SET</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INJ_EOC_SET</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INJ_SATURATE_SET</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INJ_RANGE_SET</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INJ_COLLISION_SET</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_MASK</name>
          <description>Interrupt mask register.</description>
          <addressOffset>0x218</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>EOS_MASK</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OVERFLOW_MASK</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FW_COLLISION_MASK</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DSI_COLLISION_MASK</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INJ_EOC_MASK</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INJ_SATURATE_MASK</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INJ_RANGE_MASK</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INJ_COLLISION_MASK</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_MASKED</name>
          <description>Interrupt masked request register</description>
          <addressOffset>0x21C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>EOS_MASKED</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>OVERFLOW_MASKED</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>FW_COLLISION_MASKED</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DSI_COLLISION_MASKED</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>INJ_EOC_MASKED</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>INJ_SATURATE_MASKED</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>INJ_RANGE_MASKED</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>INJ_COLLISION_MASKED</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SATURATE_INTR</name>
          <description>Saturate interrupt request register.</description>
          <addressOffset>0x220</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>SATURATE_INTR</name>
              <description>Saturate Interrupt: hardware sets this interrupt for each channel if a conversion result (before averaging) of that channel is either 0x000 or 0xFFF (for 12-bit resolution), this is an indication that the ADC likely saturated. Write with '1' to clear bit.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SATURATE_INTR_SET</name>
          <description>Saturate interrupt set request register</description>
          <addressOffset>0x224</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>SATURATE_SET</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SATURATE_INTR_MASK</name>
          <description>Saturate interrupt mask register.</description>
          <addressOffset>0x228</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>SATURATE_MASK</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SATURATE_INTR_MASKED</name>
          <description>Saturate interrupt masked request register</description>
          <addressOffset>0x22C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>SATURATE_MASKED</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RANGE_INTR</name>
          <description>Range detect interrupt request register.</description>
          <addressOffset>0x230</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>RANGE_INTR</name>
              <description>Range detect Interrupt: hardware sets this interrupt for each channel if the conversion result (after averaging) of that channel met the condition specified by the SAR_RANGE registers. Write with '1' to clear bit.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RANGE_INTR_SET</name>
          <description>Range detect interrupt set request register</description>
          <addressOffset>0x234</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>RANGE_SET</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RANGE_INTR_MASK</name>
          <description>Range detect interrupt mask register.</description>
          <addressOffset>0x238</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>RANGE_MASK</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RANGE_INTR_MASKED</name>
          <description>Range interrupt masked request register</description>
          <addressOffset>0x23C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>RANGE_MASKED</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_CAUSE</name>
          <description>Interrupt cause register</description>
          <addressOffset>0x240</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xC00000FF</resetMask>
          <fields>
            <field>
              <name>EOS_MASKED_MIR</name>
              <description>Mirror copy of corresponding bit in SAR_INTR_MASKED</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>OVERFLOW_MASKED_MIR</name>
              <description>Mirror copy of corresponding bit in SAR_INTR_MASKED</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>FW_COLLISION_MASKED_MIR</name>
              <description>Mirror copy of corresponding bit in SAR_INTR_MASKED</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DSI_COLLISION_MASKED_MIR</name>
              <description>Mirror copy of corresponding bit in SAR_INTR_MASKED</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>INJ_EOC_MASKED_MIR</name>
              <description>Mirror copy of corresponding bit in SAR_INTR_MASKED</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>INJ_SATURATE_MASKED_MIR</name>
              <description>Mirror copy of corresponding bit in SAR_INTR_MASKED</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>INJ_RANGE_MASKED_MIR</name>
              <description>Mirror copy of corresponding bit in SAR_INTR_MASKED</description>
              <bitRange>[6:6]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>INJ_COLLISION_MASKED_MIR</name>
              <description>Mirror copy of corresponding bit in SAR_INTR_MASKED</description>
              <bitRange>[7:7]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SATURATE_MASKED_RED</name>
              <description>Reduction OR of all SAR_SATURATION_INTR_MASKED bits</description>
              <bitRange>[30:30]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>RANGE_MASKED_RED</name>
              <description>Reduction OR of all SAR_RANGE_INTR_MASKED bits</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INJ_CHAN_CONFIG</name>
          <description>Injection channel configuration register.</description>
          <addressOffset>0x280</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xC0003777</resetMask>
          <fields>
            <field>
              <name>INJ_PIN_ADDR</name>
              <description>Address of the pin to be sampled by this injection channel. If differential is enabled then PIN_ADDR[0] is ignored and considered to be 0, i.e. PIN_ADDR points to the even pin of a pin pair.</description>
              <bitRange>[2:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INJ_PORT_ADDR</name>
              <description>Address of the port that contains the pin to be sampled by this channel.</description>
              <bitRange>[6:4]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SARMUX</name>
                  <description>SARMUX pins.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CTB0</name>
                  <description>CTB0</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CTB1</name>
                  <description>CTB1</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CTB2</name>
                  <description>CTB2</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CTB3</name>
                  <description>CTB3</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AROUTE_VIRT</name>
                  <description>AROUTE virtual port</description>
                  <value>6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SARMUX_VIRT</name>
                  <description>SARMUX virtual port</description>
                  <value>7</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INJ_DIFFERENTIAL_EN</name>
              <description>Differential enable for this channel.
- 0: The voltage on the addressed pin is measured (Single-ended) and the resulting value is stored in the corresponding data register.
- 1: The differential voltage on the addressed pin pair is measured and the resulting value is stored in the corresponding data register. (INJ_PIN_ADDR[0] is ignored).</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INJ_RESOLUTION</name>
              <description>Resolution for this channel.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>12B</name>
                  <description>12-bit resolution is used for this channel.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SUBRES</name>
                  <description>The resolution specified by SUB_RESOLUTION in the SAR_SAMPLE_CTRL register is used for this channel.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INJ_AVG_EN</name>
              <description>Averaging enable for this channel. If set the AVG_CNT and AVG_SHIFT settings are used for sampling the addressed pin(s)</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INJ_SAMPLE_TIME_SEL</name>
              <description>Injection sample time select: select which of the 4 global sample times to use for this channel</description>
              <bitRange>[13:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INJ_TAILGATING</name>
              <description>Injection channel tailgating.
- 0: no tailgating for this channel, SAR is immediately triggered when the INJ_START_EN bit is set if the SAR is not busy. If the SAR is busy, the INJ
     channel addressed pin is sampled at the end of the current scan.
- 1: injection channel tailgating. The addressed pin is sampled after the next trigger and after all enabled channels have been scanned.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INJ_START_EN</name>
              <description>Set by firmware to enable the injection channel. If INJ_TAILGATING is not set this bit also functions as trigger for this channel. Cleared by hardware after this channel has been sampled (i.e. this channel is always one shot even if CONTINUOUS is set). Also cleared if the SAR is disabled.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INJ_RESULT</name>
          <description>Injection channel result register</description>
          <addressOffset>0x290</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xF0000000</resetMask>
          <fields>
            <field>
              <name>INJ_RESULT</name>
              <description>SAR conversion result of the channel.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>INJ_COLLISION_INTR_MIR</name>
              <description>mirror bit of corresponding bit in SAR_INTR register</description>
              <bitRange>[28:28]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>INJ_SATURATE_INTR_MIR</name>
              <description>mirror bit of corresponding bit in SAR_INTR register</description>
              <bitRange>[29:29]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>INJ_RANGE_INTR_MIR</name>
              <description>mirror bit of corresponding bit in SAR_INTR register</description>
              <bitRange>[30:30]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>INJ_EOC_INTR_MIR</name>
              <description>mirror bit of corresponding bit in SAR_INTR register</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MUX_SWITCH0</name>
          <description>SARMUX Firmware switch controls</description>
          <addressOffset>0x300</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3FFFFFFF</resetMask>
          <fields>
            <field>
              <name>MUX_FW_P0_VPLUS</name>
              <description>Firmware control: 0=open, 1=close switch between pin P0 and vplus signal. Write with '1' to set bit.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_P1_VPLUS</name>
              <description>Firmware control: 0=open, 1=close switch between pin P1 and vplus signal. Write with '1' to set bit.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_P2_VPLUS</name>
              <description>Firmware control: 0=open, 1=close switch between pin P2 and vplus signal. Write with '1' to set bit.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_P3_VPLUS</name>
              <description>Firmware control: 0=open, 1=close switch between pin P3 and vplus signal. Write with '1' to set bit.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_P4_VPLUS</name>
              <description>Firmware control: 0=open, 1=close switch between pin P4 and vplus signal. Write with '1' to set bit.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_P5_VPLUS</name>
              <description>Firmware control: 0=open, 1=close switch between pin P5 and vplus signal. Write with '1' to set bit.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_P6_VPLUS</name>
              <description>Firmware control: 0=open, 1=close switch between pin P6 and vplus signal. Write with '1' to set bit.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_P7_VPLUS</name>
              <description>Firmware control: 0=open, 1=close switch between pin P7 and vplus signal. Write with '1' to set bit.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_P0_VMINUS</name>
              <description>Firmware control: 0=open, 1=close switch between pin P0 and vminus signal. Write with '1' to set bit.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_P1_VMINUS</name>
              <description>Firmware control: 0=open, 1=close switch between pin P1 and vminus signal. Write with '1' to set bit.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_P2_VMINUS</name>
              <description>Firmware control: 0=open, 1=close switch between pin P2 and vminus signal. Write with '1' to set bit.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_P3_VMINUS</name>
              <description>Firmware control: 0=open, 1=close switch between pin P3 and vminus signal. Write with '1' to set bit.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_P4_VMINUS</name>
              <description>Firmware control: 0=open, 1=close switch between pin P4 and vminus signal. Write with '1' to set bit.</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_P5_VMINUS</name>
              <description>Firmware control: 0=open, 1=close switch between pin P5 and vminus signal. Write with '1' to set bit.</description>
              <bitRange>[13:13]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_P6_VMINUS</name>
              <description>Firmware control: 0=open, 1=close switch between pin P6 and vminus signal. Write with '1' to set bit.</description>
              <bitRange>[14:14]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_P7_VMINUS</name>
              <description>Firmware control: 0=open, 1=close switch between pin P7 and vminus signal. Write with '1' to set bit.</description>
              <bitRange>[15:15]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_VSSA_VMINUS</name>
              <description>Firmware control: 0=open, 1=close switch between vssa_kelvin and vminus signal. Write with '1' to set bit.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_TEMP_VPLUS</name>
              <description>Firmware control: 0=open, 1=close switch between temperature sensor and vplus signal, also powers on the temperature sensor. Write with '1' to set bit.</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_AMUXBUSA_VPLUS</name>
              <description>Firmware control: 0=open, 1=close switch between amuxbusa and vplus signal. Write with '1' to set bit.</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_AMUXBUSB_VPLUS</name>
              <description>Firmware control: 0=open, 1=close switch between amuxbusb and vplus signal. Write with '1' to set bit.</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_AMUXBUSA_VMINUS</name>
              <description>Firmware control: 0=open, 1=close switch between amuxbusa and vminus signal. Write with '1' to set bit.</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_AMUXBUSB_VMINUS</name>
              <description>Firmware control: 0=open, 1=close switch between amuxbusb and vminus signal. Write with '1' to set bit.</description>
              <bitRange>[21:21]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_SARBUS0_VPLUS</name>
              <description>Firmware control: 0=open, 1=close switch between sarbus0 and vplus signal. Write with '1' to set bit.</description>
              <bitRange>[22:22]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_SARBUS1_VPLUS</name>
              <description>Firmware control: 0=open, 1=close switch between sarbus1 and vplus signal. Write with '1' to set bit.</description>
              <bitRange>[23:23]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_SARBUS0_VMINUS</name>
              <description>Firmware control: 0=open, 1=close switch between sarbus0 and vminus signal. Write with '1' to set bit.</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_SARBUS1_VMINUS</name>
              <description>Firmware control: 0=open, 1=close switch between sarbus1 and vminus signal. Write with '1' to set bit.</description>
              <bitRange>[25:25]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_P4_COREIO0</name>
              <description>Firmware control: 0=open, 1=close switch between P4 and coreio0 signal. Write with '1' to set bit.</description>
              <bitRange>[26:26]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_P5_COREIO1</name>
              <description>Firmware control: 0=open, 1=close switch between P5 and coreio1 signal. Write with '1' to set bit.</description>
              <bitRange>[27:27]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_P6_COREIO2</name>
              <description>Firmware control: 0=open, 1=close switch between P6 and coreio2 signal. Write with '1' to set bit.</description>
              <bitRange>[28:28]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_P7_COREIO3</name>
              <description>Firmware control: 0=open, 1=close switch between P7 and coreio3 signal. Write with '1' to set bit.</description>
              <bitRange>[29:29]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MUX_SWITCH_CLEAR0</name>
          <description>SARMUX Firmware switch control clear</description>
          <addressOffset>0x304</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3FFFFFFF</resetMask>
          <fields>
            <field>
              <name>MUX_FW_P0_VPLUS</name>
              <description>Write '1' to clear corresponding bit in MUX_SWITCH0</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_P1_VPLUS</name>
              <description>Write '1' to clear corresponding bit in MUX_SWITCH0</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_P2_VPLUS</name>
              <description>Write '1' to clear corresponding bit in MUX_SWITCH0</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_P3_VPLUS</name>
              <description>Write '1' to clear corresponding bit in MUX_SWITCH0</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_P4_VPLUS</name>
              <description>Write '1' to clear corresponding bit in MUX_SWITCH0</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_P5_VPLUS</name>
              <description>Write '1' to clear corresponding bit in MUX_SWITCH0</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_P6_VPLUS</name>
              <description>Write '1' to clear corresponding bit in MUX_SWITCH0</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_P7_VPLUS</name>
              <description>Write '1' to clear corresponding bit in MUX_SWITCH0</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_P0_VMINUS</name>
              <description>Write '1' to clear corresponding bit in MUX_SWITCH0</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_P1_VMINUS</name>
              <description>Write '1' to clear corresponding bit in MUX_SWITCH0</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_P2_VMINUS</name>
              <description>Write '1' to clear corresponding bit in MUX_SWITCH0</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_P3_VMINUS</name>
              <description>Write '1' to clear corresponding bit in MUX_SWITCH0</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_P4_VMINUS</name>
              <description>Write '1' to clear corresponding bit in MUX_SWITCH0</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_P5_VMINUS</name>
              <description>Write '1' to clear corresponding bit in MUX_SWITCH0</description>
              <bitRange>[13:13]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_P6_VMINUS</name>
              <description>Write '1' to clear corresponding bit in MUX_SWITCH0</description>
              <bitRange>[14:14]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_P7_VMINUS</name>
              <description>Write '1' to clear corresponding bit in MUX_SWITCH0</description>
              <bitRange>[15:15]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_VSSA_VMINUS</name>
              <description>Write '1' to clear corresponding bit in MUX_SWITCH0</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_TEMP_VPLUS</name>
              <description>Write '1' to clear corresponding bit in MUX_SWITCH0</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_AMUXBUSA_VPLUS</name>
              <description>Write '1' to clear corresponding bit in MUX_SWITCH0</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_AMUXBUSB_VPLUS</name>
              <description>Write '1' to clear corresponding bit in MUX_SWITCH0</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_AMUXBUSA_VMINUS</name>
              <description>Write '1' to clear corresponding bit in MUX_SWITCH0</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_AMUXBUSB_VMINUS</name>
              <description>Write '1' to clear corresponding bit in MUX_SWITCH0</description>
              <bitRange>[21:21]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_SARBUS0_VPLUS</name>
              <description>Write '1' to clear corresponding bit in MUX_SWITCH0</description>
              <bitRange>[22:22]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_SARBUS1_VPLUS</name>
              <description>Write '1' to clear corresponding bit in MUX_SWITCH0</description>
              <bitRange>[23:23]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_SARBUS0_VMINUS</name>
              <description>Write '1' to clear corresponding bit in MUX_SWITCH0</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_SARBUS1_VMINUS</name>
              <description>Write '1' to clear corresponding bit in MUX_SWITCH0</description>
              <bitRange>[25:25]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_P4_COREIO0</name>
              <description>Write '1' to clear corresponding bit in MUX_SWITCH0</description>
              <bitRange>[26:26]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_P5_COREIO1</name>
              <description>Write '1' to clear corresponding bit in MUX_SWITCH0</description>
              <bitRange>[27:27]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_P6_COREIO2</name>
              <description>Write '1' to clear corresponding bit in MUX_SWITCH0</description>
              <bitRange>[28:28]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_P7_COREIO3</name>
              <description>Write '1' to clear corresponding bit in MUX_SWITCH0</description>
              <bitRange>[29:29]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MUX_SWITCH1</name>
          <description>SARMUX Firmware switch controls</description>
          <addressOffset>0x308</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xF</resetMask>
          <fields>
            <field>
              <name>MUX_FW_P4_DFT_INP</name>
              <description>Firmware control: 0=open, 1=close switch between P4 pin and dft_inp signal. Write with '1' to set bit.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_P5_DFT_INM</name>
              <description>Firmware control: 0=open, 1=close switch between P5 pin and dft_inm signal. Write with '1' to set bit.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_ADFT0_SARBUS0</name>
              <description>Firmware control: 0=open, 1=close switch between adft0 signal and sarbus0 signal. Write with '1' to set bit.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_ADFT1_SARBUS1</name>
              <description>Firmware control: 0=open, 1=close switch between adft1 signal and sarbus1 signal. Write with '1' to set bit.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MUX_SWITCH_CLEAR1</name>
          <description>SARMUX Firmware switch control clear</description>
          <addressOffset>0x30C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xF</resetMask>
          <fields>
            <field>
              <name>MUX_FW_P4_DFT_INP</name>
              <description>Write '1' to clear corresponding bit in MUX_SWITCH1</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_P5_DFT_INM</name>
              <description>Write '1' to clear corresponding bit in MUX_SWITCH1</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_ADFT0_SARBUS0</name>
              <description>Write '1' to clear corresponding bit in MUX_SWITCH1</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_ADFT1_SARBUS1</name>
              <description>Write '1' to clear corresponding bit in MUX_SWITCH1</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MUX_SWITCH_HW_CTRL</name>
          <description>SARMUX switch hardware control</description>
          <addressOffset>0x340</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xCF00FF</resetMask>
          <fields>
            <field>
              <name>MUX_HW_CTRL_P0</name>
              <description>Hardware control: 0=only firmware control, 1=hardware control masked by firmware setting for pin P0 switches.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_HW_CTRL_P1</name>
              <description>Hardware control: 0=only firmware control, 1=hardware control masked by firmware setting for pin P1 switches.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_HW_CTRL_P2</name>
              <description>Hardware control: 0=only firmware control, 1=hardware control masked by firmware setting for pin P2 switches.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_HW_CTRL_P3</name>
              <description>Hardware control: 0=only firmware control, 1=hardware control masked by firmware setting for pin P3 switches.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_HW_CTRL_P4</name>
              <description>Hardware control: 0=only firmware control, 1=hardware control masked by firmware setting for pin P4 switches.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_HW_CTRL_P5</name>
              <description>Hardware control: 0=only firmware control, 1=hardware control masked by firmware setting for pin P5 switches.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_HW_CTRL_P6</name>
              <description>Hardware control: 0=only firmware control, 1=hardware control masked by firmware setting for pin P6 switches.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_HW_CTRL_P7</name>
              <description>Hardware control: 0=only firmware control, 1=hardware control masked by firmware setting for pin P7 switches.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_HW_CTRL_VSSA</name>
              <description>Hardware control: 0=only firmware control, 1=hardware control masked by firmware setting for vssa switch.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_HW_CTRL_TEMP</name>
              <description>Hardware control: 0=only firmware control, 1=hardware control masked by firmware setting for temp switch.</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_HW_CTRL_AMUXBUSA</name>
              <description>Hardware control: 0=only firmware control, 1=hardware control masked by firmware setting for amuxbusa switches.</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_HW_CTRL_AMUXBUSB</name>
              <description>Hardware control: 0=only firmware control, 1=hardware control masked by firmware setting for amuxbusb switches.</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_HW_CTRL_SARBUS0</name>
              <description>Hardware control: 0=only firmware control, 1=hardware control masked by firmware setting for sarbus0 switches.</description>
              <bitRange>[22:22]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_HW_CTRL_SARBUS1</name>
              <description>Hardware control: 0=only firmware control, 1=hardware control masked by firmware setting for sarbus1 switches.</description>
              <bitRange>[23:23]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MUX_SWITCH_STATUS</name>
          <description>SARMUX switch status</description>
          <addressOffset>0x348</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3FFFFFF</resetMask>
          <fields>
            <field>
              <name>MUX_FW_P0_VPLUS</name>
              <description>switch status of corresponding bit in MUX_SWITCH0</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MUX_FW_P1_VPLUS</name>
              <description>switch status of corresponding bit in MUX_SWITCH0</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MUX_FW_P2_VPLUS</name>
              <description>switch status of corresponding bit in MUX_SWITCH0</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MUX_FW_P3_VPLUS</name>
              <description>switch status of corresponding bit in MUX_SWITCH0</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MUX_FW_P4_VPLUS</name>
              <description>switch status of corresponding bit in MUX_SWITCH0</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MUX_FW_P5_VPLUS</name>
              <description>switch status of corresponding bit in MUX_SWITCH0</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MUX_FW_P6_VPLUS</name>
              <description>switch status of corresponding bit in MUX_SWITCH0</description>
              <bitRange>[6:6]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MUX_FW_P7_VPLUS</name>
              <description>switch status of corresponding bit in MUX_SWITCH0</description>
              <bitRange>[7:7]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MUX_FW_P0_VMINUS</name>
              <description>switch status of corresponding bit in MUX_SWITCH0</description>
              <bitRange>[8:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MUX_FW_P1_VMINUS</name>
              <description>switch status of corresponding bit in MUX_SWITCH0</description>
              <bitRange>[9:9]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MUX_FW_P2_VMINUS</name>
              <description>switch status of corresponding bit in MUX_SWITCH0</description>
              <bitRange>[10:10]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MUX_FW_P3_VMINUS</name>
              <description>switch status of corresponding bit in MUX_SWITCH0</description>
              <bitRange>[11:11]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MUX_FW_P4_VMINUS</name>
              <description>switch status of corresponding bit in MUX_SWITCH0</description>
              <bitRange>[12:12]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MUX_FW_P5_VMINUS</name>
              <description>switch status of corresponding bit in MUX_SWITCH0</description>
              <bitRange>[13:13]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MUX_FW_P6_VMINUS</name>
              <description>switch status of corresponding bit in MUX_SWITCH0</description>
              <bitRange>[14:14]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MUX_FW_P7_VMINUS</name>
              <description>switch status of corresponding bit in MUX_SWITCH0</description>
              <bitRange>[15:15]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MUX_FW_VSSA_VMINUS</name>
              <description>switch status of corresponding bit in MUX_SWITCH0</description>
              <bitRange>[16:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MUX_FW_TEMP_VPLUS</name>
              <description>switch status of corresponding bit in MUX_SWITCH0</description>
              <bitRange>[17:17]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MUX_FW_AMUXBUSA_VPLUS</name>
              <description>switch status of corresponding bit in MUX_SWITCH0</description>
              <bitRange>[18:18]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MUX_FW_AMUXBUSB_VPLUS</name>
              <description>switch status of corresponding bit in MUX_SWITCH0</description>
              <bitRange>[19:19]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MUX_FW_AMUXBUSA_VMINUS</name>
              <description>switch status of corresponding bit in MUX_SWITCH0</description>
              <bitRange>[20:20]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MUX_FW_AMUXBUSB_VMINUS</name>
              <description>switch status of corresponding bit in MUX_SWITCH0</description>
              <bitRange>[21:21]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MUX_FW_SARBUS0_VPLUS</name>
              <description>switch status of corresponding bit in MUX_SWITCH0</description>
              <bitRange>[22:22]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MUX_FW_SARBUS1_VPLUS</name>
              <description>switch status of corresponding bit in MUX_SWITCH0</description>
              <bitRange>[23:23]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MUX_FW_SARBUS0_VMINUS</name>
              <description>switch status of corresponding bit in MUX_SWITCH0</description>
              <bitRange>[24:24]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MUX_FW_SARBUS1_VMINUS</name>
              <description>switch status of corresponding bit in MUX_SWITCH0</description>
              <bitRange>[25:25]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PUMP_CTRL</name>
          <description>Switch pump control</description>
          <addressOffset>0x380</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x80000001</resetMask>
          <fields>
            <field>
              <name>CLOCK_SEL</name>
              <description>Clock select: 0=external clock, 1=internal clock (deprecated).</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ENABLED</name>
              <description>0=disabled: pump output is VDDA_PUMP, 1=enabled: pump output is boosted.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ANA_TRIM</name>
          <description>Analog trim register.</description>
          <addressOffset>0xF00</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xF</resetMask>
          <fields>
            <field>
              <name>CAP_TRIM</name>
              <description>Attenuation cap trimming</description>
              <bitRange>[2:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TRIMUNIT</name>
              <description>Attenuation cap trimming</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>WOUNDING</name>
          <description>SAR wounding register</description>
          <addressOffset>0xF04</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3</resetMask>
          <fields>
            <field>
              <name>WOUND_RESOLUTION</name>
              <description>Maximum SAR resolution allowed</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>12BIT</name>
                  <description>unwounded: up to full 12-bit SAR resolution allowed</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>10BIT</name>
                  <description>wounded: max resolution upto 10-bit SAR resolution allowed</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>8BIT</name>
                  <description>wounded: only 8-bit SAR resolution allowed</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>8BIT_TOO</name>
                  <description>wounded: only 8-bit SAR resolution allowed</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>PASS0</name>
      <description>PASS top-level MMIO (DSAB, INTR)</description>
      <headerStructName>PASS</headerStructName>
      <baseAddress>0x403F0000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>65536</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>INTR_CAUSE</name>
          <description>Interrupt cause register</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xF</resetMask>
          <fields>
            <field>
              <name>CTB0_INT</name>
              <description>CTB0 interrupt pending</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>CTB1_INT</name>
              <description>CTB1 interrupt pending</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>CTB2_INT</name>
              <description>CTB2 interrupt pending</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>CTB3_INT</name>
              <description>CTB3 interrupt pending</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DFT_CTRL</name>
          <description>DFT control register</description>
          <addressOffset>0x30</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1</resetMask>
          <fields>
            <field>
              <name>DSAB_ADFT_RES_EN</name>
              <description>Close the switch to connect the DSAB ADFT resistor to the AMUXBUS</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <cluster>
          <name>DSAB</name>
          <description>DSAB configuration</description>
          <addressOffset>0x00000E00</addressOffset>
          <register>
            <name>DSAB_CTRL</name>
            <description>global DSAB control</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x80000F3F</resetMask>
            <fields>
              <field>
                <name>CURRENT_SEL</name>
                <description>current selection for dsab_ibias, dsab_ibias = CURRENT_SEL * 0.075 uA (+/-5 percent)</description>
                <bitRange>[5:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SEL_OUT</name>
                <description>selection for ibias_out&lt;n&gt; and irefout_ptat_2pt4&lt;n&gt;
0: bypass respectively irefin_0tc_2pt4&lt;n&gt; and bypass irefin_ptat_2pt4&lt;n&gt;
1: drive respectively replicated dsab_ibias&lt;n&gt; and 0.</description>
                <bitRange>[11:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ENABLED</name>
                <description>- 0: DSAB IP disabled (put analog in power down, put all iref in bypass)
- 1: DSAB IP enabled</description>
                <bitRange>[31:31]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DSAB_DFT</name>
            <description>DFT bits</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xF</resetMask>
            <fields>
              <field>
                <name>EN_DFT</name>
                <description>- 0: DSAB DFT disabled
- 1: DSAB DFT enabled (connect output to amuxbus)</description>
                <bitRange>[3:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
        <register>
          <name>DSAB_TRIM</name>
          <description>DSAB Trim bits</description>
          <addressOffset>0xF00</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xF</resetMask>
          <fields>
            <field>
              <name>IBIAS_TRIM</name>
              <description>1111=lowest, 0000=highest</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
  </peripherals>
</device>