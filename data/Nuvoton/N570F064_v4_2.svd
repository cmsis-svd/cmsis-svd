<?xml version="1.0" encoding="utf-8"?>
<device schemaVersion="1.1" xmlns:xs="http://www.w3.org/2001/XMLSchema-instance" xs:noNamespaceSchemaLocation="CMSIS-SVD_Schema_1_1.xsd" >
  <name>N570F064_v4_2</name>
  <version>1.0</version>
  <description>N570F064_v4_2 SVD file</description>
  <!-- Bus Interface Properties -->
  <!-- Cortex-M0 is byte addressable -->
  <addressUnitBits>8</addressUnitBits>
  <!-- the maximum data bit width accessible within a single transfer is 32bits -->
  <width>32</width>

  <!-- Register Default Properties -->
  <!-- the size of the registers is set to a bit width of 32. This can be overruled for individual peripherals and/or registers -->
  <size>32</size>
  <!-- the access to all registers is set to be readable and writeable. This can be overruled for individual peripherals and/or registers -->
  <access>read-write</access>
  <!-- for demonstration purposes the resetValue for all registers of the device is set to be 0. This can be overruled within the description -->
  <resetValue>0</resetValue>
  <!-- the resetMask = 0 specifies that by default no register of this device has a defined reset value -->
  <resetMask>0</resetMask>

  <peripherals>
    <peripheral>
      <name>SYS</name>
      <description>SYS Register Map</description>
      <groupName>SYS</groupName>
      <baseAddress>0x50000000</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x0</offset>
        <size>0x10</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x18</offset>
        <size>0x4</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x30</offset>
        <size>0xC</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x40</offset>
        <size>0x8</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x4C</offset>
        <size>0x4</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x54</offset>
        <size>0x4</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x5C</offset>
        <size>0x4</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0xF0</offset>
        <size>0x14</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x110</offset>
        <size>0xC</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>SYS_PDID</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SYS_PDID</displayName>
          <description>Product Identifier Register</description>
          <addressOffset>0x0</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>IMG2</name>
              <description>Product Identifier\nData in MAP2 of information block are copied to this register after power on. MAP2 is used to store part number defined by Nuvoton.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SYS_RSTSTS</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SYS_RSTSTS</displayName>
          <description>System Reset Source Register</description>
          <addressOffset>0x4</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFF000</resetMask>
          <fields>
            <field>
              <name>PORF</name>
              <description>POR Reset Flag \nThe POR reset flag is set by the "Reset Signal" from the Power-on Reset (POR) Controller to indicate the previous reset source. \nNote: Write 1 to clear this bit to 0.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No reset from POR</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Power-on Reset (POR) Controller had issued the reset signal to reset the system</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PINRF</name>
              <description>RESETB Pin Reset Flag \nThe RESETB pin reset flag is set by the "Reset Signal" from the RESETB Pin to indicate the previous reset source. \nNote: Write 1 to clear this bit to 0.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No reset from RESETB pin</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Pin RESETB had issued the reset signal to reset the system</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>WDTRF</name>
              <description>Reset Source From WDG\nThe WDTRF flag is set if pervious reset source originates from the Watch-Dog module.\nNote: Write 1 to clear this bit to 0.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No reset from Watch-Dog</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The Watch-Dog module issued the reset signal to reset the system</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>LVRF</name>
              <description>LVR Reset Flag \nThe LVR reset flag is set by the "Reset Signal" from the Low Voltage Reset Controller to indicate the previous reset source. \nNote: Write 1 to clear this bit to 0.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No reset from LVR</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>LVR controller had issued the reset signal to reset the system</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BOD</name>
              <description>BOD Reset Flag \nThe BOD reset flag is set by the "Reset Signal" from the Brown Out Reset Controller to indicate the previous reset source. \nNote: Write 1 to clear this bit to 0.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No reset from BOD</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>BOD controller had issued the reset signal to reset the system</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PMURSTF</name>
              <description>Reset Source From PMU\nThe PMURSTF flag is set by the reset signal from the PMU module to indicate the previous reset source.\nNote: Write 1 to clear this bit to 0.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No reset from PMU</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The PMU has issued the reset signal to reset the system</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PIN_WK</name>
              <description>Wakeup from DPD From PIN\nThe device was woken from Deep Power Down by a low transition on the WAKEUP in or RESETB pin. \nNote: Write 1 to this register to clear all wakeup flags.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No wakeup from PIN</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The device was issued a wakeup from DPD by a pin transition</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TIM_WK</name>
              <description>Wakeup from DPD From TIMER\nThe device was woken from Deep Power Down by count of 10kHz timer. \n</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No wakeup from TIMER</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The device was issued a wakeup from DPD by a TIMER event</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>POR_WK</name>
              <description>Wakeup from DPD From POR\nThe device was woken from Deep Power Down by a Power On Reset. \n</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No wakeup from POR</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The device was issued a wakeup from DPD by a POR</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SYS_IPRST0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SYS_IPRST0</displayName>
          <description>IP Reset Control Resister0</description>
          <addressOffset>0x8</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CHIPRST</name>
              <description>CHIP One Shot Reset\nSet this bit will reset the whole chip, this bit will automatically return to "0" after 2 clock cycles.\nCHIPRST is same as POR reset, all the chip modules are reset and the chip configuration settings from Flash Memory are reloaded.\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Normal</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reset CHIP</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CPURST</name>
              <description>CPU Kernel One Shot Reset\nSetting this bit will reset the CPU kernel and Flash Memory Controller(FMC), this bit will automatically return to "0" after the 2 clock cycles\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Normal</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reset CPU</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SYS_IPRST1</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SYS_IPRST1</displayName>
          <description>IP Reset Control Resister1</description>
          <addressOffset>0xC</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>GPIORST</name>
              <description>GPIO Controller Reset\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Normal operation</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reset</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TMR0RST</name>
              <description>Timer0 Controller Reset\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Normal Operation</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reset</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TMR1RST</name>
              <description>Timer1 Controller Reset\n</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Normal Operation</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reset</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TMR2RST</name>
              <description>Timer2 Controller Reset\n</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Normal operation</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reset</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TMRFRST</name>
              <description>TimerF Controller Reset\n</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Normal operation</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reset</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PDMARST</name>
              <description>PDMA Controller Reset\n</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Normal operation</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reset</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SPI0RST</name>
              <description>SPI0 Controller Reset\n</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Normal Operation</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reset</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SPIMRST</name>
              <description>SPIM Controller Reset\n</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Normal Operation</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reset</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PWM0RST</name>
              <description>PWM0 Controller Reset\n</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Normal Operation</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reset</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PWM1RST</name>
              <description>PWM1 Controller Reset\n</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Normal Operation</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reset</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ADCRST</name>
              <description>ADC Controller Reset \n</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Normal Operation</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reset</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DPWMRST</name>
              <description>DPWM Controller Reset \n</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Normal Operation</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reset</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SYS_BODCTL</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SYS_BODCTL</displayName>
          <description>Brown-out Detector Control Register</description>
          <addressOffset>0x18</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFF0FF00</resetMask>
          <fields>
            <field>
              <name>BOD_EN</name>
              <description>Brown-Out Detector Enable (Initialized &amp; Protected Bit)\nThe default value is set by flash controller as inverse of user configuration CBODEN bit (config0 [20]). \n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Brown-Out Detector function is disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Brown-Out Detector function enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BOD_RSTEN</name>
              <description>Brown-Out Detector Reset or Interrupt Bit (Initialized &amp; Protected Bit)\nThe default value is set by flash controller as inverse of user configuration CBORST bit (config0 [21]). \nWhen the BOD is enabled and the interrupt is asserted, the interrupt will be kept till the BOD is disabled. The interrupt for CPU can be blocked either by disabling the interrupt in the NVIC or by disabling the interrupt source by disabling the BOD. BOD can then be re-enabled as required.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Brown-Out Detector generate an interrupt</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Brown-Out Detector will reset chip</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BOD_LVL</name>
              <description>Brown-Out Detector Threshold Voltage Selection (Initialized &amp; Protected Bit)\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>BOD_HYS</name>
              <description>Brown-Out Detector Hysteresis  (Initialized &amp; Protected Bit)\nThe default value is set by flash controller user configuration CBOV[4] bit (config0 [26]). \n</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No hysteresis on BOD detection</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>BOD hysteresis enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BOD_OUT</name>
              <description>Brown-Out Detector Output State \n</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Brown-out Detector status output is 0, the detected voltage is higher than BOD_VL setting</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Brown-out Detector status output is 1, the detected voltage is lower than BOD_VL setting</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BOD_INT</name>
              <description>Brown-Out Detector Interrupt\n</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>1</name>
                    <description>indicates BOD_INT is active. Write 1 to clear</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>LVR_EN</name>
              <description>Low Voltage Reset (LVR) Enable (Initialized &amp; Protected Bit)\nThe LVR function resets the chip when the input power voltage is lower than LVR trip point. Default value is set by flash controller as inverse of CLVR (config0 [27]). \n</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disable LVR function</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable LVR function</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>LVR_FILTER</name>
              <description>Default value is 00</description>
              <bitOffset>17</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>LVR output will be filtered by1 HCLK</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>LVR output will be filtered by 2 HCLK</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>LVR output will be filtered by 8 HCLK</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>LVR output will be filtered by 15 HCLK</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SYS_GPA_MFP</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SYS_GPA_MFP</displayName>
          <description>GPIO PA Multiple Alternate Functions Control Register</description>
          <addressOffset>0x30</addressOffset>
          <access>read-write</access>
          <resetValue>0x55000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PA0MFP</name>
              <description>PA.0 Multi-function Pin Selection\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PA1MFP</name>
              <description>PA.1 Multi-function Pin Selection\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PA2MFP</name>
              <description>PA.2 Multi-function Pin Selection\n</description>
              <bitOffset>4</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PA3MFP</name>
              <description>PA.3 Multi-function Pin Selection\n</description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PA4MFP</name>
              <description>PA.4 Multi-function Pin Selection\n</description>
              <bitOffset>8</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PA5MFP</name>
              <description>PA.5 Multi-function Pin Selection\n</description>
              <bitOffset>10</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PA6MFP</name>
              <description>PA.6 Multi-function Pin Selection\n</description>
              <bitOffset>12</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PA7MFP</name>
              <description>PA.7 Multi-function Pin Selection\n</description>
              <bitOffset>14</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PA8MFP</name>
              <description>PA.8 Multi-function Pin Selection\n</description>
              <bitOffset>16</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PA9MFP</name>
              <description>PA.9 Multi-function Pin Selection\n</description>
              <bitOffset>18</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PA10MFP</name>
              <description>PA.10 Multi-function Pin Selection\n</description>
              <bitOffset>20</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PA11MFP</name>
              <description>PA.11 Multi-function Pin Selection\n</description>
              <bitOffset>22</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PA12MFP</name>
              <description>PA.12 Multi-function Pin Selection\n</description>
              <bitOffset>24</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PA13MFP</name>
              <description>PA.13 Multi-function Pin Selection\n</description>
              <bitOffset>26</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PA14MFP</name>
              <description>PA.14 Multi-function Pin Selection\n</description>
              <bitOffset>28</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PA15MFP</name>
              <description>PA.15 Multi-function Pin Selection\n</description>
              <bitOffset>30</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SYS_GPB_MFP</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SYS_GPB_MFP</displayName>
          <description>GPIO PB Multiple Alternate Functions Control Register</description>
          <addressOffset>0x34</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PB0MFP</name>
              <description>PB.0 Multi-function Pin Selection\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PB1MFP</name>
              <description>PB.1 Multi-function Pin Selection\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PB2MFP</name>
              <description>PB.2 Multi-function Pin Selection\n</description>
              <bitOffset>4</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PB3MFP</name>
              <description>PB.3 Multi-function Pin Selection\n</description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PB4MFP</name>
              <description>PB.4 Multi-function Pin Selection\n</description>
              <bitOffset>8</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PB5MFP</name>
              <description>PB.5 Multi-function Pin Selection\n</description>
              <bitOffset>10</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SYS_ICE_MFP</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SYS_ICE_MFP</displayName>
          <description>ICE Multi-function-pin Controller Register</description>
          <addressOffset>0x38</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000001</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ICE_EN</name>
              <description>This bit will set  ICE_CLK &amp; ICE_DAT pins to be serial debug wires or PA.6/7\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>ICE_CLK and ICE_DAT will be assigned as PA.6 and PA.7, for general IO purpose</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>ICE_CLK and ICE_DAT will be set as ICE CLOCK/ ICE DIO, only for debugging purpose</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SYS_GPIO_INTP</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SYS_GPIO_INTP</displayName>
          <description>GPIO Input Type and Slew Rate Control Register</description>
          <addressOffset>0x40</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000FFF</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
          </fields>
       </register>
       <register>
          <name>SYS_GPA_PULL</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SYS_GPA_PULL</displayName>
          <description>PA.15 ~ PA.0 Pull Resistance Control Register</description>
          <addressOffset>0x44</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PU_EN0</name>
              <description>This function only for the GPIO pin as an INPUT mode.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Pull-Up function Disable</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Pull-Up  function Enable</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PU_EN1</name>
              <description>This function only for the GPIO pin as an INPUT mode.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Pull-Up function Disable</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Pull-Up  function Enable</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PU_EN2</name>
              <description>This function only for the GPIO pin as an INPUT mode.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Pull-Up function Disable</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Pull-Up  function Enable</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PU_EN3</name>
              <description>This function only for the GPIO pin as an INPUT mode.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Pull-Up function Disable</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Pull-Up  function Enable</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PU_EN4</name>
              <description>This function only for the GPIO pin as an INPUT mode.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Pull-Up function Disable</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Pull-Up  function Enable</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PU_EN5</name>
              <description>This function only for the GPIO pin as an INPUT mode.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Pull-Up function Disable</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Pull-Up  function Enable</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PU_EN6</name>
              <description>This function only for the GPIO pin as an INPUT mode.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Pull-Up function Disable</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Pull-Up  function Enable</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PU_EN7</name>
              <description>This function only for the GPIO pin as an INPUT mode.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Pull-Up function Disable</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Pull-Up  function Enable</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PU_EN8</name>
              <description>This function only for the GPIO pin as an INPUT mode.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Pull-Up function Disable</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Pull-Up  function Enable</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PU_EN9</name>
              <description>This function only for the GPIO pin as an INPUT mode.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Pull-Up function Disable</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Pull-Up  function Enable</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PU_EN10</name>
              <description>This function only for the GPIO pin as an INPUT mode.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Pull-Up function Disable</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Pull-Up  function Enable</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PU_EN11</name>
              <description>This function only for the GPIO pin as an INPUT mode.</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Pull-Up function Disable</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Pull-Up  function Enable</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PU_EN12</name>
              <description>This function only for the GPIO pin as an INPUT mode.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Pull-Up function Disable</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Pull-Up  function Enable</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PU_EN13</name>
              <description>This function only for the GPIO pin as an INPUT mode.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Pull-Up function Disable</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Pull-Up  function Enable</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PU_EN14</name>
              <description>This function only for the GPIO pin as an INPUT mode.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Pull-Up function Disable</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Pull-Up  function Enable</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PU_EN15</name>
              <description>This function only for the GPIO pin as an INPUT mode.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Pull-Up function Disable</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Pull-Up  function Enable</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SYS_GPA_IEN</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SYS_GPA_IEN</displayName>
          <description>PA.15 ~ PA.0 Digital Input Buffer Control Register</description>
          <addressOffset>0x4C</addressOffset>
          <access>read-write</access>
          <resetValue>0x0000F000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>IEN</name>
              <description></description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Input buffer Enabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Input buffer disabled, and input signal always equals to 0</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SYS_GPB_PULL</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SYS_GPB_PULL</displayName>
          <description>PB.5 ~ PB.0 Pull Resistance Control Register</description>
          <addressOffset>0x54</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PU_EN0</name>
              <description>This function only for the GPIO pin as an INPUT mode.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Pull-Up function Disable</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Pull-Up function Enable</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PU_EN1</name>
              <description>This function only for the GPIO pin as an INPUT mode.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Pull-Up function Disable</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Pull-Up function Enable</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PU_EN2</name>
              <description>This function only for the GPIO pin as an INPUT mode.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Pull-Up function Disable</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Pull-Up function Enable</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PU_EN3</name>
              <description>This function only for the GPIO pin as an INPUT mode.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Pull-Up function Disable</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Pull-Up function Enable</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PU_EN4</name>
              <description>This function only for the GPIO pin as an INPUT mode.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Pull-Up function Disable</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Pull-Up function Enable</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PU_EN5</name>
              <description>This function only for the GPIO pin as an INPUT mode.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Pull-Up function Disable</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Pull-Up function Enable</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SYS_GPB_IEN</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SYS_GPB_IEN</displayName>
          <description>PB.5 ~ PB.0 Digital Input Buffer Control Register</description>
          <addressOffset>0x5C</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>IEN</name>
              <description></description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Input buffer Enabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Input buffer disabled, and input signal always equals to 0</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SYS_IMGMAP3</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SYS_IMGMAP3</displayName>
          <description>MAP3 Data Image Register</description>
          <addressOffset>0xF0</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>IMG3</name>
              <description>Data Image of MAP3\nData in MAP3 of information block are copied to this register after power on.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SYS_DEVICEID</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SYS_DEVICEID</displayName>
          <description>Device ID Register</description>
          <addressOffset>0xF4</addressOffset>
          <access>read-only</access>
          <resetValue>0x00003571</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DEVICEID</name>
              <description>Device ID Data \nThis register provides specific read-only information for the Device ID</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SYS_IMGMAP0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SYS_IMGMAP0</displayName>
          <description>MAP0 Data Image Register</description>
          <addressOffset>0xF8</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>IMG0</name>
              <description>Data Image of MAP0\nData in MAP0 of information block are copied to this register after power on.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SYS_IMGMAP1</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SYS_IMGMAP1</displayName>
          <description>MAP1 Data Image Register</description>
          <addressOffset>0xFC</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>IMG1</name>
              <description>Data Image of MAP1\nData in MAP1 of information block are copied to this register after power on.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SYS_REGLCTL</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SYS_REGLCTL</displayName>
          <description>Register Lock Control Register</description>
          <addressOffset>0x100</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
          </fields>
       </register>
       <register>
          <name>SYS_OSCTRIM</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SYS_OSCTRIM</displayName>
          <description>Internal Oscillator Trim Register</description>
          <addressOffset>0x110</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>OSC10K_TRIM</name>
              <description>23bit trim for 10kHz oscillator.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>23</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TRM_CLK</name>
              <description>Must be toggled to load a new OSC10K_TRIM</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SYS_OSC10K</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SYS_OSC10K</displayName>
          <description>10kHz oscillator and bias trim register</description>
          <addressOffset>0x114</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
          </fields>
       </register>
       <register>
          <name>SYS_OSC_TRIMn</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SYS_OSC_TRIMn</displayName>
          <description>Internal Oscillator Trim Register</description>
          <addressOffset>0x118</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>TRIM</name>
              <description>16bit sign extended representation of 10bit trim.\nOSC_TRIM[0] maps to above-mentioned OSCTRIM.\nOSC_TRIM[1] &amp; OSC_TRIM[2] are reserved.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EN2MHZ</name>
              <description>1: Low Frequency mode of oscillator active (2MHz).\n0: High frequency mode (20-50MHz)</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>SCS</name>
      <description>SCS Register Map</description>
      <groupName>SCS</groupName>
      <baseAddress>0xE000E000</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x100</offset>
        <size>0x4</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x180</offset>
        <size>0x4</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x200</offset>
        <size>0x4</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x280</offset>
        <size>0x4</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x400</offset>
        <size>0x14</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>NVIC_ISER</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>NVIC_ISER</displayName>
          <description>IRQ0 ~ IRQ18 Set-enable Control Register</description>
          <addressOffset>0x100</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SETENA</name>
              <description>Interrupt Set-Enable Bit\nThe NVIC_ISER register enables interrupts, and shows what interrupts are enabled. Each bit represents an interrupt number from IRQ0 ~ IRQ18 (Vector number from 16 ~ 34).\n\nWrite Operation: \n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect.\nInterrupt Disabled</description>
                    <value>0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Interrupt Enabled</description>
                    <value>1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>NVIC_ICER</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>NVIC_ICER</displayName>
          <description>IRQ0 ~ IRQ18 Clear-enable Control Register</description>
          <addressOffset>0x180</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CLRENA</name>
              <description>Interrupt Clear-Enable Bit\nThe NVIC_ICER register disables interrupts, and shows what interrupts are enabled.  Each bit represents an interrupt number from IRQ0 ~ IRQ18 (Vector number from 16 ~ 34).\n\nWrite Operation: \n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect.\nInterrupt Disabled</description>
                    <value>0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Interrupt Disabled.\nInterrupt Enabled</description>
                    <value>1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>NVIC_ISPR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>NVIC_ISPR</displayName>
          <description>IRQ0 ~ IRQ18 Set-pending Control Register</description>
          <addressOffset>0x200</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SETPEND</name>
              <description>Interrupt Set-Pending Bit\nThe NVIC_ISPR register forces interrupts into the pending state, and shows what interrupts are pending. Each bit represents an interrupt number from IRQ0 ~ IRQ18 (Vector number from 16 ~ 34).\n\nWrite Operation: \n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect.\nInterrupt is not pending</description>
                    <value>0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Changes interrupt state to pending.\nInterrupt is pending</description>
                    <value>1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>NVIC_ICPR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>NVIC_ICPR</displayName>
          <description>IRQ0 ~ IRQ18 Clear-pending Control Register</description>
          <addressOffset>0x280</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CLRPEND</name>
              <description>Interrupt Clear-Pending Bit\nThe NVIC_ICPR register removes the pending state of associated interrupts, and shows what interrupts are pending. Each bit represents an interrupt number from IRQ0 ~ IRQ18 (Vector number from 16 ~ 34).\nWrite Operation: \n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect.\nInterrupt is not pending</description>
                    <value>0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Removes pending state of an interrupt.\nInterrupt is pending</description>
                    <value>1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>NVIC_IPR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>NVIC_IPR0</displayName>
          <description>IRQ0 ~ IRQ3 Priority Control Register</description>
          <addressOffset>0x400</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PRI_0</name>
              <description>Priority Of IRQ0\n"0" denotes the highest priority and "3" denotes lowest priority</description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PRI_1</name>
              <description>Priority Of IRQ1\n"0" denotes the highest priority and "3" denotes lowest priority</description>
              <bitOffset>14</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PRI_2</name>
              <description>Priority Of IRQ2\n"0" denotes the highest priority and "3" denotes lowest priority</description>
              <bitOffset>22</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PRI_3</name>
              <description>Priority Of IRQ3\n"0" denotes the highest priority and "3" denotes lowest priority</description>
              <bitOffset>30</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>NVIC_IPR1</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>NVIC_IPR1</displayName>
          <description>IRQ4 ~ IRQ7 Priority Control Register</description>
          <addressOffset>0x404</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PRI_4</name>
              <description>Priority Of IRQ4\n"0" denotes the highest priority and "3" denotes lowest priority</description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PRI_5</name>
              <description>Priority Of IRQ5\n"0" denotes the highest priority and "3" denotes lowest priority</description>
              <bitOffset>14</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PRI_6</name>
              <description>Priority Of IRQ6\n"0" denotes the highest priority and "3" denotes lowest priority</description>
              <bitOffset>22</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PRI_7</name>
              <description>Priority Of IRQ7\n"0" denotes the highest priority and "3" denotes lowest priority</description>
              <bitOffset>30</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>NVIC_IPR2</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>NVIC_IPR2</displayName>
          <description>IRQ8 ~ IRQ11 Priority Control Register</description>
          <addressOffset>0x408</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PRI_8</name>
              <description>Priority Of IRQ8\n"0" denotes the highest priority and "3" denotes lowest priority</description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PRI_9</name>
              <description>Priority Of IRQ9\n"0" denotes the highest priority and "3" denotes lowest priority</description>
              <bitOffset>14</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PRI_10</name>
              <description>Priority Of IRQ10\n"0" denotes the highest priority and "3" denotes lowest priority</description>
              <bitOffset>22</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PRI_11</name>
              <description>Priority Of IRQ11\n"0" denotes the highest priority and "3" denotes lowest priority</description>
              <bitOffset>30</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>NVIC_IPR3</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>NVIC_IPR3</displayName>
          <description>IRQ12 ~ IRQ15 Priority Control Register</description>
          <addressOffset>0x40C</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PRI_12</name>
              <description>Priority Of IRQ12\n"0" denotes the highest priority and "3" denotes lowest priority</description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PRI_13</name>
              <description>Priority Of IRQ13\n"0" denotes the highest priority and "3" denotes lowest priority</description>
              <bitOffset>14</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PRI_14</name>
              <description>Priority Of IRQ14\n"0" denotes the highest priority and "3" denotes lowest priority</description>
              <bitOffset>22</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PRI_15</name>
              <description>Priority Of IRQ15\n"0" denotes the highest priority and "3" denotes lowest priority</description>
              <bitOffset>30</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>NVIC_IPR4</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>NVIC_IPR4</displayName>
          <description>IRQ16 ~ IRQ18 Priority Control Register</description>
          <addressOffset>0x410</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PRI_12</name>
              <description>Priority Of IRQ12\n"0" denotes the highest priority and "3" denotes lowest priority</description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PRI_13</name>
              <description>Priority Of IRQ13\n"0" denotes the highest priority and "3" denotes lowest priority</description>
              <bitOffset>14</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PRI_14</name>
              <description>Priority Of IRQ14\n"0" denotes the highest priority and "3" denotes lowest priority</description>
              <bitOffset>22</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>INT</name>
      <description>INT Register Map</description>
      <groupName>INT</groupName>
      <baseAddress>0x50000300</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x0</offset>
        <size>0x4C</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x80</offset>
        <size>0x8</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>IRQ0_SRC</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>IRQ0_SRC</displayName>
          <description>IRQ0 (WDT) Interrupt Source Identity Register</description>
          <addressOffset>0x0</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>INT_SRC</name>
              <description>Interrupt Source Identity\nBit2: 0\nBit1: 0\nBit0: WDT_INT</description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>IRQ1_SRC</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>IRQ1_SRC</displayName>
          <description>IRQ1 (DPWM) Interrupt Source Identity Register</description>
          <addressOffset>0x4</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>INT_SRC</name>
              <description>Interrupt Source Identity\nBit2: 0\nBit1: 0\nBit0: DPWM_INT</description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>IRQ2_SRC</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>IRQ2_SRC</displayName>
          <description>IRQ2 (ADC) Interrupt Source Identity Register</description>
          <addressOffset>0x8</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>INT_SRC</name>
              <description>Interrupt Source Identity\nBit2: 0\nBit1: 0\nBit0: ADC_INT</description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>IRQ3_SRC</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>IRQ3_SRC</displayName>
          <description>Reserved</description>
          <addressOffset>0xC</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
          </fields>
       </register>
       <register>
          <name>IRQ4_SRC</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>IRQ4_SRC</displayName>
          <description>IRQ4 (SPIM) Interrupt Source Identity Register</description>
          <addressOffset>0x10</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>INT_SRC</name>
              <description>Interrupt Source Identity\nBit2: 0\nBit1: 0\nBit0: SPIM_INT</description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>IRQ5_SRC</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>IRQ5_SRC</displayName>
          <description>IRQ5 (Timer0) Interrupt Source Identity Register</description>
          <addressOffset>0x14</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>INT_SRC</name>
              <description>Interrupt Source Identity\nBit2: 0\nBit1: 0\nBit0: Timer0_INT</description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>IRQ6_SRC</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>IRQ6_SRC</displayName>
          <description>IRQ6 (Timer1) Interrupt Source Identity Register</description>
          <addressOffset>0x18</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>INT_SRC</name>
              <description>Interrupt Source Identity\nBit2: 0\nBit1: 0\nBit0: Timer1_INT</description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>IRQ7_SRC</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>IRQ7_SRC</displayName>
          <description>IRQ7 (Timer2) Interrupt Source Identity Register</description>
          <addressOffset>0x1C</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>INT_SRC</name>
              <description>Interrupt Source Identity\nBit2: 0\nBit1: 0\nBit0: Timer2_INT</description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>IRQ8_SRC</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>IRQ8_SRC</displayName>
          <description>IRQ8 (GPA/B) Interrupt Source Identity Register</description>
          <addressOffset>0x20</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>INT_SRC</name>
              <description>Interrupt Source Identity\nBit2: 0\nBit1: GPB_INT\nBit0: GPA_INT</description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>IRQ9_SRC</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>IRQ9_SRC</displayName>
          <description>IRQ9 (SPI0) Interrupt Source Identity Register</description>
          <addressOffset>0x24</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>INT_SRC</name>
              <description>Interrupt Source Identity\nBit2: 0\nBit1: 0\nBit0: SPI0_INT</description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>IRQ10_SRC</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>IRQ10_SRC</displayName>
          <description>IRQ10 (PWM0) Interrupt Source Identity Register</description>
          <addressOffset>0x28</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>INT_SRC</name>
              <description>Interrupt Source Identity\nBit2: 0\nBit1: 0\nBit0: PWM0_INT</description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>IRQ11_SRC</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>IRQ11_SRC</displayName>
          <description>IRQ11 (PDMA) Interrupt Source Identity Register</description>
          <addressOffset>0x2C</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>INT_SRC</name>
              <description>Interrupt Source Identity\nBit2: 0\nBit1: 0\nBit0: PDMA_INT</description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>IRQ12_SRC</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>IRQ12_SRC</displayName>
          <description>IRQ12 (TimerF) Interrupt Source Identity Register</description>
          <addressOffset>0x30</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>INT_SRC</name>
              <description>Interrupt Source Identity\nBit2: 0\nBit1: 0\nBit0: TimerF_INT</description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>IRQ13_SRC</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>IRQ13_SRC</displayName>
          <description>IRQ13 (RTC) Interrupt Source Identity Register</description>
          <addressOffset>0x34</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>INT_SRC</name>
              <description>Interrupt Source Identity\nBit2: 0\nBit1: 0\nBit0: RTC_INT</description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>IRQ14_SRC</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>IRQ14_SRC</displayName>
          <description>Reserved</description>
          <addressOffset>0x38</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
          </fields>
       </register>
       <register>
          <name>IRQ15_SRC</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>IRQ15_SRC</displayName>
          <description>IRQ15 (PWM1) Interrupt Source Identity Register</description>
          <addressOffset>0x3C</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>INT_SRC</name>
              <description>Interrupt Source Identity\nBit2: 0\nBit1: 0\nBit0: PWM1_INT</description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>IRQ16_SRC</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>IRQ16_SRC</displayName>
          <description>Reserved</description>
          <addressOffset>0x40</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
          </fields>
       </register>
       <register>
          <name>IRQ17_SRC</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>IRQ17_SRC</displayName>
          <description>IRQ17 (UART0) Interrupt Source Identity Register</description>
          <addressOffset>0x44</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>INT_SRC</name>
              <description>Interrupt Source Identity\nBit2: 0\nBit1: 0\nBit0: UART0_INT</description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>IRQ18_SRC</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>IRQ18_SRC</displayName>
          <description>IRQ18 (BOD) Interrupt Source Identity Register</description>
          <addressOffset>0x48</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>INT_SRC</name>
              <description>Interrupt Source Identity\nBit2: 0\nBit1: 0\nBit0: BOD_INT</description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>NMI_SEL</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>NMI_SEL</displayName>
          <description>NMI Source Interrupt Select Control Register</description>
          <addressOffset>0x80</addressOffset>
          <access>read-write</access>
          <resetValue>0x0000001F</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>NMI_SEL</name>
              <description>NMI Source Interrupt Select\nThe NMI interrupt to Cortex-M0 can be selected from one of the interrupt [18:0].\nThe NMI_SEL bit is used to select the NMI interrupt source.\nNote: IRQ3, IRQ14 and IRQ16 are reserved.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>IRQ_TM</name>
              <description>IRQ Test Mode\nThis bit is the protected bit. To program this bit needs an open lock sequence, write "59h", "16h", "88h" to register SYS_REGLCTL to un-lock this bit.  Refer to the register SYS_REGLCTL at address SYS_BA+0x100.\n</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The interrupt register MCU_IRQ operates in normal mode. The MCU_IRQ collects all the interrupts from the peripheral and generates interrupt to MCU</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>All the interrupts from peripheral to MCU are blocked. The peripheral IRQ signals (0-15) are replaced by the value in the MCU_IRQ register</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>MCU_IRQ</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>MCU_IRQ</displayName>
          <description>MCU IRQ Number Identify Register</description>
          <addressOffset>0x84</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MCU_IRQ</name>
              <description>MCU IRQ Source Test Mode\nThe MCU_IRQ collects all the interrupts from the peripherals and generates the synchronous interrupt to MCU Cortex-M0. There are two modes to generate interrupt to MCU Cortex-M0, the normal mode and test mode.\nWhen MCU_IRQ[n] is "0": Writing MCU_IRQ[n] "1" will generate an interrupt to Cortex_M0 IRQ[n].\nWhen MCU_IRQ[n] is "1" (meaning an interrupt is asserted): Writing MCU_IRQ[n] "1" will clear the interrupt; writing MCU_IRQ[n] "0": has no effect.\nNote: IRQ3, IRQ14 and IRQ16 are reserved.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>GPIO</name>
      <description>GPIO Register Map</description>
      <groupName>GPIO</groupName>
      <baseAddress>0x50004000</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x0</offset>
        <size>0x4</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x8</offset>
        <size>0x4</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x10</offset>
        <size>0x4</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x18</offset>
        <size>0xC</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x40</offset>
        <size>0x4</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x48</offset>
        <size>0x4</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x50</offset>
        <size>0x4</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x58</offset>
        <size>0xC</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x800</offset>
        <size>0x58</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>PA_MODE</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PA_MODE</displayName>
          <description>GPIO PA Pin I/O Mode Control</description>
          <addressOffset>0x0</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MODE0</name>
              <description>Port [A/B] Pin[N] I/O Mode Control \nEach GPIO Px pin has four modes:\nNote: PB_MODE[15:6] are reserved to 0.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO Px[n] pin is in INPUT mode</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIO Px[n] pin is in OUTPUT mode</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>GPIO Px[n] pin is in Open-Drain mode</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>GPIO Px[n] pin is in Quasi-bidirectional mode</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>MODE1</name>
              <description>Port [A/B] Pin[N] I/O Mode Control \nEach GPIO Px pin has four modes:\nNote: PB_MODE[15:6] are reserved to 0.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO Px[n] pin is in INPUT mode</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIO Px[n] pin is in OUTPUT mode</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>GPIO Px[n] pin is in Open-Drain mode</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>GPIO Px[n] pin is in Quasi-bidirectional mode</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>MODE2</name>
              <description>Port [A/B] Pin[N] I/O Mode Control \nEach GPIO Px pin has four modes:\nNote: PB_MODE[15:6] are reserved to 0.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO Px[n] pin is in INPUT mode</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIO Px[n] pin is in OUTPUT mode</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>GPIO Px[n] pin is in Open-Drain mode</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>GPIO Px[n] pin is in Quasi-bidirectional mode</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>MODE3</name>
              <description>Port [A/B] Pin[N] I/O Mode Control \nEach GPIO Px pin has four modes:\nNote: PB_MODE[15:6] are reserved to 0.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO Px[n] pin is in INPUT mode</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIO Px[n] pin is in OUTPUT mode</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>GPIO Px[n] pin is in Open-Drain mode</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>GPIO Px[n] pin is in Quasi-bidirectional mode</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>MODE4</name>
              <description>Port [A/B] Pin[N] I/O Mode Control \nEach GPIO Px pin has four modes:\nNote: PB_MODE[15:6] are reserved to 0.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO Px[n] pin is in INPUT mode</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIO Px[n] pin is in OUTPUT mode</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>GPIO Px[n] pin is in Open-Drain mode</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>GPIO Px[n] pin is in Quasi-bidirectional mode</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>MODE5</name>
              <description>Port [A/B] Pin[N] I/O Mode Control \nEach GPIO Px pin has four modes:\nNote: PB_MODE[15:6] are reserved to 0.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO Px[n] pin is in INPUT mode</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIO Px[n] pin is in OUTPUT mode</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>GPIO Px[n] pin is in Open-Drain mode</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>GPIO Px[n] pin is in Quasi-bidirectional mode</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>MODE6</name>
              <description>Port [A/B] Pin[N] I/O Mode Control \nEach GPIO Px pin has four modes:\nNote: PB_MODE[15:6] are reserved to 0.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO Px[n] pin is in INPUT mode</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIO Px[n] pin is in OUTPUT mode</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>GPIO Px[n] pin is in Open-Drain mode</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>GPIO Px[n] pin is in Quasi-bidirectional mode</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>MODE7</name>
              <description>Port [A/B] Pin[N] I/O Mode Control \nEach GPIO Px pin has four modes:\nNote: PB_MODE[15:6] are reserved to 0.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO Px[n] pin is in INPUT mode</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIO Px[n] pin is in OUTPUT mode</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>GPIO Px[n] pin is in Open-Drain mode</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>GPIO Px[n] pin is in Quasi-bidirectional mode</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>MODE8</name>
              <description>Port [A/B] Pin[N] I/O Mode Control \nEach GPIO Px pin has four modes:\nNote: PB_MODE[15:6] are reserved to 0.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO Px[n] pin is in INPUT mode</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIO Px[n] pin is in OUTPUT mode</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>GPIO Px[n] pin is in Open-Drain mode</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>GPIO Px[n] pin is in Quasi-bidirectional mode</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>MODE9</name>
              <description>Port [A/B] Pin[N] I/O Mode Control \nEach GPIO Px pin has four modes:\nNote: PB_MODE[15:6] are reserved to 0.</description>
              <bitOffset>18</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO Px[n] pin is in INPUT mode</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIO Px[n] pin is in OUTPUT mode</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>GPIO Px[n] pin is in Open-Drain mode</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>GPIO Px[n] pin is in Quasi-bidirectional mode</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>MODE10</name>
              <description>Port [A/B] Pin[N] I/O Mode Control \nEach GPIO Px pin has four modes:\nNote: PB_MODE[15:6] are reserved to 0.</description>
              <bitOffset>20</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO Px[n] pin is in INPUT mode</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIO Px[n] pin is in OUTPUT mode</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>GPIO Px[n] pin is in Open-Drain mode</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>GPIO Px[n] pin is in Quasi-bidirectional mode</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>MODE11</name>
              <description>Port [A/B] Pin[N] I/O Mode Control \nEach GPIO Px pin has four modes:\nNote: PB_MODE[15:6] are reserved to 0.</description>
              <bitOffset>22</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO Px[n] pin is in INPUT mode</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIO Px[n] pin is in OUTPUT mode</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>GPIO Px[n] pin is in Open-Drain mode</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>GPIO Px[n] pin is in Quasi-bidirectional mode</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>MODE12</name>
              <description>Port [A/B] Pin[N] I/O Mode Control \nEach GPIO Px pin has four modes:\nNote: PB_MODE[15:6] are reserved to 0.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO Px[n] pin is in INPUT mode</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIO Px[n] pin is in OUTPUT mode</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>GPIO Px[n] pin is in Open-Drain mode</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>GPIO Px[n] pin is in Quasi-bidirectional mode</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>MODE13</name>
              <description>Port [A/B] Pin[N] I/O Mode Control \nEach GPIO Px pin has four modes:\nNote: PB_MODE[15:6] are reserved to 0.</description>
              <bitOffset>26</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO Px[n] pin is in INPUT mode</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIO Px[n] pin is in OUTPUT mode</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>GPIO Px[n] pin is in Open-Drain mode</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>GPIO Px[n] pin is in Quasi-bidirectional mode</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>MODE14</name>
              <description>Port [A/B] Pin[N] I/O Mode Control \nEach GPIO Px pin has four modes:\nNote: PB_MODE[15:6] are reserved to 0.</description>
              <bitOffset>28</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO Px[n] pin is in INPUT mode</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIO Px[n] pin is in OUTPUT mode</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>GPIO Px[n] pin is in Open-Drain mode</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>GPIO Px[n] pin is in Quasi-bidirectional mode</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>MODE15</name>
              <description>Port [A/B] Pin[N] I/O Mode Control \nEach GPIO Px pin has four modes:\nNote: PB_MODE[15:6] are reserved to 0.</description>
              <bitOffset>30</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO Px[n] pin is in INPUT mode</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIO Px[n] pin is in OUTPUT mode</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>GPIO Px[n] pin is in Open-Drain mode</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>GPIO Px[n] pin is in Quasi-bidirectional mode</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PA_DOUT</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PA_DOUT</displayName>
          <description>GPIO PA Data Output Value</description>
          <addressOffset>0x8</addressOffset>
          <access>read-write</access>
          <resetValue>0x0000FFFF</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DOUT</name>
              <description>Port [A/B] Pin[N] Output Value\nEach of these bits controls the status of a GPIO pin when the GPIO pin is configured as output, open-drain or quasi-bidirectional mode.\nNote: PB_DOUT[15:6] are reserved to 0.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO port [A/B] Pin[n] will drive Low if the corresponding output mode bit is set</description>
                    <value>0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIO port [A/B] Pin[n] will drive High if the corresponding output mode bit is set</description>
                    <value>1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PA_PIN</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PA_PIN</displayName>
          <description>GPIO PA Pin Value</description>
          <addressOffset>0x10</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFF0000</resetMask>
          <fields>
            <field>
              <name>PIN</name>
              <description>Port [A/B] Pin[N] Pin Values\nEach bit of the register reflects the actual status of the respective Px.n pin. If the bit is 1, it indicates the corresponding pin status is high; else the pin status is low. \nNote: PB_PIN[15:6] are reserved to 0.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PA_INTTYPE</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PA_INTTYPE</displayName>
          <description>GPIO PA Interrupt Trigger Type</description>
          <addressOffset>0x18</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TYPE</name>
              <description>Port [A/B] Pin[N] Edge Or Level Detection Interrupt Trigger Type Control\nTYPE[n] is used to control whether the interrupt mode is level triggered or edge triggered. If the interrupt mode is level triggered, the input source is sampled by one HCLK clock to generate the interrupt \nNote: If level triggered interrupt is selected, then only one level can be selected in the Px_INTEN register. If both levels are set, the setting is ignored and  no interrupt will occur</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Edge triggered interrupt</description>
                    <value>0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Level triggered interrupt</description>
                    <value>1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PA_INTEN</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PA_INTEN</displayName>
          <description>GPIO PA Interrupt Enable</description>
          <addressOffset>0x1C</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>FLIEN0</name>
              <description>Port [A/B] Interrupt Enable By Input Falling Edge Or Input Level Low\nFLIEN[n] is used to enable the falling/low-level interrupt for each of the corresponding input Px.n pin. To set "1" also enables the pin wake-up function.\nWhen setting the FLIEN[n] (Px_INTEN[n]) bit to 1 : \nIf the interrupt is configured as level trigger mode (TYPE[n] is set to 1), one interrupt will occur while the input Px.n state is at low level. \nIf the interrupt is configured as edge trigger mode (TYPE[n] is set to 0), one interrupt will occur while he input Px.n state changes from high to low. \n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disable Px.n for low-level or high-to-low interrupt</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable Px.n for low-level or high-to-low interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>FLIEN1</name>
              <description>Port [A/B] Interrupt Enable By Input Falling Edge Or Input Level Low\nFLIEN[n] is used to enable the falling/low-level interrupt for each of the corresponding input Px.n pin. To set "1" also enables the pin wake-up function.\nWhen setting the FLIEN[n] (Px_INTEN[n]) bit to 1 : \nIf the interrupt is configured as level trigger mode (TYPE[n] is set to 1), one interrupt will occur while the input Px.n state is at low level. \nIf the interrupt is configured as edge trigger mode (TYPE[n] is set to 0), one interrupt will occur while he input Px.n state changes from high to low. \n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disable Px.n for low-level or high-to-low interrupt</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable Px.n for low-level or high-to-low interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>FLIEN2</name>
              <description>Port [A/B] Interrupt Enable By Input Falling Edge Or Input Level Low\nFLIEN[n] is used to enable the falling/low-level interrupt for each of the corresponding input Px.n pin. To set "1" also enables the pin wake-up function.\nWhen setting the FLIEN[n] (Px_INTEN[n]) bit to 1 : \nIf the interrupt is configured as level trigger mode (TYPE[n] is set to 1), one interrupt will occur while the input Px.n state is at low level. \nIf the interrupt is configured as edge trigger mode (TYPE[n] is set to 0), one interrupt will occur while he input Px.n state changes from high to low. \n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disable Px.n for low-level or high-to-low interrupt</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable Px.n for low-level or high-to-low interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>FLIEN3</name>
              <description>Port [A/B] Interrupt Enable By Input Falling Edge Or Input Level Low\nFLIEN[n] is used to enable the falling/low-level interrupt for each of the corresponding input Px.n pin. To set "1" also enables the pin wake-up function.\nWhen setting the FLIEN[n] (Px_INTEN[n]) bit to 1 : \nIf the interrupt is configured as level trigger mode (TYPE[n] is set to 1), one interrupt will occur while the input Px.n state is at low level. \nIf the interrupt is configured as edge trigger mode (TYPE[n] is set to 0), one interrupt will occur while he input Px.n state changes from high to low. \n</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disable Px.n for low-level or high-to-low interrupt</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable Px.n for low-level or high-to-low interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>FLIEN4</name>
              <description>Port [A/B] Interrupt Enable By Input Falling Edge Or Input Level Low\nFLIEN[n] is used to enable the falling/low-level interrupt for each of the corresponding input Px.n pin. To set "1" also enables the pin wake-up function.\nWhen setting the FLIEN[n] (Px_INTEN[n]) bit to 1 : \nIf the interrupt is configured as level trigger mode (TYPE[n] is set to 1), one interrupt will occur while the input Px.n state is at low level. \nIf the interrupt is configured as edge trigger mode (TYPE[n] is set to 0), one interrupt will occur while he input Px.n state changes from high to low. \n</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disable Px.n for low-level or high-to-low interrupt</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable Px.n for low-level or high-to-low interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>FLIEN5</name>
              <description>Port [A/B] Interrupt Enable By Input Falling Edge Or Input Level Low\nFLIEN[n] is used to enable the falling/low-level interrupt for each of the corresponding input Px.n pin. To set "1" also enables the pin wake-up function.\nWhen setting the FLIEN[n] (Px_INTEN[n]) bit to 1 : \nIf the interrupt is configured as level trigger mode (TYPE[n] is set to 1), one interrupt will occur while the input Px.n state is at low level. \nIf the interrupt is configured as edge trigger mode (TYPE[n] is set to 0), one interrupt will occur while he input Px.n state changes from high to low. \n</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disable Px.n for low-level or high-to-low interrupt</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable Px.n for low-level or high-to-low interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>FLIEN6</name>
              <description>Port [A/B] Interrupt Enable By Input Falling Edge Or Input Level Low\nFLIEN[n] is used to enable the falling/low-level interrupt for each of the corresponding input Px.n pin. To set "1" also enables the pin wake-up function.\nWhen setting the FLIEN[n] (Px_INTEN[n]) bit to 1 : \nIf the interrupt is configured as level trigger mode (TYPE[n] is set to 1), one interrupt will occur while the input Px.n state is at low level. \nIf the interrupt is configured as edge trigger mode (TYPE[n] is set to 0), one interrupt will occur while he input Px.n state changes from high to low. \n</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disable Px.n for low-level or high-to-low interrupt</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable Px.n for low-level or high-to-low interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>FLIEN7</name>
              <description>Port [A/B] Interrupt Enable By Input Falling Edge Or Input Level Low\nFLIEN[n] is used to enable the falling/low-level interrupt for each of the corresponding input Px.n pin. To set "1" also enables the pin wake-up function.\nWhen setting the FLIEN[n] (Px_INTEN[n]) bit to 1 : \nIf the interrupt is configured as level trigger mode (TYPE[n] is set to 1), one interrupt will occur while the input Px.n state is at low level. \nIf the interrupt is configured as edge trigger mode (TYPE[n] is set to 0), one interrupt will occur while he input Px.n state changes from high to low. \n</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disable Px.n for low-level or high-to-low interrupt</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable Px.n for low-level or high-to-low interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>FLIEN8</name>
              <description>Port [A/B] Interrupt Enable By Input Falling Edge Or Input Level Low\nFLIEN[n] is used to enable the falling/low-level interrupt for each of the corresponding input Px.n pin. To set "1" also enables the pin wake-up function.\nWhen setting the FLIEN[n] (Px_INTEN[n]) bit to 1 : \nIf the interrupt is configured as level trigger mode (TYPE[n] is set to 1), one interrupt will occur while the input Px.n state is at low level. \nIf the interrupt is configured as edge trigger mode (TYPE[n] is set to 0), one interrupt will occur while he input Px.n state changes from high to low. \n</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disable Px.n for low-level or high-to-low interrupt</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable Px.n for low-level or high-to-low interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>FLIEN9</name>
              <description>Port [A/B] Interrupt Enable By Input Falling Edge Or Input Level Low\nFLIEN[n] is used to enable the falling/low-level interrupt for each of the corresponding input Px.n pin. To set "1" also enables the pin wake-up function.\nWhen setting the FLIEN[n] (Px_INTEN[n]) bit to 1 : \nIf the interrupt is configured as level trigger mode (TYPE[n] is set to 1), one interrupt will occur while the input Px.n state is at low level. \nIf the interrupt is configured as edge trigger mode (TYPE[n] is set to 0), one interrupt will occur while he input Px.n state changes from high to low. \n</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disable Px.n for low-level or high-to-low interrupt</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable Px.n for low-level or high-to-low interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>FLIEN10</name>
              <description>Port [A/B] Interrupt Enable By Input Falling Edge Or Input Level Low\nFLIEN[n] is used to enable the falling/low-level interrupt for each of the corresponding input Px.n pin. To set "1" also enables the pin wake-up function.\nWhen setting the FLIEN[n] (Px_INTEN[n]) bit to 1 : \nIf the interrupt is configured as level trigger mode (TYPE[n] is set to 1), one interrupt will occur while the input Px.n state is at low level. \nIf the interrupt is configured as edge trigger mode (TYPE[n] is set to 0), one interrupt will occur while he input Px.n state changes from high to low. \n</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disable Px.n for low-level or high-to-low interrupt</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable Px.n for low-level or high-to-low interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>FLIEN11</name>
              <description>Port [A/B] Interrupt Enable By Input Falling Edge Or Input Level Low\nFLIEN[n] is used to enable the falling/low-level interrupt for each of the corresponding input Px.n pin. To set "1" also enables the pin wake-up function.\nWhen setting the FLIEN[n] (Px_INTEN[n]) bit to 1 : \nIf the interrupt is configured as level trigger mode (TYPE[n] is set to 1), one interrupt will occur while the input Px.n state is at low level. \nIf the interrupt is configured as edge trigger mode (TYPE[n] is set to 0), one interrupt will occur while he input Px.n state changes from high to low. \n</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disable Px.n for low-level or high-to-low interrupt</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable Px.n for low-level or high-to-low interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>FLIEN12</name>
              <description>Port [A/B] Interrupt Enable By Input Falling Edge Or Input Level Low\nFLIEN[n] is used to enable the falling/low-level interrupt for each of the corresponding input Px.n pin. To set "1" also enables the pin wake-up function.\nWhen setting the FLIEN[n] (Px_INTEN[n]) bit to 1 : \nIf the interrupt is configured as level trigger mode (TYPE[n] is set to 1), one interrupt will occur while the input Px.n state is at low level. \nIf the interrupt is configured as edge trigger mode (TYPE[n] is set to 0), one interrupt will occur while he input Px.n state changes from high to low. \n</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disable Px.n for low-level or high-to-low interrupt</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable Px.n for low-level or high-to-low interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>FLIEN13</name>
              <description>Port [A/B] Interrupt Enable By Input Falling Edge Or Input Level Low\nFLIEN[n] is used to enable the falling/low-level interrupt for each of the corresponding input Px.n pin. To set "1" also enables the pin wake-up function.\nWhen setting the FLIEN[n] (Px_INTEN[n]) bit to 1 : \nIf the interrupt is configured as level trigger mode (TYPE[n] is set to 1), one interrupt will occur while the input Px.n state is at low level. \nIf the interrupt is configured as edge trigger mode (TYPE[n] is set to 0), one interrupt will occur while he input Px.n state changes from high to low. \n</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disable Px.n for low-level or high-to-low interrupt</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable Px.n for low-level or high-to-low interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>FLIEN14</name>
              <description>Port [A/B] Interrupt Enable By Input Falling Edge Or Input Level Low\nFLIEN[n] is used to enable the falling/low-level interrupt for each of the corresponding input Px.n pin. To set "1" also enables the pin wake-up function.\nWhen setting the FLIEN[n] (Px_INTEN[n]) bit to 1 : \nIf the interrupt is configured as level trigger mode (TYPE[n] is set to 1), one interrupt will occur while the input Px.n state is at low level. \nIf the interrupt is configured as edge trigger mode (TYPE[n] is set to 0), one interrupt will occur while he input Px.n state changes from high to low. \n</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disable Px.n for low-level or high-to-low interrupt</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable Px.n for low-level or high-to-low interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>FLIEN15</name>
              <description>Port [A/B] Interrupt Enable By Input Falling Edge Or Input Level Low\nFLIEN[n] is used to enable the falling/low-level interrupt for each of the corresponding input Px.n pin. To set "1" also enables the pin wake-up function.\nWhen setting the FLIEN[n] (Px_INTEN[n]) bit to 1 : \nIf the interrupt is configured as level trigger mode (TYPE[n] is set to 1), one interrupt will occur while the input Px.n state is at low level. \nIf the interrupt is configured as edge trigger mode (TYPE[n] is set to 0), one interrupt will occur while he input Px.n state changes from high to low. \n</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disable Px.n for low-level or high-to-low interrupt</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable Px.n for low-level or high-to-low interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RHIEN0</name>
              <description>Port [A/B] Interrupt Enable By Input Rising Edge Or Input Level High\nRHIEN[n] is used to enable the rising/high-level interrupt for each of the corresponding input Px.n pin. To set "1" also enables the pin wake-up function.\nWhen setting the RHIEN[n] (Px_INTEN[n+16]) bit to 1 : \nIf the interrupt is configured as level trigger mode (TYPE[n] is set to 1), one interrupt will occur while the input Px.n state is at high level. \nIf the interrupt is configured as edge trigger mode (TYPE[n] is set to 0), one interrupt will occur while he input Px.n state changes from low to high. \n</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disable Px.n for low-to-high or level-high interrupt</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable Px.n for low-to-high or level-high interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RHIEN1</name>
              <description>Port [A/B] Interrupt Enable By Input Rising Edge Or Input Level High\nRHIEN[n] is used to enable the rising/high-level interrupt for each of the corresponding input Px.n pin. To set "1" also enables the pin wake-up function.\nWhen setting the RHIEN[n] (Px_INTEN[n+16]) bit to 1 : \nIf the interrupt is configured as level trigger mode (TYPE[n] is set to 1), one interrupt will occur while the input Px.n state is at high level. \nIf the interrupt is configured as edge trigger mode (TYPE[n] is set to 0), one interrupt will occur while he input Px.n state changes from low to high. \n</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disable Px.n for low-to-high or level-high interrupt</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable Px.n for low-to-high or level-high interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RHIEN2</name>
              <description>Port [A/B] Interrupt Enable By Input Rising Edge Or Input Level High\nRHIEN[n] is used to enable the rising/high-level interrupt for each of the corresponding input Px.n pin. To set "1" also enables the pin wake-up function.\nWhen setting the RHIEN[n] (Px_INTEN[n+16]) bit to 1 : \nIf the interrupt is configured as level trigger mode (TYPE[n] is set to 1), one interrupt will occur while the input Px.n state is at high level. \nIf the interrupt is configured as edge trigger mode (TYPE[n] is set to 0), one interrupt will occur while he input Px.n state changes from low to high. \n</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disable Px.n for low-to-high or level-high interrupt</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable Px.n for low-to-high or level-high interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RHIEN3</name>
              <description>Port [A/B] Interrupt Enable By Input Rising Edge Or Input Level High\nRHIEN[n] is used to enable the rising/high-level interrupt for each of the corresponding input Px.n pin. To set "1" also enables the pin wake-up function.\nWhen setting the RHIEN[n] (Px_INTEN[n+16]) bit to 1 : \nIf the interrupt is configured as level trigger mode (TYPE[n] is set to 1), one interrupt will occur while the input Px.n state is at high level. \nIf the interrupt is configured as edge trigger mode (TYPE[n] is set to 0), one interrupt will occur while he input Px.n state changes from low to high. \n</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disable Px.n for low-to-high or level-high interrupt</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable Px.n for low-to-high or level-high interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RHIEN4</name>
              <description>Port [A/B] Interrupt Enable By Input Rising Edge Or Input Level High\nRHIEN[n] is used to enable the rising/high-level interrupt for each of the corresponding input Px.n pin. To set "1" also enables the pin wake-up function.\nWhen setting the RHIEN[n] (Px_INTEN[n+16]) bit to 1 : \nIf the interrupt is configured as level trigger mode (TYPE[n] is set to 1), one interrupt will occur while the input Px.n state is at high level. \nIf the interrupt is configured as edge trigger mode (TYPE[n] is set to 0), one interrupt will occur while he input Px.n state changes from low to high. \n</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disable Px.n for low-to-high or level-high interrupt</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable Px.n for low-to-high or level-high interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RHIEN5</name>
              <description>Port [A/B] Interrupt Enable By Input Rising Edge Or Input Level High\nRHIEN[n] is used to enable the rising/high-level interrupt for each of the corresponding input Px.n pin. To set "1" also enables the pin wake-up function.\nWhen setting the RHIEN[n] (Px_INTEN[n+16]) bit to 1 : \nIf the interrupt is configured as level trigger mode (TYPE[n] is set to 1), one interrupt will occur while the input Px.n state is at high level. \nIf the interrupt is configured as edge trigger mode (TYPE[n] is set to 0), one interrupt will occur while he input Px.n state changes from low to high. \n</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disable Px.n for low-to-high or level-high interrupt</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable Px.n for low-to-high or level-high interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RHIEN6</name>
              <description>Port [A/B] Interrupt Enable By Input Rising Edge Or Input Level High\nRHIEN[n] is used to enable the rising/high-level interrupt for each of the corresponding input Px.n pin. To set "1" also enables the pin wake-up function.\nWhen setting the RHIEN[n] (Px_INTEN[n+16]) bit to 1 : \nIf the interrupt is configured as level trigger mode (TYPE[n] is set to 1), one interrupt will occur while the input Px.n state is at high level. \nIf the interrupt is configured as edge trigger mode (TYPE[n] is set to 0), one interrupt will occur while he input Px.n state changes from low to high. \n</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disable Px.n for low-to-high or level-high interrupt</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable Px.n for low-to-high or level-high interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RHIEN7</name>
              <description>Port [A/B] Interrupt Enable By Input Rising Edge Or Input Level High\nRHIEN[n] is used to enable the rising/high-level interrupt for each of the corresponding input Px.n pin. To set "1" also enables the pin wake-up function.\nWhen setting the RHIEN[n] (Px_INTEN[n+16]) bit to 1 : \nIf the interrupt is configured as level trigger mode (TYPE[n] is set to 1), one interrupt will occur while the input Px.n state is at high level. \nIf the interrupt is configured as edge trigger mode (TYPE[n] is set to 0), one interrupt will occur while he input Px.n state changes from low to high. \n</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disable Px.n for low-to-high or level-high interrupt</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable Px.n for low-to-high or level-high interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RHIEN8</name>
              <description>Port [A/B] Interrupt Enable By Input Rising Edge Or Input Level High\nRHIEN[n] is used to enable the rising/high-level interrupt for each of the corresponding input Px.n pin. To set "1" also enables the pin wake-up function.\nWhen setting the RHIEN[n] (Px_INTEN[n+16]) bit to 1 : \nIf the interrupt is configured as level trigger mode (TYPE[n] is set to 1), one interrupt will occur while the input Px.n state is at high level. \nIf the interrupt is configured as edge trigger mode (TYPE[n] is set to 0), one interrupt will occur while he input Px.n state changes from low to high. \n</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disable Px.n for low-to-high or level-high interrupt</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable Px.n for low-to-high or level-high interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RHIEN9</name>
              <description>Port [A/B] Interrupt Enable By Input Rising Edge Or Input Level High\nRHIEN[n] is used to enable the rising/high-level interrupt for each of the corresponding input Px.n pin. To set "1" also enables the pin wake-up function.\nWhen setting the RHIEN[n] (Px_INTEN[n+16]) bit to 1 : \nIf the interrupt is configured as level trigger mode (TYPE[n] is set to 1), one interrupt will occur while the input Px.n state is at high level. \nIf the interrupt is configured as edge trigger mode (TYPE[n] is set to 0), one interrupt will occur while he input Px.n state changes from low to high. \n</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disable Px.n for low-to-high or level-high interrupt</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable Px.n for low-to-high or level-high interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RHIEN10</name>
              <description>Port [A/B] Interrupt Enable By Input Rising Edge Or Input Level High\nRHIEN[n] is used to enable the rising/high-level interrupt for each of the corresponding input Px.n pin. To set "1" also enables the pin wake-up function.\nWhen setting the RHIEN[n] (Px_INTEN[n+16]) bit to 1 : \nIf the interrupt is configured as level trigger mode (TYPE[n] is set to 1), one interrupt will occur while the input Px.n state is at high level. \nIf the interrupt is configured as edge trigger mode (TYPE[n] is set to 0), one interrupt will occur while he input Px.n state changes from low to high. \n</description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disable Px.n for low-to-high or level-high interrupt</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable Px.n for low-to-high or level-high interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RHIEN11</name>
              <description>Port [A/B] Interrupt Enable By Input Rising Edge Or Input Level High\nRHIEN[n] is used to enable the rising/high-level interrupt for each of the corresponding input Px.n pin. To set "1" also enables the pin wake-up function.\nWhen setting the RHIEN[n] (Px_INTEN[n+16]) bit to 1 : \nIf the interrupt is configured as level trigger mode (TYPE[n] is set to 1), one interrupt will occur while the input Px.n state is at high level. \nIf the interrupt is configured as edge trigger mode (TYPE[n] is set to 0), one interrupt will occur while he input Px.n state changes from low to high. \n</description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disable Px.n for low-to-high or level-high interrupt</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable Px.n for low-to-high or level-high interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RHIEN12</name>
              <description>Port [A/B] Interrupt Enable By Input Rising Edge Or Input Level High\nRHIEN[n] is used to enable the rising/high-level interrupt for each of the corresponding input Px.n pin. To set "1" also enables the pin wake-up function.\nWhen setting the RHIEN[n] (Px_INTEN[n+16]) bit to 1 : \nIf the interrupt is configured as level trigger mode (TYPE[n] is set to 1), one interrupt will occur while the input Px.n state is at high level. \nIf the interrupt is configured as edge trigger mode (TYPE[n] is set to 0), one interrupt will occur while he input Px.n state changes from low to high. \n</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disable Px.n for low-to-high or level-high interrupt</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable Px.n for low-to-high or level-high interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RHIEN13</name>
              <description>Port [A/B] Interrupt Enable By Input Rising Edge Or Input Level High\nRHIEN[n] is used to enable the rising/high-level interrupt for each of the corresponding input Px.n pin. To set "1" also enables the pin wake-up function.\nWhen setting the RHIEN[n] (Px_INTEN[n+16]) bit to 1 : \nIf the interrupt is configured as level trigger mode (TYPE[n] is set to 1), one interrupt will occur while the input Px.n state is at high level. \nIf the interrupt is configured as edge trigger mode (TYPE[n] is set to 0), one interrupt will occur while he input Px.n state changes from low to high. \n</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disable Px.n for low-to-high or level-high interrupt</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable Px.n for low-to-high or level-high interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RHIEN14</name>
              <description>Port [A/B] Interrupt Enable By Input Rising Edge Or Input Level High\nRHIEN[n] is used to enable the rising/high-level interrupt for each of the corresponding input Px.n pin. To set "1" also enables the pin wake-up function.\nWhen setting the RHIEN[n] (Px_INTEN[n+16]) bit to 1 : \nIf the interrupt is configured as level trigger mode (TYPE[n] is set to 1), one interrupt will occur while the input Px.n state is at high level. \nIf the interrupt is configured as edge trigger mode (TYPE[n] is set to 0), one interrupt will occur while he input Px.n state changes from low to high. \n</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disable Px.n for low-to-high or level-high interrupt</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable Px.n for low-to-high or level-high interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RHIEN15</name>
              <description>Port [A/B] Interrupt Enable By Input Rising Edge Or Input Level High\nRHIEN[n] is used to enable the rising/high-level interrupt for each of the corresponding input Px.n pin. To set "1" also enables the pin wake-up function.\nWhen setting the RHIEN[n] (Px_INTEN[n+16]) bit to 1 : \nIf the interrupt is configured as level trigger mode (TYPE[n] is set to 1), one interrupt will occur while the input Px.n state is at high level. \nIf the interrupt is configured as edge trigger mode (TYPE[n] is set to 0), one interrupt will occur while he input Px.n state changes from low to high. \n</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disable Px.n for low-to-high or level-high interrupt</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable Px.n for low-to-high or level-high interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PA_INTSRC</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PA_INTSRC</displayName>
          <description>GPIO PA Interrupt Source Flag</description>
          <addressOffset>0x20</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>INTSRC</name>
              <description>Port [A/B] Interrupt Source Flag\nRead operation:\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No interrupt from Px.n.\nNo action</description>
                    <value>0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Px.n generated an interrupt.\nClear the corresponding pending interrupt</description>
                    <value>1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PA_MODE">
          <name>PB_MODE</name>
          <displayName>PB_MODE</displayName>
          <description>GPIO PB Pin I/O Mode Control</description>
          <addressOffset>0x40</addressOffset>
       </register>
       <register derivedFrom="PA_DOUT">
          <name>PB_DOUT</name>
          <displayName>PB_DOUT</displayName>
          <description>GPIO PB Data Output Value</description>
          <addressOffset>0x48</addressOffset>
       </register>
       <register derivedFrom="PA_PIN">
          <name>PB_PIN</name>
          <displayName>PB_PIN</displayName>
          <description>GPIO PB Pin Value</description>
          <addressOffset>0x50</addressOffset>
       </register>
       <register derivedFrom="PA_INTTYPE">
          <name>PB_INTTYPE</name>
          <displayName>PB_INTTYPE</displayName>
          <description>GPIO PB Interrupt Trigger Type</description>
          <addressOffset>0x58</addressOffset>
       </register>
       <register derivedFrom="PA_INTEN">
          <name>PB_INTEN</name>
          <displayName>PB_INTEN</displayName>
          <description>GPIO PB Interrupt Enable</description>
          <addressOffset>0x5C</addressOffset>
       </register>
       <register derivedFrom="PA_INTSRC">
          <name>PB_INTSRC</name>
          <displayName>PB_INTSRC</displayName>
          <description>GPIO PB Interrupt Source Flag</description>
          <addressOffset>0x60</addressOffset>
       </register>
       <register>
          <name>PA0_PDIO</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PA0_PDIO</displayName>
          <description>GPIO PA.n Pin Data Input/Output Register</description>
          <addressOffset>0x800</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFF0</resetMask>
          <fields>
            <field>
              <name>PDIO</name>
              <description>GPIO Px.n Pin Data Input/Output\nWriting this bit can control one GPIO pin output value.\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Corresponding GPIO pin set to low</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Corresponding GPIO pin set to high</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PA0_PDIO">
          <name>PA1_PDIO</name>
          <displayName>PA1_PDIO</displayName>
          <description>GPIO PA.n Pin Data Input/Output Register</description>
          <addressOffset>0x804</addressOffset>
       </register>
       <register derivedFrom="PA0_PDIO">
          <name>PA2_PDIO</name>
          <displayName>PA2_PDIO</displayName>
          <description>GPIO PA.n Pin Data Input/Output Register</description>
          <addressOffset>0x808</addressOffset>
       </register>
       <register derivedFrom="PA0_PDIO">
          <name>PA3_PDIO</name>
          <displayName>PA3_PDIO</displayName>
          <description>GPIO PA.n Pin Data Input/Output Register</description>
          <addressOffset>0x80C</addressOffset>
       </register>
       <register derivedFrom="PA0_PDIO">
          <name>PA4_PDIO</name>
          <displayName>PA4_PDIO</displayName>
          <description>GPIO PA.n Pin Data Input/Output Register</description>
          <addressOffset>0x810</addressOffset>
       </register>
       <register derivedFrom="PA0_PDIO">
          <name>PA5_PDIO</name>
          <displayName>PA5_PDIO</displayName>
          <description>GPIO PA.n Pin Data Input/Output Register</description>
          <addressOffset>0x814</addressOffset>
       </register>
       <register derivedFrom="PA0_PDIO">
          <name>PA6_PDIO</name>
          <displayName>PA6_PDIO</displayName>
          <description>GPIO PA.n Pin Data Input/Output Register</description>
          <addressOffset>0x818</addressOffset>
       </register>
       <register derivedFrom="PA0_PDIO">
          <name>PA7_PDIO</name>
          <displayName>PA7_PDIO</displayName>
          <description>GPIO PA.n Pin Data Input/Output Register</description>
          <addressOffset>0x81C</addressOffset>
       </register>
       <register derivedFrom="PA0_PDIO">
          <name>PA8_PDIO</name>
          <displayName>PA8_PDIO</displayName>
          <description>GPIO PA.n Pin Data Input/Output Register</description>
          <addressOffset>0x820</addressOffset>
       </register>
       <register derivedFrom="PA0_PDIO">
          <name>PA9_PDIO</name>
          <displayName>PA9_PDIO</displayName>
          <description>GPIO PA.n Pin Data Input/Output Register</description>
          <addressOffset>0x824</addressOffset>
       </register>
       <register derivedFrom="PA0_PDIO">
          <name>PA10_PDIO</name>
          <displayName>PA10_PDIO</displayName>
          <description>GPIO PA.n Pin Data Input/Output Register</description>
          <addressOffset>0x828</addressOffset>
       </register>
       <register derivedFrom="PA0_PDIO">
          <name>PA11_PDIO</name>
          <displayName>PA11_PDIO</displayName>
          <description>GPIO PA.n Pin Data Input/Output Register</description>
          <addressOffset>0x82C</addressOffset>
       </register>
       <register derivedFrom="PA0_PDIO">
          <name>PA12_PDIO</name>
          <displayName>PA12_PDIO</displayName>
          <description>GPIO PA.n Pin Data Input/Output Register</description>
          <addressOffset>0x830</addressOffset>
       </register>
       <register derivedFrom="PA0_PDIO">
          <name>PA13_PDIO</name>
          <displayName>PA13_PDIO</displayName>
          <description>GPIO PA.n Pin Data Input/Output Register</description>
          <addressOffset>0x834</addressOffset>
       </register>
       <register derivedFrom="PA0_PDIO">
          <name>PA14_PDIO</name>
          <displayName>PA14_PDIO</displayName>
          <description>GPIO PA.n Pin Data Input/Output Register</description>
          <addressOffset>0x838</addressOffset>
       </register>
       <register derivedFrom="PA0_PDIO">
          <name>PA15_PDIO</name>
          <displayName>PA15_PDIO</displayName>
          <description>GPIO PA.n Pin Data Input/Output Register</description>
          <addressOffset>0x83C</addressOffset>
       </register>
       <register derivedFrom="PA0_PDIO">
          <name>PB0_PDIO</name>
          <displayName>PB0_PDIO</displayName>
          <description>GPIO PB.n Pin Data Input/Output Register</description>
          <addressOffset>0x840</addressOffset>
       </register>
       <register derivedFrom="PB0_PDIO">
          <name>PB1_PDIO</name>
          <displayName>PB1_PDIO</displayName>
          <description>GPIO PB.n Pin Data Input/Output Register</description>
          <addressOffset>0x844</addressOffset>
       </register>
       <register derivedFrom="PB0_PDIO">
          <name>PB2_PDIO</name>
          <displayName>PB2_PDIO</displayName>
          <description>GPIO PB.n Pin Data Input/Output Register</description>
          <addressOffset>0x848</addressOffset>
       </register>
       <register derivedFrom="PB0_PDIO">
          <name>PB3_PDIO</name>
          <displayName>PB3_PDIO</displayName>
          <description>GPIO PB.n Pin Data Input/Output Register</description>
          <addressOffset>0x84C</addressOffset>
       </register>
       <register derivedFrom="PB0_PDIO">
          <name>PB4_PDIO</name>
          <displayName>PB4_PDIO</displayName>
          <description>GPIO PB.n Pin Data Input/Output Register</description>
          <addressOffset>0x850</addressOffset>
       </register>
       <register derivedFrom="PB0_PDIO">
          <name>PB5_PDIO</name>
          <displayName>PB5_PDIO</displayName>
          <description>GPIO PB.n Pin Data Input/Output Register</description>
          <addressOffset>0x854</addressOffset>
       </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>RTC</name>
      <description>RTC Register Map</description>
      <groupName>RTC</groupName>
      <baseAddress>0x40008000</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x0</offset>
        <size>0x4</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>RTC_CTL</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>RTC_CTL</displayName>
          <description>RTC Control Register</description>
          <addressOffset>0x0</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RTIF</name>
              <description>RTC Interrupt Flag\nIf the RTC interrupt is enabled, then the hardware will set this bit to indicate that the RTC interrupt has occurred. If the RTC interrupt is not enabled, then this bit indicates that a timeout period has elapsed.\nNote: This bit is cleared by writing 1 to this bit.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RTC interrupt does not occur</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RTC interrupt occurs</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RTIE</name>
              <description>RTC Interrupt Enable\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disable the RTC interrupt</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable the RTC interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RTCE</name>
              <description>RTC Enable\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disable RTC function</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable RTC function</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RTIS</name>
              <description>RTC Timer Interval Select\nThese two bits select the timeout interval for the RTC. \n</description>
              <bitOffset>3</bitOffset>
              <bitWidth>3</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Time-out frequency is 0.25Hz,</description>
                    <value>#000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Time-out frequency is 0.5Hz,</description>
                    <value>#001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Time-out frequency is 1Hz,</description>
                    <value>#010</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Time-out frequency is 2Hz</description>
                    <value>#011</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>4</name>
                    <description>Time-out frequency is 4Hz,</description>
                    <value>#100</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>5</name>
                    <description>Time-out frequency is 8Hz,</description>
                    <value>#101</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>6</name>
                    <description>Time-out frequency is 16Hz,</description>
                    <value>#110</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>7</name>
                    <description>Time-out frequency is 32Hz</description>
                    <value>#111</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>OSCFM</name>
      <description>OSCFM Register Map</description>
      <groupName>OSCFM</groupName>
      <baseAddress>0x40008004</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x0</offset>
        <size>0xC</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>OSCFM_CTL</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>OSCFM_CTL</displayName>
          <description>Frequency Measurement Control Register</description>
          <addressOffset>0x0</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CLK_FM_SEL</name>
              <description>CLK FM SELETION\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FM_DONE</name>
              <description>FM DONE FLAG\nIf FM_GO is "0", clear the FM_DONE.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>not done or no action</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>testing done,</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>FM_CYC</name>
              <description>FM Cycle number\nNote: OSCFM_CYC[7:0] also can write this resigster</description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FM_GO</name>
              <description>FM GO BUSY\n 0 --- no action \n 1 --- start to frequency measurement</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>OSCFM_CNT</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>OSCFM_CNT</displayName>
          <description>Frequency Measurement Counter Register</description>
          <addressOffset>0x4</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>OSCFM_CNT</name>
              <description>FM Counter Number\n Report the counter</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>OSCFM_CYCLE</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>OSCFM_CYCLE</displayName>
          <description>Frequency Measurement Cycle Register</description>
          <addressOffset>0x8</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>FM_CYC</name>
              <description>FM iteration cycle number\n  \nNote: FM_CYC[7:0] can be overwritten by OSCFM_CTL[23:16]</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>SPI0</name>
      <description>SPI Register Map</description>
      <groupName>SPI</groupName>
      <baseAddress>0x40030000</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x0</offset>
        <size>0xC</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x10</offset>
        <size>0x8</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x20</offset>
        <size>0x8</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x34</offset>
        <size>0x8</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>SPI0_CTL</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SPI0_CTL</displayName>
          <description>Control and Status Register</description>
          <addressOffset>0x0</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000004</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>GOBUSY</name>
              <description>Go and Busy Status\nNOTE: All registers should be set before writing 1 to this BUSY bit. When a transfer is in progress, writing to any register of the SPI master/slave core has no effect.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Writing 0 to this bit has no effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Writing 1 to this bit starts the transfer. This bit remains set during the transfer and is automatically cleared after transfer finished</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RXNET</name>
              <description>Receive At Negative Edge\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The received data input signal is latched at the rising edge of SCLK</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The received data input signal is latched at the falling edge of SCLK</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TXNEG</name>
              <description>Transmit At Negative Edge\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The transmitted data output signal is changed at the rising edge of SCLK</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The transmitted data output signal is changed at the falling edge of SCLK</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DWIDTH</name>
              <description>Transmit Bit Length\nThis field specifies how many bits are transmitted in one transmit/receive. Up to 32 bits can be transmitted.\nDWIDTH aaa 0x01 --- 1 bit\nDWIDTH aaa 0x02 --- 2 bits\n----\nDWIDTH aaa 0x1f  --- 31 bits\nDWIDTH aaa 0x00 --- 32 bits</description>
              <bitOffset>3</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TXNUM</name>
              <description>Transmit/Receive Word Numbers\nThis field specifies how many transmit/receive word numbers should be executed in one transfer.\n</description>
              <bitOffset>8</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Only one transmit/receive word will be executed in one transfer</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Two successive transmit/receive word will be executed in one transfer</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Reserved</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Reserved</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>LSB</name>
              <description>LSB First\n</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The MSB is transmitted/received first (which bit in SPI_TX0/1 and SPI_RX0/1 register that is depends on the DWIDTH field)</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The LSB is sent first on the line (bit 0 of SPI_TX0/1), and the first bit received from the line will be put in the LSB position in the Rx register (bit 0 of SPI_RX0/1)</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CLKPOL</name>
              <description>Clock Polarity\n</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>SCLK idle low</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>SCLK idle high</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SUSPITV</name>
              <description>Suspend Interval (Master Only)\nThese four bits provide configurable suspend interval between two successive transmit/receive transactions in a transfer. The suspend interval is from the last falling clock edge of the current transaction to the first rising clock edge of the successive transaction if CLKPOL aaa 0. If CLKPOL aaa 1, the interval is from the rising clock edge to the falling clock edge. The default value is 0x0. When TXCNT aaa 00b, setting this field has no effect on transfer except as determined by REORDER[0] setting. The suspend interval is determined  according to the following equation:\n(SUSPITV[3:0] + 2) * period of SCLK</description>
              <bitOffset>12</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>UNITIF</name>
              <description>Interrupt Flag\nNOTE: This bit is cleared by writing 1 to itself.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Indicates the transfer is not  finished yet</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Indicates that the transfer is complete. Interrupt is generated to CPU if enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>UNITIEN</name>
              <description>Interrupt Enable\n</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disable SPI Interrupt</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable SPI Interrupt to CPU</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SLAVE</name>
              <description>Master Slave Mode Control\n</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Master mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Slave mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BYTEITV</name>
              <description>Insert Sleep Interval Between Bytes\nThis function is only valid for 32bit transfers (DWIDTH aaa 0). If set then a pause of (SUSPITV+2) SCLK cycles is inserted between each byte transmitted.</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>REORDER</name>
              <description>Byte Endian Reorder Function\nThis function changes the order of bytes sent/received to be least significant physical byte first.</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FIFOEN</name>
              <description>FIFO Mode\n</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No FIFO present on transmit and receive buffer</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable FIFO on transmit and receive buffer</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>VARCLKEN</name>
              <description>Variable Clock Enable (Master Only)\nNote that when enabled, the setting of DWIDTH must be programmed as 0x10 (16 bits mode)</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The serial clock output frequency is fixed and determined only by the value of DIVIDER0</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>SCLK output frequency is variable. The output frequency is determined by the value of SPI_VARCLK, DIVIDER0, and DIVIDER1</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RXEMPTY</name>
              <description>Receive FIFO Empty Status\n</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The receive data FIFO is not empty</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The receive data FIFO is empty</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RXFULL</name>
              <description>Receive  FIFO Full Status\n</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The receive data FIFO is not full</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The receive data FIFO is full</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TXEMPTY</name>
              <description>Transmit FIFO Empty Status\n</description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The transmit data FIFO is not empty</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The transmit data FIFO is empty</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TXFULL</name>
              <description>Transmit  FIFO Full Status\n</description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The transmit data FIFO is not full</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The transmit data FIFO is full</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PDMASSEN</name>
              <description>Enable DMA Automatic SS function\nWhen enabled, interface will automatically generate a SS signal for an entire PDMA access transaction.</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SPI0_CLKDIV</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SPI0_CLKDIV</displayName>
          <description>Clock Divider Register (Master Only)</description>
          <addressOffset>0x4</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DIVIDER0</name>
              <description>Clock Divider Register (master only)\nThe value in this field is the frequency division of the system clock, PCLK, to generate the serial clock on the output SCLK. The desired frequency is obtained according to the following equation:\nIn other words, the maximum frequency of SCLK clock is one fifth of the SPI peripheral clock.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DIVIDER1</name>
              <description>Clock Divider 2 Register (master only)\nThe value in this field is the 2nd frequency divider of the system clock, PCLK, to generate the serial clock on the output SCLK. The desired frequency is obtained according to the following equation:\n</description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SPI0_SSCTL</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SPI0_SSCTL</displayName>
          <description>Slave Select Register</description>
          <addressOffset>0x8</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SS</name>
              <description>Slave Select Register (Master only)\nIf AUTOSS bit is cleared, writing 1 to any bit location of this field sets the proper SPISSx0/1 line to an active state and writing 0 sets the line back to inactive state.\nIf AUTOSS bit is set, writing 1 to any bit location of this field will select appropriate SPISSx0/1 line to be automatically driven to active state for the duration of the transmit/receive, and will be driven to inactive state for the rest of the time. (The active level of SPISSx0/1 is specified in SSACTPOL).\nNote: SPISSx0 is always defined as device/slave select input signal in slave mode.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SSACTPOL</name>
              <description>Slave Select Active Level \nIt defines the active level of device/slave select signal (SPISSx0/1).\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The slave select signal SPISSx0/1 is active at low-level/falling-edge</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The slave select signal SPISSx0/1 is active at high-level/rising-edge</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>AUTOSS</name>
              <description>Automatic Slave Select (Master only)\n</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>If this bit is cleared, slave select signals are asserted and de-asserted by setting and clearing related bits in SPI_SSCTL[1:0] register</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>If this bit is set, SPISSx0/1 signals are generated automatically. It means that device/slave select signal, which is set in SPI_SSCTL[1:0] register is asserted by the SPI controller when transmit/receive is started by setting BUSY, and is de-asserted after each transmit/receive is finished</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>LVTRGEN</name>
              <description>Slave Select Level Trigger (Slave only)\n</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The input slave select signal is edge-trigger. This is the default value</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The slave select signal will be level-trigger. It depends on SSACTPOL to decide the signal is active low or active high</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>LVTRGSTS</name>
              <description>Level Trigger Flag\nWhen the LVTRGEN bit is set in slave mode, this bit can be read to indicate the received bit number is met the requirement or not.\nNote: This bit is READ only</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>One of the received number and the received bit length doesn't meet the requirement in one transfer</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The received number and received bits met the requirement which defines in TXCNT and DWIDTH among one transfer</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SPI0_RX0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SPI0_RX0</displayName>
          <description>Data Receive Register 0</description>
          <addressOffset>0x10</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RX</name>
              <description>Data Receive Register\nThe Data Receive Registers hold the value of received data of the last executed transfer. Valid bits depend on the transmit bit length field in the SPI_CNTRL register. For example, if Tx_BIT_LEN is set to 0x08 and Tx_NUM is set to 0x0, bit Rx0[7:0] holds the received data.\nNOTE: The Data Receive Registers are read only registers.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="SPI0_RX0">
          <name>SPI0_RX1</name>
          <displayName>SPI0_RX1</displayName>
          <description>Data Receive Register 1</description>
          <addressOffset>0x14</addressOffset>
       </register>
       <register>
          <name>SPI0_TX0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SPI0_TX0</displayName>
          <description>Data Transmit Register 0</description>
          <addressOffset>0x20</addressOffset>
          <access>write-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>Tx</name>
              <description>Data Transmit Register\nThe Data Transmit Registers hold the data to be transmitted in the next transfer. Valid bits depend on the transmit bit length field in the CNTRL register. For example, if Tx_BIT_LEN is set to 0x08 and the Tx_NUM is set to 0x0, the bit Tx0[7:0] will be transmitted in next transfer. If Tx_BIT_LEN is set to 0x00 and Tx_NUM is set to 0x1, the core will perform two 32-bit transmit/receive successive using the same setting (the order is Tx0[31:0], Tx1[31:0]).</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="SPI0_TX0">
          <name>SPI0_TX1</name>
          <displayName>SPI0_TX1</displayName>
          <description>Data Transmit Register 1</description>
          <addressOffset>0x24</addressOffset>
       </register>
       <register>
          <name>SPI_VARCLK</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SPI_VARCLK</displayName>
          <description>Variable Clock Pattern Register</description>
          <addressOffset>0x34</addressOffset>
          <access>read-write</access>
          <resetValue>0x007FFF87</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>VARCLK</name>
              <description>Variable Clock Pattern\nThe value in this field is the frequency pattern of the SPI clock. If the bit field of VARCLK is '0', the output frequency of SCLK is given by the value of DIVIDER. If the bit field of VARCLK is '1', the output frequency of SCLK is given by the value of DIVIDER2. Refer to register DIVIDER.\nRefer to Variable Serial Clock Frequency paragraph for detailed description.\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SPI_PDMACTL</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SPI_PDMACTL</displayName>
          <description>SPI PDMA Control Register</description>
          <addressOffset>0x38</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TXPDMAEN</name>
              <description>Transmit DMA Start\nSet this bit to 1 will start the transmit DMA process. SPI module will issue request to DMA module automatically. \nIf using DMA mode to transfer data, remember not to set GO_BUSY bit of SPI_CNTRL register. The DMA controller inside SPI module will set it automatically whenever necessary.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXPDMAEN</name>
              <description>Receive DMA Start\nSet this bit to 1 will start the receive DMA process. SPI module will issue request to DMA module automatically.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>TMR</name>
      <description>TMR Register Map</description>
      <groupName>TMR</groupName>
      <baseAddress>0x40010000</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x0</offset>
        <size>0x10</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x20</offset>
        <size>0x18</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x40</offset>
        <size>0x10</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>TIMER0_CTL</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>TIMER0_CTL</displayName>
          <description>Timer0 Control and Status Register</description>
          <addressOffset>0x0</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000005</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PSC</name>
              <description>Timer Clock Prescaler\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ACTSTS</name>
              <description>Timer Active Status Bit (Read Only)\nThis bit indicates the counter status of Timer.\n</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Timer is not active</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Timer is active</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>RSTCNT</name>
              <description>Counter Reset Bit\nSet this bit will reset the Timer counter, pre-scale and also force CNTEN to 0.\n</description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reset Timer's pre-scale counter, internal 16-bit up-counter and CNTEN bit</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>OPMODE</name>
              <description>Timer Operating Mode\n</description>
              <bitOffset>27</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The Timer is operating in the one-shot mode. The associated interrupt signal is generated once (if INTEN is 1) and CNTEN is automatically cleared by hardware</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The Timer is operating in the periodic mode. The associated interrupt signal is generated periodically (if INTEN is 1)</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Reserved</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>The Timer is operating in continuous counting mode. The associated interrupt signal is generated when TIMERx_CNT = TIMERx_CMP (if INTEN is 1); however, the 16-bit up-counter counts continuously without reset</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>INTEN</name>
              <description>Interrupt Enable Bit\nIf timer interrupt is enabled, the timer asserts its interrupt signal when the associated count is equal to TIMERx_CMP.</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disable TIMER Interrupt</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable TIMER Interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CNTEN</name>
              <description>Counter Enable Bit\n</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Stop/Suspend counting</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Start counting</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>TIMER0_CMP</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>TIMER0_CMP</displayName>
          <description>Timer0 Compare Register</description>
          <addressOffset>0x4</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CMPDAT</name>
              <description>Timer Comparison Value\nNote 1: Never set CMPDAT to 0x000 or 0x001. Timer will not function correctly.\nNote 2: No matter CNTEN is 0 or 1, whenever software writes a new value into this register, TIMER will restart counting by using this new value and abort previous count.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>TIMER0_INTSTS</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>TIMER0_INTSTS</displayName>
          <description>Timer0 Interrupt Status Register</description>
          <addressOffset>0x8</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TIF</name>
              <description>Timer Interrupt Flag (Read Only)\nThis bit indicates the interrupt status of Timer.\nTIF bit is set by hardware when the 16-bit counter matches the timer comparison value (CMPDAT). It is cleared by writing 1 to itself\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>CNT (TIMERx_CNT[15:0]) value matches the CMPDAT (TIMERx_CMP[15:0]) value</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>TIMER0_CNT</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>TIMER0_CNT</displayName>
          <description>Timer0 Data Register</description>
          <addressOffset>0xC</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CNT</name>
              <description>Timer Data Register\nUser can read this register for the current up-counter value while TIMERx_CTL.CNTEN is set to 1,</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="TIMER0_CTL">
          <name>TIMER1_CTL</name>
          <displayName>TIMER1_CTL</displayName>
          <description>Timer1 Control and Status Register</description>
          <addressOffset>0x20</addressOffset>
       </register>
       <register derivedFrom="TIMER0_CMP">
          <name>TIMER1_CMP</name>
          <displayName>TIMER1_CMP</displayName>
          <description>Timer1 Compare Register</description>
          <addressOffset>0x24</addressOffset>
       </register>
       <register derivedFrom="TIMER0_INTSTS">
          <name>TIMER1_INTSTS</name>
          <displayName>TIMER1_INTSTS</displayName>
          <description>Timer1 Interrupt Status Register</description>
          <addressOffset>0x28</addressOffset>
       </register>
       <register derivedFrom="TIMER0_CNT">
          <name>TIMER1_CNT</name>
          <displayName>TIMER1_CNT</displayName>
          <description>Timer1 Data Register</description>
          <addressOffset>0x2C</addressOffset>
       </register>
       <register>
          <name>TIMERF_INTSTS</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>TIMERF_INTSTS</displayName>
          <description>TimerF Interrupt Status Register</description>
          <addressOffset>0x30</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TFIF</name>
              <description>TimerF Interrupt Flag\nThis bit indicates the interrupt status of TimerF.\nTFIF bit is set by hardware when TimerF time out. It is cleared by writing 1 to this bit.\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>It indicates that TimerF does not time out yet</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>It indicates that TimerF time out. The interrupt flag is set if TimerF interrupt was enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TFIE</name>
              <description>TimerF Interrupt Enable\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disable TimerF Interrupt</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable TimerF Interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>IR_CTL</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>IR_CTL</displayName>
          <description>IR Carrier Output Control Register</description>
          <addressOffset>0x34</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
          </fields>
       </register>
       <register derivedFrom="TIMER0_CTL">
          <name>TIMER2_CTL</name>
          <displayName>TIMER2_CTL</displayName>
          <description>Timer2 Control and Status Register</description>
          <addressOffset>0x40</addressOffset>
       </register>
       <register derivedFrom="TIMER0_CMP">
          <name>TIMER2_CMP</name>
          <displayName>TIMER2_CMP</displayName>
          <description>Timer2 Compare Register</description>
          <addressOffset>0x44</addressOffset>
       </register>
       <register derivedFrom="TIMER0_INTSTS">
          <name>TIMER2_INTSTS</name>
          <displayName>TIMER2_INTSTS</displayName>
          <description>Timer2 Interrupt Status Register</description>
          <addressOffset>0x48</addressOffset>
       </register>
       <register derivedFrom="TIMER0_CNT">
          <name>TIMER2_CNT</name>
          <displayName>TIMER2_CNT</displayName>
          <description>Timer2 Data Register</description>
          <addressOffset>0x4C</addressOffset>
       </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>WDT</name>
      <description>WDT Register Map</description>
      <groupName>WDT</groupName>
      <baseAddress>0x40004000</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x0</offset>
        <size>0x4</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>WDT_CTL</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>WDT_CTL</displayName>
          <description>Watchdog Timer Control Register</description>
          <addressOffset>0x0</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000700</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RSTCNT</name>
              <description>Clear Watchdog Timer \nSet this bit will clear the Watchdog timer. \nNote: This bit will auto clear after few clock cycles</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Writing 0 to this bit has no effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reset the contents of the Watchdog timer</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RSTEN</name>
              <description>Watchdog Timer Reset Enable\nSetting this bit will enable the Watchdog timer reset function.\nNote: This function cannot work with XTL32-based clock source.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disable Watchdog timer reset function</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable Watchdog timer reset function</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RSTF</name>
              <description>Watchdog Timer Reset Flag\nWhen the Watchdog timer initiates a reset, the hardware will set this bit. This flag can be read by software to determine the source of reset. Software is responsible to clear it manually by writing 1 to it. If RSTEN is disabled, then the Watchdog timer has no effect on this bit.\nNote: This bit is cleared by writing 1 to this bit.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Watchdog timer reset has not occurred</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Watchdog timer reset has occurred</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IF</name>
              <description>Watchdog Timer Interrupt Flag\nIf the Watchdog timer interrupt is enabled, then the hardware will set this bit to indicate that the Watchdog timer interrupt has occurred. If the Watchdog timer interrupt is not enabled, then this bit indicates that a timeout period has elapsed.\nNote: This bit is cleared by writing 1 to this bit.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Watchdog timer interrupt has not occurred</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Watchdog timer interrupt has occurred</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>WKEN</name>
              <description>WDT Time-Out Wake-Up Function Control\nIf this bit is set to 1, while WDT time-out interrupt flag IF (WDT_CTL[3]) is generated to 1 and interrupt enable bit INTEN (WDT_CTL[6]) is enabled, the WDT time-out interrupt signal will generate a wake-up trigger event to chip. \n</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disable WDT Wakeup CPU function</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable the Wakeup function that WDT timeout can wake up CPU from power-down mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>WKF</name>
              <description>WDT Time-Out Wake-Up Flag\nIf WDT causes CPU wake up from sleep or power-down mode, this bit will be set to high.\nNote: This bit is cleared by writing 1 to it.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>WDT does not cause CPU wake-up</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>CPU wakes up from sleep or power-down mode by WDT time-out interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>INTEN</name>
              <description>Watchdog Time-Out Interrupt Enable\n</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disable the WDT time-out interrupt</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable the WDT time-out interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>WDTEN</name>
              <description>Watchdog Timer Enable\n</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disable the WDT(Watchdog timer) (This action will reset the internal counter)</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable the WDT(Watchdog timer)</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TOUTSEL</name>
              <description>Watchdog Timer Interval Select\nThese three bits select the timeout interval for the Watchdog timer, a watchdog reset will occur 1024 clock cycles later if Watchdog timer is not reset. \nThe WDT interrupt timeout is given by:\nWhere WDT_CLK is the period of the Watchdog Timer clock source.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>3</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>24 * WDT_CLK</description>
                    <value>#000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>26 * WDT_CLK</description>
                    <value>#001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>28 * WDT_CLK</description>
                    <value>#010</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>210 * WDT_CLK</description>
                    <value>#011</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>4</name>
                    <description>212 * WDT_CLK</description>
                    <value>#100</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>5</name>
                    <description>214 * WDT_CLK</description>
                    <value>#101</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>6</name>
                    <description>216 * WDT_CLK</description>
                    <value>#110</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>7</name>
                    <description>218 * WDT_CLK</description>
                    <value>#111</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>DPWM</name>
      <description>DPWM Register Map</description>
      <groupName>DPWM</groupName>
      <baseAddress>0x40070000</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x0</offset>
        <size>0x14</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>DPWM_CTL</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>DPWM_CTL</displayName>
          <description>DPWM and DAC Control Register</description>
          <addressOffset>0x0</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MODUFRQ</name>
              <description>DPWM Modulation Frequency. \n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DEADTIME</name>
              <description>DPWM Driver Deadtime Control.\nEnabling this bit will insert an additional clock cycle deadtime into the switching of PMOS and NMOS driver transistors.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DITHEREN</name>
              <description>DPWM Signal Dither Control\nTo prevent structured noise on PWM output due to DC offsets in the input signal it is possible to add random dither to the PWM signal. These bits control the dither:\n0: No dither.\n1: &#177;1 bit dither\n3: &#177;2 bit dither</description>
              <bitOffset>4</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DPWMEN</name>
              <description>DPWM Enable.\n1: Enable DPWM, SPK pins are enabled and driven, data is taken from FIFO.\n0: Disable DPWM, SPK pins are tri-state, CIC filter is reset, FIFO pointers are reset (FIFO data is not reset).\nNote : This field will be effective only when DAC_EN field in this register is set as "0".</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CLIPIE</name>
              <description>Read data in DATA[31:0] clipped within 0x0000-7fff ~ 0xffff-8000\nRead operation of this register will get clipped data in DATA[31:0] register but\nclipped with the range : 0x00 ~ 7fff  ~ 0x ffff ~8000. The content of DATA[31:0]\nwill not be change.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXTHIE</name>
              <description>DPWM FIFO threshold interrupt\n1: DPWM FIFO threshold interrupt Enabled.\n0: DPWM FIFO threshold interrupt Disabled.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXTH</name>
              <description>DPWM FIFO threshold\nIf the valid data count of the DPWM FIFO buffer is less than or equal to RXTH setting, the RXTHF bit will set to 1, else the RXTHF bit will be cleared to 0.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ZCIE</name>
              <description>Zero cross enable\n0: output data doesn't cross zero point\n1: output data cross zero point</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DAC_EN</name>
              <description>DAC ENABLE\n0 --- DAC function disable\n1 --- DAC function enable</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DAC_EN_10BIT</name>
              <description>DAC ENABLE 10Bit\n0 --- 13 Bit mode\n1 --- 10 bit mode, don't use lower 3BITs</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DAC_PD</name>
              <description>DAC POWER DOWN\n0 --- power on DAC13B\n1 --- power down  DAC13B</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DACBUFBYPASS</name>
              <description>DAC BUFFER BYPASS\n0 --- disable BYPASS DAC BUFFER\n1 --- enable  BYPASS DAC BUFFER</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DACBUF_PD</name>
              <description>DAC BUFFER POWER DOWN\n0 --- power on DAC BUFFER \n1 --- power off DAC BUFFER</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DAC_INSEL</name>
              <description>DAC input data selection\n0 ---  DATA from CIC and GAIN output\n1 ---  DATA from FIFO output</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>DPWM_STS</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>DPWM_STS</displayName>
          <description>DPWM and DAC FIFO Status Register</description>
          <addressOffset>0x4</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000002</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>FULL</name>
              <description>FIFO Full\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>FIFO is not full</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>FIFO is full</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>EMPTY</name>
              <description>FIFO Empty\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>FIFO is not empty</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>FIFO is empty</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>RXTHF</name>
              <description>DPWM FIFO threshold Interrupt Status (Read Only)\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The valid data count within the DPWM FIFO buffer is larger than the setting value of RXTH</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The valid data count within the transmit FIFO buffer is less than or equal to the setting value of RXTH</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>FIFO_POINTER</name>
              <description>DPWM FIFO Pointer (Read Only)\nThe FULL bit and FIFO_POINTER[3:0] indicates the field that the valid data count within the DPWM FIFO buffer.\nThe Maximum value shown in FIFO_POINTER is 15. When the using level of DPWM FIFO Buffer equal to 16, The FULL bit is set to 1.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>DPWM_DMACTL</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>DPWM_DMACTL</displayName>
          <description>DPWM and DAC PDMA Control Register</description>
          <addressOffset>0x8</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DMAEN</name>
              <description>Enable DPWM and DAC DMA Interface.\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disable PDMA. No requests will be made to PDMA controller</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable PDMA. Block will request data from PDMA controller whenever FIFO is not empty</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>DPWM_DATA</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>DPWM_DATA</displayName>
          <description>DPWM and DAC FIFO Input Register</description>
          <addressOffset>0xC</addressOffset>
          <access>write-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>INDATA</name>
              <description>DPWM and DAC FIFO Audio Data Input\nA write to this register pushes data onto the DPWM and DAC FIFO and increments the write pointer. This is the address that PDMA writes audio data to.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>DPWM_ZOHDIV</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>DPWM_ZOHDIV</displayName>
          <description>DPWM and DAC Zero Order Hold Division Register</description>
          <addressOffset>0x10</addressOffset>
          <access>read-write</access>
          <resetValue>0x0000FF30</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ZOH_DIV</name>
              <description>DPWM Zero Order Hold, down-sampling divisor.\nThe input sample rate of the DPWM is set by HCLK frequency and the divisor set in this register by the following formula:\nValid range is 1,..,255. Default is 48, which gives a sample rate of 16kHz for a 49.152MHz (default) HCLK.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GAIN</name>
              <description>(GAIN[7:0]+1)/256, GAIN&#8800;0</description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DAC_DIV</name>
              <description>DAC clock divider\nDAC data sample rate is set by this divider\n</description>
              <bitOffset>16</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>ADC</name>
      <description>ADC Register Map</description>
      <groupName>ADC</groupName>
      <baseAddress>0x400E0000</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x0</offset>
        <size>0x38</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x3C</offset>
        <size>0xC</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>ADC_DAT0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>ADC_DAT0</displayName>
          <description>A/D Data Register for the Channel Defined in CHSEQ0</description>
          <addressOffset>0x0</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RESULT</name>
              <description>A/D Conversion Result\nThis field contains the 12-bit conversion result. Its data format is defined by ADCFM bit.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>12</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>EXTS</name>
              <description>Extension Bits Of RESULT for Different Data Format\nIf ADCFM is "0", EXTS all are read as "0".\nIf ADCFM is "1", EXTS all are read as bit RESULT[11].</description>
              <bitOffset>12</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>OV</name>
              <description>Over Run Flag\nIf converted data in RESULT[11:0] have not been read before new conversion result is loaded to this register, OV is set to 1. It is cleared by hardware after ADC_DAT register is read.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Data in RESULT are recent conversion result</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Data in RESULT are overwritten</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>VALID</name>
              <description>Valid Flag\nThis bit is set to 1 when corresponding channel analog input conversion is completed and cleared by hardware after ADC_DAT register is read.</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Data in RESULT are not valid</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Data in RESULT are valid</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="ADC_DAT0">
          <name>ADC_DAT1</name>
          <displayName>ADC_DAT1</displayName>
          <description>A/D Data Register for the Channel Defined in CHSEQ1</description>
          <addressOffset>0x4</addressOffset>
       </register>
       <register derivedFrom="ADC_DAT0">
          <name>ADC_DAT2</name>
          <displayName>ADC_DAT2</displayName>
          <description>A/D Data Register for the Channel Defined in CHSEQ2</description>
          <addressOffset>0x8</addressOffset>
       </register>
       <register derivedFrom="ADC_DAT0">
          <name>ADC_DAT3</name>
          <displayName>ADC_DAT3</displayName>
          <description>A/D Data Register for the Channel Defined in CHSEQ3</description>
          <addressOffset>0xC</addressOffset>
       </register>
       <register derivedFrom="ADC_DAT0">
          <name>ADC_DAT4</name>
          <displayName>ADC_DAT4</displayName>
          <description>A/D Data Register for the Channel Defined in CHSEQ4</description>
          <addressOffset>0x10</addressOffset>
       </register>
       <register derivedFrom="ADC_DAT0">
          <name>ADC_DAT5</name>
          <displayName>ADC_DAT5</displayName>
          <description>A/D Data Register for the Channel Defined in CHSEQ5</description>
          <addressOffset>0x14</addressOffset>
       </register>
       <register derivedFrom="ADC_DAT0">
          <name>ADC_DAT6</name>
          <displayName>ADC_DAT6</displayName>
          <description>A/D Data Register for the Channel Defined in CHSEQ6</description>
          <addressOffset>0x18</addressOffset>
       </register>
       <register derivedFrom="ADC_DAT0">
          <name>ADC_DAT7</name>
          <displayName>ADC_DAT7</displayName>
          <description>A/D Data Register for the Channel Defined in CHSEQ7</description>
          <addressOffset>0x1C</addressOffset>
       </register>
       <register>
          <name>ADC_CTL</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>ADC_CTL</displayName>
          <description>A/D Control Register</description>
          <addressOffset>0x20</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ADCEN</name>
              <description>A/D Converter Enable\nBefore starting A/D conversion function, this bit should be set to 1. Clear it to 0 to disable A/D converter analog circuit power consumption.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disable</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ADCIE</name>
              <description>A/D Interrupt Enable\nA/D conversion end interrupt request is generated if ADCIE bit is set to 1.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disable A/D interrupt function</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable A/D interrupt function</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>OPMODE</name>
              <description>A/D Converter Operation Mode\n\nNote 1: This field will be effective only when DS_EN field in this register is set as "0".\nWhen DS_EN is set as "1",  ADC conversion will be forced to  "continuous scan mode"\nNote 2: When changing the operation mode, software should disable SWTRG bit firstly.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Single conversion</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reserved</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Single-cycle scan</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Continuous scan</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PDMAEN</name>
              <description>PDMA Transfer Enable Bit \n\nWhen A/D conversion is completed, the converted data is loaded into ADC_DATn (n: 0 ~ 7) register, user can enable this bit to generate a PDMA data transfer request. \n</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PDMA data transfer Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PDMA data transfer Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SWTRG</name>
              <description>A/D Conversion Start\nNote: SWTRG bit can be reset to 0 by software, or can be cleared to 0 by hardware automatically at the end of single mode and single-cycle scan mode on specified channel. In continuous scan mode, A/D conversion is continuously performed sequentially until software writes 0 to this bit or chip resets.</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Conversion is stopped and A/D converter enters idle state</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Start conversion</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ADCFM</name>
              <description>Data Format Of ADC Conversion Result\n</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Unsigned</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>2'Complemet</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DS_RATE</name>
              <description>Down Sample Rate\n</description>
              <bitOffset>16</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Down sample X2</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Down sample X4</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Down sample X8</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Down sample X16</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DS_EN</name>
              <description>Down Sample Function Enable \n</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Down sample function is disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Down sample function is enabled. When this field is set, ADC will be forced to continuous scan mode, no matter what is specified in field OPMODE (ADC_CTL[3:2])</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>HP_FSEL</name>
              <description>High-pass Filter Frequency Selection:\n</description>
              <bitOffset>20</bitOffset>
              <bitWidth>3</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Do not remove DC part</description>
                    <value>#000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>DC part is suppressed by -40dB, -3dB at 0.005 x Sampling Rate</description>
                    <value>#001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>DC part is suppressed by -40dB, -3dB at 0.010 x Sampling Rate</description>
                    <value>#010</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>DC part is suppressed by -40dB, -3dB at 0.014 x Sampling Rate</description>
                    <value>#011</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>4</name>
                    <description>DC part is suppressed by -40dB, -3dB at 0.019 x Sampling Rate</description>
                    <value>#100</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>5</name>
                    <description>DC part is suppressed by -40dB, -3dB at 0.023 x Sampling Rate</description>
                    <value>#101</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>6</name>
                    <description>DC part is suppressed by -40dB, -3dB at 0.027 x Sampling Rate</description>
                    <value>#110</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>7</name>
                    <description>DC part is suppressed by -40dB, -3dB at 0.032 x Sampling Rate</description>
                    <value>#111</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>HP_EN</name>
              <description>High-pass Filter Enable\n</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>High-pass filter is disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>High-pass filter is enabled (must in continuous scan mode)</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>ADC_CHSEQ</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>ADC_CHSEQ</displayName>
          <description>A/D Channel Sequence Register</description>
          <addressOffset>0x24</addressOffset>
          <access>read-write</access>
          <resetValue>0xFFFFFFFF</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CHSEQ0</name>
              <description>Select Channel N As The 1st Conversion In Scan Sequence\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CHSEQ1</name>
              <description>Select Channel N As The 2nd Conversion In Scan Sequence\nThe definition of channel selection is the same as CHSEQ0.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CHSEQ2</name>
              <description>Select Channel N As The 3rd Conversion In Scan Sequence\nThe definition of channel selection is the same as CHSEQ0.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CHSEQ3</name>
              <description>Select Channel N As The 4th Conversion In Scan Sequence\nThe definition of channel selection is the same as CHSEQ0.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CHSEQ4</name>
              <description>Select Channel N As The 5th Conversion In Scan Sequence\nThe definition of channel selection is the same as CHSEQ0.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CHSEQ5</name>
              <description>Select Channel N As The 6th Conversion In Scan Sequence\nThe definition of channel selection is the same as CHSEQ0.</description>
              <bitOffset>20</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CHSEQ6</name>
              <description>Select Channel N As The 7th Conversion In Scan Sequence\nThe definition of channel selection is the same as CHSEQ0.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CHSEQ7</name>
              <description>Select Channel N As The 8th Conversion In Scan Sequence\nThe definition of channel selection is the same as CHSEQ0.</description>
              <bitOffset>28</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>ADC_CMP0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>ADC_CMP0</displayName>
          <description>A/D Compare Register 0</description>
          <addressOffset>0x28</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ADCMPEN</name>
              <description>Compare Enable\nSet this bit to 1 to enable the comparison CMPDAT with specified channel conversion result when converted data is loaded into ADC_DAT register.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disable compare</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable compare</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ADCMPIE</name>
              <description>Compare Interrupt Enable\nWhen converted data in RESULT is less (or greater) than the compare data CMPDAT, ADCMPF bit is asserted. If ADCMPIE is set to 1, a compare interrupt request is generated.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disable</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CMPCOND</name>
              <description>Compare Condition\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>ADCMPFx bit is set if conversion result is less than CMPDAT</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>ADCMPFx bit is set if conversion result is greater or equal to CMPDAT,</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CMPCH</name>
              <description>Compare Channel Selection\n</description>
              <bitOffset>3</bitOffset>
              <bitWidth>3</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Channel 0 conversion result is selected to be compared</description>
                    <value>#000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Channel 1 conversion result is selected to be compared</description>
                    <value>#001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Channel 2 conversion result is selected to be compared</description>
                    <value>#010</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Channel 3 conversion result is selected to be compared</description>
                    <value>#011</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>4</name>
                    <description>Reserved</description>
                    <value>#100</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>5</name>
                    <description>The conversion result of pre-amplifier output is selected to be compared</description>
                    <value>#101</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>6</name>
                    <description>Channel 6 conversion result is selected to be compared</description>
                    <value>#110</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>7</name>
                    <description>Channel 7 conversion result is selected to be compared</description>
                    <value>#111</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CMPMCNT</name>
              <description>Compare Match Count\nWhen the specified A/D channel analog conversion result matches the comparing condition, the internal match counter will increase 1. When the internal counter achieves the setting, (CMPMCNT+1) hardware will set the ADCMPF bit.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CMPDAT</name>
              <description>Compare Data\nThis field possessing the 5 MSB of 12-bit compare data, and 7 LSB are treated as "0", is used to compare with conversion result of specified channel. Software can use it to monitor the external analog input pin voltage transition in scan mode without imposing a load on software.\nThe data format should be consistent with the setting of ADCFM bit.</description>
              <bitOffset>23</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="ADC_CMP0">
          <name>ADC_CMP1</name>
          <displayName>ADC_CMP1</displayName>
          <description>A/D Compare Register 1</description>
          <addressOffset>0x2C</addressOffset>
       </register>
       <register>
          <name>ADC_STATUS</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>ADC_STATUS</displayName>
          <description>A/D Status Register</description>
          <addressOffset>0x30</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000070</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_RESULT</name>
              <description>ADC PDMA transfer data\n \nIf DW_EN is "0" and HPF_EN is "0", transfer SAR output to SRAM\nIf DW_EN is "1" and HPF_EN is "0", transfer DW output to SRAM\nIf  HPF_EN is "1", transfer HPF output to SRAM</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>ADC_PDMA</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>ADC_PDMA</displayName>
          <description>ADC PDMA Control Register</description>
          <addressOffset>0x34</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
          </fields>
       </register>
       <register>
          <name>ADC_PGCTL</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>ADC_PGCTL</displayName>
          <description>ADC Pre-amplifier Gain Control Register</description>
          <addressOffset>0x3C</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000900</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ZERO_CROSS</name>
              <description>1: Gain update only on zero crossing. 0: immediate</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SAR_VREF</name>
              <description></description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EN_PGA</name>
              <description>1: Enable PGA 0: Disable PGA</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PD_IBEN</name>
              <description>1: Power down analog bias generation</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>IBGEN_TRIM</name>
              <description>Set to 0</description>
              <bitOffset>12</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MICB_EN</name>
              <description>1: Enable MIC_BIAS</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MICB_VSEL</name>
              <description>Select MIC BIAS level. 0: 0%,1:65%,2:70%,3:50% of VCCA</description>
              <bitOffset>17</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PGA_SEL</name>
              <description></description>
              <bitOffset>24</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>ADC_VMID</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>ADC_VMID</displayName>
          <description>ADC VMID Control Register</description>
          <addressOffset>0x40</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000006</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SHCLK_N</name>
              <description>Specify the high level of ADC start signal.\nNote: Suggested and default value is 0.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CONV_N</name>
              <description>Specify ADC conversion clock number\nCONV_N has to be equal to or great than 11.\nTo update this field, programmer can only revise bit [14:8] and keep other bits the same as before.\nNote: CONV_N valid range is from 11~127</description>
              <bitOffset>8</bitOffset>
              <bitWidth>7</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>ADC_HWPARA</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>ADC_HWPARA</displayName>
          <description>ADC H/W Parameter Control Register</description>
          <addressOffset>0x44</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000B00</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
          </fields>
       </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>PDMA_CH0</name>
      <description>PDMA Register Map</description>
      <groupName>PDMA</groupName>
      <baseAddress>0x50009000</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x0</offset>
        <size>0x28</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>PDMA_CSRx</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_CSRx</displayName>
          <description>PDMA Channel x Control Register</description>
          <addressOffset>0x0</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMACEN</name>
              <description>PDMA Channel Enable\nSetting this bit to 1 enables PDMA's operation. If this bit is cleared, PDMA will ignore all PDMA request and force Bus Master into IDLE state.\nNote: SW_RST will clear this bit.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_RST</name>
              <description>Software Engine Reset\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Writing 0 to this bit has no effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Writing 1 to this bit will reset the internal state machine and pointers. The contents of the control register will not be cleared. This bit will auto clear after a few clock cycles</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>MODE_SEL</name>
              <description>PDMA Mode Select\nThis parameter selects to transfer direction of the PDMA channel. Possible values are:\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Memory to Memory mode (SRAM-to-SRAM)</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>IP to Memory mode (APB-to-SRAM)</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Memory to IP mode (SRAM-to-APB)</description>
                    <value>#10</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SAD_SEL</name>
              <description>Source Address Select\nThis parameter determines the behavior of the current source address register with each PDMA transfer. It can either be fixed, incremented or wrapped.\n</description>
              <bitOffset>4</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Transfer Source address is incremented</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reserved</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Transfer Source address is fixed</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Transfer Source address is wrapped. When CBCR (Current Byte Count) equals zero, the CSAR (Current Source Address) and CBCR registers will be reloaded from the SAR (Source Address) and BCR (Byte Count) registers automatically and PDMA will start another transfer. Cycle continues until software sets PDMA_EN=0. When PDMA_EN is disabled, the PDMA will complete the active transfer but the remaining data in the SBUF will not be transferred to the destination address</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DAD_SEL</name>
              <description>Destination Address Select\nThis parameter determines the behavior of the current destination address register with each PDMA transfer. It can either be fixed, incremented or wrapped.\n</description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Transfer Destination Address is incremented</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reserved</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Transfer Destination Address is fixed (Used when data transferred from multiple addresses to a single destination such as peripheral FIFO input)</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Transfer Destination Address is wrapped. When CBCR (Current Byte Count) equals zero, the CDAR (Current Destination Address) and CBCR registers will be reloaded from the DAR (Destination Address) and BCR (Byte Count) registers automatically and PDMA will start another transfer. Cycle continues until software sets PDMA_EN=0. When PDMA_EN is disabled, the PDMA will complete the active transfer but the remaining data in the SBUF will not be transferred to the destination address</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>WRA_INT_SEL</name>
              <description>Wrap Interrupt Select \nx1x1: Both half and w interrupts generated.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>APB_TWS</name>
              <description>Peripheral Transfer Width Select.\nThis parameter determines the data width to be transferred each PDMA transfer operation.\nNote: This field is meaningful only when MODE_SEL is IP to Memory mode (APB-to-Memory) or Memory to IP mode (Memory-to-APB).</description>
              <bitOffset>19</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>One word (32 bits) is transferred for every PDMA operation</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>One byte (8 bits) is transferred for every PDMA operation</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>One half-word (16 bits) is transferred for every PDMA operation</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Reserved</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TRIG_EN</name>
              <description>Trigger Enable - Start a PDMA operation.\nNote: When PDMA transfer completed, this bit will be cleared automatically.\nIf a bus error occurs, all PDMA transfer will be stopped. Software must reset  PDMA channel, and then trigger again.</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Write: no effect. Read: Idle/Finished</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable PDMA data read or write transfer</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PDMA_SARx</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_SARx</displayName>
          <description>PDMA Channel x Source Address Register</description>
          <addressOffset>0x4</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SAR</name>
              <description>PDMA Transfer Source Address Register\nThis register holds the initial Source Address of PDMA transfer. \nNote: The source address must be word aligned.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PDMA_DARx</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_DARx</displayName>
          <description>PDMA Channel x Destination Address Register</description>
          <addressOffset>0x8</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DAR</name>
              <description>PDMA Transfer Destination Address Register\nThis register holds the initial Destination Address of PDMA transfer. \nNote: The destination address must be word aligned.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PDMA_BCRx</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_BCRx</displayName>
          <description>PDMA Channel x Transfer Byte Count Register</description>
          <addressOffset>0xC</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BCR</name>
              <description>PDMA Transfer Byte Count Register\nThis register controls the transfer byte count of PDMA. Maximum value is 0xFFFF.\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PDMA_POINTx</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_POINTx</displayName>
          <description>PDMA Channel x Internal Buffer Pointer Register</description>
          <addressOffset>0x10</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>POINT</name>
              <description>PDMA Internal Buffer Pointer Register (Read Only)\nA PDMA transaction consists of two stages, a read from the source address and a write to the destination address. Internally this data is buffered in a 32bit register. If transaction width between the read and write transactions are different, this register tracks which byte/half-word of the internal buffer is being processed by the current transaction.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PDMA_CSARx</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_CSARx</displayName>
          <description>PDMA Channel x Current Source Address Register</description>
          <addressOffset>0x14</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CSAR</name>
              <description>PDMA Current Source Address Register (Read Only)\nThis register returns the source address from which the PDMA transfer is occurring. This register is loaded from SAR when PDMA is triggered or when a wraparound occurs.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PDMA_CDARx</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_CDARx</displayName>
          <description>PDMA Channel x Current Destination Address Register</description>
          <addressOffset>0x18</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CDAR</name>
              <description>PDMA Current Destination Address Register (Read Only)\nThis register returns the destination address to which the PDMA transfer is occurring. This register is loaded from DAR when PDMA is triggered or when a wraparound occurs.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PDMA_CBCRx</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_CBCRx</displayName>
          <description>PDMA Channel x Current Transfer Byte Count Register</description>
          <addressOffset>0x1C</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CBCR</name>
              <description>PDMA Current Byte Count Register (Read Only)\nThis field indicates the current remaining byte count of PDMA transfer. This register is initialized with BCR register when PDMA is triggered or when a wraparound occurs</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PDMA_IERx</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_IERx</displayName>
          <description>PDMA Channel x Interrupt Enable Register</description>
          <addressOffset>0x20</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000001</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TABORT_IE</name>
              <description>PDMA Read/Write Target Abort Interrupt Enable\nIf enabled, the PDMA controller will generate and interrupt to the CPU whenever a PDMA transaction is aborted due to an error. If a transfer is aborted, PDMA channel must be reset to resume DMA operation. \n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disable PDMA transfer target abort interrupt generation</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable PDMA transfer target abort interrupt generation</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BLKD_IE</name>
              <description>PDMA Transfer Done Interrupt Enable\nIf enabled, the PDMA controller will generate and interrupt to the CPU when the requested PDMA transfer is complete.\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disable PDMA transfer done interrupt generation</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable PDMA transfer done interrupt generation</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>WAR_IE</name>
              <description>Wraparound Interrupt Enable\nIf enabled, and channel source or destination address is in wraparound mode,  the PDMA controller will generate a WRAP interrupt to the CPU according to the setting of CSR.WRA_INT_SEL. This can be interrupts when the transaction has finished and has wrapped around and/or when the transaction is half way in progress. This allows the efficient implementation of circular buffers for DMA.\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disable Wraparound PDMA interrupt generation</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable Wraparound interrupt generation</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PDMA_ISRx</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_ISRx</displayName>
          <description>PDMA Channel x Interrupt Status Register</description>
          <addressOffset>0x24</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xF0F0FFFF</resetMask>
          <fields>
            <field>
              <name>TABORT_IF</name>
              <description>PDMA Read/Write Target Abort Interrupt Flag\nThis flag indicates a Target Abort interrupt condition has occurred. This condition can happen if attempt is made to read/write from  invalid or  non-existent memory space. It occurs when PDMA controller receives a bus error from AHB master. Upon occurrence PDMA will stop transfer and go to idle state. To resume, software must reset PDMA channel and initiate transfer again.\nNOTE: This bit is cleared by writing 1 to itself.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No bus ERROR response received</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Bus ERROR response received</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BLKD_IF</name>
              <description>Block Transfer Done Interrupt Flag\nThis bit indicates that PDMA block transfer complete interrupt has been generated. It is cleared by writing 1 to the bit.\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Transfer ongoing or Idle</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Transfer Complete</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>WAR_IF</name>
              <description>Wrap around transfer byte count interrupt flag.\nThese flags are set whenever the conditions for a wraparound interrupt (complete or half complete) are met. They are cleared by writing one to the bits.\n</description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Current transfer finished flag (CBCR==0)</description>
                    <value>#0001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>4</name>
                    <description>Current transfer half complete flag (CBCR==BCR/2)</description>
                    <value>#0100</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>INTR</name>
              <description>Interrupt Pin Status (Read Only)\nThis bit is the Interrupt pin status of PDMA channel.</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>PDMA_CH1</name>
      <description>PDMA Register Map</description>
      <groupName>PDMA</groupName>
      <baseAddress>0x50009100</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x0</offset>
        <size>0x28</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>PDMA_CSRx</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_CSRx</displayName>
          <description>PDMA Channel x Control Register</description>
          <addressOffset>0x0</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMACEN</name>
              <description>PDMA Channel Enable\nSetting this bit to 1 enables PDMA's operation. If this bit is cleared, PDMA will ignore all PDMA request and force Bus Master into IDLE state.\nNote: SW_RST will clear this bit.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_RST</name>
              <description>Software Engine Reset\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Writing 0 to this bit has no effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Writing 1 to this bit will reset the internal state machine and pointers. The contents of the control register will not be cleared. This bit will auto clear after a few clock cycles</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>MODE_SEL</name>
              <description>PDMA Mode Select\nThis parameter selects to transfer direction of the PDMA channel. Possible values are:\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Memory to Memory mode (SRAM-to-SRAM)</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>IP to Memory mode (APB-to-SRAM)</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Memory to IP mode (SRAM-to-APB)</description>
                    <value>#10</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SAD_SEL</name>
              <description>Source Address Select\nThis parameter determines the behavior of the current source address register with each PDMA transfer. It can either be fixed, incremented or wrapped.\n</description>
              <bitOffset>4</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Transfer Source address is incremented</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reserved</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Transfer Source address is fixed</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Transfer Source address is wrapped. When CBCR (Current Byte Count) equals zero, the CSAR (Current Source Address) and CBCR registers will be reloaded from the SAR (Source Address) and BCR (Byte Count) registers automatically and PDMA will start another transfer. Cycle continues until software sets PDMA_EN=0. When PDMA_EN is disabled, the PDMA will complete the active transfer but the remaining data in the SBUF will not be transferred to the destination address</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DAD_SEL</name>
              <description>Destination Address Select\nThis parameter determines the behavior of the current destination address register with each PDMA transfer. It can either be fixed, incremented or wrapped.\n</description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Transfer Destination Address is incremented</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reserved</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Transfer Destination Address is fixed (Used when data transferred from multiple addresses to a single destination such as peripheral FIFO input)</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Transfer Destination Address is wrapped. When CBCR (Current Byte Count) equals zero, the CDAR (Current Destination Address) and CBCR registers will be reloaded from the DAR (Destination Address) and BCR (Byte Count) registers automatically and PDMA will start another transfer. Cycle continues until software sets PDMA_EN=0. When PDMA_EN is disabled, the PDMA will complete the active transfer but the remaining data in the SBUF will not be transferred to the destination address</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>WRA_INT_SEL</name>
              <description>Wrap Interrupt Select \nx1x1: Both half and w interrupts generated.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>APB_TWS</name>
              <description>Peripheral Transfer Width Select.\nThis parameter determines the data width to be transferred each PDMA transfer operation.\nNote: This field is meaningful only when MODE_SEL is IP to Memory mode (APB-to-Memory) or Memory to IP mode (Memory-to-APB).</description>
              <bitOffset>19</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>One word (32 bits) is transferred for every PDMA operation</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>One byte (8 bits) is transferred for every PDMA operation</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>One half-word (16 bits) is transferred for every PDMA operation</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Reserved</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TRIG_EN</name>
              <description>Trigger Enable - Start a PDMA operation.\nNote: When PDMA transfer completed, this bit will be cleared automatically.\nIf a bus error occurs, all PDMA transfer will be stopped. Software must reset  PDMA channel, and then trigger again.</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Write: no effect. Read: Idle/Finished</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable PDMA data read or write transfer</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PDMA_SARx</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_SARx</displayName>
          <description>PDMA Channel x Source Address Register</description>
          <addressOffset>0x4</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SAR</name>
              <description>PDMA Transfer Source Address Register\nThis register holds the initial Source Address of PDMA transfer. \nNote: The source address must be word aligned.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PDMA_DARx</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_DARx</displayName>
          <description>PDMA Channel x Destination Address Register</description>
          <addressOffset>0x8</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DAR</name>
              <description>PDMA Transfer Destination Address Register\nThis register holds the initial Destination Address of PDMA transfer. \nNote: The destination address must be word aligned.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PDMA_BCRx</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_BCRx</displayName>
          <description>PDMA Channel x Transfer Byte Count Register</description>
          <addressOffset>0xC</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BCR</name>
              <description>PDMA Transfer Byte Count Register\nThis register controls the transfer byte count of PDMA. Maximum value is 0xFFFF.\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PDMA_POINTx</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_POINTx</displayName>
          <description>PDMA Channel x Internal Buffer Pointer Register</description>
          <addressOffset>0x10</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>POINT</name>
              <description>PDMA Internal Buffer Pointer Register (Read Only)\nA PDMA transaction consists of two stages, a read from the source address and a write to the destination address. Internally this data is buffered in a 32bit register. If transaction width between the read and write transactions are different, this register tracks which byte/half-word of the internal buffer is being processed by the current transaction.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PDMA_CSARx</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_CSARx</displayName>
          <description>PDMA Channel x Current Source Address Register</description>
          <addressOffset>0x14</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CSAR</name>
              <description>PDMA Current Source Address Register (Read Only)\nThis register returns the source address from which the PDMA transfer is occurring. This register is loaded from SAR when PDMA is triggered or when a wraparound occurs.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PDMA_CDARx</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_CDARx</displayName>
          <description>PDMA Channel x Current Destination Address Register</description>
          <addressOffset>0x18</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CDAR</name>
              <description>PDMA Current Destination Address Register (Read Only)\nThis register returns the destination address to which the PDMA transfer is occurring. This register is loaded from DAR when PDMA is triggered or when a wraparound occurs.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PDMA_CBCRx</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_CBCRx</displayName>
          <description>PDMA Channel x Current Transfer Byte Count Register</description>
          <addressOffset>0x1C</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CBCR</name>
              <description>PDMA Current Byte Count Register (Read Only)\nThis field indicates the current remaining byte count of PDMA transfer. This register is initialized with BCR register when PDMA is triggered or when a wraparound occurs</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PDMA_IERx</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_IERx</displayName>
          <description>PDMA Channel x Interrupt Enable Register</description>
          <addressOffset>0x20</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000001</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TABORT_IE</name>
              <description>PDMA Read/Write Target Abort Interrupt Enable\nIf enabled, the PDMA controller will generate and interrupt to the CPU whenever a PDMA transaction is aborted due to an error. If a transfer is aborted, PDMA channel must be reset to resume DMA operation. \n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disable PDMA transfer target abort interrupt generation</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable PDMA transfer target abort interrupt generation</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BLKD_IE</name>
              <description>PDMA Transfer Done Interrupt Enable\nIf enabled, the PDMA controller will generate and interrupt to the CPU when the requested PDMA transfer is complete.\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disable PDMA transfer done interrupt generation</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable PDMA transfer done interrupt generation</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>WAR_IE</name>
              <description>Wraparound Interrupt Enable\nIf enabled, and channel source or destination address is in wraparound mode,  the PDMA controller will generate a WRAP interrupt to the CPU according to the setting of CSR.WRA_INT_SEL. This can be interrupts when the transaction has finished and has wrapped around and/or when the transaction is half way in progress. This allows the efficient implementation of circular buffers for DMA.\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disable Wraparound PDMA interrupt generation</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable Wraparound interrupt generation</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PDMA_ISRx</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_ISRx</displayName>
          <description>PDMA Channel x Interrupt Status Register</description>
          <addressOffset>0x24</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xF0F0FFFF</resetMask>
          <fields>
            <field>
              <name>TABORT_IF</name>
              <description>PDMA Read/Write Target Abort Interrupt Flag\nThis flag indicates a Target Abort interrupt condition has occurred. This condition can happen if attempt is made to read/write from  invalid or  non-existent memory space. It occurs when PDMA controller receives a bus error from AHB master. Upon occurrence PDMA will stop transfer and go to idle state. To resume, software must reset PDMA channel and initiate transfer again.\nNOTE: This bit is cleared by writing 1 to itself.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No bus ERROR response received</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Bus ERROR response received</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BLKD_IF</name>
              <description>Block Transfer Done Interrupt Flag\nThis bit indicates that PDMA block transfer complete interrupt has been generated. It is cleared by writing 1 to the bit.\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Transfer ongoing or Idle</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Transfer Complete</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>WAR_IF</name>
              <description>Wrap around transfer byte count interrupt flag.\nThese flags are set whenever the conditions for a wraparound interrupt (complete or half complete) are met. They are cleared by writing one to the bits.\n</description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Current transfer finished flag (CBCR==0)</description>
                    <value>#0001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>4</name>
                    <description>Current transfer half complete flag (CBCR==BCR/2)</description>
                    <value>#0100</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>INTR</name>
              <description>Interrupt Pin Status (Read Only)\nThis bit is the Interrupt pin status of PDMA channel.</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>PDMA_GCR</name>
      <description>PDMA Register Map</description>
      <groupName>PDMA</groupName>
      <baseAddress>0x50009F00</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x0</offset>
        <size>0x8</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0xC</offset>
        <size>0x4</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>PDMA_GCRCSR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_GCRCSR</displayName>
          <description>PDMA Global Control Register</description>
          <addressOffset>0x0</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_RST</name>
              <description>PDMA Software Reset\nNote: This bit can reset all channels (global reset).</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Writing 0 to this bit has no effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Writing 1 to this bit will reset the internal state machine and pointers. The contents of control register will not be cleared. This bit will auto clear after several clock cycles</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>HCLK_EN</name>
              <description>PDMA Controller Channel Clock Enable Control\nTo enable clock for channel  n HCLK_EN[n] must be set.\n</description>
              <bitOffset>8</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PDMA_PDSSR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_PDSSR</displayName>
          <description>PDMA Service Selection Control Register</description>
          <addressOffset>0x4</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SPI0_RXSEL</name>
              <description>PDMA SPI0 Receive Selection\nThis field defines which PDMA channel is connected to SPI0 peripheral receive (PDMA source) request.\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No channel select</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Select channel 0</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Select channel 1</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Reserved</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SPI0_TXSEL</name>
              <description>PDMA SPI0 Transmit Selection\nThis field defines which PDMA channel is connected to SPI0 peripheral transmit (PDMA destination) request.\n</description>
              <bitOffset>4</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No channel select</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Select channel 0</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Select channel 1</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Reserved</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SPIM_RXSEL</name>
              <description>PDMA SPIM Receive Selection\nThis field defines which PDMA channel is connected to SPIM peripheral receive (PDMA source) request.\n</description>
              <bitOffset>8</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No channel select</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Select channel 0</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Select channel 1</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Reserved</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SPIM_TXSEL</name>
              <description>PDMA SPIM Transmit Selection\nThis field defines which PDMA channel is connected to SPIM peripheral transmit (PDMA destination) request.\n</description>
              <bitOffset>12</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No channel select</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Select channel 0</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Select channel 1</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Reserved</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ADC_RXSEL</name>
              <description>PDMA ADC Receive Selection\nThis field defines which PDMA channel is connected to ADC peripheral receive (PDMA source) request.\n</description>
              <bitOffset>16</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No channel select</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Select channel 0</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Select channel 1</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Reserved</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DPWM_TXSEL</name>
              <description>PDMA DPWM Transmit Selection\nThis field defines which PDMA channel is connected to DPWM peripheral transmit (PDMA destination) request.\n</description>
              <bitOffset>20</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No channel select</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Select channel 0</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Select channel 1</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Reserved</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PDMA_GCRISR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_GCRISR</displayName>
          <description>PDMA Global Interrupt Status Register</description>
          <addressOffset>0xC</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>GCRISR</name>
              <description>Interrupt Pin Status (Read Only)\nGCRISR[n] is the interrupt status of PDMA channel n.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>SPIM</name>
      <description>SPIM Register Map</description>
      <groupName>SPIM</groupName>
      <baseAddress>0x50007000</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x0</offset>
        <size>0x8</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x10</offset>
        <size>0x20</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>SPIM_CTL0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SPIM_CTL0</displayName>
          <description>Control and Status Register 0</description>
          <addressOffset>0x0</addressOffset>
          <access>read-write</access>
          <resetValue>0x00C00002</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RXDMAEN</name>
              <description>RX DMA Enable Control Bit\nIf set RXDMAEN to high, SPI interface will receive the data from slave automatically.\nNote: Only support master mode.\nNote2: Before setting RXDMAEN, user must set PDMA register correctly first.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>DMA Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>DMA Enable</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TXDMAEN</name>
              <description>TX DMA Enable Control Bit\nIf set TXDMAEN to high, SPI interface will transfer the data to slave automatically.\nNote: Only support master mode.\nNote2: Before setting RXDMAEN, user must set PDMA register correctly first.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>DMA Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>DMA Enable</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IEN</name>
              <description>Interrupt Enable Control\n</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>SPIM Interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>SPIM Interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IF</name>
              <description>Interrupt Flag\nWrite Operation:\n</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect.\nThe transfer has not finished yet</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Write 1 to clear.\nThe transfer has done</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DWIDTH</name>
              <description>Transmit/Receive Bit Length\nThis field specifies how many bits are transmitted/received in one transmit/receive transaction.\nNote: Only 8-, 16-, 24-, and 32-bit are allowed. Other bit length will result in incorrect transfer.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>5</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>7</name>
                    <description>8 bits</description>
                    <value>0x7</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>15</name>
                    <description>16 bits</description>
                    <value>0xf</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>23</name>
                    <description>24 bits</description>
                    <value>0x17</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>31</name>
                    <description>32 bits</description>
                    <value>0x1f</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BURSTNUM</name>
              <description>Transmit/Receive Burst Number\nThis field specifies how many transmit/receive transactions should be executed continuously in one transfer.\n</description>
              <bitOffset>13</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Only one transmit/receive transaction will be executed in one transfer</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Two successive transmit/receive transactions will be executed in one transfer</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Three successive transmit/receive transactions will be executed in one transfer</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Four successive transmit/receive transactions will be executed in one transfer</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>QDIODIR</name>
              <description>SPI Interface Direction Select For Quad/Dual Mode\n</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Interface signals are input</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Interface signals are output</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SUSPITV</name>
              <description>Suspend Interval\n</description>
              <bitOffset>16</bitOffset>
              <bitWidth>4</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>2 HCLK clock cycles</description>
                    <value>0x0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>3 HCLK clock cycles</description>
                    <value>0x1</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>14</name>
                    <description>16 HCLK clock cycles</description>
                    <value>0xe</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>15</name>
                    <description>17 HCLK clock cycles</description>
                    <value>0xf</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BITMODE</name>
              <description>SPI Interface Bit Mode\nNote. SPIM_MOSI is Data 0 pin for Quad Mode.\nSPIM_MISO is Data 1 pin for Quad Mode.</description>
              <bitOffset>20</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Standard mode</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Dual mode</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Quad mode</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Reserved</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SPIM_CTL1</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SPIM_CTL1</displayName>
          <description>Control Register 1</description>
          <addressOffset>0x4</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000010</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SPIMEN</name>
              <description>Go and Busy Status\nWrite Operation:\nNote: All registers should be set before writing 1 to the SPIMEN bit. When a transfer is in progress, you should not write to any register of this peripheral.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect.\nThe transfer has done</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Start the transfer. This bit remains set during the transfer and is automatically cleared after transfer finished.\nThe transfer has not finished yet</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SS</name>
              <description>Slave Select Active Enable Control\nNote: This interface can only drive one device/slave at a given time. Therefore, the slave selects of the selected device must be set to its active level before starting any read or write transfer.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>SPIM_SS is in active level</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>SPIM_SS is in inactive level</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SSACTPOL</name>
              <description>Slave Select Active Level\nIt defines the active level of device/slave select signal (SPIM_SS).\n</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The SPIM_SS slave select signal is Active Low</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The SPIM_SS slave select signal is Active High</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DLYSEL</name>
              <description>RX Sample Clock Source Delay Chain Select\n</description>
              <bitOffset>12</bitOffset>
              <bitWidth>3</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Not Delay</description>
                    <value>#000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Select sample clock through 2 Delay Cell</description>
                    <value>#001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Select sample clock through 4 Delay Cell</description>
                    <value>#010</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Select sample clock through 6 Delay Cell</description>
                    <value>#011</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>7</name>
                    <description>Select sample clock through 14 Delay Cell</description>
                    <value>#111</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DIVIDER</name>
              <description>Clock Divider Register\nThe value in this field is the frequency divider of the system clock to generate the serial clock on the output SPIM_CLK pin. The desired frequency is obtained according to the following equation:\n\nNote: When set DIVIDER to zero, the frequency of SPIM_CLK will be equal to the frequency of SYS_CLK.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SPIM_RX0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SPIM_RX0</displayName>
          <description>Data Receive Register 0</description>
          <addressOffset>0x10</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RX</name>
              <description>Data Receive Register\nThe Data Receive Registers hold the received data of the last executed transfer. \nNumber of valid RX registers is specified in SPIM_CTL0[BURSTNUM]. If BURSTNUM &gt; 0, received data are held in the most significant RX register first.\nNumber of valid-bit is specified in SPIM_CTL0[DWIDTH]. If DWIDTH is 16, 24, or 32, received data are held in the least significant byte of RX register first.\nIn a byte, received data are held in the most significant bit of RX register first.\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="SPIM_RX0">
          <name>SPIM_RX1</name>
          <displayName>SPIM_RX1</displayName>
          <description>Data Receive Register 1</description>
          <addressOffset>0x14</addressOffset>
       </register>
       <register derivedFrom="SPIM_RX0">
          <name>SPIM_RX2</name>
          <displayName>SPIM_RX2</displayName>
          <description>Data Receive Register 2</description>
          <addressOffset>0x18</addressOffset>
       </register>
       <register derivedFrom="SPIM_RX0">
          <name>SPIM_RX3</name>
          <displayName>SPIM_RX3</displayName>
          <description>Data Receive Register 3</description>
          <addressOffset>0x1C</addressOffset>
       </register>
       <register>
          <name>SPIM_TX0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SPIM_TX0</displayName>
          <description>Data Transmit Register 0</description>
          <addressOffset>0x20</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TX</name>
              <description>Data Transmit Register\nThe Data Transmit Registers hold the data to be transmitted in next transfer. \nNumber of valid TX registers is specified in SPIM_CTL0[BURSTNUM]. If BURSTNUM &gt; 0, data are transmitted in the most significant TX register first.\nNumber of valid-bit is specified in SPIM_CTL0[DWIDTH]. If DWIDTH is 16, 24, or 32, data are transmitted in the least significant byte of TX register first.\nIn a byte, data are transmitted in the most significant bit of TX register first.\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="SPIM_TX0">
          <name>SPIM_TX1</name>
          <displayName>SPIM_TX1</displayName>
          <description>Data Transmit Register 1</description>
          <addressOffset>0x24</addressOffset>
       </register>
       <register derivedFrom="SPIM_TX0">
          <name>SPIM_TX2</name>
          <displayName>SPIM_TX2</displayName>
          <description>Data Transmit Register 2</description>
          <addressOffset>0x28</addressOffset>
       </register>
       <register derivedFrom="SPIM_TX0">
          <name>SPIM_TX3</name>
          <displayName>SPIM_TX3</displayName>
          <description>Data Transmit Register 3</description>
          <addressOffset>0x2C</addressOffset>
       </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>FMC</name>
      <description>FCM Register Map</description>
      <groupName>FCM</groupName>
      <baseAddress>0x5000C000</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x0</offset>
        <size>0x18</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>FMC_ISPCTL</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>FMC_ISPCTL</displayName>
          <description>ISP Control Register</description>
          <addressOffset>0x0</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ISPEN</name>
              <description>ISP Enable\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disable ISP function</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable ISP function</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BS</name>
              <description>Boot Select \n1: LDROM, 0: APROM\nModify this bit to select which ROM next boot is to occur. This bit also functions as MCU boot status flag, which can be used to check where MCU booted from. This bit is initialized after power-on reset with the inverse of CBS in Config0; It is not reset for any other reset event.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CFGUEN</name>
              <description>CONFIG Update Enable\nWhen enabled, ISP functions can access the CONFIG address space and modify device configuration area.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable, 0 = Disable</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>LDUEN</name>
              <description>LDROM Update Enable\nLDROM update enable bit. \n</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>LDROM cannot be updated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>LDROM can be updated when the MCU runs in APROM</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ISPFF</name>
              <description>ISP Fail Flag\nThis bit is set by hardware when a triggered ISP meets any of the following conditions:\n(1) APROM writes to itself.\n(2) LDROM writes to itself. \n(3) Destination address is illegal, such as over an available range.\nWrite 1 to clear.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SWRST</name>
              <description>Software Reset\nWriting 1 to this bit will initiate a software reset. It is cleared by hardware after reset.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>WAIT_CFG</name>
              <description>Flash Access Wait State Configuration\n0x11: Zero wait states. HCLK &lt; 24MHz\n0x01: Two wait states. \n0x00: Four wait state.\nBefore changing WAIT_CFG, ensure HCLK speed is &lt; 25MHz.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CACHE_DIS</name>
              <description>Cache Disable\nWhen set to 1, caching of flash memory reads is disabled.</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>FMC_ISPADR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>FMC_ISPADR</displayName>
          <description>ISP Address Register</description>
          <addressOffset>0x4</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ISPADR</name>
              <description>ISP Address Register\nThis is the memory address register that a subsequent ISP command will access. ISP operation are carried out on 32bit words only, consequently ISPARD[1:0] must be 00b for  correct ISP operation.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>FMC_ISPDAT</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>FMC_ISPDAT</displayName>
          <description>ISP Data Register</description>
          <addressOffset>0x8</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ISPDAT</name>
              <description>ISP Data Register\nWrite data to this register before an ISP program operation.\nRead data from this register after an ISP read operation</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>FMC_ISPCMD</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>FMC_ISPCMD</displayName>
          <description>ISP Command Register</description>
          <addressOffset>0xC</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ISPCMD</name>
              <description>ISP Command \n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>6</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Read</description>
                    <value>0x00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>11</name>
                    <description>Read CID</description>
                    <value>0x0b</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>12</name>
                    <description>Read DID</description>
                    <value>0x0c</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>33</name>
                    <description>Program</description>
                    <value>0x21</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>34</name>
                    <description>Page Erase</description>
                    <value>0x22</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>FMC_ISPTRG</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>FMC_ISPTRG</displayName>
          <description>ISP Trigger Control Register</description>
          <addressOffset>0x10</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ISPGO</name>
              <description>ISP Start Trigger\nWrite 1 to start ISP operation. This will be cleared to 0 by hardware automatically when ISP operation is finished.\nAfter triggering an ISP function M0 instruction pipeline should be flushed with a ISB instruction to guarantee data integrity.\nThis is a protected register, user must first follow the unlock sequence (see Register Lock Control Register (SYS_REGLCTL)) to gain access.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>ISP operation is finished</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>ISP is on going</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>FMC_DFBADR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>FMC_DFBADR</displayName>
          <description>Data Flash Base Address Register</description>
          <addressOffset>0x14</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>DFBA</name>
              <description>Data Flash Base Address\nThis register reports the data flash starting address. It is a read only register.\nData flash size is defined by user configuration, register content is loaded from Config1 when chip is reset.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
      </registers>
    </peripheral>
  </peripherals>
</device>
