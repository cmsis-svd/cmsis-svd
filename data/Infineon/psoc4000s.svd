<?xml version="1.0" encoding="utf-8"?>
<!-- Generator version: 1.6.0.358 -->
<device schemaVersion="1.3" xmlns:xs="http://www.w3.org/2001/XMLSchema-instance" xs:noNamespaceSchemaLocation="CMSIS-SVD.xsd">
  <vendor>Cypress Semiconductor</vendor>
  <vendorID>Cypress</vendorID>
  <name>psoc4000s</name>
  <series>PSoC4000S</series>
  <version>1.0</version>
  <description>PSoC4000S</description>
  <licenseText>Copyright 2016-2020 Cypress Semiconductor Corporation\n
    SPDX-License-Identifier: Apache-2.0\n
\n
    Licensed under the Apache License, Version 2.0 (the "License");\n
    you may not use this file except in compliance with the License.\n
    You may obtain a copy of the License at\n
\n
      http://www.apache.org/licenses/LICENSE-2.0\n
\n
    Unless required by applicable law or agreed to in writing, software\n
    distributed under the License is distributed on an "AS IS" BASIS,\n
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n
    See the License for the specific language governing permissions and\n
    limitations under the License.</licenseText>
  <cpu>
    <name>CM0PLUS</name>
    <revision>r0p1</revision>
    <endian>little</endian>
    <mpuPresent>false</mpuPresent>
    <fpuPresent>false</fpuPresent>
    <vtorPresent>1</vtorPresent>
    <nvicPrioBits>2</nvicPrioBits>
    <vendorSystickConfig>0</vendorSystickConfig>
  </cpu>
  <addressUnitBits>8</addressUnitBits>
  <width>32</width>
  <resetValue>0x00000000</resetValue>
  <resetMask>0xFFFFFFFF</resetMask>
  <peripherals>
    <peripheral>
      <name>PERI</name>
      <description>Peripheral Interconnect</description>
      <baseAddress>0x40010000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>65536</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>DIV_CMD</name>
          <description>Divider command register</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xFFFF</resetValue>
          <resetMask>0xC000FFFF</resetMask>
          <fields>
            <field>
              <name>SEL_DIV</name>
              <description>(SEL_TYPE, SEL_DIV) specifies the divider on which the command (DISABLE/ENABLE) is performed.
 
If SEL_DIV is '63' and 'SEL_TYPE' is '3' (default/reset value), no divider is specified and no clock signal(s) are generated.</description>
              <bitRange>[5:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SEL_TYPE</name>
              <description>Specifies the divider type of the divider on which the command is performed:
0: 8.0 (integer) clock dividers.
1: 16.0 (integer) clock dividers.
2: 16.5 (fractional) clock dividers.
3: 24.5 (fractional) clock dividers.</description>
              <bitRange>[7:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PA_SEL_DIV</name>
              <description>(PA_SEL_TYPE, PA_SEL_DIV) pecifies the divider to which phase alignment is performed for the clock enable command. Any enabled divider can be used as reference. This allows all dividers to be aligned with each other, even when they are enabled at different times.
 
If PA_SEL_DIV is '63' and 'PA_SEL_TYPE' is '3', 'clk_hf' is used as reference.</description>
              <bitRange>[13:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PA_SEL_TYPE</name>
              <description>Specifies the divider type of the divider to which phase alignment is performed for the clock enable command:
0: 8.0 (integer) clock dividers.
1: 16.0 (integer) clock dividers.
2: 16.5 (fractional) clock dividers.
3: 24.5 (fractional) clock dividers.</description>
              <bitRange>[15:14]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DISABLE</name>
              <description>Clock divider disable command (mutually exlusive with ENABLE). SW sets this field to '1' and HW sets this field to '0'.
 
The SEL_DIV and SEL_TYPE fields specify which divider is to be disabled.
 
The HW sets the DISABLE field to '0' immediately and the HW sets the DIV_XXX_CTL.EN field of the divider to '0' immediately.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ENABLE</name>
              <description>Clock divider enable command (mutually exclusive with DISABLE). Typically, SW sets this field to '1' to enable a divider and HW sets this field to '0' to indicate that divider enabling has completed. When a divider is enabled, its integer and fractional (if present) counters are initialized to '0'. If a divider is to be re-enabled using different integer and fractional divider values, the SW should follow these steps:
0: Disable the divider using the DIV_CMD.DISABLE field.
1: Configure the divider's DIV_XXX_CTL register.
2: Enable the divider using the DIV_CMD_ENABLE field.
 
The SEL_DIV and SEL_TYPE fields specify which divider is to be enabled. The enabled divider may be phase aligned to either 'clk_hf' (typical usage) or to ANY enabled divider.
 
The PA_SEL_DIV and P_SEL_TYPE fields specify the reference divider.
 
The HW sets the ENABLE field to '0' when the enabling is performed and the HW set the DIV_XXX_CTL.EN field of the divider to '1' when the enabling is performed. Note that enabling with phase alignment to a low frequency divider takes time. E.g. To align to a divider that generates a clock of 'clk_hf'/n (with n being the integer divider value INT_DIV+1), up to n cycles may be required to perform alignment. Phase alignment to 'clk_hf' takes affect immediately. SW can set this field to '0' during phase alignment to abort the enabling process.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>64</dim>
          <dimIncrement>4</dimIncrement>
          <name>PCLK_CTL[%s]</name>
          <description>Programmable clock control register</description>
          <addressOffset>0x100</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xFF</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>SEL_DIV</name>
              <description>Specifies one of the dividers of the divider type specified by SEL_TYPE.
 
If SEL_DIV is '63' and 'SEL_TYPE' is '3' (default/reset value), no divider is specified and no clock control signal(s) are generated.
 
When transitioning a clock between two out of phase dividers, spurious clock control signals may be generated for one 'clk_hf' cycle during this transition. These clock control signals may cause a single clock period that is smaller than any of the two divider periods. To prevent these spurious clock signals, the clock multiplexer can be disconnected (SEL_DIV is '63' and 'SEL_TYPE' is '3') for a transition time that is larger than the smaller of the two divider periods.</description>
              <bitRange>[5:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SEL_TYPE</name>
              <description>Specifies divider type:
0: 8.0 (integer) clock dividers.
1: 16.0 (integer) clock dividers.
2: 16.5 (fractional) clock dividers.
3: 24.5 (fractional) clock dividers.</description>
              <bitRange>[7:6]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>64</dim>
          <dimIncrement>4</dimIncrement>
          <name>DIV_8_CTL[%s]</name>
          <description>Divider control register (for 8.0 divider)</description>
          <addressOffset>0x200</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF01</resetMask>
          <fields>
            <field>
              <name>EN</name>
              <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
 
Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>INT8_DIV</name>
              <description>Integer division by (1+INT8_DIV). Allows for integer divisions in the range [1, 256]. Note: this type of divider does NOT allow for a fractional division.
 
For the generation of a divided clock, the integer division range is restricted to [2, 256].
 
For the generation of a 50/50 percent duty cycle digital divided clock, the integer division range is resticited to even numbers in the range [2, 256]. The generation of a 50/50  percent duty cycle analog divided clock has no restrictions.
 
Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
              <bitRange>[15:8]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>64</dim>
          <dimIncrement>4</dimIncrement>
          <name>DIV_16_CTL[%s]</name>
          <description>Divider control register (for 16.0 divider)</description>
          <addressOffset>0x300</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFF01</resetMask>
          <fields>
            <field>
              <name>EN</name>
              <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
 
Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>INT16_DIV</name>
              <description>Integer division by (1+INT16_DIV). Allows for integer divisions in the range [1, 65,536]. Note: this type of divider does NOT allow for a fractional division.
 
For the generation of a divided clock, the integer division range is restricted to [2, 65,536].
 
For the generation of a 50/50 percent duty cycle digital divided clock, the integer division range is restricted to even numbers in the range [2, 65,536]. The generation of a 50/50  percent duty cycle analog divided clock has no restrictions.
 
Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
              <bitRange>[23:8]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>64</dim>
          <dimIncrement>4</dimIncrement>
          <name>DIV_16_5_CTL[%s]</name>
          <description>Divider control register (for 16.5 divider)</description>
          <addressOffset>0x400</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFF9</resetMask>
          <fields>
            <field>
              <name>EN</name>
              <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
 
Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>FRAC5_DIV</name>
              <description>Fractional division by (FRAC5_DIV/32). Allows for fractional divisions in the range [0, 31/32]. Note that fractional division results in clock jitter as some clock periods may be 1 'clk_hf' cycle longer than other clock periods.
 
Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
              <bitRange>[7:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INT16_DIV</name>
              <description>Integer division by (1+INT16_DIV). Allows for integer divisions in the range [1, 65,536]. Note: combined with fractional division, this divider type allows for a division in the range [1, 65,536 31/32] in 1/32 increments.
 
For the generation of a divided clock, the division range is restricted to [2, 65,536 31/32].
 
For the generation of a 50/50 percent duty cycle divided clock, the  division range is restricted to [2, 65,536].
 
Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
              <bitRange>[23:8]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>63</dim>
          <dimIncrement>4</dimIncrement>
          <name>DIV_24_5_CTL[%s]</name>
          <description>Divider control register (for 24.5 divider)</description>
          <addressOffset>0x500</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFF9</resetMask>
          <fields>
            <field>
              <name>EN</name>
              <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
 
Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>FRAC5_DIV</name>
              <description>Fractional division by (FRAC5_DIV/32). Allows for fractional divisions in the range [0, 31/32]. Note that fractional division results in clock jitter as some clock periods may be 1 'clk_hf' cycle longer than other clock periods.
 
Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
              <bitRange>[7:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INT24_DIV</name>
              <description>Integer division by (1+INT24_DIV). Allows for integer divisions in the range [1, 16,777,216]. Note: combined with fractional division, this divider type allows for a division in the range [1, 16,777,216 31/32] in 1/32 increments.
 
For the generation of a divided clock, the integer division range is restricted to [2, 16,777,216 31/32].
 
For the generation of a 50/50 percent duty cycle divided clock, the  division range is restricted to [2, 16,777,216].
 
Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
              <bitRange>[31:8]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TR_CTL</name>
          <description>Trigger control register</description>
          <addressOffset>0x600</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xC0FF0F7F</resetMask>
          <fields>
            <field>
              <name>TR_SEL</name>
              <description>Specifies the activated trigger when TR_ACT is '1'. TR_OUT specifies whether the activated trigger is an input trigger or output trigger to the trigger multiplexer. During activation (TR_ACT is '1'), SW should not modify this register field. If the specified trigger is not present, the trigger activation has no effect.</description>
              <bitRange>[6:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TR_GROUP</name>
              <description>Specifies the trigger group.</description>
              <bitRange>[11:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TR_COUNT</name>
              <description>Amount of cycles a specific trigger is activated. During activation (TR_ACT is '1'), HW decrements this field to '0' using a cycle counter. During activation, SW should not modify this register field. A value of 255 is a special case: HW does NOT decrement this field to '0' and trigger activation is under direct control of TR_ACT: when TR_ACT is '1' the trigger is activated and when TR_ACT is '0' the trigger is deactivated.</description>
              <bitRange>[23:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TR_OUT</name>
              <description>Specifies whether trigger activation is for a specific input or ouput trigger of the trigger multiplexer. Activation of a specific input trigger, will result in activation of all output triggers that have the specific input trigger selected through their TR_OUT_CTL.SEL  field. Activation of a specific output trigger, will result in activation of the specified TR_SEL output trigger only.
'0': TR_SEL selection and trigger activation is for an input trigger to the trigger multiplexer.
'1': TR_SEL selection and trigger activation is for an output trigger from the trigger multiplexer.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TR_ACT</name>
              <description>SW sets this field to '1' by to activate (set to '1') a trigger as identified by TR_SEL and TR_OUT for TR_COUNT cycles. HW sets this field to '0' when the cycle counter is decremented to '0'. Note: a TR_COUNT value of 255 is a special case and trigger activation is under direct control of the TR_ACT field (the counter is not decremented).</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <cluster>
          <name>TR_GROUP</name>
          <description>Peripheral Interconnect trigger group control registers</description>
          <addressOffset>0x00002000</addressOffset>
          <register>
            <dim>128</dim>
            <dimIncrement>4</dimIncrement>
            <name>TR_OUT_CTL[%s]</name>
            <description>Trigger control register</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x7F</resetMask>
            <fields>
              <field>
                <name>SEL</name>
                <description>Specifies input trigger. This field is typically set during the setup of a chip use case scenario. Changing this field while activated triggers are present on the input triggers may result in unpredictable behavior. Note that input trigger 0 (default value) is typically connected to a constant signal level of '0', and as a result will not cause HW activation of the output trigger.</description>
                <bitRange>[6:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
      </registers>
    </peripheral>
    <peripheral>
      <name>HSIOM</name>
      <description>High Speed IO Matrix (HSIOM)</description>
      <baseAddress>0x40020000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>16384</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <cluster>
          <dim>5</dim>
          <dimIncrement>256</dimIncrement>
          <name>PRT[%s]</name>
          <description>HSIOM port registers</description>
          <addressOffset>0x00000000</addressOffset>
          <register>
            <name>PORT_SEL</name>
            <description>Port selection register</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>IO0_SEL</name>
                <description>Selects connection for IO pad 0 route.</description>
                <bitRange>[3:0]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>GPIO</name>
                    <description>SW controlled GPIO.</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>GPIO_DSI</name>
                    <description>SW controlled 'out', DSI controlled 'oe_n'.</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DSI_DSI</name>
                    <description>DSI controlled 'out' and 'oe_n'.</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DSI_GPIO</name>
                    <description>DSI controlled 'out', SW controlled 'oe_n'.</description>
                    <value>3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CSD_SENSE</name>
                    <description>CSD sense connection (analog mode)</description>
                    <value>4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CSD_SHIELD</name>
                    <description>CSD shield connection (analog mode)</description>
                    <value>5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>AMUXA</name>
                    <description>AMUXBUS A connection.</description>
                    <value>6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>AMUXB</name>
                    <description>AMUXBUS B connection. This mode is also used for CSD GPIO charging.  When CSD GPIO charging is enabled in CSD_CONTROL, 'oe_n' is connected to '!csd_charge' signal (and IO pad is also still connected to AMUXBUS B).</description>
                    <value>7</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACT_0</name>
                    <description>Chip specific Active source 0 connection.</description>
                    <value>8</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACT_1</name>
                    <description>Chip specific Active source 1 connection.</description>
                    <value>9</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACT_2</name>
                    <description>Chip specific Active source 2 connection.</description>
                    <value>10</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACT_3</name>
                    <description>Chip specific Active source 3 connection.</description>
                    <value>11</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>LCD_COM</name>
                    <description>LCD common connection. This mode provides DeepSleep functionality  (provided that the LCD block is enabled and properly configured).</description>
                    <value>12</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>LCD_SEG</name>
                    <description>LCD segment connection. This mode provides DeepSleep functionality  (provided that the LCD block is enabled and properly configured).</description>
                    <value>13</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DS_2</name>
                    <description>Chip specific DeepSleep source 2 connection.</description>
                    <value>14</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DS_3</name>
                    <description>Chip specific DeepSleep source 3 connection.</description>
                    <value>15</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>IO1_SEL</name>
                <description>Selects connection for IO pad 1 route.</description>
                <bitRange>[7:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>IO2_SEL</name>
                <description>Selects connection for IO pad 2 route.</description>
                <bitRange>[11:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>IO3_SEL</name>
                <description>Selects connection for IO pad 3 route.</description>
                <bitRange>[15:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>IO4_SEL</name>
                <description>Selects connection for IO pad 4 route.</description>
                <bitRange>[19:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>IO5_SEL</name>
                <description>Selects connection for IO pad 5 route.</description>
                <bitRange>[23:20]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>IO6_SEL</name>
                <description>Selects connection for IO pad 6 route.</description>
                <bitRange>[27:24]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>IO7_SEL</name>
                <description>Selects connection for IO pad 7 route.</description>
                <bitRange>[31:28]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
        <register>
          <name>PUMP_CTL</name>
          <description>Pump control</description>
          <addressOffset>0x2000</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x80000001</resetMask>
          <fields>
            <field>
              <name>CLOCK_SEL</name>
              <description>Clock select:
'0': External clock.
'1': Internal clock (deprecated).</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ENABLED</name>
              <description>Pump enabled:
'0': Disabled.
'1': Enabled.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>8</dim>
          <dimIncrement>4</dimIncrement>
          <name>AMUX_SPLIT_CTL[%s]</name>
          <description>AMUX splitter cell control</description>
          <addressOffset>0x2100</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x77</resetMask>
          <fields>
            <field>
              <name>SWITCH_AA_SL</name>
              <description>T-switch control for Left AMUXBUSA switch:
'0': switch open.
'1': switch closed.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SWITCH_AA_SR</name>
              <description>T-switch control for Right AMUXBUSA switch:
'0': switch open.
'1': switch closed.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SWITCH_AA_S0</name>
              <description>T-switch control for AMUXBUSA vssa/ground switch:
'0': switch open.
'1': switch closed.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SWITCH_BB_SL</name>
              <description>T-switch control for Left AMUXBUSB switch.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SWITCH_BB_SR</name>
              <description>T-switch control for Right AMUXBUSB switch.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SWITCH_BB_S0</name>
              <description>T-switch control for AMUXBUSB vssa/ground switch.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>SRSSLT</name>
      <description>System Resources Lite Subsystem</description>
      <baseAddress>0x40030000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>65536</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>PWR_CONTROL</name>
          <description>Power Mode Control</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x8F003F</resetMask>
          <fields>
            <field>
              <name>POWER_MODE</name>
              <description>Current power mode of the device.  Note that this field cannot be read in all power modes on actual silicon.</description>
              <bitRange>[3:0]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>RESET</name>
                  <description>RESET state</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ACTIVE</name>
                  <description>ACTIVE state</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SLEEP</name>
                  <description>SLEEP state</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DEEP_SLEEP</name>
                  <description>DEEP_SLEEP state</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DEBUG_SESSION</name>
              <description>Indicates whether a debug session is active (CDBGPWRUPREQ signal is 1)</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_SESSION</name>
                  <description>No debug session active</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SESSION_ACTIVE</name>
                  <description>Debug session is active</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>LPM_READY</name>
              <description>Indicates whether the low power mode regulator is ready to enter DEEPSLEEP mode.  
0: If DEEPSLEEP mode is requested, device will enter SLEEP mode.  When low power regulators are ready, device will automatically enter the originally requested mode.
1: Normal operation.  DEEPSLEEP works as described.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>OVER_TEMP_EN</name>
              <description>Enables the die over temperature sensor.  Must be enabled when using the TEMP_HIGH interrupt.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OVER_TEMP_THRESH</name>
              <description>Over-temperature threshold.
0: TEMP_HIGH condition occurs between 120C and 125C.
1: TEMP_HIGH condition occurs between 60C and 75C (used for testing).</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SPARE</name>
              <description>Spare AHB readback bits that are hooked to PWR_PWRSYS_TRIM1.SPARE_TRIM[1:0] through spare logic equivalent to bitwise inversion.  Engineering only.</description>
              <bitRange>[19:18]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>EXT_VCCD</name>
              <description>Always write 0 except as noted below. 

PSoC4-S0 and Streetfighter CapSense products may set this bit if Vccd is provided externally (on Vccd pin).  Setting this bit turns off the active regulator and will lead to system reset (BOD) unless both Vddd and Vccd pins are supplied externally.  This register bit only resets for XRES, POR, or a detected BOD.</description>
              <bitRange>[23:23]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PWR_KEY_DELAY</name>
          <description>Power System Key&amp;Delay Register</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xF8</resetValue>
          <resetMask>0x3FF</resetMask>
          <fields>
            <field>
              <name>WAKEUP_HOLDOFF</name>
              <description>Delay to wait for references to settle on wakeup from deepsleep.  BOD is ignored and system does not resume until this delay expires. Note that the same delay on POR is hard-coded.  The default assumes the output of the predivider is 48MHz + 3 percent.  Firmware may scale this setting according to the fastest actual clock frequency that can occur when waking from DEEPSLEEP.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PWR_DDFT_SELECT</name>
          <description>Power DDFT Mode Selection Register</description>
          <addressOffset>0xC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>DDFT0_SEL</name>
              <description>Select signal for power DDFT output #0</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>WAKEUP</name>
                  <description>wakeup</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AWAKE</name>
                  <description>awake</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ACT_POWER_EN</name>
                  <description>act_power_en</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ACT_POWER_UP</name>
                  <description>act_power_up</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ACT_POWER_GOOD</name>
                  <description>act_power_good</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ACT_REF_EN</name>
                  <description>srss_adft_control_act_ref_en</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ACT_COMP_EN</name>
                  <description>srss_adft_control_act_comp_en</description>
                  <value>6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DPSLP_REF_EN</name>
                  <description>srss_adft_control_dpslp_ref_en</description>
                  <value>7</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DPSLP_REG_EN</name>
                  <description>srss_adft_control_dpslp_reg_en</description>
                  <value>8</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DPSLP_COMP_EN</name>
                  <description>srss_adft_control_dpslp_comp_en</description>
                  <value>9</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>OVER_TEMP_EN</name>
                  <description>pwr_control_over_temp_en</description>
                  <value>10</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SLEEPHOLDREQ_N</name>
                  <description>sleepholdreq_n</description>
                  <value>11</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ADFT_BUF_EN</name>
                  <description>adft_buf_en</description>
                  <value>12</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ATPG_OBSERVE</name>
                  <description>ATPG observe point (no functional purpose)</description>
                  <value>13</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>GND</name>
                  <description>1'b0</description>
                  <value>14</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PWR</name>
                  <description>1'b1</description>
                  <value>15</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DDFT1_SEL</name>
              <description>Select signal for power DDFT output #1</description>
              <bitRange>[7:4]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>WAKEUP</name>
                  <description>wakeup</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AWAKE</name>
                  <description>awake</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ACT_POWER_EN</name>
                  <description>act_power_en</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ACT_POWER_UP</name>
                  <description>act_power_up</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ACT_POWER_GOOD</name>
                  <description>act_power_good</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ACT_REF_VALID</name>
                  <description>act_ref_valid</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ACT_REG_VALID</name>
                  <description>act_reg_valid</description>
                  <value>6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ACT_COMP_OUT</name>
                  <description>act_comp_out</description>
                  <value>7</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ACT_TEMP_HIGH</name>
                  <description>act_temp_high</description>
                  <value>8</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DPSLP_COMP_OUT</name>
                  <description>dpslp_comp_out</description>
                  <value>9</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DPSLP_POWER_UP</name>
                  <description>dpslp_power_up</description>
                  <value>10</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AWAKE_DELAYED</name>
                  <description>awake_delayed</description>
                  <value>11</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LPM_READY</name>
                  <description>lpm_ready</description>
                  <value>12</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SLEEPHOLDACK_N</name>
                  <description>sleepholdack_n</description>
                  <value>13</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>GND</name>
                  <description>1'b0</description>
                  <value>14</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PWR</name>
                  <description>1'b1</description>
                  <value>15</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>TST_MODE</name>
          <description>Test Mode Control Register</description>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xD0000004</resetMask>
          <fields>
            <field>
              <name>SWD_CONNECTED</name>
              <description>0: SWD not active
1: SWD activated (Line Reset &amp; Connect sequence passed)
(Note: this bit replaces TST_CTRL.SWD_CONNECTED and is present in all M0S8 products except TSG4)</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>BLOCK_ALT_XRES</name>
              <description>Relevant only for parts that have the alternate XRES mechanism of overloading a GPIO pin temporarily as alternate XRES during test.  When set, this bit blocks the alternate XRES function, such that the pin can be used for normal I/O or for ddft/adft observation.  See SAS Part-V and Part-IX for details. This register bit only resets for XRES, POR, or a detected BOD.</description>
              <bitRange>[28:28]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TEST_KEY_DFT_EN</name>
              <description>This bit is set when a XRES test mode key is shifted in.  It is the value of the test_key_dft_en signal.  When this bit is set, the BootROM will not yield execution to the FLASH image (same function as setting TEST_MODE bit below).</description>
              <bitRange>[30:30]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>TEST_MODE</name>
              <description>0: Normal operation mode
1: Test mode (any test mode)
Setting this bit will prevent BootROM from yielding execution to Flash image.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CLK_SELECT</name>
          <description>Clock Select Register</description>
          <addressOffset>0x28</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x8</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>HFCLK_SEL</name>
              <description>Selects a source for clk_hf and dsi_in[0].  Note that not all products support all clock sources.  Selecting a clock source that is not supported will result in undefined behavior.</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>IMO</name>
                  <description>IMO - Internal R/C Oscillator</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>EXTCLK</name>
                  <description>EXTCLK - External Clock Pin</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ECO</name>
                  <description>ECO - External-Crystal Oscillator or PLL subsystem output</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>HFCLK_DIV</name>
              <description>Selects clk_hf predivider value.</description>
              <bitRange>[3:2]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_DIV</name>
                  <description>Transparent mode, feed through selected clock source w/o dividing.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIV_BY_2</name>
                  <description>Divide selected clock source by 2</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIV_BY_4</name>
                  <description>Divide selected clock source by 4</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIV_BY_8</name>
                  <description>Divide selected clock source by 8</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PUMP_SEL</name>
              <description>Selects clock source for charge pump clock.  This clock is not guaranteed to be glitch free when changing any of its sources or settings.</description>
              <bitRange>[5:4]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>GND</name>
                  <description>No clock, connect to gnd</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>IMO</name>
                  <description>Use main IMO output</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HFCLK</name>
                  <description>Use clk_hf (using selected source after predivider but before prescaler)</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SYSCLK_DIV</name>
              <description>Select clk_sys prescaler value.</description>
              <bitRange>[7:6]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_DIV</name>
                  <description>clk_sys= clk_hf/1</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIV_BY_2</name>
                  <description>clk_sys= clk_hf/2</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIV_BY_4</name>
                  <description>clk_sys= clk_hf/4</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIV_BY_8</name>
                  <description>clk_sys= clk_hf/8</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>CLK_ILO_CONFIG</name>
          <description>ILO Configuration</description>
          <addressOffset>0x2C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x80000000</resetValue>
          <resetMask>0x80000000</resetMask>
          <fields>
            <field>
              <name>ENABLE</name>
              <description>Master enable for ILO oscillator.  This bit is hardware set whenever the WDT_DISABLE_KEY is not set to the magic value.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CLK_IMO_CONFIG</name>
          <description>IMO Configuration</description>
          <addressOffset>0x30</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x80000000</resetValue>
          <resetMask>0x80000000</resetMask>
          <fields>
            <field>
              <name>ENABLE</name>
              <description>Master enable for IMO oscillator.  Clearing this bit will disable the IMO.  Don't do this if the system is running off it.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CLK_DFT_SELECT</name>
          <description>Clock DFT Mode Selection Register</description>
          <addressOffset>0x34</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x7F7F</resetMask>
          <fields>
            <field>
              <name>DFT_SEL0</name>
              <description>Select signal for DFT output #0</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NC</name>
                  <description>Disabled - output is 0</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ILO</name>
                  <description>clk_ilo: ILO output</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>IMO</name>
                  <description>clk_imo: IMO primary output</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ECO</name>
                  <description>clk_eco: ECO output</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>EXTCLK</name>
                  <description>clk_ext: external clock input</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HFCLK</name>
                  <description>clk_hf: root of the high-speed clock tree</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LFCLK</name>
                  <description>clk_lf:  root of the low-speed clock tree</description>
                  <value>6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SYSCLK</name>
                  <description>clk_sys:  root of the CPU/AHB clock tree (gated version of clk_hf)</description>
                  <value>7</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PUMPCLK</name>
                  <description>clk_pump: clock provided to charge pumps in FLASH and PA</description>
                  <value>8</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SLPCTRLCLK</name>
                  <description>clk_slpctrl:  clock provided to SleepController</description>
                  <value>9</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DFT_DIV0</name>
              <description>DFT Output Divide Down.</description>
              <bitRange>[5:4]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_DIV</name>
                  <description>Direct Output</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIV_BY_2</name>
                  <description>Divide by 2</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIV_BY_4</name>
                  <description>Divide by 4</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIV_BY_8</name>
                  <description>Divide by 8</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DFT_EDGE0</name>
              <description>Edge sensitivity for in-line divider on output #0 (only relevant when DIV0&gt;0).</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>POSEDGE</name>
                  <description>Use posedge for divider</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NEGEDGE</name>
                  <description>Use negedge for divider</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DFT_SEL1</name>
              <description>Select signal for DFT output #1</description>
              <bitRange>[11:8]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NC</name>
                  <description>Disabled - output is 0</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ILO</name>
                  <description>clk_ilo: ILO output</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>IMO</name>
                  <description>clk_imo: IMO primary output</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ECO</name>
                  <description>clk_eco: ECO output</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>EXTCLK</name>
                  <description>clk_ext: external clock input</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HFCLK</name>
                  <description>clk_hf: root of the high-speed clock tree</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LFCLK</name>
                  <description>clk_lf:  root of the low-speed clock tree</description>
                  <value>6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SYSCLK</name>
                  <description>clk_sys:  root of the CPU/AHB clock tree (gated version of clk_hf)</description>
                  <value>7</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PUMPCLK</name>
                  <description>clk_pump: clock provided to charge pumps in FLASH and PA</description>
                  <value>8</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SLPCTRLCLK</name>
                  <description>clk_slpctrl:  clock provided to SleepController</description>
                  <value>9</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DFT_DIV1</name>
              <description>DFT Output Divide Down.</description>
              <bitRange>[13:12]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_DIV</name>
                  <description>Direct Output</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIV_BY_2</name>
                  <description>Divide by 2</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIV_BY_4</name>
                  <description>Divide by 4</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIV_BY_8</name>
                  <description>Divide by 8</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DFT_EDGE1</name>
              <description>Edge sensitivity for in-line divider on output #1 (only relevant when DIV1&gt;0).</description>
              <bitRange>[14:14]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>POSEDGE</name>
                  <description>Use posedge for divider</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NEGEDGE</name>
                  <description>Use negedge for divider</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>WDT_DISABLE_KEY</name>
          <description>Watchdog Disable Key Register</description>
          <addressOffset>0x38</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>KEY</name>
              <description>Disables WDT reset when equal to 0xACED8865.  The WDT reset functions normally for any other setting.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>WDT_COUNTER</name>
          <description>Watchdog Counter Register</description>
          <addressOffset>0x3C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>COUNTER</name>
              <description>Current value of WDT Counter</description>
              <bitRange>[15:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>WDT_MATCH</name>
          <description>Watchdog Match Register</description>
          <addressOffset>0x40</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x1000</resetValue>
          <resetMask>0xFFFFF</resetMask>
          <fields>
            <field>
              <name>MATCH</name>
              <description>Match value for Watchdog counter.  Every time WDT_COUNTER reaches MATCH an interrupt is generated.  Two unserviced interrupts will lead to a system reset (i.e. at the third match).</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>IGNORE_BITS</name>
              <description>The number of MSB bits of the watchdog timer that are NOT checked against MATCH.  This value provides control over the time-to-reset of the watchdog (which happens after 3 successive matches).  Note that certain products may enforce a minimum value for this register through design time configuration.</description>
              <bitRange>[19:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SRSS_INTR</name>
          <description>SRSS Interrupt Register</description>
          <addressOffset>0x44</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3</resetMask>
          <fields>
            <field>
              <name>WDT_MATCH</name>
              <description>WDT Interrupt Request.  This bit is set each time WDT_COUNTR==WDT_MATCH.  Clearing this bit also feeds the watch dog.  Missing 2 interrupts in a row will generate brown-out reset.  Due to internal synchronization, it takes 2 SYSCLK cycles to update after a W1C.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TEMP_HIGH</name>
              <description>Regulator over-temp interrupt.  This interrupt can occur when a short circuit exists on the vccd pin or when extreme loads are applied on IO-cells causing the die to overheat.  Firmware is encourage to shutdown all IO cells and then go to DeepSleep mode when this interrupt occurs if protection against such conditions is desired.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SRSS_INTR_SET</name>
          <description>SRSS Interrupt Set Register</description>
          <addressOffset>0x48</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x2</resetMask>
          <fields>
            <field>
              <name>TEMP_HIGH</name>
              <description>Writing 1 to this bit internally sets the overtemp interrupt.  This can be observed by reading SRSS_INTR.TEMP_HIGH.  This bit always reads back as zero.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SRSS_INTR_MASK</name>
          <description>SRSS Interrupt Mask Register</description>
          <addressOffset>0x4C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3</resetMask>
          <fields>
            <field>
              <name>WDT_MATCH</name>
              <description>Clearing this bit will not forward the interrupt to the CPU.  It will not, however, disable the WDT reset generation on 2 missed interrupts.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TEMP_HIGH</name>
              <description>Masks REG_OVERTEMP interrupt</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RES_CAUSE</name>
          <description>Reset Cause Observation Register</description>
          <addressOffset>0x54</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x19</resetMask>
          <fields>
            <field>
              <name>RESET_WDT</name>
              <description>A WatchDog Timer reset has occurred since last power cycle.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESET_PROT_FAULT</name>
              <description>A protection violation occurred that requires a RESET.  This includes, but is not limited to, hitting a debug breakpoint while in Privileged Mode.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESET_SOFT</name>
              <description>Cortex-M0 requested a system reset through it's SYSRESETREQ.  This can be done via a debugger probe or in firmware.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PWR_BG_TRIM1</name>
          <description>Bandgap Trim Register</description>
          <addressOffset>0xF00</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x10</resetValue>
          <resetMask>0x3F</resetMask>
          <fields>
            <field>
              <name>REF_VTRIM</name>
              <description>Trims the bandgap reference voltage output.  Used to trim the VBG to the voltage where its temperature curvature is minimal.  Bit [5] is unused within the bandgap block.</description>
              <bitRange>[5:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PWR_BG_TRIM2</name>
          <description>Bandgap Trim Register</description>
          <addressOffset>0xF04</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x1C</resetValue>
          <resetMask>0x3F</resetMask>
          <fields>
            <field>
              <name>REF_ITRIM</name>
              <description>Trims the bandgap reference current output.  Used to trim the IBG to the voltage where its temperature curvature is minimal.</description>
              <bitRange>[5:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CLK_IMO_SELECT</name>
          <description>IMO Frequency Select Register</description>
          <addressOffset>0xF08</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x7</resetMask>
          <fields>
            <field>
              <name>FREQ</name>
              <description>Select operating frequency</description>
              <bitRange>[2:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>24_MHZ</name>
                  <description>IMO runs at 24 MHz</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>28_MHZ</name>
                  <description>IMO runs at 28 MHz</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>32_MHZ</name>
                  <description>IMO runs at 32 MHz</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>36_MHZ</name>
                  <description>IMO runs at 36 MHz</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>40_MHZ</name>
                  <description>IMO runs at 40 MHz</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>44_MHZ</name>
                  <description>IMO runs at 44 MHz</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>48_MHZ</name>
                  <description>IMO runs at 48 MHz</description>
                  <value>6</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>CLK_IMO_TRIM1</name>
          <description>IMO Trim Register</description>
          <addressOffset>0xF0C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x80</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>OFFSET</name>
              <description>Frequency trim bits.  These bits are determined at manufacturing time for each FREQ setting (IMO_TRIM2) and stored in SFLASH.  This field is hardware updated during USB osclock mode. This field is mapped to the most significant bits of the IMO trim imo_clk_trim[10:3].  The step size of 1 LSB on this field is approximately 120 kHz.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CLK_IMO_TRIM2</name>
          <description>IMO Trim Register</description>
          <addressOffset>0xF10</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x7</resetMask>
          <fields>
            <field>
              <name>FSOFFSET</name>
              <description>Frequency trim bits.  These bits are not trimmed during manufacturing and kept at 0 under normal operation.  This field is hardware updated during USB osclock mode. This field is mapped to the least significant bits of the IMO trim imo_clk_trim[2:0].  The step size of 1 LSB on this field is approximately 15 kHz.</description>
              <bitRange>[2:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PWR_PWRSYS_TRIM1</name>
          <description>Power System Trim Register</description>
          <addressOffset>0xF14</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>DPSLP_REF_TRIM</name>
              <description>Trims the DeepSleep reference that is used by the DeepSleep regulator and DeepSleep power comparator.</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SPARE_TRIM</name>
              <description>Active-Reference temperature compensation trim (repurposed from spare bits).
Bits [7:6] - trim the Active-Reference IREF temperature coefficient (TC).
  00: TC = 0 (unchanged)
  01: TC = +80ppm/C 
  10: TC = -80ppm/C
  11: TC = -150ppm/C

Bits [5:4] - trim the Active-Reference VREF temperature coefficient (TC).
  00: TC = 0 (unchanged)
  01: TC = -50ppm/C 
  10: TC = -80ppm/C
  11: TC = +150ppm/C</description>
              <bitRange>[7:4]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CLK_IMO_TRIM3</name>
          <description>IMO Trim Register</description>
          <addressOffset>0xF18</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x50</resetValue>
          <resetMask>0x7F</resetMask>
          <fields>
            <field>
              <name>STEPSIZE</name>
              <description>IMO trim stepsize bits.  These bits are determined at manufacturing time to adjust for process variation.  They are used to tune the stepsize of the FSOFFSET and OFFSET trims.</description>
              <bitRange>[4:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TCTRIM</name>
              <description>IMO temperature compesation trim.  These bits are determined at manufacturing time to adjust for temperature dependence. This bits are dependent on frequency and need to be changed using the Cypress provided frequency change algorithm.</description>
              <bitRange>[6:5]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>GPIO</name>
      <description>GPIO port control/configuration</description>
      <baseAddress>0x40040000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>16384</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <cluster>
          <dim>5</dim>
          <dimIncrement>256</dimIncrement>
          <name>PRT[%s]</name>
          <description>GPIO port registers</description>
          <addressOffset>0x00000000</addressOffset>
          <register>
            <name>DR</name>
            <description>Port output data register</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>DATA0</name>
                <description>IO pad 0 output data.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DATA1</name>
                <description>IO pad 1 output data.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DATA2</name>
                <description>IO pad 2 output data.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DATA3</name>
                <description>IO pad 3 output data.</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DATA4</name>
                <description>IO pad 4 output data.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DATA5</name>
                <description>IO pad 5 output data.</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DATA6</name>
                <description>IO pad 6 output data.</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DATA7</name>
                <description>IO pad 7 output data.</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>PS</name>
            <description>Port IO pad state register</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1FF</resetMask>
            <fields>
              <field>
                <name>DATA0</name>
                <description>IO pad 0 state:
1: Logic high, if the pin voltage is above the input buffer threshold, logic high.
0: Logic low, if the pin voltage is below that threshold, logic low.
If the drive mode for the pin is set to high Z Analog, the pin state will read 0 independent of the voltage on the pin.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>DATA1</name>
                <description>IO pad 1 state.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>DATA2</name>
                <description>IO pad 2 state.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>DATA3</name>
                <description>IO pad 3 state.</description>
                <bitRange>[3:3]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>DATA4</name>
                <description>IO pad 4 state.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>DATA5</name>
                <description>IO pad 5 state.</description>
                <bitRange>[5:5]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>DATA6</name>
                <description>IO pad 6 state.</description>
                <bitRange>[6:6]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>DATA7</name>
                <description>IO pad 7 state.</description>
                <bitRange>[7:7]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>FLT_DATA</name>
                <description>Reads of this register return the logical state of the filtered pin.</description>
                <bitRange>[8:8]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>PC</name>
            <description>Port configuration register</description>
            <addressOffset>0x8</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFBFFFFFF</resetMask>
            <fields>
              <field>
                <name>DM0</name>
                <description>The GPIO drive mode for IO pad 0.
Note: when initializing IO's that are connected to a live bus (such as I2C), make sure the HSIOM is properly configured (HSIOM_PRT_SELx) before turning the IO on here to avoid producing glitches on the bus.</description>
                <bitRange>[2:0]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>OFF</name>
                    <description>Mode 0 (analog mode): Output buffer off (high Z). Input buffer off.</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>INPUT</name>
                    <description>Mode 1: Output buffer off (high Z). Input buffer on.</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>0_PU</name>
                    <description>Mode 2: Strong pull down ('0'), weak/resistive pull up (PU). Input buffer on.</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>PD_1</name>
                    <description>Mode 3: Weak/resistive pull down (PD), strong pull up ('1'). Input buffer on.</description>
                    <value>3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>0_Z</name>
                    <description>Mode 4: Strong pull down ('0'), open drain (pull up off). Input buffer on.</description>
                    <value>4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Z_1</name>
                    <description>Mode 5: Open drain (pull down off), strong pull up ('1'). Input buffer on.</description>
                    <value>5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>0_1</name>
                    <description>Mode 6: Strong pull down ('0'), strong pull up ('1'). Input buffer on.</description>
                    <value>6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>PD_PU</name>
                    <description>Mode 7: Weak/resistive pull down (PD), weak/resistive pull up (PU). Input buffer on.</description>
                    <value>7</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DM1</name>
                <description>The GPIO drive mode for IO pad 1.</description>
                <bitRange>[5:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DM2</name>
                <description>The GPIO drive mode for IO pad 2.</description>
                <bitRange>[8:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DM3</name>
                <description>The GPIO drive mode for IO pad 3.</description>
                <bitRange>[11:9]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DM4</name>
                <description>The GPIO drive mode for IO pad 4.</description>
                <bitRange>[14:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DM5</name>
                <description>The GPIO drive mode for IO pad 5.</description>
                <bitRange>[17:15]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DM6</name>
                <description>The GPIO drive mode for IO pad 6.</description>
                <bitRange>[20:18]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DM7</name>
                <description>The GPIO drive mode for IO pad 7.</description>
                <bitRange>[23:21]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PORT_VTRIP_SEL</name>
                <description>The GPIO cells include a VTRIP_SEL signal to alter the input buffer voltage. Note: this bit is ignored for SIO ports, the VTRIP_SEL settings in the SIO register are used instead (a separate VTRIP_SEL is provided for each pin pair).
0: input buffer functions as a CMOS input buffer.
1: input buffer functions as a LVTTL input buffer.</description>
                <bitRange>[24:24]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PORT_SLOW</name>
                <description>This field controls the output edge rate of all pins on the port:
'0': fast.
'1': slow.</description>
                <bitRange>[25:25]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PORT_HYST_TRIM</name>
                <description>This field is used to improve the hysteresis (to 10 percent of vddio) of the selectable trip point input buffer. The voltage reference comes from the VREFGEN block and is only available when using the VREFGEN block:
'0': &lt;= 2.2 V input signaling Voltage.
'1': &gt; 2.2 V input signaling Voltage.</description>
                <bitRange>[27:27]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PORT_SLEW_CTL</name>
                <description>Slew control. Only used in the O_Z drive mode (mode 4: strong pull down, open drain): This field is intended for I2C functionality. See BROS 001-70428 for more details.</description>
                <bitRange>[29:28]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>PORT_SLEW_CTL_0</name>
                    <description>HS mode (100pf &lt; Cb &lt; 400pF, 1.71&lt;VDDD&lt;5.5, Vext&gt;3.0)
FS mode (10pf&lt;Cb&lt;400pf,1.71&lt;VDDD&lt;5.5) (20-160ns)</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>PORT_SLEW_CTL_1</name>
                    <description>HS mode (Cb&lt;100pf,1.71&lt;VDDD&lt;5.5,Vext&gt;2.8,F=1.7MHz) (10-80ns)
FS+ Mode (Vext&gt;2.8,1.71&lt;VDDD&lt;5.5) (20-120ns)</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>PORT_SLEW_CTL_2</name>
                    <description>HS mode (100pf&lt;Cb&lt;400pf, 1.71&lt;VDDD&lt;5.5,Vext&lt;3.3) (20-160ns)</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>PORT_SLEW_CTL_3</name>
                    <description>HS mode (Cb&lt;100pf,1.71&lt;VDDD&lt;5.5,Vext&lt;=2.8,F=1.7MHz) (10-80ns)
FS+ mode (Vext&lt;=2.8,1.71&lt;VDDD&lt;5.5) (20-120ns)</description>
                    <value>3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PORT_IB_MODE_SEL</name>
                <description>This field selects the input buffer reference. The size (1 or 2 bits) and functionality is dependent on the IO cell.
For GPIOv2 IO cells, bit PORT_IB_MODE_SEL[1] is not used (GPIOv2 IO cell replaces GPIO IO cell):
'0'/'2': CMOS input buffer (PORT_VTRIP_SEL is '0'), LVTTL input buffer (PORT_VTRIP_SEL is '1')
'1'/'3': vcchib.
For GPIO_OVTv2 and SIOv2 IO cells:
'0': CMOS input buffer (PORT_VTRIP_SEL is '0'), LVTTL input buffer (PORT_VTRIP_SEL is '1')
'1': vcchib.
'2': OVT.
'3': Reference (possibly from reference generator cell).
For SIO IO cell, this field is present but not used as the SIO IO cell does not provide input buffer mode select functionality (SIOv2 IO cell will replace SIO IO cell, as soon as it is available).</description>
                <bitRange>[31:30]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_CFG</name>
            <description>Port interrupt configuration register</description>
            <addressOffset>0xC</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1FFFFF</resetMask>
            <fields>
              <field>
                <name>EDGE0_SEL</name>
                <description>Sets which edge will trigger an IRQ for IO pad 0.</description>
                <bitRange>[1:0]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>DISABLE</name>
                    <description>Disabled</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>RISING</name>
                    <description>Rising edge</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>FALLING</name>
                    <description>Falling edge</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>BOTH</name>
                    <description>Both rising and falling edges</description>
                    <value>3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>EDGE1_SEL</name>
                <description>Sets which edge will trigger an IRQ for IO pad 1.</description>
                <bitRange>[3:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EDGE2_SEL</name>
                <description>Sets which edge will trigger an IRQ for IO pad 2.</description>
                <bitRange>[5:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EDGE3_SEL</name>
                <description>Sets which edge will trigger an IRQ for IO pad 3.</description>
                <bitRange>[7:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EDGE4_SEL</name>
                <description>Sets which edge will trigger an IRQ for IO pad 4.</description>
                <bitRange>[9:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EDGE5_SEL</name>
                <description>Sets which edge will trigger an IRQ for IO pad 5.</description>
                <bitRange>[11:10]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EDGE6_SEL</name>
                <description>Sets which edge will trigger an IRQ for IO pad 6.</description>
                <bitRange>[13:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EDGE7_SEL</name>
                <description>Sets which edge will trigger an IRQ for IO pad 7.</description>
                <bitRange>[15:14]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>FLT_EDGE_SEL</name>
                <description>Same for the glitch filtered pin (selected by FLT_SELECT).</description>
                <bitRange>[17:16]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>DISABLE</name>
                    <description>Disabled</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>RISING</name>
                    <description>Rising edge</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>FALLING</name>
                    <description>Falling edge</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>BOTH</name>
                    <description>Both rising and falling edges</description>
                    <value>3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>FLT_SEL</name>
                <description>Selects which pin is routed through the 50ns glitch filter to provide a glitch-safe interrupt.</description>
                <bitRange>[20:18]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR</name>
            <description>Port interrupt status register</description>
            <addressOffset>0x10</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1FF01FF</resetMask>
            <fields>
              <field>
                <name>DATA0</name>
                <description>Interrupt pending on IO pad 0. Firmware writes 1 to clear the interrupt.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DATA1</name>
                <description>Interrupt pending on IO pad 1. Firmware writes 1 to clear the interrupt.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DATA2</name>
                <description>Interrupt pending on IO pad 2. Firmware writes 1 to clear the interrupt.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DATA3</name>
                <description>Interrupt pending on IO pad 3. Firmware writes 1 to clear the interrupt.</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DATA4</name>
                <description>Interrupt pending on IO pad 4. Firmware writes 1 to clear the interrupt.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DATA5</name>
                <description>Interrupt pending on IO pad 5. Firmware writes 1 to clear the interrupt.</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DATA6</name>
                <description>Interrupt pending on IO pad 6. Firmware writes 1 to clear the interrupt.</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DATA7</name>
                <description>Interrupt pending on IO pad 7. Firmware writes 1 to clear the interrupt.</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>FLT_DATA</name>
                <description>Deglitched interrupt pending (selected by FLT_SELECT).</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PS_DATA0</name>
                <description>`</description>
                <bitRange>[16:16]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PS_DATA1</name>
                <description>N/A</description>
                <bitRange>[17:17]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PS_DATA2</name>
                <description>N/A</description>
                <bitRange>[18:18]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PS_DATA3</name>
                <description>N/A</description>
                <bitRange>[19:19]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PS_DATA4</name>
                <description>N/A</description>
                <bitRange>[20:20]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PS_DATA5</name>
                <description>N/A</description>
                <bitRange>[21:21]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PS_DATA6</name>
                <description>N/A</description>
                <bitRange>[22:22]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PS_DATA7</name>
                <description>N/A</description>
                <bitRange>[23:23]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PS_FLT_DATA</name>
                <description>This is a duplicate of the contents of the PS register, provided here to allow reading of both pin state and interrupt state of the port in a single read operation.</description>
                <bitRange>[24:24]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SIO</name>
            <description>Port SIO configuration register</description>
            <addressOffset>0x14</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>PAIR_VREG01_EN</name>
                <description>Selects output buffer mode:
0: unregulated output buffer
1: regulated output buffer</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PAIR_IBUF01_SEL</name>
                <description>Selects input buffer mode:
0: singled ended input buffer
1: differential input buffer</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PAIR_VTRIP01_SEL</name>
                <description>Selects trip-point of input buffer. In single ended input buffer mode (IBUF01_SEL = '0'):
0: input buffer functions as a CMOS input buffer.
1: input buffer functions as a LVTTL input buffer.
In differential input buffer mode (IBUF01_SEL = '1')
'0': trip-point is 0.5*Vddio or 0.5*Voh (depends on VREF_SEL/VOH_SEL)
'1': trip-point is 0.4*Vddio or 1.0*Vref  (depends on VREF_SEL)

Please refer to s8iom0s8 BROS 001-70428, section 4.2.7  for more details.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PAIR_VREF01_SEL</name>
                <description>Selects reference voltage Vref for trip-point of input buffer:
0: trip-point reference of SRSS internal referece Vref (1.2V)
1: trip-point reference of SRSS internal referece Vref (1.2V)
2: trip-point reference of AMUXBUS_A
3: trip-point reference of AMUXBUS_B

Please refer to s8iom0s8 BROS 001-70428, section 4.2.7 for more details.</description>
                <bitRange>[4:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PAIR_VOH01_SEL</name>
                <description>Selects regulated Voh output level and trip point of input buffer for a specific SIO pin pair. Voh depends on the selected reference voltage (VREF_SEL). 
0: Voh = 1*reference; e.g. reference at 1.2V -&gt; Voh = 1.2V 
1: Voh = 1.25*reference; e.g. reference at 1.2V -&gt; Voh = 1.5V
2: Voh = 1.49*reference; e.g. reference at 1.2V -&gt; Voh = ~1.8V
3: Voh = 1.67*reference; e.g. reference at 1.2V -&gt; Voh = 2V
4: Voh = 2.08*reference; e.g. reference at 1.2V -&gt; Voh = 2.5V
5: Voh = 2.5*reference; e.g. reference at 1.2V -&gt; Voh = 3V
6: Voh = 2.78*reference; e.g. reference at 1.2V -&gt; Voh = ~3.3V
7: Voh = 4.16*reference; e.g. reference at 1.2V -&gt; Voh = 5.0V
Note: The upper value on VOH is limited to Vddio - 400mV</description>
                <bitRange>[7:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PAIR_VREG23_EN</name>
                <description>See corresponding definition for IO pads 2 and 3.</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PAIR_IBUF23_SEL</name>
                <description>See corresponding definition for IO pads 2 and 3.</description>
                <bitRange>[9:9]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PAIR_VTRIP23_SEL</name>
                <description>See corresponding definition for IO pads 2 and 3.</description>
                <bitRange>[10:10]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PAIR_VREF23_SEL</name>
                <description>See corresponding definition for IO pads 2 and 3.</description>
                <bitRange>[12:11]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PAIR_VOH23_SEL</name>
                <description>See corresponding definition for IO pads 2 and 3.</description>
                <bitRange>[15:13]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PAIR_VREG45_EN</name>
                <description>See corresponding definition for IO pads 4 and 5.</description>
                <bitRange>[16:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PAIR_IBUF45_SEL</name>
                <description>See corresponding definition for IO pads 4 and 5.</description>
                <bitRange>[17:17]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PAIR_VTRIP45_SEL</name>
                <description>See corresponding definition for IO pads 4 and 5.</description>
                <bitRange>[18:18]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PAIR_VREF45_SEL</name>
                <description>See corresponding definition for IO pads 4 and 5.</description>
                <bitRange>[20:19]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PAIR_VOH45_SEL</name>
                <description>See corresponding definition for IO pads 4 and 5.</description>
                <bitRange>[23:21]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PAIR_VREG67_EN</name>
                <description>See corresponding definition for IO pads 6 and 7.</description>
                <bitRange>[24:24]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PAIR_IBUF67_SEL</name>
                <description>See corresponding definition for IO pads 6 and 7.</description>
                <bitRange>[25:25]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PAIR_VTRIP67_SEL</name>
                <description>See corresponding definition for IO pads 6 and 7.</description>
                <bitRange>[26:26]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PAIR_VREF67_SEL</name>
                <description>See corresponding definition for IO pads 6 and 7.</description>
                <bitRange>[28:27]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PAIR_VOH67_SEL</name>
                <description>See corresponding definition for IO pads 6 and 7.</description>
                <bitRange>[31:29]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>PC2</name>
            <description>Port configuration register 2</description>
            <addressOffset>0x18</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>INP_DIS0</name>
                <description>Disables the input buffer for IO pad 0 independent of the port control drive mode (PC.DM). This bit should be set when analog signals are present on the pin and PC.DM != 0 is required to use the output driver.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>INP_DIS1</name>
                <description>Disables the input buffer for IO pad 1.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>INP_DIS2</name>
                <description>Disables the input buffer for IO pad 2.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>INP_DIS3</name>
                <description>Disables the input buffer for IO pad 3.</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>INP_DIS4</name>
                <description>Disables the input buffer for IO pad 4.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>INP_DIS5</name>
                <description>Disables the input buffer for IO pad 5.</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>INP_DIS6</name>
                <description>Disables the input buffer for IO pad 6.</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>INP_DIS7</name>
                <description>Disables the input buffer for IO pad 7.</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DR_SET</name>
            <description>Port output data set register</description>
            <addressOffset>0x40</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>DATA</name>
                <description>IO pad i:
'0': Output state DR.DATA[i] not affected.
'1': Output state DR.DATA[i] set to '1'.</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DR_CLR</name>
            <description>Port output data clear register</description>
            <addressOffset>0x44</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>DATA</name>
                <description>IO pad i:
'0': Output state DR.DATA[i] not affected.
'1': Output state DR.DATA[i] set to '0'.</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DR_INV</name>
            <description>Port output data invert register</description>
            <addressOffset>0x48</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>DATA</name>
                <description>IO pad i:
'0': Output state DR.DATA[i] not affected.
'1': Output state DR.DATA[i] inverted ('0' =&gt; '1', '1' =&gt; '0').</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>VREFGEN</name>
            <description>Reference generator configuration register</description>
            <addressOffset>0x80</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x11F</resetMask>
            <fields>
              <field>
                <name>REF_SEL</name>
                <description>Reference selection. A reference Voltage vinref is created using a Voltage vddio:
'0': vinref = (0 * 13 + 184)/600 * vddio = 184/600 * vddio.
'1': vinref = (1 * 13 + 184)/600 * vddio = 197/600 * vddio.
'2': vinref = (2 * 13 + 184)/600 * vddio = 210/600 * vddio.
...
'31': vinref = (31 * 13 + 184)/600 * vddio = 587/600 * vddio.</description>
                <bitRange>[4:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VREFGEN_EN</name>
                <description>Reference generator enable:
'0': Disabled.
'1': Enabled.</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
        <register>
          <name>INTR_CAUSE</name>
          <description>Interrupt port cause register</description>
          <addressOffset>0x1000</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PORT_INT</name>
              <description>Each IO port has an associated bit field in this register. The bit field reflects the IO port's interrupt line (bit field i reflects 'gpio_interrupts[i]' for IO port i). The register is used when the system uses a shared/combined interrupt line 'gpio_interrupt'. The SW ISR reads the register to deternine which IO port(s) is responsible for the shared/combined interrupt line 'gpio_interrupt'. Once, the IO port(s) is determined, the IO port's INTR register is read to determine the IO pad(s) in the IO port that caused the interrupt.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>PRGIO</name>
      <description>Programmable IO configuration</description>
      <baseAddress>0x40050000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>4096</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <cluster>
          <dim>2</dim>
          <dimIncrement>256</dimIncrement>
          <name>PRT[%s]</name>
          <description>Programmable IO port registers</description>
          <addressOffset>0x00000000</addressOffset>
          <register>
            <name>CTL</name>
            <description>Control register</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x2001400</resetValue>
            <resetMask>0x82001F00</resetMask>
            <fields>
              <field>
                <name>BYPASS</name>
                <description>Bypass of the programmable IO, one bit for each IO pin: BYPASS[i] is for IO pin i. When ENABLED is '1', this field is used. When ENABLED is '0', this field is NOT used and PRGIO is always bypassed.
'0': No bypass (programmable IO fabric is exposed). 
'1': Bypass (programmable IO fabric is hidden).</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CLOCK_SRC</name>
                <description>Clock ('clk_fabric') and reset ('rst_fabric_n') source selection:
'0': io_data_in[0]/'1'.
...
'7': io_data_in[7]/'1'.
'8': chip_data[0]/'1'.
...
'15': chip_data[7]/'1'.
'16': clk_prgio/rst_sys_act_n. Used for both Active functionality synchronous logic on 'clk_prgio'. This selection is intended for synchronous operation on a PCLK specified clock frequency ('clock_prgio_en'). Note that the fabric's clocked elements are frequency aligned, but NOT phase aligned to 'clk_sys'. 
'17': clk_prgio/rst_sys_dpslp_n. Used for both DeepSleep functionality synchronous logic on 'clk_prgio' (note that 'clk_prgio' is NOT available in DeepSleep and Hibernate power modes).  This selection is intended for synchronous operation on a PCLK specified clock frequency ('clock_prgio_en'). Note that the fabric's clocked elements are frequency aligned, but NOT phase aligned to 'clk_sys'. 
'18': clk_prgio/rst_sys_hib_n. Used for both Hibernate functionality synchronous logic on 'clk_prgio' (note that 'clk_prgio' is NOT available in DeepSleep and Hibernate power modes).  This selection is intended for synchronous operation on a PCLK specified clock frequency ('clock_prgio_en'). Note that the fabric's clocked elements are frequency aligned, but NOT phase aligned to 'clk_sys'. 
'19': clk_lf/rst_lf_dpslp_n (note that 'clk_lf' is only available in DeepSleep power mode). This selection is intended for synchronous operation on'clk_lf'. Note that the fabric's clocked elements are frequency aligned, but NOT phase aligned to other 'clk_lf' clocked elements.
'20'-'30': Clock source is constant '0'. Any of these clock sources should be selected when the IP is disabled to ensure low power consumption.
'31': clk_sys/'1'. This selection is NOT intended for 'clk_sys' operation, but for asynchronous operation: three 'clk_sys' cycles after enabling the IP, the IP is fully functional (reset is de-activated). To be used for asynchronous (clockless) fabric functionality.</description>
                <bitRange>[12:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>HLD_OVR</name>
                <description>IO cell hold override functionality. In DeepSleep and Hibernate power modes, the HSIOM holds the IO cell output and output enable signals if Active functionality is connected to the IO pads. This is undesirable if the PRGIO is supposed to deliver DeepSleep or Hibernate output functionality on these IO pads. This field is used to control the hold override functionality from the PRGIO:
'0': The HSIOM controls the IO cell hold override functionality ('hsiom_hld_ovr').
'1': The PRGIO controls the IO cel hold override functionality:
- In bypass mode (ENABLED is '0' or BYPASS[i] is '1'), the HSIOM control is used.
- In NON bypass mode (ENABLED is '1' and BYPASS[i] is '0'), the PRGIO sets hold override to 'pwr_hld_ovr_hib' to enable PRGIO functionality in DeepSleep and Hibernate power modes (but disables it in Stop power mode).

Note that in Hibernate power mode, the PRGIO should not rely on the state of Active or DeepSleep functionality signals from the HSIOM: these signals are clamped to '0' in Hibernate'</description>
                <bitRange>[24:24]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PIPELINE_EN</name>
                <description>Enable for pipeline register:
'0': Disabled (register is bypassed).
'1': Enabled.</description>
                <bitRange>[25:25]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ENABLED</name>
                <description>Enable for programmable IO. Should only be set to '1' when the programmable IO is completely configured:
'0': Disabled (signals are bypassed; behavior as if BYPASS is 0xFF). When disabled, the fabric (data unit and LUTs) reset is activated.

If the IP is disabled:
- The PIPELINE_EN register field should be set to '1', to ensure low power consumption by preventing combinatorial loops.
- The CLOCK_SRC register field should be set to '20'-'30' (clock is constant '0'), to ensure low power consumption.

'1': Enabled. Once enabled, it takes 3 'clk_fabric' clock cycles till the fabric reset is de-activated and the fabric becomes fully functional. This ensures that the IO pins' input synchronizer states are flushed when the fabric is fully functional.</description>
                <bitRange>[31:31]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SYNC_CTL</name>
            <description>Synchronization control register</description>
            <addressOffset>0x10</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>IO_SYNC_EN</name>
                <description>Synchronization of the IO pin input signals to 'clk_fabric', one bit for each IO pin: IO_SYNC_EN[i] is for IO pin i.
'0': No synchronization.
'1': Synchronization.</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CHIP_SYNC_EN</name>
                <description>Synchronization of the chip input signals to 'clk_fabric', one bit for each input: CHIP_SYNC_EN[i] is for input i.
'0': No synchronization.
'1': Synchronization.</description>
                <bitRange>[15:8]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <dim>8</dim>
            <dimIncrement>4</dimIncrement>
            <name>LUT_SEL[%s]</name>
            <description>LUT component input selection</description>
            <addressOffset>0x20</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>LUT_TR0_SEL</name>
                <description>LUT input signal 'tr0_in' source selection:
'0': Data unit output.
'1': LUT 1 output.
'2': LUT 2 output.
'3': LUT 3 output.
'4': LUT 4 output.
'5': LUT 5 output.
'6': LUT 6 output.
'7': LUT 7 output.
'8': chip_data[0] (for LUTs 0, 1, 2, 3); chip_data[4] (for LUTs 4, 5, 6, 7).
'9': chip_data[1] (for LUTs 0, 1, 2, 3); chip_data[5] (for LUTs 4, 5, 6, 7).
'10': chip_data[2] (for LUTs 0, 1, 2, 3); chip_data[6] (for LUTs 4, 5, 6, 7).
'11': chip_data[3] (for LUTs 0, 1, 2, 3); chip_data[7] (for LUTs 4, 5, 6, 7).
'12': io_data_in[0] (for LUTs 0, 1, 2, 3); io_data_in[4] (for LUTs 4, 5, 6, 7).
'13': io_data_in[1] (for LUTs 0, 1, 2, 3); io_data_in[5] (for LUTs 4, 5, 6, 7).
'14': io_data_in[2] (for LUTs 0, 1, 2, 3); io_data_in[6] (for LUTs 4, 5, 6, 7).
'15': io_data_in[3] (for LUTs 0, 1, 2, 3); io_data_in[7] (for LUTs 4, 5, 6, 7).</description>
                <bitRange>[3:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>LUT_TR1_SEL</name>
                <description>LUT input signal 'tr1_in' source selection:
'0': LUT 0 output.
'1': LUT 1 output.
'2': LUT 2 output.
'3': LUT 3 output.
'4': LUT 4 output.
'5': LUT 5 output.
'6': LUT 6 output.
'7': LUT 7 output.
'8': chip_data[0] (for LUTs 0, 1, 2, 3); chip_data[4] (for LUTs 4, 5, 6, 7).
'9': chip_data[1] (for LUTs 0, 1, 2, 3); chip_data[5] (for LUTs 4, 5, 6, 7).
'10': chip_data[2] (for LUTs 0, 1, 2, 3); chip_data[6] (for LUTs 4, 5, 6, 7).
'11': chip_data[3] (for LUTs 0, 1, 2, 3); chip_data[7] (for LUTs 4, 5, 6, 7).
'12': io_data_in[0] (for LUTs 0, 1, 2, 3); io_data_in[4] (for LUTs 4, 5, 6, 7).
'13': io_data_in[1] (for LUTs 0, 1, 2, 3); io_data_in[5] (for LUTs 4, 5, 6, 7).
'14': io_data_in[2] (for LUTs 0, 1, 2, 3); io_data_in[6] (for LUTs 4, 5, 6, 7).
'15': io_data_in[3] (for LUTs 0, 1, 2, 3); io_data_in[7] (for LUTs 4, 5, 6, 7).</description>
                <bitRange>[11:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>LUT_TR2_SEL</name>
                <description>LUT input signal 'tr2_in' source selection. Encoding is the same as for LUT_TR1_SEL.</description>
                <bitRange>[19:16]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <dim>8</dim>
            <dimIncrement>4</dimIncrement>
            <name>LUT_CTL[%s]</name>
            <description>LUT component control register</description>
            <addressOffset>0x40</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>LUT</name>
                <description>LUT configuration. Depending on the LUT opcode LUT_OPC, the internal state lut_reg (captured in a flip-flop) and the LUT input signals tr0_in, tr1_in, tr2_in, the LUT configuration is used to determine the LUT output signal and the next sequential state (lut_reg).</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>LUT_OPC</name>
                <description>LUT opcode specifies the LUT operation:
'0': Combinatoral output, no feedback.
   tr_out   = LUT[{tr2_in, tr1_in, tr0_in}].
'1': Combinatorial output, feedback.
   tr_out   = LUT[{lut_reg, tr1_in, tr0_in}].
On clock:
    lut_reg &lt;= tr_in2.
'2': Sequential output, no feedback.
   temp    = LUT[{tr2_in, tr1_in, tr0_in}].
   tr_out   = lut_reg.
On clock:
   lut_reg &lt;= temp.
'3': Register with asynchronous set and reset.
   tr_out           = lut_reg.
   enable          = (tr2_in ^ LUT[4]) | LUT[5].
   set               = enable &amp; (tr1_in ^ LUT[2]) &amp; LUT[3].
   clr                = enable &amp; (tr0_in ^ LUT[0]) &amp; LUT[1].
Asynchronously (no clock required):
   lut_reg         &lt;= if (clr) '0' else if (set) '1'</description>
                <bitRange>[9:8]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DU_SEL</name>
            <description>Data unit component input selection</description>
            <addressOffset>0xC0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>DU_TR0_SEL</name>
                <description>Data unit input signal 'tr0_in' source selection:
'0': Constant '0'.
'1': Constant '1'.
'2': Data unit output.
'10-3': LUT 7 - 0 outputs.
Otherwise: Undefined.</description>
                <bitRange>[3:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DU_TR1_SEL</name>
                <description>Data unit input signal 'tr1_in' source selection. Encoding is the same as for DU_TR0_SEL.</description>
                <bitRange>[11:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DU_TR2_SEL</name>
                <description>Data unit input signal 'tr2_in' source selection. Encoding is the same as for DU_TR0_SEL.</description>
                <bitRange>[19:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DU_DATA0_SEL</name>
                <description>Data unit input data 'data0_in' source selection:
'0': Constant '0'.
'1': chip_data[7:0].
'2': io_data_in[7:0].
'3': DATA.DATA MMIO register field.</description>
                <bitRange>[25:24]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DU_DATA1_SEL</name>
                <description>Data unit input data 'data1_in' source selection. Encoding is the same as for DU_DATA0_SEL.</description>
                <bitRange>[29:28]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DU_CTL</name>
            <description>Data unit component control register</description>
            <addressOffset>0xC4</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>DU_SIZE</name>
                <description>Size/width of the data unit data operands (in bits) is DU_SIZE+1. E.g., if DU_SIZE is 7, the width is 8 bits.</description>
                <bitRange>[2:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DU_OPC</name>
                <description>Data unit opcode specifies the data unit operation:
'1': INCR
'2': DECR
'3': INCR_WRAP
'4': DECR_WRAP
'5': INCR_DECR
'6': INCR_DECR_WRAP
'7': ROR
'8': SHR
'9': AND_OR
'10': SHR_MAJ3
'11': SHR_EQL.
Otherwise: Undefined.</description>
                <bitRange>[11:8]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DATA</name>
            <description>Data register</description>
            <addressOffset>0xF0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>DATA</name>
                <description>Data unit input data source.</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
      </registers>
    </peripheral>
    <peripheral>
      <name>TCPWM</name>
      <description>Timer/Counter/PWM</description>
      <baseAddress>0x40060000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>65536</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>CTRL</name>
          <description>TCPWM control register 0.</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>COUNTER_ENABLED</name>
              <description>Counter enables for counters 0 up to CNT_NR-1.
'0': counter disabled.
'1': counter enabled.
Counter static configuration information (e.g. CTRL.MODE, all TR_CTRL0, TR_CTRL1, and TR_CTRL2 register fields) should only be modified when the counter is disabled. When a counter is disabled, command and status information associated to the counter is cleared by HW, this includes:
- the associated counter triggers in the CMD register are set to '0'.
- the counter's interrupt cause fields in counter's INTR register.
- the counter's status fields in counter's STATUS register..
- the counter's trigger outputs ('tr_overflow', 'tr_underflow' and 'tr_compare_match').
- the counter's line outputs ('line_out' and 'line_compl_out').</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CMD</name>
          <description>TCPWM command register.</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>COUNTER_CAPTURE</name>
              <description>Counters SW capture trigger. When written with '1', a capture trigger is generated and the HW sets the field to '0' when the SW trigger has taken effect. It should be noted that the HW operates on the counter frequency. If the counter is disabled through CTRL.COUNTER_ENABLED, the field is immediately set to '0'.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>COUNTER_RELOAD</name>
              <description>Counters SW reload trigger. For HW behavior, see COUNTER_CAPTURE field.</description>
              <bitRange>[15:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>COUNTER_STOP</name>
              <description>Counters SW stop trigger. For HW behavior, see COUNTER_CAPTURE field.</description>
              <bitRange>[23:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>COUNTER_START</name>
              <description>Counters SW start trigger. For HW behavior, see COUNTER_CAPTURE field.</description>
              <bitRange>[31:24]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_CAUSE</name>
          <description>TCPWM Counter interrupt cause register.</description>
          <addressOffset>0xC</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>COUNTER_INT</name>
              <description>Counters interrupt signal active. If the counter is disabled through CTRL.COUNTER_ENABLED, the associated interrupt field is immediately set to '0'.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <cluster>
          <dim>5</dim>
          <dimIncrement>64</dimIncrement>
          <name>CNT[%s]</name>
          <description>Timer/Counter/PWM Counter Module</description>
          <addressOffset>0x00000100</addressOffset>
          <register>
            <name>CTRL</name>
            <description>Counter control register</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x737FF0F</resetMask>
            <fields>
              <field>
                <name>AUTO_RELOAD_CC</name>
                <description>Specifies switching of the CC and buffered CC values. This field has a function in TIMER, PWM, PWM_DT and PWM_PR modes.
Timer mode:
'0': never switch.
'1': switch on a compare match event.
PWM, PWM_DT, PWM_PR modes: 
'0: never switch.
'1': switch on a terminal count event with an actively pending switch event.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>AUTO_RELOAD_PERIOD</name>
                <description>Specifies switching of the PERIOD and buffered PERIOD values. This field has a function in PWM, PWM_DT and PWM_PR modes.
'0': never switch.
'1': switch on a terminal count event with and actively pending siwtch event.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PWM_SYNC_KILL</name>
                <description>Specifies asynchronous/synchronous kill behavior:
'1': synchronous kill mode: the kill event disables the 'dt_line_out' and 'dt_line_compl_out' signals till the next terminal count event (synchronous kill). In synchronous kill mode, STOP_EDGE should  be RISING_EDGE.
'0': asynchronous kill mode: the kill event only disables the 'dt_line_out' and 'dt_line_compl_out' signals when present. In asynchronous kill mode, STOP_EDGE should be NO_EDGE_DET. 

This field has a function in PWM and PWM_DT modes only. This field is only used when PWM_STOP_ON_KILL is '0'.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PWM_STOP_ON_KILL</name>
                <description>Specifies whether the counter stops on a kill events:
'0': kill event does NOT stop counter.
'1': kill event stops counter.

This field has a function in PWM, PWM_DT and PWM_PR modes only.</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>GENERIC</name>
                <description>Generic 8-bit control field. In PWM_DT mode, this field is used to determine the dead time: amount of dead time cycles in the counter clock domain. In all other modes, the lower 3 bits of this field determine pre-scaling of the selected counter clock.</description>
                <bitRange>[15:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>UP_DOWN_MODE</name>
                <description>Determines counter direction.</description>
                <bitRange>[17:16]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>COUNT_UP</name>
                    <description>Count up (to PERIOD). An overflow event is generated when the counter reaches PERIOD. A terminal count event is generated when the counter reaches PERIOD.</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>COUNT_DOWN</name>
                    <description>Count down (to '0'). An underflow event is generated when the counter reaches '0'. A terminal count event is generated when the counter reaches '0'.</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>COUNT_UPDN1</name>
                    <description>Count up (to PERIOD), then count down (to '0'). An overflow event is generated when the counter reaches PERIOD. An underflow event is generated when the counter reaches '0'. A terminal count event is generated when the counter reaches '0'.</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>COUNT_UPDN2</name>
                    <description>Count up (to PERIOD), then count down (to '0'). An overflow event is generated when the counter reaches PERIOD. An underflow event is generated when the counter reaches '0'. A terminal count event is generated when the counter reaches '0' AND when the counter reaches PERIOD (this counter direction can be used for PWM functionality with asymmetrical updates).</description>
                    <value>3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>ONE_SHOT</name>
                <description>When '0', counter runs continuous. When '1', counter is turned off by hardware when a terminal count event is generated.</description>
                <bitRange>[18:18]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>QUADRATURE_MODE</name>
                <description>In QUAD mode selects quadrature encoding mode (X1/X2/X4).
In PWM, PWM_DT and PWM_PR modes, these two bits can be used to invert 'dt_line_out' and 'dt_line_compl_out'.  Inversion is the last step in generation of 'dt_line_out' and 'dt_line_compl_out'; i.e. a disabled output line 'dt_line_out' has the value QUADRATURE_MODE[0] and a disabled output line 'dt_line_compl_out' has the value QUADRATURE_MODE[1].</description>
                <bitRange>[21:20]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>X1</name>
                    <description>X1 encoding (QUAD mode)</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>X2</name>
                    <description>X2 encoding (QUAD mode)</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>X4</name>
                    <description>X4 encoding (QUAD mode)</description>
                    <value>2</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>MODE</name>
                <description>Counter mode.</description>
                <bitRange>[26:24]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>TIMER</name>
                    <description>Timer mode</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CAPTURE</name>
                    <description>Capture mode</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>QUAD</name>
                    <description>Quadrature encoding mode</description>
                    <value>3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>PWM</name>
                    <description>Pulse width modulation (PWM) mode</description>
                    <value>4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>PWM_DT</name>
                    <description>PWM with deadtime insertion mode</description>
                    <value>5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>PWM_PR</name>
                    <description>Pseudo random pulse width modulation</description>
                    <value>6</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>STATUS</name>
            <description>Counter status register</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x8000FF01</resetMask>
            <fields>
              <field>
                <name>DOWN</name>
                <description>When '0', counter is counting up. When '1', counter is counting down. In QUAD mode, this field indicates the direction of the latest counter change: '0' when last incremented and '1' when last decremented.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>GENERIC</name>
                <description>Generic 8-bit counter field. In PWM_DT mode, this counter is used for dead time insertion. In all other modes, this counter is used for pre-scaling the selected counter clock. PWM_DT mode can NOT use prescaled clock functionality.</description>
                <bitRange>[15:8]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>RUNNING</name>
                <description>When '0', the counter is NOT running. When '1', the counter is running.</description>
                <bitRange>[31:31]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>COUNTER</name>
            <description>Counter count register</description>
            <addressOffset>0x8</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFF</resetMask>
            <fields>
              <field>
                <name>COUNTER</name>
                <description>16-bit counter value. It is advised to not write to this field when the counter is running.</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CC</name>
            <description>Counter compare/capture register</description>
            <addressOffset>0xC</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0xFFFF</resetValue>
            <resetMask>0xFFFF</resetMask>
            <fields>
              <field>
                <name>CC</name>
                <description>In CAPTURE mode, captures the counter value. In other modes, compared to counter value.</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CC_BUFF</name>
            <description>Counter buffered compare/capture register</description>
            <addressOffset>0x10</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0xFFFF</resetValue>
            <resetMask>0xFFFF</resetMask>
            <fields>
              <field>
                <name>CC</name>
                <description>Additional buffer for counter CC register.</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>PERIOD</name>
            <description>Counter period register</description>
            <addressOffset>0x14</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0xFFFF</resetValue>
            <resetMask>0xFFFF</resetMask>
            <fields>
              <field>
                <name>PERIOD</name>
                <description>Period value: upper value of the counter. When the counter should count for n cycles, this field should be set to n-1.</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>PERIOD_BUFF</name>
            <description>Counter buffered period register</description>
            <addressOffset>0x18</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0xFFFF</resetValue>
            <resetMask>0xFFFF</resetMask>
            <fields>
              <field>
                <name>PERIOD</name>
                <description>Additional buffer for counter PERIOD register.</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>TR_CTRL0</name>
            <description>Counter trigger control register 0</description>
            <addressOffset>0x20</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x10</resetValue>
            <resetMask>0xFFFFF</resetMask>
            <fields>
              <field>
                <name>CAPTURE_SEL</name>
                <description>Selects one of the 16 input triggers as a capture trigger. Input trigger 0 is always '0' and input trigger 1 is always '1'. Input trigger 2 is the first external trigger line (tcpwm.tr_in[0]).

In the PWM, PWM_DT and PWM_PR modes this trigger is used to switch the values if the compare and period registers with their buffer counterparts.</description>
                <bitRange>[3:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>COUNT_SEL</name>
                <description>Selects one of the 16 input triggers as a count trigger. In QUAD mode, this is the first phase (phi A). Default setting selects input trigger 1, which is always '1'.</description>
                <bitRange>[7:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RELOAD_SEL</name>
                <description>Selects one of the 16 input triggers as a reload trigger. In QUAD mode, this is the index or revolution pulse. In this mode, it will update the counter with the value in the TCPWM_CNTn_PERIOD register.</description>
                <bitRange>[11:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>STOP_SEL</name>
                <description>Selects one of the 16 input triggers as a stop trigger. In PWM, PWM_DT and PWM_PR modes, this is the kill trigger. In these modes, the kill trigger is used to either temporarily block the PWM outputs (PWM_STOP_ON_KILL is '0') or stop the functionality (PWM_STOP_ON_KILL is '1'). For the PWM and PWM_DT modes, the blocking of the output signals can be  asynchronous (STOP_EDGE should be NO_EDGE_DET) in which case the blocking is as long as the trigger is '1' or synchronous (STOP_EDGE should be RISING_EDGE) in which case it extends till the next terminal count event.</description>
                <bitRange>[15:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>START_SEL</name>
                <description>Selects one of the 16 input triggers as a start trigger. In QUAD mode, this is the second phase (phi B).</description>
                <bitRange>[19:16]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>TR_CTRL1</name>
            <description>Counter trigger control register 1</description>
            <addressOffset>0x24</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x3FF</resetValue>
            <resetMask>0x3FF</resetMask>
            <fields>
              <field>
                <name>CAPTURE_EDGE</name>
                <description>A capture event will copy the counter value into the CC register.</description>
                <bitRange>[1:0]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>RISING_EDGE</name>
                    <description>Rising edge. Any rising edge generates an event.</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>FALLING_EDGE</name>
                    <description>Falling edge. Any falling edge generates an event.</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>BOTH_EDGES</name>
                    <description>Rising AND falling edge. Any odd amount of edges generates an event.</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>NO_EDGE_DET</name>
                    <description>No edge detection, use trigger as is.</description>
                    <value>3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>COUNT_EDGE</name>
                <description>A counter event will increase or decrease the counter by '1'.</description>
                <bitRange>[3:2]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>RISING_EDGE</name>
                    <description>Rising edge. Any rising edge generates an event.</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>FALLING_EDGE</name>
                    <description>Falling edge. Any falling edge generates an event.</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>BOTH_EDGES</name>
                    <description>Rising AND falling edge. Any odd amount of edges generates an event.</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>NO_EDGE_DET</name>
                    <description>No edge detection, use trigger as is.</description>
                    <value>3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RELOAD_EDGE</name>
                <description>A reload event will initialize the counter. When counting up, the counter is initialized to '0'. When counting down, the counter is initialized with PERIOD.</description>
                <bitRange>[5:4]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>RISING_EDGE</name>
                    <description>Rising edge. Any rising edge generates an event.</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>FALLING_EDGE</name>
                    <description>Falling edge. Any falling edge generates an event.</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>BOTH_EDGES</name>
                    <description>Rising AND falling edge. Any odd amount of edges generates an event.</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>NO_EDGE_DET</name>
                    <description>No edge detection, use trigger as is.</description>
                    <value>3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>STOP_EDGE</name>
                <description>A stop event, will stop the counter; i.e. it will no longer be running. Stopping will NOT disable the counter.</description>
                <bitRange>[7:6]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>RISING_EDGE</name>
                    <description>Rising edge. Any rising edge generates an event.</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>FALLING_EDGE</name>
                    <description>Falling edge. Any falling edge generates an event.</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>BOTH_EDGES</name>
                    <description>Rising AND falling edge. Any odd amount of edges generates an event.</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>NO_EDGE_DET</name>
                    <description>No edge detection, use trigger as is.</description>
                    <value>3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>START_EDGE</name>
                <description>A start event will start the counter; i.e. the counter will become running. Starting does NOT enable the counter. A start event will not initialize the counter whereas the reload event does.</description>
                <bitRange>[9:8]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>RISING_EDGE</name>
                    <description>Rising edge. Any rising edge generates an event.</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>FALLING_EDGE</name>
                    <description>Falling edge. Any falling edge generates an event.</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>BOTH_EDGES</name>
                    <description>Rising AND falling edge. Any odd amount of edges generates an event.</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>NO_EDGE_DET</name>
                    <description>No edge detection, use trigger as is.</description>
                    <value>3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>TR_CTRL2</name>
            <description>Counter trigger control register 2</description>
            <addressOffset>0x28</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x3F</resetValue>
            <resetMask>0x3F</resetMask>
            <fields>
              <field>
                <name>CC_MATCH_MODE</name>
                <description>Determines the effect of a compare match event (COUNTER equals CC register) on the 'line_out' output signals.  Note that INVERT is especially useful for center aligned pulse width modulation.
To generate a duty cycle of 0 percent, the counter CC register should be set to '0'. For a 100 percent duty cycle, the counter CC register should be set to larger than the counter PERIOD register.</description>
                <bitRange>[1:0]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>SET</name>
                    <description>Set to '1'</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CLEAR</name>
                    <description>Set to '0'</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>INVERT</name>
                    <description>Invert</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>NO_CHANGE</name>
                    <description>No Change</description>
                    <value>3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OVERFLOW_MODE</name>
                <description>Determines the effect of a counter overflow event (COUNTER reaches PERIOD) on the 'line_out' output signals.</description>
                <bitRange>[3:2]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>SET</name>
                    <description>Set to '1'</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CLEAR</name>
                    <description>Set to '0'</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>INVERT</name>
                    <description>Invert</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>NO_CHANGE</name>
                    <description>No Change</description>
                    <value>3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>UNDERFLOW_MODE</name>
                <description>Determines the effect of a counter underflow event (COUNTER reaches '0') on the 'line_out' output signals.</description>
                <bitRange>[5:4]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>SET</name>
                    <description>Set to '1'</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CLEAR</name>
                    <description>Set to '0'</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>INVERT</name>
                    <description>Invert</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>NO_CHANGE</name>
                    <description>No Change</description>
                    <value>3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR</name>
            <description>Interrupt request register.</description>
            <addressOffset>0x30</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x3</resetMask>
            <fields>
              <field>
                <name>TC</name>
                <description>Terminal count event. Set to '1', when event is detected. Write with '1' to clear bit.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CC_MATCH</name>
                <description>Counter matches CC register event. Set to '1', when event is detected. Write with '1' to clear bit.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_SET</name>
            <description>Interrupt set request register.</description>
            <addressOffset>0x34</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x3</resetMask>
            <fields>
              <field>
                <name>TC</name>
                <description>Write with '1' to set corresponding bit in interrupt request register.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CC_MATCH</name>
                <description>Write with '1' to set corresponding bit in interrupt request register.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_MASK</name>
            <description>Interrupt mask register.</description>
            <addressOffset>0x38</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x3</resetMask>
            <fields>
              <field>
                <name>TC</name>
                <description>Mask bit for corresponding bit in interrupt request register.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CC_MATCH</name>
                <description>Mask bit for corresponding bit in interrupt request register.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_MASKED</name>
            <description>Interrupt masked request register</description>
            <addressOffset>0x3C</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x3</resetMask>
            <fields>
              <field>
                <name>TC</name>
                <description>Logical and of corresponding request and mask bits.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>CC_MATCH</name>
                <description>Logical and of corresponding request and mask bits.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
        </cluster>
      </registers>
    </peripheral>
    <peripheral>
      <name>WCO</name>
      <description>32KHz Oscillator</description>
      <baseAddress>0x40070000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>65536</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>CONFIG</name>
          <description>WCO Configuration Register</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x470002</resetValue>
          <resetMask>0xC0FF0007</resetMask>
          <fields>
            <field>
              <name>LPM_EN</name>
              <description>Force block into Low Power Mode:
0: Do not force low power mode (LPM) on
1: Force low power mode (LPM) on</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LPM_AUTO</name>
              <description>Automatically control low power mode (only relevant when LPM_EN=0):
0: Do not enter low power mode (LPM) in DeepSleep
1: Enter low power mode (LPM) in DeepSleep. The logic monitors !act_power_en to determine the device has entered DeepSleep.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EXT_INPUT_EN</name>
              <description>Disables the load resistor and allows external clock input for pad_xin</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ENBUS</name>
              <description>Test Mode Control bits
enbus[7] - N/A
enbus[6] - 1=enable both primary Beta Multipliers
enbus[5] - N/A
enbus[4] - N/A
enbus[3] - Load Resistor Control
enbus[2] - Load Resistor Control
enbus[1] - Load Resistor Control
enbus[0] - Load Resistor Control</description>
              <bitRange>[23:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DPLL_ENABLE</name>
              <description>Enable DPLL operation. The Oscillator is specified to be stable after 500 ms thus the DPLL should be asserted no sooner than that after IP_ENABLE is set.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>IP_ENABLE</name>
              <description>Master enable for IP - disables both WCO and DPLL</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>STATUS</name>
          <description>WCO Status Register</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1</resetMask>
          <fields>
            <field>
              <name>OUT_BLNK_A</name>
              <description>Indicates that output has transitioned - This bit is intended for Test Mode Only and is not a reliable indicator.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DPLL</name>
          <description>WCO DPLL Register</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x3FC00000</resetValue>
          <resetMask>0x3FFF07FF</resetMask>
          <fields>
            <field>
              <name>DPLL_MULT</name>
              <description>Multiplier to determine IMO frequency in multiples of the WCO frequency

Fimo = (DPLL_MULT + 1)  * Fwco</description>
              <bitRange>[10:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DPLL_LF_IGAIN</name>
              <description>DPLL Loop Filter Integral Gain Setting
0x0 - 0.0625
0x1 - 0.125
0x2 - 0.25
0x3 - 0.5
0x4 - 1.0
0x5 - 2.0
0x6 - 4.0
0x7 - 8.0</description>
              <bitRange>[18:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DPLL_LF_PGAIN</name>
              <description>DPLL Loop Filter Proportionial Gain Setting
0x0 - 0.0625
0x1 - 0.125
0x2 - 0.25
0x3 - 0.5
0x4 - 1.0
0x5 - 2.0
0x6 - 4.0
0x7 - 8.0</description>
              <bitRange>[21:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DPLL_LF_LIMIT</name>
              <description>Maximum IMO offset allowed (used to prevent DPLL dynamics from selecting an IMO frequency that the logic cannot support)</description>
              <bitRange>[29:22]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TRIM</name>
          <description>WCO Trim Register</description>
          <addressOffset>0xF00</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x2211</resetValue>
          <resetMask>0x3737</resetMask>
          <fields>
            <field>
              <name>XGM</name>
              <description>Amplifier GM setting - Used when WCO.LPM_AUTO=0 or when LPM_AUTO=1 and not in DeepSleep mode.
0x0 - 3370 nA
0x1 - 2620 nA
0x2 - 2250 nA
0x3 - 1500 nA
0x4 - 1870 nA
0x5 - 1120 nA
0x6 -  750 nA
0x7 -      0 nA</description>
              <bitRange>[2:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LPM_GM</name>
              <description>GM setting for LPM (bandwidth = DC/ms)  - Used when WCO.LPM_AUTO=0 or when LPM_AUTO=1 and not in DeepSleep mode.</description>
              <bitRange>[5:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>XGM_FOR_LPM_AUTO</name>
              <description>Amplifier GM setting - Used when WCO.LPM_AUTO=1 and in DeepSleep mode
0x0 - 3370 nA
0x1 - 2620 nA
0x2 - 2250 nA
0x3 - 1500 nA
0x4 - 1870 nA
0x5 - 1120 nA
0x6 -  750 nA
0x7 -      0 nA</description>
              <bitRange>[10:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LPM_GM_FOR_LPM_AUTO</name>
              <description>GM setting for LPM (bandwidth = DC/ms) - Used when WCO.LPM_AUTO=1 and in DeepSleep mode</description>
              <bitRange>[13:12]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>SCB0</name>
      <description>Serial Communications Block (SPI/UART/I2C)</description>
      <headerStructName>SCB</headerStructName>
      <baseAddress>0x40080000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>65536</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>CTRL</name>
          <description>Generic control register.</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x300000F</resetValue>
          <resetMask>0x83031F0F</resetMask>
          <fields>
            <field>
              <name>OVS</name>
              <description>N/A</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EC_AM_MODE</name>
              <description>Internally clocked mode ('0') or externally clocked mode ('1') address matching (I2C) or selection (SPI). In internally clocked mode, the serial interface protocols run off the peripheral clock. In externally clocked mode, the serial interface protocols run off the clock as provided by the serial interface. Externally clocked mode is only used for synchronous serial interface protocols (SPI and I2C) in slave mode. In SPI mode, only Motorola submode (all Motorola modes: 0, 1, 2, 3) is supported.

In UART mode this field should be '0'.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EC_OP_MODE</name>
              <description>Internally clocked mode ('0') or externally clocked mode ('1') operation. In internally clocked mode, the serial interface protocols run off the peripheral clock. In externally clocked mode, the serial interface protocols run off the clock as provided by the serial interface. Externally clocked operation mode is only used for synchronous serial interface protocols (SPI and I2C) in slave mode AND EZ mode. In SPI mode, only Motorola submode (all Motorola modes: 0, 1, 2, 3) is supported. The maximum SPI slave, EZ mode bitrate is 48 Mbps (transmission and IO delays outside the IP will degrade the effective bitrate).

In UART mode this field should be '0'.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EZ_MODE</name>
              <description>Non EZ mode ('0') or EZ mode ('1'). In EZ mode, a meta protocol is applied to the serial interface protocol. This meta protocol adds meaning to the data frames transferred by the serial interface protocol: a data frame can represent a memory address, a write memory data element or a read memory data element. EZ mode is only used for synchronous serial interface protocols: SPI and I2C. In SPI mode, only Motorola submode (all Motorola modes: 0, 1, 2, 3) is supported and the transmitter should use continuous data frames; i.e. data frames mot seperated by slave deselection. This mode is only applicable to slave functionality. In EZ mode, the slave can read from and write to an addressable memory structure of 32 bytes. In EZ mode, data frames should 8-bit in size and should be transmitted and received with the Most Significant Bit (MSB) first.

In UART mode this field should be '0'.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BYTE_MODE</name>
              <description>Determines the number of bits per FIFO data element:
'0': 16-bit FIFO data elements.
'1': 8-bit FIFO data elements. This mode doubles the amount of FIFO entries, but  TX_CTRL.DATA_WIDTH and RX_CTRL.DATA_WIDTH are restricted to [0, 7].</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CMD_RESP_MODE</name>
              <description>Determines CMD_RESP mode of operation:
'0': CMD_RESP mode disabled.
'1': CMD_RESP mode enabled (also requires EC_AM_MODE and EC_OP_MODE to be set to '1').</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ADDR_ACCEPT</name>
              <description>Determines whether a received matching address is accepted in the RX FIFO ('1') or not ('0').

In I2C mode, this field is used to allow the slave to put the received slave address or general call address in the RX FIFO. Note that a received matching address is put in the RX FIFO when ADDR_ACCEPT is '1' for both I2C read and write transfers.

In multi-processor UART receiver mode, this field is used to allow the receiver to put the received address in the RX FIFO. Note: non-matching addresses are never put in the RX FIFO.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BLOCK</name>
              <description>Only used in externally clocked mode. If the externally clocked logic and the MMIO SW accesses to EZ memory coincide/collide, this bit determines whether a SW access should block and result in bus wait states ('BLOCK is 1') or not (BLOCK is '0'). IF BLOCK is '0' and the accesses collide, MMIO read operations return 0xffff:ffff and MMIO write operations are ignored. Colliding accesses are registered as interrupt causes: field BLOCKED of MMIO registers INTR_TX and INTR_RX.</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MODE</name>
              <description>N/A</description>
              <bitRange>[25:24]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>I2C</name>
                  <description>Inter-Integrated Circuits (I2C) mode.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SPI</name>
                  <description>Serial Peripheral Interface (SPI) mode.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UART</name>
                  <description>Universal Asynchronous Receiver/Transmitter (UART) mode.</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ENABLED</name>
              <description>IP enabled ('1') or not ('0'). The proper order in which to initialize the IP is as follows:
- Program protocol specific information using SPI_CTRL, UART_CTRL (and UART_TX_CTRL and UART_RX_CTRL) or I2C_CTRL. This includes selection of a submode, master/slave functionality and transmitter/receiver functionality when applicable.
- Program generic transmitter (TX_CTRL) and receiver (RX_CTRL) information. This includes enabling of the transmitter and receiver functionality.
- Program transmitter FIFO (TX_FIFO_CTRL) and receiver FIFO (RX_FIFO_CTRL) information.
- Program CTRL to enable IP, select the specific operation mode and oversampling factor.
When the IP is enabled, no control information should be changed. Changes should be made AFTER disabling the IP, e.g. to modify the operation mode (from I2C to SPI) or to go from externally to internally clocked. The change takes effect after the IP is re-enabled. Note that disabling the IP will cause re-initialization of the design and associated state is lost (e.g. FIFO content).</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>STATUS</name>
          <description>Generic status register.</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>EC_BUSY</name>
              <description>Inidicates whether the externally clocked logic is potentially accessing the EZ memory (this is only possible in EZ mode). This bit can be used by SW to determine whether it is safe to issue a SW access to the EZ memory (without bus wait states (a blocked SW access) or bus errors being generated). Note that the INTR_TX.BLOCKED and INTR_RX.BLOCKED interrupt causes are used to indicate whether a SW access was actually blocked by externally clocked logic.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CMD_RESP_CTRL</name>
          <description>Command/response control register.</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1FF01FF</resetMask>
          <fields>
            <field>
              <name>BASE_RD_ADDR</name>
              <description>I2C/SPI read base address for CMD_RESP mode. Address is used by a I2C CMD_RESP mode read transfer (CTRL.MODE is I2C) or a SPI CMD_RESP mode read transfer (CTRL.MODE is SPI): at the start of a read transfer BASE_RD_ADDR is copied to CMD_RESP_STATUS.CURR_RD_ADDR. This field should not be modified during ongoing bus transfers.</description>
              <bitRange>[8:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BASE_WR_ADDR</name>
              <description>I2C/SPI read base address for CMD_RESP mode. Address is used by a I2C CMD_RESP mode write transfer (CTRL.MODE is I2C) or a SPI CMD_RESP mode write transfer (CTRL.MODE is SPI): at the start of a write transfer BASE_WE_ADDR is copied to CMD_RESP_STATUS.CURR_WR_ADDR. This field should not be modified during ongoing bus transfers.</description>
              <bitRange>[24:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CMD_RESP_STATUS</name>
          <description>Command/response status register.</description>
          <addressOffset>0xC</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>CURR_RD_ADDR</name>
              <description>I2C/SPI read current address for CMD_RESP mode. HW increments the field after a read access to the memory buffer. However, when the last memory buffer address is reached, the address is NOT incremented (but remains at the maximim memory buffer address). 

The field is used to determine how many bytes have been read (# bytes = CURR_RD_ADDR - CMD_RESP_CTRL.BASE_RD_ADDR). 

This field is reliable during when there is no bus transfer. This field is potentially unreliable when there is a bus transfer bus transfer: when CMD_RESP_EC_BUSY is '0', the field is reliable.</description>
              <bitRange>[8:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>CURR_WR_ADDR</name>
              <description>I2C/SPI write current address for CMD_RESP mode. HW increments the field after a read access to the memory buffer. However, when the last memory buffer address is reached, the address is NOT incremented (but remains at the maximim memory buffer address).

The field is used to determine how many bytes have been written (# bytes = CURR_WR_ADDR - CMD_RESP_CTRL.BASE_WR_ADDR).

This field is reliable during when there is no bus transfer. This field is potentially unreliable when there is a bus transfer bus transfer: when CMD_RESP_EC_BUSY is '0', the field is reliable.</description>
              <bitRange>[24:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>CMD_RESP_EC_BUS_BUSY</name>
              <description>Indicates whether there is an ongoing bus transfer to the IP.
'0': no ongoing bus transfer.
'1': ongoing bus transferr.

For SPI, the field is '1' when the slave is selected.

For I2C, the field is set to '1' at a I2C START/RESTART. In case of an address match, the  field is set to '0' on a I2C STOP. In case of NO address match, the field is set to '0' after the failing address match.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>CMD_RESP_EC_BUSY</name>
              <description>Indicates whether the CURR_RD_ADDR and CURR_WR_ADDR fields in this register are reliable (when CMD_RESP_EC_BUSY is '0') or not reliable (when CMD_RESP_EC_BUSY is '1'). Note:
- When there is no ongoing bus transfer, CMD_RESP_EC_BUSY is '0' (reliable).
- When there is a ongoing bus transfer, CMD_RESP_EC_BUSY is '0' (reliable), when the CURR_RD_ADDR and CURR_WR_ADDR are not being updated by the HW.
- When there is a ongoing bus transfer, CMD_RESP_EC_BUSY is '1' (not reliable), when the CURR_RD_ADDR or CURR_WR_ADDR are being updated by the HW. 
   Note that this update lasts one I2C clock cycle, or two SPI clock cycles.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SPI_CTRL</name>
          <description>SPI control register.</description>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x3000000</resetValue>
          <resetMask>0x8F010F3F</resetMask>
          <fields>
            <field>
              <name>CONTINUOUS</name>
              <description>Continuous SPI data transfers enabled ('1') or not ('0'). This field is used in master mode. In slave mode, both continuous and non-continuous SPI data transfers are supported independent of this field.

When continuous transfers are enabled individual data frame transfers are not necessarily seperated by slave deselection (as indicated by the level or pulse on the SELECT line): if the TX FIFO has multiple data frames, data frames are send out without slave deselection.

When continuous transfers are not enabled individual data frame transfers are always seperated by slave deselection: independent of the availability of TX FIFO data frames, data frames are send out with slave deselection.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SELECT_PRECEDE</name>
              <description>Only used in SPI Texas Instruments' submode.

When '1', the data frame start indication is a pulse on the SELECT line that precedes the transfer of the first data frame bit.

When '0', the data frame start indication is a pulse on the SELECT line that coincides with the transfer of the first data frame bit.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CPHA</name>
              <description>Only applicable in SPI Motorola submode. Indicates the clock phase. This field, together with the CPOL field, indicates when MOSI data is driven and MISO data is captured:
- Motorola mode 0. CPOL is '0', CPHA is '0': MOSI  is driven on a falling edge of SCLK. MISO is captured on a rising edge of SCLK.
- Motorola mode 1. CPOL is '0', CPHA is '1': MOSI  is driven on a rising edge of SCLK. MISO is captured on a falling edge of SCLK.
- Motorola mode 2. CPOL is '1', CPHA is '0': MOSI  is driven on a rising edge of SCLK. MISO is captured on a falling edge of SCLK.
- Motorola mode 3. CPOL is '1', CPHA is '1': MOSI  is driven on a falling edge of SCLK. MISO is captured on a rising edge of SCLK.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CPOL</name>
              <description>Indicates the clock polarity. Only used in SPI Motorola submode. This field, together with the CPHA field, indicates when MOSI data is driven and MISO data is captured:
- CPOL is '0': SCLK is '0' when not transmitting data.
- CPOL is '1': SCLK is '1' when not transmitting data.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LATE_MISO_SAMPLE</name>
              <description>Changes the SCLK edge on which MISO is captured. Only used in master mode.

When '0', the default applies (for Motorola as determined by CPOL and CPHA, for Texas Instruments on the falling edge of SCLK and for National Semiconductors on the rising edge of SCLK). 

When '1', the alternate clock edge is used (which comes half a SPI SCLK period later). Late sampling addresses the round trip delay associated with transmitting SCLK from the master to the slave and transmitting MISO from the slave to the master.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SCLK_CONTINUOUS</name>
              <description>Only applicable in master mode. 
'0': SCLK is generated, when the SPI master is enabled and data is transmitted.
'1': SCLK is generated, when the SPI master is enabled. This mode is useful for slave devices that use SCLK for functional operation other than just SPI functionality.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SSEL_POLARITY0</name>
              <description>Slave select polarity. SSEL_POLARITY0 applies to the outgoing SPI slave select signal 0 (master mode) and to the incoming SPI slave select signal (slave mode). only SPI_SELECT[0] is used in slave mode.
For Motorola and National Semiconductors submodes: 
'0': slave select is low/'0' active.
'1': slave select is high/'1' active.
For Texas Istruments submode:
'0': high/'1' active precede/coincide pulse.
'1': low/'0' active precede/coincide pulse.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SSEL_POLARITY1</name>
              <description>Slave select polarity. SSEL_POLARITY1 applies to the outgoing SPI slave select signal 1 (master mode).</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SSEL_POLARITY2</name>
              <description>Slave select polarity. SSEL_POLARITY2 applies to the outgoing SPI slave select signal 2 (master mode).</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SSEL_POLARITY3</name>
              <description>Slave select polarity. SSEL_POLARITY3 applies to the outgoing SPI slave select signal 3 (master mode).</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LOOPBACK</name>
              <description>Local loopback control (does NOT affect the information on the pins). Only used in master mode. Not used in National Semiconductors submode.
'0': the SPI master MISO line 'spi_miso_in' is connected to the SPI MISO pin.
'1': the SPI master MISO line 'spi_miso_in' is connected to the SPI master MOSI line 'spi_mosi_out'. In other words, in loopback mode the SPI master receives on MISO what it transmits on MOSI.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MODE</name>
              <description>N/A</description>
              <bitRange>[25:24]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SPI_MOTOROLA</name>
                  <description>SPI Motorola submode. In master mode, when not transmitting data (SELECT is inactive), SCLK is stable at CPOL. In slave mode, when not selected, SCLK is ignored; i.e. it can be either stable or clocking. In master mode, when there is no data to transmit (TX FIFO is empty), SELECT is inactive.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SPI_TI</name>
                  <description>SPI Texas Instruments submode. In master mode, when not transmitting data, SCLK is stable at '0'. In slave mode, when not selected, SCLK is ignored; i.e. it can be either stable or clocking. In master mode, when there is no data to transmit (TX FIFO is empty), SELECT is inactive; i.e. no pulse is generated.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SPI_NS</name>
                  <description>SPI National Semiconducturs submode. In master mode, when not transmitting data, SCLK is stable at '0'. In slave mode, when not selected, SCLK is ignored; i.e. it can be either stable or clocking. In master mode, when there is no data to transmit (TX FIFO is empty), SELECT is inactive.</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SLAVE_SELECT</name>
              <description>Selects one of the four outgoing SPI slave select signals:
- 0: Slave 0, SPI_SELECT[0].
- 1: Slave 1, SPI_SELECT[1].
- 2: Slave 2, SPI_SELECT[2].
- 3: Slave 3, SPI_SELECT[3].
Only used in master mode. The IP should be disabled when changes are made to this field.
only SPI_SELECT[0] is used in slave mode.</description>
              <bitRange>[27:26]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MASTER_MODE</name>
              <description>Master ('1') or slave ('0') mode. In master mode, transmission will commence on availability of data frames in the TX FIFO. In slave mode, when selected and there is no data frame in the TX FIFO, the slave will transmit all '1's. In both master and slave modes, received data frames will be lost if the RX FIFO is full.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SPI_STATUS</name>
          <description>SPI status register.</description>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>BUS_BUSY</name>
              <description>SPI bus is busy. The bus is considered busy ('1') during an ongoing transaction. For Motorola and National submodes, the busy bit is '1', when the slave selection (low active) is activated. For TI submode, the busy bit is '1' from the time the preceding/coinciding slave select (high active) is activated for the first transmitted data frame, till the last MOSI/MISO bit of the last data frame is transmitted.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SPI_EC_BUSY</name>
              <description>Inidicates whether the externally clocked logic is potentially accessing the EZ memory and/or updating BASE_ADDR or CURR_ADDR (this is only possible in EZ mode). This bit can be used by SW to determine whether BASE_ADDR and CURR_ADDR are reliable.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>CURR_EZ_ADDR</name>
              <description>SPI current EZ address. Current address pointer. This field is only reliable in internally clocked mode. In externally clocked mode the field may be unreliable (during an ongoing transfer when SPI_EC_BUSY is '1'), as clock domain synchronization is not performed in the design.</description>
              <bitRange>[15:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>BASE_EZ_ADDR</name>
              <description>SPI base EZ address. Address as provided by a SPI write transfer. This field is only reliable in internally clocked mode. In externally clocked mode the field may be unreliable, as clock domain synchronization is not performed in the design.</description>
              <bitRange>[23:16]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UART_CTRL</name>
          <description>UART control register.</description>
          <addressOffset>0x40</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x3000000</resetValue>
          <resetMask>0x3010000</resetMask>
          <fields>
            <field>
              <name>LOOPBACK</name>
              <description>Local loopback control (does NOT affect the information on the pins). When '0', the transmitter TX line 'uart_tx_out' is connected to the TX pin and the receiver RX line 'uart_rx_in' is connected to the RX pin. When '1', the transmitter TX line 'uart_tx_out' is connected to the receiver RX line 'uart_rx_in'. A similar connections scheme is followed for 'uart_rts_out' and 'uart_cts_in'.

This allows a SCB UART transmitter to communicate with its receiver counterpart.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MODE</name>
              <description>N/A</description>
              <bitRange>[25:24]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>UART_STD</name>
                  <description>Standard UART submode.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UART_SMARTCARD</name>
                  <description>SmartCard (ISO7816) submode. Support for negative acknowledgement (NACK) on the receiver side and retransmission on the transmitter side.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UART_IRDA</name>
                  <description>Infrared Data Association (IrDA) submode. Return to Zero modulation scheme. In this mode, the oversampling factor should be 16, that is OVS is 15.</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>UART_TX_CTRL</name>
          <description>UART transmitter control register.</description>
          <addressOffset>0x44</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x2</resetValue>
          <resetMask>0x137</resetMask>
          <fields>
            <field>
              <name>STOP_BITS</name>
              <description>Stop bits. STOP_BITS + 1 is the duration of the stop period in terms of halve bit periods. Valid range is [1, 7]; i.e. a stop period should last at least one bit period.</description>
              <bitRange>[2:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PARITY</name>
              <description>Parity bit. When '0', the transmitter generates an even parity. When '1', the transmitter generates an odd parity. Only applicable in standard UART and SmartCard submodes.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PARITY_ENABLED</name>
              <description>Parity generation enabled ('1') or not ('0'). Only applicable in standard UART submodes. In SmartCard submode, parity generation is always enabled through hardware. In IrDA submode, parity generation is always disabled through hardware</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RETRY_ON_NACK</name>
              <description>When '1', a data frame is retransmitted when a negative acknowledgement is received. Only applicable to the SmartCard submode.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UART_RX_CTRL</name>
          <description>UART receiver control register.</description>
          <addressOffset>0x48</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xA0002</resetValue>
          <resetMask>0xF3777</resetMask>
          <fields>
            <field>
              <name>STOP_BITS</name>
              <description>Stop bits. STOP_BITS + 1 is the duration of the stop period in terms of halve bit periods. Valid range is [1, 7]; i.e. a stop period should last at least one bit period. If STOP_BITS is '1', stop bits error detection is NOT performed. If STOP_BITS is in [2, 7], stop bits error detection is performed and the associated interrupt cause INTR_RX.FRAME_ERROR is set to '1' if an error is detected. In other words, the receiver supports data frames with a 1 bit period stop bit sequence, but requires at least 1.5 bit period stop bit sequences to detect errors. This limitation is due to possible transmitter and receiver clock skew that prevents the design from doing reliable stop bit detection for short (1 bit bit period) stop bit sequences. Note that in case of a stop bits error, the successive data frames may get lost as the receiver needs to resynchronize its start bit detection. The amount of lost data frames depends on both the amount of stop bits, the idle ('1') time between data frames and the data frame value.</description>
              <bitRange>[2:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PARITY</name>
              <description>Parity bit. When '0', the receiver expects an even parity. When '1', the receiver expects an odd parity. Only applicable in standard UART and SmartCard submodes.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PARITY_ENABLED</name>
              <description>Parity checking enabled ('1') or not ('0'). Only applicable in standard UART submode. In SmartCard submode, parity checking is always enabled through hardware. In IrDA submode, parity checking is always disabled through hardware.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>POLARITY</name>
              <description>Inverts incoming RX line signal 'uart_rx_in'. Inversion is after local loopback. This functionality is intended for IrDA receiver functionality.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DROP_ON_PARITY_ERROR</name>
              <description>Behaviour when a parity check fails. When '0', received data is send to the RX FIFO. When '1', received data is dropped and lost. Only applicable in standard UART and SmartCard submodes (negatively acknowledged SmartCard data frames may be dropped with this field).</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DROP_ON_FRAME_ERROR</name>
              <description>Behaviour when an error is detected in a start or stop period. When '0', received data is send to the RX FIFO. When '1', received data is dropped and lost.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MP_MODE</name>
              <description>Multi-processor mode. When '1', multi-processor mode is enabled. In this mode, RX_CTRL.DATA_WIDTH should indicate a 9-bit data frame. In multi-processor mode, the 9th received bit of a data frame seperates addresses (bit is '1') from data (bit is '0'). A received address is matched with RX_MATCH.DATA and RX_MATCH.MASK. In the case of a match, subsequent received data are sent to the RX FIFO. In the case of NO match, subsequent received data are dropped.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LIN_MODE</name>
              <description>Only applicable in standard UART submode. When '1', the receiver performs break detection and baud rate detection on the incoming data. First, break detection counts the amount of bit periods that have a line value of '0'. BREAK_WIDTH specifies the minum required amount of bit periods. Successful break detection sets the INTR_RX.BREAK_DETECT interrupt cause to '1'. Second, baud rate detection counts the amount of peripheral clock periods that are use to receive the synchronization byte (0x55; least significant bit first). The count is available through UART_RX_STATUS.BR_COUNTER. Successful baud rate detection sets the INTR_RX.BAUD_DETECT interrupt cause to '1' (BR_COUNTER is reliable). This functionality is used to synchronize/refine the receiver clock to the transmitter clock. The receiver software can use the BR_COUNTER value to set the right IP clock (from the programmable clock IP) to guarantee successful receipt of the first LIN data frame (Protected Identifier Field) after the synchronization byte.</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SKIP_START</name>
              <description>Only applicable in standard UART submode. When '1', the receiver skips start bit detection for the first received data frame. Instead, it synchronizes on the first received data frame bit, which should be a '1'. This functionality is intended for wake up from DeepSleep when receiving a data frame. The transition from idle ('1') to START ('0') on the RX line is used to wake up the CPU. The transition detection (and the associated wake up functionality) is performed by the GPIO2 IP. The woken up CPU will enable the SCB's UART receiver functionality. Once enabled, it is assumed that the START bit is ongoing (the CPU wakeup and SCB enable time should be less than the START bit period). The SCB will synchronize to a '0' to '1' transition, which indicates the first data frame bit is received (first data frame bit should be '1'). After synchronization to the first data frame bit, the SCB will resume normal UART functionality: subsequent data frames will be synchronized on the receipt of a START bit.</description>
              <bitRange>[13:13]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BREAK_WIDTH</name>
              <description>Break width. BREAK_WIDTH + 1 is the minimum width in bit periods of a break. During a break the transmitted/received line value is '0'. This feature is useful for standard UART submode and LIN submode ('break field' detection). Once, the break is detected, the INTR_RX.BREAK_DETECT bit is set to '1'. Note that break detection precedes baud rate detection, which is used to synchronize/refine the receiver clock to the transmitter clock. As a result, break detection operates with an unsynchronized/unrefined receiver clock. Therefore, the receiver's definition of a bit period is imprecise and the setting of this field should take this imprecision into account. The LIN standard also accounts for this imprecision: a LIN start bit followed by 8 data bits allows for up to 9 consecutive '0' bit periods during regular transmission, whereas the LIN break detection should be at least 13 consecutive '0' bit periods. This provides for a margin of 4 bit periods. Therefore, the default value of this field is set to 10, representing a minimal break field with of 10+1 = 11 bit periods; a value in between the 9 consecutive bit periods of a regular transmission and the 13 consecutive bit periods of a break field. This provides for slight imprecisions of the receiver clock wrt. the transmitter clock. There should not be a need to program this field to any value other than its default value.</description>
              <bitRange>[19:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UART_RX_STATUS</name>
          <description>UART receiver status register.</description>
          <addressOffset>0x4C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>BR_COUNTER</name>
              <description>Amount of peripheral clock periods that constitute the transmission of a 0x55 data frame (sent least signficant bit first) as determined by the receiver. BR_COUNTER / 8 is the amount of peripheral clock periods that constitute a bit period. This field has valid data when INTR_RX.BAUD_DETECT is set to '1'.</description>
              <bitRange>[11:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UART_FLOW_CTRL</name>
          <description>UART flow control register</description>
          <addressOffset>0x50</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x30100FF</resetMask>
          <fields>
            <field>
              <name>TRIGGER_LEVEL</name>
              <description>Trigger level. When the receiver FIFO has less entries than the amount of this field, a Ready To Send (RTS) output signal 'uart_rts_out' is activated. By setting this field to '0', flow control is effectively SW disabled (may be useful for debug purposes).</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RTS_POLARITY</name>
              <description>Polarity of the RTS output signal 'uart_rts_out':
'0': RTS is low/'0' active; 'uart_rts_out' is '0' when active and 'uart_rts_out' is '1' when inactive.
'1': RTS is high/'1' active; 'uart_rts_out' is '1' when active and 'uart_rts_out' is '0' when inactive.

During IP reset (Hibernate system power mode), 'uart_rts_out' is '1'. This represents an inactive state assuming a low/'0' active polarity.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CTS_POLARITY</name>
              <description>Polarity of the CTS input signal 'uart_cts_in':
'0': CTS is low/'0' active; 'uart_cts_in' is '0' when active and 'uart_cts_in' is '1' when inactive.
'1': CTS is high/'1' active; 'uart_cts_in' is '1' when active and 'uart_cts_in' is '0' when inactive.</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CTS_ENABLED</name>
              <description>Enable use of CTS input signal 'uart_cts_in' by the UART transmitter:
'0': Disabled. The UART transmitter ignores 'uart_cts_in', and transmits when a data frame is available for transmission in the TX FIFO or the TX shift register.
'1': Enabled. The UART transmitter uses 'uart_cts_in' to qualify the transmission of data. It transmits when 'uart_cts_in' is active and a data frame is available for transmission in the TX FIFO or the TX shift register.

If UART_CTRL.LOOPBACK is '1', 'uart_cts_in' is connected to 'uart_rts_out' in the IP (both signals are subjected to signal polarity changes as indicated by RTS_POLARITY and CTS_POLARITY).</description>
              <bitRange>[25:25]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I2C_CTRL</name>
          <description>I2C control register.</description>
          <addressOffset>0x60</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xFB88</resetValue>
          <resetMask>0xC001FBFF</resetMask>
          <fields>
            <field>
              <name>HIGH_PHASE_OVS</name>
              <description>Serial I2C interface high phase oversampling factor. HIGH_PHASE_OVS + 1 peripheral clock periods constitute the high phase of a bit period. The valid range is [5, 15] with input signal median filtering and [4, 15] without input signal median filtering.

The field is only used in master mode. In slave mode, the field is NOT used. However, there is a frequency requirement for the IP clock wrt. the regular interface (IF) high time to guarantee functional correct behavior. With input signal median filtering, the IF high time should be &gt;= 6 IP clock cycles and &lt;= 16 IP clock cycles. Without input signal median filtering, the IF high time should be &gt;= 5 IP clock cycles and &lt;= 16 IP clock cycles.</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LOW_PHASE_OVS</name>
              <description>Serial I2C interface low phase oversampling factor. LOW_PHASE_OVS + 1 peripheral clock periods constitute the low phase of a bit period. The valid range is [7, 15] with input signal median filtering and [6, 15] without input signal median filtering. 

The field is only used in master mode. In slave mode, the field is NOT used. However, there is a frequency requirement for the IP clock wrt. the regular (no stretching) interface (IF) low time to guarantee functional correct behavior. With input signal median filtering, the IF low time should be &gt;= 8 IP clock cycles and &lt;= 16 IP clock cycles. Without input signal median filtering, the IF low time should be &gt;= 7 IP clock cycles and &lt;= 16 IP clock cycles.</description>
              <bitRange>[7:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>M_READY_DATA_ACK</name>
              <description>When '1', a received data element by the master is immediately ACK'd when the receiver FIFO is not full.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>M_NOT_READY_DATA_NACK</name>
              <description>When '1', a received data element byte the master is immediately NACK'd when the receiver FIFO is full. When '0', clock stretching is used instead (till the receiver FIFO is no longer full).</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>S_GENERAL_IGNORE</name>
              <description>When '1', a received general call slave address is immediately NACK'd (no ACK or clock stretching) and treated as a non matching slave address. This is useful for slaves that do not need any data supplied within the general call structure.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>S_READY_ADDR_ACK</name>
              <description>When '1', a received (matching) slave address is immediately ACK'd when the receiver FIFO is not full. In EZ mode, this field should be set to '1'.</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>S_READY_DATA_ACK</name>
              <description>When '1', a received data element by the slave is immediately ACK'd when the receiver FIFO is not full. In EZ mode, this field should be set to '1'.</description>
              <bitRange>[13:13]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>S_NOT_READY_ADDR_NACK</name>
              <description>For internally clocked logic (EC_AM is '0' and EC_OP is '0') on an address match or general call address (and S_GENERAL_IGNORE is '0'). Only used when:
- EC_AM is '0', EC_OP is '0' and non EZ mode.
Functionality is as follows:
- 1: a received (matching) slave address is immediately NACK'd when the receiver FIFO is full.
- 0: clock stretching is performed (till the receiver FIFO is no longer full). 

For externally clocked logic (EC_AM is '1') on an address match or general call address (and S_GENERAL_IGNORE is '0'). Only used when (NOT used when EC_AM is '1' and EC_OP is '1' and address match and EZ mode):
- EC_AM is '1' and EC_OP is '0'.
- EC_AM is '1' and general call address match.
- EC_AM is '1' and non EZ mode.
Functionality is as follows:
- 1: a received (matching or general) slave address is always immediately NACK'd. There are two possibilities: 1). the internally clocked logic is enabled (we are in Active system power mode) and it handles the rest of the current transfer. In this case the I2C master will not observe the NACK. 2). the internally clocked logic is not enabled (we are in DeepSleep system power mode). In this case the I2C master will observe the NACK and may retry the transfer in the future (which gives the internally clocked logic the time to wake up from DeepSleep system power mode). 
- 0: clock stretching is performed (till the internally clocked logic takes over). The internally clocked logic will handle the ongoing transfer as soon as it is enabled.</description>
              <bitRange>[14:14]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>S_NOT_READY_DATA_NACK</name>
              <description>For internally clocked logic only. Only used when:
- non EZ mode.
Functionality is as follows:
- 1: a received data element byte the slave is immediately NACK'd when the receiver FIFO is full.
- 0: clock stretching is performed (till the receiver FIFO is no longer full).</description>
              <bitRange>[15:15]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LOOPBACK</name>
              <description>Local loopback control (does NOT affect the information on the pins). Only applicable in master/slave mode. When '0', the I2C SCL and SDA lines are connected to the I2C SCL and SDA pins. When '1', I2C SCL and SDA lines are routed internally in the peripheral, and as a result unaffected by other I2C devices. This allows a SCB I2C peripheral to address itself.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SLAVE_MODE</name>
              <description>Slave mode enabled ('1') or not ('0').</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MASTER_MODE</name>
              <description>Master mode enabled ('1') or not ('0'). Note that both master and slave modes can be enabled at the same time. This allows the IP to address itself.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I2C_STATUS</name>
          <description>I2C status register.</description>
          <addressOffset>0x64</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x31</resetMask>
          <fields>
            <field>
              <name>BUS_BUSY</name>
              <description>I2C bus is busy. The bus is considered busy ('1'), from the time a START is detected or from the time the SCL line is '0'. The bus is considered idle ('0'), from the time a STOP is detected. If the IP is disabled, BUS_BUSY is '0'. After enabling the IP, it takes time for the BUS_BUSY to detect a busy bus. This time is the maximum high time of the SCL line. For a 100 kHz interface frequency, this maximum high time may last roughly 5 us (half a bit period).

For single master systems, BUS_BUSY does not have to be used to detect an idle bus before a master starts a transfer using I2C_M_CMD.M_START (no bus collisions).

For multi-master systems, BUS_BUSY can be used to detect an idle bus before a master starts a transfer using I2C_M_CMD.M_START_ON_IDLE (to prevent bus collisions).</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>I2C_EC_BUSY</name>
              <description>Inidicates whether the externally clocked logic is potentially accessing the EZ memory and/or updating BASE_EZ_ADDR or CURR_EZ_ADDR (this is only possible in EZ mode). This bit can be used by SW to determine whether BASE_EZ_ADDR and CURR_EZ_ADDR are reliable.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>S_READ</name>
              <description>I2C slave read transfer ('1') or I2C slave write transfer ('0'). When the I2C slave is inactive/idle or receiving START, REPEATED START, STOP or an address, this field is '0''.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>M_READ</name>
              <description>I2C master read transfer ('1') or I2C master write transfer ('0'). When the I2C master is inactive/idle or transmitting START, REPEATED START, STOP or an address, this field is '0''.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>CURR_EZ_ADDR</name>
              <description>I2C slave current EZ address. Current address pointer. This field is only reliable in internally clocked mode. In externally clocked mode the field may be unreliable (during an ongoing transfer when I2C_EC_BUSY is '1'), as clock domain synchronization is not performed in the design.</description>
              <bitRange>[15:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>BASE_EZ_ADDR</name>
              <description>I2C slave base EZ address. Address as provided by an I2C write transfer. This field is only reliable in internally clocked mode. In externally clocked mode the field may be unreliable, as clock domain synchronization is not performed in the design.</description>
              <bitRange>[23:16]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I2C_M_CMD</name>
          <description>I2C master command register.</description>
          <addressOffset>0x68</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1F</resetMask>
          <fields>
            <field>
              <name>M_START</name>
              <description>When '1', transmit a START or REPEATED START. Whether a START or REPEATED START is transmitted depends on the state of the master state machine. A START is only transmitted when the master state machine is in the default state. A REPEATED START is transmitted when the master state machine is not in the default state, but is working on an ongoing transaction. The REPEATED START can only be transmitted after a NACK or ACK has been received for a transmitted data element or after a NACK has been transmitted for a received data element. When this action is performed, the hardware sets this field to '0'.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>M_START_ON_IDLE</name>
              <description>When '1', transmit a START as soon as the bus is idle (I2C_STATUS.BUS_BUSY is '0', note that BUSY has a default value of '0'). For bus idle detection the hardware relies on STOP detection. As a result, bus idle detection is only functional after at least one I2C bus transfer has been detected on the bus (default/reset value of BUSY is '0') . A START is only transmitted when the master state machine is in the default state. When this action is performed, the hardware sets this field to '0'.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>M_ACK</name>
              <description>When '1', attempt to transmit an acknowledgement (ACK). When this action is performed, the hardware sets this field to '0'.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>M_NACK</name>
              <description>When '1', attempt to transmit a negative acknowledgement (NACK). When this action is performed, the hardware sets this field to '0'.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>M_STOP</name>
              <description>When '1', attempt to transmit a STOP. When this action is performed, the hardware sets this field to '0'. 
 I2C_M_CMD.M_START has a higher priority than this command: in situations where both a STOP and a REPEATED START could be transmitted, M_START takes precedence over M_STOP.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I2C_S_CMD</name>
          <description>I2C slave command register.</description>
          <addressOffset>0x6C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3</resetMask>
          <fields>
            <field>
              <name>S_ACK</name>
              <description>When '1', attempt to transmit an acknowledgement (ACK). When this action is performed, the hardware sets this field to '0'. In EZ mode, this field should be set to '0' (it is only to be used in non EZ mode).</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>S_NACK</name>
              <description>When '1', attempt to transmit a negative acknowledgement (NACK). When this action is performed, the hardware sets this field to '0'.  In EZ mode, this field should be set to '0' (it is only to be used in non EZ mode). This command has a higher priority than I2C_S_CMD.S_ACK, I2C_CTRL.S_READY_ADDR_ACK or I2C_CTRL.S_READY_DATA_ACK.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I2C_CFG</name>
          <description>I2C configuration register.</description>
          <addressOffset>0x70</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x2A1013</resetValue>
          <resetMask>0x303F1313</resetMask>
          <fields>
            <field>
              <name>SDA_IN_FILT_TRIM</name>
              <description>Trim bits for 'i2c_sda_in' 50 ns filter. See s8i2cs BROS (001-59539) for more details on the trim bit values.</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SDA_IN_FILT_SEL</name>
              <description>Selection of 'i2c_sda_in' filter delay:
'0': 0 ns.
'1: 50 ns (filter enabled).</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SCL_IN_FILT_TRIM</name>
              <description>Trim bits for 'i2c_scl_in' 50 ns filter. See s8i2cs BROS (001-59539) for more details on the trim bit values. With s8iom0s8v1p2 I/Os, trim bits should be programmed to 3 to suppress glitches below 50ns.</description>
              <bitRange>[9:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SCL_IN_FILT_SEL</name>
              <description>Selection of 'i2c_scl_in' filter delay:
'0': 0 ns.
'1: 50 ns (filter enabled).</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SDA_OUT_FILT0_TRIM</name>
              <description>Trim bits for 'i2c_sda_out' 50 ns filter 0. See s8i2cs BROS (001-59539) for more details on the trim bit values.</description>
              <bitRange>[17:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SDA_OUT_FILT1_TRIM</name>
              <description>Trim bits for 'i2c_sda_out' 50 ns filter 1. See s8i2cs BROS (001-59539) for more details on the trim bit values.</description>
              <bitRange>[19:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SDA_OUT_FILT2_TRIM</name>
              <description>Trim bits for 'i2c_sda_out' 50 ns filter 2. See s8i2cs BROS (001-59539) for more details on the trim bit values.</description>
              <bitRange>[21:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SDA_OUT_FILT_SEL</name>
              <description>Selection of cumulative 'i2c_sda_out' filter delay:
'0': 0 ns.
'1': 50 ns (filter 0 enabled).
'2': 100 ns (filters 0 and 1 enabled).
'3': 150 ns (filters 0, 1 and 2 enabled).</description>
              <bitRange>[29:28]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TX_CTRL</name>
          <description>Transmitter control register.</description>
          <addressOffset>0x200</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x107</resetValue>
          <resetMask>0x10F</resetMask>
          <fields>
            <field>
              <name>DATA_WIDTH</name>
              <description>Dataframe width. DATA_WIDTH + 1 is the amount of bits in a transmitted data frame. This number does not include start, parity and stop bits. For UART mode, the valid range is [3, 8]. For SPI, the valid range is [3, 15]. For I2C the only valid value is 7.</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MSB_FIRST</name>
              <description>Least significant bit first ('0') or most significant bit first ('1'). For I2C, this field should be '1'.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TX_FIFO_CTRL</name>
          <description>Transmitter FIFO control register.</description>
          <addressOffset>0x204</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x300FF</resetMask>
          <fields>
            <field>
              <name>TRIGGER_LEVEL</name>
              <description>Trigger level. When the transmitter FIFO has less entries than the number of this field, a transmitter trigger event INTR_TX.TRIGGER is generated.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLEAR</name>
              <description>When '1', the transmitter FIFO and transmitter shift register are cleared/invalidated. Invalidation will last for as long as this field is '1'. If a quick clear/invalidation is required, the field should be set to '1' and be followed by a set to '0'. If a clear/invalidation is required for an extended time period, the field should be set to '1' during the complete time period.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FREEZE</name>
              <description>When '1', hardware reads from the transmitter FIFO do not remove FIFO entries. Freeze will not advance the TX FIFO read pointer.</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TX_FIFO_STATUS</name>
          <description>Transmitter FIFO status register.</description>
          <addressOffset>0x208</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFF81FF</resetMask>
          <fields>
            <field>
              <name>USED</name>
              <description>Amount of entries in the transmitter FIFO. The value of this field ranges from 0 to FF_DATA_NR (EZ_DATA_NR/2).</description>
              <bitRange>[8:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SR_VALID</name>
              <description>Indicates whether the TX shift registers holds a valid data frame ('1') or not ('0'). The shift register can be considered the top of the TX FIFO (the data frame is not included in the USED field of the TX FIFO). The shift register is a working register and holds the data frame that is currently transmitted (when the protocol state machine is transmitting a data frame) or the data frame that is tranmitted next (when the protocol state machine is not transmitting a data frame).</description>
              <bitRange>[15:15]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>RD_PTR</name>
              <description>FIFO read pointer: FIFO location from which a data frame is read by the hardware.</description>
              <bitRange>[23:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>WR_PTR</name>
              <description>FIFO write pointer: FIFO location at which a new data frame is written.</description>
              <bitRange>[31:24]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TX_FIFO_WR</name>
          <description>Transmitter FIFO write register.</description>
          <addressOffset>0x240</addressOffset>
          <size>32</size>
          <access>write-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>DATA</name>
              <description>Data frame written into the transmitter FIFO. Behavior is similar to that of a PUSH operation. Note that when CTRL.BYTE_MODE is '1', only DATA[7:0] are used.

A write to a full TX FIFO sets INTR_TX.OVERFLOW to '1'.</description>
              <bitRange>[15:0]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RX_CTRL</name>
          <description>Receiver control register.</description>
          <addressOffset>0x300</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x107</resetValue>
          <resetMask>0x30F</resetMask>
          <fields>
            <field>
              <name>DATA_WIDTH</name>
              <description>Dataframe width. DATA_WIDTH + 1 is the expected amount of bits in received data frame. This number does not include start, parity and stop bits. For UART mode, the valid range is [3, 8]. For SPI, the valid range is [3, 15]. For I2C the only valid value is 7. In EZ mode (for both SPI and I2C), the only valid value is 7.</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MSB_FIRST</name>
              <description>Least significant bit first ('0') or most significant bit first ('1'). For I2C, this field should be '1'.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MEDIAN</name>
              <description>Median filter. When '1', a digital 3 taps median filter is performed on input interface lines. This filter should reduce the susceptability to errors. However, its requires higher oversampling values. For UART IrDA submode, this field should always be '1'.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RX_FIFO_CTRL</name>
          <description>Receiver FIFO control register.</description>
          <addressOffset>0x304</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x300FF</resetMask>
          <fields>
            <field>
              <name>TRIGGER_LEVEL</name>
              <description>Trigger level. When the receiver FIFO has more entries than the number of this field, a receiver trigger event INTR_RX.TRIGGER is generated.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLEAR</name>
              <description>When '1', the receiver FIFO and receiver shift register are cleared/invalidated. Invalidation will last for as long as this field is '1'. If a quick clear/invalidation is required, the field should be set to '1' and be followed by a set to '0'. If a clear/invalidation is required for an extended time period, the field should be set to '1' during the complete time period.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FREEZE</name>
              <description>When '1', hardware writes to the receiver FIFO have no effect. Freeze will not advance the RX FIFO write pointer.</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RX_FIFO_STATUS</name>
          <description>Receiver FIFO status register.</description>
          <addressOffset>0x308</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFF81FF</resetMask>
          <fields>
            <field>
              <name>USED</name>
              <description>Amount of entries in the receiver FIFO. The value of this field ranges from 0 to FF_DATA_NR (EZ_DATA_NR/2).</description>
              <bitRange>[8:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SR_VALID</name>
              <description>Indicates whether the RX shift registers holds a (partial) valid data frame ('1') or not ('0'). The shift register can be considered the bottom of the RX FIFO (the data frame is not included in the USED field of the RX FIFO). The shift register is a working register and holds the data frame that is currently being received (when the protocol state machine is receiving a data frame).</description>
              <bitRange>[15:15]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>RD_PTR</name>
              <description>FIFO read pointer: FIFO location from which a data frame is read.</description>
              <bitRange>[23:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>WR_PTR</name>
              <description>FIFO write pointer: FIFO location at which a new data frame is written by the hardware.</description>
              <bitRange>[31:24]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RX_MATCH</name>
          <description>Slave address and mask register.</description>
          <addressOffset>0x310</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF00FF</resetMask>
          <fields>
            <field>
              <name>ADDR</name>
              <description>Slave device address.

In UART multi-processor mode, all 8 bits are used.

In I2C slave mode, only bits 7 down to 1 are used. This reflects the organization of the first transmitted byte in a I2C transfer: the first 7 bits represent the address of the addressed slave, and the last 1 bit is a read/write indicator ('0': write, '1': read).</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MASK</name>
              <description>Slave device address mask. This field is a mask that specifies which of the ADDR field bits in the ADDR field take part in the matching of the slave address: MATCH = ((ADDR &amp; MASK) == ('slave address' &amp; MASK)).</description>
              <bitRange>[23:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RX_FIFO_RD</name>
          <description>Receiver FIFO read register.</description>
          <addressOffset>0x340</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>DATA</name>
              <description>Data read from the receiver FIFO. Reading a data frame will remove the data frame from the FIFO; i.e. behavior is similar to that of a POP operation. Note that when CTRL.BYTE_MODE is '1', only DATA[7:0] are used.

This register has a side effect when read by software: a data frame is removed from the FIFO. This may be undesirable during debug; i.e. a read during debug should NOT have a side effect. To this end, the IP uses the AHB-Lite 'hmaster[0]' input signal. When this signal is '1' in the address cycle of a bus transfer, a read transfer will not have a side effect. As a result, a read from this register will not remove a data frame from the FIFO. As a result, a read from this register behaves as a read from the SCB_RX_FIFO_RD_SILENT register.

A read from an empty RX FIFO sets INTR_RX.UNDERFLOW to '1'.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RX_FIFO_RD_SILENT</name>
          <description>Receiver FIFO read register.</description>
          <addressOffset>0x344</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>DATA</name>
              <description>Data read from the receiver FIFO. Reading a data frame will NOT remove the data frame from the FIFO; i.e. behavior is similar to that of a PEEK operation. Note that when CTRL.BYTE_MODE is '1', only DATA[7:0] are used.

A read from an empty RX FIFO sets INTR_RX.UNDERFLOW to '1'.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_CAUSE</name>
          <description>Active clocked interrupt signal register</description>
          <addressOffset>0xE00</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3F</resetMask>
          <fields>
            <field>
              <name>M</name>
              <description>Master interrupt active ('interrupt_master'): INTR_M_MASKED != 0.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>S</name>
              <description>Slave interrupt active ('interrupt_slave'): INTR_S_MASKED != 0.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>TX</name>
              <description>Transmitter interrupt active ('interrupt_tx'): INTR_TX_MASKED != 0.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>RX</name>
              <description>Receiver interrupt active ('interrupt_rx'): INTR_RX_MASKED != 0.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>I2C_EC</name>
              <description>Externally clock I2C interrupt active ('interrupt_i2c_ec'): INTR_I2C_EC_MASKED != 0.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SPI_EC</name>
              <description>Externally clocked SPI interrupt active ('interrupt_spi_ec'): INTR_SPI_EC_MASKED != 0.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_I2C_EC</name>
          <description>Externally clocked I2C interrupt request register</description>
          <addressOffset>0xE80</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xF</resetMask>
          <fields>
            <field>
              <name>WAKE_UP</name>
              <description>Wake up request. Active on incoming slave request (with address match).

Only used when EC_AM is '1'.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EZ_STOP</name>
              <description>STOP detection. Activated on the end of a every transfer (I2C STOP).

Only available for a slave request with an address match, in EZ and CMD_RESP modes, when EC_OP is '1'.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EZ_WRITE_STOP</name>
              <description>STOP detection after a write transfer occurred. Activated on the end of a write transfer (I2C STOP). This event is an indication that a buffer memory location has been written to. For EZ mode: a  transfer that only writes the base address does NOT activate this event. 

Only available for a slave request with an address match, in EZ and CMD_RESP modes, when EC_OP is '1'.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EZ_READ_STOP</name>
              <description>STOP detection after a read transfer occurred. Activated on the end of a read transfer (I2C STOP). This event is an indication that a buffer memory location has been read from.

Only available for a slave request with an address match, in EZ and CMD_RESP modes, when EC_OP is '1'.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_I2C_EC_MASK</name>
          <description>Externally clocked I2C interrupt mask register</description>
          <addressOffset>0xE88</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xF</resetMask>
          <fields>
            <field>
              <name>WAKE_UP</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EZ_STOP</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EZ_WRITE_STOP</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EZ_READ_STOP</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_I2C_EC_MASKED</name>
          <description>Externally clocked I2C interrupt masked register</description>
          <addressOffset>0xE8C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xF</resetMask>
          <fields>
            <field>
              <name>WAKE_UP</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>EZ_STOP</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>EZ_WRITE_STOP</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>EZ_READ_STOP</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_SPI_EC</name>
          <description>Externally clocked SPI interrupt request register</description>
          <addressOffset>0xEC0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xF</resetMask>
          <fields>
            <field>
              <name>WAKE_UP</name>
              <description>Wake up request. Active on incoming slave request when externally clocked selection is '1'.

Only used when EC_AM is '1'.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EZ_STOP</name>
              <description>STOP detection. Activated on the end of a every transfer (SPI deselection).

Only available in EZ and CMD_RESP mode and when EC_OP is '1'.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EZ_WRITE_STOP</name>
              <description>STOP detection after a write transfer occurred. Activated on the end of a write transfer (SPI deselection). This event is an indication that a buffer memory location has been written to. For EZ mode: a  transfer that only writes the base address does NOT activate this event. 

Only used in EZ and CMD_RESP modes and when EC_OP is '1'.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EZ_READ_STOP</name>
              <description>STOP detection after a read transfer occurred. Activated on the end of a read transfer (SPI deselection). This event is an indication that a buffer memory location has been read from.

Only used in EZ and CMD_RESP modes and when EC_OP is '1'.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_SPI_EC_MASK</name>
          <description>Externally clocked SPI interrupt mask register</description>
          <addressOffset>0xEC8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xF</resetMask>
          <fields>
            <field>
              <name>WAKE_UP</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EZ_STOP</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EZ_WRITE_STOP</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EZ_READ_STOP</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_SPI_EC_MASKED</name>
          <description>Externally clocked SPI interrupt masked register</description>
          <addressOffset>0xECC</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xF</resetMask>
          <fields>
            <field>
              <name>WAKE_UP</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>EZ_STOP</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>EZ_WRITE_STOP</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>EZ_READ_STOP</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_M</name>
          <description>Master interrupt request register.</description>
          <addressOffset>0xF00</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x317</resetMask>
          <fields>
            <field>
              <name>I2C_ARB_LOST</name>
              <description>I2C master lost arbitration: the value driven by the master on the SDA line is not the same as the value observed on the SDA line.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_NACK</name>
              <description>I2C master negative acknowledgement. Set to '1', when the master receives a NACK (typically after the master transmitted the slave address or TX data).</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_ACK</name>
              <description>I2C master acknowledgement. Set to '1', when the master receives a ACK (typically after the master transmitted the slave address or TX data).</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_STOP</name>
              <description>I2C master STOP. Set to '1', when the master has transmitted a STOP.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_BUS_ERROR</name>
              <description>I2C master bus error (unexpected detection of START or STOP condition).</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SPI_DONE</name>
              <description>SPI master transfer done event: all data frames in the transmit FIFO are sent and the transmit FIFO and shift register are empty.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_M_SET</name>
          <description>Master interrupt set request register</description>
          <addressOffset>0xF04</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x317</resetMask>
          <fields>
            <field>
              <name>I2C_ARB_LOST</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_NACK</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_ACK</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_STOP</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_BUS_ERROR</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SPI_DONE</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_M_MASK</name>
          <description>Master interrupt mask register.</description>
          <addressOffset>0xF08</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x317</resetMask>
          <fields>
            <field>
              <name>I2C_ARB_LOST</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_NACK</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_ACK</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_STOP</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_BUS_ERROR</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SPI_DONE</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_M_MASKED</name>
          <description>Master interrupt masked request register</description>
          <addressOffset>0xF0C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x317</resetMask>
          <fields>
            <field>
              <name>I2C_ARB_LOST</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>I2C_NACK</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>I2C_ACK</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>I2C_STOP</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>I2C_BUS_ERROR</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SPI_DONE</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_S</name>
          <description>Slave interrupt request register.</description>
          <addressOffset>0xF40</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFF</resetMask>
          <fields>
            <field>
              <name>I2C_ARB_LOST</name>
              <description>I2C slave lost arbitration: the value driven on the SDA line is not the same as the value observed on the SDA line (while the SCL line is '1'). This should not occur, it represents erroneous I2C bus behavior. In case of lost arbitration, the I2C slave state machine abort the ongoing transfer. The Firmware may decide to clear the TX and RX FIFOs in case of this error.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_NACK</name>
              <description>I2C slave negative acknowledgement received. Set to '1', when the slave receives a NACK (typically after the slave transmitted TX data).</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_ACK</name>
              <description>I2C slave acknowledgement received. Set to '1', when the slave receives a ACK (typically after the slave transmitted TX data).</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_WRITE_STOP</name>
              <description>I2C STOP event for I2C write transfer intended for this slave (address matching is performed). Set to '1', when STOP or REPEATED START event is detected. The REPEATED START event is included in this interrupt cause such that the I2C transfers separated by a REPEATED START can be distinguished and potentially treated separately by the Firmware. Note that the second I2C transfer (after a REPEATED START) may be to a different slave address.

In non EZ mode, the event is detected on any I2C write transfer intended for this slave. Note that a I2C write address intended for the slave (address is matching and a it is a write transfer) will result in a I2C_WRITE_STOP event independent of whether the I2C address is ACK'd or NACK'd.

In EZ mode, the event is detected only on I2C write transfers that have EZ data written to the memory structure (an I2C write transfer that only communicates an I2C address and EZ address, will not result in this event being detected).</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_STOP</name>
              <description>I2C STOP event for I2C (read or write) transfer intended for this slave (address matching is performed). Set to '1', when STOP or REPEATED START event is detected. The REPEATED START event is included in this interrupt cause such that the I2C transfers separated by a REPEATED START can be distinguished and potentially treated separately by the Firmware. Note that the second I2C transfer (after a REPEATED START) may be to a different slave address.

The event is detected on any I2C transfer intended for this slave. Note that a I2C address intended for the slave (address is matching) will result in a I2C_STOP event independent of whether the I2C address is ACK'd or NACK'd.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_START</name>
              <description>I2C slave START received. Set to '1', when START or REPEATED START event is detected.

In the case of externally clocked address matching (CTRL.EC_AM_MODE is '1') AND clock stretching is performed (till the internally clocked logic takes over) (I2C_CTRL.S_NOT_READY_ADDR_NACK is '0'), this field is NOT set. The Firmware should use INTR_S_EC.WAKE_UP, INTR_S.I2C_ADDR_MATCH and INTR_S.I2C_GENERAL.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_ADDR_MATCH</name>
              <description>I2C slave matching address received. If CTRL.ADDR_ACCEPT, the received address (including the R/W bit) is available in the RX FIFO. In the case of externally clocked address matching (CTRL.EC_AM_MODE is '1') and internally clocked operation (CTRL.EC_OP_MODE is '0'), this field is set when the event is detected.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_GENERAL</name>
              <description>I2C slave general call address received.  If CTRL.ADDR_ACCEPT, the received address 0x00 (including the R/W bit) is available in the RX FIFO.   In the case of externally clocked address matching (CTRL.EC_AM_MODE is '1') and internally clocked operation (CTRL.EC_OP_MODE is '0'), this field is set when the event is detected.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_BUS_ERROR</name>
              <description>I2C slave bus error (unexpected detection of START or STOP condition). This should not occur, it represents erroneous I2C bus behavior. In case of a bus error, the I2C slave state machine abort the ongoing transfer. The Firmware may decide to clear the TX and RX FIFOs in case of this error.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SPI_EZ_WRITE_STOP</name>
              <description>SPI slave deselected after a write EZ SPI transfer occurred.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SPI_EZ_STOP</name>
              <description>SPI slave deselected after any EZ SPI transfer occurred.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SPI_BUS_ERROR</name>
              <description>SPI slave deselected at an unexpected time in the SPI transfer. The Firmware may decide to clear the TX and RX FIFOs in case of this error.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_S_SET</name>
          <description>Slave interrupt set request register.</description>
          <addressOffset>0xF44</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFF</resetMask>
          <fields>
            <field>
              <name>I2C_ARB_LOST</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_NACK</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_ACK</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_WRITE_STOP</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_STOP</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_START</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_ADDR_MATCH</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_GENERAL</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_BUS_ERROR</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SPI_EZ_WRITE_STOP</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SPI_EZ_STOP</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SPI_BUS_ERROR</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_S_MASK</name>
          <description>Slave interrupt mask register.</description>
          <addressOffset>0xF48</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFF</resetMask>
          <fields>
            <field>
              <name>I2C_ARB_LOST</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_NACK</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_ACK</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_WRITE_STOP</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_STOP</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_START</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_ADDR_MATCH</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_GENERAL</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_BUS_ERROR</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SPI_EZ_WRITE_STOP</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SPI_EZ_STOP</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SPI_BUS_ERROR</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_S_MASKED</name>
          <description>Slave interrupt masked request register</description>
          <addressOffset>0xF4C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFF</resetMask>
          <fields>
            <field>
              <name>I2C_ARB_LOST</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>I2C_NACK</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>I2C_ACK</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>I2C_WRITE_STOP</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>I2C_STOP</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>I2C_START</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>I2C_ADDR_MATCH</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>I2C_GENERAL</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>I2C_BUS_ERROR</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SPI_EZ_WRITE_STOP</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SPI_EZ_STOP</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SPI_BUS_ERROR</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_TX</name>
          <description>Transmitter interrupt request register.</description>
          <addressOffset>0xF80</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x7F3</resetMask>
          <fields>
            <field>
              <name>TRIGGER</name>
              <description>Less entries in the TX FIFO than the value specified by TX_FIFO_CTRL. 

Only used in FIFO mode.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>NOT_FULL</name>
              <description>TX FIFO is not full. Dependent on CTRL.BYTE_MODE: (FF_DATA_NR = EZ_DATA_NR/2)
BYTE_MODE is '0': # entries != FF_DATA_NR/2.
BYTE_MODE is '1': # entries != FF_DATA_NR.

Only used in FIFO mode.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EMPTY</name>
              <description>TX FIFO is empty; i.e. it has 0 entries.

Only used in FIFO mode.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OVERFLOW</name>
              <description>Attempt to write to a full TX FIFO.

Only used in FIFO mode.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UNDERFLOW</name>
              <description>Attempt to read from an empty TX FIFO. This happens when the IP is ready to transfer data and EMPTY is '1'.

Only used in FIFO mode.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BLOCKED</name>
              <description>AHB-Lite write transfer can not get access to the EZ memory (EZ data access), due to an externally clocked EZ access. This may happen when STATUS.EC_BUSY is '1'.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UART_NACK</name>
              <description>UART transmitter received a negative acknowledgement in SmartCard mode. Set to '1', when event is detected. Write with '1' to clear bit.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UART_DONE</name>
              <description>UART transmitter done event. This happens when the IP is done transferring all data in the TX FIFO; i.e. EMPTY is '1'. Set to '1', when event is detected. Write with '1' to clear bit.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UART_ARB_LOST</name>
              <description>UART lost arbitration: the value driven on the TX line is not the same as the value observed on the RX line. This condition event is usefull when transmitter and receiver share a TX/RX line. This is the case in LIN or SmartCard modes. Set to '1', when event is detected. Write with '1' to clear bit.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_TX_SET</name>
          <description>Transmitter interrupt set request register</description>
          <addressOffset>0xF84</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x7F3</resetMask>
          <fields>
            <field>
              <name>TRIGGER</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>NOT_FULL</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EMPTY</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OVERFLOW</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UNDERFLOW</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BLOCKED</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UART_NACK</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UART_DONE</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UART_ARB_LOST</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_TX_MASK</name>
          <description>Transmitter interrupt mask register.</description>
          <addressOffset>0xF88</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x7F3</resetMask>
          <fields>
            <field>
              <name>TRIGGER</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>NOT_FULL</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EMPTY</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OVERFLOW</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UNDERFLOW</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BLOCKED</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UART_NACK</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UART_DONE</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UART_ARB_LOST</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_TX_MASKED</name>
          <description>Transmitter interrupt masked request register</description>
          <addressOffset>0xF8C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x7F3</resetMask>
          <fields>
            <field>
              <name>TRIGGER</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>NOT_FULL</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>EMPTY</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>OVERFLOW</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>UNDERFLOW</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>BLOCKED</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>UART_NACK</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>UART_DONE</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>UART_ARB_LOST</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_RX</name>
          <description>Receiver interrupt request register.</description>
          <addressOffset>0xFC0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFED</resetMask>
          <fields>
            <field>
              <name>TRIGGER</name>
              <description>More entries in the RX FIFO than the value specified by TRIGGER_LEVEL in SCB_RX_FIFO_CTL.

Only used in FIFO mode.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>NOT_EMPTY</name>
              <description>RX FIFO is not empty.

Only used in FIFO mode.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FULL</name>
              <description>RX FIFO is full. Note that received data frames are lost when the RX FIFO is full. Dependent on CTRL.BYTE_MODE: (FF_DATA_NR = EZ_DATA_NR/2)
BYTE_MODE is '0': # entries == FF_DATA_NR/2.
BYTE_MODE is '1': # entries == FF_DATA_NR.

Only used in FIFO mode.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OVERFLOW</name>
              <description>Attempt to write to a full RX FIFO. Note: in I2C mode, the OVERFLOW is set when a data frame is received and the RX FIFO is full, independent of whether it is ACK'd or NACK'd.

Only used in FIFO mode.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UNDERFLOW</name>
              <description>Attempt to read from an empty RX FIFO.

Only used in FIFO mode.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BLOCKED</name>
              <description>AHB-Lite read transfer can not get access to the EZ memory (EZ_DATA accesses), due to an externally clocked EZ access. This may happen when STATUS.EC_BUSY is '1'.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FRAME_ERROR</name>
              <description>Frame error in received data frame. Set to '1', when event is detected. Write with '1' to clear bit. This can be either a start or stop bit(s) error:
Start bit error: after the detection of the beginning of a start bit period (RX line changes from '1' to '0'), the middle of the start bit period is sampled erroneously (RX line is '1').  Note: a start bit error is detected BEFORE a data frame is received.
Stop bit error: the RX line is sampled as '0', but a '1' was expected. Note: a stop bit error may result in failure to receive successive data frame(s). Note: a stop bit error is detected AFTER a data frame is received.

A stop bit error is detected after a data frame is received, and the UART_RX_CTL.DROP_ON_FRAME_ERROR field specifies whether the received frame is dropped or send to the RX FIFO. If UART_RX_CTL.DROP_ON_FRAME_ERROR is '1', the received data frame is dropped. If UART_RX_CTL.DROP_ON_FRAME_ERROR is '0', the received data frame is send to the RX FIFO. Note that Firmware can only identify the erroneous data frame in the RX FIFO if it is fast enough to read the data frame before the hardware writes a next data frame into the RX FIFO; i.e. the RX FIFO does not have error flags to tag erroneous data frames.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PARITY_ERROR</name>
              <description>Parity error in received data frame. Set to '1', when event is detected. Write with '1' to clear bit. If UART_RX_CTL.DROP_ON_PARITY_ERROR is '1', the received frame is dropped. If UART_RX_CTL.DROP_ON_PARITY_ERROR is '0', the received frame is send to the RX FIFO. In SmartCard submode, negatively acknowledged data frames generate a parity error. Note that Firmware can only identify the erroneous data frame in the RX FIFO if it is fast enough to read the data frame before the hardware writes a next data frame into the RX FIFO.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BAUD_DETECT</name>
              <description>LIN baudrate detection is completed.  The receiver software uses the UART_RX_STATUS.BR_COUNTER value to set the right IP clock (from the programmable clock IP) to guarantee successful receipt of the first LIN data frame (Protected Identifier Field) after the synchronization byte. Set to '1', when event is detected. Write with '1' to clear bit.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BREAK_DETECT</name>
              <description>Break detection is successful: the line is '0' for UART_RX_CTRL.BREAK_WIDTH + 1 bit period. Can occur at any time to address unanticipated break fields; i.e. 'break-in-data' is supported. This feature is supported for the UART standard and LIN submodes. For the UART standard submodes, ongoing receipt of data frames is NOT affected; i.e. Firmware is expected to take the proper action. For the LIN submode, possible ongoing receipt of a data frame is stopped and the (partially) received data frame is dropped and baud rate detection is started. Set to '1', when event is detected. Write with '1' to clear bit.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_RX_SET</name>
          <description>Receiver interrupt set request register.</description>
          <addressOffset>0xFC4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFED</resetMask>
          <fields>
            <field>
              <name>TRIGGER</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>NOT_EMPTY</name>
              <description>Write with '1' to set corresponding bit in interrupt status register.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FULL</name>
              <description>Write with '1' to set corresponding bit in interrupt status register.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OVERFLOW</name>
              <description>Write with '1' to set corresponding bit in interrupt status register.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UNDERFLOW</name>
              <description>Write with '1' to set corresponding bit in interrupt status register.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BLOCKED</name>
              <description>Write with '1' to set corresponding bit in interrupt status register.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FRAME_ERROR</name>
              <description>Write with '1' to set corresponding bit in interrupt status register.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PARITY_ERROR</name>
              <description>Write with '1' to set corresponding bit in interrupt status register.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BAUD_DETECT</name>
              <description>Write with '1' to set corresponding bit in interrupt status register.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BREAK_DETECT</name>
              <description>Write with '1' to set corresponding bit in interrupt status register.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_RX_MASK</name>
          <description>Receiver interrupt mask register.</description>
          <addressOffset>0xFC8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFED</resetMask>
          <fields>
            <field>
              <name>TRIGGER</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>NOT_EMPTY</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FULL</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OVERFLOW</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UNDERFLOW</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BLOCKED</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FRAME_ERROR</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PARITY_ERROR</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BAUD_DETECT</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BREAK_DETECT</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_RX_MASKED</name>
          <description>Receiver interrupt masked request register</description>
          <addressOffset>0xFCC</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFED</resetMask>
          <fields>
            <field>
              <name>TRIGGER</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>NOT_EMPTY</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>FULL</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>OVERFLOW</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>UNDERFLOW</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>BLOCKED</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>FRAME_ERROR</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>PARITY_ERROR</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>BAUD_DETECT</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>BREAK_DETECT</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral derivedFrom="SCB0">
      <name>SCB1</name>
      <baseAddress>0x40090000</baseAddress>
    </peripheral>
    <peripheral>
      <name>LCD</name>
      <description>LCD Controller Block</description>
      <baseAddress>0x400A0000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>65536</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>ID</name>
          <description>ID &amp; Revision</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x1F0F0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ID</name>
              <description>the ID of LCD controller peripheral is 0xF0F0</description>
              <bitRange>[15:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>REVISION</name>
              <description>the version number is 0x0001</description>
              <bitRange>[31:16]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DIVIDER</name>
          <description>LCD Divider Register</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SUBFR_DIV</name>
              <description>Input clock frequency divide value, to generate the 1/4 sub-frame period. The sub-frame period is  4*(SUBFR_DIV+1) cycles long.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DEAD_DIV</name>
              <description>Length of the dead time period in cycles.  When set to  zero, no dead time period exists.</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CONTROL</name>
          <description>LCD Configuration Register</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x80000F7F</resetMask>
          <fields>
            <field>
              <name>LS_EN</name>
              <description>Low speed (LS) generator enable
1: enable
0: disable</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HS_EN</name>
              <description>High speed (HS) generator enable
1: enable
0: disable</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LCD_MODE</name>
              <description>HS/LS Mode selection</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>LS</name>
                  <description>Select Low Speed (32kHz) Generator (Works in Active, Sleep and DeepSleep power modes).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HS</name>
                  <description>Select High Speed (system clock) Generator (Works in Active and Sleep power modes only).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TYPE</name>
              <description>LCD driving waveform type configuration.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>TYPE_A</name>
                  <description>Type A - Each frame addresses each COM pin only once with a balanced (DC=0) waveform.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>TYPE_B</name>
                  <description>Type B - Each frame addresses each COM pin twice in sequence with a positive and negative waveform that together are balanced (DC=0).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>OP_MODE</name>
              <description>Driving mode configuration</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>PWM</name>
                  <description>PWM Mode</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CORRELATION</name>
                  <description>Digital Correlation Mode</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BIAS</name>
              <description>PWM bias selection</description>
              <bitRange>[6:5]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>HALF</name>
                  <description>1/2 Bias</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>THIRD</name>
                  <description>1/3 Bias</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>FOURTH</name>
                  <description>1/4 Bias (not supported by LS generator)</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>FIFTH</name>
                  <description>1/5 Bias (not supported by LS generator)</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>COM_NUM</name>
              <description>The number of COM connections minus 2. So:
0: 2 COM's
1: 3 COM's
...
13: 15 COM's
14: 16 COM's
15: undefined</description>
              <bitRange>[11:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LS_EN_STAT</name>
              <description>LS enable status bit.  This bit is a copy of LS_EN that is synchronized to the low speed clock domain and back to the system clock domain. Firmware can use this bit to observe whether LS_EN has taken effect in the low speed clock domain.  Firmware should never change the configuration for the LS generator without ensuring this bit is 0.
The following procedure should be followed to disable the LS generator:
1. If LS_EN=0 we are done.  Exit the procedure.
2. Check that LS_EN_STAT=1.  If not, wait until it is. This will catch the case of a recent enable (LS_EN=1) that has not taken effect yet.
3. Set LS_EN=0.
4. Wait until LS_EN_STAT=0.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>8</dim>
          <dimIncrement>4</dimIncrement>
          <name>DATA0[%s]</name>
          <description>LCD Pin Data Registers</description>
          <addressOffset>0x100</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DATA</name>
              <description>Bits [4i+3:4i] represent the pin data for pin [i] for COMS 1-4 (COM1 is lsb).</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>8</dim>
          <dimIncrement>4</dimIncrement>
          <name>DATA1[%s]</name>
          <description>LCD Pin Data Registers</description>
          <addressOffset>0x200</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DATA</name>
              <description>Bits [4i+3:4i] represent the pin data for pin [i] for COMS 5-8 (COM5 is lsb).</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>8</dim>
          <dimIncrement>4</dimIncrement>
          <name>DATA2[%s]</name>
          <description>LCD Pin Data Registers</description>
          <addressOffset>0x300</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DATA</name>
              <description>Bits [4i+3:4i] represent the pin data for pin [i] for COMS 9-12 (COM9 is lsb).</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>8</dim>
          <dimIncrement>4</dimIncrement>
          <name>DATA3[%s]</name>
          <description>LCD Pin Data Registers</description>
          <addressOffset>0x400</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DATA</name>
              <description>Bits [4i+3:4i] represent the pin data for pin [i] for COMS 13-16 (COM13 is lsb).</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>CSD0</name>
      <description>Capsense Controller</description>
      <headerStructName>CSD</headerStructName>
      <baseAddress>0x400B0000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>4096</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>CONFIG</name>
          <description>Configuration and Control</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x4000000</resetValue>
          <resetMask>0xCF0C5370</resetMask>
          <fields>
            <field>
              <name>FILTER_DELAY</name>
              <description>This value determines the number of cycles that the digital filter makes the CSDCMP output ignored while the counter counts and IDAC is on. 
When set to 0 the digital filter is off. When set to any other value the ignoring will last for FILTER_DELAY clk_csd cycles after the start of each measurement and from the first comparator trip to the end of each measurement.</description>
              <bitRange>[6:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SHIELD_DELAY</name>
              <description>Selects the delay by which csd_shield is delayed relative to csd_sense.</description>
              <bitRange>[9:8]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>OFF</name>
                  <description>Delay line is off, csd_shield=csd_sense</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>D5NS</name>
                  <description>Introduces a 5ns delay (typ)</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>D10NS</name>
                  <description>Introduces a 10ns delay (typ)</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>D20NS</name>
                  <description>Introduces a 20ns delay (typ)</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SENSE_EN</name>
              <description>Enables the sense modulator output. 
0: all switches, static or dynamic, are open and IDAC in CSD mode is off
1: switches and IDAC can be closed/on as per MMIO setting and CSD sequencer.</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CHARGE_MODE</name>
              <description>Enable charging of the Cmod/Csh_tank capacitor using the GPIO digital output buffer using the csd_charge signal.  Note that using the GPIO requires proper configuraiton of the GPIO pin.</description>
              <bitRange>[14:14]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>CHARGE_OFF</name>
                  <description>Use this to keep csd_charge signal low. For charging Cmod/Csh_tank capacitor CSD internal switches (HCBV) can be used but that is a separate configuration.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CHARGE_IO</name>
                  <description>Use csd_charge to enable the GPIO Driver to charge capacitor.  The capacitor must be  sensed with HSCMP using the appropriate switches (HMPM or HMPT).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>MUTUAL_CAP</name>
              <description>Enables mutual cap sensing mode</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SELFCAP</name>
                  <description>Self-cap mode (configure sense line as CSD_SENSE)</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>MUTUALCAP</name>
                  <description>Mutual-cap mode (configure Tx line as CSD_SENSE, inverted Tx line as CSD_SHIELD and Rx Line as AMUXA). In this mode the polarity bit of the IDAC is controlled by csd_sense.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CSX_DUAL_CNT</name>
              <description>Enable the use of two counters for MUTUAL cap sensing mode (CSX), do not use when MUTUAL_CAP=0</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>ONE</name>
                  <description>Use one counter for both phases (source and sink).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>TWO</name>
                  <description>Use two counters, separate count for when csd_sense is high and when csd_sense is low.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DSI_COUNT_SEL</name>
              <description>Select what to output  on the dsi_count bus.</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>CSD_RESULT</name>
                  <description>depending on the dsi_count_val_sel input either output  RESULT_VAL1.VALUE (0) or RESULT_VAL2.VALUE (1) on the dsi_count bus. Note that dsi_count_val_sel is not synchronized, i.e. it controls the mux combinatorially.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ADC_RESULT</name>
                  <description>output ADC_RES.VIN_CNT on the dsi_count bus</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DSI_SAMPLE_EN</name>
              <description>Enables the use of the dsi_sample_in input instead of the comparator output to strobe COUNTER.</description>
              <bitRange>[25:25]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SAMPLE_SYNC</name>
              <description>Enables double synchronizing of sample input from DSI (only relevant when DSI_SAMPLE_EN=1).</description>
              <bitRange>[26:26]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DSI_SENSE_EN</name>
              <description>Enables the use of the dsi_sense_in input instead of the internally generated modulation signal to drive csd_sense and csd_shield signals.</description>
              <bitRange>[27:27]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LP_MODE</name>
              <description>Select the power mode for the CSD components (REFGEN, AMBUF, CSDCMP, HSCMP):
0: High Power mode
1: Low Power mode</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ENABLE</name>
              <description>Master enable of the CSDv2 IP.  Must be set to 1 for any CSDv2, ADC or IDAC operation to function.
When 0 all analog components will be off and all switches will be open.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SPARE</name>
          <description>Spare MMIO</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xF</resetMask>
          <fields>
            <field>
              <name>SPARE</name>
              <description>Spare MMIO</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>STATUS</name>
          <description>Status Register</description>
          <addressOffset>0x80</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xF</resetMask>
          <fields>
            <field>
              <name>CSD_CHARGE</name>
              <description>Qualified, and possible inverted value of COMP_OUT that is used to drive GPIO's charging Cmod or Csh_tank.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>CSD_SENSE</name>
              <description>Signal used to drive the Cs switches.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>HSCMP_OUT</name>
              <description>Output of reference buffer comparator used to charge up Cmod and/or Csh_tank (synchronized)</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>C_LT_VREF</name>
                  <description>Vin &lt; Vref</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>C_GT_VREF</name>
                  <description>Vin &gt; Vref</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CSDCMP_OUT</name>
              <description>Output of main sensing comparator (synchronized)</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>STAT_SEQ</name>
          <description>Current Sequencer status</description>
          <addressOffset>0x84</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x70007</resetMask>
          <fields>
            <field>
              <name>SEQ_STATE</name>
              <description>CSD sequencer state</description>
              <bitRange>[2:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>ADC_STATE</name>
              <description>ADC sequencer state (only relevant after SEQ_STATE has reached SAMPLE_NORM and ADC sequencer has started)</description>
              <bitRange>[18:16]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>STAT_CNTS</name>
          <description>Current status counts</description>
          <addressOffset>0x88</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>NUM_CONV</name>
              <description>Current number of conversions remaining when in Sample_* states (note that in AutoZero* states the same down counter is reused to count the cycles)</description>
              <bitRange>[15:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RESULT_VAL1</name>
          <description>Result CSD/CSX accumulation counter value 1</description>
          <addressOffset>0xD0</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFF</resetMask>
          <fields>
            <field>
              <name>VALUE</name>
              <description>Accumulated counter value for this result. In case of Mutual cap with two counters (CSX = config.mutual_cap &amp; config.csx_dual_cnt) this counter counts when csd_sense is high.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>BAD_CONVS</name>
              <description>Number of 'bad' conversion for which the CSD comparator did not trigger within the normal time window, either because Vref was not crossed at all, or if the Vref was already crossed before the window started. This counter is reset when the sequencer is started and will saturate at 255 when more than 255 conversions are bad.</description>
              <bitRange>[23:16]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RESULT_VAL2</name>
          <description>Result CSX accumulation counter value 2</description>
          <addressOffset>0xD4</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>VALUE</name>
              <description>Only used in case of Mutual cap with two counters (CSX = config.mutual_cap &amp; config.csx_dual_cnt), this counter counts when csd_sense is low.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ADC_RES</name>
          <description>ADC measurement</description>
          <addressOffset>0xE0</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xC001FFFF</resetMask>
          <fields>
            <field>
              <name>VIN_CNT</name>
              <description>Count to source/sink Cref1 + Cref2 from Vin to Vrefhi. This is also the current counter value for the HSCMP counter</description>
              <bitRange>[15:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>HSCMP_POL</name>
              <description>Polarity used for IDACB for this last ADC result, 0= source, 1= sink</description>
              <bitRange>[16:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>ADC_OVERFLOW</name>
              <description>This flag is set when the ADC counter overflows. This is an indication to the firmware that the IDACB current level is too low.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>ADC_ABORT</name>
              <description>This flag is set when the ADC sequencer was aborted before tripping HSCMP.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR</name>
          <description>CSD Interrupt Request Register</description>
          <addressOffset>0xF0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x106</resetMask>
          <fields>
            <field>
              <name>SAMPLE</name>
              <description>A normal sample is complete (CSDv1 compatible interrupt)</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INIT</name>
              <description>Coarse initialization complete or Sample initialization complete (the latter is typically ignored)</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ADC_RES</name>
              <description>ADC Result ready</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_SET</name>
          <description>CSD Interrupt set register</description>
          <addressOffset>0xF4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x106</resetMask>
          <fields>
            <field>
              <name>SAMPLE</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INIT</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ADC_RES</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_MASK</name>
          <description>CSD Interrupt mask register</description>
          <addressOffset>0xF8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x106</resetMask>
          <fields>
            <field>
              <name>SAMPLE</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INIT</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ADC_RES</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_MASKED</name>
          <description>CSD Interrupt masked register</description>
          <addressOffset>0xFC</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x106</resetMask>
          <fields>
            <field>
              <name>SAMPLE</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>INIT</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>ADC_RES</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>HSCMP</name>
          <description>High Speed Comparator configuration</description>
          <addressOffset>0x180</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x80000011</resetMask>
          <fields>
            <field>
              <name>HSCMP_EN</name>
              <description>High Speed Comparator enable</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>OFF</name>
                  <description>Disable comparator, output is zero</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ON</name>
                  <description>On, regular operation. Note that CONFIG.LP_MODE determines the power mode level</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>HSCMP_INVERT</name>
              <description>Invert the HSCMP output before it is used to control switches and the CSD sequencer. This bit does not affect the ADC sequencer or the STATUS.HSCMP_OUT</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>AZ_EN</name>
              <description>Auto-Zero enable, allow the Sequencer to Auto-Zero this component</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>AMBUF</name>
          <description>Reference Generator configuration</description>
          <addressOffset>0x184</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3</resetMask>
          <fields>
            <field>
              <name>PWR_MODE</name>
              <description>Amux buffer power level</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>OFF</name>
                  <description>Disable buffer</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NORM</name>
                  <description>On, normal or low power level depending on CONFIG.LP_MODE.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HI</name>
                  <description>On, high or low power level depending on CONFIG.LP_MODE.</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>REFGEN</name>
          <description>Reference Generator configuration</description>
          <addressOffset>0x188</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x9F1F71</resetMask>
          <fields>
            <field>
              <name>REFGEN_EN</name>
              <description>Reference Generator Enable</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>OFF</name>
                  <description>Disable Reference Generator</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ON</name>
                  <description>On, regular operation. Note that CONFIG.LP_MODE determines the power mode level</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BYPASS</name>
              <description>Bypass selected input reference unbuffered to Vrefhi</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>VDDA_EN</name>
              <description>Close Vdda switch to top of resistor string (or Vrefhi?)</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RES_EN</name>
              <description>Resistor string enable; 0= open switch on top of the resistor string (Vreflo=Vssa)</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GAIN</name>
              <description>Select resistor string tap for feedback, 0= minimum vout, 31= maximum vout = vrefhi -&gt; gain=1  (only works if the resistor string is enabled; RES_EN=1)</description>
              <bitRange>[12:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>VREFLO_SEL</name>
              <description>Select resistor string tap for Vreflo/Vreflo_int, 0= minimum vout, 31= maximum vout = vrefhi (only works if the resistor string is enabled; RES_EN=1)</description>
              <bitRange>[20:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>VREFLO_INT</name>
              <description>Ouput the resistor string tap either to Vreflo (0) or Vreflo_int (1).</description>
              <bitRange>[23:23]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CSDCMP</name>
          <description>CSD Comparator configuration</description>
          <addressOffset>0x18C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xB0000331</resetMask>
          <fields>
            <field>
              <name>CSDCMP_EN</name>
              <description>CSD Comparator Enable</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>OFF</name>
                  <description>Disable comparator, output is zero</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ON</name>
                  <description>On, regular operation. Note that CONFIG.LP_MODE determines the power mode level</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>POLARITY_SEL</name>
              <description>Select which IDAC polarity to use to detect CSDCMP triggering</description>
              <bitRange>[5:4]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>IDACA_POL</name>
                  <description>Use idaca_pol (firmware setting with CSX and optionally DSI mixed in) to determine the direction, this is the most common use-case, used for normal CSD and normal CSX</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>IDACB_POL</name>
                  <description>Use idacb_pol (firmware setting with optional DSI mixed in) to determine the direction, this is only used for normal CSD if IDACB is used i.s.o. IDACA (not common)</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DUAL_POL</name>
                  <description>Use the expression (csd_sense ? idaca_pol : idacb_pol)  to determine the direction, this is only useful for the CSX with DUAL_IDAC use-case</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CMP_PHASE</name>
              <description>Select in what phase(s) the comparator is active. Note, this also determines when a bad conversion is detected, namely at the beginning and end of the comparator active phase (also taking into account FILTER_DELAY and non-overlap).</description>
              <bitRange>[9:8]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>FULL</name>
                  <description>Comparator is active from start of Phi2 and kept active into Phi1. Intended usage: legacy CSD for balancing over a full csd_sense period (non-overlap should be turned off)</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PHI1</name>
                  <description>Comparator is active during Phi1 only. Currently no known use-case.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PHI2</name>
                  <description>Comparator is active during Phi2 only. Intended usage: CSD Low EMI.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PHI1_2</name>
                  <description>Comparator is activated at the start of both Phi1 and Phi2 (non-overlap should be enabled). Intended usage: CSX, or Full-Wave.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CMP_MODE</name>
              <description>Select which signal to output on dsi_sample_out.</description>
              <bitRange>[28:28]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>CSD</name>
                  <description>CSD mode: output the filtered sample signal on dsi_sample_out</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>GP</name>
                  <description>General Purpose mode: output the unfiltered sample unfiltered comparator output, either asynchronous or flopped.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>FEEDBACK_MODE</name>
              <description>This bit controls whether the output directly from the comparator (csdcmp_out) or the flopped version (csdcmp_out_ff) is used. For CSD operation, the selected signal controls the IDAC(s), in GP mode the signal goes out on dsi_sample_out.</description>
              <bitRange>[29:29]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>FLOP</name>
                  <description>Use feedback from sampling flip-flop (used in most modes).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>COMP</name>
                  <description>Use feedback from comparator directly (used in single Cmod mutual cap sensing only)</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>AZ_EN</name>
              <description>Auto-Zero enable, allow the Sequencer to Auto-Zero this component</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>IDACA</name>
          <description>IDACA Configuration</description>
          <addressOffset>0x1C0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3EF0FFF</resetMask>
          <fields>
            <field>
              <name>VAL</name>
              <description>Current value setting for this IDAC (7 bits).</description>
              <bitRange>[6:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>POL_DYN</name>
              <description>Polarity is dynamic, this bit does not influence the logic in the SoftIP, it only goes to the HardIP.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>STATIC</name>
                  <description>Static polarity. Polarity is expected to be stable, so to save power this avoids the shunting of the unused polarity, at the expense of response time.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DYNAMIC</name>
                  <description>Dynamic polarity. Polarity is expected to change frequently (e.g. invert after every csd_sense phase), so to improve response time this keeps the shunt of the unused polarity on at the expense of power.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>POLARITY</name>
              <description>Selects the polarity of the IDAC (sensing operation). Normally the actual polarity depends on this bit, optionally mixed with DSI (see DSI_CTRL_EN) and if LEG1_MODE==CSD also mixed with the CSD configuration and operation. However in mutual cap mode with one IDAC (config.mutual_cap=1 &amp; config.csx_dual_idac=0) the polarity of the IDAC is controlled by csd_sense.</description>
              <bitRange>[9:8]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>VSSA_SRC</name>
                  <description>Normal: switch between Vssa and Cmod.  For non-CSD application, IDAC will source current.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VDDA_SNK</name>
                  <description>Inverted: switch between Vdda and Cmod. For non-CSD application, IDAC will sink current.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SENSE</name>
                  <description>The polarity of the IDAC will follow the csd_sense signal (POL_DYN bit should be set too). The intended usage is for CSX using a single IDAC.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SENSE_INV</name>
                  <description>The polarity of the IDAC will follow the inverted csd_sense signal (POL_DYN bit should be set too). The intended usage is for CSX using a single IDAC.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BAL_MODE</name>
              <description>Balancing mode: only applies to legs configured as CSD.</description>
              <bitRange>[11:10]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>FULL</name>
                  <description>enabled from start of Phi2 until disabled by CSDCMP. Intended usage: legacy CSD for balancing over a full csd_sense period (non-overlap should be turned off)</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PHI1</name>
                  <description>enabled from start of Phi1 and disabled by CSDCMP or at end of Phi1. Enables dual IDAC CSX or Full-Wave, one for sourcing and the other for sinking.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PHI2</name>
                  <description>enabled from start of Phi2 and disabled by CSDCMP or at end of Phi2. Intended usage: CSD Low EMI or  dual IDAC CSX or Full-Wave.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PHI1_2</name>
                  <description>enabled from start of both Phi1 and Phi2 and disabled by CSDCMP or at end of Phi1 or Phi2 (if non-overlap enabled). Intended usage: single IDAC CSX, or Full-Wave.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>LEG1_MODE</name>
              <description>Controls the usage mode of LEG1 and the Polarity bit</description>
              <bitRange>[17:16]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>GP_STATIC</name>
                  <description>General Purpose static mode: LEG1 and POLARITY are controlled by MMIO and optionally mixed with DSI (see DSI_CTRL_EN). No shunting is used, this saves power when off but also any on/off switching will take longer.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>GP</name>
                  <description>General Purpose dynamic mode: LEG1 and POLARITY are controlled by MMIO and optionally mixed with DSI (see DSI_CTRL_EN). Shunting is used, so on/off switching is faster, but power is wasted when the leg is disabled.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CSD_STATIC</name>
                  <description>CSD static mode: LEG1 can only be on when the CSD Sequencer is in the Sample_init or Sample_norm state. In those states LEG1 is controlled by LEG1_EN, csd_sense and the CSD configuration. Polarity is controlled by the CSD configuration and operation. In addition leg1 enable and polarity can optionally be mixed with DSI (see DSI_CTRL_EN). No shunting is used, this saves power when off but also any on/off switching will take longer.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CSD</name>
                  <description>CSD dynamic mode: LEG1 can only be on when the CSD Sequencer is in the Sample_init or Sample_norm state. In thoses states LEG1 is controlled by LEG1_EN, the CSD configuration, csd_sense and the flopped CSDCMP output (CSDCMP_OUT_FF). Polarity is controlled by the CSD configuration and operation. In addition leg1 enable and polarity can optionally be mixed with DSI (see DSI_CTRL_EN). Shunting is used, so on/off switching is faster, but power is wasted when the leg is disabled.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>LEG2_MODE</name>
              <description>Controls the usage mode of LEG2</description>
              <bitRange>[19:18]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>GP_STATIC</name>
                  <description>General Purpose static mode: LEG2 is controlled by MMIO and optionally mixed with DSI (see DSI_CTRL_EN).  No shunting is used, this saves power when off but also any on/off switching will take longer.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>GP</name>
                  <description>General Purpose dynamic mode: LEG2 is controlled by MMIO and optionally mixed with DSI (see DSI_CTRL_EN). Shunting is used, so on/off switching is faster, but power is wasted when the leg is disabled.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CSD_STATIC</name>
                  <description>CSD static mode: LEG2 can only be on when the CSD Sequencer is in the Sample_init or Sample_norm state. In those states LEG2 is controlled by LEG2_EN, csd_sense and the CSD configuration. Polarity is controlled by the CSD configuration and operation. In addition leg2 enable and polarity can optionally be mixed with DSI (see DSI_CTRL_EN). No shunting is used, this saves power when off but also any on/off switching will take longer.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CSD</name>
                  <description>CSD dynamic mode: LEG2 can only be on when the CSD Sequencer is in the Sample_init or Sample_norm state. In those states LEG2 is controlled by LEG2_EN, the CSD configuration, csd_sense and the flopped CSDCMP output (CSDCMP_OUT_FF). In addition leg2 enable can optionally be mixed with DSI (see DSI_CTRL_EN). Shunting is used, so on/off switching is faster, but power is wasted when the leg is disabled.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DSI_CTRL_EN</name>
              <description>Mix DSI inputs with MMIO controls or not (before getting mixed with CSD controls if enabled).
0: no DSI control 
     IDACA_POLARITY = IDACA.POLARITY 
     IDACA_LEG1_EN =  IDACA.LEG1_EN 
     IDACA_LEG2_EN = IDACA.LEG2_EN   
1: Mix MMIO with DSI control
     IDACA_POLARITY = IDACA.POLARITY EXOR dsi_idaca_pol
     IDACA_LEG1_EN =  IDACA.LEG1_EN AND dsi_idaca_leg1_en 
     IDACA_LEG2_EN = IDACA.LEG2_EN AND dsi_idaca_leg2_en</description>
              <bitRange>[21:21]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RANGE</name>
              <description>IDAC multiplier</description>
              <bitRange>[23:22]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>IDAC_LO</name>
                  <description>1 LSB =   37.5 nA</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>IDAC_MED</name>
                  <description>1 LSB =  300 nA</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>IDAC_HI</name>
                  <description>1 LSB = 2400 nA</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>LEG1_EN</name>
              <description>output enable for leg 1 to CSDBUSA</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LEG2_EN</name>
              <description>output enable for leg 2 to CSDBUSA</description>
              <bitRange>[25:25]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>IDACB</name>
          <description>IDACB Configuration</description>
          <addressOffset>0x1C4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x7EF0FFF</resetMask>
          <fields>
            <field>
              <name>VAL</name>
              <description>Current value setting for this IDAC (7 bits).</description>
              <bitRange>[6:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>POL_DYN</name>
              <description>Polarity is dynamic, this bit does not influence the logic in the SoftIP, it only goes to the HardIP.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>STATIC</name>
                  <description>Static polarity. Polarity is expected to be stable, so to save power this avoids the shunting of the unused polarity, at the expense of response time.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DYNAMIC</name>
                  <description>Dynamic polarity. Polarity is expected to change frequently (e.g. invert after every csd_sense phase), so to improve response time this keeps the shunt of the unused polarity on at the expense of power.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>POLARITY</name>
              <description>Selects the polarity of the IDAC (sensing operation). Normally the actual polarity depends on this bit, optionally mixed with DSI (see DSI_CTRL_EN) and if LEG1_EN==1 and LEG1_MODE==CSD also mixed with the CSD configuration and operation. In mutual cap mode however (see config.mutual_cap) the polarity of the IDAC is controlled by csd_sense. If LEG3_EN=1 (the other two legs must be off) then the ADC sequencer controls the IDACB polarity, optionally mixed with DSI.</description>
              <bitRange>[9:8]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>VSSA_SRC</name>
                  <description>Normal: switch between Vssa and Cmod.  For non-CSD application, IDAC will source current.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VDDA_SNK</name>
                  <description>Inverted: switch between Vdda and Cmod. For non-CSD application, IDAC will sink current.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SENSE</name>
                  <description>The polarity of the IDAC will follow the csd_sense signal (POL_DYN bit should be set too). The intended usage is for CSX using a single IDAC.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SENSE_INV</name>
                  <description>The polarity of the IDAC will follow the inverted csd_sense signal (POL_DYN bit should be set too). The intended usage is for CSX using a single IDAC.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BAL_MODE</name>
              <description>same as corresponding IDACA Balancing mode</description>
              <bitRange>[11:10]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>FULL</name>
                  <description>same as corresponding IDACA Balancing mode</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PHI1</name>
                  <description>same as corresponding IDACA Balancing mode</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PHI2</name>
                  <description>same as corresponding IDACA Balancing mode</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PHI1_2</name>
                  <description>same as corresponding IDACA Balancing mode</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>LEG1_MODE</name>
              <description>Controls the usage mode of LEG1 and the Polarity bit</description>
              <bitRange>[17:16]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>GP_STATIC</name>
                  <description>same as corresponding IDACA.LEG1_MODE</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>GP</name>
                  <description>same as corresponding IDACA.LEG1_MODE</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CSD_STATIC</name>
                  <description>same as corresponding IDACA.LEG1_MODE</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CSD</name>
                  <description>same as corresponding IDACA.LEG1_MODE</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>LEG2_MODE</name>
              <description>Controls the usage mode of LEG2</description>
              <bitRange>[19:18]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>GP_STATIC</name>
                  <description>same as corresponding IDACA.LEG2_MODE</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>GP</name>
                  <description>same as corresponding IDACA.LEG2_MODE</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CSD_STATIC</name>
                  <description>same as corresponding IDACA.LEG2_MODE</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CSD</name>
                  <description>same as corresponding IDACA.LEG2_MODE</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DSI_CTRL_EN</name>
              <description>Mix DSI inputs with MMIO controls or not (before getting mixed with CSD controls if enabled)
0: no DSI control
     IDACB_POLARITY = IDACB.POLARITY 
     IDACB_LEG1_EN =  IDACB.LEG1_EN 
     IDACB_LEG2_EN = IDACB.LEG2_EN   
     IDACB_LEG3_EN = IDACB.LEG3_EN   
1: Mix MMIO with DSI control
     IDACB_POLARITY = IDACB.POLARITY EXOR dsi_idacb_pol
     IDACB_LEG1_EN =  IDACB.LEG1_EN AND dsi_idacb_leg1_en 
     IDACB_LEG2_EN = IDACB.LEG2_EN AND dsi_idacb_leg2_en  
     IDACB_LEG3_EN = IDACB.LEG3_EN AND dsi_idacb_leg3_en</description>
              <bitRange>[21:21]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RANGE</name>
              <description>IDAC multiplier</description>
              <bitRange>[23:22]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>IDAC_LO</name>
                  <description>1 LSB =   37.5 nA</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>IDAC_MED</name>
                  <description>1 LSB =  300 nA</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>IDAC_HI</name>
                  <description>1 LSB = 2400 nA</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>LEG1_EN</name>
              <description>output enable for leg 1 to CSDBUSB or CSDBUSA</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LEG2_EN</name>
              <description>output enable for leg 2 to CSDBUSB or CSDBUSA</description>
              <bitRange>[25:25]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LEG3_EN</name>
              <description>output enable for leg3 to CSDBUSC, only allowed when RANGE = IDAC_LO. When this bit is set both other legs should be off.
Note that leg3 can only be used for ADC mode, not GP mode. Which means that leg3 can only be on when the ADC Sequencer is in the ADC_measure or Calib_measure state. In those states  leg3 is controlled by the ADC configuration and the HSCMP output. In addition this leg3 enable bit can optionally be mixed with DSI (see DSI_CTRL_EN).
When LEG3_EN=1 also the IDACB polarity is controlled by the ADC sequencer.</description>
              <bitRange>[26:26]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SW_RES</name>
          <description>Switch Resistance configuration</description>
          <addressOffset>0x1F0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xF00FF</resetMask>
          <fields>
            <field>
              <name>RES_HCAV</name>
              <description>Select resistance or low EMI (slow ramp) for the HCAV switch</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>LOW</name>
                  <description>Low</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>MED</name>
                  <description>Medium</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HIGH</name>
                  <description>High</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LOWEMI</name>
                  <description>Low EMI (slow ramp: 3 switches closed by fixed delay line)</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RES_HCAG</name>
              <description>Select resistance or low EMI for the corresponding switch</description>
              <bitRange>[3:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RES_HCBV</name>
              <description>Select resistance or low EMI for the corresponding switch</description>
              <bitRange>[5:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RES_HCBG</name>
              <description>Select resistance or low EMI for the corresponding switch</description>
              <bitRange>[7:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RES_F1PM</name>
              <description>Select resistance for the corresponding  switch</description>
              <bitRange>[17:16]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>LOW</name>
                  <description>Low</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>MED</name>
                  <description>Medium</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HIGH</name>
                  <description>High</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RSVD</name>
                  <description>N/A</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RES_F2PT</name>
              <description>Select resistance for the corresponding  switch</description>
              <bitRange>[19:18]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SENSE_PERIOD</name>
          <description>Sense clock period</description>
          <addressOffset>0x200</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3F70FFF</resetMask>
          <fields>
            <field>
              <name>SENSE_DIV</name>
              <description>The length-1 of the Sense modulation 'clock' period in clk_csd cycles. For regular CSD one sense clock cycle = one conversion (=phi1+phi2) .
Note this is the base divider, clock dithering may change the actual period length.
Note that SENSE_DIV must be at least 1 and additionally also allow for one clk_hf of non overlap on both phases, i.e. if clk_csd=clk_hf then SENSE_DIV must be &gt;=3.</description>
              <bitRange>[11:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LFSR_SIZE</name>
              <description>Selects the length of the LFSR which determines the LFSR repeat period. The 5 LSB of the LFSR are used  for the clock dithering variation (from -16 to 15) on the base period (was PRS in CSDv1). Whenever the LFSR is used (non zero value in this field) the LFSR_CLEAR bit should also be set.
Caveat do not use clock dithering unless SENSE_DIV &gt; 16, otherwise results are undefined.</description>
              <bitRange>[18:16]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>OFF</name>
                  <description>Don't use clock dithering (=spreadspectrum) (LFSR output value is zero)</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>6B</name>
                  <description>6-bit LFSR (G(x)=X^6  +X^4+X^3+    X+1, period= 63)</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>7B</name>
                  <description>7-bit LFSR (G(x)=X^7  +X^4+X^3+X^2+1, period= 127)</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>9B</name>
                  <description>9-bit LFSR (G(x)=X^9  +X^4+X^3+    X+1, period= 511)</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>10B</name>
                  <description>10-bit LFSR (G(x)=X^10+X^4+X^3+    X+1, period= 1023)</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>8B</name>
                  <description>8-bit LFSR (G(x)=X^8  +X^4+X^3+X^2+1, period= 255)</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>12B</name>
                  <description>12-bit LFSR (G(x)=X^12+X^7+X^4+X^3+1, period= 4095)</description>
                  <value>6</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>LFSR_SCALE</name>
              <description>Shift the LFSR output left by LSFR_SCALE bits before adding to SENSE_DIV. This dithering is disabled when SEL_LSFR_MSB is set.
The clock divider to be used = (SENSE_DIV+1) + (SEL_LSFR_MSB ? 0 : (LFSR_OUT&lt;&lt;LFSR_SCALE)).
Note that the clock divider including the dithering term must fit in 12 bits, otherwise the result is undefined.</description>
              <bitRange>[23:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LFSR_CLEAR</name>
              <description>When set, forces the LFSR to it's initial state (all ones).  This bit is automatically cleared by hardware after the LFSR is cleared, which is at the next clk_csd positive edge. This bit should be set whenever this register is written and the LFSR is used.
Note that the LFSR will also get reset to all ones during the AutoZero_1/2 states.</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SEL_LFSR_MSB</name>
              <description>Use the MSB of configured LSFR size as csd_sense signal. Intended to be used only with bit 8 or 12-bit LFSR size for CSDv1 backward compatibility (PRS). When this bit is set then clock divider dithering is disabled.</description>
              <bitRange>[25:25]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SENSE_DUTY</name>
          <description>Sense clock duty cycle</description>
          <addressOffset>0x204</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xD0FFF</resetMask>
          <fields>
            <field>
              <name>SENSE_WIDTH</name>
              <description>Defines the length of the first phase of the sense clock in clk_csd cycles. 
A value of 0 disables this feature and the duty cycle of csd_sense will be 50 percent, which is equal to SENSE_WIDTH = (SENSE_DIV+1)/2, or when clock dithering is used that becomes [(SENSE_DIV+1) + (LFSR_OUT &lt;&lt; LSFR_SCALE)]/2.  At all times it must be assured that the phases are at least 2 clk_csd cycles (1 for non overlap), if this rule is violated the result is undefined.</description>
              <bitRange>[11:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SENSE_POL</name>
              <description>Polarity of the sense clock
0 = start with low phase (typical for regular negative transfer CSD)
1 = start with high phase</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OVERLAP_PHI1</name>
              <description>NonOverlap or not for Phi1 (csd_sense=0).
0 = Non-overlap for Phi1, the Phi1 signal is  csd_sense inverted except that the signal goes low 1 clk_sample before csd_sense goes high. Intended usage: new low EMI CSD/CSX with static GPIO.
1 = 'Overlap' (= not non-overlap) for Phi1, the Phi1 signal is  csd_sense inverted. Intended usage: legacy CSD with GPIO switching, the GPIO internal circuit ensures that the switches are non-overlapping.</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OVERLAP_PHI2</name>
              <description>Same as OVERLAP_PHI1 but for Phi2 (csd_sense=1).</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SW_HS_P_SEL</name>
          <description>HSCMP Pos input switch Waveform selection</description>
          <addressOffset>0x280</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x11111111</resetMask>
          <fields>
            <field>
              <name>SW_HMPM</name>
              <description>Set HMPM switch
0: static open
1: static closed</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_HMPT</name>
              <description>Set corresponding switch</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_HMPS</name>
              <description>Set corresponding switch</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_HMMA</name>
              <description>Set corresponding switch</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_HMMB</name>
              <description>Set corresponding switch</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_HMCA</name>
              <description>Set corresponding switch</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_HMCB</name>
              <description>Set corresponding switch</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_HMRH</name>
              <description>Set corresponding switch</description>
              <bitRange>[28:28]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SW_HS_N_SEL</name>
          <description>HSCMP Neg input switch Waveform selection</description>
          <addressOffset>0x284</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x77110000</resetMask>
          <fields>
            <field>
              <name>SW_HCCC</name>
              <description>Set corresponding switch</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_HCCD</name>
              <description>Set corresponding switch</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_HCRH</name>
              <description>Select waveform for corresponding switch</description>
              <bitRange>[26:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_HCRL</name>
              <description>Select waveform for corresponding switch</description>
              <bitRange>[30:28]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SW_SHIELD_SEL</name>
          <description>Shielding switches Waveform selection</description>
          <addressOffset>0x288</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x117777</resetMask>
          <fields>
            <field>
              <name>SW_HCAV</name>
              <description>N/A</description>
              <bitRange>[2:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_HCAG</name>
              <description>Select waveform for corresponding switch</description>
              <bitRange>[6:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_HCBV</name>
              <description>N/A</description>
              <bitRange>[10:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_HCBG</name>
              <description>Select waveform for corresponding switch, using csd_shield as base</description>
              <bitRange>[14:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_HCCV</name>
              <description>Set corresponding switch</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_HCCG</name>
              <description>Set corresponding switch
If the ADC is enabled then this switch is directly controlled by the ADC sequencer.</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SW_AMUXBUF_SEL</name>
          <description>Amuxbuffer switches Waveform selection</description>
          <addressOffset>0x290</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x11171110</resetMask>
          <fields>
            <field>
              <name>SW_IRBY</name>
              <description>Set corresponding switch</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_IRLB</name>
              <description>Set corresponding switch</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_ICA</name>
              <description>Set corresponding switch</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_ICB</name>
              <description>Select waveform for corresponding switch</description>
              <bitRange>[18:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_IRLI</name>
              <description>Set corresponding switch</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_IRH</name>
              <description>Set corresponding switch</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_IRL</name>
              <description>Set corresponding switch</description>
              <bitRange>[28:28]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SW_BYP_SEL</name>
          <description>AMUXBUS bypass switches Waveform selection</description>
          <addressOffset>0x294</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x111000</resetMask>
          <fields>
            <field>
              <name>SW_BYA</name>
              <description>Set corresponding switch</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_BYB</name>
              <description>Set corresponding switch</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_CBCC</name>
              <description>Set corresponding switch
If the ADC is enabled then this switch is directly controlled by the ADC sequencer.</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SW_CMP_P_SEL</name>
          <description>CSDCMP Pos Switch Waveform selection</description>
          <addressOffset>0x2A0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1111777</resetMask>
          <fields>
            <field>
              <name>SW_SFPM</name>
              <description>Select waveform for corresponding switch</description>
              <bitRange>[2:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_SFPT</name>
              <description>Select waveform for corresponding switch</description>
              <bitRange>[6:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_SFPS</name>
              <description>Select waveform for corresponding switch</description>
              <bitRange>[10:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_SFMA</name>
              <description>Set corresponding switch</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_SFMB</name>
              <description>Set corresponding switch</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_SFCA</name>
              <description>Set corresponding switch</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_SFCB</name>
              <description>Set corresponding switch</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SW_CMP_N_SEL</name>
          <description>CSDCMP Neg Switch Waveform selection</description>
          <addressOffset>0x2A4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x77000000</resetMask>
          <fields>
            <field>
              <name>SW_SCRH</name>
              <description>Select waveform for corresponding switch</description>
              <bitRange>[26:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_SCRL</name>
              <description>Select waveform for corresponding switch</description>
              <bitRange>[30:28]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SW_REFGEN_SEL</name>
          <description>Reference Generator Switch Waveform selection</description>
          <addressOffset>0x2A8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x11010011</resetMask>
          <fields>
            <field>
              <name>SW_IAIB</name>
              <description>Set corresponding switch</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_IBCB</name>
              <description>Set corresponding switch</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_SGMB</name>
              <description>Set corresponding switch</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_SGRE</name>
              <description>Set corresponding switch</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_SGR</name>
              <description>Set corresponding switch</description>
              <bitRange>[28:28]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SW_FW_MOD_SEL</name>
          <description>Full Wave Cmod Switch Waveform selection</description>
          <addressOffset>0x2B0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x11170701</resetMask>
          <fields>
            <field>
              <name>SW_F1PM</name>
              <description>Set corresponding switch</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_F1MA</name>
              <description>Select waveform for corresponding switch</description>
              <bitRange>[10:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_F1CA</name>
              <description>Select waveform for corresponding switch</description>
              <bitRange>[18:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_C1CC</name>
              <description>Set corresponding switch</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_C1CD</name>
              <description>Set corresponding switch</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_C1F1</name>
              <description>Set corresponding switch</description>
              <bitRange>[28:28]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SW_FW_TANK_SEL</name>
          <description>Full Wave Csh_tank Switch Waveform selection</description>
          <addressOffset>0x2B4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x11177710</resetMask>
          <fields>
            <field>
              <name>SW_F2PT</name>
              <description>Set corresponding switch</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_F2MA</name>
              <description>Select waveform for corresponding switch</description>
              <bitRange>[10:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_F2CA</name>
              <description>Select waveform for corresponding switch</description>
              <bitRange>[14:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_F2CB</name>
              <description>Select waveform for corresponding switch</description>
              <bitRange>[18:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_C2CC</name>
              <description>Set corresponding switch</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_C2CD</name>
              <description>Set corresponding switch</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_C2F2</name>
              <description>Set corresponding switch</description>
              <bitRange>[28:28]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SW_DSI_SEL</name>
          <description>DSI output switch control Waveform selection</description>
          <addressOffset>0x2C0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x77</resetMask>
          <fields>
            <field>
              <name>DSI_CSH_TANK</name>
              <description>Select waveform for dsi_csh_tank signal (called dsi_cap_lo_en in CDSv1). For CSX when DUAL_CAP_EN is set this signal will have the special functionality to go low one clk_hf cycle ahead of the end of the corresponding csd_sense phase (just like for CSDv1), in all other use-cases the functionality is the same as for other switch controls.</description>
              <bitRange>[2:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DSI_CMOD</name>
              <description>Select waveform for dsi_cmod signal (called dsi_cap_hi_en in CDSv1).  For CSX when DUAL_CAP_EN is set this signal will have the special functionality to go low one clk_hf cycle ahead of the end of the corresponding csd_sense phase (just like for CSDv1), in all other use-cases the functionality is the same as for other switch controls.</description>
              <bitRange>[6:4]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SEQ_TIME</name>
          <description>Sequencer Timing</description>
          <addressOffset>0x300</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>AZ_TIME</name>
              <description>Define Auto-Zero time in csd_sense cycles -1.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SEQ_INIT_CNT</name>
          <description>Sequencer Initial conversion and sample counts</description>
          <addressOffset>0x310</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>CONV_CNT</name>
              <description>Number of conversion per sample, if set to 0 the Sample_init state will be skipped.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SEQ_NORM_CNT</name>
          <description>Sequencer Normal conversion and sample counts</description>
          <addressOffset>0x314</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>CONV_CNT</name>
              <description>Number of conversion per sample, if set to 0 the Sample_norm state will be skipped.
Sample window size = SEQ_NORM_CNT.CONV_CNT * (SENSE_PERIOD.SENSE_DIV+1).
Note for CSDv1 Sample window size = PERIOD</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ADC_CTL</name>
          <description>ADC Control</description>
          <addressOffset>0x320</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x300FF</resetMask>
          <fields>
            <field>
              <name>ADC_TIME</name>
              <description>ADC timing -1 in csd_sense clock cycles (actual time is ADC_TIME+1 cycles), either used to discharge Cref1&amp;2, or as the aperture to capture the input voltage on Cref1&amp;2</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ADC_MODE</name>
              <description>Enable ADC measurement. When enabled the ADC sequencer will be started when the main sequencer goes to the SAMPLE_NORM state</description>
              <bitRange>[17:16]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>OFF</name>
                  <description>No ADC measurement</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VREF_CNT</name>
                  <description>Count time A to bring Cref1 + Cref2 up from Vssa to Vrefhi with IDACB</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VREF_BY2_CNT</name>
                  <description>Count time B to bring Cref1 + Cref2 back up to Vrefhi with IDACB (after bringing them down for time A/2 cycles with IDACB sinking)</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VIN_CNT</name>
                  <description>Determine HSCMP polarity and count time C to source/sink Cref1 + Cref2 from Vin to Vrefhi.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>SEQ_START</name>
          <description>Sequencer start</description>
          <addressOffset>0x340</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x31B</resetMask>
          <fields>
            <field>
              <name>START</name>
              <description>Start the CSD sequencer. The sequencer will clear this bit when it is done. Depending on the mode the sequencer is done when a sample has been accumulated, when the high speed comparator trips or if the sequencer is aborted. When the ADC is enabled the ADC sequencer will start when the CSD sequencer reaches the Sample_norm state (only with the regular CSD scan mode).</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SEQ_MODE</name>
              <description>0 = regular CSD scan + optional ADC 
1 = coarse initialization, the Sequencer will go to the INIT_COARSE state.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ABORT</name>
              <description>When a 1 is written the CSD and ADC sequencers will be aborted (if they are running) and the START bit will be cleared. This bit always read as 0.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DSI_START_EN</name>
              <description>When this bit is set a positive edge on dsi_start will start the CSD sequencer and if enabled also the ADC sequencer.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>AZ0_SKIP</name>
              <description>When set the AutoZero_0 state will be skipped</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>AZ1_SKIP</name>
              <description>When set the AutoZero_1 state will be skipped</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TRIM_CTRL</name>
          <description>Trim control</description>
          <addressOffset>0xF00</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x22</resetValue>
          <resetMask>0x33</resetMask>
          <fields>
            <field>
              <name>DELAY_TRIM</name>
              <description>Trim input for Shield Delay block. Risk mitigation only; no test program or calpairs are needed for this</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DELAY_HYS</name>
              <description>Hystersis input for Shield Delay block. Risk mitigation only; no test program or calpairs are needed for this</description>
              <bitRange>[5:4]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>LPCOMP</name>
      <description>Low Power Comparators</description>
      <baseAddress>0x400C0000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>65536</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>ID</name>
          <description>ID &amp; Revision</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x1E0E0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ID</name>
              <description>the ID of LPCOMP peripheral is 0xE0E0</description>
              <bitRange>[15:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>REVISION</name>
              <description>the version number is 0x0001</description>
              <bitRange>[31:16]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CONFIG</name>
          <description>LPCOMP Configuration Register</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x33FFFF</resetMask>
          <fields>
            <field>
              <name>MODE1</name>
              <description>Operating mode for the comparator</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SLOW</name>
                  <description>Slow operating mode (uses less power, &lt;50uA)</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>FAST</name>
                  <description>Fast operating mode (uses more power, &lt;400uA)</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ULP</name>
                  <description>Ultra low power operting mode (uses ~2-4uA)</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>HYST1</name>
              <description>Add 10mV hysteresis to the comparator
- 0: Enable Hysteresis
- 1: Disable Hysteresis</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FILTER1</name>
              <description>N/A</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INTTYPE1</name>
              <description>Sets which edge will trigger an IRQ</description>
              <bitRange>[5:4]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DISABLE</name>
                  <description>Disabled, no interrupts will be detected</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RISING</name>
                  <description>Rising edge</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>FALLING</name>
                  <description>Falling edge</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>BOTH</name>
                  <description>Both rising and falling edges</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>OUT1</name>
              <description>Current output value of the comparator.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>ENABLE1</name>
              <description>Enable comparator #1</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MODE2</name>
              <description>Operating mode for the comparator</description>
              <bitRange>[9:8]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SLOW</name>
                  <description>Slow operating mode (uses less power, &lt;50uA)</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>FAST</name>
                  <description>Fast operating mode (uses more power, &lt;400uA)</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ULP</name>
                  <description>Ultra low power operting mode (uses ~2-4uA)</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>HYST2</name>
              <description>Add 10mV hysteresis to the comparator
- 0: Enable Hysteresis
- 1: Disable Hysteresis</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FILTER2</name>
              <description>N/A</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INTTYPE2</name>
              <description>Sets which edge will trigger an IRQ</description>
              <bitRange>[13:12]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DISABLE</name>
                  <description>Disabled, no interrupts will be detected</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RISING</name>
                  <description>Rising edge</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>FALLING</name>
                  <description>Falling edge</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>BOTH</name>
                  <description>Both rising and falling edges</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>OUT2</name>
              <description>Current output value of the comparator.</description>
              <bitRange>[14:14]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>ENABLE2</name>
              <description>Enable comparator #2</description>
              <bitRange>[15:15]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DSI_BYPASS1</name>
              <description>Opamp1 bypass comparator output synchronization for DSI output: 0=synchronize (level or pulse), 1=bypass (output async)
Note that in DeepSleep mode this bit needs to be set to observe the DSI output on the dedicated pin.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DSI_LEVEL1</name>
              <description>Opamp1 comparator DSI (trigger) out level : 0=pulse, 1=level</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DSI_BYPASS2</name>
              <description>Opamp2 bypass comparator output synchronization for DSI output: 0=synchronize (level or pulse), 1=bypass (output async)
Note that in DeepSleep mode this bit needs to be set to observe the DSI output on the dedicated pin.</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DSI_LEVEL2</name>
              <description>Opamp2 comparator DSI (trigger) out level : 0=pulse, 1=level</description>
              <bitRange>[21:21]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR</name>
          <description>LPCOMP Interrupt request register</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3</resetMask>
          <fields>
            <field>
              <name>COMP1</name>
              <description>Comparator 1 Interrupt: hardware sets this interrupt when comparator 0 triggers. Write with '1' to clear bit.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>COMP2</name>
              <description>Comparator 2 Interrupt: hardware sets this interrupt when comparator 0 triggers. Write with '1' to clear bit.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_SET</name>
          <description>LPCOMP Interrupt set register</description>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3</resetMask>
          <fields>
            <field>
              <name>COMP1</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>COMP2</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_MASK</name>
          <description>LPCOMP Interrupt request mask</description>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3</resetMask>
          <fields>
            <field>
              <name>COMP1_MASK</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>COMP2_MASK</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_MASKED</name>
          <description>LPCOMP Interrupt request masked</description>
          <addressOffset>0x1C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3</resetMask>
          <fields>
            <field>
              <name>COMP1_MASKED</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>COMP2_MASKED</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TRIM1</name>
          <description>LPCOMP Trim Register</description>
          <addressOffset>0xFF00</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1F</resetMask>
          <fields>
            <field>
              <name>COMP1_TRIMA</name>
              <description>Trim A for Comparator #1</description>
              <bitRange>[4:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TRIM2</name>
          <description>LPCOMP Trim Register</description>
          <addressOffset>0xFF04</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1F</resetMask>
          <fields>
            <field>
              <name>COMP1_TRIMB</name>
              <description>Trim B for Comparator #1</description>
              <bitRange>[4:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TRIM3</name>
          <description>LPCOMP Trim Register</description>
          <addressOffset>0xFF08</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1F</resetMask>
          <fields>
            <field>
              <name>COMP2_TRIMA</name>
              <description>Trim A for Comparator #2</description>
              <bitRange>[4:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TRIM4</name>
          <description>LPCOMP Trim Register</description>
          <addressOffset>0xFF0C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1F</resetMask>
          <fields>
            <field>
              <name>COMP2_TRIMB</name>
              <description>Trim B for Comparator #2</description>
              <bitRange>[4:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>CPUSS</name>
      <description>CPU Subsystem</description>
      <baseAddress>0x40100000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>4096</size>
        <usage>registers</usage>
      </addressBlock>
      <interrupt>
        <name>ioss_interrupts_gpio_0</name>
        <description>GPIO P0</description>
        <value>0</value>
      </interrupt>
      <interrupt>
        <name>ioss_interrupts_gpio_1</name>
        <description>GPIO P1</description>
        <value>1</value>
      </interrupt>
      <interrupt>
        <name>ioss_interrupts_gpio_2</name>
        <description>GPIO P2</description>
        <value>2</value>
      </interrupt>
      <interrupt>
        <name>ioss_interrupts_gpio_3</name>
        <description>GPIO P3</description>
        <value>3</value>
      </interrupt>
      <interrupt>
        <name>ioss_interrupt_gpio</name>
        <description>GPIO All Ports</description>
        <value>4</value>
      </interrupt>
      <interrupt>
        <name>lpcomp_interrupt</name>
        <description>LPCOMP trigger interrupt</description>
        <value>5</value>
      </interrupt>
      <interrupt>
        <name>srss_interrupt_wdt</name>
        <description>WDT</description>
        <value>6</value>
      </interrupt>
      <interrupt>
        <name>scb_0_interrupt</name>
        <description>SCB #0</description>
        <value>7</value>
      </interrupt>
      <interrupt>
        <name>scb_1_interrupt</name>
        <description>SCB #1</description>
        <value>8</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupt_spcif</name>
        <description>SPCIF interrupt</description>
        <value>9</value>
      </interrupt>
      <interrupt>
        <name>csd_interrupt</name>
        <description>CSD #0 (Primarily Capsense)</description>
        <value>10</value>
      </interrupt>
      <interrupt>
        <name>tcpwm_interrupts_0</name>
        <description>TCPWM #0, Counter #0</description>
        <value>11</value>
      </interrupt>
      <interrupt>
        <name>tcpwm_interrupts_1</name>
        <description>TCPWM #0, Counter #1</description>
        <value>12</value>
      </interrupt>
      <interrupt>
        <name>tcpwm_interrupts_2</name>
        <description>TCPWM #0, Counter #2</description>
        <value>13</value>
      </interrupt>
      <interrupt>
        <name>tcpwm_interrupts_3</name>
        <description>TCPWM #0, Counter #3</description>
        <value>14</value>
      </interrupt>
      <interrupt>
        <name>tcpwm_interrupts_4</name>
        <description>TCPWM #0, Counter #4</description>
        <value>15</value>
      </interrupt>
      <registers>
        <register>
          <name>CONFIG</name>
          <description>Configuration register</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1</resetMask>
          <fields>
            <field>
              <name>VECT_IN_RAM</name>
              <description>0': Vector Table is located at 0x0000:0000 in flash
'1': Vector Table is located at 0x2000:0000 in SRAM
Note that vectors for RESET and FAULT are always fetched from ROM. Value in flash/RAM is ignored for these vectors.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SYSREQ</name>
          <description>SYSCALL control register</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x30000000</resetValue>
          <resetMask>0xF800FFFF</resetMask>
          <fields>
            <field>
              <name>SYSCALL_COMMAND</name>
              <description>Opcode of the system call being requested.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DIS_RESET_VECT_REL</name>
              <description>Disable Reset Vector fetch relocation:
'0': CPU accesses to locations 0x0000:0000 - 0x0000:0007 are redirected to ROM.
'1': CPU accesses to locations 0x0000:0000 - 0x0000:0007 are made to flash.
Note that this field defaults to '0' on reset, ensuring actual reset vector fetches are always made to ROM. Note that this field does not affect DAP accesses. Flash DfT routines may set this bit to '1' to enable uninhibited read-back of programmed data in the first flash page.</description>
              <bitRange>[27:27]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PRIVILEGED</name>
              <description>Indicates whether the system is in privileged ('1') or user mode ('0'). Only CPU SW executing from ROM can set this field to '1' when ROM_ACCESS_EN is '1' (the CPU is executing a SystemCall NMI interrupt handler). Any other write to this field sets is to '0'. This field is used as the AHB-Lite hprot[1] signal to implement Cypress proprietary user/privileged modes. These modes are used to enable/disable access to specific MMIO registers and memory regions.</description>
              <bitRange>[28:28]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ROM_ACCESS_EN</name>
              <description>Indicates that executing from Boot ROM is enabled. HW sets this field to '1', on reset or when the SystemCall NMI vector is fetched from Boot ROM. HW sets this field to '0', when the CPU is NOT executing from either Boot or System ROM. This bit is used for debug purposes only.</description>
              <bitRange>[29:29]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>HMASTER_0</name>
              <description>Indicates the source of the write access to the SYSREQ register.
'0': CPU write access.
'1': DAP write access.
HW sets this field when the SYSREQ register is written to and SYSCALL_REQ is '0' (the last time it is set is when SW sets SYSCALL_REQ from '0' to '1').</description>
              <bitRange>[30:30]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SYSCALL_REQ</name>
              <description>CPU/DAP writes a '1' to this field to request a SystemCall. The HMASTER_0 field indicates the source of the write access. Setting this field to '1' immediate results in a NMI. The SystemCall NMI interrupt handler sets this field to '0' after servicing the request.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SYSARG</name>
          <description>SYSARG control register</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SYSCALL_ARG</name>
              <description>Argument to System Call specified in SYSREQ. Semantics of argument depends on system call made. Typically a pointer to a parameter block.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PROTECTION</name>
          <description>Protection control register</description>
          <addressOffset>0xC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xF</resetValue>
          <resetMask>0xC000000F</resetMask>
          <fields>
            <field>
              <name>PROTECTION_MODE</name>
              <description>Current protection mode; this field is available as a global signal everywhere in the system. Writes to this field are ignored when PROTECTION_LOCK is '1':
0b1xxx: BOOT
0b01xx: KILL
0b001x: PROTECTED
0b0001: OPEN
0b0000: VIRGIN (also used for DEAD mode, but then FLASH_LOCK is also set)</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FLASH_LOCK</name>
              <description>Setting this bit will force SPCIF.ADDRESS.AXA to be ignored, which prevents SM Flash from being erased or overwritten. It is used to indicate the DEAD protection mode. Writes to this field are ignored when PROTECTION_LOCK is '1'</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PROTECTION_LOCK</name>
              <description>Setting this field will block (ignore) any further writes to the PROTECTION_MODE field in this register. Once '1', this field cannot be cleared.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PRIV_ROM</name>
          <description>ROM privilege register</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3FF00FF</resetMask>
          <fields>
            <field>
              <name>BROM_PROT_LIMIT</name>
              <description>Indicates the limit where the privileged area of the Boot ROM partition starts in increments of 256 Bytes.
'0':  Entire Boot ROM is Privileged.
'1':  First 256 Bytes are User accessable.
...
BROM_PROT_LIMIT &gt;= 'Boot ROM partition capacity': Entire Boot ROM partition is user mode accessible.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SROM_PROT_LIMIT</name>
              <description>Indicates the limit where the privileged area of System ROM partition starts in increments of 256 Bytes. The limit is wrt. the start of the ROM memory (start of the Boot ROM partition).
SROM_PROT_LIMIT * 256 Byte &lt;= 'Boot ROM partition capacity':  Entire System ROM is Privileged.
SROM_PROT_LIMIT * 256 Byte &gt; 'Boot ROM partition capacity':  First SROM_PROT_LIMIT * 256 - 'Boot ROM partition capacity' Bytes are User accessable.
...
SROM_PROT_LIMIT &gt;= 'ROM capacity': Entire System ROM is user mode accessible.</description>
              <bitRange>[25:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PRIV_RAM</name>
          <description>RAM privilege register</description>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1FF</resetMask>
          <fields>
            <field>
              <name>RAM_PROT_LIMIT</name>
              <description>Indicates the limit where the privileged area of SRAM starts in increments of 256 Bytes.
'0':  Entire SRAM is Privileged.
'1':  First 256 Bytes are User accessable.

Any number larger than the size of the SRAM indicates that the entire SRAM is user mode accessible.</description>
              <bitRange>[8:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PRIV_FLASH</name>
          <description>Flash privilege register</description>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFF</resetMask>
          <fields>
            <field>
              <name>FLASH_PROT_LIMIT</name>
              <description>Indicates the limit where the privileged area of flash starts in increments of 256 Bytes.
'0':  Entire flash is Privileged.
'1':  First 256 Bytes are User accessable.

Any number larger than the size of the flash indicates that the entire flash is user mode accessible. Note that SuperVisory rows are always User accessable.

If FLASH_PROT_LIMIT defines a non-empty privileged area, the boot ROM will assume that a system call table exists at the beginning of the Flash privileged area and use it for all SystemCalls made using SYSREQ.</description>
              <bitRange>[11:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>WOUNDING</name>
          <description>Wounding register</description>
          <addressOffset>0x1C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x7770000</resetMask>
          <fields>
            <field>
              <name>RAM_WOUND</name>
              <description>Indicates the amount of accessible RAM 0 memory capacitty in this part. The value in this field is effectively write-once (it is only possible to set bits, not clear them). The remainder portion of SRAM is not accessible and will return an AHB-Lite bus error.
'0': entire memory accessible
'1': first 1/2 of the memory accessible
'2': first 1/4 of the memory accessible
'3': first 1/8 of the memory accessible
'4': first 1/16 of the memory accessible
'5': first 1/32 of the memory accessible
'6': first 1/64 of the memory accessible
'7': first 1/128 of the memory accessible</description>
              <bitRange>[18:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FLASH_WOUND</name>
              <description>Indicates the amount of accessible flash in this part. The value in this field is effectively write-once (it is only possible to set bits, not clear them). The remainder portion of flash is not accessible and will return an AHB-Lite bus error.
'0': entire memory accessible
'1': first 1/2 of the memory accessible
'2': first 1/4 of the memory accessible
'3': first 1/8 of the memory accessible
'4': first 1/16 of the memory accessible
'5': first 1/32 of the memory accessible
'6': first 1/64 of the memory accessible
'7': first 1/128 of the memory accessible (used for the DEAD protection mode)</description>
              <bitRange>[22:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RAM1_WOUND</name>
              <description>Wounding of RAM 1 (see description of RAM_WOUND).</description>
              <bitRange>[26:24]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INT_SEL</name>
          <description>Interrupt multiplexer select register</description>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DSI</name>
              <description>Specifies interrupt source:
'0': Fixed Function.
'1': DSI.
When changing the source of a specific interrupt, it is advised to temporarily disable the interrupt using the CM0 NVIC's CLRENA and SETENA interrupt enable clear and set registers to prevent a spurious interrupt activation. In addition, the CM0 NVIC's CLRPEND interrupt pending clear register should be used clear a pending interrupt before re-enabling the interrupt.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INT_MODE</name>
          <description>DSI interrupt pulse mode register</description>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DSI_INT_PULSE</name>
              <description>Specifies DSI interrupt format:
'0': level sensitive; i.e. no pulse generator.
'1': pulse generator on rising edge.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>NMI_MODE</name>
          <description>DSI NMI pulse mode register</description>
          <addressOffset>0x28</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1</resetMask>
          <fields>
            <field>
              <name>DSI_NMI_PULSE</name>
              <description>Specifies DSI NMI format:
'0': level sensitive; i.e. no pulse generator.
'1': pulse generator on rising edge.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>FLASH_CTL</name>
          <description>FLASH control register</description>
          <addressOffset>0x30</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x30113</resetMask>
          <fields>
            <field>
              <name>FLASH_WS</name>
              <description>Amount of ROM wait states:
'0': 0 wait states (fast flash: [0, 24] MHz system frequency, slow flash: [0, 16] MHz system frequency)
'1': 1 wait state (fast flash: [24, 48] MHz system frequency, slow flash: [16, 32] MHz system frequency)
'2': 2 wait states (slow flash: [32, 48] MHz system frequency)
'3': 3 wait states (can be used to give more time for flash access if 2 wait states are not sufficient)</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PREF_EN</name>
              <description>Prefetch enable:
'0': disabled. This is a desirable seeting when FLASH_WS is '0' or when predictable execution behavior is required.
'1': enabled.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FLASH_INVALIDATE</name>
              <description>1': Invalidates the content of the flash controller's buffers.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ARB</name>
              <description>Arbitration policy:
'0': CPU has priority
'1': DW/DMA has priority
'2': Roundrobin
'3': Roundrobin - sticky</description>
              <bitRange>[17:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ROM_CTL</name>
          <description>ROM control register</description>
          <addressOffset>0x34</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1</resetMask>
          <fields>
            <field>
              <name>ROM_WS</name>
              <description>Amount of ROM wait states:
'0': 0 wait states. Use this setting for newer, faster ROM design. Use this setting for older, slower ROM design and frequencies in the range [0, 24] MHz.
'1': 1 wait state. Use this setting for older, slower ROM design and frequencies in the range &lt;24, 48] MHz.

CPUSSv2 supports two types of ROM memory: an older, slower design (operating at up to 24 MHz) and a newer, faster design (operating at up to 48 MHz). The older design requires 1 wait state for frequencies above 24 MHz. The newer design never requires wait states. All chips after Street Fighter will use the newer design. As a result, all chips after Street Fighter can always use 0 wait states.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RAM_CTL</name>
          <description>RAM control register</description>
          <addressOffset>0x38</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x30000</resetMask>
          <fields>
            <field>
              <name>ARB</name>
              <description>Arbitration policy:
'0': CPU has priority
'1': DW/DMA has priority
'2': Roundrobin
'3': Roundrobin - sticky</description>
              <bitRange>[17:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_CTL</name>
          <description>DMA controller register</description>
          <addressOffset>0x3C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x30000</resetMask>
          <fields>
            <field>
              <name>ARB</name>
              <description>Arbitration policy:
'0': CPU has priority
'1': DW/DMA has priority
'2': Roundrobin
'3': Roundrobin - sticky</description>
              <bitRange>[17:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PRIV_RAM1</name>
          <description>RAM 1 privilege register</description>
          <addressOffset>0xA0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x1FF</resetValue>
          <resetMask>0x1FF</resetMask>
          <fields>
            <field>
              <name>RAM_PROT_LIMIT</name>
              <description>See description of PRIV_RAM.RAM_PROT_LIMIT. Note that the reset value is 0x1ff, indicating that the complete RAM 1 memory capacity is User accessable.</description>
              <bitRange>[8:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RAM1_CTL</name>
          <description>RAM 1 control register</description>
          <addressOffset>0xA4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x30000</resetMask>
          <fields>
            <field>
              <name>ARB</name>
              <description>Arbitration policy (for RAM controller 1):
'0': CPU has priority
'1': DW/DMA has priority
'2': Roundrobin
'3': Roundrobin - sticky</description>
              <bitRange>[17:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MTB_CTL</name>
          <description>MTB control register</description>
          <addressOffset>0xB0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1</resetMask>
          <fields>
            <field>
              <name>CPU_HALT_TSTOP_EN</name>
              <description>1': Enable CPU Halt to stop MTB trace. ('HALTED' output of CM0+ can stop the trace when high/'1')
'0': 'HALTED' output of CM0+ can not strop trace.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>24</dim>
          <dimIncrement>4</dimIncrement>
          <name>SL_CTL[%s]</name>
          <description>Slave control register</description>
          <addressOffset>0x100</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x30000</resetMask>
          <fields>
            <field>
              <name>ARB</name>
              <description>Arbitration policy:
'0': CPU priority
'1': DMA priority
'2': Roundrobin
'3': Roundrobin - sticky</description>
              <bitRange>[17:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>SPCIF</name>
      <description>Flash Control Interface</description>
      <baseAddress>0x40110000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>65536</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>GEOMETRY</name>
          <description>Flash/NVL geometry information</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x80000000</resetMask>
          <fields>
            <field>
              <name>FLASH</name>
              <description>Regular flash capacity in 256 Byte multiples (chip dependent). If multiple flash macros are present, this field provides the flash capacity of all flash macros together:
'0': 256 Bytes.
'1': 2*256 Bytes.
...
'16383': 16384*256 Bytes.</description>
              <bitRange>[13:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SFLASH</name>
              <description>Supervisory flash capacity in 256 Byte multiples (chip dependent). If multiple flash macros are present, this field provides the supervisory flash capacity of all flash macros together:
'0': 256 Bytes.
'1': 2*256 Bytes.
...
'63': 64*256 Bytes.</description>
              <bitRange>[19:14]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>NUM_FLASH</name>
              <description>Number of flash macros (chip dependent):
'0': 1 flash macro
'1': 2 flash macros
'2': 3 flash macros
'3': 4 flash macros</description>
              <bitRange>[21:20]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>FLASH_ROW</name>
              <description>Page size in 64 Byte multiples (chip dependent):
'0': 64 byte
'1': 128 byte
'2': 192 byte
'3': 256 byte

The page size is used to detemine the number of Bytes in a page for Flash page based operations (e.g. PGM_PAGE).

Note: the field name FLASH_ROW is misleading, as this field specifies the number of Bytes in a page, rather than the number of Bytes in a row. In a single plane flash macro architecture, a page consists of a single row. However, in a multi plane flash macro architecture, a page consists of multiple rows from different planes.</description>
              <bitRange>[23:22]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>NVL</name>
              <description>NVLatch size in Byte multiples (chip dependent):
'0': 0 Bytes
'1': 1 Byte
...
'127': 127 Bytes</description>
              <bitRange>[30:24]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DE_CPD_LP</name>
              <description>0': SRAM busy wait loop has not been copied.
'1': Busy wait loop has been written into SRAM.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>NVL_WR_DATA</name>
          <description>NVL write data register</description>
          <addressOffset>0x1C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>DATA</name>
              <description>Data to be written to NVLatch array</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR</name>
          <description>SPCIF interrupt request register</description>
          <addressOffset>0x7F0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1</resetMask>
          <fields>
            <field>
              <name>TIMER</name>
              <description>Timer counter value reaches '0'. Set to '1', when event is detected. Write INTR field with '1', to clear bit. Write INTR_SET field with '1', to set bit.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_SET</name>
          <description>SPCIF interrupt set request register</description>
          <addressOffset>0x7F4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1</resetMask>
          <fields>
            <field>
              <name>TIMER</name>
              <description>Write INTR_SET field with '1' to set corresponding INTR field.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_MASK</name>
          <description>SPCIF interrupt mask register</description>
          <addressOffset>0x7F8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1</resetMask>
          <fields>
            <field>
              <name>TIMER</name>
              <description>Mask for corresponding field in INTR register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_MASKED</name>
          <description>SPCIF interrupt masked request register</description>
          <addressOffset>0x7FC</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1</resetMask>
          <fields>
            <field>
              <name>TIMER</name>
              <description>Logical and of corresponding request and mask fields.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
  </peripherals>
</device>