<?xml version="1.0" encoding="utf-8"?>

<!-- =========================================================================== -->
<!--                                                                             -->
<!-- File naming: <vendor>_<part/series name>.svd                                -->
<!-- Filename: MEC1322.svd                                                       -->
<!-- Purpose: System Viewer Description (SVD) of MEC1322 (Schema Version 1.2)    -->
<!--                                                                             -->
<!-- =========================================================================== -->
<!--                                                                             -->
<!-- Copyright (C) 2012-2014 ARM Limited. All rights reserved.                   -->
<!--                                                                             -->
<!-- Redistribution and use in source and binary forms, with or without          -->
<!-- modification, are permitted provided that the following conditions are met: -->
<!--  - Redistributions of source code must retain the above copyright           -->
<!--    notice, this list of conditions and the following disclaimer.            -->
<!--  - Redistributions in binary form must reproduce the above copyright        -->
<!--    notice, this list of conditions and the following disclaimer in the      -->
<!--    documentation and/or other materials provided with the distribution.     -->
<!--  - Neither the name of ARM nor the names of its contributors may be used    -->
<!--    to endorse or promote products derived from this software without        -->
<!--    specific prior written permission.                                       -->
<!--                                                                             -->
<!-- THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" -->
<!-- AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE   -->
<!-- IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  -->
<!-- ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE     -->
<!-- LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR         -->
<!-- CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF        -->
<!-- SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS    -->
<!-- INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN     -->
<!-- CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)     -->
<!-- ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  -->
<!-- POSSIBILITY OF SUCH DAMAGE.                                                 -->
<!--                                                                             -->
<!-- =========================================================================== -->

<device schemaVersion="1.1" xmlns:xs="http://www.w3.org/2001/XMLSchema-instance" xs:noNamespaceSchemaLocation="CMSIS-SVD.xsd" >
  <vendor>Microchip Technology Inc.</vendor>                      <!-- device vendor name -->
  <vendorID>MCHP</vendorID>                                       <!-- device vendor short name -->
  <name>MEC1322</name>                                            <!-- name of part-->
  <series>ARMCM4F</series>                                        <!-- device series the device belongs to -->
  <version>1.0</version>                                          <!-- version of this description, adding CMSIS-SVD 1.1 tags -->
  <description>
    The EC (MEC1322) is built around an ARM Cortex M4F Processor provided by Arm\n
    Ltd. (the "ARM M4F IP"). The ARM Cortex M4F is a full-featured 32-bit embedded\n
    processor, implementing the ARMv7-M THUMB instruction set and FPU instruction\n
    set in hardware.\n
    \n
    The ARM M4F IP is configured as a Von Neumann, Byte-Addressable, Little-Endian\n
    architecture. It provides a single unified 32-bit byte-level address, for a\n
    total direct addressing space of 4GByte. It has multiple bus interfaces, but\n
    these express priorities of access to the chip-level resources (Instruction\n
    Fetch vs. Data RAM vs. others), and they do not represent separate addressing\n
    spaces.
  </description>
  <licenseText>                                                   <!-- this license text will appear in header file. \n force line breaks -->
    ARM Limited (ARM) is supplying this software for use with Cortex-M\n
    processor based microcontroller, but can be equally used for other\n
    suitable processor architectures. This file can be freely distributed.\n
    Modifications to this file shall be clearly marked.\n
    \n
    THIS SOFTWARE IS PROVIDED "AS IS".  NO WARRANTIES, WHETHER EXPRESS, IMPLIED\n
    OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF\n
    MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.\n
    ARM SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR\n
    CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
  </licenseText>
  <cpu>                                                           <!-- details about the cpu embedded in the device -->
    <name>CM4</name>
    <revision>r1p0</revision>
    <endian>little</endian>
    <mpuPresent>true</mpuPresent>
    <fpuPresent>true</fpuPresent>
    <nvicPrioBits>3</nvicPrioBits>
    <vendorSystickConfig>false</vendorSystickConfig>
  </cpu>
  <addressUnitBits>8</addressUnitBits>                            <!-- byte addressable memory -->
  <width>32</width>                                               <!-- bus width is 32 bits -->
  <!-- default settings implicitly inherited by subsequent sections -->
  <size>32</size>                                                 <!-- this is the default size (number of bits) of all peripherals
                                                                       and register that do not define "size" themselves -->
  <access>read-write</access>                                     <!-- default access permission for all subsequent registers -->
  <resetValue>0x00000000</resetValue>                             <!-- by default all bits of the registers are initialized to 0 on reset -->
  <resetMask>0xFFFFFFFF</resetMask>                               <!-- by default all 32Bits of the registers are used -->

  <peripherals>

    <!-- [ Table of Contents ] -->
    <!-- < Chapter 3.0 >  Power, Clocks, and Resets  -->
    <!-- < Chapter 4.0 >  VBAT Register Bank  -->
    <!-- < Chapter 5.0 >  LPC Interface  -->
    <!-- < Chapter 6.0 >  Chip Configuration  -->
    <!-- < Chapter 9.0 >  Embedded Memory Interface (EMI)  -->
    <!-- < Chapter 10.0>  ACPI Embedded Controller Interface (ACPI-ECI)  -->
    <!-- < Chapter 11.0>  8042 Emulated Keyboard Controller  -->
    <!-- < Chapter 12.0>  MailBox Register Interface  -->
    <!-- < Chapter 13.0>  ACPI PM1 Block Interface  -->
    <!-- < Chapter 14.0>  UART  -->
    <!-- < Chapter 15.0>  EC Interrupt Aggregator -->
    <!-- < Chapter 16.0>  Watchdog Timer (WDT)  -->
    <!-- < Chapter 17.0>  Basic Timer  -->
    <!-- < Chapter 18.0>  Hibernation Timer  -->
    <!-- < Chapter 19.0>  RTC With Date and DST Adjustment  -->
    <!-- < Chapter 20.0>  GPIO Interface  -->
    <!-- < Chapter 21.0>  Internal DMA Controller  -->
    <!-- < Chapter 22.0>  SMBus Interface  -->
    <!-- < Chapter 23.0>  PECI Interface  -->
    <!-- < Chapter 24.0>  TACH  -->
    <!-- < Chapter 25.0>  PWM  -->
    <!-- < Chapter 26.0>  RPM-PWM Interface  -->
    <!-- < Chapter 27.0>  General Purpose Serial Peripheral Interface (GP-SPI)  -->
    <!-- < Chapter 28.0>  Blinking/Breathing PWM -->
    <!-- < Chapter 29.0>  PS/2 Device Interface  -->
    <!-- < Chapter 30.0>  Keyboard Matrix Scan Support -->
    <!-- < Chapter 31.0>  SMSC BC-Link Master -->
    <!-- < Chapter 32.0>  Trace FIFO Debug Port (TFDP) -->
    <!-- < Chapter 33.0>  Analog to Digital Converter -->
    <!-- < Chapter 35.0>  EC Subsystem Registers -->
    <!-- < Chapter 36.0>  Test Mechanisms -->

    <peripheral>
    <!-- < Chapter 3.0 >  Power, Clocks, and Resets  -->
    <!-- 40080100  PCR                             0  PCR                    Chip Sleep Enable Register                           -->
    <!-- 40080104  PCR                             0  PCR                    Chip Clock Required Register                         -->
    <!-- 40080108  PCR                             0  PCR                    EC Sleep Enables Register                            -->
    <!-- 4008010C  PCR                             0  PCR                    EC Clock Required Status Register                    -->
    <!-- 40080110  PCR                             0  PCR                    Host Sleep Enables Register                          -->
    <!-- 40080114  PCR                             0  PCR                    Host Clock Required Status Register                  -->
    <!-- 40080118  PCR                             0  PCR                    CHIP_PCR_ADDR_SYS-   _SLEEP_CTRL_0                   -->
    <!-- 40080120  PCR                             0  PCR                    Processor Clock Control                              -->
    <!-- 40080124  PCR                             0  PCR                    EC Sleep Enable 2 Register                           -->
    <!-- 40080128  PCR                             0  PCR                    EC Clock Required 2 Status Register                  -->
    <!-- 4008012C  PCR                             0  PCR                    Slow Clock Control                                   -->
    <!-- 40080130  PCR                             0  PCR                    Oscillator ID Register                               -->
    <!-- 40080134  PCR                             0  PCR                    PCR chip sub-system power reset status               -->
    <!-- 40080138  PCR                             0  PCR                    Chip Reset Enable                                    -->
    <!-- 4008013C  PCR                             0  PCR                    Host Reset Enable                                    -->
    <!-- 40080140  PCR                             0  PCR                    EC Reset Enable                                      -->
    <!-- 40080144  PCR                             0  PCR                    EC Reset Enable 2                                    -->
    <!-- 40080148  PCR                             0  PCR                    PCR Clock Reset Control                              -->
    <!--  -->
      <name>PCR</name>
      <version>1.0</version>
      <description>The Power, Clocks, and Resets (PCR) chapter identifies all the power supplies,\n
       clock sources, and reset inputs to the chip and defines all the derived power, clock, and reset signals.
      </description>
      <groupName>PCR</groupName>
      <baseAddress>0x40080100</baseAddress>
      <size>32</size>
      <access>read-write</access>

      <addressBlock>
        <offset>0</offset>
        <size>0x080</size>
        <usage>registers</usage>
      </addressBlock>

      <registers>

        <!-- Chip Sleep Enable Register (CHIP_SLP_EN) -->
        <register>
          <name>CHIP_SLP_EN</name>
          <description>Chip Sleep Enable Register (CHIP_SLP_EN), MCHP Reserved
          </description>
          <addressOffset>0x00</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
        </register>

        <!-- Chip Clock Required Status Registers (CHIP_CLK_REQ_STS) -->
        <register>
          <name>CHIP_CLK_REQ_STS</name>
          <description>Chip Clock Required Status Registers (CHIP_CLK_REQ_STS), MCHP Reserved
          </description>
          <addressOffset>0x04</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
        </register>

        <!-- EC Sleep Enable Register (EC_SLP_EN) -->
        <register>
          <name>EC_SLP_EN</name>
          <description>EC Sleep Enable Register (EC_SLP_EN)
          </description>
          <addressOffset>0x08</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>

          <fields>
            <!-- INT Sleep Enable (INT_SLP_EN) -->
            <field>
              <name>INT_SLP_EN</name>
              <description>INT Sleep Enable (INT_SLP_EN)
              </description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>

            <!-- PECI Sleep Enable (PECI_SLP_EN) -->
            <field>
              <name>PECI_SLP_EN</name>
              <description>PECI Sleep Enable (PECI_SLP_EN)
              </description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>

            <!-- TACH0 Sleep Enable (TACH0_SLP_EN) -->
            <field>
              <name>TACH0_SLP_EN</name>
              <description>TACH0 Sleep Enable (TACH0_SLP_EN)
              </description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>

            <!-- PWM0 Sleep Enable (PWM0_SLP_EN) -->
            <field>
              <name>PWM0_SLP_EN</name>
              <description>PWM0 Sleep Enable (PWM0_SLP_EN)
              </description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>

            <!-- PMC Sleep Enable (PMC_SLP_EN) -->
            <field>
              <name>PMC_SLP_EN</name>
              <description>PMC Sleep Enable (PMC_SLP_EN)
              </description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>

            <!-- DMA Sleep Enable (DMA_SLP_EN) -->
            <field>
              <name>DMA_SLP_EN</name>
              <description>DMA Sleep Enable (DMA_SLP_EN)
              </description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>

            <!-- TFDP Sleep Enable (TFDP_SLP_EN) -->
            <field>
              <name>TFDP_SLP_EN</name>
              <description>TFDP Sleep Enable (TFDP_SLP_EN)
              </description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>

            <!-- PROCESSOR Sleep Enable (PROCESSOR_SLP_EN) -->
            <field>
              <name>PROCESSOR_SLP_EN</name>
              <description>PROCESSOR Sleep Enable (PROCESSOR_SLP_EN)
              </description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>

            <!-- WDT Sleep Enable (WDT_SLP_EN) -->
            <field>
              <name>WDT_SLP_EN</name>
              <description>WDT Sleep Enable (WDT_SLP_EN)
              </description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>

            <!-- SMB0 Sleep Enable (SMB0_SLP_EN) -->
            <field>
              <name>SMB0_SLP_EN</name>
              <description>SMB0 Sleep Enable (SMB0_SLP_EN)
              </description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>

            <!-- TACH1 Sleep Enable (TACH1_SLP_EN) -->
            <field>
              <name>TACH1_SLP_EN</name>
              <description>TACH1 Sleep Enable (TACH1_SLP_EN)
              </description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>

            <!-- PWM1 Sleep Enable (PWM1_SLP_EN) -->
            <field>
              <name>PWM1_SLP_EN</name>
              <description>PWM1 Sleep Enable (PWM1_SLP_EN)
              </description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>

            <!-- PWM2 Sleep Enable (PWM2_SLP_EN) -->
            <field>
              <name>PWM2_SLP_EN</name>
              <description>PWM2 Sleep Enable (PWM2_SLP_EN)
              </description>
              <bitRange>[21:21]</bitRange>
              <access>read-write</access>
            </field>

            <!-- PWM3 Sleep Enable (PWM3_SLP_EN) -->
            <field>
              <name>PWM3_SLP_EN</name>
              <description>PWM3 Sleep Enable (PWM3_SLP_EN)
              </description>
              <bitRange>[22:22]</bitRange>
              <access>read-write</access>
            </field>

            <!-- EC_REG_BANK Sleep Enable (EC_REG_BANK_SLP_EN) -->
            <field>
              <name>EC_REG_BANK_SLP_EN</name>
              <description>EC_REG_BANK Sleep Enable (EC_REG_BANK_SLP_EN)
              </description>
              <bitRange>[29:29]</bitRange>
              <access>read-write</access>
            </field>

            <!-- TIMER16_0 Sleep Enable (TIMER16_0_SLP_EN) -->
            <field>
              <name>TIMER16_0_SLP_EN</name>
              <description>TIMER16_0 Sleep Enable (TIMER16_0_SLP_EN)
              </description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>

            <!-- TIMER16_1 Sleep Enable (TIMER16_1_SLP_EN) -->
            <field>
              <name>TIMER16_1_SLP_EN</name>
              <description>TIMER16_1 Sleep Enable (TIMER16_1_SLP_EN)
              </description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>

        <!-- EC Clock Required Status Registers (EC_CLK_REQ_STS) -->
        <register>
          <name>EC_CLK_REQ_STS</name>
          <description>EC Clock Required Status Registers (EC_CLK_REQ_STS)
          </description>
          <addressOffset>0x0C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>

          <fields>
            <!-- INT Clock Required (INT_CLK_REQ) -->
            <field>
              <name>INT_CLK_REQ</name>
              <description>INT Clock Required (INT_CLK_REQ)
              </description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>

            <!-- PECI Clock Required (PECI_CLK_REQ) -->
            <field>
              <name>PECI_CLK_REQ</name>
              <description>PECI Clock Required (PECI_CLK_REQ)
              </description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>

            <!-- TACH0 Clock Required (TACH0_CLK_REQ) -->
            <field>
              <name>TACH0_CLK_REQ</name>
              <description>TACH0 Clock Required (TACH0_CLK_REQ)
              </description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>

            <!-- PWM0 Clock Required (PWM0_CLK_REQ) -->
            <field>
              <name>PWM0_CLK_REQ</name>
              <description>PWM0 Clock Required (PWM0_CLK_REQ)
              </description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
            </field>

            <!-- PMC Clock Required (PMC_CLK_REQ) -->
            <field>
              <name>PMC_CLK_REQ</name>
              <description>PMC Clock Required (PMC_CLK_REQ)
              </description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
            </field>

            <!-- DMA Clock Required (DMA_CLK_REQ) -->
            <field>
              <name>DMA_CLK_REQ</name>
              <description>DMA Clock Required (DMA_CLK_REQ)
              </description>
              <bitRange>[6:6]</bitRange>
              <access>read-only</access>
            </field>

            <!-- TFDP Clock Required (TFDP_CLK_REQ) -->
            <field>
              <name>TFDP_CLK_REQ</name>
              <description>TFDP Clock Required (TFDP_CLK_REQ)
              </description>
              <bitRange>[7:7]</bitRange>
              <access>read-only</access>
            </field>

            <!-- PROCESSOR Clock Required (PROCESSOR_CLK_REQ) -->
            <field>
              <name>PROCESSOR_CLK_REQ</name>
              <description>PROCESSOR Clock Required (PROCESSOR_CLK_REQ)
              </description>
              <bitRange>[8:8]</bitRange>
              <access>read-only</access>
            </field>

            <!-- WDT Clock Required (WDT_CLK_REQ) -->
            <field>
              <name>WDT_CLK_REQ</name>
              <description>WDT Clock Required (WDT_CLK_REQ)
              </description>
              <bitRange>[9:9]</bitRange>
              <access>read-only</access>
            </field>

            <!-- SMB0 Clock Required (SMB0_CLK_REQ) -->
            <field>
              <name>SMB0_CLK_REQ</name>
              <description>SMB0 Clock Required (SMB0_CLK_REQ)
              </description>
              <bitRange>[10:10]</bitRange>
              <access>read-only</access>
            </field>

            <!-- TACH1 Clock Required (TACH1_CLK_REQ) -->
            <field>
              <name>TACH1_CLK_REQ</name>
              <description>TACH1 Clock Required (TACH1_CLK_REQ)
              </description>
              <bitRange>[11:11]</bitRange>
              <access>read-only</access>
            </field>

            <!-- PWM1 Clock Required (PWM1_CLK_REQ) -->
            <field>
              <name>PWM1_CLK_REQ</name>
              <description>PWM1 Clock Required (PWM1_CLK_REQ)
              </description>
              <bitRange>[20:20]</bitRange>
              <access>read-only</access>
            </field>

            <!-- PWM2 Clock Required (PWM2_CLK_REQ) -->
            <field>
              <name>PWM2_CLK_REQ</name>
              <description>PWM2 Clock Required (PWM2_CLK_REQ)
              </description>
              <bitRange>[21:21]</bitRange>
              <access>read-only</access>
            </field>

            <!-- PWM3 Clock Required (PWM3_CLK_REQ) -->
            <field>
              <name>PWM3_CLK_REQ</name>
              <description>PWM3 Clock Required (PWM3_CLK_REQ)
              </description>
              <bitRange>[22:22]</bitRange>
              <access>read-only</access>
            </field>

            <!-- EC_REG_BANK Clock Required (EC_REG_BANK_CLK_REQ) -->
            <field>
              <name>EC_REG_BANK_CLK_REQ</name>
              <description>EC_REG_BANK Clock Required (EC_REG_BANK_CLK_REQ)
              </description>
              <bitRange>[29:29]</bitRange>
              <access>read-only</access>
            </field>

            <!-- TIMER16_0 Clock Required (TIMER16_0_CLK_REQ) -->
            <field>
              <name>TIMER16_0_CLK_REQ</name>
              <description>TIMER16_0 Clock Required (TIMER16_0_CLK_REQ)
              </description>
              <bitRange>[30:30]</bitRange>
              <access>read-only</access>
            </field>

            <!-- TIMER16_1 Clock Required (TIMER16_1_CLK_REQ) -->
            <field>
              <name>TIMER16_1_CLK_REQ</name>
              <description>TIMER16_1 Clock Required (TIMER16_1_CLK_REQ)
              </description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>

        <!-- Host Sleep Enable Register (HOST_SLP_EN) -->
        <register>
          <name>HOST_SLP_EN</name>
          <description>Host Sleep Enable Register (HOST_SLP_EN)
          </description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>

          <fields>
            <!-- LPC Sleep Enable (LPC_SLP_EN) -->
            <field>
              <name>LPC_SLP_EN</name>
              <description>LPC Sleep Enable (LPC_SLP_EN)
              </description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>

            <!-- UART 0 Sleep Enable (M16550_0_SLP_EN) -->
            <field>
              <name>M16550_0_SLP_EN</name>
              <description>UART 0 Sleep Enable (M16550_0_SLP_EN)
              </description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>

            <!-- GLBL_CFG (GLBL_CFG_SLP_EN) -->
            <field>
              <name>GLBL_CFG_SLP_EN</name>
              <description>GLBL_CFG (GLBL_CFG_SLP_EN)
              </description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>

            <!-- ACPI EC 0 Sleep Enable (ACPI_EC_0_SLP_EN) -->
            <field>
              <name>ACPI_EC_0_SLP_EN</name>
              <description>ACPI EC 0 Sleep Enable (ACPI_EC_0_SLP_EN)
              </description>
              <bitRange>[13:13]</bitRange>
              <access>read-write</access>
            </field>

            <!-- ACPI EC 1 Sleep Enable (ACPI_EC_1_SLP_EN) -->
            <field>
              <name>ACPI_EC_1_SLP_EN</name>
              <description>ACPI EC 1 Sleep Enable (ACPI_EC_1_SLP_EN)
              </description>
              <bitRange>[14:14]</bitRange>
              <access>read-write</access>
            </field>

            <!-- ACPI PM1 Sleep Enable (ACPI_PM1_SLP_EN) -->
            <field>
              <name>ACPI_PM1_SLP_EN</name>
              <description>ACPI PM1 Sleep Enable (ACPI_PM1_SLP_EN)
              </description>
              <bitRange>[15:15]</bitRange>
              <access>read-write</access>
            </field>

            <!-- 8042EM Sleep Enable (8042EM_SLP_EN) -->
            <field>
              <name>KBCEM_SLP_EN</name>
              <description>8042EM Sleep Enable (8042EM_SLP_EN)
              </description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>

            <!-- RTC Sleep Enable (RTC_SLP_EN) -->
            <field>
              <name>RTC_SLP_EN</name>
              <description>RTC Sleep Enable (RTC_SLP_EN)
              </description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>

          </fields>
        </register>

        <!-- Host Clock Required Status Registers (HOST_CLK_REQ) -->
        <register>
          <name>HOST_CLK_REQ</name>
          <description>Host Clock Required Status Registers (HOST_CLK_REQ)
          </description>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <!-- LPC Clock Required (LPC_CLK_REQ) -->
            <field>
              <name>LPC_CLK_REQ</name>
              <description>LPC Clock Required (LPC_CLK_REQ)
              </description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>

            <!-- UART 0 Clock Required (M16550_0_CLK_REQ) -->
            <field>
              <name>M16550_0_CLK_REQ</name>
              <description>UART 0 Clock Required (M16550_0_CLK_REQ)
              </description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>

            <!-- GLBL_CFG Clock Required (GLBL_CFG_CLK_REQ) -->
            <field>
              <name>GLBL_CFG_CLK_REQ</name>
              <description>GLBL_CFG Clock Required (GLBL_CFG_CLK_REQ)
              </description>
              <bitRange>[12:12]</bitRange>
              <access>read-only</access>
            </field>

            <!-- ACPI EC 0 Clock Required (ACPI_EC_0_CLK_REQ) -->
            <field>
              <name>ACPI_EC_0_CLK_REQ</name>
              <description>ACPI EC 0 Clock Required (ACPI_EC_0_CLK_REQ)
              </description>
              <bitRange>[13:13]</bitRange>
              <access>read-only</access>
            </field>

            <!-- ACPI EC 1 Clock Required (ACPI_EC_1_CLK_REQ) -->
            <field>
              <name>ACPI_EC_1_CLK_REQ</name>
              <description>ACPI EC 1 Clock Required (ACPI_EC_1_CLK_REQ)
              </description>
              <bitRange>[14:14]</bitRange>
              <access>read-only</access>
            </field>

            <!-- ACPI PM1 Clock Required (ACPI_PM1_CLK_REQ) -->
            <field>
              <name>ACPI_PM1_CLK_REQ</name>
              <description>ACPI PM1 Clock Required (ACPI_PM1_CLK_REQ)
              </description>
              <bitRange>[15:15]</bitRange>
              <access>read-only</access>
            </field>

            <!-- 8042EM Clock Required (8042EM_CLK_REQ) -->
            <field>
              <name>KBCEM_CLK_REQ</name>
              <description>8042EM Clock Required (8042EM_CLK_REQ)
              </description>
              <bitRange>[16:16]</bitRange>
              <access>read-only</access>
            </field>

            <!-- RTC Clock Required (RTC_CLK_REQ) -->
            <field>
              <name>RTC_CLK_REQ</name>
              <description>RTC Clock Required (RTC_CLK_REQ)
              </description>
              <bitRange>[18:18]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>

        <!-- System Sleep Control Register (SYS_SLP_CNTRL) -->
        <register>
          <name>SYS_SLP_CNTRL</name>
          <description>System Sleep Control Register (SYS_SLP_CNTRL)
          </description>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>

          <fields>
            <!-- Ring oscillator power down (ROSC_PD) -->
            <field>
              <name>ROSC_PD</name>
              <description>Ring oscillator power down (ROSC_PD)
              </description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>

            <!-- Ring oscillator output gate (ROSC_GATE) -->
            <field>
              <name>ROSC_GATE</name>
              <description>Ring oscillator output gate (ROSC_GATE)
              </description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>

            <!-- Core regulator standby (REG_STDBY) -->
            <field>
              <name>REG_STDBY</name>
              <description>Core regulator standby (REG_STDBY)
              </description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>

          </fields>
        </register>

        <!-- Processor Clock Control Register (PROC_CLK_CNTRL) -->
        <register>
          <name>PROC_CLK_CNTRL</name>
          <description>Processor Clock Control Register (PROC_CLK_CNTRL) [7:0] Processor Clock Divide Value (PROC_DIV)\n
           0: Clock off (suicide for the processor to do this).\n
           1: divide 48 MHz Ring Oscillator by 1.\n
           4: divide 48 MHz Ring Oscillator by 4.\n
           16: divide 48 MHz Ring Oscillator by 16.\n
           48: divide 48 MHz Ring Oscillator by 48.\n
           No other values are supported
          </description>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
        </register>

        <!-- EC Sleep Enable 2 Register (EC_SLP_EN2) -->
        <register>
          <name>EC_SLP_EN2</name>
          <description>EC Sleep Enable 2 Register (EC_SLP_EN2)
          </description>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>

          <fields>
            <!-- ADC Sleep Enable (ADC_SLP_EN) -->
            <field>
              <name>ADC_SLP_EN</name>
              <description>ADC Sleep Enable (ADC_SLP_EN)
              </description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>

            <!-- PS2_0 Sleep Enable (PS2_0_SLP_EN) -->
            <field>
              <name>PS2_0_SLP_EN</name>
              <description>PS2_0 Sleep Enable (PS2_0_SLP_EN)
              </description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>

            <!-- PS2_1 Sleep Enable (PS2_1_SLP_EN) -->
            <field>
              <name>PS2_1_SLP_EN</name>
              <description>PS2_1 Sleep Enable (PS2_1_SLP_EN)
              </description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>

            <!-- PS2_2 Sleep Enable (PS2_2_SLP_EN) -->
            <field>
              <name>PS2_2_SLP_EN</name>
              <description>PS2_2 Sleep Enable (PS2_2_SLP_EN)
              </description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>

            <!-- PS2_3 Sleep Enable (PS2_3_SLP_EN) -->
            <field>
              <name>PS2_3_SLP_EN</name>
              <description>PS2_3 Sleep Enable (PS2_3_SLP_EN)
              </description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>

            <!-- SPI0 Sleep Enable (SPI0_SLP_EN) -->
            <field>
              <name>SPI0_SLP_EN</name>
              <description>SPI0 Sleep Enable (SPI0_SLP_EN)
              </description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>

            <!-- HTIMER Sleep Enable (HTIMER_SLP_EN) -->
            <field>
              <name>HTIMER_SLP_EN</name>
              <description>HTIMER Sleep Enable (HTIMER_SLP_EN)
              </description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>

            <!-- KEYSCAN Sleep Enable (KEYSCAN_SLP_EN) -->
            <field>
              <name>KEYSCAN_SLP_EN</name>
              <description>KEYSCAN Sleep Enable (KEYSCAN_SLP_EN)
              </description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>

            <!-- RPM-PWM Sleep Enable (RPMPWM_SLP_EN) -->
            <field>
              <name>RPMPWM_SLP_EN</name>
              <description>RPM-PWM Sleep Enable (RPMPWM_SLP_EN)
              </description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>

            <!-- SMB1 Sleep Enable (SMB1_SLP_EN) -->
            <field>
              <name>SMB1_SLP_EN</name>
              <description>SMB1 Sleep Enable (SMB1_SLP_EN)
              </description>
              <bitRange>[13:13]</bitRange>
              <access>read-write</access>
            </field>

            <!-- SMB2 Sleep Enable (SMB2_SLP_EN) -->
            <field>
              <name>SMB2_SLP_EN</name>
              <description>SMB2 Sleep Enable (SMB2_SLP_EN)
              </description>
              <bitRange>[14:14]</bitRange>
              <access>read-write</access>
            </field>

            <!-- SMB3 Sleep Enable (SMB3_SLP_EN) -->
            <field>
              <name>SMB3_SLP_EN</name>
              <description>SMB3 Sleep Enable (SMB3_SLP_EN)
              </description>
              <bitRange>[15:15]</bitRange>
              <access>read-write</access>
            </field>

            <!-- LED0 Sleep Enable (LED0_SLP_EN) -->
            <field>
              <name>LED0_SLP_EN</name>
              <description>LED0 Sleep Enable (LED0_SLP_EN)
              </description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>

            <!-- LED1 Sleep Enable (LED1_SLP_EN) -->
            <field>
              <name>LED1_SLP_EN</name>
              <description>LED1 Sleep Enable (LED1_SLP_EN)
              </description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>

            <!-- LED2 Sleep Enable (LED2_SLP_EN) -->
            <field>
              <name>LED2_SLP_EN</name>
              <description>LED2 Sleep Enable (LED2_SLP_EN)
              </description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>

            <!-- BCM Sleep Enable (BCM_SLP_EN) -->
            <field>
              <name>BCM_SLP_EN</name>
              <description>BCM Sleep Enable (BCM_SLP_EN)
              </description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
            </field>

            <!-- SPI1 Sleep Enable (SPI1_SLP_EN) -->
            <field>
              <name>SPI1_SLP_EN</name>
              <description>SPI1 Sleep Enable (SPI1_SLP_EN)
              </description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>

            <!-- TIMER16_2_Sleep Enable (TIMER16_2_SLP_EN) -->
            <field>
              <name>TIMER16_2_SLP_EN</name>
              <description>TIMER16_2_Sleep Enable (TIMER16_2_SLP_EN)
              </description>
              <bitRange>[21:21]</bitRange>
              <access>read-write</access>
            </field>

            <!-- TIMER16_3 Sleep Enable (TIMER16_3_SLP_EN) -->
            <field>
              <name>TIMER16_3_SLP_EN</name>
              <description>TIMER16_3 Sleep Enable (TIMER16_3_SLP_EN)
              </description>
              <bitRange>[22:22]</bitRange>
              <access>read-write</access>
            </field>

            <!-- TIMER32_0 Sleep Enable (TIMER32_0_SLP_EN) -->
            <field>
              <name>TIMER32_0_SLP_EN</name>
              <description>TIMER32_0 Sleep Enable (TIMER32_0_SLP_EN)
              </description>
              <bitRange>[23:23]</bitRange>
              <access>read-write</access>
            </field>

            <!-- TIMER32_1 Sleep Enable (TIMER32_1_SLP_EN) -->
            <field>
              <name>TIMER32_1_SLP_EN</name>
              <description>TIMER32_1 Sleep Enable (TIMER32_1_SLP_EN)
              </description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
            </field>

            <!-- LED3 Sleep Enable (LED3_SLP_EN) -->
            <field>
              <name>LED3_SLP_EN</name>
              <description>LED3 Sleep Enable (LED3_SLP_EN)
              </description>
              <bitRange>[25:25]</bitRange>
              <access>read-write</access>
            </field>

          </fields>
        </register>

        <!-- EC Clock Required 2 Status Register (EC_CLK_REQ2_STS) -->
        <register>
          <name>EC_CLK_REQ2_STS</name>
          <description>EC Clock Required 2 Status Register (EC_CLK_REQ2_STS)
          </description>
          <addressOffset>0x28</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>

          <fields>

            <!-- ADC Clock Required (ADC_CLK_REQ) -->
            <field>
              <name>ADC_CLK_REQ</name>
              <description>ADC Clock Required (ADC_CLK_REQ)
              </description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
            </field>

            <!-- PS2_0 Clock Required (PS2_0_SLP_CLK_REQ) -->
            <field>
              <name>PS2_0_SLP_CLK_REQ</name>
              <description>PS2_0 Clock Required (PS2_0_SLP_CLK_REQ)
              </description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
            </field>

            <!-- PS2_1 Clock Required (PS2_1_SLP_CLK_REQ) -->
            <field>
              <name>PS2_1_SLP_CLK_REQ</name>
              <description>PS2_1 Clock Required (PS2_1_SLP_CLK_REQ)
              </description>
              <bitRange>[6:6]</bitRange>
              <access>read-only</access>
            </field>

            <!-- PS2_2 Clock Required (PS2_2_SLP_CLK_REQ) -->
            <field>
              <name>PS2_2_SLP_CLK_REQ</name>
              <description>PS2_2 Clock Required (PS2_2_SLP_CLK_REQ)
              </description>
              <bitRange>[7:7]</bitRange>
              <access>read-only</access>
            </field>

            <!-- PS2_3 Clock Required (PS2_3_SLP_CLK_REQ) -->
            <field>
              <name>PS2_3_SLP_CLK_REQ</name>
              <description>PS2_3 Clock Required (PS2_3_SLP_CLK_REQ)
              </description>
              <bitRange>[8:8]</bitRange>
              <access>read-only</access>
            </field>

            <!-- SPI0 Clock Required (SPI0_SLP_CLK_REQ) -->
            <field>
              <name>SPI0_SLP_CLK_REQ</name>
              <description>SPI0 Clock Required (SPI0_SLP_CLK_REQ)
              </description>
              <bitRange>[9:9]</bitRange>
              <access>read-only</access>
            </field>

            <!-- HTIMER Clock Required (HTIMER_SLP_CLK_REQ) -->
            <field>
              <name>HTIMER_SLP_CLK_REQ</name>
              <description>HTIMER Clock Required (HTIMER_SLP_CLK_REQ)
              </description>
              <bitRange>[10:10]</bitRange>
              <access>read-only</access>
            </field>

            <!-- KEYSCAN Clock Required (KEYSCAN_SLP_CLK_REQ) -->
            <field>
              <name>KEYSCAN_SLP_CLK_REQ</name>
              <description>KEYSCAN Clock Required (KEYSCAN_SLP_CLK_REQ)
              </description>
              <bitRange>[11:11]</bitRange>
              <access>read-only</access>
            </field>

            <!-- RPM-PWM Clock Required (RPMPWM_SLP_CLK_REQ) -->
            <field>
              <name>RPMPWM_SLP_CLK_REQ</name>
              <description>RPM-PWM Clock Required (RPMPWM_SLP_CLK_REQ)
              </description>
              <bitRange>[12:12]</bitRange>
              <access>read-only</access>
            </field>

            <!-- SMB1 Clock Required (SMB1_SLP_CLK_REQ) -->
            <field>
              <name>SMB1_SLP_CLK_REQ</name>
              <description>SMB1 Clock Required (SMB1_SLP_CLK_REQ)
              </description>
              <bitRange>[13:13]</bitRange>
              <access>read-only</access>
            </field>

            <!-- SMB2 Clock Required (SMB2_SLP_CLK_REQ) -->
            <field>
              <name>SMB2_SLP_CLK_REQ</name>
              <description>SMB2 Clock Required (SMB2_SLP_CLK_REQ)
              </description>
              <bitRange>[14:14]</bitRange>
              <access>read-only</access>
            </field>

            <!-- SMB3 Clock Required (SMB3_SLP_CLK_REQ) -->
            <field>
              <name>SMB3_SLP_CLK_REQ</name>
              <description>SMB3 Clock Required (SMB3_SLP_CLK_REQ)
              </description>
              <bitRange>[15:15]</bitRange>
              <access>read-only</access>
            </field>

            <!-- LED0 Clock Required (LED0_SLP_CLK_REQ) -->
            <field>
              <name>LED0_SLP_CLK_REQ</name>
              <description>LED0 Clock Required (LED0_SLP_CLK_REQ)
              </description>
              <bitRange>[16:16]</bitRange>
              <access>read-only</access>
            </field>

            <!-- LED1 Clock Required (LED1_SLP_CLK_REQ) -->
            <field>
              <name>LED1_SLP_CLK_REQ</name>
              <description>LED1 Clock Required (LED1_SLP_CLK_REQ)
              </description>
              <bitRange>[17:17]</bitRange>
              <access>read-only</access>
            </field>

            <!-- LED2 Clock Required (LED2_SLP_CLK_REQ) -->
            <field>
              <name>LED2_SLP_CLK_REQ</name>
              <description>LED2 Clock Required (LED2_SLP_CLK_REQ)
              </description>
              <bitRange>[18:18]</bitRange>
              <access>read-only</access>
            </field>

            <!-- BCM Clock Required (BCM_SLP_CLK_REQ) -->
            <field>
              <name>BCM_SLP_CLK_REQ</name>
              <description>BCM Clock Required (BCM_SLP_CLK_REQ)
              </description>
              <bitRange>[19:19]</bitRange>
              <access>read-only</access>
            </field>

            <!-- SPI1 Clock Required (SPI1_SLP_CLK_REQ) -->
            <field>
              <name>SPI1_SLP_CLK_REQ</name>
              <description>SPI1 Clock Required (SPI1_SLP_CLK_REQ)
              </description>
              <bitRange>[20:20]</bitRange>
              <access>read-only</access>
            </field>

            <!-- TIMER16_2_Clock Required (TIMER16_2_SLP_CLK_REQ) -->
            <field>
              <name>TIMER16_2_SLP_CLK_REQ</name>
              <description>TIMER16_2_Clock Required (TIMER16_2_SLP_CLK_REQ)
              </description>
              <bitRange>[21:21]</bitRange>
              <access>read-only</access>
            </field>

            <!-- TIMER16_3 Clock Required (TIMER16_3_SLP_CLK_REQ) -->
            <field>
              <name>TIMER16_3_SLP_CLK_REQ</name>
              <description>TIMER16_3 Clock Required (TIMER16_3_SLP_CLK_REQ)
              </description>
              <bitRange>[22:22]</bitRange>
              <access>read-only</access>
            </field>

            <!-- TIMER32_0 Clock Required (TIMER32_0_SLP_CLK_REQ) -->
            <field>
              <name>TIMER32_0_SLP_CLK_REQ</name>
              <description>TIMER32_0 Clock Required (TIMER32_0_SLP_CLK_REQ)
              </description>
              <bitRange>[23:23]</bitRange>
              <access>read-only</access>
            </field>

            <!-- TIMER32_1 Clock Required (TIMER32_1_SLP_CLK_REQ) -->
            <field>
              <name>TIMER32_1_SLP_CLK_REQ</name>
              <description>TIMER32_1 Clock Required (TIMER32_1_SLP_CLK_REQ)
              </description>
              <bitRange>[24:24]</bitRange>
              <access>read-only</access>
            </field>

            <!-- LED3 Clock Required (LED3_SLP_CLK_REQ) -->
            <field>
              <name>LED3_SLP_CLK_REQ</name>
              <description>LED3 Clock Required (LED3_SLP_CLK_REQ)
              </description>
              <bitRange>[25:25]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>

        <!-- Slow Clock Control Register (SLOW_CLK_CNTRL) -->
        <register>
          <name>SLOW_CLK_CNTRL</name>
          <description>Slow Clock Control Register (SLOW_CLK_CNTRL)  Slow Clock (100 kHz) Divide Value (slow_div) Configures the 100kHz_Clk.\n
           0: Clock off \n
           n: divide by n.\n
           Note: The default setting is for 100 kHz.
          </description>
          <addressOffset>0x2C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x000001E0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
        </register>

        <!-- Oscillator ID Register (CHIP_OSC_ID) -->
        <register>
          <name>CHIP_OSC_ID</name>
          <description>Oscillator ID Register (CHIP_OSC_ID)
          </description>
          <addressOffset>0x30</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>

          <fields>
            <!-- OSC_LOCK (OSC_LOCK) -->
            <field>
              <name>OSC_LOCK</name>
              <description>OSC_LOCK (OSC_LOCK)
              </description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>

        <!-- PCR chip sub-system power reset status (CHIP_PWR_RST_STS) -->
        <register>
          <name>CHIP_PWR_RST_STS</name>
          <description>PCR chip sub-system power reset status (CHIP_PWR_RST_STS)
          </description>
          <addressOffset>0x34</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>

          <fields>
            <!-- VCC Reset Status (VCC_RST_N) -->
            <field>
              <name>VCC_RST_N</name>
              <description>VCC Reset Status (VCC_RST_N) Indicates the status of PWRGD. 0 = reset active (PWRGD not asserted). 1 = reset not active (PWRGD asserted).
              </description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>

            <!-- SIO_Reset Status (SIO_RST_N) -->
            <field>
              <name>SIO_RST_N</name>
              <description>SIO_Reset Status (SIO_RST_N) Indicates the status of nSIO_RESET. 0 = reset active. 1 = reset not active.
              </description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
            </field>

            <!-- VBAT reset status (VBAT_RST_N) -->
            <field>
              <name>VBAT_RST_N</name>
              <description>VBAT reset status (VBAT_RST_N) 0 = No reset occurred while VCC1 was off or since the last time this bit was cleared. 1 = A reset occurred.(R/WC)
              </description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>

            <!-- VCC1 reset status (VCC1_RST_N) -->
            <field>
              <name>VCC1_RST_N</name>
              <description>VCC1 reset status (VCC1_RST_N) Indicates the status of VCC1_RESET.(R/WC)\n
               0 = No reset occurred since the last time this bit was cleared.\n
               1 = A reset occurred.
              </description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>

            <!-- 32K_ACTIVE (32K_ACTIVE) -->
            <field>
              <name>_32K_ACTIVE</name>
              <description>32K_ACTIVE (32K_ACTIVE)
              </description>
              <bitRange>[10:10]</bitRange>
              <access>read-only</access>
            </field>

            <!-- PCICLK_ACTIVE (PCICLK_ACTIVE) -->
            <field>
              <name>PCICLK_ACTIVE</name>
              <description>PCICLK_ACTIVE (PCICLK_ACTIVE)
              </description>
              <bitRange>[11:11]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>

        <!-- Chip Reset Enable Register (CHIP_RST_EN) -->
        <register>
          <name>CHIP_RST_EN</name>
          <description>Chip Reset Enable Register (CHIP_RST_EN) MCHP Reserved
          </description>
          <addressOffset>0x38</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
        </register>

        <!-- Host Reset Enable Register (HOST_RST_EN) -->
        <register>
          <name>HOST_RST_EN</name>
          <description>Host Reset Enable Register (HOST_RST_EN) 0: block will not be reset on sleep. 1: block will be reset on sleep.
          </description>
          <addressOffset>0x3C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>

          <fields>
            <!-- LPC Reset Enable (LPC_RST_EN) -->
            <field>
              <name>LPC_RST_EN</name>
              <description>LPC Reset Enable (LPC_RST_EN)
              </description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>

            <!-- UART 0 Reset Enable (M16550_0_RST_EN) -->
            <field>
              <name>M16550_0_RST_EN</name>
              <description>UART 0 Reset Enable (M16550_0_RST_EN)
              </description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>

            <!-- GLBL_CFG Reset Enable (GLBL_CFG_RST_EN) -->
            <field>
              <name>GLBL_CFG_RST_EN</name>
              <description>GLBL_CFG Reset Enable (GLBL_CFG_RST_EN)
              </description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>

            <!-- ACPI EC 0 Reset Enable (ACPI_EC_0_RST_EN) -->
            <field>
              <name>ACPI_EC_0_RST_EN</name>
              <description>ACPI EC 0 Reset Enable (ACPI_EC_0_RST_EN)
              </description>
              <bitRange>[13:13]</bitRange>
              <access>read-write</access>
            </field>

            <!-- ACPI EC 1 Reset Enable (ACPI_EC_1_RST_EN) -->
            <field>
              <name>ACPI_EC_1_RST_EN</name>
              <description>ACPI EC 1 Reset Enable (ACPI_EC_1_RST_EN)
              </description>
              <bitRange>[14:14]</bitRange>
              <access>read-write</access>
            </field>

            <!-- ACPI PM1 Reset Enable (ACPI_PM1_RST_EN) -->
            <field>
              <name>ACPI_PM1_RST_EN</name>
              <description>ACPI PM1 Reset Enable (ACPI_PM1_RST_EN)
              </description>
              <bitRange>[15:15]</bitRange>
              <access>read-write</access>
            </field>

            <!-- 8042EM Reset Enable (8042EM_RST_EN) -->
            <field>
              <name>KBCEM_RST_EN</name>
              <description>8042EM Reset Enable (8042EM_RST_EN)
              </description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>

            <!-- RTC Reset Enable (RTC_RST_EN) -->
            <field>
              <name>RTC_RST_EN</name>
              <description>RTC Reset Enable (RTC_RST_EN)
              </description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>

        <!-- EC Reset Enable Register (EC_RST_EN) -->
        <register>
          <name>EC_RST_EN</name>
          <description>EC Reset Enable Register (EC_RST_EN) 0: block will not be reset on sleep. 1: block will be reset on sleep.
          </description>
          <addressOffset>0x40</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>

          <fields>
            <!-- INT Reset Enable (INT_RST_EN) -->
            <field>
              <name>INT_RST_EN</name>
              <description>INT Reset Enable (INT_RST_EN)
              </description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>

            <!-- PECI Reset Enable (PECI_RST_EN) -->
            <field>
              <name>PECI_RST_EN</name>
              <description>PECI Reset Enable (PECI_RST_EN)
              </description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>

            <!-- TACH0 Reset Enable (TACH0_RST_EN) -->
            <field>
              <name>TACH0_RST_EN</name>
              <description>TACH0 Reset Enable (TACH0_RST_EN)
              </description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>

            <!-- PWM0 Reset Enable (PWM0_RST_EN) -->
            <field>
              <name>PWM0_RST_EN</name>
              <description>PWM0 Reset Enable (PWM0_RST_EN)
              </description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>

            <!-- PMC Reset Enable (PMC_RST_EN) -->
            <field>
              <name>PMC_RST_EN</name>
              <description>PMC Reset Enable (PMC_RST_EN)
              </description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>

            <!-- DMA Reset Enable (DMA_RST_EN) -->
            <field>
              <name>DMA_RST_EN</name>
              <description>DMA Reset Enable (DMA_RST_EN)
              </description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>

            <!-- TFDP Reset Enable (TFDP_RST_EN) -->
            <field>
              <name>TFDP_RST_EN</name>
              <description>TFDP Reset Enable (TFDP_RST_EN)
              </description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>

            <!-- PROCESSOR Sleep Enable (PROCESSOR_RST_EN) -->
            <field>
              <name>PROCESSOR_RST_EN</name>
              <description>PROCESSOR Sleep Enable (PROCESSOR_RST_EN)
              </description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>

            <!-- WDT Reset Enable (WDT_RST_EN) -->
            <field>
              <name>WDT_RST_EN</name>
              <description>WDT Reset Enable (WDT_RST_EN)
              </description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>

            <!-- SMB0 Reset Enable (SMB0_RST_EN) -->
            <field>
              <name>SMB0_RST_EN</name>
              <description>SMB0 Reset Enable (SMB0_RST_EN)
              </description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>

            <!-- TACH1 Reset Enable (TACH1_RST_EN) -->
            <field>
              <name>TACH1_RST_EN</name>
              <description>TACH1 Reset Enable (TACH1_RST_EN)
              </description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>

            <!-- PWM1 Reset Enable (PWM1_RST_EN) -->
            <field>
              <name>PWM1_RST_EN</name>
              <description>PWM1 Reset Enable (PWM1_RST_EN)
              </description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>

            <!-- PWM2 Reset Enable (PWM2_RST_EN) -->
            <field>
              <name>PWM2_RST_EN</name>
              <description>PWM2 Reset Enable (PWM2_RST_EN)
              </description>
              <bitRange>[21:21]</bitRange>
              <access>read-write</access>
            </field>

            <!-- PWM3 Reset Enable (PWM3_RST_EN) -->
            <field>
              <name>PWM3_RST_EN</name>
              <description>PWM3 Reset Enable (PWM3_RST_EN)
              </description>
              <bitRange>[22:22]</bitRange>
              <access>read-write</access>
            </field>

            <!-- EC_REG_BANK Reset Enable (EC_REG_BANK_RST_EN) -->
            <field>
              <name>EC_REG_BANK_RST_EN</name>
              <description>EC_REG_BANK Reset Enable (EC_REG_BANK_RST_EN)
              </description>
              <bitRange>[29:29]</bitRange>
              <access>read-write</access>
            </field>

            <!-- TIMER16_0 Reset Enable (TIMER16_0_RST_EN) -->
            <field>
              <name>TIMER16_0_RST_EN</name>
              <description>TIMER16_0 Reset Enable (TIMER16_0_RST_EN)
              </description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>

            <!-- TIMER16_1 Reset Enable (TIMER16_1_RST_EN) -->
            <field>
              <name>TIMER16_1_RST_EN</name>
              <description>TIMER16_1 Reset Enable (TIMER16_1_RST_EN)
              </description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>

        <!-- EC Reset Enable 2 Register (EC_RST_EN2) -->
        <register>
          <name>EC_RST_EN2</name>
          <description>EC Reset Enable 2 Register (EC_RST_EN2)  0: block will not be reset on sleep. 1: block will be reset on sleep.
          </description>
          <addressOffset>0x44</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>

          <fields>
            <!-- ADC Reset Enable (ADC_RST_EN) -->
            <field>
              <name>ADC_RST_EN</name>
              <description>ADC Reset Enable (ADC_RST_EN)
              </description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>

            <!-- PS2_0 Reset Enable (PS2_0_RST_EN) -->
            <field>
              <name>PS2_0_RST_EN</name>
              <description>PS2_0 Reset Enable (PS2_0_RST_EN)
              </description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>

            <!-- PS2_1 Reset Enable (PS2_1_RST_EN) -->
            <field>
              <name>PS2_1_RST_EN</name>
              <description>PS2_1 Reset Enable (PS2_1_RST_EN)
              </description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>

            <!-- PS2_2 Reset Enable (PS2_2_RST_EN) -->
            <field>
              <name>PS2_2_RST_EN</name>
              <description>PS2_2 Reset Enable (PS2_2_RST_EN)
              </description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>

            <!-- PS2_3 Reset Enable (PS2_3_RST_EN) -->
            <field>
              <name>PS2_3_RST_EN</name>
              <description>PS2_3 Reset Enable (PS2_3_RST_EN)
              </description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>

            <!-- SPI0 Reset Enable (SPI0_SLP_EN) -->
            <field>
              <name>SPI0_SLP_EN</name>
              <description>SPI0 Reset Enable (SPI0_SLP_EN)
              </description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>

            <!-- HTIMER Reset Enable (HTIMER_RST_EN) -->
            <field>
              <name>HTIMER_RST_EN</name>
              <description>HTIMER Reset Enable (HTIMER_RST_EN)
              </description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>

            <!-- KEYSCAN Reset Enable (KEYSCAN_RST_EN) -->
            <field>
              <name>KEYSCAN_RST_EN</name>
              <description>KEYSCAN Reset Enable (KEYSCAN_RST_EN)
              </description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>

            <!-- RPM-PWM Reset Enable (RPMPWM_RST_EN) -->
            <field>
              <name>RPMPWM_RST_EN</name>
              <description>RPM-PWM Reset Enable (RPMPWM_RST_EN)
              </description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>

            <!-- SMB1 Reset Enable (SMB1_RST_EN) -->
            <field>
              <name>SMB1_RST_EN</name>
              <description>SMB1 Reset Enable (SMB1_RST_EN)
              </description>
              <bitRange>[13:13]</bitRange>
              <access>read-write</access>
            </field>

            <!-- SMB2 Reset Enable (SMB2_RST_EN) -->
            <field>
              <name>SMB2_RST_EN</name>
              <description>SMB2 Reset Enable (SMB2_RST_EN)
              </description>
              <bitRange>[14:14]</bitRange>
              <access>read-write</access>
            </field>

            <!-- SMB3 Reset Enable (SMB3_RST_EN) -->
            <field>
              <name>SMB3_RST_EN</name>
              <description>SMB3 Reset Enable (SMB3_RST_EN)
              </description>
              <bitRange>[15:15]</bitRange>
              <access>read-write</access>
            </field>

            <!-- LED0 Reset Enable (LED0_RST_EN) -->
            <field>
              <name>LED0_RST_EN</name>
              <description>LED0 Reset Enable (LED0_RST_EN)
              </description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>

            <!-- LED1 Reset Enable (LED1_RST_EN) -->
            <field>
              <name>LED1_RST_EN</name>
              <description>LED1 Reset Enable (LED1_RST_EN)
              </description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>

            <!-- LED2 Reset Enable (LED2_RST_EN) -->
            <field>
              <name>LED2_RST_EN</name>
              <description>LED2 Reset Enable (LED2_RST_EN)
              </description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>

            <!-- BCM Reset Enable (BCM_RST_EN) -->
            <field>
              <name>BCM_RST_EN</name>
              <description>BCM Reset Enable (BCM_RST_EN)
              </description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
            </field>

            <!-- SPI1 Reset Enable (SPI1_RST_EN) -->
            <field>
              <name>SPI1_RST_EN</name>
              <description>SPI1 Reset Enable (SPI1_RST_EN)
              </description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>

            <!-- TIMER16_2_Reset Enable (TIMER16_2_RST_EN) -->
            <field>
              <name>TIMER16_2_RST_EN</name>
              <description>TIMER16_2_Reset Enable (TIMER16_2_RST_EN)
              </description>
              <bitRange>[21:21]</bitRange>
              <access>read-write</access>
            </field>

            <!-- TIMER16_3 Reset Enable (TIMER16_3_RST_EN) -->
            <field>
              <name>TIMER16_3_RST_EN</name>
              <description>TIMER16_3 Reset Enable (TIMER16_3_RST_EN)
              </description>
              <bitRange>[22:22]</bitRange>
              <access>read-write</access>
            </field>

            <!-- TIMER32_0 Reset Enable (TIMER32_0_RST_EN) -->
            <field>
              <name>TIMER32_0_RST_EN</name>
              <description>TIMER32_0 Reset Enable (TIMER32_0_RST_EN)
              </description>
              <bitRange>[23:23]</bitRange>
              <access>read-write</access>
            </field>

            <!-- TIMER32_1 Reset Enable (TIMER32_1_RST_EN) -->
            <field>
              <name>TIMER32_1_RST_EN</name>
              <description>TIMER32_1 Reset Enable (TIMER32_1_RST_EN)
              </description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
            </field>

            <!-- LED3 Reset Enable (LED3_RST_EN) -->
            <field>
              <name>LED3_RST_EN</name>
              <description>LED3 Reset Enable (LED3_RST_EN)
              </description>
              <bitRange>[25:25]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>

        <!-- Power Reset Control (PWR_RST_CTRL) Register -->
        <register>
          <name>PWR_RST_CTRL</name>
          <description>Power Reset Control (PWR_RST_CTRL) Register
          </description>
          <addressOffset>0x48</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000001</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>

          <fields>
            <!-- iRESET_OUT (IRESET_OUT) -->
            <field>
              <name>IRESET_OUT</name>
              <description>iRESET_OUT (IRESET_OUT)
              </description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <!--  -->

    <peripheral>
    <!-- < Chapter 4.0 >  VBAT Register Bank  -->
    <!-- 4000A400  VBAT Registers                  0  VBAT_EC_REG_BANK       Power-Fail and Reset Status Register                 -->
    <!-- 4000A404  VBAT Registers                  0  VBAT_EC_REG_BANK       MCHP Reserved                                        -->
    <!-- 4000A408  VBAT Registers                  0  VBAT_EC_REG_BANK       Clock Enable Register                                -->
    <!-- 4000A800  VBAT Powered RAM                0  Registers              VBAT Backed Memory                                   -->
    <!--  -->
      <name>VBAT</name>
      <version>1.0</version>
      <description>The VBAT Register Bank block is a block implemented for aggregating miscellaneous\n
       battery-backed registers required the host and by the Embedded Controller (EC) Subsystem that are\n
       not unique to a block implemented in the EC subsystem.\n
       \n
       The VBAT Powered RAM provides a 64 Byte Random Accessed Memory that is operational while the main \n
       power rail is operational, and will retain its values powered by battery power while the main rail is unpowered.
      </description>
      <groupName>VBAT</groupName>
      <baseAddress>0x4000A400</baseAddress>
      <size>32</size>
      <access>read-write</access>

      <addressBlock>
        <offset>0</offset>
        <size>0x010</size>
        <usage>registers</usage>
      </addressBlock>

      <interrupt>
        <name>PFR_STS</name>
        <description>PFR_STS Interrupt ..................... Also see GIRQ 17.25</description>
        <value>43</value>
      </interrupt>

      <registers>
        <!-- Power-Fail and Reset Status Register (PFR_STS) -->
        <register>
          <name>PFR_STS</name>
          <description>The Power-Fail and Reset Status Register collects and retains the VBAT RST and WDT event status when VCC1 is unpowered.
          </description>
          <addressOffset>0x00</addressOffset>
          <size>8</size>
          <access>read-write</access>
          <resetValue>0x80</resetValue>
          <resetMask>0xFF</resetMask>

          <fields>
            <!-- DET32K_IN -->
            <field>
              <name>DET32K_IN</name>
              <description>0 = No clock detected on the XTAL[1:2] pins. 1= Clock detected on the XTAL[1:2] pins.
              </description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>

            <!-- WDT -->
            <field>
              <name>WDT</name>
              <description>The WDT bit is asserted ('1') following a Watch-Dog Timer Forced Reset (WDT Event). To clear the WDT bit EC firmware must write a '1' to this bit; writing a '0' to the WDT bit has no affect.
              </description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>

            <!-- VBAT_RST -->
            <field>
              <name>VBAT_RST</name>
              <description>The VBAT RST bit is set to '1' by hardware when a VBAT_POR is detected.(R/WC)
              </description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>

          </fields>
        </register>

        <!-- CLOCK ENABLE REGISTER (CLOCK_EN) -->
        <register>
          <name>CLOCK_EN</name>
          <description>CLOCK ENABLE Control
          </description>
          <addressOffset>0x08</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>

          <fields>
            <!-- XOSEL (XOSEL) -->
            <field>
              <name>XOSEL</name>
              <description>This bit controls whether a crystal or single ended clock source is used.\n
               1= the 32.768 KHz Crystal Oscillator is driven by a single-ended 32.768 KHz clock source connected to the XTAL2 pin. \n
               0= the 32.768 KHz Crystal Oscillator requires a 32.768 KHz parallel resonant crystal connected between the XTAL1 and XTAL2 pins (default).
              </description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>

            <!-- 32K_EN (32K_EN) -->
            <field>
              <name>_32K_EN</name>
              <description>0: 32.768 KHz Crystal Oscillator OFF (VBAT_POR default).\n
               1: 32.768 KHz Crystal Oscillator ON. The 32.768 KHz Crystal Oscillator can only be enabled by firmware
              </description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <!--  -->

    <peripheral>
    <!-- < Chapter 5.0 >  LPC Interface  -->
    <!-- RUNTIME REGISTER SUMMARY  -->
    <!-- 400F3000  LPC                             0  LPC_Runtime            Configuration Port Index Register                    -->
    <!-- 400F3001  LPC                             0  LPC_Runtime            Configuration Port Data Register                     -->
    <!-- EC-ONLY REGISTER SUMMARY  -->
    <!-- 400F3104  LPC                             0  LPC_EC_Only            LPC Bus Monitor Register                             -->
    <!-- 400F3108  LPC                             0  LPC_EC_Only            Host Bus Error Register                              -->
    <!-- 400F310C  LPC                             0  LPC_EC_Only            EC SERIRQ Register                                   -->
    <!-- 400F3110  LPC                             0  LPC_EC_Only            EC Clock Control Register                            -->
    <!-- 400F3120  LPC                             0  LPC_EC_Only            BAR Inhibit Register                                 -->
    <!-- 400F3130  LPC                             0  LPC_EC_Only            LPC BAR Init Register                                -->
    <!-- CONFIGURATION REGISTER SUMMARY  -->
    <!-- 400F3330  LPC                             0  LPC_Config             LPC Activate                                         -->
    <!-- 400F3340  LPC                             0  LPC_Config             SIRQ0 Interrupt Configuration Register               -->
    <!-- 400F3341  LPC                             0  LPC_Config             SIRQ1 Interrupt Configuration Register               -->
    <!-- 400F3342  LPC                             0  LPC_Config             SIRQ2 Interrupt Configuration Register               -->
    <!-- 400F3343  LPC                             0  LPC_Config             SIRQ3 Interrupt Configuration Register               -->
    <!-- 400F3344  LPC                             0  LPC_Config             SIRQ4 Interrupt Configuration Register               -->
    <!-- 400F3345  LPC                             0  LPC_Config             SIRQ5 Interrupt Configuration Register               -->
    <!-- 400F3346  LPC                             0  LPC_Config             SIRQ6 Interrupt Configuration Register               -->
    <!-- 400F3347  LPC                             0  LPC_Config             SIRQ7 Interrupt Configuration Register               -->
    <!-- 400F3348  LPC                             0  LPC_Config             SIRQ8 Interrupt Configuration Register               -->
    <!-- 400F3349  LPC                             0  LPC_Config             SIRQ9 Interrupt Configuration Register               -->
    <!-- 400F334A  LPC                             0  LPC_Config             SIRQ10 Interrupt Configuration Register              -->
    <!-- 400F334B  LPC                             0  LPC_Config             SIRQ11 Interrupt Configuration Register              -->
    <!-- 400F334C  LPC                             0  LPC_Config             SIRQ12 Interrupt Configuration Register              -->
    <!-- 400F334D  LPC                             0  LPC_Config             SIRQ13 Interrupt Configuration Register              -->
    <!-- 400F334E  LPC                             0  LPC_Config             SIRQ14 Interrupt Configuration Register              -->
    <!-- 400F334F  LPC                             0  LPC_Config             SIRQ15 Interrupt Configuration Register              -->
    <!-- 400F3360  LPC                             0  LPC_Config             LPC Interface BAR Register                           -->
    <!-- 400F3364  LPC                             0  LPC_Config             EM Interface 0 BAR                                   -->
    <!-- 400F3368  LPC                             0  LPC_Config             UART 0 BAR Register                                  -->
    <!-- 400F3378  LPC                             0  LPC_Config             Keyboard Controller BAR                              -->
    <!-- 400F3388  LPC                             0  LPC_Config             ACPI EC Interface 0 BAR                              -->
    <!-- 400F338C  LPC                             0  LPC_Config             ACPI EC Interface 1 BAR                              -->
    <!-- 400F3390  LPC                             0  LPC_Config             ACPI PM1 Interface BAR                               -->
    <!-- 400F3394  LPC                             0  LPC_Config             Legacy (GATEA20) Interface BAR                       -->
    <!-- 400F3398  LPC                             0  LPC_Config             Mailbox Registers Interface BAR                      -->
    <!-- 400F339C  LPC                             0  LPC_Config             RTC Registers Interface BAR                          -->
    <!-- 400F33C0  LPC                             0  LPC_Config             Mailbox Registers I/F Memory BAR                     -->
    <!-- 400F33C6  LPC                             0  LPC_Config             ACPI EC Interface 0 Memory BAR                       -->
    <!-- 400F33CC  LPC                             0  LPC_Config             ACPI EC Interface 1 Memory BAR                       -->
    <!-- 400F33D2  LPC                             0  LPC_Config             EM Interface 0 Memory BAR                            -->
    <!--  -->
      <name>LPC</name>
      <version>1.0</version>
      <description>The registers defined for the LPC Interface block are accessible by the\n
      various hosts as indicated in Section 5.9, "LPC Configuration Registers", Section 5.10,\n
      "EC-Only Registers"and Section 5.11, "Runtime Registers".
      </description>
      <groupName>LPC_INTERFACE</groupName>
      <baseAddress>0x400F3000</baseAddress>
      <size>32</size>
      <access>read-write</access>

      <addressBlock>
        <offset>0</offset>
        <size>0x400</size>
        <usage>registers</usage>
      </addressBlock>

      <interrupt>
        <name>LPC</name>
        <description>LPC Interrupt ......................... Also see GIRQ 14.2</description>
        <value>12</value>
      </interrupt>

      <registers>
        <!-- INDEX Register -->
        <register>
          <name>INDEX</name>
          <description>The INDEX register, which is part of the Configuration Port, is used as a pointer to a Configuration Register Address.
          </description>
          <addressOffset>0x00</addressOffset>
          <size>8</size>
          <access>read-write</access>
          <resetValue>0x00</resetValue>
          <resetMask>0xFF</resetMask>
        </register>

        <!-- DATA Register -->
        <register>
          <name>DATA</name>
          <description>The DATA register, which is part of the Configuration Port, is used to read or write data to the register currently being selected by the INDEX Register.
          </description>
          <addressOffset>0x01</addressOffset>
          <size>8</size>
          <access>read-write</access>
          <resetValue>0x00</resetValue>
          <resetMask>0xFF</resetMask>
        </register>

        <!-- LPC Bus Monitor Register -->
        <register>
          <name>BUS_MONITOR</name>
          <description>LPC BUS MONITOR REGISTER
          </description>
          <addressOffset>0x104</addressOffset>
          <size>32</size>
          <access>read</access>
          <resetValue>0x0000</resetValue>
          <resetMask>0xFFFF</resetMask>

          <fields>
            <!-- LRESET: LRESET_STATUS -->
            <field>
              <name>LRESET_STATUS</name>
              <description>This bit reflects the state of the LRESET# input pin. The LRESET_Status is the inverse of the LRESET# pin.
              </description>
              <bitRange>[1:1]</bitRange>
              <access>read</access>

              <enumeratedValues>
                <enumeratedValue>
                  <name>Inactive</name>
                  <description>When the LRESET_Status bit is '0b', the LRESET# input pin is deasserted (that is, the pin has the value '1b').
                  </description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Active</name>
                  <description>When the LRESET_Status bit is '1b', the LRESET# input pin is asserted (that is, the pin has the value '0b').
                  </description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>

        <!-- Host Bus Error Register -->
        <register>
          <name>HOST_BUS_ERROR</name>
          <description>Host Bus Error Register
          </description>
          <addressOffset>0x108</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0000</resetValue>
          <resetMask>0xFFFF</resetMask>

          <fields>
            <!-- LPC: LPC_INTERNAL_ERR -->
            <field>
              <name>LPC_ERR</name>
              <description>A BAR conflict or an internal bus error occurs as a result of an LPC access. (R/WC)
              </description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>

            <!--  EN: EN_INTERNAL_ERR -->
            <field>
              <name>EN_ERR</name>
              <description>Internal bus errors will also cause LPC_INTERNAL_ERR to be set. (R/WC)
              </description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>

            <!-- BAR: BAR_CONFLICT -->
            <field>
              <name>BAR_ERR</name>
              <description>a BAR conflict occurs on an LPC address. (R/WC)
              </description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>

            <!-- RUNTIME: RUNTIME_ERR -->
            <field>
              <name>RUNTIME_ERR</name>
              <description>EN_INTERNAL_ERR is 1 and an LPC I/O access causes an internal bus error. This error will only occur if a BAR is misconfigured. (R/WC)
              </description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>

            <!-- CONFIG: CONFIG_ERR -->
            <field>
              <name>CONFIG_ERR</name>
              <description>EN_INTERNAL_ERR is 1 and an LPC Configuration access causes an internal bus error. (R/WC)
              </description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>

            <!-- DMA: DMA_ERR -->
            <field>
              <name>DMA_ERR</name>
              <description>EN_INTERNAL_ERR is 1 and an LPC DMA access causes an internal bus error. (R/WC)
              </description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>

            <!-- ERR_ADDR: ErrorAddress[23:16] -->
            <field>
              <name>ERR_ADDR</name>
              <description>This 24-bit field captures the 24-bit internal address of every LPC transaction whenever the bit LPC_INTERNAL_ERR in this register is 0.
              </description>
              <bitRange>[31:8]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>

        <!-- EC SERIRQ Register -->
        <register>
          <name>EC_SERIRQ</name>
          <description>If the LPC Logical Device is selected as the source for a Serial Interrupt Request by an Interrupt Configuration register, this bit is used as the interrupt source.
          </description>
          <addressOffset>0x10C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0000</resetValue>
          <resetMask>0xFFFF</resetMask>

          <fields>
            <!-- EC_IRQ -->
            <field>
              <name>EC_IRQ</name>
              <description>This bit is used as the interrupt source of a LPC Logical Device
              </description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>

        <!-- EC CLOCK CONTROL REGISTER -->
        <register>
          <name>CLK_CTRL</name>
          <description>Controls throughput of LPC transactions.
          </description>
          <addressOffset>0x110</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0004</resetValue>
          <resetMask>0xFFFF</resetMask>

          <fields>
            <!-- Clock_Control -->
            <field>
              <name>CR</name>
              <description>This field controls when the host interface will permit the internal ring oscillator to be shut down.
              </description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
            </field>

            <!-- Handshake -->
            <field>
              <name>HANDSHAKE</name>
              <description>This bit controls throughput of LPC transactions.
              </description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>

        <!-- BAR Inhibit Register -->
        <register>
          <name>BAR_INHIBIT</name>
          <description>The BAR for Logical Device i is disabled and its addresses will not be claimed on the LPC bus
          </description>
          <addressOffset>0x120</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0000</resetValue>
          <resetMask>0xFFFF</resetMask>
        </register>

        <!-- LPC BAR Init Register -->
        <register>
          <name>BAR_INIT</name>
          <description>This field is loaded into the LPC BAR at offset 60h on nSIO_RESET.
          </description>
          <addressOffset>0x130</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x002E</resetValue>
          <resetMask>0x00FF</resetMask>
        </register>

        <!-- LPC Activate -->
        <register>
          <name>ACTIVATE</name>
          <description>The LPC Logical Device is powered and functional.
          </description>
          <addressOffset>0x330</addressOffset>
          <size>8</size>
          <access>read-write</access>
          <resetValue>0x00</resetValue>
          <resetMask>0xFF</resetMask>
        </register>

        <!-- SIRQ[0-15] Interrupt Configuration Register -->
        <register>
          <dim>16</dim>
          <dimIncrement>1</dimIncrement>
          <dimIndex>0-15</dimIndex>
          <name>SIRQ[%s]</name>
          <description>The LPC Controller implements 16 IRQ channels that may be configured to be asserted by any logical device.
          </description>
          <addressOffset>0x340</addressOffset>
          <size>8</size>
          <access>read-write</access>
          <resetValue>0x00</resetValue>
          <resetMask>0xFF</resetMask>

          <fields>
            <!-- FRAME -->
            <field>
              <name>FRAME</name>
              <description>These six bits select the Logical Device for on-chip devices as the source for the interrupt.
              </description>
              <bitRange>[5:0]</bitRange>
              <access>read-write</access>
            </field>

            <!-- DEVICE -->
            <field>
              <name>DEVICE</name>
              <description>This field should always be set to 0 in order to enable a SERIRQ.
              </description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>

            <!-- SELECT -->
            <field>
              <name>SELECT</name>
              <description>If this bit is 1, the first interrupt signal from the Logical Device is selected for the SERIRQ vector. If this bit is 0, the second interrupt signal from the Logical Device is selected.
              </description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>

        <!-- LPC Interface BAR Register -->
        <register>
          <name>LPC_BAR</name>
          <description>LPC Interface BAR Register
          </description>
          <addressOffset>0x360</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x002E0C01</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>

          <fields>
            <!-- MASK -->
            <field>
              <name>MASK</name>
              <description>These 8 bits are used to mask off address bits in the address match between an LPC I/O address and the Host Address field of the BARs
              </description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>

            <!-- FRAME -->
            <field>
              <name>FRAME</name>
              <description>These 6 bits are used to specify a logical device frame number within a bus.
              </description>
              <bitRange>[13:8]</bitRange>
              <access>read-write</access>
            </field>

            <!-- DEVICE -->
            <field>
              <name>DEVICE</name>
              <description>This bit combined with FRAME constitute the Logical Device Number. DEVICE identifies the physical location of the logical device.
              </description>
              <bitRange>[14:14]</bitRange>
              <access>read-write</access>
            </field>

            <!-- VALID -->
            <field>
              <name>VALID</name>
              <description>If this bit is 1, the BAR is valid and will participate in LPC matches. If it is 0 this BAR is ignored
              </description>
              <bitRange>[15:15]</bitRange>
              <access>read-write</access>
            </field>

            <!-- LPC_HOST_ADDR -->
            <field>
              <name>LPC_HOST_ADDR</name>
              <description>These 16 bits are used to match LPC I/O addresses
              </description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>

        <!-- EM Interface 0 BAR -->
        <register derivedFrom="LPC_BAR">
          <name>EM_BAR</name>
          <description>EM Interface 0 BAR
          </description>
          <addressOffset>0x364</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0000000F</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
        </register>

        <!-- UART 0 BAR Register -->
        <register derivedFrom="LPC_BAR">
          <name>UART_BAR</name>
          <description>UART 0 BAR Register
          </description>
          <addressOffset>0x368</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000707</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
        </register>

        <!-- Keyboard Controller (8042) BAR -->
        <register derivedFrom="LPC_BAR">
          <name>KBC_BAR</name>
          <description>Keyboard Controller (8042) BAR
          </description>
          <addressOffset>0x378</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00600104</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
        </register>

        <!-- ACPI EC Interface 0 BAR -->
        <register derivedFrom="LPC_BAR">
          <name>EC0_BAR</name>
          <description>ACPI EC Interface 0 BAR
          </description>
          <addressOffset>0x388</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00620304</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
        </register>

        <!-- ACPI EC Interface 1 BAR -->
        <register derivedFrom="LPC_BAR">
          <name>EC1_BAR</name>
          <description>ACPI EC Interface 1 BAR
          </description>
          <addressOffset>0x38C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00660407</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
        </register>

        <!-- ACPI PM1 Interface BAR -->
        <register derivedFrom="LPC_BAR">
          <name>PM1_BAR</name>
          <description>ACPI PM1 Interface BAR
          </description>
          <addressOffset>0x390</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000507</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
        </register>

        <!-- Legacy (GATEA20) Interface BAR -->
        <register derivedFrom="LPC_BAR">
          <name>LGC_BAR</name>
          <description>Legacy (GATEA20) Interface BAR
          </description>
          <addressOffset>0x394</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00920600</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
        </register>

        <!-- Mailbox Registers Interface BAR -->
        <register derivedFrom="LPC_BAR">
          <name>MBX_BAR</name>
          <description>Mailbox Registers Interface BAR
          </description>
          <addressOffset>0x398</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000901</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
        </register>

        <!-- RTC Registers Interface BAR -->
        <register derivedFrom="LPC_BAR">
          <name>RTC_BAR</name>
          <description>RTC Registers Interface BAR
          </description>
          <addressOffset>0x39C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000B3F</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
        </register>

        <!-- Mailbox Registers I/F Memory BAR -->
        <cluster>
          <name>MBX_MEM_BAR</name>
          <description>Mailbox Registers I/F Memory BAR
          </description>
          <addressOffset>0x3C0</addressOffset>
          <register>
            <name>CR</name>
            <description>MEM_BAR Control [15:0]
            </description>
            <addressOffset>0x00</addressOffset>
            <size>16</size>
            <access>read-write</access>

            <fields>
              <!-- MASK -->
              <field>
                <name>MASK</name>
                <description>These bits are used to mask off address bits in the address match between an LPC memory address and the Host Address field of the BARs
                </description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>

              <!-- FRAME -->
              <field>
                <name>FRAME</name>
                <description>These 6 bits are used to specify a logical device frame number within a bus. This field is multiplied by 400h to provide the frame address within the peripheral bus address
                </description>
                <bitRange>[13:8]</bitRange>
                <access>read-write</access>
              </field>

              <!-- VALID -->
              <field>
                <name>VALID</name>
                <description>If this bit is 1, the BAR is valid and will participate in LPC matches. If it is 0 this BAR is ignored.
                </description>
                <bitRange>[15:15]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>

          <register>
            <name>HOST_LO_ADDR</name>
            <description>HOST_ADDRESS[15:0] These 16 bits are used to match LPC memory addresses.
            </description>
            <addressOffset>0x02</addressOffset>
            <size>16</size>
            <access>read-write</access>
          </register>

          <register>
            <name>HOST_HI_ADDR</name>
            <description>HOST_ADDRESS[31:16] These 16 bits are used to match LPC memory addresses.
            </description>
            <addressOffset>0x04</addressOffset>
            <size>16</size>
            <access>read-write</access>
          </register>
        </cluster>

        <!-- ACPI EC Interface 0 Memory BAR -->
        <cluster derivedFrom="MBX_MEM_BAR">
          <name>EC0_MEM_BAR</name>
          <description>ACPI EC Interface 0 Memory BAR
          </description>
          <addressOffset>0x3C6</addressOffset>
        </cluster>

        <!-- ACPI EC Interface 1 Memory BAR -->
        <cluster derivedFrom="MBX_MEM_BAR">
          <name>EC1_MEM_BAR</name>
          <description>ACPI EC Interface 1 Memory BAR
          </description>
          <addressOffset>0x3CC</addressOffset>
        </cluster>

        <!-- EM Interface 0 Memory BAR -->
        <cluster derivedFrom="MBX_MEM_BAR">
          <name>EMI_MEM_BAR</name>
          <description>EM Interface 0 Memory BAR
          </description>
          <addressOffset>0x3D2</addressOffset>
        </cluster>
      </registers>
    </peripheral>
    <!--  -->

    <peripheral>
    <!-- < Chapter 6.0 >  Chip Configuration  -->
    <!-- 400FFF07  Global Configuration Registers  0  GCR                    Logical Device Number Register                       -->
    <!-- 400FFF20  Global Configuration Registers  0  GCR                    Device ID Register                                   -->
    <!-- 400FFF21  Global Configuration Registers  0  GCR                    Device Revision Hard Wired Register                  -->
    <!--  -->
      <name>GCR</name>
      <version>1.0</version>
      <description> The Logical Device Configuration registers support motherboard designs in\n
       which the resources required by their components are known and assigned by the BIOS\n
       at POST.
      </description>
      <groupName>CHIP_CONFIGURATION</groupName>
      <baseAddress>0x400FFF00</baseAddress>
      <size>8</size>
      <access>read-write</access>

      <addressBlock>
        <offset>0</offset>
        <size>0x030</size>
        <usage>registers</usage>
      </addressBlock>

      <registers>

        <!-- Logical Device Number -->
        <register>
          <name>LOGICAL_DEVICE_NUMBER</name>
          <description>A write to this register selects the current logical device. This allows access to the control and configuration registers for each logical device.
          </description>
          <addressOffset>0x07</addressOffset>
          <size>8</size>
          <access>read-write</access>
          <resetValue>0x000</resetValue>
          <resetMask>0x00FF</resetMask>
        </register>

        <!-- Device ID -->
        <register>
          <name>DEVICE_ID</name>
          <description>A read-only register which provides device identification.
          </description>
          <addressOffset>0x20</addressOffset>
          <size>8</size>
          <access>read</access>
          <resetValue>0x15</resetValue>
          <resetMask>0xFF</resetMask>
        </register>

        <!-- Device Revision Hard Wired -->
        <register>
          <name>DEVICE_REVISION</name>
          <description>A read-only register which provides device revision information.
          </description>
          <addressOffset>0x21</addressOffset>
          <size>8</size>
          <access>read</access>
          <resetValue>0x00</resetValue>
          <resetMask>0xFF</resetMask>
        </register>

      </registers>
    </peripheral>
    <!--  -->

    <peripheral>
    <!-- < Chapter 9.0 >  Embedded Memory Interface (EMI)  -->
    <!-- 400F0000  IMAP                            0  EMI_RUNTIME            EMI Host-to-EC Mailbox Register                      -->
    <!-- 400F0001  IMAP                            0  EMI_RUNTIME            EC-to-Host Mailbox Register                          -->
    <!-- 400F0002  IMAP                            0  EMI_RUNTIME            EC Address Register                                  -->
    <!-- 400F0004  IMAP                            0  EMI_RUNTIME            EC Data Register                                     -->
    <!-- 400F0008  IMAP                            0  EMI_RUNTIME            Interrupt Source Register                            -->
    <!-- 400F000A  IMAP                            0  EMI_RUNTIME            Interrupt Mask Register                              -->
    <!-- 400F000C  IMAP                            0  EMI_RUNTIME            Application ID Register                              -->
    <!-- 400F0100  IMAP                            0  EMI_EC_ONLY            EMI Host-to-EC Mailbox Register                      -->
    <!-- 400F0101  IMAP                            0  EMI_EC_ONLY            EC-to-Host Mailbox Register                          -->
    <!-- 400F0104  IMAP                            0  EMI_EC_ONLY            Memory Base Address 0 Register                       -->
    <!-- 400F0108  IMAP                            0  EMI_EC_ONLY            Memory Read Limit 0 Register                         -->
    <!-- 400F010A  IMAP                            0  EMI_EC_ONLY            Memory Write Limit 0 Register                        -->
    <!-- 400F010C  IMAP                            0  EMI_EC_ONLY            Memory Base Address 1 Register                       -->
    <!-- 400F0110  IMAP                            0  EMI_EC_ONLY            Memory Read Limit 1 Register                         -->
    <!-- 400F0112  IMAP                            0  EMI_EC_ONLY            Memory Write Limit 1 Register                        -->
    <!-- 400F0114  IMAP                            0  EMI_EC_ONLY            Interrupt Set Register                               -->
    <!-- 400F0116  IMAP                            0  EMI_EC_ONLY            Host Clear Enable Register                           -->
    <!--  -->
      <name>EMI</name>
      <version>1.0</version>
      <description>The Embedded Memory Interface (EMI) provides a standard run-time mechanism\n
       for the system host to communicate with the Embedded Controller (EC) and other logical components.
      </description>
      <groupName>EMI</groupName>
      <baseAddress>0x400F0000</baseAddress>
      <size>32</size>
      <access>read-write</access>

      <addressBlock>
        <offset>0</offset>
        <size>0x180</size>
        <usage>registers</usage>
      </addressBlock>

      <interrupt>
        <name>EMI_0</name>
        <description>EMI_0 (IMAP) Interrupt ................ Also see GIRQ 15.2</description>
        <value>14</value>
      </interrupt>

      <registers>
        <!-- Host-to-EC Mailbox Register -->
        <register>
          <name>HOST_EC_MBX</name>
          <description>Host-to-EC Mailbox Register
          </description>
          <addressOffset>0x00</addressOffset>
          <size>8</size>
          <access>read-write</access>
          <resetValue>0x00</resetValue>
          <resetMask>0xFF</resetMask>
        </register>

        <!-- EC-to-Host Mailbox Register -->
        <register>
          <name>EC_HOST_MBX</name>
          <description>EC-to-Host Mailbox Register
          </description>
          <addressOffset>0x01</addressOffset>
          <size>8</size>
          <access>read-write</access>
          <resetValue>0x00</resetValue>
          <resetMask>0xFF</resetMask>
        </register>

        <!-- EC Address Register -->
        <register>
          <name>EC_ADDRESS</name>
          <description>EC Address Access Control Register
          </description>
          <addressOffset>0x02</addressOffset>
          <size>16</size>
          <access>read-write</access>
          <resetValue>0x0000</resetValue>
          <resetMask>0xFFFF</resetMask>

          <fields>
            <!-- ACCESS_TYPE -->
            <field>
              <name>ACCESS_TYPE</name>
              <description>This field defines the type of access that occurs when the EC Data Register is read or written.\n
               11b=Auto-increment 32-bit access. 10b=32-bit access. 01b=16-bit access. 00b=8-bit access.
              </description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
            </field>

            <!-- EC_ADDRESS -->
            <field>
              <name>EC_ADDRESS</name>
              <description>This field defines bits[14:2] of EC_Address [15:0]. Bits[1:0] of the EC_Address are always forced to 00b.
              </description>
              <bitRange>[14:2]</bitRange>
              <access>read-write</access>
            </field>

            <!-- REGION -->
            <field>
              <name>REGION</name>
              <description>1= The address defined by EC_Address[14:2] is relative to the base address specified by the Memory Base Address 1 Register.\n
               0= The address defined by EC_Address[14:2] is relative to the base address specified by the Memory Base Address 0 Register.
              </description>
              <bitRange>[15:15]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>

        <!-- EC Data Byte Register -->
        <register>
          <dim>4</dim>
          <dimIncrement>1</dimIncrement>
          <dimIndex>0,1,2,3</dimIndex>
          <name>EC_DATA_BYTE[%s]</name>
          <description>EC Data Byte Register
          </description>
          <addressOffset>0x04</addressOffset>
          <size>8</size>
          <access>read-write</access>
          <resetValue>0x00</resetValue>
          <resetMask>0xFF</resetMask>
        </register>

        <!-- EC Data Byte Register -->
        <register>
          <name>EC_DATA</name>
          <description>EC Data Register
          </description>
          <alternateRegister>EC_DATA_BYTE0</alternateRegister>
          <addressOffset>0x04</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
        </register>

        <!-- Interrupt Source Register -->
        <register>
          <name>EC_SWI</name>
          <description>[0:0] EC_WR EC Mailbox Write. This bit is set when the EC-to-HOST Mailbox Register has been written by the EC at offset 01h of the EC-Only registers.(read-only)\n
           [15:1] EC Software Interrupt Least Significant Bits. These bits are software interrupt bits that may be set by the EC to notify the host of an event. The meaning of these bits is dependent on the firmware implementation. (R/WC)
          </description>
          <addressOffset>0x08</addressOffset>
          <size>16</size>
          <access>read-write</access>
          <resetValue>0x0000</resetValue>
          <resetMask>0xFFFF</resetMask>
        </register>

        <!-- Interrupt Mask Register -->
        <register>
          <name>EC_SWI_EN</name>
          <description>[15:1] Each bit that is set to '1b' in this field enables the generation of a Host Event interrupt by the corresponding bit in the EC_SWI field in the Interrupt Source Register
          </description>
          <addressOffset>0x0A</addressOffset>
          <size>16</size>
          <access>read-write</access>
          <resetValue>0x0000</resetValue>
          <resetMask>0xFFFF</resetMask>
        </register>

        <!-- Application ID Register -->
        <register>
          <name>APPLICATION_ID</name>
          <description>Application ID Register, APPLICATION_ID When this field is 00h it can be written with any value. When set to a non-zero value, writing that value will clear this register to 00h. When set to a non-zero value, writing any value other than the current contents will have no effect.
          </description>
          <addressOffset>0x0C</addressOffset>
          <size>8</size>
          <access>read-write</access>
          <resetValue>0x00</resetValue>
          <resetMask>0xFF</resetMask>
        </register>

        <!-- Host-to-EC Mailbox Register -->
        <register>
          <name>HOST2EC_MBX</name>
          <description>Host-to-EC Mailbox Register, 8-bit mailbox used communicate information from the system host to the embedded controller. Writing this register generates an event to notify the embedded controller. (R/WC)
          </description>
          <addressOffset>0x100</addressOffset>
          <size>8</size>
          <access>read-write</access>
          <resetValue>0x00</resetValue>
          <resetMask>0xFF</resetMask>
        </register>

        <!-- EC-to-Host Mailbox Register -->
        <register>
          <name>EC2HOST_MBX</name>
          <description>EC-to-Host Mailbox Register, 8-bit mailbox used communicate information from the embedded controller to the system host. Writing this register generates an event to notify the system host.
          </description>
          <addressOffset>0x101</addressOffset>
          <size>8</size>
          <access>read-write</access>
          <resetValue>0x00</resetValue>
          <resetMask>0xFF</resetMask>
        </register>

        <!-- Memory Base Address 0 Register -->
        <register>
          <name>MEMORY_BASE_ADDRESS_0</name>
          <description>Memory Base Address 0 Register [31:2] This memory base address defines the beginning of region 0 in the Embedded Controller's 32-bit internal address space. Memory allocated to region 0 is intended to be shared between the Host and the EC. The region defined by this base register is used when bit 15 of the EC Address Register is 0. The access will be to a memory location at an offset defined by the EC_Address relative to the beginning of the region defined by this register. Therefore, a read or write to the memory that is triggered by the EC Data Register will occur at Memory_Base_Address_0 + EC_Address.
          </description>
          <addressOffset>0x104</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
        </register>

        <!-- Memory Read Limit 0 Register -->
        <register>
          <name>MEMORY_READ_LIMIT_0</name>
          <description>Memory Read Limit 0 Register [14:2] Whenever a read of any byte in the EC Data Register is attempted, and bit 15 of EC_Address is 0, the field EC_Address[14:2] in the EC_Address_Register is compared to this field. As long as EC_Address[14:2] is less than this field the EC_Data_Register will be loaded from the 24-bit internal address space.
          </description>
          <addressOffset>0x108</addressOffset>
          <size>16</size>
          <access>read-write</access>
          <resetValue>0x0000</resetValue>
          <resetMask>0xFFFF</resetMask>
        </register>

        <!-- Memory Write Limit 0 Register -->
        <register>
          <name>MEMORY_WRITE_LIMIT_0</name>
          <description>Memory Write Limit 0 Register [14:2] Whenever a write of any byte in EC DATA Register is attempted and bit 15 of EC_Address is 0, the field EC_ADDRESS_MSB in the EC_Address Register is compared to this field. As long as EC_Address[14:2] is less than Memory_Write_Limit_0[14:2] the addressed bytes in the EC DATA Register will be written into the internal 24-bit address space. If EC_Address[14:2] is greater than or equal to the Memory_Write_Limit_0[14:2] no writes will take place.
          </description>
          <addressOffset>0x10A</addressOffset>
          <size>16</size>
          <access>read-write</access>
          <resetValue>0x0000</resetValue>
          <resetMask>0xFFFF</resetMask>
        </register>

        <!-- Memory Base Address 1 Register -->
        <register>
          <name>MEMORY_BASE_ADDRESS_1</name>
          <description>Memory Base Address 1 Register. [31:2] This memory base address defines the beginning of region 1 in the Embedded Controller's 32-bit internal address space. Memory allocated to region 1 is intended to be shared between the Host and the EC. The region defined by this base register is used when bit 15 of the EC Address Register is 1. The access will be to a memory location at an offset defined by the EC_Address relative to the beginning of the region defined by this register. Therefore, a read or write to the memory that is triggered by the EC Data Register will occur at Memory_Base_Address_1 + EC_Address.
          </description>
          <addressOffset>0x10C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0000</resetValue>
          <resetMask>0xFFFF</resetMask>
        </register>

        <!-- Memory Read Limit 1 Register -->
        <register>
          <name>MEMORY_READ_LIMIT_1</name>
          <description>Memory Read Limit 1 Register, [14:2]: Whenever a read of any byte in the EC Data Register is attempted, and bit 15 of EC_ADDRESS is 1, the field EC_ADDRESS in the EC_Address_Register is compared to this field. As long as EC_ADDRESS is less than this value, the EC_Data_Register will be loaded from the 24-bit internal address space.
          </description>
          <addressOffset>0x110</addressOffset>
          <size>16</size>
          <access>read-write</access>
          <resetValue>0x0000</resetValue>
          <resetMask>0xFFFF</resetMask>
        </register>

        <!-- Memory Write Limit 1 Register -->
        <register>
          <name>MEMORY_WRITE_LIMIT_1</name>
          <description>Memory Write Limit 1 Register, [14:2]: Whenever a write of any byte in EC DATA Register is attempted and bit 15 of EC_Address is 1, the field EC_Address[14:2] in the EC_Address Register is compared to this field. As long as EC_Address[14:2] is less than Memory_Write_Limit_1[14:2] the addressed bytes in the EC DATA Register will be written into the internal 24-bit address space. If EC_Address[14:2] is greater than or equal to the Memory_Write_Limit_1[14:2] no writes will take place.
          </description>
          <addressOffset>0x112</addressOffset>
          <size>16</size>
          <access>read-write</access>
          <resetValue>0x0000</resetValue>
          <resetMask>0xFFFF</resetMask>
        </register>

        <!-- Interrupt Set Register -->
        <register>
          <name>EC_SWI_SET</name>
          <description>[15:1] Interrupt Set Register, Writing a bit in this field with a '1b' sets the corresponding bit in the Interrupt Source Register to '1b'. Writing a bit in this field with a '0b' has no effect. Reading this field returns the current contents of the Interrupt Source Register.
          </description>
          <addressOffset>0x114</addressOffset>
          <size>16</size>
          <access>read-write</access>
          <resetValue>0x0000</resetValue>
          <resetMask>0xFFFF</resetMask>
        </register>

        <!-- Host Clear Enable Register -->
        <register>
          <name>CLEAR_ENABLE</name>
          <description>[15:1] Host Clear Enable Register, When a bit in this field is '0b', the corresponding bit in the Interrupt Source Register cannot be cleared by writes to the Interrupt Source Register. When a bit in this field is '1b', the corresponding bit in the Interrupt Source Register can be cleared when that register bit is written with a '1b'.
          </description>
          <addressOffset>0x116</addressOffset>
          <size>16</size>
          <access>read-write</access>
          <resetValue>0x0000</resetValue>
          <resetMask>0xFFFF</resetMask>
        </register>
      </registers>
    </peripheral>
    <!--  -->

    <peripheral>
    <!-- < Chapter 10.0>  ACPI Embedded Controller Interface (ACPI-ECI) -->
    <!-- 400F0C00  ACPI EC Interface               0  ACPI_Runtime           ACPI OS Data Register  Byte 0                        -->
    <!-- 400F0C00  ACPI EC Interface               0  ACPI_Runtime           ACPI OS Data Register  Byte 0                        -->
    <!-- 400F0C01  ACPI EC Interface               0  ACPI_Runtime           ACPI OS Data Register  Byte 1                        -->
    <!-- 400F0C01  ACPI EC Interface               0  ACPI_Runtime           ACPI OS Data Register  Byte 1                        -->
    <!-- 400F0C02  ACPI EC Interface               0  ACPI_Runtime           ACPI OS Data Register  Byte 2                        -->
    <!-- 400F0C02  ACPI EC Interface               0  ACPI_Runtime           ACPI OS Data Register  Byte 2                        -->
    <!-- 400F0C03  ACPI EC Interface               0  ACPI_Runtime           ACPI OS Data Register  Byte 3                        -->
    <!-- 400F0C03  ACPI EC Interface               0  ACPI_Runtime           ACPI OS Data Register  Byte 3                        -->
    <!-- 400F0C04  ACPI EC Interface               0  ACPI_Runtime           ACPI OS Command Register                             -->
    <!-- 400F0C04  ACPI EC Interface               0  ACPI_Runtime           STATUS OS-Register                                   -->
    <!-- 400F0C05  ACPI EC Interface               0  ACPI_Runtime           Byte Control OS-Register                             -->
    <!-- 400F0D00  ACPI EC Interface               0  ACPI_EC_Only           EC2OS Data EC-Register Byte 0                        -->
    <!-- 400F0D01  ACPI EC Interface               0  ACPI_EC_Only           EC2OS Data EC-Register Byte 1                        -->
    <!-- 400F0D02  ACPI EC Interface               0  ACPI_EC_Only           EC2OS Data EC-Register Byte 2                        -->
    <!-- 400F0D03  ACPI EC Interface               0  ACPI_EC_Only           EC2OS Data EC-Register Byte 3                        -->
    <!-- 400F0D04  ACPI EC Interface               0  ACPI_EC_Only           STATUS EC-Register                                   -->
    <!-- 400F0D05  ACPI EC Interface               0  ACPI_EC_Only           Byte Control EC-Register                             -->
    <!-- 400F0D08  ACPI EC Interface               0  ACPI_EC_Only           OS2EC Data EC-Register Byte 0                        -->
    <!-- 400F0D08  ACPI EC Interface               0  ACPI_EC_Only           OS2EC Data EC-Register Byte 0                        -->
    <!-- 400F0D09  ACPI EC Interface               0  ACPI_EC_Only           OS2EC Data EC-Register Byte 1                        -->
    <!-- 400F0D0A  ACPI EC Interface               0  ACPI_EC_Only           OS2EC Data EC-Register Byte 2                        -->
    <!-- 400F0D0B  ACPI EC Interface               0  ACPI_EC_Only           OS2EC Data EC-Register Byte 3                        -->
    <!-- 400F1000  ACPI EC Interface               1  ACPI_Runtime           ACPI OS Data Register  Byte 0                        -->
    <!-- 400F1000  ACPI EC Interface               1  ACPI_Runtime           ACPI OS Data Register  Byte 0                        -->
    <!-- 400F1001  ACPI EC Interface               1  ACPI_Runtime           ACPI OS Data Register  Byte 1                        -->
    <!-- 400F1001  ACPI EC Interface               1  ACPI_Runtime           ACPI OS Data Register  Byte 1                        -->
    <!-- 400F1002  ACPI EC Interface               1  ACPI_Runtime           ACPI OS Data Register  Byte 2                        -->
    <!-- 400F1002  ACPI EC Interface               1  ACPI_Runtime           ACPI OS Data Register  Byte 2                        -->
    <!-- 400F1003  ACPI EC Interface               1  ACPI_Runtime           ACPI OS Data Register  Byte 3                        -->
    <!-- 400F1003  ACPI EC Interface               1  ACPI_Runtime           ACPI OS Data Register  Byte 3                        -->
    <!-- 400F1004  ACPI EC Interface               1  ACPI_Runtime           ACPI OS Command Register                             -->
    <!-- 400F1004  ACPI EC Interface               1  ACPI_Runtime           STATUS OS-Register                                   -->
    <!-- 400F1005  ACPI EC Interface               1  ACPI_Runtime           Byte Control OS-Register                             -->
    <!-- 400F1100  ACPI EC Interface               1  ACPI_EC_Only           EC2OS Data EC-Register Byte 0                        -->
    <!-- 400F1101  ACPI EC Interface               1  ACPI_EC_Only           EC2OS Data EC-Register Byte 1                        -->
    <!-- 400F1102  ACPI EC Interface               1  ACPI_EC_Only           EC2OS Data EC-Register Byte 2                        -->
    <!-- 400F1103  ACPI EC Interface               1  ACPI_EC_Only           EC2OS Data EC-Register Byte 3                        -->
    <!-- 400F1104  ACPI EC Interface               1  ACPI_EC_Only           STATUS EC-Register                                   -->
    <!-- 400F1105  ACPI EC Interface               1  ACPI_EC_Only           Byte Control EC-Register                             -->
    <!-- 400F1108  ACPI EC Interface               1  ACPI_EC_Only           OS2EC Data EC-Register Byte 0                        -->
    <!-- 400F1108  ACPI EC Interface               1  ACPI_EC_Only           OS2EC Data EC-Register Byte 0                        -->
    <!-- 400F1109  ACPI EC Interface               1  ACPI_EC_Only           OS2EC Data EC-Register Byte 1                        -->
    <!-- 400F110A  ACPI EC Interface               1  ACPI_EC_Only           OS2EC Data EC-Register Byte 2                        -->
    <!-- 400F110B  ACPI EC Interface               1  ACPI_EC_Only           OS2EC Data EC-Register Byte 3                        -->
    <!--  -->
      <name>ACPI</name>
      <version>1.0</version>
      <description>The ACPI Embedded Controller Interface (ACPI-ECI) provides a four byte full\n
       duplex data interface which is a superset of the standard ACPI Embedded Controller Interface\n
       (ACPI-ECI) one byte data interface. The ACPI Embedded Controller Interface (ACPI-ECI) defaults\n
       to the standard one byte interface.
      </description>
      <groupName>ACPI_EC</groupName>
      <baseAddress>0x400F0C00</baseAddress>
      <size>32</size>
      <access>read-write</access>

      <addressBlock>
        <offset>0</offset>
        <size>0x120</size>
        <usage>registers</usage>
      </addressBlock>

      <interrupt>
        <name>ACPIEC0_IBF</name>
        <description>ACPIEC[0] IBF Interrupt ............... Also see GIRQ 15.6</description>
        <value>15</value>
      </interrupt>

      <interrupt>
        <name>ACPIEC0_OBF</name>
        <description>ACPIEC[0] OBF Interrupt ............... Also see GIRQ 15.7</description>
        <value>16</value>
      </interrupt>

      <interrupt>
        <name>ACPIEC1_IBF</name>
        <description>ACPIEC[1] IBF Interrupt ............... Also see GIRQ 15.8</description>
        <value>17</value>
      </interrupt>

      <interrupt>
        <name>ACPIEC1_OBF</name>
        <description>ACPIEC[1] OBF Interrupt ............... Also see GIRQ 15.9</description>
        <value>18</value>
      </interrupt>

      <registers>
        <cluster>
          <dim>2</dim>
          <dimIncrement>0x400</dimIncrement>
          <dimIndex>0,1</dimIndex>
          <name>EC[%s]</name>
          <description>Runtime Register Aliasing into EC-Only Registers indicates the aliasing from Runtime registers to EC-Only registers. The Host/EC Access column distinguishes the aliasing based on access type.
          </description>
          <addressOffset>0x000</addressOffset>

          <!-- ACPI OS Data Register Register -->
          <register>
            <dim>4</dim>
            <dimIncrement>1</dimIncrement>
            <dimIndex>0,1,2,3</dimIndex>
            <name>OS_DATA[%s]</name>
            <description>Writes by the ACPI_OS to the ACPI-OS DATA BYTES[n] are aliased to the OS2EC DATA BYTES[n]. Reads by the ACPI_OS from the ACPI-OS DATA BYTES[n] are aliased to the EC2OS DATA BYTES[n].
            </description>
            <addressOffset>0x00</addressOffset>
            <size>8</size>
            <access>read-write</access>
            <resetValue>0x00</resetValue>
            <resetMask>0xFF</resetMask>
          </register>

          <!-- ACPI OS COMMAND Register -->
          <register>
            <name>OS_COMMAND</name>
            <description>Writes to the this register are aliased in the OS2EC Data EC Byte 0 Register.\n
             Writes to the this register also set the CMD and IBF bits in the OS STATUS OS Register
            </description>
            <addressOffset>0x04</addressOffset>
            <size>8</size>
            <access>write</access>
            <resetValue>0x00</resetValue>
            <resetMask>0xFF</resetMask>
          </register>

          <!-- OS STATUS OS Register -->
          <register>
            <name>OS_STATUS</name>
            <description>OS STATUS 
            </description>
            <alternateRegister>OS_COMMAND</alternateRegister>
            <addressOffset>0x04</addressOffset>
            <size>8</size>
            <access>read</access>
            <resetValue>0x00</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <!-- OBF -->
              <field>
                <name>OBF</name>
                <description>OBF  The Output Buffer Full bit is set to indicate that a the ACPI_EC has written a data to the ACPI_OS and that data is ready.
                </description>
                <bitRange>[0:0]</bitRange>
                <access>read</access>
              </field>

              <!-- IBF -->
              <field>
                <name>IBF</name>
                <description>IBF   The Input Buffer Full bit is set to indicate that a the ACPI_OS has written a command or data to the ACPI_EC and that data is ready.
                </description>
                <bitRange>[1:1]</bitRange>
                <access>read</access>
              </field>

              <!-- UD1B -->
              <field>
                <name>UD1B</name>
                <description>UD1B   User Defined
                </description>
                <bitRange>[2:2]</bitRange>
                <access>read</access>
              </field>

              <!-- CMD -->
              <field>
                <name>CMD</name>
                <description>CMD  This bit is set when the OS2EC Data EC Byte 0 Register contains a command byte written into ACPI OS COMMAND Register
                </description>
                <bitRange>[3:3]</bitRange>
                <access>read</access>
              </field>

              <!-- BURST -->
              <field>
                <name>BURST</name>
                <description>BURST   The BURST bit is set when the ACPI_EC is in Burst Mode
                </description>
                <bitRange>[4:4]</bitRange>
                <access>read</access>
              </field>

              <!-- SCI_EVT -->
              <field>
                <name>SCI_EVT</name>
                <description>SCI_EVT   This bit is set by software when an SCI event is pending
                </description>
                <bitRange>[5:5]</bitRange>
                <access>read</access>
              </field>

              <!-- SMI_EVT -->
              <field>
                <name>SMI_EVT</name>
                <description>SMI_EVT  This bit is set when an SMI event is pending
                </description>
                <bitRange>[6:6]</bitRange>
                <access>read</access>
              </field>

              <!-- UD0B -->
              <field>
                <name>UD0B</name>
                <description>UD0B  User Defined
                </description>
                <bitRange>[7:7]</bitRange>
                <access>read</access>
              </field>
            </fields>
          </register>

          <!-- OS Byte Control Register -->
          <register>
            <name>OS_BYTE_CONTROL</name>
            <description>OS Byte Control [0:0] FOUR_BYTE_ACCESS When this bit is set to '1', the ACPI Embedded Controller Interface (ACPI-ECI) accesses four bytes through the ACPI-OS DATA BYTES[3:0]. When this bit is cleared to '0', the ACPI Embedded Controller Interface (ACPI-ECI) accesses one byte through the ACPI OS Data Register Byte 0 Register.
            </description>
            <addressOffset>0x05</addressOffset>
            <size>8</size>
            <access>read</access>
            <resetValue>0x00</resetValue>
            <resetMask>0xFF</resetMask>
          </register>

          <!-- EC2OS_DATA -->
          <register>
            <dim>4</dim>
            <dimIncrement>1</dimIncrement>
            <dimIndex>0,1,2,3</dimIndex>
            <name>EC2OS_DATA[%s]</name>
            <description>EC2OS Data Bytes
            </description>
            <addressOffset>0x100</addressOffset>
            <size>8</size>
            <access>read-write</access>
            <resetValue>0x00</resetValue>
            <resetMask>0xFF</resetMask>
          </register>

          <!-- STATUS EC-Register -->
          <register>
            <name>EC_STATUS</name>
            <description>EC STATUS
            </description>
            <addressOffset>0x104</addressOffset>
            <size>8</size>
            <access>read-write</access>
            <resetValue>0x00</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <!-- OBF -->
              <field>
                <name>OBF</name>
                <description>OBF  The Output Buffer Full bit is set to indicate that a the ACPI_EC has written a data to the ACPI_OS and that data is ready.
                </description>
                <bitRange>[0:0]</bitRange>
                <access>read</access>
              </field>

              <!-- IBF -->
              <field>
                <name>IBF</name>
                <description>IBF   The Input Buffer Full bit is set to indicate that a the ACPI_OS has written a command or data to the ACPI_EC and that data is ready.
                </description>
                <bitRange>[1:1]</bitRange>
                <access>read</access>
              </field>

              <!-- UD1A -->
              <field>
                <name>UD1A</name>
                <description>UD1A   User Defined
                </description>
                <bitRange>[2:2]</bitRange>
                <access>read</access>
              </field>

              <!-- CMD -->
              <field>
                <name>CMD</name>
                <description>CMD  This bit is set when the OS2EC Data EC Byte 0 Register contains a command byte written into ACPI OS COMMAND Register
                </description>
                <bitRange>[3:3]</bitRange>
                <access>read</access>
              </field>

              <!-- BURST -->
              <field>
                <name>BURST</name>
                <description>BURST   The BURST bit is set when the ACPI_EC is in Burst Mode
                </description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>

              <!-- SCI_EVT -->
              <field>
                <name>SCI_EVT</name>
                <description>SCI_EVT   This bit is set by software when an SCI event is pending
                </description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>

              <!-- SMI_EVT -->
              <field>
                <name>SMI_EVT</name>
                <description>SMI_EVT  This bit is set when an SMI event is pending
                </description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>

              <!-- UD0A -->
              <field>
                <name>UD0A</name>
                <description>UD0A  User Defined
                </description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>

          <!-- Byte Control EC-Register -->
          <register>
            <name>EC_BYTE_CONTROL</name>
            <description>[0:0] FOUR_BYTE_ACCESS When this bit is set to '1', the ACPI Embedded Controller Interface (ACPI-ECI) accesses four bytes through the ACPI-OS DATA BYTES[3:0]. When this bit is cleared to '0', the ACPI Embedded Controller Interface (ACPI-ECI) accesses one byte through the ACPI OS Data Register Byte 0 Register.
            </description>
            <addressOffset>0x105</addressOffset>
            <size>8</size>
            <access>read-write</access>
            <resetValue>0x000F</resetValue>
            <resetMask>0xFFFF</resetMask>
          </register>

          <!-- OS2EC Data EC-Register Byte -->
          <register>
            <dim>4</dim>
            <dimIncrement>1</dimIncrement>
            <dimIndex>0,1,2,3</dimIndex>
            <name>OS2EC_DATA[%s]</name>
            <description>OS2EC Data Bytes
            </description>
            <addressOffset>0x108</addressOffset>
            <size>8</size>
            <access>read-write</access>
            <resetValue>0x00</resetValue>
            <resetMask>0xFF</resetMask>
          </register>
        </cluster>
      </registers>
    </peripheral>
    <!--  -->

    <peripheral>
    <!-- < Chapter 11.0>  8042 Emulated Keyboard Controller  -->
    <!-- 400F0400  8042 Host Interface             0  KBC_Runtime            EC_Host Data/Aux Register (Read)                     -->
    <!-- 400F0400  8042 Host Interface             0  KBC_Runtime            Host_EC Data Register    (Write)                     -->
    <!-- 400F0404  8042 Host Interface             0  KBC_Runtime            Host_EC Command Register (Write)                     -->
    <!-- 400F0404  8042 Host Interface             0  KBC_Runtime            Keyboard Status Read Register                        -->
    <!-- 400F0500  8042 Host Interface             0  KBC_EC_Only            Host_EC Data/Cmd Register                            -->
    <!-- 400F0500  8042 Host Interface             0  KBC_EC_Only            EC_Host Data Register                                -->
    <!-- 400F0504  8042 Host Interface             0  KBC_EC_Only            Keyboard Status Read Register                        -->
    <!-- 400F0508  8042 Host Interface             0  KBC_EC_Only            Keyboard Control Register                            -->
    <!-- 400F050C  8042 Host Interface             0  KBC_EC_Only            EC_Host Aux Register                                 -->
    <!-- 400F0514  8042 Host Interface             0  KBC_EC_Only            PCOBF Register                                       -->
    <!-- 400F0730  8042 Host Interface             0  KBC_Configuration      Activate Register                                    -->
    <!--  -->
      <name>KBC</name>
      <version>1.0</version>
      <description>The MEC1322 keyboard controller uses the EC to produce a superset of the\n
       features provided by the industry-standard 8042 keyboard controller. The 8042 Emulated Keyboard\n
       Controller is a Host/EC Message Interface with hardware assists to emulate 8042 behavior and\n
       provide Legacy GATEA20 support.
      </description>
      <groupName>8042_KBC</groupName>
      <baseAddress>0x400F0400</baseAddress>
      <size>32</size>
      <access>read-write</access>

      <addressBlock>
        <offset>0</offset>
        <size>0x800</size>
        <usage>registers</usage>
      </addressBlock>

      <interrupt>
        <name>KBC8042_OBF</name>
        <description>8042EM OBF Interrupt .................. Also see GIRQ 15.13</description>
        <value>22</value>
      </interrupt>

      <interrupt>
        <name>KBC8042_IBF</name>
        <description>8042EM IBF Interrupt .................. Also see GIRQ 15.14</description>
        <value>23</value>
      </interrupt>

      <registers>
        <!-- EC_Host Data/Aux Register (Read) -->
        <register>
          <name>RD_PORT60_DATA</name>
          <description>EC_Host Data/Aux Register (Read)  This 8-bit register is read-only. When read by the Host, the PCOBF and/or AUXOBF interrupts are cleared and the OBF flag in the status register is cleared.
          </description>
          <addressOffset>0x00</addressOffset>
          <size>8</size>
          <access>read</access>
          <resetValue>0x00</resetValue>
          <resetMask>0xFF</resetMask>
        </register>

        <!-- Host_EC Data Register    (Write) -->
        <register>
          <name>WT_PORT60_DATA</name>
          <description>Host_EC Data Register (Write)  This 8-bit register is write-only. When written, the C/D bit in the Keyboard Status Read Register is cleared to '0', signifying data, and the IBF in the same register is set to '1'.
          </description>
          <alternateRegister>RD_PORT60_DATA</alternateRegister>
          <addressOffset>0x00</addressOffset>
          <size>8</size>
          <access>write</access>
          <resetValue>0x00</resetValue>
          <resetMask>0xFF</resetMask>
        </register>

        <!-- Host_EC Command Register (Write) -->
        <register>
          <name>WT_PORT64_CMD</name>
          <description>Host_EC Command Register (Write) This 8-bit register is write-only and is an alias of the register at offset 0h. When written, the C/D bit in the Keyboard Status Read Register is set to '1', signifying a command, and the IBF in the same register is set to '1'.
          </description>
          <addressOffset>0x04</addressOffset>
          <size>8</size>
          <access>write</access>
          <resetValue>0x00</resetValue>
          <resetMask>0xFF</resetMask>
        </register>

        <!-- Keyboard Status Read Register -->
        <register>
          <name>RD_PORT64_STATUS</name>
          <description>Keyboard Status Read Register
          </description>
          <alternateRegister>WT_PORT64_CMD</alternateRegister>
          <addressOffset>0x04</addressOffset>
          <size>8</size>
          <access>read-write</access>
          <resetValue>0x00</resetValue>
          <resetMask>0xFF</resetMask>

          <fields>
            <!-- OBF -->
            <field>
              <name>OBF</name>
              <description>OBF  Output Buffer Full.
              </description>
              <bitRange>[0:0]</bitRange>
              <access>read</access>
            </field>

            <!-- IBF -->
            <field>
              <name>IBF</name>
              <description>IBF  Input Buffer Full.
              </description>
              <bitRange>[1:1]</bitRange>
              <access>read</access>
            </field>

            <!-- UD0 -->
            <field>
              <name>UD0</name>
              <description>UD0  User-defined data.
              </description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>

            <!-- C/D -->
            <field>
              <name>CMDnDATA</name>
              <description>C/D   Command Data. This bit specifies whether the input data register contains data or a command ('0' = data, '1' = command).
              </description>
              <bitRange>[3:3]</bitRange>
              <access>read</access>
            </field>

            <!-- UD1 -->
            <field>
              <name>UD1</name>
              <description>UD1  User-defined data.
              </description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>

            <!-- AUXOBF -->
            <field>
              <name>AUXOBF</name>
              <description>AUXOBF  Auxiliary Output Buffer Full.
              </description>
              <bitRange>[5:5]</bitRange>
              <access>read</access>
            </field>

            <!-- UD2 -->
            <field>
              <name>UD2</name>
              <description>UD2  User-defined data.
              </description>
              <bitRange>[7:6]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>

        <!-- Host_EC Data/Cmd Register -->
        <register>
          <name>HOST2EC_DATA</name>
          <description>Host_EC Data/Cmd Register  This register is an alias of the HOST_EC Data / CMD Register.
          </description>
          <addressOffset>0x100</addressOffset>
          <size>8</size>
          <access>read</access>
          <resetValue>0x00</resetValue>
          <resetMask>0xFF</resetMask>
        </register>

        <!-- EC_Host Data Register -->
        <register>
          <name>EC_DATA</name>
          <description>EC_Host Data Register
          </description>
          <alternateRegister>HOST2EC_DATA</alternateRegister>
          <addressOffset>0x100</addressOffset>
          <size>8</size>
          <access>write</access>
          <resetValue>0x00</resetValue>
          <resetMask>0xFF</resetMask>
        </register>

        <!-- Keyboard Status Read Register -->
          <register derivedFrom="RD_PORT64_STATUS">
          <name>STATUS</name>
          <description>Keyboard Status Read Register
          </description>
          <addressOffset>0x104</addressOffset>
          <size>8</size>
          <access>read-write</access>
          <resetValue>0x00</resetValue>
          <resetMask>0xFF</resetMask>
        </register>

        <!-- Keyboard Control Register -->
        <register>
          <name>CONTROL</name>
          <description>Keyboard Control Register
          </description>
          <addressOffset>0x108</addressOffset>
          <size>8</size>
          <access>read-write</access>
          <resetValue>0x00</resetValue>
          <resetMask>0xFF</resetMask>

          <fields>
            <!-- UD3 -->
            <field>
              <name>UD3</name>
              <description>UD3  User-defined data.
              </description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>

            <!-- SAEN -->
            <field>
              <name>SAEN</name>
              <description>SAEN   Software-assist enable. 1=This bit allows control of the GATEA20 signal via firmware 0=GATEA20 corresponds to either the last Host-initiated control of GATEA20 or the firmware write to the Keyboard Control Register or the EC AUX Data Register.
              </description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>

            <!-- PCOBFEN -->
            <field>
              <name>PCOBFEN</name>
              <description>PCOBFEN  1= reflects the value written to the PCOBF Register, 0=PCOBF reflects the status of writes to the EC Data Register
              </description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>

            <!-- UD4 -->
            <field>
              <name>UD4</name>
              <description>UD4  User-defined data.
              </description>
              <bitRange>[4:3]</bitRange>
              <access>read-write</access>
            </field>

            <!-- OBFEN -->
            <field>
              <name>OBFEN</name>
              <description>OBFEN   When this bit is '1, the system interrupt signal KIRQ is driven by the bit PCOBF and MIRQ is driven by AUXOBF. When this bit is '0', KIRQ and MIRQ are driven low.
              </description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>

            <!-- UD5 -->
            <field>
              <name>UD5</name>
              <description>UD5  User-defined data.
              </description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>

            <!-- AUXH -->
            <field>
              <name>AUXH</name>
              <description>AUXH   AUX in Hardware. 1=AUXOBF of the Keyboard Status Read Register is set in hardware by a write to the EC AUX Data Register\n
               0=AUXOBF is not modified in hardware, but can be read and written by the EC using the EC-Only alias of the EC Keyboard Status Register
              </description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>

        <!-- EC_Host Aux Register -->
        <register>
          <name>AUX_DATA</name>
          <description>EC_Host Aux Register  This 8-bit register is write-only. When written, the C/D in the Keyboard Status Read Register is cleared to '0', signifying data, and the IBF in the same register is set to '1'. When the Runtime Register at offset 0h is read by the Host, it functions as the EC_HOST Data / AUX Data Register.
          </description>
          <addressOffset>0x10C</addressOffset>
          <size>8</size>
          <access>write</access>
          <resetValue>0x00</resetValue>
          <resetMask>0xFF</resetMask>
        </register>

        <!-- PCOBF Register -->
        <register>
          <name>PCOBF</name>
          <description>PCOBF Register: If enabled by the bit OBFEN, the bit PCOBF is gated onto KIRQ. The KIRQ signal is a system interrupt which signifies that the EC has written to the HOST2EC Data Register (EC-Only offset 0h).
          </description>
          <addressOffset>0x114</addressOffset>
          <size>8</size>
          <access>read-write</access>
          <resetValue>0x00</resetValue>
          <resetMask>0xFF</resetMask>
        </register>

        <!-- Activate Register -->
        <register>
          <name>ACTIVATE</name>
          <description>Activate Register   [0:0] ACTIVATE 1=The 8042 Interface is powered and functional. 0=The 8042 Interface is powered down and inactive.
          </description>
          <addressOffset>0x330</addressOffset>
          <size>8</size>
          <access>read-write</access>
          <resetValue>0x00</resetValue>
          <resetMask>0xFF</resetMask>
        </register>
      </registers>
    </peripheral>

    <peripheral>
    <!--  -->
    <!-- 400F1800  8042 Host Interface             0  Legacy_Runtime         PORT92 Register                                      -->
    <!-- 400F1900  8042 Host Interface             0  Legacy_EC_Only         GATEA20 Control Register                             -->
    <!-- 400F1908  8042 Host Interface             0  Legacy_EC_Only         SETGA20L Register                                    -->
    <!-- 400F190C  8042 Host Interface             0  Legacy_EC_Only         RSTGA20L Register                                    -->
    <!-- 400F1B30  8042 Host Interface             0  Legacy_Configuration   PORT92 Enable Register                               -->
    <!--  -->
      <name>PORT92</name>
      <version>1.0</version>
      <description>The registers listed in the Configuration Register Summary table are for a single instance of the Legacy Port92/GATEA20 logic.
      </description>
      <groupName>PORT92</groupName>
      <baseAddress>0x400F1800</baseAddress>
      <size>32</size>
      <access>read-write</access>

      <addressBlock>
        <offset>0</offset>
        <size>0x400</size>
        <usage>registers</usage>
      </addressBlock>

      <registers>
        <!-- PORT92 Register -->
        <register>
          <name>PORT92</name>
          <description>PORT92 Register: The registers listed in the Runtime Register Summary table are for a single instance of the Legacy Port92/GATEA20 logic.
          </description>
          <addressOffset>0x00</addressOffset>
          <size>8</size>
          <access>read-write</access>
          <resetValue>0x00</resetValue>
          <resetMask>0xFF</resetMask>

          <fields>
            <!-- ALT_CPU_RESET -->
            <field>
              <name>ALT_CPU_RESET</name>
              <description>ALT_CPU_RESET   This bit provides an alternate means to generate a CPU_RESET pulse.
              </description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>

            <!-- ALT_GATE_A20 -->
            <field>
              <name>ALT_GATE_A20</name>
              <description>ALT_GATE_A20   This bit provides an alternate means for system control of the GATEA20 pin.
              </description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>

        <!-- GATEA20 Control Register -->
        <register>
          <name>GATEA20</name>
          <description>GATEA20 Control Register  [0:0] GATEA20 0=The GATEA20 output is driven low, 1=The GATEA20 output is driven high
          </description>
          <addressOffset>0x100</addressOffset>
          <size>8</size>
          <access>read-write</access>
          <resetValue>0x00</resetValue>
          <resetMask>0xFF</resetMask>
        </register>

        <!-- SETGA20L Register -->
        <register>
          <name>SETGA20L</name>
          <description>SETGA20L Register  A write to this register sets GATEA20 in the GATEA20 Control Register.
          </description>
          <addressOffset>0x108</addressOffset>
          <size>8</size>
          <access>write</access>
          <resetValue>0x00</resetValue>
          <resetMask>0xFF</resetMask>
        </register>

        <!-- RSTGA20L Register -->
        <register>
          <name>RSTGA20L</name>
          <description>RSTGA20L Register  A write to this register sets GATEA20 in the GATEA20 Control Register.
          </description>
          <addressOffset>0x10C</addressOffset>
          <size>8</size>
          <access>read-write</access>
          <resetValue>0x00</resetValue>
          <resetMask>0xFF</resetMask>
        </register>

        <!-- PORT92 Enable Register -->
        <register>
          <name>PORT92_ENABLE</name>
          <description>PORT92 Enable Register [0:0] P92_EN When this bit is '1', the Port92h Register is enabled. When this bit is '0', the Port92h Register is disabled, and Host writes to LPC address 92h are ignored.
          </description>
          <addressOffset>0x330</addressOffset>
          <size>8</size>
          <access>read-write</access>
          <resetValue>0x00</resetValue>
          <resetMask>0xFF</resetMask>
        </register>

      </registers>
    </peripheral>
    <!--  -->

    <peripheral>
    <!-- < Chapter 12.0>  MailBox Register Interface  -->
    <!-- RUNTIME REGISTER SUMMARY                                                                                                 -->
    <!-- 400F2400  Mailbox Registers Interface     0  MBX_Runtime            MBX_Index Register                                   -->
    <!-- 400F2404  Mailbox Registers Interface     0  MBX_Runtime            MBX_Data_Register                                    -->
    <!-- EC-ONLY REGISTER SUMMARY                                                                                                 -->
    <!-- 400F2500  Mailbox Registers Interface     0  MBX_EC_Only            HOST-to-EC Mailbox Register                          -->
    <!-- 400F2504  Mailbox Registers Interface     0  MBX_EC_Only            EC-to-Host Mailbox Register                          -->
    <!-- 400F2508  Mailbox Registers Interface     0  MBX_EC_Only            SMI Interrupt Source Register                        -->
    <!-- 400F250C  Mailbox Registers Interface     0  MBX_EC_Only            SMI Interrupt Mask Register                          -->
    <!-- 400F2510  Mailbox Registers Interface     0  MBX_EC_Only            Mailbox Register [3:0]                               -->
    <!-- 400F2514  Mailbox Registers Interface     0  MBX_EC_Only            Mailbox Register [7:4]                               -->
    <!-- 400F2518  Mailbox Registers Interface     0  MBX_EC_Only            Mailbox Register [Bh:8]                              -->
    <!-- 400F251C  Mailbox Registers Interface     0  MBX_EC_Only            Mailbox Register [Fh:Ch]                             -->
    <!-- 400F2520  Mailbox Registers Interface     0  MBX_EC_Only            Mailbox Register [13h:10h]                           -->
    <!-- 400F2524  Mailbox Registers Interface     0  MBX_EC_Only            Mailbox Register [17h:14h]                           -->
    <!-- 400F2528  Mailbox Registers Interface     0  MBX_EC_Only            Mailbox Register [1Bh:18h]                           -->
    <!-- 400F252C  Mailbox Registers Interface     0  MBX_EC_Only            Mailbox Register [1Fh:1Ch]                           -->
    <!-- 400F2530  Mailbox Registers Interface     0  MBX_EC_Only            Mailbox Register [23h:20h]                           -->
    <!-- 400F2534  Mailbox Registers Interface     0  MBX_EC_Only            Mailbox Register [27h:24h]                           -->
    <!-- 400F2538  Mailbox Registers Interface     0  MBX_EC_Only            Mailbox Register [2Ah:28h]                           -->
    <!--  -->
      <name>MBX</name>
      <version>1.0</version>
      <description>The Mailbox provides a standard run-time mechanism for the host to\n
       communicate with the Embedded Controller (EC)
      </description>
      <groupName>MAILBOX</groupName>
      <baseAddress>0x400F2400</baseAddress>
      <size>32</size>
      <access>read-write</access>

      <addressBlock>
        <offset>0</offset>
        <size>0x180</size>
        <usage>registers</usage>
      </addressBlock>

      <interrupt>
        <name>MAILBOX</name>
        <description>MAILBOX Interrupt ..................... Also see GIRQ 15.15</description>
        <value>24</value>
      </interrupt>

      <interrupt>
        <name>MAILBOX_DATA</name>
        <description>MAILBOX DATA Interrupt ................ Also see GIRQ 15.16</description>
        <value>40</value>
      </interrupt>

      <registers>
        <!-- MBX_Index Register -->
        <register>
          <name>INDEX</name>
          <description>MBX_Index Register
          </description>
          <addressOffset>0x00</addressOffset>
          <size>8</size>
          <access>read-write</access>
          <resetValue>0x00</resetValue>
          <resetMask>0xFF</resetMask>
        </register>

        <!-- MBX_Data_Register -->
        <register>
          <name>DATA</name>
          <description>MBX_Data_Register
          </description>
          <addressOffset>0x04</addressOffset>
          <size>8</size>
          <access>read-write</access>
          <resetValue>0x00</resetValue>
          <resetMask>0xFF</resetMask>
        </register>

        <!-- HOST-to-EC Mailbox Register -->
        <register>
          <name>HOST_TO_EC</name>
          <description>If enabled, an interrupt to the EC marked by the MBX_DATA bit in the Interrupt Aggregator will be generated whenever the Host writes this register. This register is cleared when written with FFh.
          </description>
          <addressOffset>0x100</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00</resetValue>
          <resetMask>0xFF</resetMask>
        </register>

        <!-- EC-to-Host Mailbox Register -->
        <register>
          <name>EC_TO_HOST</name>
          <description>An EC write to this register will set bit EC_WR in the SMI Interrupt Source Register to '1b'. If enabled, this will generate a Host SMI. This register is cleared when written with FFh.
          </description>
          <addressOffset>0x104</addressOffset>
          <size>8</size>
          <access>read-write</access>
          <resetValue>0x00</resetValue>
          <resetMask>0xFF</resetMask>
        </register>

        <!-- SMI Interrupt Source Register -->
        <register>
          <name>SMI_SOURCE</name>
          <description>SMI Interrupt Source Register
          </description>
          <addressOffset>0x108</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <!-- EC_WR -->
            <field>
              <name>EC_WR</name>
              <description>EC Mailbox Write. This bit is set automatically when the EC-to-Host Mailbox Register has been written. An SMI or SIRQ to the Host is generated when n this bit is '1b' and the corresponding bit in the SMI Interrupt Mask Register register is '1b'. This bit is automatically cleared by a read of the EC-to-Host Mailbox Register through the Host Access Port.
              </description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>

            <!-- EC_SWI -->
            <field>
              <name>EC_SWI</name>
              <description>EC Software Interrupt. An SIRQ to the Host is generated when any bit in this register when this bit is set to '1b' and the corresponding bit in the SMI Interrupt Mask Register register is '1b'.
              </description>
              <bitRange>[7:1]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>

        <!-- SMI Interrupt Mask Register -->
        <register>
          <name>SMI_MASK</name>
          <description>SMI Interrupt Mask Register
          </description>
          <addressOffset>0x10C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0000</resetValue>
          <resetMask>0xFFFF</resetMask>

          <fields>
            <!-- EC_WR_EN -->
            <field>
              <name>EC_WR_EN</name>
              <description>EC Mailbox Write.Interrupt Enable. Each bit in this field that is '1b' enables the generation of SIRQ interrupts when the corresponding bit in the EC_SWI field in the SMI Interrupt Source Register is '1b'.
              </description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>

            <!-- EC_SWI_EN -->
            <field>
              <name>EC_SWI_EN</name>
              <description>EC Software Interrupt Enable. If this bit is '1b', the bit EC_WR in the SMI Interrupt Source Register is enabled for the generation of SIRQ or nSMI events.
              </description>
              <bitRange>[7:1]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>

        <!-- Mailbox Register -->
        <register>
          <dim>11</dim>
          <dimIncrement>4</dimIncrement>
          <dimIndex>0-10</dimIndex>
          <name>REG[%s]</name>
          <description>Mailbox Register
          </description>
          <addressOffset>0x110</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
        </register>
      </registers>
    </peripheral>
    <!--  -->

    <peripheral>
    <!-- < Chapter 13.0>  ACPI PM1 Block Interface  -->
    <!-- 400F1400  ACPI PM1                        0  PM1_Runtime            PM1 Status 1       (Reserved)                        -->
    <!-- 400F1401  ACPI PM1                        0  PM1_Runtime            PM1 Status 2                                         -->
    <!-- 400F1402  ACPI PM1                        0  PM1_Runtime            PM1 Enable 1       (Reserved)                        -->
    <!-- 400F1403  ACPI PM1                        0  PM1_Runtime            PM1 Enable 2                                         -->
    <!-- 400F1404  ACPI PM1                        0  PM1_Runtime            PM1 Control 1      (Reserved)                        -->
    <!-- 400F1405  ACPI PM1                        0  PM1_Runtime            PM1 Control 2                                        -->
    <!-- 400F1406  ACPI PM1                        0  PM1_Runtime            PM2 Control 1      (Reserved)                        -->
    <!-- 400F1407  ACPI PM1                        0  PM1_Runtime            PM2 Control 2      (Reserved)                        -->
    <!-- 400F1500  ACPI PM1                        0  PM1_EC_Only            PM1 Status 1       (Reserved)                        -->
    <!-- 400F1501  ACPI PM1                        0  PM1_EC_Only            PM1 Status 2                                         -->
    <!-- 400F1502  ACPI PM1                        0  PM1_EC_Only            PM1 Enable 1       (Reserved)                        -->
    <!-- 400F1503  ACPI PM1                        0  PM1_EC_Only            PM1 Enable 2                                         -->
    <!-- 400F1504  ACPI PM1                        0  PM1_EC_Only            PM1 Control 1      (Reserved)                        -->
    <!-- 400F1505  ACPI PM1                        0  PM1_EC_Only            PM1 Control 2                                        -->
    <!-- 400F1506  ACPI PM1                        0  PM1_EC_Only            PM2 Control 1      (Reserved)                        -->
    <!-- 400F1507  ACPI PM1                        0  PM1_EC_Only            PM2 Control 2      (Reserved)                        -->
    <!-- 400F1510  ACPI PM1                        0  PM1_EC_Only            PM1 EC PM Status                                     -->
    <!--  -->
      <name>PM1</name>
      <version>1.0</version>
      <description>The MEC1322 implements the ACPI fixed registers but includes only those bits\n
       that apply to the power button sleep button and RTC alarm events. The ACPI WAK_STS, SLP_TYP,\n
       and SLP_EN bits are also supported.
      </description>
      <groupName>ACPI_PM1</groupName>
      <baseAddress>0x400F1400</baseAddress>
      <size>32</size>
      <access>read-write</access>

      <addressBlock>
        <offset>0</offset>
        <size>0x120</size>
        <usage>registers</usage>
      </addressBlock>

      <interrupt>
        <name>ACPIPM1_CTL</name>
        <description>ACPIPM1_CTL Interrupt ................. Also see GIRQ 15.10</description>
        <value>19</value>
      </interrupt>

      <interrupt>
        <name>ACPIPM1_EN</name>
        <description>ACPIPM1_EN Interrupt .................. Also see GIRQ 15.11</description>
        <value>20</value>
      </interrupt>

      <interrupt>
        <name>ACPIPM1_STS</name>
        <description>ACPIPM1_STS Interrupt ................. Also see GIRQ 15.12</description>
        <value>21</value>
      </interrupt>

      <registers>
        <!-- PM1 Status 2 -->
        <register>
          <name>STS2</name>
          <description>PM1 Status 2
          </description>
          <addressOffset>0x01</addressOffset>
          <size>8</size>
          <access>read-write</access>
          <resetValue>0x00</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <!-- PWRBTN_STS -->
            <field>
              <name>PWRBTN_STS</name>
              <description>PWRBTN_STS  This bit can be set or cleared by the EC to simulate a Power button status if the power is controlled by the EC. (R/WC)
              </description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>

            <!-- SLPBTN_STS -->
            <field>
              <name>SLPBTN_STS</name>
              <description>SLPBTN_STS  This bit can be set or cleared by the EC to simulate a Sleep button status if the sleep state is controlled by the EC. (R/WC)
              </description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>

            <!-- RTC_STS -->
            <field>
              <name>RTC_STS</name>
              <description>RTC_STS  This bit can be set or cleared by the EC to simulate a RTC status. (R/WC)
              </description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>

            <!-- PWRBTNOR_STS -->
            <field>
              <name>PWRBTNOR_STS</name>
              <description>PWRBTNOR_STS  This bit can be set or cleared by the EC to simulate a Power button override event status if the power is controlled by the EC. (R/WC)
              </description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>

            <!-- WAK_STS -->
            <field>
              <name>WAK_STS</name>
              <description>WAK_STS  This bit can be set or cleared by the EC. The Host writing a one to this bit can also clear this bit.  (R/WC)
              </description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>

        <!-- PM1 Enable 2 -->
        <register>
          <name>EN2</name>
          <description>PM1 Enable 2
          </description>
          <addressOffset>0x03</addressOffset>
          <size>8</size>
          <access>read-write</access>
          <resetValue>0x00</resetValue>
          <resetMask>0xFF</resetMask>

          <fields>
            <!-- PWRBTN_EN -->
            <field>
              <name>PWRBTN_EN</name>
              <description>PWRBTN_EN  This bit can be read or written by the Host. It can be read by the EC.
              </description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>

            <!-- SLPBTN_EN -->
            <field>
              <name>SLPBTN_EN</name>
              <description>SLPBTN_EN  This bit can be read or written by the Host. It can be read by the EC.
              </description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>

            <!-- RTC_EN -->
            <field>
              <name>RTC_EN</name>
              <description>RTC_EN   This bit can be read or written by the Host. It can be read by the EC.
              </description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>

        <!-- PM1 Control 2 -->
        <register>
          <name>CTRL2</name>
          <description>PM1 Control 2
          </description>
          <addressOffset>0x05</addressOffset>
          <size>8</size>
          <access>read-write</access>
          <resetValue>0x00</resetValue>
          <resetMask>0xFF</resetMask>

          <fields>
            <!-- PWRBTNOR_EN -->
            <field>
              <name>PWRBTNOR_EN</name>
              <description>PWRBTNOR_EN  This bit can be set or cleared by the Host, read by the EC.
              </description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>

            <!-- SLP_TYP -->
            <field>
              <name>SLP_TYP</name>
              <description>SLP_TYP  These bits can be set or cleared by the Host, read by the EC.
              </description>
              <bitRange>[4:2]</bitRange>
              <access>read-write</access>
            </field>

            <!-- SLP_EN -->
            <field>
              <name>SLP_EN</name>
              <description>SLP_EN
              </description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>

        <!-- PM1 Status 2 -->
        <register derivedFrom="STS2">
          <name>STS_2</name>
          <description>PM1 Status 2
          </description>
          <addressOffset>0x101</addressOffset>
        </register>

        <!-- PM1 Enable 2 -->
        <register derivedFrom="EN2">
          <name>EN_2</name>
          <description>PM1 Enable 2
          </description>
          <addressOffset>0x103</addressOffset>
        </register>

        <!-- PM1 Control 2 -->
        <register derivedFrom="CTRL2">
          <name>CTRL_2</name>
          <description>PM1 Control 2
          </description>
          <addressOffset>0x105</addressOffset>
        </register>

        <!-- PM1 EC PM Status -->
        <register>
          <name>PM_STS</name>
          <description>PM1 EC PM Status  [0:0] EC_SCI_STS, If the EC_SCI_STS bit is '1', an interrupt is generated on the EC_SCI# pin.
          </description>
          <addressOffset>0x110</addressOffset>
          <size>8</size>
          <access>read-write</access>
          <resetValue>0x00</resetValue>
          <resetMask>0xFF</resetMask>
        </register>
      </registers>
    </peripheral>
    <!--  -->

    <peripheral>
    <!-- < Chapter 14.0>  UART  -->
    <!-- 400F1C00  M16C550A UART                   0  UART_Runtime           UART Programmable BAUD Rate Generator (LSB) Register -->
    <!-- 400F1C00  M16C550A UART                   0  UART_Runtime           UART Transmit Buffer Register                        -->
    <!-- 400F1C00  M16C550A UART                   0  UART_Runtime           UART Receive Buffer Register                         -->
    <!-- 400F1C01  M16C550A UART                   0  UART_Runtime           UART Interrupt Enable Register                       -->
    <!-- 400F1C01  M16C550A UART                   0  UART_Runtime           UART Programmable BAUD Rate Generator (MSB) Register -->
    <!-- 400F1C02  M16C550A UART                   0  UART_Runtime           UART FIFO Control Register                           -->
    <!-- 400F1C02  M16C550A UART                   0  UART_Runtime           UART Interrupt Identification Register               -->
    <!-- 400F1C03  M16C550A UART                   0  UART_Runtime           UART Line Control Register                           -->
    <!-- 400F1C04  M16C550A UART                   0  UART_Runtime           UART Modem Control Register                          -->
    <!-- 400F1C05  M16C550A UART                   0  UART_Runtime           UART Line Status Register                            -->
    <!-- 400F1C06  M16C550A UART                   0  UART_Runtime           UART Modem Status Register                           -->
    <!-- 400F1C07  M16C550A UART                   0  UART_Runtime           UART Scratchpad Register                             -->
    <!-- 400F1F30  M16C550A UART                   0  UART_Config            UART Activate Register                               -->
    <!-- 400F1FF0  M16C550A UART                   0  UART_Config            UART Config Select Register                          -->
    <!--  -->
      <name>UART</name>
      <version>1.0</version>
      <description>The 16550 UART (Universal Asynchronous Receiver/Transmitter) is a\n
       full-function Two Pin Serial Port that supports the standard RS-232 Interface.
      </description>
      <groupName>UART</groupName>
      <baseAddress>0x400F1C00</baseAddress>
      <size>32</size>
      <access>read-write</access>

      <addressBlock>
        <offset>0</offset>
        <size>0x400</size>
        <usage>registers</usage>
      </addressBlock>

      <interrupt>
        <name>UART_0</name>
        <description>UART_0 Interrupt ...................... Also see GIRQ 15.0</description>
        <value>13</value>
      </interrupt>

      <registers>
        <!-- UART Programmable BAUD Rate Generator (LSB) Register -->
        <register>
          <name>BAUDRATE_LSB</name>
          <description>UART Programmable BAUD Rate Generator (LSB) Register
          </description>
          <addressOffset>0x00</addressOffset>
          <size>8</size>
          <access>read-write</access>
          <resetValue>0x00</resetValue>
          <resetMask>0xFF</resetMask>
        </register>

        <!-- UART Receive Buffer Register -->
        <register>
          <name>RX_DATA</name>
          <description>UART Receive Buffer Register
          </description>
          <alternateRegister>BAUDRATE_LSB</alternateRegister>
          <addressOffset>0x00</addressOffset>
          <size>8</size>
          <access>read</access>
          <resetValue>0x00</resetValue>
          <resetMask>0xFF</resetMask>
        </register>

        <!-- UART Transmit Buffer Register -->
        <register>
          <name>TX_DATA</name>
          <description>UART Transmit Buffer Register
          </description>
          <alternateRegister>BAUDRATE_LSB</alternateRegister>
          <addressOffset>0x00</addressOffset>
          <size>8</size>
          <access>write</access>
          <resetValue>0x00</resetValue>
          <resetMask>0xFF</resetMask>
        </register>

        <!-- UART Programmable BAUD Rate Generator (MSB) Register -->
        <register>
          <name>BAUDRATE_MSB</name>
          <description>UART Programmable BAUD Rate Generator (MSB) Register. [6:0] BAUD_RATE_DIVISOR_MSB, [7:7] BAUD_CLK_SEL \n
           1=If CLK_SRC is '0', the baud clock is derived from the 1.8432MHz_Clk. If CLK_SRC is '1', this bit has no effect\n
           0=If CLK_SRC is '0', the baud clock is derived from the 24MHz_Clk. If CLK_SRC is '1', this bit has no effect
          </description>
          <addressOffset>0x01</addressOffset>
          <size>8</size>
          <access>read-write</access>
          <resetValue>0x00</resetValue>
          <resetMask>0xFF</resetMask>
        </register>

        <!-- UART Interrupt Enable Register -->
        <register>
          <name>INT_EN</name>
          <description>UART Interrupt Enable Register
          </description>
          <alternateRegister>BAUDRATE_MSB</alternateRegister>
          <addressOffset>0x01</addressOffset>
          <size>8</size>
          <access>read-write</access>
          <resetValue>0x00</resetValue>
          <resetMask>0xFF</resetMask>

          <fields>
            <!-- ERDAI -->
            <field>
              <name>ERDAI</name>
              <description>ERDAI This bit enables the Received Data Available Interrupt (and timeout interrupts in the FIFO mode) when set to logic '1'.
              </description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>

            <!-- ETHREI -->
            <field>
              <name>ETHREI</name>
              <description>ETHREI This bit enables the Transmitter Holding Register Empty Interrupt when set to logic '1'.
              </description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>

            <!-- ELSI -->
            <field>
              <name>ELSI</name>
              <description>ELSI This bit enables the Received Line Status Interrupt when set to logic '1'.
              </description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>

            <!-- EMSI -->
            <field>
              <name>EMSI</name>
              <description>EMSI  This bit enables the MODEM Status Interrupt when set to logic '1'.
              </description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>

        <!-- UART FIFO Control Register -->
        <register>
          <name>FIFO_CR</name>
          <description>UART FIFO Control Register
          </description>
          <addressOffset>0x02</addressOffset>
          <size>8</size>
          <access>read-write</access>
          <resetValue>0x00</resetValue>
          <resetMask>0xFF</resetMask>

          <fields>
            <!-- EXRF -->
            <field>
              <name>EXRF</name>
              <description>EXRF Enable XMIT and RECV FIFO.
              </description>
              <bitRange>[0:0]</bitRange>
              <access>write</access>
            </field>

            <!-- CLEAR_RECV_FIFO -->
            <field>
              <name>CLEAR_RECV_FIFO</name>
              <description>CLEAR_RECV_FIFO  Setting this bit to a logic '1' clears all bytes in the RCVR FIFO and resets its counter logic to '0'.
              </description>
              <bitRange>[1:1]</bitRange>
              <access>write</access>
            </field>

            <!-- CLEAR_XMIT_FIFO -->
            <field>
              <name>CLEAR_XMIT_FIFO</name>
              <description>CLEAR_XMIT_FIFO  Setting this bit to a logic '1' clears all bytes in the XMIT FIFO and resets its counter logic to '0' . The shift register is not cleared. This bit is self-clearing.
              </description>
              <bitRange>[2:2]</bitRange>
              <access>write</access>
            </field>

            <!-- DMA_MODE_SELECT -->
            <field>
              <name>DMA_MODE_SELECT</name>
              <description>DMA_MODE_SELECT  Writing to this bit has no effect on the operation of the UART. The RXRDY and TXRDY pins are not available on this chip.
              </description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>

            <!-- RECV_FIFO_TRIGGER_LEVEL -->
            <field>
              <name>RECV_FIFO_TRIGGER_LEVEL</name>
              <description>RECV_FIFO_TRIGGER_LEVEL These bits are used to set the trigger level for the RCVR FIFO interrupt.
              </description>
              <bitRange>[7:6]</bitRange>
              <access>read-write</access>
            </field>

          </fields>
        </register>

        <!-- UART Interrupt Identification Register -->
        <register>
          <name>INT_ID</name>
          <description>UART Interrupt Identification Register
          </description>
          <alternateRegister>FIFO_CR</alternateRegister>
          <addressOffset>0x02</addressOffset>
          <size>8</size>
          <access>read-write</access>
          <resetValue>0x00</resetValue>
          <resetMask>0xFF</resetMask>

          <fields>
            <!-- IPEND -->
            <field>
              <name>IPEND</name>
              <description>IPEND  This bit can be used in either a hardwired prioritized or polled environment to indicate whether an interrupt is pending.
              </description>
              <bitRange>[0:0]</bitRange>
              <access>read</access>
            </field>

            <!-- INTID -->
            <field>
              <name>INTID</name>
              <description>INTID  These bits identify the highest priority interrupt pending
              </description>
              <bitRange>[3:1]</bitRange>
              <access>read</access>
            </field>

            <!-- FIFO_EN -->
            <field>
              <name>FIFO_EN</name>
              <description>These two bits are set when the FIFO CONTROL Register bit 0 equals 1.
              </description>
              <bitRange>[7:6]</bitRange>
              <access>read</access>
            </field>
          </fields>
        </register>

        <!-- UART Line Control Register -->
        <register>
          <name>LINE_CR</name>
          <description>UART Line Control Register
          </description>
          <addressOffset>0x03</addressOffset>
          <size>8</size>
          <access>read-write</access>
          <resetValue>0x00</resetValue>
          <resetMask>0xFF</resetMask>

          <fields>
            <!-- WORD_LENGTH -->
            <field>
              <name>WORD_LENGTH</name>
              <description>WORD_LENGTH These two bits specify the number of bits in each transmitted or received serial character.
              </description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
            </field>

            <!-- STOP_BITS -->
            <field>
              <name>STOP_BITS</name>
              <description>STOP_BITS  This bit specifies the number of stop bits in each transmitted or received serial character.
              </description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>

            <!-- ENABLE_PARITY -->
            <field>
              <name>ENABLE_PARITY</name>
              <description>ENABLE_PARITY  Parity Enable bit.
              </description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>

            <!-- PARITY_SELECT -->
            <field>
              <name>PARITY_SELECT</name>
              <description>PARITY_SELECT Even Parity Select bit.
              </description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>

            <!-- STICK_PARITY -->
            <field>
              <name>STICK_PARITY</name>
              <description>STICK_PARITY  Stick Parity bit.
              </description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>

            <!-- BREAK_CONTROL -->
            <field>
              <name>BREAK_CONTROL</name>
              <description>BREAK_CONTROL Set Break Control bit
              </description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>

            <!-- DLAB -->
            <field>
              <name>DLAB</name>
              <description>DLAB Divisor Latch Access Bit (DLAB).
              </description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>

        <!-- UART Modem Control Register -->
        <register>
          <name>MODEM_CR</name>
          <description>UART Modem Control Register
          </description>
          <addressOffset>0x04</addressOffset>
          <size>8</size>
          <access>read-write</access>
          <resetValue>0x00</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>

            <!-- DTR -->
            <field>
              <name>DTR</name>
              <description>DTR  This bit controls the Data Terminal Ready (nDTR) output.
              </description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>

            <!-- RTS -->
            <field>
              <name>RTS</name>
              <description>RTS  This bit controls the Request To Send (nRTS) output.
              </description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>

            <!-- OUT1 -->
            <field>
              <name>OUT1</name>
              <description>OUT1 This bit controls the Output 1 (OUT1) bit.
              </description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>

            <!-- OUT2 -->
            <field>
              <name>OUT2</name>
              <description>OUT2  This bit is used to enable an UART interrupt.
              </description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>

            <!-- LOOPBACK -->
            <field>
              <name>LOOPBACK</name>
              <description>LOOPBACK  This bit provides the loopback feature for diagnostic testing of the Serial Port.
              </description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>

        <!-- UART Line Status Register -->
        <register>
          <name>LINE_STS</name>
          <description>UART Line Status Register
          </description>
          <addressOffset>0x05</addressOffset>
          <size>8</size>
          <access>read-only</access>
          <resetValue>0x00</resetValue>
          <resetMask>0xFF</resetMask>

          <fields>

            <!-- DATA_READY -->
            <field>
              <name>DATA_READY</name>
              <description>DATA_READY  Data Ready. It is set to a logic '1' whenever a complete incoming character has been received and transferred into the Receiver Buffer Register or the FIFO
              </description>
              <bitRange>[0:0]</bitRange>
              <access>read</access>
            </field>

            <!-- OVERRUN -->
            <field>
              <name>OVERRUN</name>
              <description>OVERRUN  Overrun Error.
              </description>
              <bitRange>[1:1]</bitRange>
              <access>read</access>
            </field>

            <!-- PARITY ERROR -->
            <field>
              <name>PE</name>
              <description>PARITY ERROR  Parity Error.
              </description>
              <bitRange>[2:2]</bitRange>
              <access>read</access>
            </field>

            <!-- FRAME_ERROR -->
            <field>
              <name>FRAME_ERROR</name>
              <description>FRAME_ERROR Framing Error.
              </description>
              <bitRange>[3:3]</bitRange>
              <access>read</access>
            </field>

            <!-- BREAK_INTERRUPT -->
            <field>
              <name>BREAK_INTERRUPT</name>
              <description>BREAK_INTERRUPT   Break Interrupt.
              </description>
              <bitRange>[4:4]</bitRange>
              <access>read</access>
            </field>

            <!-- TRANSMIT_EMPTY -->
            <field>
              <name>TRANSMIT_EMPTY</name>
              <description>TRANSMIT_EMPTY  Transmitter Holding Register Empty Bit 5 indicates that the Serial Port is ready to accept a new character for transmission.
              </description>
              <bitRange>[5:5]</bitRange>
              <access>read</access>
            </field>

            <!-- TRANSMIT_ERROR -->
            <field>
              <name>TRANSMIT_ERROR</name>
              <description>Transmitter Empty. Bit 6 is set to a logic '1' whenever the Transmitter Holding Register (THR) and Transmitter Shift Register (TSR) are both empty.
              </description>
              <bitRange>[6:6]</bitRange>
              <access>read</access>
            </field>

            <!-- FIFO_ERROR -->
            <field>
              <name>FIFO_ERROR</name>
              <description>FIFO_ERROR
              </description>
              <bitRange>[7:7]</bitRange>
              <access>read</access>
            </field>
          </fields>
        </register>

        <!-- UART Modem Status Register -->
        <register>
          <name>MODEM_STS</name>
          <description>UART Modem Status Register
          </description>
          <addressOffset>0x06</addressOffset>
          <size>8</size>
          <access>read-only</access>
          <resetValue>0x00</resetValue>
          <resetMask>0xFF</resetMask>

          <fields>
            <!-- CTS -->
            <field>
              <name>CTS</name>
              <description>CTS  Delta Clear To Send (DCTS).
              </description>
              <bitRange>[0:0]</bitRange>
              <access>read</access>
            </field>

            <!-- DSR -->
            <field>
              <name>DSR</name>
              <description>DSR  Delta Data Set Ready (DDSR).
              </description>
              <bitRange>[1:1]</bitRange>
              <access>read</access>
            </field>

            <!-- RI -->
            <field>
              <name>RI</name>
              <description>RI  Trailing Edge of Ring Indicator (TERI).
              </description>
              <bitRange>[2:2]</bitRange>
              <access>read</access>
            </field>

            <!-- DCD -->
            <field>
              <name>DCD</name>
              <description>DCD  Delta Data Carrier Detect (DDCD).
              </description>
              <bitRange>[3:3]</bitRange>
              <access>read</access>
            </field>

            <!-- nCTS -->
            <field>
              <name>nCTS</name>
              <description>nCTS  This bit is the complement of the Clear To Send (nCTS) input.
              </description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>

            <!-- nDSR -->
            <field>
              <name>nDSR</name>
              <description>This bit is the complement of the Data Set Ready (nDSR) input.
              </description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>

            <!-- nRI -->
            <field>
              <name>nRI</name>
              <description>nRI This bit is the complement of the Ring Indicator (nRI) input.
              </description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>

            <!-- nDCD -->
            <field>
              <name>nDCD</name>
              <description>nDCD   This bit is the complement of the Data Carrier Detect (nDCD) input.
              </description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>

        <!-- UART Scratchpad Register -->
        <register>
          <name>SCRATCHPAD</name>
          <description>UART Scratchpad Register    This 8 bit read/write register has no effect on the operation of the Serial Port. It is intended as a scratchpad register to be used by the programmer to hold data temporarily.
          </description>
          <addressOffset>0x07</addressOffset>
          <size>8</size>
          <access>read-write</access>
          <resetValue>0x00</resetValue>
          <resetMask>0xFF</resetMask>
        </register>

        <!-- UART Activate Register -->
        <register>
          <name>ACTIVATE</name>
          <description>UART Activate Register. [0:0] ACTIVATE When this bit is 1, the UART logical device is powered and functional. When this bit is 0, the UART logical device is powered down and inactive.
          </description>
          <addressOffset>0x330</addressOffset>
          <size>8</size>
          <access>read-write</access>
          <resetValue>0x00</resetValue>
          <resetMask>0xFF</resetMask>
        </register>

        <!-- UART Config Select Register -->
        <register>
          <name>CONFIG</name>
          <description>UART Config Select Register
          </description>
          <addressOffset>0x3F0</addressOffset>
          <size>8</size>
          <access>read-write</access>
          <resetValue>0x00</resetValue>
          <resetMask>0xFF</resetMask>

          <fields>
            <!-- CLK_SRC -->
            <field>
              <name>CLK_SRC</name>
              <description>CLK_SRC  1=The UART Baud Clock is derived from an external clock source, 0=The UART Baud Clock is derived from one of the two internal clock sources
              </description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>

            <!-- POWER -->
            <field>
              <name>POWER</name>
              <description>POWER  1=The RESET reset signal is derived from nSIO_RESET, 0=The RESET reset signal is derived from VCC1_RESET
              </description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>

            <!-- POLARITY -->
            <field>
              <name>POLARITY</name>
              <description>POLARITY  1=The UART_TX and UART_RX pins functions are inverted, 0=The UART_TX and UART_RX pins functions are not inverted
              </description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>

      </registers>
    </peripheral>
    <!--  -->

    <peripheral>
    <!-- < Chapter 15.0>  EC Interrupt Aggregator  -->
    <!-- 4000C000  EC Interrupt Aggregator (INTS)  0  INTS_EC_ONLY           GIRQ8 Source Register                                -->
    <!-- 4000C004  EC Interrupt Aggregator (INTS)  0  INTS_EC_ONLY           GIRQ8 Enable Set Register                            -->
    <!-- 4000C008  EC Interrupt Aggregator (INTS)  0  INTS_EC_ONLY           GIRQ8 Result Register                                -->
    <!-- 4000C00C  EC Interrupt Aggregator (INTS)  0  INTS_EC_ONLY           GIRQ8 Enable Clear Register                          -->
    <!-- 4000C014  EC Interrupt Aggregator (INTS)  0  INTS_EC_ONLY           GIRQ9 Source Register                                -->
    <!-- 4000C018  EC Interrupt Aggregator (INTS)  0  INTS_EC_ONLY           GIRQ9 Enable Set Register                            -->
    <!-- 4000C01C  EC Interrupt Aggregator (INTS)  0  INTS_EC_ONLY           GIRQ9 Result Register                                -->
    <!-- 4000C020  EC Interrupt Aggregator (INTS)  0  INTS_EC_ONLY           GIRQ9 Enable Clear Register                          -->
    <!-- 4000C028  EC Interrupt Aggregator (INTS)  0  INTS_EC_ONLY           GIRQ10 Source Register                               -->
    <!-- 4000C02C  EC Interrupt Aggregator (INTS)  0  INTS_EC_ONLY           GIRQ10 Enable Set Register                           -->
    <!-- 4000C030  EC Interrupt Aggregator (INTS)  0  INTS_EC_ONLY           GIRQ10 Result Register                               -->
    <!-- 4000C034  EC Interrupt Aggregator (INTS)  0  INTS_EC_ONLY           GIRQ10 Enable Clear Register                         -->
    <!-- 4000C03C  EC Interrupt Aggregator (INTS)  0  INTS_EC_ONLY           GIRQ11 Source Register                               -->
    <!-- 4000C040  EC Interrupt Aggregator (INTS)  0  INTS_EC_ONLY           GIRQ11 Enable Set Register                           -->
    <!-- 4000C044  EC Interrupt Aggregator (INTS)  0  INTS_EC_ONLY           GIRQ11 Result Register                               -->
    <!-- 4000C048  EC Interrupt Aggregator (INTS)  0  INTS_EC_ONLY           GIRQ11 Enable Clear Register                         -->
    <!-- 4000C050  EC Interrupt Aggregator (INTS)  0  INTS_EC_ONLY           GIRQ12 Source Register                               -->
    <!-- 4000C054  EC Interrupt Aggregator (INTS)  0  INTS_EC_ONLY           GIRQ12 Enable Set Register                           -->
    <!-- 4000C058  EC Interrupt Aggregator (INTS)  0  INTS_EC_ONLY           GIRQ12 Result Register                               -->
    <!-- 4000C05C  EC Interrupt Aggregator (INTS)  0  INTS_EC_ONLY           GIRQ12 Enable Clear Register                         -->
    <!-- 4000C064  EC Interrupt Aggregator (INTS)  0  INTS_EC_ONLY           GIRQ13 Source Register                               -->
    <!-- 4000C068  EC Interrupt Aggregator (INTS)  0  INTS_EC_ONLY           GIRQ13 Enable Set Register                           -->
    <!-- 4000C06C  EC Interrupt Aggregator (INTS)  0  INTS_EC_ONLY           GIRQ13 Result Register                               -->
    <!-- 4000C070  EC Interrupt Aggregator (INTS)  0  INTS_EC_ONLY           GIRQ13 Enable Clear Register                         -->
    <!-- 4000C078  EC Interrupt Aggregator (INTS)  0  INTS_EC_ONLY           GIRQ14 Source Register                               -->
    <!-- 4000C07C  EC Interrupt Aggregator (INTS)  0  INTS_EC_ONLY           GIRQ14 Enable Set Register                           -->
    <!-- 4000C080  EC Interrupt Aggregator (INTS)  0  INTS_EC_ONLY           GIRQ14 Result Register                               -->
    <!-- 4000C084  EC Interrupt Aggregator (INTS)  0  INTS_EC_ONLY           GIRQ14 Enable Clear Register                         -->
    <!-- 4000C08C  EC Interrupt Aggregator (INTS)  0  INTS_EC_ONLY           GIRQ15 Source Register                               -->
    <!-- 4000C090  EC Interrupt Aggregator (INTS)  0  INTS_EC_ONLY           GIRQ15 Enable Set Register                           -->
    <!-- 4000C094  EC Interrupt Aggregator (INTS)  0  INTS_EC_ONLY           GIRQ15 Result Register                               -->
    <!-- 4000C098  EC Interrupt Aggregator (INTS)  0  INTS_EC_ONLY           GIRQ15 Enable Clear Register                         -->
    <!-- 4000C0A0  EC Interrupt Aggregator (INTS)  0  INTS_EC_ONLY           GIRQ16 Source Register                               -->
    <!-- 4000C0A4  EC Interrupt Aggregator (INTS)  0  INTS_EC_ONLY           GIRQ16 Enable Set Register                           -->
    <!-- 4000C0A8  EC Interrupt Aggregator (INTS)  0  INTS_EC_ONLY           GIRQ16 Result Register                               -->
    <!-- 4000C0AC  EC Interrupt Aggregator (INTS)  0  INTS_EC_ONLY           GIRQ16 Enable Clear Register                         -->
    <!-- 4000C0B4  EC Interrupt Aggregator (INTS)  0  INTS_EC_ONLY           GIRQ17 Source Register                               -->
    <!-- 4000C0B8  EC Interrupt Aggregator (INTS)  0  INTS_EC_ONLY           GIRQ17 Enable Set Register                           -->
    <!-- 4000C0BC  EC Interrupt Aggregator (INTS)  0  INTS_EC_ONLY           GIRQ17 Result Register                               -->
    <!-- 4000C0C0  EC Interrupt Aggregator (INTS)  0  INTS_EC_ONLY           GIRQ17 Enable Clear Register                         -->
    <!-- 4000C0C8  EC Interrupt Aggregator (INTS)  0  INTS_EC_ONLY           GIRQ18 Source Register                               -->
    <!-- 4000C0CC  EC Interrupt Aggregator (INTS)  0  INTS_EC_ONLY           GIRQ18 Enable Set Register                           -->
    <!-- 4000C0D0  EC Interrupt Aggregator (INTS)  0  INTS_EC_ONLY           GIRQ18 Result Register                               -->
    <!-- 4000C0D4  EC Interrupt Aggregator (INTS)  0  INTS_EC_ONLY           GIRQ18 Enable Clear Register                         -->
    <!-- 4000C0DC  EC Interrupt Aggregator (INTS)  0  INTS_EC_ONLY           GIRQ19 Source Register                               -->
    <!-- 4000C0E0  EC Interrupt Aggregator (INTS)  0  INTS_EC_ONLY           GIRQ19 Enable Set Register                           -->
    <!-- 4000C0E4  EC Interrupt Aggregator (INTS)  0  INTS_EC_ONLY           GIRQ19 Result Register                               -->
    <!-- 4000C0E8  EC Interrupt Aggregator (INTS)  0  INTS_EC_ONLY           GIRQ19 Enable Clear Register                         -->
    <!-- 4000C0F0  EC Interrupt Aggregator (INTS)  0  INTS_EC_ONLY           GIRQ20 Source Register                               -->
    <!-- 4000C0F4  EC Interrupt Aggregator (INTS)  0  INTS_EC_ONLY           GIRQ20 Enable Set Register                           -->
    <!-- 4000C0F8  EC Interrupt Aggregator (INTS)  0  INTS_EC_ONLY           GIRQ20 Result Register                               -->
    <!-- 4000C0FC  EC Interrupt Aggregator (INTS)  0  INTS_EC_ONLY           GIRQ20 Enable Clear Register                         -->
    <!-- 4000C104  EC Interrupt Aggregator (INTS)  0  INTS_EC_ONLY           GIRQ21 Source Register                               -->
    <!-- 4000C108  EC Interrupt Aggregator (INTS)  0  INTS_EC_ONLY           GIRQ21 Enable Set Register                           -->
    <!-- 4000C10C  EC Interrupt Aggregator (INTS)  0  INTS_EC_ONLY           GIRQ21 Result Register                               -->
    <!-- 4000C110  EC Interrupt Aggregator (INTS)  0  INTS_EC_ONLY           GIRQ21 Enable Clear Register                         -->
    <!-- 4000C118  EC Interrupt Aggregator (INTS)  0  INTS_EC_ONLY           GIRQ22 Source Register                               -->
    <!-- 4000C11C  EC Interrupt Aggregator (INTS)  0  INTS_EC_ONLY           GIRQ22 Enable Set Register                           -->
    <!-- 4000C120  EC Interrupt Aggregator (INTS)  0  INTS_EC_ONLY           GIRQ22 Result Register                               -->
    <!-- 4000C124  EC Interrupt Aggregator (INTS)  0  INTS_EC_ONLY           GIRQ22 Enable Clear Register                         -->
    <!-- 4000C12C  EC Interrupt Aggregator (INTS)  0  INTS_EC_ONLY           GIRQ23 Source Register                               -->
    <!-- 4000C130  EC Interrupt Aggregator (INTS)  0  INTS_EC_ONLY           GIRQ23 Enable Set Register                           -->
    <!-- 4000C134  EC Interrupt Aggregator (INTS)  0  INTS_EC_ONLY           GIRQ23 Result Register                               -->
    <!-- 4000C138  EC Interrupt Aggregator (INTS)  0  INTS_EC_ONLY           GIRQ23 Enable Clear Register                         -->
    <!-- 4000C200  EC Interrupt Aggregator (INTS)  0  INTS_EC_ONLY           Block Enable Set Register                            -->
    <!-- 4000C204  EC Interrupt Aggregator (INTS)  0  INTS_EC_ONLY           Block Enable Clear Register                          -->
    <!-- 4000C208  EC Interrupt Aggregator (INTS)  0  INTS_EC_ONLY           Block IRQ Vector Register                            -->
    <!--  -->
      <name>INTS</name>
      <version>1.0</version>
      <description>The interrupt generation logic is made of 16 groups of signals, each of which\n
       consist of a Status register, a Enable register and a Result register. The Status and Enable are\n
       latched registers. The Result register is a bit by bit AND function of the Source and Enable registers.\n
       All the bits of the Result register are OR'ed together and AND'ed with the corresponding bit in the Block\n
       Select register to form the interrupt signal that is routed to the ARM interrupt controller.
      </description>
      <groupName>INTS</groupName>
      <baseAddress>0x4000C000</baseAddress>
      <size>32</size>
      <access>read-write</access>

      <addressBlock>
        <offset>0</offset>
        <size>0x210</size>
        <usage>registers</usage>
      </addressBlock>

      <interrupt>
        <name>GIRQ08</name>
        <description>GIRQ08 ................................ Interrupt Aggregator</description>
        <value>57</value>
      </interrupt>

      <interrupt>
        <name>GIRQ09</name>
        <description>GIRQ09 ................................ Interrupt Aggregator</description>
        <value>58</value>
      </interrupt>

      <interrupt>
        <name>GIRQ10</name>
        <description>GIRQ10 ................................ Interrupt Aggregator</description>
        <value>59</value>
      </interrupt>

      <interrupt>
        <name>GIRQ11</name>
        <description>GIRQ11 ................................ Interrupt Aggregator</description>
        <value>60</value>
      </interrupt>

      <interrupt>
        <name>GIRQ12</name>
        <description>GIRQ12 ................................ Interrupt Aggregator</description>
        <value>61</value>
      </interrupt>

      <interrupt>
        <name>GIRQ13</name>
        <description>GIRQ13 ................................ Interrupt Aggregator</description>
        <value>62</value>
      </interrupt>

      <interrupt>
        <name>GIRQ14</name>
        <description>GIRQ14 ................................ Interrupt Aggregator</description>
        <value>63</value>
      </interrupt>

      <interrupt>
        <name>GIRQ15</name>
        <description>GIRQ15 ................................ Interrupt Aggregator</description>
        <value>64</value>
      </interrupt>

      <interrupt>
        <name>GIRQ16</name>
        <description>GIRQ16 ................................ Interrupt Aggregator</description>
        <value>65</value>
      </interrupt>

      <interrupt>
        <name>GIRQ17</name>
        <description>GIRQ17 ................................ Interrupt Aggregator</description>
        <value>66</value>
      </interrupt>

      <interrupt>
        <name>GIRQ18</name>
        <description>GIRQ18 ................................ Interrupt Aggregator</description>
        <value>67</value>
      </interrupt>

      <interrupt>
        <name>GIRQ19</name>
        <description>GIRQ19 ................................ Interrupt Aggregator</description>
        <value>68</value>
      </interrupt>

      <interrupt>
        <name>GIRQ20</name>
        <description>GIRQ20 ................................ Interrupt Aggregator</description>
        <value>69</value>
      </interrupt>

      <interrupt>
        <name>GIRQ21</name>
        <description>GIRQ21 ................................ Interrupt Aggregator</description>
        <value>70</value>
      </interrupt>

      <interrupt>
        <name>GIRQ22</name>
        <description>GIRQ22 ................................ Interrupt Aggregator</description>
        <value>71</value>
      </interrupt>

      <interrupt>
        <name>GIRQ23</name>
        <description>GIRQ23 ................................ Interrupt Aggregator</description>
        <value>72</value>
      </interrupt>

      <registers>
        <cluster>
          <dim>16</dim>
          <dimIncrement>0x14</dimIncrement>
          <dimIndex>0-15</dimIndex>
          <name>IRQ[%s]</name>
          <description>DEFINITIONS FOR GIRQ i SOURCE, ENABLE, AND RESULT REGISTERS
          </description>
          <addressOffset>0x000</addressOffset>

          <!-- GIRQx Source Register -->
          <register>
            <name>SOURCE</name>
            <description>GIRQx Source Register, R/WC except for reserved bits D31
            </description>
            <addressOffset>0x00</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
          </register>

          <!-- GIRQx Enable Set Register -->
          <register>
            <name>ENABLE_SET</name>
            <description>GIRQx Enable Set Register, R/WS except for reserved bits D31\n
             Each GIRQx bit can be individually enabled to assert an interrupt event.\n
             0= Writing a zero has no effect. \n
             1= Writing a one will enable respective GIRQx
            </description>
            <addressOffset>0x04</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
          </register>

          <!-- GIRQx Result Register -->
          <register>
            <name>RESULT</name>
            <description>GIRQx Result Register. Bits D30 down to D0 are defined in the following subsections reflect the state of the GIRQx interrupt source after the enable bit. The GIRQx result bits are OR'd together to generate the IRQx vector.
            </description>
            <addressOffset>0x08</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
          </register>

          <!-- GIRQxEnable Clear Register -->
          <register>
            <name>ENABLE_CLEAR</name>
            <description>GIRQx Enable Clear Register. Each GIRQx bit can be individually disabled to assert an interrupt event.\n
             0= Writing a zero has no effect.\n
             1= Writing a one will disable respective GIRQx.
            </description>
            <addressOffset>0x0C</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
          </register>
        </cluster>

        <!-- Block Enable Set Register -->
        <register>
          <name>BLOCK_ENABLE_SET</name>
          <description>Block Enable Set Register [23:8] IRQ Vector Enable Set [23:8] Each IRQ Vector can be individually enabled to assert an interrupt event to the EC.
           0= Writing a zero has no effect.\n
           1= Writing a one will enable respective IRQi.
          </description>
          <addressOffset>0x200</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
        </register>

        <!-- Block Enable Clear Register -->
        <register>
          <name>BLOCK_ENABLE_CLEAR</name>
          <description>Block Enable Clear Register [23:8] IRQ Vector Enable Clear[23:8] Each IRQ Vector can be individually disabled to assert an interrupt event to the EC.\n
           0= Writing a zero has no effect. \n
           1= Writing a one will disable respective IRQi vector.
          </description>
          <addressOffset>0x204</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
        </register>

        <!-- Block IRQ Vector Register -->
        <register>
          <name>IRQ_VECTOR_STATE</name>
          <description>Block IRQ Vector Register [23:8] IRQ Vector [23:8] Each read only bit reflects the current state of the IRQ i vector to the EC.
          </description>
          <addressOffset>0x208</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
        </register>
      </registers>
    </peripheral>
    <!--  -->

    <peripheral>
    <!-- < Chapter 16.0>  Watchdog Timer (WDT)  -->
    <!-- 40000400  Watchdog Timer Interface        0  WDT Registers          WDT Load Register                                    -->
    <!-- 40000404  Watchdog Timer Interface        0  WDT Registers          WDT Control Register                                 -->
    <!-- 40000408  Watchdog Timer Interface        0  WDT Registers          WDT Kick Register                                    -->
    <!-- 4000040C  Watchdog Timer Interface        0  WDT Registers          WDT Count Register                                   -->
    <!--  -->
      <name>WDT</name>
      <version>1.0</version>
      <description>The function of the Watchdog Timer is to provide a mechanism to detect\n
       if the internal embedded controller has failed. When enabled, the Watchdog Timer (WDT) circuit\n
       will generate a WDT Event if the user program fails to reload the WDT within a specified length\n
       of time known as the WDT Interval.
      </description>
      <groupName>WDT</groupName>
      <baseAddress>0x40000400</baseAddress>
      <size>32</size>
      <access>read-write</access>

      <addressBlock>
        <offset>0</offset>
        <size>0x010</size>
        <usage>registers</usage>
      </addressBlock>

      <registers>
        <!-- WDT Load Register -->
        <register>
          <name>LOAD</name>
          <description>Writing this field reloads the Watch Dog Timer counter.
          </description>
          <addressOffset>0x00</addressOffset>
          <size>16</size>
          <access>read-write</access>
          <resetValue>0x000F</resetValue>
          <resetMask>0xFFFF</resetMask>
        </register>

        <!-- WDT Control Register -->
        <register>
          <name>CONTROL</name>
          <description>WDT Control Register
          </description>
          <addressOffset>0x04</addressOffset>
          <size>16</size>
          <access>read-write</access>
          <resetValue>0x0000</resetValue>
          <resetMask>0xFFFF</resetMask>

          <fields>
            <!-- WDT_ENABLE: WDT Enable -->
            <field>
              <name>ENABLE</name>
              <description>WDT Block enabled
              </description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>

            <!-- WDT_STATUS: WDT Status -->
            <field>
              <name>STATUS</name>
              <description>WDT_STATUS is set by hardware if the last reset of MEC1322/24 was caused by an underflow of the WDT. This bit must be cleared by the EC firmware writing a '1' to this bit. Writing a '0' to this bit has no effect.
              </description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>

        <!-- WDT Kick Register -->
        <register>
          <name>KICK</name>
          <description>Writes to the WDT Kick Register (WDT_kick) cause the WDT to reload the WDT Load Register (WDT_load) value and start decrementing when the WDT Enable (WDT_enable) bit in the WDT Control Register (WDT_control) is set to '1'. When the WDT Enable (WDT_enable) bit in the WDT Control Register (WDT_control) is cleared to '0', writes to the WDT Kick Register (WDT_kick) have no effect.
          </description>
          <addressOffset>0x08</addressOffset>
          <size>8</size>
          <access>write</access>
          <resetValue>0x00</resetValue>
          <resetMask>0xFF</resetMask>
        </register>

        <!-- WDT Count Register -->
        <register>
          <name>COUNT</name>
          <description>This read-only register provide the current WDT count.
          </description>
          <addressOffset>0x0C</addressOffset>
          <size>16</size>
          <access>read</access>
          <resetValue>0x000F</resetValue>
          <resetMask>0xFFFF</resetMask>
        </register>

      </registers>
    </peripheral>
    <!--  -->

    <peripheral>
    <!-- < Chapter 17.0>  Basic Timer -->
    <!-- 40000C00  Basic Timer                     0  Basic_Timer_EC_Only    Timer Count                                          -->
    <!-- 40000C04  Basic Timer                     0  Basic_Timer_EC_Only    Timer Preload                                        -->
    <!-- 40000C08  Basic Timer                     0  Basic_Timer_EC_Only    Timer Status                                         -->
    <!-- 40000C0C  Basic Timer                     0  Basic_Timer_EC_Only    Timer Interrupt Enable                               -->
    <!-- 40000C10  Basic Timer                     0  Basic_Timer_EC_Only    Timer Control                                        -->
    <!-- 40000C20  Basic Timer                     1  Basic_Timer_EC_Only    Timer Count                                          -->
    <!-- 40000C24  Basic Timer                     1  Basic_Timer_EC_Only    Timer Preload                                        -->
    <!-- 40000C28  Basic Timer                     1  Basic_Timer_EC_Only    Timer Status                                         -->
    <!-- 40000C2C  Basic Timer                     1  Basic_Timer_EC_Only    Timer Interrupt Enable                               -->
    <!-- 40000C30  Basic Timer                     1  Basic_Timer_EC_Only    Timer Control                                        -->
    <!-- 40000C40  Basic Timer                     2  Basic_Timer_EC_Only    Timer Count                                          -->
    <!-- 40000C44  Basic Timer                     2  Basic_Timer_EC_Only    Timer Preload                                        -->
    <!-- 40000C48  Basic Timer                     2  Basic_Timer_EC_Only    Timer Status                                         -->
    <!-- 40000C4C  Basic Timer                     2  Basic_Timer_EC_Only    Timer Interrupt Enable                               -->
    <!-- 40000C50  Basic Timer                     2  Basic_Timer_EC_Only    Timer Control                                        -->
    <!-- 40000C60  Basic Timer                     3  Basic_Timer_EC_Only    Timer Count                                          -->
    <!-- 40000C64  Basic Timer                     3  Basic_Timer_EC_Only    Timer Preload                                        -->
    <!-- 40000C68  Basic Timer                     3  Basic_Timer_EC_Only    Timer Status                                         -->
    <!-- 40000C6C  Basic Timer                     3  Basic_Timer_EC_Only    Timer Interrupt Enable                               -->
    <!-- 40000C70  Basic Timer                     3  Basic_Timer_EC_Only    Timer Control                                        -->
    <!-- 40000C80  Basic Timer                     4  Basic_Timer_EC_Only    Timer Count                                          -->
    <!-- 40000C84  Basic Timer                     4  Basic_Timer_EC_Only    Timer Preload                                        -->
    <!-- 40000C88  Basic Timer                     4  Basic_Timer_EC_Only    Timer Status                                         -->
    <!-- 40000C8C  Basic Timer                     4  Basic_Timer_EC_Only    Timer Interrupt Enable                               -->
    <!-- 40000C90  Basic Timer                     4  Basic_Timer_EC_Only    Timer Control                                        -->
    <!-- 40000CA0  Basic Timer                     5  Basic_Timer_EC_Only    Timer Count                                          -->
    <!-- 40000CA4  Basic Timer                     5  Basic_Timer_EC_Only    Timer Preload                                        -->
    <!-- 40000CA8  Basic Timer                     5  Basic_Timer_EC_Only    Timer Status                                         -->
    <!-- 40000CAC  Basic Timer                     5  Basic_Timer_EC_Only    Timer Interrupt Enable                               -->
    <!-- 40000CB0  Basic Timer                     5  Basic_Timer_EC_Only    Timer Control                                        -->
    <!--  -->
      <name>TIMER</name>
      <version>1.0</version>
      <description>This timer block offers a simple mechanism for firmware to maintain a time\n
       base. This timer may be instantiated as 16 bits or 32 bits.
      </description>
      <groupName>TIMER</groupName>
      <baseAddress>0x40000C00</baseAddress>
      <size>32</size>
      <access>read-write</access>

      <addressBlock>
        <offset>0</offset>
        <size>0x0C0</size>
        <usage>registers</usage>
      </addressBlock>

      <interrupt>
        <name>TIMER0</name>
        <description>TIMER_16_0 Interrupt .................. Also see GIRQ 23.0</description>
        <value>49</value>
      </interrupt>

      <interrupt>
        <name>TIMER1</name>
        <description>TIMER_16_1 Interrupt .................. Also see GIRQ 23.1</description>
        <value>50</value>
      </interrupt>

      <interrupt>
        <name>TIMER2</name>
        <description>TIMER_16_2 Interrupt .................. Also see GIRQ 23.2</description>
        <value>51</value>
      </interrupt>

      <interrupt>
        <name>TIMER3</name>
        <description>TIMER_16_3 Interrupt .................. Also see GIRQ 23.3</description>
        <value>52</value>
      </interrupt>

      <interrupt>
        <name>TIMER4</name>
        <description>TIMER_32_0 Interrupt .................. Also see GIRQ 23.4</description>
        <value>53</value>
      </interrupt>

      <interrupt>
        <name>TIMER5</name>
        <description>TIMER_32_1 Interrupt .................. Also see GIRQ 23.5</description>
        <value>54</value>
      </interrupt>

      <registers>
        <cluster>
          <dim>6</dim>
          <dimIncrement>0x20</dimIncrement>
          <dimIndex>0-5</dimIndex>
          <name>CH[%s]</name>
          <description>Channel implemented will have these registers to determine that channel's operation.
          </description>
          <addressOffset>0x00</addressOffset>
          <!-- Timer Count Register -->
          <register>
            <name>COUNT</name>
            <description>This is the value of the Timer counter. This is updated by Hardware but may be set by Firmware.
            </description>
            <addressOffset>0x00</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0000</resetValue>
            <resetMask>0xFFFF</resetMask>
          </register>

          <!-- Timer Preload Register -->
          <register>
            <name>PRELOAD</name>
            <description>This is the value of the Timer pre-load for the counter. This is used by H/W when the counter is to be restarted automatically; this will become the new value of the counter upon restart.
            </description>
            <addressOffset>0x04</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0000</resetValue>
            <resetMask>0xFFFF</resetMask>
          </register>

          <!-- Timer Status Register -->
          <register>
            <name>STATUS</name>
            <description>This is the interrupt status that fires when the timer reaches its limit. (R/WC)
            </description>
            <addressOffset>0x08</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0000</resetValue>
            <resetMask>0xFFFF</resetMask>

            <fields>
              <!-- INT_EVT: EVENT_INTERRUPT -->
              <field>
                <name>INT_EVT</name>
                <description>This is the interrupt status that fires when the timer reaches its limit. (R/WC)
                </description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>

          </register>

          <!-- Timer Int Enable Register -->
          <register>
            <name>INT_EN</name>
            <description>This is the interrupt enable for the status EVENT_INTERRUPT bit in the Timer Status Register
            </description>
            <addressOffset>0x0C</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0000</resetValue>
            <resetMask>0xFFFF</resetMask>

            <fields>
              <!-- INT_EVT: EVENT_INTERRUPT -->
              <field>
                <name>ENABLE</name>
                <description>This is the interrupt enable for the status EVENT_INTERRUPT bit in the Timer Status Register
                </description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>

          </register>

          <!-- Timer Control Register -->
          <register>
            <name>CONTROL</name>
            <description>Timer Control Register
            </description>
            <addressOffset>0x10</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0000</resetValue>
            <resetMask>0xFFFF</resetMask>

            <fields>
              <!-- ENABLE -->
              <field>
                <name>ENABLE</name>
                <description>This enables the block for operation.
                </description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>

              <!-- COUNT_UP -->
              <field>
                <name>COUNT_UP</name>
                <description>This selects the counter direction.
                </description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>

              <!-- AUTO_RESTART -->
              <field>
                <name>AUTO_RESTART</name>
                <description>This will select the action taken upon completing a count.
                </description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>

              <!-- SOFT_RESET -->
              <field>
                <name>SOFT_RESET</name>
                <description>This is a soft reset. This is self clearing 1 cycle after it is written.
                </description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>

              <!-- START -->
              <field>
                <name>START</name>
                <description>This bit triggers the timer counter.
                </description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>

              <!-- RELOAD -->
              <field>
                <name>RELOAD</name>
                <description>This bit reloads the counter without interrupting it operation. This will not function if the timer has already completed (when the START bit in this register is '0').
                </description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>

              <!-- HALT -->
              <field>
                <name>HALT</name>
                <description>This is a halt bit. This will halt the timer as long as it is active.
                </description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>

              <!-- PRE_SCALE -->
              <field>
                <name>PRE_SCALE</name>
                <description>This is used to divide down the system clock through clock enables to lower the power consumption of the block and allow slow timers.
                </description>
                <bitRange>[31:16]</bitRange>
                <access>read-write</access>
              </field>

            </fields>
          </register>
        </cluster>
      </registers>
    </peripheral>
    <!--  -->

    <peripheral>
    <!-- < Chapter 18.0>  Hibernation Timer  -->
    <!-- 40009800  Hibernation Timer               0  Registers              HTimer x Preload Register                            -->
    <!-- 40009804  Hibernation Timer               0  Registers              Hibernation Timer x Control Register                 -->
    <!-- 40009808  Hibernation Timer               0  Registers              Hibernation Timer x Count Register                   -->
    <!--  -->
      <name>HTM</name>
      <version>1.0</version>
      <description>The Hibernation Timer can generate a wake event to the Embedded Controller (EC)\n
       when it is in a hibernation mode. This block supports wake events up to 2 hours in duration. The timer\n
       is a 16-bit binary count-down timer that can be programmed in 30.5us and 0.125 second increments for period\n
       ranges of 30.5us to 2s or 0.125s to 136.5 minutes, respectively.
      </description>
      <groupName>HTM</groupName>
      <baseAddress>0x40009800</baseAddress>
      <size>32</size>
      <access>read-write</access>

      <addressBlock>
        <offset>0</offset>
        <size>0x010</size>
        <usage>registers</usage>
      </addressBlock>

      <interrupt>
        <name>HTIMER</name>
        <description>HTIMER Interrupt ...................... Also see GIRQ 17.20</description>
        <value>38</value>
      </interrupt>

      <registers>
        <!-- HTimer Preload Register -->
        <register>
          <name>PRELOAD</name>
          <description>[15:0] This register is used to set the Hibernation Timer Preload value.
          </description>
          <addressOffset>0x00</addressOffset>
          <size>16</size>
          <access>read-write</access>
          <resetValue>0x0000</resetValue>
          <resetMask>0xFFFF</resetMask>
        </register>

        <!-- HTimer Control Register -->
        <register>
          <name>CONTROL</name>
          <description>[0:0] 1= The Hibernation Timer has a resolution of 0.125s per LSB, which yields a maximum time in excess of 2 hours.\n
           0= The Hibernation Timer has a resolution of 30.5us per LSB, which yields a maximum time of ~2seconds.
          </description>
          <addressOffset>0x04</addressOffset>
          <size>16</size>
          <access>read-write</access>
          <resetValue>0x0000</resetValue>
          <resetMask>0xFFFF</resetMask>
        </register>

        <!-- HTimer Count Register -->
        <register>
          <name>COUNT</name>
          <description>The current state of the Hibernation Timer.
          </description>
          <addressOffset>0x08</addressOffset>
          <size>16</size>
          <access>read</access>
          <resetValue>0x0000</resetValue>
          <resetMask>0xFFFF</resetMask>
        </register>
      </registers>
    </peripheral>
    <!--  -->

    <peripheral>
    <!-- < Chapter 19.0>  RTC With Date and DST Adjustment -->
    <!-- 400F2C00  RTC                             0  RTC                    Seconds                                              -->
    <!-- 400F2C01  RTC                             0  RTC                    Seconds Alarm                                        -->
    <!-- 400F2C02  RTC                             0  RTC                    Minutes                                              -->
    <!-- 400F2C03  RTC                             0  RTC                    Minutes Alarm                                        -->
    <!-- 400F2C04  RTC                             0  RTC                    Hours                                                -->
    <!-- 400F2C05  RTC                             0  RTC                    Hours Alarm                                          -->
    <!-- 400F2C06  RTC                             0  RTC                    Day of Week                                          -->
    <!-- 400F2C07  RTC                             0  RTC                    Day of Month                                         -->
    <!-- 400F2C08  RTC                             0  RTC                    Month                                                -->
    <!-- 400F2C09  RTC                             0  RTC                    Year                                                 -->
    <!-- 400F2C0A  RTC                             0  RTC                    Register A                                           -->
    <!-- 400F2C0B  RTC                             0  RTC                    Register B                                           -->
    <!-- 400F2C0C  RTC                             0  RTC                    Register C                                           -->
    <!-- 400F2C0D  RTC                             0  RTC                    Register D                                           -->
    <!-- 400F2C10  RTC                             0  RTC                    RTC Control                                          -->
    <!-- 400F2C14  RTC                             0  RTC                    Week Alarm                                           -->
    <!-- 400F2C18  RTC                             0  RTC                    Daylight Savings Forward                             -->
    <!-- 400F2C1C  RTC                             0  RTC                    Daylight Savings Backward                            -->
    <!-- 400F2C20  RTC                             0  RTC                    RTC Test Mode                                        -->
    <!--  -->
      <name>RTC</name>
      <version>1.0</version>
      <description>This is the set of registers that are automatically counted by hardware\n
       every 1 second while the block is enabled to run and to update. These registers are:\n
       Seconds, Minutes, Hours, Day of Week, Day of Month, Month, and Year.
      </description>
      <groupName>RTC</groupName>
      <baseAddress>0x400F2C00</baseAddress>
      <size>32</size>
      <access>read-write</access>

      <addressBlock>
        <offset>0</offset>
        <size>0x040</size>
        <usage>registers</usage>
      </addressBlock>

      <interrupt>
        <name>RTC</name>
        <description>RTC Interrupt ......................... Also see GIRQ 17.18</description>
        <value>91</value>
      </interrupt>

      <interrupt>
        <name>RTC_ALARM</name>
        <description>RTC ALARM Interrupt ................... Also see GIRQ 17.19</description>
        <value>92</value>
      </interrupt>

      <registers>
        <!-- Seconds -->
        <register>
          <name>SEC</name>
          <description>Seconds Register
          </description>
          <addressOffset>0x00</addressOffset>
          <size>8</size>
          <access>read-write</access>
          <resetValue>0x00</resetValue>
          <resetMask>0xFF</resetMask>
        </register>

        <!-- Seconds Alarm -->
        <register>
          <name>SEC_ALARM</name>
          <description>Seconds Alarm Register
          </description>
          <addressOffset>0x01</addressOffset>
          <size>8</size>
          <access>read-write</access>
          <resetValue>0x00</resetValue>
          <resetMask>0xFF</resetMask>
        </register>

        <!-- Minutes -->
        <register>
          <name>MIN</name>
          <description>Minutes Register
          </description>
          <addressOffset>0x02</addressOffset>
          <size>8</size>
          <access>read-write</access>
          <resetValue>0x00</resetValue>
          <resetMask>0xFF</resetMask>
        </register>

        <!-- Minutes Alarm Register -->
        <register>
          <name>MIN_ALARM</name>
          <description>Minutes Alarm Register
          </description>
          <addressOffset>0x03</addressOffset>
          <size>8</size>
          <access>read-write</access>
          <resetValue>0x00</resetValue>
          <resetMask>0xFF</resetMask>
        </register>

        <!-- Hours Register -->
        <register>
          <name>HR</name>
          <description>Hours Register
          </description>
          <addressOffset>0x04</addressOffset>
          <size>8</size>
          <access>read-write</access>
          <resetValue>0x00</resetValue>
          <resetMask>0xFF</resetMask>
        </register>

        <!-- Hours Alarm Register -->
        <register>
          <name>HR_ALARM</name>
          <description>Hours Alarm Register
          </description>
          <addressOffset>0x05</addressOffset>
          <size>8</size>
          <access>read-write</access>
          <resetValue>0x00</resetValue>
          <resetMask>0xFF</resetMask>
        </register>

        <!-- Day of Week Register -->
        <register>
          <name>DAY_WEEK</name>
          <description>Day of Week Register
          </description>
          <addressOffset>0x06</addressOffset>
          <size>8</size>
          <access>read-write</access>
          <resetValue>0x00</resetValue>
          <resetMask>0xFF</resetMask>
        </register>

        <!-- Day of Month Register -->
        <register>
          <name>DAY_MONTH</name>
          <description>Day of Month Register
          </description>
          <addressOffset>0x07</addressOffset>
          <size>8</size>
          <access>read-write</access>
          <resetValue>0x00</resetValue>
          <resetMask>0xFF</resetMask>
        </register>

        <!-- Month Register -->
        <register>
          <name>MONTH</name>
          <description>Month Register
          </description>
          <addressOffset>0x08</addressOffset>
          <size>8</size>
          <access>read-write</access>
          <resetValue>0x00</resetValue>
          <resetMask>0xFF</resetMask>
        </register>

        <!-- Year Register -->
        <register>
          <name>YEAR</name>
          <description>Year Register
          </description>
          <addressOffset>0x09</addressOffset>
          <size>8</size>
          <access>read-write</access>
          <resetValue>0x00</resetValue>
          <resetMask>0xFF</resetMask>
        </register>

        <!-- Register A -->
        <register>
          <name>REG_A</name>
          <description>Register A
          </description>
          <addressOffset>0x0A</addressOffset>
          <size>8</size>
          <access>read-write</access>
          <resetValue>0x00</resetValue>
          <resetMask>0xFF</resetMask>
        </register>

        <!-- Register B -->
        <register>
          <name>REG_B</name>
          <description>Register B
          </description>
          <addressOffset>0x0B</addressOffset>
          <size>8</size>
          <access>read-write</access>
          <resetValue>0x00</resetValue>
          <resetMask>0xFF</resetMask>
        </register>

        <!-- Register C -->
        <register>
          <name>REG_C</name>
          <description>Register C
          </description>
          <addressOffset>0x0C</addressOffset>
          <size>8</size>
          <access>read-write</access>
          <resetValue>0x00</resetValue>
          <resetMask>0xFF</resetMask>
        </register>

        <!-- Register D -->
        <register>
          <name>REG_D</name>
          <description>Register D
          </description>
          <addressOffset>0x0D</addressOffset>
          <size>8</size>
          <access>read-write</access>
          <resetValue>0x00</resetValue>
          <resetMask>0xFF</resetMask>
        </register>

        <!-- RTC Control Register -->
        <register>
          <name>CONTROL</name>
          <description>RTC Control Register
          </description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0000</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <!-- BLOCK_ENABLE -->
            <field>
              <name>BLOCK_ENABLE</name>
              <description>BLOCK_ENABLE This bit must be '1' in order for the block to function internally. Registers may be initialized first, before setting this bit to '1' to start operation.
              </description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>

            <!-- SOFT_RESET -->
            <field>
              <name>SOFT_RESET</name>
              <description>SOFT_RESET A '1' written to this bit position will trigger the RTC_RST reset, resetting the block and all registers except this one and the Test Register. This bit is self-clearing at the end of the reset, one cycle of LPC Bus Clock later, and so requires no waiting.
              </description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>

            <!-- ALARM_ENABLE -->
            <field>
              <name>ALARM_ENABLE</name>
              <description>ALARM_ENABLE  1=Enables the Alarm features, 0=Disables the Alarm features
              </description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>

        <!-- Week Alarm Register -->
        <register>
          <name>WEEK_ALARM</name>
          <description>Week Alarm Register[7:0] - ALARM_DAY_OF_WEEK This register, if written to a value in the range 1--7, will inhibit the Alarm interrupt unless this field matches the contents of the Day of Week Register also.
          </description>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0000</resetValue>
          <resetMask>0xFFFF</resetMask>
        </register>

        <!-- Daylight Savings Forward Register -->
        <register>
          <name>DAYLIGHT_SAVINGS_FORWARD</name>
          <description>Daylight Savings Forward Register
          </description>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>

          <fields>

            <!-- DST_MONTH -->
            <field>
              <name>DST_MONTH</name>
              <description>This field matches the Month Register.
              </description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>

            <!-- DST_DAY_OF_WEEK -->
            <field>
              <name>DST_DAY_OF_WEEK</name>
              <description>This field matches the Day of Week Register bits[2:0].
              </description>
              <bitRange>[10:8]</bitRange>
              <access>read-write</access>
            </field>

            <!-- DST_WEEK -->
            <field>
              <name>DST_WEEK</name>
              <description>5=Last week of month, 4 =Fourth week of month, 3=Third week of month, 2=Second week of month, 1=First week of month
              </description>
              <bitRange>[18:16]</bitRange>
              <access>read-write</access>
            </field>

            <!-- DST_HOUR -->
            <field>
              <name>DST_HOUR</name>
              <description>This field holds the matching value for bits[6:0] of the Hours register. The written value will be interpreted according to the 24/12 Hour mode and DM mode settings at the time of writing.
              </description>
              <bitRange>[30:24]</bitRange>
              <access>read-write</access>
            </field>

            <!-- DST_AM_PM -->
            <field>
              <name>DST_AM_PM</name>
              <description>This bit selects AM vs. PM, to match bit[7] of the Hours Register if 12-Hour mode is selected in Register B at the time of writing.
              </description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>

        <!-- Daylight Savings Backward Register -->
        <register derivedFrom="DAYLIGHT_SAVINGS_FORWARD">
          <name>DAYLIGHT_SAVINGS_BACKWARD</name>
          <description>Daylight Savings Backward Register
          </description>
          <addressOffset>0x1C</addressOffset>
          <size>32</size>
        </register>

      </registers>
    </peripheral>
    <!--  -->

    <peripheral>
    <!-- < Chapter 20.0>  GPIO Interface  -->
    <!-- 40081000  GPIO                            0  GPIO Registers         GPIO000 Pin Control                                  -->
    <!-- 40081004  GPIO                            0  GPIO Registers         GPIO001 Pin Control                                  -->
    <!-- 40081008  GPIO                            0  GPIO Registers         GPIO002 Pin Control                                  -->
    <!-- 4008100C  GPIO                            0  GPIO Registers         GPIO003 Pin Control                                  -->
    <!-- 40081010  GPIO                            0  GPIO Registers         GPIO004 Pin Control                                  -->
    <!-- 40081014  GPIO                            0  GPIO Registers         GPIO005 Pin Control                                  -->
    <!-- 40081018  GPIO                            0  GPIO Registers         GPIO006 Pin Control                                  -->
    <!-- 4008101C  GPIO                            0  GPIO Registers         GPIO007 Pin Control                                  -->
    <!-- 40081020  GPIO                            0  GPIO Registers         GPIO010 Pin Control                                  -->
    <!-- 40081024  GPIO                            0  GPIO Registers         GPIO011 Pin Control                                  -->
    <!-- 40081028  GPIO                            0  GPIO Registers         GPIO012 Pin Control                                  -->
    <!-- 4008102C  GPIO                            0  GPIO Registers         GPIO013 Pin Control                                  -->
    <!-- 40081030  GPIO                            0  GPIO Registers         GPIO014 Pin Control                                  -->
    <!-- 40081034  GPIO                            0  GPIO Registers         GPIO015 Pin Control                                  -->
    <!-- 40081038  GPIO                            0  GPIO Registers         GPIO016 Pin Control                                  -->
    <!-- 4008103C  GPIO                            0  GPIO Registers         GPIO017 Pin Control                                  -->
    <!-- 40081040  GPIO                            0  GPIO Registers         GPIO020 Pin Control                                  -->
    <!-- 40081044  GPIO                            0  GPIO Registers         GPIO021 Pin Control                                  -->
    <!-- 40081048  GPIO                            0  GPIO Registers         GPIO022 Pin Control                                  -->
    <!-- 4008104C  GPIO                            0  GPIO Registers         GPIO023 Pin Control                                  -->
    <!-- 40081050  GPIO                            0  GPIO Registers         GPIO024 Pin Control                                  -->
    <!-- 40081054  GPIO                            0  GPIO Registers         GPIO025 Pin Control                                  -->
    <!-- 40081058  GPIO                            0  GPIO Registers         GPIO026 Pin Control                                  -->
    <!-- 4008105C  GPIO                            0  GPIO Registers         GPIO027 Pin Control                                  -->
    <!-- 40081060  GPIO                            0  GPIO Registers         GPIO030 Pin Control                                  -->
    <!-- 40081064  GPIO                            0  GPIO Registers         GPIO031 Pin Control                                  -->
    <!-- 40081068  GPIO                            0  GPIO Registers         GPIO032 Pin Control                                  -->
    <!-- 4008106C  GPIO                            0  GPIO Registers         GPIO033 Pin Control                                  -->
    <!-- 40081070  GPIO                            0  GPIO Registers         GPIO034 Pin Control                                  -->
    <!-- 40081074  GPIO                            0  GPIO Registers         GPIO035 Pin Control                                  -->
    <!-- 40081078  GPIO                            0  GPIO Registers         GPIO036 Pin Control                                  -->
    <!-- 40081080  GPIO                            0  GPIO Registers         GPIO040 Pin Control                                  -->
    <!-- 40081084  GPIO                            0  GPIO Registers         GPIO041 Pin Control                                  -->
    <!-- 40081088  GPIO                            0  GPIO Registers         GPIO042 Pin Control                                  -->
    <!-- 4008108C  GPIO                            0  GPIO Registers         GPIO043 Pin Control                                  -->
    <!-- 40081090  GPIO                            0  GPIO Registers         GPIO044 Pin Control                                  -->
    <!-- 40081094  GPIO                            0  GPIO Registers         GPIO045 Pin Control                                  -->
    <!-- 40081098  GPIO                            0  GPIO Registers         GPIO046 Pin Control                                  -->
    <!-- 4008109C  GPIO                            0  GPIO Registers         GPIO047 Pin Control                                  -->
    <!-- 400810A0  GPIO                            0  GPIO Registers         GPIO050 Pin Control                                  -->
    <!-- 400810A4  GPIO                            0  GPIO Registers         GPIO051 Pin Control                                  -->
    <!-- 400810A8  GPIO                            0  GPIO Registers         GPIO052 Pin Control                                  -->
    <!-- 400810AC  GPIO                            0  GPIO Registers         GPIO053 Pin Control                                  -->
    <!-- 400810B0  GPIO                            0  GPIO Registers         GPIO054 Pin Control                                  -->
    <!-- 400810B4  GPIO                            0  GPIO Registers         GPIO055 Pin Control                                  -->
    <!-- 400810B8  GPIO                            0  GPIO Registers         GPIO056 Pin Control                                  -->
    <!-- 400810BC  GPIO                            0  GPIO Registers         GPIO057 Pin Control                                  -->
    <!-- 400810C0  GPIO                            0  GPIO Registers         GPIO060 Pin Control                                  -->
    <!-- 400810C4  GPIO                            0  GPIO Registers         GPIO061 Pin Control                                  -->
    <!-- 400810C8  GPIO                            0  GPIO Registers         GPIO062 Pin Control                                  -->
    <!-- 400810CC  GPIO                            0  GPIO Registers         GPIO063 Pin Control                                  -->
    <!-- 400810D0  GPIO                            0  GPIO Registers         GPIO064 Pin Control                                  -->
    <!-- 400810D4  GPIO                            0  GPIO Registers         GPIO065 Pin Control                                  -->
    <!-- 400810D8  GPIO                            0  GPIO Registers         GPIO066 Pin Control                                  -->
    <!-- 400810DC  GPIO                            0  GPIO Registers         GPIO067 Pin Control                                  -->
    <!-- 40081100  GPIO                            0  GPIO Registers         GPIO100 Pin Control                                  -->
    <!-- 40081104  GPIO                            0  GPIO Registers         GPIO101 Pin Control                                  -->
    <!-- 40081108  GPIO                            0  GPIO Registers         GPIO102 Pin Control                                  -->
    <!-- 4008110C  GPIO                            0  GPIO Registers         GPIO103 Pin Control                                  -->
    <!-- 40081110  GPIO                            0  GPIO Registers         GPIO104 Pin Control                                  -->
    <!-- 40081114  GPIO                            0  GPIO Registers         GPIO105 Pin Control                                  -->
    <!-- 40081118  GPIO                            0  GPIO Registers         GPIO106 Pin Control                                  -->
    <!-- 4008111C  GPIO                            0  GPIO Registers         GPIO107 Pin Control                                  -->
    <!-- 40081120  GPIO                            0  GPIO Registers         GPIO110 Pin Control                                  -->
    <!-- 40081124  GPIO                            0  GPIO Registers         GPIO111 Pin Control                                  -->
    <!-- 40081128  GPIO                            0  GPIO Registers         GPIO112 Pin Control                                  -->
    <!-- 4008112C  GPIO                            0  GPIO Registers         GPIO113 Pin Control                                  -->
    <!-- 40081130  GPIO                            0  GPIO Registers         GPIO114 Pin Control                                  -->
    <!-- 40081134  GPIO                            0  GPIO Registers         GPIO115 Pin Control                                  -->
    <!-- 40081138  GPIO                            0  GPIO Registers         GPIO116 Pin Control                                  -->
    <!-- 4008113C  GPIO                            0  GPIO Registers         GPIO117 Pin Control                                  -->
    <!-- 40081140  GPIO                            0  GPIO Registers         GPIO120 Pin Control                                  -->
    <!-- 40081144  GPIO                            0  GPIO Registers         GPIO121 Pin Control                                  -->
    <!-- 40081148  GPIO                            0  GPIO Registers         GPIO122 Pin Control                                  -->
    <!-- 4008114C  GPIO                            0  GPIO Registers         GPIO123 Pin Control                                  -->
    <!-- 40081150  GPIO                            0  GPIO Registers         GPIO124 Pin Control                                  -->
    <!-- 40081154  GPIO                            0  GPIO Registers         GPIO125 Pin Control                                  -->
    <!-- 40081158  GPIO                            0  GPIO Registers         GPIO126 Pin Control                                  -->
    <!-- 4008115C  GPIO                            0  GPIO Registers         GPIO127 Pin Control                                  -->
    <!-- 40081160  GPIO                            0  GPIO Registers         GPIO130 Pin Control                                  -->
    <!-- 40081164  GPIO                            0  GPIO Registers         GPIO131 Pin Control                                  -->
    <!-- 40081168  GPIO                            0  GPIO Registers         GPIO132 Pin Control                                  -->
    <!-- 4008116C  GPIO                            0  GPIO Registers         GPIO133 Pin Control                                  -->
    <!-- 40081170  GPIO                            0  GPIO Registers         GPIO134 Pin Control                                  -->
    <!-- 40081174  GPIO                            0  GPIO Registers         GPIO135 Pin Control                                  -->
    <!-- 40081178  GPIO                            0  GPIO Registers         GPIO136 Pin Control                                  -->
    <!-- 40081180  GPIO                            0  GPIO Registers         GPIO140 Pin Control                                  -->
    <!-- 40081184  GPIO                            0  GPIO Registers         GPIO141 Pin Control                                  -->
    <!-- 40081188  GPIO                            0  GPIO Registers         GPIO142 Pin Control                                  -->
    <!-- 4008118C  GPIO                            0  GPIO Registers         GPIO143 Pin Control                                  -->
    <!-- 40081190  GPIO                            0  GPIO Registers         GPIO144 Pin Control                                  -->
    <!-- 40081194  GPIO                            0  GPIO Registers         GPIO145 Pin Control                                  -->
    <!-- 40081198  GPIO                            0  GPIO Registers         GPIO146 Pin Control                                  -->
    <!-- 4008119C  GPIO                            0  GPIO Registers         GPIO147 Pin Control                                  -->
    <!-- 400811A0  GPIO                            0  GPIO Registers         GPIO150 Pin Control                                  -->
    <!-- 400811A4  GPIO                            0  GPIO Registers         GPIO151 Pin Control                                  -->
    <!-- 400811A8  GPIO                            0  GPIO Registers         GPIO152 Pin Control                                  -->
    <!-- 400811AC  GPIO                            0  GPIO Registers         GPIO153 Pin Control                                  -->
    <!-- 400811B0  GPIO                            0  GPIO Registers         GPIO154 Pin Control                                  -->
    <!-- 400811B4  GPIO                            0  GPIO Registers         GPIO155 Pin Control                                  -->
    <!-- 400811B8  GPIO                            0  GPIO Registers         GPIO156 Pin Control                                  -->
    <!-- 400811BC  GPIO                            0  GPIO Registers         GPIO157 Pin Control                                  -->
    <!-- 400811C0  GPIO                            0  GPIO Registers         GPIO160 Pin Control                                  -->
    <!-- 400811C4  GPIO                            0  GPIO Registers         GPIO161 Pin Control                                  -->
    <!-- 400811C8  GPIO                            0  GPIO Registers         GPIO162 Pin Control                                  -->
    <!-- 400811CC  GPIO                            0  GPIO Registers         GPIO163 Pin Control                                  -->
    <!-- 400811D0  GPIO                            0  GPIO Registers         GPIO164 Pin Control                                  -->
    <!-- 400811D4  GPIO                            0  GPIO Registers         GPIO165 Pin Control                                  -->
    <!-- 40081200  GPIO                            0  GPIO Registers         GPIO200 Pin Control                                  -->
    <!-- 40081204  GPIO                            0  GPIO Registers         GPIO201 Pin Control                                  -->
    <!-- 40081208  GPIO                            0  GPIO Registers         GPIO202 Pin Control                                  -->
    <!-- 4008120C  GPIO                            0  GPIO Registers         GPIO203 Pin Control                                  -->
    <!-- 40081210  GPIO                            0  GPIO Registers         GPIO204 Pin Control                                  -->
    <!-- 40081214  GPIO                            0  GPIO Registers         Reserved                                             -->
    <!-- 40081218  GPIO                            0  GPIO Registers         GPIO206 Pin Control                                  -->
    <!-- 4008121C  GPIO                            0  GPIO Registers         Reserved                                             -->
    <!-- 40081220  GPIO                            0  GPIO Registers         GPIO210 Pin Control                                  -->
    <!-- 40081224  GPIO                            0  GPIO Registers         GPIO211 Pin Control                                  -->
    <!-- 40081228  GPIO                            0  GPIO Registers         GPIO212 Pin Control                                  -->
    <!-- 4008122C  GPIO                            0  GPIO Registers         GPIO213 Pin Control                                  -->
    <!-- 40081280  GPIO                            0  GPIO Registers         Output GPIO[000:036]                                 -->
    <!-- 40081284  GPIO                            0  GPIO Registers         Output GPIO[040:076]                                 -->
    <!-- 40081288  GPIO                            0  GPIO Registers         Output GPIO[100:136]                                 -->
    <!-- 4008128C  GPIO                            0  GPIO Registers         Output GPIO[140:176]                                 -->
    <!-- 40081290  GPIO                            0  GPIO Registers         Output GPIO[200:236]                                 -->
    <!-- 40081300  GPIO                            0  GPIO Registers         Input GPIO[000:036]                                  -->
    <!-- 40081304  GPIO                            0  GPIO Registers         Input GPIO[040:076]                                  -->
    <!-- 40081308  GPIO                            0  GPIO Registers         Input GPIO[100:136]                                  -->
    <!-- 4008130C  GPIO                            0  GPIO Registers         Input GPIO[140:176]                                  -->
    <!-- 40081310  GPIO                            0  GPIO Registers         Input GPIO[200:236]                                  -->
    <!-- 40081314  GPIO                            0  GPIO Registers         Reserved                                             -->
    <!-- 40081500  GPIO                            0  GPIO Registers         GPIO000 Pin Control 2                                -->
    <!-- 40081504  GPIO                            0  GPIO Registers         GPIO001 Pin Control 2                                -->
    <!-- 40081508  GPIO                            0  GPIO Registers         GPIO002 Pin Control 2                                -->
    <!-- 4008150C  GPIO                            0  GPIO Registers         GPIO003 Pin Control 2                                -->
    <!-- 40081510  GPIO                            0  GPIO Registers         GPIO004 Pin Control 2                                -->
    <!-- 40081514  GPIO                            0  GPIO Registers         GPIO005 Pin Control 2                                -->
    <!-- 40081518  GPIO                            0  GPIO Registers         GPIO006 Pin Control 2                                -->
    <!-- 4008151C  GPIO                            0  GPIO Registers         GPIO007 Pin Control 2                                -->
    <!-- 40081520  GPIO                            0  GPIO Registers         GPIO010 Pin Control 2                                -->
    <!-- 40081524  GPIO                            0  GPIO Registers         GPIO011 Pin Control 2                                -->
    <!-- 40081528  GPIO                            0  GPIO Registers         GPIO012 Pin Control 2                                -->
    <!-- 4008152C  GPIO                            0  GPIO Registers         GPIO013 Pin Control 2                                -->
    <!-- 40081530  GPIO                            0  GPIO Registers         GPIO014 Pin Control 2                                -->
    <!-- 40081534  GPIO                            0  GPIO Registers         GPIO015 Pin Control 2                                -->
    <!-- 40081538  GPIO                            0  GPIO Registers         GPIO016 Pin Control 2                                -->
    <!-- 4008153C  GPIO                            0  GPIO Registers         GPIO017 Pin Control 2                                -->
    <!-- 40081540  GPIO                            0  GPIO Registers         GPIO020 Pin Control 2                                -->
    <!-- 40081544  GPIO                            0  GPIO Registers         GPIO021 Pin Control 2                                -->
    <!-- 40081548  GPIO                            0  GPIO Registers         GPIO022 Pin Control 2                                -->
    <!-- 4008154C  GPIO                            0  GPIO Registers         GPIO023 Pin Control 2                                -->
    <!-- 40081550  GPIO                            0  GPIO Registers         GPIO024 Pin Control 2                                -->
    <!-- 40081554  GPIO                            0  GPIO Registers         GPIO025 Pin Control 2                                -->
    <!-- 40081558  GPIO                            0  GPIO Registers         GPIO026 Pin Control 2                                -->
    <!-- 4008155C  GPIO                            0  GPIO Registers         GPIO027 Pin Control 2                                -->
    <!-- 40081560  GPIO                            0  GPIO Registers         GPIO030 Pin Control 2                                -->
    <!-- 40081564  GPIO                            0  GPIO Registers         GPIO031 Pin Control 2                                -->
    <!-- 40081568  GPIO                            0  GPIO Registers         GPIO032 Pin Control 2                                -->
    <!-- 4008156C  GPIO                            0  GPIO Registers         GPIO033 Pin Control 2                                -->
    <!-- 40081570  GPIO                            0  GPIO Registers         GPIO034 Pin Control 2                                -->
    <!-- 40081574  GPIO                            0  GPIO Registers         GPIO035 Pin Control 2                                -->
    <!-- 40081578  GPIO                            0  GPIO Registers         GPIO036 Pin Control 2                                -->
    <!-- 40081580  GPIO                            0  GPIO Registers         GPIO040 Pin Control 2                                -->
    <!-- 40081584  GPIO                            0  GPIO Registers         GPIO041 Pin Control 2                                -->
    <!-- 40081588  GPIO                            0  GPIO Registers         GPIO042 Pin Control 2                                -->
    <!-- 4008158C  GPIO                            0  GPIO Registers         GPIO043 Pin Control 2                                -->
    <!-- 40081590  GPIO                            0  GPIO Registers         GPIO044 Pin Control 2                                -->
    <!-- 40081594  GPIO                            0  GPIO Registers         GPIO045 Pin Control 2                                -->
    <!-- 40081598  GPIO                            0  GPIO Registers         GPIO046 Pin Control 2                                -->
    <!-- 4008159C  GPIO                            0  GPIO Registers         GPIO047 Pin Control 2                                -->
    <!-- 400815A0  GPIO                            0  GPIO Registers         GPIO050 Pin Control 2                                -->
    <!-- 400815A4  GPIO                            0  GPIO Registers         GPIO051 Pin Control 2                                -->
    <!-- 400815A8  GPIO                            0  GPIO Registers         GPIO052 Pin Control 2                                -->
    <!-- 400815AC  GPIO                            0  GPIO Registers         GPIO053 Pin Control 2                                -->
    <!-- 400815B0  GPIO                            0  GPIO Registers         GPIO054 Pin Control 2                                -->
    <!-- 400815B4  GPIO                            0  GPIO Registers         GPIO055 Pin Control 2                                -->
    <!-- 400815B8  GPIO                            0  GPIO Registers         GPIO056 Pin Control 2                                -->
    <!-- 400815BC  GPIO                            0  GPIO Registers         GPIO057 Pin Control 2                                -->
    <!-- 400815C0  GPIO                            0  GPIO Registers         GPIO060 Pin Control 2                                -->
    <!-- 400815C4  GPIO                            0  GPIO Registers         GPIO061 Pin Control 2                                -->
    <!-- 400815C8  GPIO                            0  GPIO Registers         GPIO062 Pin Control 2                                -->
    <!-- 400815CC  GPIO                            0  GPIO Registers         GPIO063 Pin Control 2                                -->
    <!-- 400815D0  GPIO                            0  GPIO Registers         GPIO064 Pin Control 2                                -->
    <!-- 400815D4  GPIO                            0  GPIO Registers         GPIO065 Pin Control 2                                -->
    <!-- 400815D8  GPIO                            0  GPIO Registers         GPIO066 Pin Control 2                                -->
    <!-- 400815DC  GPIO                            0  GPIO Registers         GPIO067 Pin Control 2                                -->
    <!-- 400815E0  GPIO                            0  GPIO Registers         GPIO100 Pin Control 2                                -->
    <!-- 400815E4  GPIO                            0  GPIO Registers         GPIO101 Pin Control 2                                -->
    <!-- 400815E8  GPIO                            0  GPIO Registers         GPIO102 Pin Control 2                                -->
    <!-- 400815EC  GPIO                            0  GPIO Registers         GPIO103 Pin Control 2                                -->
    <!-- 400815F0  GPIO                            0  GPIO Registers         GPIO104 Pin Control 2                                -->
    <!-- 400815F4  GPIO                            0  GPIO Registers         GPIO105 Pin Control 2                                -->
    <!-- 400815F8  GPIO                            0  GPIO Registers         GPIO106 Pin Control 2                                -->
    <!-- 400815FC  GPIO                            0  GPIO Registers         GPIO107 Pin Control 2                                -->
    <!-- 40081600  GPIO                            0  GPIO Registers         GPIO110 Pin Control 2                                -->
    <!-- 40081604  GPIO                            0  GPIO Registers         GPIO111 Pin Control 2                                -->
    <!-- 40081608  GPIO                            0  GPIO Registers         GPIO112 Pin Control 2                                -->
    <!-- 4008160C  GPIO                            0  GPIO Registers         GPIO113 Pin Control 2                                -->
    <!-- 40081610  GPIO                            0  GPIO Registers         GPIO114 Pin Control 2                                -->
    <!-- 40081614  GPIO                            0  GPIO Registers         GPIO115 Pin Control 2                                -->
    <!-- 40081618  GPIO                            0  GPIO Registers         GPIO116 Pin Control 2                                -->
    <!-- 4008161C  GPIO                            0  GPIO Registers         GPIO117 Pin Control 2                                -->
    <!-- 40081620  GPIO                            0  GPIO Registers         GPIO120 Pin Control 2                                -->
    <!-- 40081624  GPIO                            0  GPIO Registers         GPIO121 Pin Control 2                                -->
    <!-- 40081628  GPIO                            0  GPIO Registers         GPIO122 Pin Control 2                                -->
    <!-- 4008162C  GPIO                            0  GPIO Registers         GPIO123 Pin Control 2                                -->
    <!-- 40081630  GPIO                            0  GPIO Registers         GPIO124 Pin Control 2                                -->
    <!-- 40081634  GPIO                            0  GPIO Registers         GPIO125 Pin Control 2                                -->
    <!-- 40081638  GPIO                            0  GPIO Registers         GPIO126 Pin Control 2                                -->
    <!-- 4008163C  GPIO                            0  GPIO Registers         GPIO127 Pin Control 2                                -->
    <!-- 40081640  GPIO                            0  GPIO Registers         GPIO130 Pin Control 2                                -->
    <!-- 40081644  GPIO                            0  GPIO Registers         GPIO131 Pin Control 2                                -->
    <!-- 40081648  GPIO                            0  GPIO Registers         GPIO132 Pin Control 2                                -->
    <!-- 4008164C  GPIO                            0  GPIO Registers         GPIO133 Pin Control 2                                -->
    <!-- 40081650  GPIO                            0  GPIO Registers         GPIO134 Pin Control 2                                -->
    <!-- 40081654  GPIO                            0  GPIO Registers         GPIO135 Pin Control 2                                -->
    <!-- 40081658  GPIO                            0  GPIO Registers         GPIO136 Pin Control 2                                -->
    <!-- 40081660  GPIO                            0  GPIO Registers         GPIO140 Pin Control 2                                -->
    <!-- 40081664  GPIO                            0  GPIO Registers         GPIO141 Pin Control 2                                -->
    <!-- 40081668  GPIO                            0  GPIO Registers         GPIO142 Pin Control 2                                -->
    <!-- 4008166C  GPIO                            0  GPIO Registers         GPIO143 Pin Control 2                                -->
    <!-- 40081670  GPIO                            0  GPIO Registers         GPIO144 Pin Control 2                                -->
    <!-- 40081674  GPIO                            0  GPIO Registers         GPIO145 Pin Control 2                                -->
    <!-- 40081678  GPIO                            0  GPIO Registers         GPIO146 Pin Control 2                                -->
    <!-- 4008167C  GPIO                            0  GPIO Registers         GPIO147 Pin Control 2                                -->
    <!-- 40081680  GPIO                            0  GPIO Registers         GPIO150 Pin Control 2                                -->
    <!-- 40081684  GPIO                            0  GPIO Registers         GPIO151 Pin Control 2                                -->
    <!-- 40081688  GPIO                            0  GPIO Registers         GPIO152 Pin Control 2                                -->
    <!-- 4008168C  GPIO                            0  GPIO Registers         GPIO153 Pin Control 2                                -->
    <!-- 40081690  GPIO                            0  GPIO Registers         GPIO154 Pin Control 2                                -->
    <!-- 40081694  GPIO                            0  GPIO Registers         GPIO155 Pin Control 2                                -->
    <!-- 40081698  GPIO                            0  GPIO Registers         GPIO156 Pin Control 2                                -->
    <!-- 4008169C  GPIO                            0  GPIO Registers         GPIO157 Pin Control 2                                -->
    <!-- 400816A0  GPIO                            0  GPIO Registers         GPIO160 Pin Control 2                                -->
    <!-- 400816A4  GPIO                            0  GPIO Registers         GPIO161 Pin Control 2                                -->
    <!-- 400816A8  GPIO                            0  GPIO Registers         GPIO162 Pin Control 2                                -->
    <!-- 400816AC  GPIO                            0  GPIO Registers         GPIO163 Pin Control 2                                -->
    <!-- 400816B0  GPIO                            0  GPIO Registers         GPIO164 Pin Control 2                                -->
    <!-- 400816B4  GPIO                            0  GPIO Registers         GPIO165 Pin Control 2                                -->
    <!-- 40081720  GPIO                            0  GPIO Registers         GPIO200 Pin Control 2                                -->
    <!-- 40081724  GPIO                            0  GPIO Registers         GPIO201 Pin Control 2                                -->
    <!-- 40081728  GPIO                            0  GPIO Registers         GPIO202 Pin Control 2                                -->
    <!-- 4008172C  GPIO                            0  GPIO Registers         GPIO203 Pin Control 2                                -->
    <!-- 40081730  GPIO                            0  GPIO Registers         GPIO204 Pin Control 2                                -->
    <!-- 40081738  GPIO                            0  GPIO Registers         GPIO206 Pin Control 2                                -->
    <!-- 40081740  GPIO                            0  GPIO Registers         GPIO210 Pin Control 2                                -->
    <!-- 40081744  GPIO                            0  GPIO Registers         GPIO211 Pin Control 2                                -->
    <!-- 40081748  GPIO                            0  GPIO Registers         GPIO212 Pin Control 2                                -->
    <!-- 4008174C  GPIO                            0  GPIO Registers         GPIO213 Pin Control 2                                -->
    <!--  -->
      <name>GPIO</name>
      <version>1.0</version>
      <description>The MEC1322/24 GPIO Interface provides general purpose input monitoring\n
       and output control, as well as managing many aspects of pin functionality; including, multi-function\n
       Pin Multiplexing Control, GPIO Direction control, PU/PD (PU_PD) resistors, asynchronous wakeup and\n
       synchronous Interrupt Detection (int_det), GPIO Direction, and Polarity control, as well as control\n
       of pin drive strength and slew rate.
      </description>
      <groupName>GPIO</groupName>
      <baseAddress>0x40081000</baseAddress>
      <size>32</size>
      <access>read-write</access>

      <addressBlock>
        <offset>0</offset>
        <size>0x800</size>
        <usage>registers</usage>
      </addressBlock>

      <registers>

        <!-- PIN CONTROL REGISTER -->
        <register>
          <dim>160</dim>
          <dimIncrement>4</dimIncrement>
          <dimIndex>0-159</dimIndex>
          <name>PIN_CONTROL[%s]</name>
          <description>Two Pin Control Registers are implemented for each GPIO. That's the first one.
          </description>
          <addressOffset>0x00</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>

          <fields>

            <!-- PU/PD (PU_PD) -->
            <field>
              <name>PU_PD</name>
              <description>PU/PD (PU_PD) 00 = None, 01 = Pull Up Enabled, 10 = Pull Down Enabled, 11 = None
              </description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
            </field>

            <!-- Power Gating Signals -->
            <field>
              <name>PWR</name>
              <description>Power Gating Signals. 00 = VCC1 Power Rail  01 = VCC2 Power Rail 1x = Reserved
              </description>
              <bitRange>[3:2]</bitRange>
              <access>read-write</access>
            </field>

            <!-- Interrupt Detection (int_det) -->
            <field>
              <name>INT_DET</name>
              <description>0 000 = Low Level Sensitive, 0 001 = High Level Sensitive\n
              0 100 = Interrupt events are disabled\n
              1 101 = Rising Edge Triggered  \n
              1 110 = Falling Edge Triggered \n
              1 111 = Either edge triggered
              </description>
              <bitRange>[6:4]</bitRange>
              <access>read-write</access>
            </field>

            <!-- Edge Enable -->
            <field>
              <name>EDGE_EN</name>
              <description>Edge Enable, 0 = Edge detection disabled, 1 = Edge detection enabled
              </description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>

            <!-- Output Buffer Type -->
            <field>
              <name>BUFFER</name>
              <description>Output Buffer Type. 0 = Push-Pull, 1 = Open Drain
              </description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>

            <!-- GPIO Direction -->
            <field>
              <name>DIR</name>
              <description>GPIO Direction. 0 = Input, 1 = Output
              </description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>

            <!-- Output GPIO Write Enable -->
            <field>
              <name>OUTPUT_WRITE_EN</name>
              <description>0 = Alternative GPIO data write enabled When this bit is zero the Alternative GPIO data write is enabled and the Output GPIO is disabled.\n
               1 = Output GPIO enable When this bit is one the Alternative GPIO data write is disabled and the Output GPIO is enabled.
              </description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>

            <!-- Polarity -->
            <field>
              <name>POLARITY</name>
              <description>0 = Non-inverted, 1 = Inverted
              </description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>

            <!-- Mux Control -->
            <field>
              <name>MUX</name>
              <description>00 = GPIO Function Selected, 01 = Signal Function 1 Selected, 10 = Signal Function 2 Selected, 11 = Signal Function 3 Selected
              </description>
              <bitRange>[13:12]</bitRange>
              <access>read-write</access>
            </field>

            <!-- Alternative GPIO data -->
            <field>
              <name>OUTPUT</name>
              <description>On writes: If enabled via the Output GPIO Write Enable, 0: GPIO[x] out = '0',  1: GPIO[x] out = '1'
              </description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>

            <!-- GPIO input from pad -->
            <field>
              <name>INPUT</name>
              <description>On reads, Bit [24] reflects the state of GPIO input from the pad regardless of setting of Bit [10].
              </description>
              <bitRange>[24:24]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>

        <!-- GPIO OUTPUT REGISTERS -->
        <register>
          <dim>5</dim>
          <dimIncrement>4</dimIncrement>
          <dimIndex>0-4</dimIndex>
          <name>OUTPUT[%s]</name>
          <description>If enabled by the Output GPIO Write Enable bit, the GPIO Output bits determine the level on the GPIO pin when the pin is configured for the GPIO output function.\n
           On writes: If enabled via the Output GPIO Write Enable 0: GPIO[x] out = '0', 1: GPIO[x] out = '1'
          </description>
          <addressOffset>0x280</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
        </register>

        <!-- GPIO INPUT REGISTERS -->
        <register>
          <dim>5</dim>
          <dimIncrement>4</dimIncrement>
          <dimIndex>0-4</dimIndex>
          <name>INPUT[%s]</name>
          <description>The GPIO Input Registers can always be used to read the state of a pin, even when the pin is in an output mode and/or when a signal function other than the GPIO signal function is selected 
          </description>
          <addressOffset>0x300</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
        </register>

        <!-- PIN CONTROL REGISTER 2 -->
        <register>
          <dim>56</dim>
          <dimIncrement>4</dimIncrement>
          <dimIndex>0-55</dimIndex>
          <name>CONTROL2_000_067[%s]</name>
          <description>PIN CONTROL REGISTER 2, from 000 - 067
          </description>
          <addressOffset>0x500</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>

          <fields>
            <!-- Slew Rate (slew_rate) -->
            <field>
              <name>SLEW_RATE</name>
              <description>This bit is used to select the slew rate on the pin. 0 = slow (half frequency), 1 = fast
              </description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>

            <!-- Drive Strength (drive_strength) -->
            <field>
              <name>DRIVE_STRENGTH</name>
              <description>These bits are used to select the drive strength on the pin. [5:4] = 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 = 12mA
              </description>
              <bitRange>[5:4]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>

        <register>
          <dim>56</dim>
          <dimIncrement>4</dimIncrement>
          <dimIndex>0-55</dimIndex>
          <name>CONTROL2_100_167[%s]</name>
          <description>PIN CONTROL REGISTER 2, from 100 - 167
          </description>
          <addressOffset>0x5E0</addressOffset>
          <fields>
            <!-- Slew Rate (slew_rate) -->
            <field>
              <name>SLEW_RATE</name>
              <description>This bit is used to select the slew rate on the pin. 0 = slow (half frequency), 1 = fast
              </description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>

            <!-- Drive Strength (drive_strength) -->
            <field>
              <name>DRIVE_STRENGTH</name>
              <description>These bits are used to select the drive strength on the pin. [5:4] = 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 = 12mA
              </description>
              <bitRange>[5:4]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>

        <register>
          <dim>56</dim>
          <dimIncrement>4</dimIncrement>
          <dimIndex>0-55</dimIndex>
          <name>CONTROL2_200_267[%s]</name>
          <description>PIN CONTROL REGISTER 2, from 200 - 267
          </description>
          <addressOffset>0x720</addressOffset>
          <fields>
            <!-- Slew Rate (slew_rate) -->
            <field>
              <name>SLEW_RATE</name>
              <description>This bit is used to select the slew rate on the pin. 0 = slow (half frequency), 1 = fast
              </description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>

            <!-- Drive Strength (drive_strength) -->
            <field>
              <name>DRIVE_STRENGTH</name>
              <description>These bits are used to select the drive strength on the pin. [5:4] = 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 = 12mA
              </description>
              <bitRange>[5:4]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>

      </registers>
    </peripheral>
    <!--  -->

    <peripheral>
    <!-- < Chapter 21.0>  Internal DMA Controller  -->
    <!-- 40002400  DMA                             0  DMA Main               DMA Main Control Register                            -->
    <!-- 40002401  DMA                             0  DMA Main               DMA Reserved                                         -->
    <!-- 40002404  DMA                             0  DMA Main               DMA AFIFO Data Register                              -->
    <!-- 40002408  DMA                             0  DMA Main               DMA Main Debug Register                              -->
    <!-- 40002409  DMA                             0  DMA Main               DMA Reserved                                         -->
    <!-- 40002410  DMA                             0  DMA_CH0                DMA Activate Register                                -->
    <!-- 40002414  DMA                             0  DMA_CH0                DMA Memory Start Address Register                    -->
    <!-- 40002418  DMA                             0  DMA_CH0                DMA Memory End Address Register                      -->
    <!-- 4000241C  DMA                             0  DMA_CH0                AHB Address Register                                 -->
    <!-- 40002420  DMA                             0  DMA_CH0                DMA Control Register                                 -->
    <!-- 40002424  DMA                             0  DMA_CH0                DMA Channel Interrupt Status                         -->
    <!-- 40002428  DMA                             0  DMA_CH0                DMA Channel Interrupt Enable                         -->
    <!-- 4000242C  DMA                             0  DMA_CH0                DMA Test Register                                    -->
    <!-- 40002430  DMA                             0  DMA_CH1                DMA Activate Register                                -->
    <!-- 40002434  DMA                             0  DMA_CH1                DMA Memory Start Address Register                    -->
    <!-- 40002438  DMA                             0  DMA_CH1                DMA Memory End Address Register                      -->
    <!-- 4000243C  DMA                             0  DMA_CH1                AHB Address Register                                 -->
    <!-- 40002440  DMA                             0  DMA_CH1                DMA Control Register                                 -->
    <!-- 40002444  DMA                             0  DMA_CH1                DMA Channel Interrupt Status                         -->
    <!-- 40002448  DMA                             0  DMA_CH1                DMA Channel Interrupt Enable                         -->
    <!-- 4000244C  DMA                             0  DMA_CH1                DMA Test Register                                    -->
    <!-- 40002450  DMA                             0  DMA_CH2                DMA Activate Register                                -->
    <!-- 40002454  DMA                             0  DMA_CH2                DMA Memory Start Address Register                    -->
    <!-- 40002458  DMA                             0  DMA_CH2                DMA Memory End Address Register                      -->
    <!-- 4000245C  DMA                             0  DMA_CH2                AHB Address Register                                 -->
    <!-- 40002460  DMA                             0  DMA_CH2                DMA Control Register                                 -->
    <!-- 40002464  DMA                             0  DMA_CH2                DMA Channel Interrupt Status                         -->
    <!-- 40002468  DMA                             0  DMA_CH2                DMA Channel Interrupt Enable                         -->
    <!-- 4000246C  DMA                             0  DMA_CH2                DMA Test Register                                    -->
    <!-- 40002470  DMA                             0  DMA_CH3                DMA Activate Register                                -->
    <!-- 40002474  DMA                             0  DMA_CH3                DMA Memory Start Address Register                    -->
    <!-- 40002478  DMA                             0  DMA_CH3                DMA Memory End Address Register                      -->
    <!-- 4000247C  DMA                             0  DMA_CH3                AHB Address Register                                 -->
    <!-- 40002480  DMA                             0  DMA_CH3                DMA Control Register                                 -->
    <!-- 40002484  DMA                             0  DMA_CH3                DMA Channel Interrupt Status                         -->
    <!-- 40002488  DMA                             0  DMA_CH3                DMA Channel Interrupt Enable                         -->
    <!-- 4000248C  DMA                             0  DMA_CH3                DMA Test Register                                    -->
    <!-- 40002490  DMA                             0  DMA_CH4                DMA Activate Register                                -->
    <!-- 40002494  DMA                             0  DMA_CH4                DMA Memory Start Address Register                    -->
    <!-- 40002498  DMA                             0  DMA_CH4                DMA Memory End Address Register                      -->
    <!-- 4000249C  DMA                             0  DMA_CH4                AHB Address Register                                 -->
    <!-- 400024A0  DMA                             0  DMA_CH4                DMA Control Register                                 -->
    <!-- 400024A4  DMA                             0  DMA_CH4                DMA Channel Interrupt Status                         -->
    <!-- 400024A8  DMA                             0  DMA_CH4                DMA Channel Interrupt Enable                         -->
    <!-- 400024AC  DMA                             0  DMA_CH4                DMA Test Register                                    -->
    <!-- 400024B0  DMA                             0  DMA_CH5                DMA Activate Register                                -->
    <!-- 400024B4  DMA                             0  DMA_CH5                DMA Memory Start Address Register                    -->
    <!-- 400024B8  DMA                             0  DMA_CH5                DMA Memory End Address Register                      -->
    <!-- 400024BC  DMA                             0  DMA_CH5                AHB Address Register                                 -->
    <!-- 400024C0  DMA                             0  DMA_CH5                DMA Control Register                                 -->
    <!-- 400024C4  DMA                             0  DMA_CH5                DMA Channel Interrupt Status                         -->
    <!-- 400024C8  DMA                             0  DMA_CH5                DMA Channel Interrupt Enable                         -->
    <!-- 400024CC  DMA                             0  DMA_CH5                DMA Test Register                                    -->
    <!-- 400024D0  DMA                             0  DMA_CH6                DMA Activate Register                                -->
    <!-- 400024D4  DMA                             0  DMA_CH6                DMA Memory Start Address Register                    -->
    <!-- 400024D8  DMA                             0  DMA_CH6                DMA Memory End Address Register                      -->
    <!-- 400024DC  DMA                             0  DMA_CH6                AHB Address Register                                 -->
    <!-- 400024E0  DMA                             0  DMA_CH6                DMA Control Register                                 -->
    <!-- 400024E4  DMA                             0  DMA_CH6                DMA Channel Interrupt Status                         -->
    <!-- 400024E8  DMA                             0  DMA_CH6                DMA Channel Interrupt Enable                         -->
    <!-- 400024EC  DMA                             0  DMA_CH6                DMA Test Register                                    -->
    <!-- 400024F0  DMA                             0  DMA_CH7                DMA Activate Register                                -->
    <!-- 400024F4  DMA                             0  DMA_CH7                DMA Memory Start Address Register                    -->
    <!-- 400024F8  DMA                             0  DMA_CH7                DMA Memory End Address Register                      -->
    <!-- 400024FC  DMA                             0  DMA_CH7                AHB Address Register                                 -->
    <!-- 40002500  DMA                             0  DMA_CH7                DMA Control Register                                 -->
    <!-- 40002504  DMA                             0  DMA_CH7                DMA Channel Interrupt Status                         -->
    <!-- 40002508  DMA                             0  DMA_CH7                DMA Channel Interrupt Enable                         -->
    <!-- 4000250C  DMA                             0  DMA_CH7                DMA Test Register                                    -->
    <!-- 40002510  DMA                             0  DMA_CH8                DMA Activate Register                                -->
    <!-- 40002514  DMA                             0  DMA_CH8                DMA Memory Start Address Register                    -->
    <!-- 40002518  DMA                             0  DMA_CH8                DMA Memory End Address Register                      -->
    <!-- 4000251C  DMA                             0  DMA_CH8                AHB Address Register                                 -->
    <!-- 40002520  DMA                             0  DMA_CH8                DMA Control Register                                 -->
    <!-- 40002524  DMA                             0  DMA_CH8                DMA Channel Interrupt Status                         -->
    <!-- 40002528  DMA                             0  DMA_CH8                DMA Channel Interrupt Enable                         -->
    <!-- 4000252C  DMA                             0  DMA_CH8                DMA Test Register                                    -->
    <!-- 40002530  DMA                             0  DMA_CH9                DMA Activate Register                                -->
    <!-- 40002534  DMA                             0  DMA_CH9                DMA Memory Start Address Register                    -->
    <!-- 40002538  DMA                             0  DMA_CH9                DMA Memory End Address Register                      -->
    <!-- 4000253C  DMA                             0  DMA_CH9                AHB Address Register                                 -->
    <!-- 40002540  DMA                             0  DMA_CH9                DMA Control Register                                 -->
    <!-- 40002544  DMA                             0  DMA_CH9                DMA Channel Interrupt Status                         -->
    <!-- 40002548  DMA                             0  DMA_CH9                DMA Channel Interrupt Enable                         -->
    <!-- 4000254C  DMA                             0  DMA_CH9                DMA Test Register                                    -->
    <!-- 40002550  DMA                             0  DMA_CH10               DMA Activate Register                                -->
    <!-- 40002554  DMA                             0  DMA_CH10               DMA Memory Start Address Register                    -->
    <!-- 40002558  DMA                             0  DMA_CH10               DMA Memory End Address Register                      -->
    <!-- 4000255C  DMA                             0  DMA_CH10               AHB Address Register                                 -->
    <!-- 40002560  DMA                             0  DMA_CH10               DMA Control Register                                 -->
    <!-- 40002564  DMA                             0  DMA_CH10               DMA Channel Interrupt Status                         -->
    <!-- 40002568  DMA                             0  DMA_CH10               DMA Channel Interrupt Enable                         -->
    <!-- 4000256C  DMA                             0  DMA_CH10               DMA Test Register                                    -->
    <!-- 40002570  DMA                             0  DMA_CH11               DMA Activate Register                                -->
    <!-- 40002574  DMA                             0  DMA_CH11               DMA Memory Start Address Register                    -->
    <!-- 40002578  DMA                             0  DMA_CH11               DMA Memory End Address Register                      -->
    <!-- 4000257C  DMA                             0  DMA_CH11               AHB Address Register                                 -->
    <!-- 40002580  DMA                             0  DMA_CH11               DMA Control Register                                 -->
    <!-- 40002584  DMA                             0  DMA_CH11               DMA Channel Interrupt Status                         -->
    <!-- 40002588  DMA                             0  DMA_CH11               DMA Channel Interrupt Enable                         -->
    <!-- 4000258C  DMA                             0  DMA_CH11               DMA Test Register                                    -->
    <!--  -->
      <name>DMA</name>
      <version>1.0</version>
      <description>The Internal DMA Controller transfers data to/from the source from/to the\n
       destination. The firmware is responsible for setting up each channel. Afterwards either the\n 
       firmware or the hardware may perform the flow control. The hardware flow control exists entirely\n 
       inside the source device. Each transfer may be 1, 2, or 4 bytes in size, so long as the device\n
       supports a transfer of that size. Every device must be on the internal 32-bit address space.
      </description>
      <groupName>DMA</groupName>
      <baseAddress>0x40002400</baseAddress>
      <size>32</size>
      <access>read-write</access>

      <addressBlock>
        <offset>0</offset>
        <size>0x200</size>
        <usage>registers</usage>
      </addressBlock>

      <interrupt>
        <name>DMA0</name>
        <description>DMA_CH0 Interrupt ..................... Also see GIRQ 13.16</description>
        <value>4</value>
      </interrupt>

      <interrupt>
        <name>DMA1</name>
        <description>DMA_CH1 Interrupt ..................... Also see GIRQ 13.17</description>
        <value>5</value>
      </interrupt>

      <interrupt>
        <name>DMA2</name>
        <description>DMA_CH2 Interrupt ..................... Also see GIRQ 13.18</description>
        <value>6</value>
      </interrupt>

      <interrupt>
        <name>DMA3</name>
        <description>DMA_CH3 Interrupt ..................... Also see GIRQ 13.19</description>
        <value>7</value>
      </interrupt>

      <interrupt>
        <name>DMA4</name>
        <description>DMA_CH4 Interrupt ..................... Also see GIRQ 13.20</description>
        <value>8</value>
      </interrupt>

      <interrupt>
        <name>DMA5</name>
        <description>DMA_CH5 Interrupt ..................... Also see GIRQ 13.21</description>
        <value>9</value>
      </interrupt>

      <interrupt>
        <name>DMA6</name>
        <description>DMA_CH6 Interrupt ..................... Also see GIRQ 13.22</description>
        <value>10</value>
      </interrupt>

      <interrupt>
        <name>DMA7</name>
        <description>DMA_CH7 Interrupt ..................... Also see GIRQ 13.23</description>
        <value>11</value>
      </interrupt>

      <interrupt>
        <name>DMA8</name>
        <description>DMA_CH8 Interrupt ..................... Also see GIRQ 13.24</description>
        <value>81</value>
      </interrupt>

      <interrupt>
        <name>DMA9</name>
        <description>DMA_CH9 Interrupt ..................... Also see GIRQ 13.25</description>
        <value>82</value>
      </interrupt>

      <interrupt>
        <name>DMA10</name>
        <description>DMA_CH10 Interrupt .................... Also see GIRQ 13.26</description>
        <value>83</value>
      </interrupt>

      <interrupt>
        <name>DMA11</name>
        <description>DMA_CH11 Interrupt .................... Also see GIRQ 13.27</description>
        <value>84</value>
      </interrupt>

      <registers>

        <!-- DMA MAIN CONTROL -->
        <register>
          <name>CONTROL</name>
          <description>Soft reset the entire module. Enable the blocks operation.
          </description>
          <addressOffset>0x00</addressOffset>
          <size>8</size>
          <access>read-write</access>
          <resetValue>0x00</resetValue>
          <resetMask>0xFF</resetMask>

          <fields>
            <!-- ACTIVATE -->
            <field>
              <name>ACTIVATE</name>
              <description>Enable the blocks operation. (R/WS)\n
               1=Enable block. Each individual channel must be enabled separately.\n
               0=Disable all channels.
              </description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>

            <!-- SOFT_RESET -->
            <field>
              <name>SOFT_RESET</name>
              <description>Soft reset the entire module. This bit is self-clearing.
              </description>
              <bitRange>[1:1]</bitRange>
              <access>write</access>
            </field>
          </fields>
        </register>

        <!-- DMA DATA PACKET -->
        <register>
          <name>DATA_PACKET</name>
          <description>Debug register that has the data that is stored in the Data Packet. This data is read data from the currently active transfer source.
          </description>
          <addressOffset>0x04</addressOffset>
          <size>32</size>
          <access>read</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
        </register>

        <cluster>
          <dim>12</dim>
          <dimIncrement>0x20</dimIncrement>
          <dimIndex>0-11</dimIndex>
          <name>CH[%s]</name>
          <description>Channel implemented will have these registers to determine that channel's operation.
          </description>
          <addressOffset>0x010</addressOffset>

          <!-- DMA CHANNEL N ACTIVATE -->
          <register>
            <name>ACTIVATE</name>
            <description>Enable this channel for operation. The DMA Main Control: Activate must also be enabled for this channel to be operational.
            </description>
            <addressOffset>0x00</addressOffset>
            <size>8</size>
            <access>read-write</access>
            <resetValue>0x00</resetValue>
            <resetMask>0xFF</resetMask>

            <fields>
              <!-- CHANNEL_ACTIVATE -->
              <field>
                <name>EN</name>
                <description>Enable this channel for operation.\n
                 1=Enable channel(block). Each individual channel must be enabled separately.\n
                 0=Disable channel(block).
                </description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>

          </register>

          <!-- DMA Channel N Memory Start Address -->
          <register>
            <name>MEM_START_ADDR</name>
            <description>This is the starting address for the Memory device.
            </description>
            <addressOffset>0x04</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
          </register>

          <!-- DMA Channel N Memory End Address -->
          <register>
            <name>MEM_END_ADDR</name>
            <description>This is the ending address for the Memory device.
            </description>
            <addressOffset>0x08</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
          </register>

          <!-- DMA Channel N Device Address -->
          <register>
            <name>DEVICE_ADDR</name>
            <description>This is the Master Device address.
            </description>
            <addressOffset>0x0C</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
          </register>

          <!-- DMA Channel N Control -->
          <register>
            <name>CONTROL</name>
            <description>DMA Channel N Control
            </description>
            <addressOffset>0x10</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>

            <fields>
              <!-- RUN -->
              <field>
                <name>RUN</name>
                <description>This is a control field. Note: This bit only applies to Hardware Flow Control mode.\n
                 1= This channel is enabled and will service transfer requests\n
                 0=This channel is disabled. All transfer requests are ignored.
                </description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>

              <!-- REQUEST -->
              <field>
                <name>REQUEST</name>
                <description>This is a status field.\n
                 1= There is a transfer request from the Master Device\n
                 0= There is no transfer request from the Master Device
                </description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>

              <!-- DONE -->
              <field>
                <name>DONE</name>
                <description>This is a status signal. It is only valid while DMA Channel Control: Run is Enabled. \n
                 This is the inverse of the DMA Channel Control: Busy field, except this is qualified with the DMA Channel Control:Run field.\n
                 1=Channel is done\n
                 0=Channel is not done or it is OFF
                </description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>

              <!-- STATUS -->
              <field>
                <name>STATUS</name>
                <description>This is a status signal. The status decode is listed in priority order with the highest priority first.\n
                 3: Error detected by the DMA\n
                 2: The DMA Channel is externally done, in that the Device has terminated the transfer over the Hardware Flow Control through the Port dma_term\n
                 1: The DMA Channel is locally done, in that Memory Start Address equals Memory End Address\n
                 0: DMA Channel Control:Run is Disabled (0x0)
                </description>
                <bitRange>[4:3]</bitRange>
                <access>read-write</access>
              </field>

              <!-- BUSY -->
              <field>
                <name>BUSY</name>
                <description>This is a status signal.\n
                 1=The DMA Channel is busy (FSM is not IDLE)\n
                 0=The DMA Channel is not busy (FSM is IDLE)
                </description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>

              <!-- TRANSFER_DIRECTION -->
              <field>
                <name>TX_DIRECTION</name>
                <description>This determines the direction of the DMA Transfer.\n
                 1=Data Packet Read from Memory Start Address followed by Data Packet Write to Device Address\n
                 0=Data Packet Read from Device Address followed by Data Packet Write to Memory Start Address
                </description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>

              <!-- HARDWARE_FLOW_CONTROL_DEVICE -->
              <field>
                <name>HARDWARE_FLOW_CONTROL_DEVICE</name>
                <description>This is the device that is connected to this channel as its Hardware Flow Control master.\n
                 The Flow Control Interface is a bus with each master concatenated onto it.\n
                 This selects which bus index of the concatenated Flow Control Interface bus is targeted towards this channel.\n
                 The Flow Control Interface Port list is dma_req, dma_term, and dma_done.
                </description>
                <bitRange>[15:9]</bitRange>
                <access>read-write</access>
              </field>

              <!-- INCREMENT_MEMORY_ADDRESS -->
              <field>
                <name>INCREMENT_MEM_ADDR</name>
                <description>This will enable an auto-increment to the DMA Channel Memory Address.\n
                 1=Increment the DMA Channel Memory Address by DMA Channel Control:Transfer Size after every Data Packet transfer\n
                 0=Do nothing
                </description>
                <bitRange>[16:16]</bitRange>
                <access>read-write</access>
              </field>

              <!-- INCREMENT_DEVICE_ADDRESS -->
              <field>
                <name>INCREMENT_DEVICE_ADDR</name>
                <description>This will enable an auto-increment to the DMA Channel Device Address.\n
                 1: Increment the DMA Channel Device Address by DMA Channel Control:Transfer Size after every Data Packet transfer\n
                 0: Do nothing
                </description>
                <bitRange>[17:17]</bitRange>
                <access>read-write</access>
              </field>

              <!-- LOCK_CHANNEL -->
              <field>
                <name>LOCK</name>
                <description>This is used to lock the arbitration of the Channel Arbiter on this channel once this channel is granted. Once this is locked, it will remain on the arbiter until it has completed it transfer (either the Transfer Aborted, Transfer Done or Transfer Terminated conditions).
                </description>
                <bitRange>[18:18]</bitRange>
                <access>read-write</access>
              </field>

              <!-- DISABLE_HARDWARE_FLOW_CONTROL -->
              <field>
                <name>DISABLE_HW_FLOW_CONTROL</name>
                <description>This will Disable the Hardware Flow Control. When disabled, any DMA Master device attempting to communicate to the DMA over the DMA Flow Control Interface (Ports: dma_req, dma_term, and dma_done) will be ignored. This should be set before using the DMA channel in Firmware Flow Control mode.
                </description>
                <bitRange>[19:19]</bitRange>
                <access>read-write</access>
              </field>

              <!-- TRANSFER_SIZE -->
              <field>
                <name>TRANSFER_SIZE</name>
                <description>This is the transfer size in Bytes of each Data Packet transfer.\n
                 Note: The transfer size must be a legal AMBA transfer size. Valid sizes are 1, 2 and 4 Bytes.
                </description>
                <bitRange>[22:20]</bitRange>
                <access>read-write</access>
              </field>

              <!-- TRANSFER_GO -->
              <field>
                <name>TRANSFER_GO</name>
                <description>This is used for the Firmware Flow Control DMA transfer.
                </description>
                <bitRange>[24:24]</bitRange>
                <access>read-write</access>
              </field>

              <!-- TRANSFER_ABORT -->
              <field>
                <name>TRANSFER_ABORT</name>
                <description>This is used to abort the current transfer on this DMA Channel. The aborted transfer will be forced to terminate immediately.
                </description>
                <bitRange>[25:25]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>

          <!-- DMA Channel N Interrupt Status -->
          <register>
            <name>INT_STATUS</name>
            <description>DMA Channel N Interrupt Status
            </description>
            <addressOffset>0x14</addressOffset>
            <size>8</size>
            <access>read-write</access>
            <resetValue>0x00</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <!-- STATUS_AMBA_BUS_ERROR -->
              <field>
                <name>BUS_ERROR</name>
                <description>This is an interrupt source register. This flags when there is an Error detected over the internal 32-bit AMBA Bus.\n
                 1: AMBA Error detected. (R/WC)
                </description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>

              <!-- STATUS_FLOW_CONTROL -->
              <field>
                <name>FLOW_CONTROL</name>
                <description>This is an interrupt source register. This flags when the DMA Channel has encountered a Hardware Flow Control Request after the DMA Channel has completed the transfer. This means the Master Device is attempting to overflow the DMA.\n
                 1=Hardware Flow Control is requesting after the transfer has completed\n
                 0=No Hardware Flow Control event
                </description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>

              <!-- STATUS_DONE -->
              <field>
                <name>DONE</name>
                <description>This is an interrupt source register. This flags when the DMA Channel has completed a transfer successfully on its side. A completed transfer is defined as when the DMA Channel reaches its limit; Memory Start Address equals Memory End Address. A completion due to a Hardware Flow Control Terminate will not flag this interrupt.\n
                 1=Memory Start Address equals Memory End Address\n
                 0=Memory Start Address does not equal Memory End Address
                </description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>

          <!-- DMA Channel N Interrupt Enable -->
          <register>
            <name>INT_EN</name>
            <description>DMA CHANNEL N INTERRUPT ENABLE
            </description>
            <addressOffset>0x18</addressOffset>
            <size>8</size>
            <access>read-write</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>

            <fields>
              <!-- STATUS_ENABLE_AMBA_BUS_ERROR -->
              <field>
                <name>BUS_ERROR</name>
                <description>This is an interrupt enable for DMA Channel Interrupt:Status AMBA Bus Error.\n
                 1=Enable Interrupt\n
                 0=Disable Interrupt
                </description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>

              <!-- STATUS_ENABLE_FLOW_CONTROL -->
              <field>
                <name>FLOW_CONTROL</name>
                <description>This is an interrupt enable for DMA Channel Interrupt:Status Flow Control Error.\n
                 1=Enable Interrupt\n
                 0=Disable Interrupt
                </description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>

              <!-- STATUS_ENABLE_DONE -->
              <field>
                <name>DONE</name>
                <description>This is an interrupt enable for DMA Channel Interrupt:Status Done.\n
                 1=Enable Interrupt\n
                 0=Disable Interrupt
                </description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
      </registers>
    </peripheral>
    <!--  -->

    <peripheral>
    <!-- < Chapter 22.0>  SMBus Interface -->
    <!-- 40001800  SMB Device Interface            0  SMB_EC_Only            Status Register                                      -->
    <!-- 40001800  SMB Device Interface            0  SMB_EC_Only            Control Register                                     -->
    <!-- 40001801  SMB Device Interface            0  SMB_EC_Only            Reserved                            (*MCHP Reserved) -->
    <!-- 40001804  SMB Device Interface            0  SMB_EC_Only            Own Address Register                                 -->
    <!-- 40001806  SMB Device Interface            0  SMB_EC_Only            Reserved                            (*MCHP Reserved) -->
    <!-- 40001808  SMB Device Interface            0  SMB_EC_Only            Data                                                 -->
    <!-- 40001809  SMB Device Interface            0  SMB_EC_Only            Reserved                            (*MCHP Reserved) -->
    <!-- 4000180C  SMB Device Interface            0  SMB_EC_Only            SMBus Master Command Register                        -->
    <!-- 40001810  SMB Device Interface            0  SMB_EC_Only            SMBus Slave Command Register                         -->
    <!-- 40001814  SMB Device Interface            0  SMB_EC_Only            PEC Register                                         -->
    <!-- 40001815  SMB Device Interface            0  SMB_EC_Only            Reserved                            (*MCHP Reserved) -->
    <!-- 40001818  SMB Device Interface            0  SMB_EC_Only            DATA_TIMING2                                         -->
    <!-- 40001819  SMB Device Interface            0  SMB_EC_Only            Reserved                            (*MCHP Reserved) -->
    <!-- 40001820  SMB Device Interface            0  SMB_EC_Only            Completion Register                                  -->
    <!-- 40001824  SMB Device Interface            0  SMB_EC_Only            Idle Scaling Register                                -->
    <!-- 40001828  SMB Device Interface            0  SMB_EC_Only            Configuration Register                               -->
    <!-- 4000182C  SMB Device Interface            0  SMB_EC_Only            Bus Clock Register                                   -->
    <!-- 4000182E  SMB Device Interface            0  SMB_EC_Only            Reserved                                             -->
    <!-- 40001830  SMB Device Interface            0  SMB_EC_Only            Block ID Register                                    -->
    <!-- 40001831  SMB Device Interface            0  SMB_EC_Only            Reserved                            (*MCHP Reserved) -->
    <!-- 40001834  SMB Device Interface            0  SMB_EC_Only            Revision Register                                    -->
    <!-- 40001835  SMB Device Interface            0  SMB_EC_Only            Reserved                            (*MCHP Reserved) -->
    <!-- 40001838  SMB Device Interface            0  SMB_EC_Only            Bit-Bang Control Register                            -->
    <!-- 40001839  SMB Device Interface            0  SMB_EC_Only            Reserved                            (*MCHP Reserved) -->
    <!-- 4000183C  SMB Device Interface            0  SMB_EC_Only            Clock Sync                          (*MCHP Reserved) -->
    <!-- 40001840  SMB Device Interface            0  SMB_EC_Only            Data Timing Register                                 -->
    <!-- 40001844  SMB Device Interface            0  SMB_EC_Only            Time-Out Scaling Register                            -->
    <!-- 40001848  SMB Device Interface            0  SMB_EC_Only            SMBus Slave Transmit Buffer Register                 -->
    <!-- 40001849  SMB Device Interface            0  SMB_EC_Only            Reserved                            (*MCHP Reserved) -->
    <!-- 4000184C  SMB Device Interface            0  SMB_EC_Only            SMBus Slave Receive Buffer Register                  -->
    <!-- 4000184D  SMB Device Interface            0  SMB_EC_Only            Reserved                            (*MCHP Reserved) -->
    <!-- 40001850  SMB Device Interface            0  SMB_EC_Only            SMBus Master Transmit Bufer Register                 -->
    <!-- 40001851  SMB Device Interface            0  SMB_EC_Only            Reserved                            (*MCHP Reserved) -->
    <!-- 40001854  SMB Device Interface            0  SMB_EC_Only            SMBus Master Receive Buffer Register                 -->
    <!-- 40001855  SMB Device Interface            0  SMB_EC_Only            Reserved                            (*MCHP Reserved) -->
    <!-- 40001858  SMB Device Interface            0  SMB_EC_Only            DEBUG_FSM_I2C                       (*MCHP Reserved) -->
    <!-- 4000185C  SMB Device Interface            0  SMB_EC_Only            DEBUG_FSM_SMB                       (*MCHP Reserved) -->
    <!-- 4000AC00  SMB Device Interface            1  SMB_EC_Only            Control Register                                     -->
    <!-- 4000AC00  SMB Device Interface            1  SMB_EC_Only            Status Register                                      -->
    <!-- 4000AC01  SMB Device Interface            1  SMB_EC_Only            Reserved                            (*MCHP Reserved) -->
    <!-- 4000AC04  SMB Device Interface            1  SMB_EC_Only            Own Address Register                                 -->
    <!-- 4000AC06  SMB Device Interface            1  SMB_EC_Only            Reserved                            (*MCHP Reserved) -->
    <!-- 4000AC08  SMB Device Interface            1  SMB_EC_Only            Data                                                 -->
    <!-- 4000AC09  SMB Device Interface            1  SMB_EC_Only            Reserved                            (*MCHP Reserved) -->
    <!-- 4000AC0C  SMB Device Interface            1  SMB_EC_Only            SMBus Master Command Register                        -->
    <!-- 4000AC10  SMB Device Interface            1  SMB_EC_Only            SMBus Slave Command Register                         -->
    <!-- 4000AC14  SMB Device Interface            1  SMB_EC_Only            PEC Register                                         -->
    <!-- 4000AC15  SMB Device Interface            1  SMB_EC_Only            Reserved                            (*MCHP Reserved) -->
    <!-- 4000AC18  SMB Device Interface            1  SMB_EC_Only            DATA_TIMING2                                         -->
    <!-- 4000AC19  SMB Device Interface            1  SMB_EC_Only            Reserved                            (*MCHP Reserved) -->
    <!-- 4000AC20  SMB Device Interface            1  SMB_EC_Only            Completion Register                                  -->
    <!-- 4000AC24  SMB Device Interface            1  SMB_EC_Only            Idle Scaling Register                                -->
    <!-- 4000AC28  SMB Device Interface            1  SMB_EC_Only            Configuration Register                               -->
    <!-- 4000AC2C  SMB Device Interface            1  SMB_EC_Only            Bus Clock Register                                   -->
    <!-- 4000AC2E  SMB Device Interface            1  SMB_EC_Only            Reserved                                             -->
    <!-- 4000AC30  SMB Device Interface            1  SMB_EC_Only            Block ID Register                                    -->
    <!-- 4000AC31  SMB Device Interface            1  SMB_EC_Only            Reserved                            (*MCHP Reserved) -->
    <!-- 4000AC34  SMB Device Interface            1  SMB_EC_Only            Revision Register                                    -->
    <!-- 4000AC35  SMB Device Interface            1  SMB_EC_Only            Reserved                            (*MCHP Reserved) -->
    <!-- 4000AC38  SMB Device Interface            1  SMB_EC_Only            Bit-Bang Control Register                            -->
    <!-- 4000AC39  SMB Device Interface            1  SMB_EC_Only            Reserved                            (*MCHP Reserved) -->
    <!-- 4000AC3C  SMB Device Interface            1  SMB_EC_Only            Clock Sync                          (*MCHP Reserved) -->
    <!-- 4000AC40  SMB Device Interface            1  SMB_EC_Only            Data Timing Register                                 -->
    <!-- 4000AC44  SMB Device Interface            1  SMB_EC_Only            Time-Out Scaling Register                            -->
    <!-- 4000AC48  SMB Device Interface            1  SMB_EC_Only            SMBus Slave Transmit Buffer Register                 -->
    <!-- 4000AC49  SMB Device Interface            1  SMB_EC_Only            Reserved                            (*MCHP Reserved) -->
    <!-- 4000AC4C  SMB Device Interface            1  SMB_EC_Only            SMBus Slave Receive Buffer Register                  -->
    <!-- 4000AC4D  SMB Device Interface            1  SMB_EC_Only            Reserved                            (*MCHP Reserved) -->
    <!-- 4000AC50  SMB Device Interface            1  SMB_EC_Only            SMBus Master Transmit Bufer Register                 -->
    <!-- 4000AC51  SMB Device Interface            1  SMB_EC_Only            Reserved                            (*MCHP Reserved) -->
    <!-- 4000AC54  SMB Device Interface            1  SMB_EC_Only            SMBus Master Receive Buffer Register                 -->
    <!-- 4000AC55  SMB Device Interface            1  SMB_EC_Only            Reserved                            (*MCHP Reserved) -->
    <!-- 4000AC58  SMB Device Interface            1  SMB_EC_Only            DEBUG_FSM_I2C                       (*MCHP Reserved) -->
    <!-- 4000AC5C  SMB Device Interface            1  SMB_EC_Only            DEBUG_FSM_SMB                       (*MCHP Reserved) -->
    <!-- 4000B000  SMB Device Interface            2  SMB_EC_Only            Control Register                                     -->
    <!-- 4000B000  SMB Device Interface            2  SMB_EC_Only            Status Register                                      -->
    <!-- 4000B001  SMB Device Interface            2  SMB_EC_Only            Reserved                            (*MCHP Reserved) -->
    <!-- 4000B004  SMB Device Interface            2  SMB_EC_Only            Own Address Register                                 -->
    <!-- 4000B006  SMB Device Interface            2  SMB_EC_Only            Reserved                            (*MCHP Reserved) -->
    <!-- 4000B008  SMB Device Interface            2  SMB_EC_Only            Data                                                 -->
    <!-- 4000B009  SMB Device Interface            2  SMB_EC_Only            Reserved                            (*MCHP Reserved) -->
    <!-- 4000B00C  SMB Device Interface            2  SMB_EC_Only            SMBus Master Command Register                        -->
    <!-- 4000B010  SMB Device Interface            2  SMB_EC_Only            SMBus Slave Command Register                         -->
    <!-- 4000B014  SMB Device Interface            2  SMB_EC_Only            PEC Register                                         -->
    <!-- 4000B015  SMB Device Interface            2  SMB_EC_Only            Reserved                            (*MCHP Reserved) -->
    <!-- 4000B018  SMB Device Interface            2  SMB_EC_Only            DATA_TIMING2                                         -->
    <!-- 4000B019  SMB Device Interface            2  SMB_EC_Only            Reserved                            (*MCHP Reserved) -->
    <!-- 4000B020  SMB Device Interface            2  SMB_EC_Only            Completion Register                                  -->
    <!-- 4000B024  SMB Device Interface            2  SMB_EC_Only            Idle Scaling Register                                -->
    <!-- 4000B028  SMB Device Interface            2  SMB_EC_Only            Configuration Register                               -->
    <!-- 4000B02C  SMB Device Interface            2  SMB_EC_Only            Bus Clock Register                                   -->
    <!-- 4000B02E  SMB Device Interface            2  SMB_EC_Only            Reserved                                             -->
    <!-- 4000B030  SMB Device Interface            2  SMB_EC_Only            Block ID Register                                    -->
    <!-- 4000B031  SMB Device Interface            2  SMB_EC_Only            Reserved                            (*MCHP Reserved) -->
    <!-- 4000B034  SMB Device Interface            2  SMB_EC_Only            Revision Register                                    -->
    <!-- 4000B035  SMB Device Interface            2  SMB_EC_Only            Reserved                            (*MCHP Reserved) -->
    <!-- 4000B038  SMB Device Interface            2  SMB_EC_Only            Bit-Bang Control Register                            -->
    <!-- 4000B039  SMB Device Interface            2  SMB_EC_Only            Reserved                            (*MCHP Reserved) -->
    <!-- 4000B03C  SMB Device Interface            2  SMB_EC_Only            Clock Sync                          (*MCHP Reserved) -->
    <!-- 4000B040  SMB Device Interface            2  SMB_EC_Only            Data Timing Register                                 -->
    <!-- 4000B044  SMB Device Interface            2  SMB_EC_Only            Time-Out Scaling Register                            -->
    <!-- 4000B048  SMB Device Interface            2  SMB_EC_Only            SMBus Slave Transmit Buffer Register                 -->
    <!-- 4000B049  SMB Device Interface            2  SMB_EC_Only            Reserved                            (*MCHP Reserved) -->
    <!-- 4000B04C  SMB Device Interface            2  SMB_EC_Only            SMBus Slave Receive Buffer Register                  -->
    <!-- 4000B04D  SMB Device Interface            2  SMB_EC_Only            Reserved                            (*MCHP Reserved) -->
    <!-- 4000B050  SMB Device Interface            2  SMB_EC_Only            SMBus Master Transmit Bufer Register                 -->
    <!-- 4000B051  SMB Device Interface            2  SMB_EC_Only            Reserved                            (*MCHP Reserved) -->
    <!-- 4000B054  SMB Device Interface            2  SMB_EC_Only            SMBus Master Receive Buffer Register                 -->
    <!-- 4000B055  SMB Device Interface            2  SMB_EC_Only            Reserved                            (*MCHP Reserved) -->
    <!-- 4000B058  SMB Device Interface            2  SMB_EC_Only            DEBUG_FSM_I2C                       (*MCHP Reserved) -->
    <!-- 4000B05C  SMB Device Interface            2  SMB_EC_Only            DEBUG_FSM_SMB                       (*MCHP Reserved) -->
    <!-- 4000B400  SMB Device Interface            3  SMB_EC_Only            Control Register                                     -->
    <!-- 4000B400  SMB Device Interface            3  SMB_EC_Only            Status Register                                      -->
    <!-- 4000B401  SMB Device Interface            3  SMB_EC_Only            Reserved                            (*MCHP Reserved) -->
    <!-- 4000B404  SMB Device Interface            3  SMB_EC_Only            Own Address Register                                 -->
    <!-- 4000B406  SMB Device Interface            3  SMB_EC_Only            Reserved                            (*MCHP Reserved) -->
    <!-- 4000B408  SMB Device Interface            3  SMB_EC_Only            Data                                                 -->
    <!-- 4000B409  SMB Device Interface            3  SMB_EC_Only            Reserved                            (*MCHP Reserved) -->
    <!-- 4000B40C  SMB Device Interface            3  SMB_EC_Only            SMBus Master Command Register                        -->
    <!-- 4000B410  SMB Device Interface            3  SMB_EC_Only            SMBus Slave Command Register                         -->
    <!-- 4000B414  SMB Device Interface            3  SMB_EC_Only            PEC Register                                         -->
    <!-- 4000B415  SMB Device Interface            3  SMB_EC_Only            Reserved                            (*MCHP Reserved) -->
    <!-- 4000B418  SMB Device Interface            3  SMB_EC_Only            DATA_TIMING2                                         -->
    <!-- 4000B419  SMB Device Interface            3  SMB_EC_Only            Reserved                            (*MCHP Reserved) -->
    <!-- 4000B420  SMB Device Interface            3  SMB_EC_Only            Completion Register                                  -->
    <!-- 4000B424  SMB Device Interface            3  SMB_EC_Only            Idle Scaling Register                                -->
    <!-- 4000B428  SMB Device Interface            3  SMB_EC_Only            Configuration Register                               -->
    <!-- 4000B42C  SMB Device Interface            3  SMB_EC_Only            Bus Clock Register                                   -->
    <!-- 4000B42E  SMB Device Interface            3  SMB_EC_Only            Reserved                                             -->
    <!-- 4000B430  SMB Device Interface            3  SMB_EC_Only            Block ID Register                                    -->
    <!-- 4000B431  SMB Device Interface            3  SMB_EC_Only            Reserved                            (*MCHP Reserved) -->
    <!-- 4000B434  SMB Device Interface            3  SMB_EC_Only            Revision Register                                    -->
    <!-- 4000B435  SMB Device Interface            3  SMB_EC_Only            Reserved                            (*MCHP Reserved) -->
    <!-- 4000B438  SMB Device Interface            3  SMB_EC_Only            Bit-Bang Control Register                            -->
    <!-- 4000B439  SMB Device Interface            3  SMB_EC_Only            Reserved                            (*MCHP Reserved) -->
    <!-- 4000B43C  SMB Device Interface            3  SMB_EC_Only            Clock Sync                          (*MCHP Reserved) -->
    <!-- 4000B440  SMB Device Interface            3  SMB_EC_Only            Data Timing Register                                 -->
    <!-- 4000B444  SMB Device Interface            3  SMB_EC_Only            Time-Out Scaling Register                            -->
    <!-- 4000B448  SMB Device Interface            3  SMB_EC_Only            SMBus Slave Transmit Buffer Register                 -->
    <!-- 4000B449  SMB Device Interface            3  SMB_EC_Only            Reserved                            (*MCHP Reserved) -->
    <!-- 4000B44C  SMB Device Interface            3  SMB_EC_Only            SMBus Slave Receive Buffer Register                  -->
    <!-- 4000B44D  SMB Device Interface            3  SMB_EC_Only            Reserved                            (*MCHP Reserved) -->
    <!-- 4000B450  SMB Device Interface            3  SMB_EC_Only            SMBus Master Transmit Bufer Register                 -->
    <!-- 4000B451  SMB Device Interface            3  SMB_EC_Only            Reserved                            (*MCHP Reserved) -->
    <!-- 4000B454  SMB Device Interface            3  SMB_EC_Only            SMBus Master Receive Buffer Register                 -->
    <!-- 4000B455  SMB Device Interface            3  SMB_EC_Only            Reserved                            (*MCHP Reserved) -->
    <!-- 4000B458  SMB Device Interface            3  SMB_EC_Only            DEBUG_FSM_I2C                       (*MCHP Reserved) -->
    <!-- 4000B45C  SMB Device Interface            3  SMB_EC_Only            DEBUG_FSM_SMB                       (*MCHP Reserved) -->
    <!--  -->
      <name>SMB0</name>
      <version>1.0</version>
      <description>The SMBus interface can handle standard SMBus 2.0 protocols as well as I2C\n
       interface.
      </description>
      <groupName>SMB</groupName>
      <baseAddress>0x40001800</baseAddress>
      <size>32</size>
      <access>read-write</access>

      <addressBlock>
        <offset>0</offset>
        <size>0x060</size>
        <usage>registers</usage>
      </addressBlock>

      <interrupt>
        <name>I2C0</name>
        <description>I2C0 / SMB0 Interrupt ................. Also see GIRQ 12.0</description>
        <value>0</value>
      </interrupt>

      <interrupt>
        <name>I2C1</name>
        <description>I2C1 / SMB1 Interrupt ................. Also see GIRQ 12.1</description>
        <value>1</value>
      </interrupt>

      <interrupt>
        <name>I2C2</name>
        <description>I2C2 / SMB2 Interrupt ................. Also see GIRQ 12.2</description>
        <value>2</value>
      </interrupt>

      <interrupt>
        <name>I2C3</name>
        <description>I2C3 / SMB3 Interrupt ................. Also see GIRQ 12.3</description>
        <value>3</value>
      </interrupt>

      <registers>
        <!-- Control Register -->
        <register>
          <name>CONTROL</name>
          <description>Control Register
          </description>
          <addressOffset>0x00</addressOffset>
          <size>8</size>
          <access>write</access>
          <resetValue>0x00</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <!-- ACK -->
            <field>
              <name>ACK</name>
              <description>The Acknowledge bit (ACK) must normally be asserted ('1'). This causes the controller to send an acknowledge automatically after each byte (this occurs during the 9th clock pulse). The ACK bit must not be asserted ('0') when the controller is operating in master/receiver mode and requires no further data to be sent from the slave transmitter. This causes a negative acknowledge on the I2C bus, which halts further transmission from the slave device. 
              </description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>

            <!-- STO -->
            <field>
              <name>STO</name>
              <description>See STA description
              </description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>

            <!-- STA -->
            <field>
              <name>STA</name>
              <description>The STA and STO bits control the generation of the I2C Start condition and the transmission of the Slave Address and R/nW bit (from the Data Register), generation of repeated Start condition, and generation of the Stop condition 
              </description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>

            <!-- ENI -->
            <field>
              <name>ENI</name>
              <description>Enable Interrupt bit (ENI) controls the Interrupt Interface
              </description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>

            <!-- ESO -->
            <field>
              <name>ESO</name>
              <description>The Enable Serial Output bit (ESO) enables and disables the SMB Controller Core serial data output (SDAT)
              </description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>

            <!-- PIN -->
            <field>
              <name>PIN</name>
              <description>The Pending Interrupt Not (PIN) bit serves as a software reset function. Writing the PIN bit to a logic '1' de-asserts all status bits except for the nBB bit which is not affected by the PIN bit. The PIN bit is a self-clearing bit. Writing this bit to a logic '0' has no effect. 
              </description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>

        <!-- Status Register -->
        <register>
          <name>STATUS</name>
          <description>Status Register
          </description>
          <addressOffset>0x00</addressOffset>
          <size>8</size>
          <access>read</access>
          <resetValue>0x00</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <!-- nBB -->
            <field>
              <name>nBB</name>
              <description>The Bus Busy bit (nBB) is a read-only flag indicating when the bus is in use. A zero indicates that the bus is busy and access is not possible.
              </description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>

            <!-- LAB -->
            <field>
              <name>LAB</name>
              <description>The Lost Arbitration Bit (LAB) is set when, in multi-master operation, arbitration is lost to another master on the bus
              </description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>

            <!-- AAS -->
            <field>
              <name>AAS</name>
              <description>The Addressed As Slave bit (AAS) is valid only when PIN is asserted ('0'). When acting as slave, AAS is set when an incoming address over the bus matches the value in the Own Address Register or if the 'general call' address (00h) has been received 
              </description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>

            <!-- LRB/AD0 -->
            <field>
              <name>LRB_AD0</name>
              <description>The "Last Received Bit"  or "Address 0" (general call) bit (LRB/AD0) serves a dual function and is valid only while the PIN bit is asserted ('0').\n
               When the AAS bit is not asserted ('0') (i.e., not addressed as a slave), the LRB/AD0 holds the value of the last received bit over the bus.\n
               When the AAS bit is asserted ('1') (i.e., addressed as slave), the SMB Controller Core has been addressed as a slave.
              </description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
            </field>

            <!-- BER -->
            <field>
              <name>BER</name>
              <description>When Bus Error (BER) is asserted, a misplaced START or STOP condition or Bus Time-Outs have been detected.
              </description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
            </field>

            <!-- STS -->
            <field>
              <name>STS</name>
              <description>When in slave receiver mode, STS is asserted ('1') when an externally generated STOP condition is detected. Note that STS is used only in slave receiver mode.
              </description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
            </field>

            <!-- SAD -->
            <field>
              <name>SAD</name>
              <description>SMBus Address Decoded (SAD)
              </description>
              <bitRange>[6:6]</bitRange>
              <access>read-only</access>
            </field>

            <!-- PIN -->
            <field>
              <name>PIN</name>
              <description>Pending Interrupt bit
              </description>
              <bitRange>[7:7]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>

        <!-- Own Address Register -->
        <register>
          <name>OWN</name>
          <description>Own Address Register\n
          Note that the Data Register and Own Address fields are offset by one bit, so that programming Own Address 1 with a value of 55h will result in the value AAh being recognized as the SMB Controller Core slave address.
          </description>
          <addressOffset>0x04</addressOffset>
          <size>16</size>
          <access>read-write</access>
          <resetValue>0x0000</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <!-- Own Address 1 -->
            <field>
              <name>ADDRESS_1</name>
              <description>The Own Address 1 bits configure one of the two addresses to which the SMB Controller Core will respond when addressed as a slave.
              </description>
              <bitRange>[6:0]</bitRange>
              <access>read-write</access>
            </field>

            <!-- Own Address 2 -->
            <field>
              <name>ADDRESS_2</name>
              <description>The Own Address 2 bits configure one of the two addresses to which the SMB Controller Core will respond when addressed as a slave.
              </description>
              <bitRange>[14:8]</bitRange>
              <access>read-write</access>
            </field>

          </fields>
        </register>

        <!-- Data -->
        <register>
          <name>DATA</name>
          <description>Data
          </description>
          <addressOffset>0x08</addressOffset>
          <size>8</size>
          <access>read-write</access>
          <resetValue>0x00</resetValue>
          <resetMask>0xFF</resetMask>
        </register>

        <!-- SMBus Master Command Register -->
        <register>
          <name>MASTER_COMMAND</name>
          <description>SMBus Master Command Register
          </description>
          <addressOffset>0x0C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <!-- MRun -->
            <field>
              <name>MRUN</name>
              <description>While this bit is 1, transfer bytes over SMBus. As long as WriteCount is non-zero, a byte from the Master Transmit Buffer is transmitted to the slave device and WriteCount is decremented.
              </description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>

            <!-- MProceed -->
            <field>
              <name>MPROCEED</name>
              <description>When this bit is 0, the Master State Machine does not transition out of the IDLE or PAUSE states. When this bit is 1, the Master State Machine immediately transitions to the WAIT-BUSBUSY and MRUN-RECEIVE states, respectively.
              </description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>

            <!-- Start0 -->
            <field>
              <name>START0</name>
              <description>If this bit is 1, send a Start bit on the SMBus before the first byte of the WriteCount is sent to the SMBus transmitter.
              </description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>

            <!-- StartN -->
            <field>
              <name>STARTN</name>
              <description>If this bit is 1, send a Start bit just before the last byte of the WriteCount is sent to the SMBus transmitter.
              </description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>

            <!-- Stop -->
            <field>
              <name>STOP</name>
              <description>If this bit is 1, send a Stop bit after the transaction completes.
              </description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>

            <!-- PEC_Term -->
            <field>
              <name>PEC_TERM</name>
              <description>If this bit is 1, a copy of the PEC register is transmitted when WriteCount is 0. After the PEC register is read, both the PEC register and this bit are cleared to 0.
              </description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>

            <!-- ReadM -->
            <field>
              <name>READM</name>
              <description>If this bit is 1, then the ReadCount field is replaced by the byte that is read from the SMBus when ReadCount[7:0] is 1. After ReadCount[7:0] is updated, this bit is cleared to 0.
              </description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>

            <!-- Read_PEC -->
            <field>
              <name>READ_PEC</name>
              <description>If this bit is 0, reading from the SMBus stops when ReadCount reaches 0. If this bit is 1, reading continues when ReadCount is 0 for one more byte.
              </description>
              <bitRange>[13:13]</bitRange>
              <access>read-write</access>
            </field>

            <!-- WriteCount[7:0] -->
            <field>
              <name>WRITECOUNT</name>
              <description>This field is a count of the number of bytes to transmit to the SMBus from the SMBus Master Transmit Buffer Register It is decremented by 1 for each byte written to the SMBus from the SMBus Master Transmit Buffer Register.
              </description>
              <bitRange>[23:16]</bitRange>
              <access>read-write</access>
            </field>

            <!-- ReadCount[7:0] -->
            <field>
              <name>READCOUNT</name>
              <description>This field is a count of the number of bytes to read in from the SMBus to the SMBus Master Receive Buffer Register and must be greater than 0 in order for the Master State Machine to initiate a read phase. It is decremented by 1 for each byte read from the SMBus into the SMBus Master Receive Buffer Register. It can be overwritten by the first byte read in from the SMBus.
              </description>
              <bitRange>[31:24]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>

        <!-- SMBus Slave Command Register -->
        <register>
          <name>SLAVE_COMMAND</name>
          <description>SMBus Slave Command Register
          </description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>

          <fields>
            <!-- SRUN -->
            <field>
              <name>SRUN</name>
              <description>Setting this bit to 1 enables the Slave State Machine to operate.
              </description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>

            <!-- SProceed -->
            <field>
              <name>SPROCEED</name>
              <description>When this bit is 0, the Slave State Machine does not transition out of the IDLE, REPEAT_START_WRITE or REPEAT_START_READ states. When this bit is 1, the Slave State Machine immediately transitions to the START_WAIT, RECEIVE and TRANSMIT states, respectively. 
              </description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>

            <!-- Slave_PEC -->
            <field>
              <name>SLAVE_PEC</name>
              <description>If Slave_WriteCount is 0 and Slave_PEC is 1 when the Master requests data, the PEC Register is copied to the DATA register. After the PEC Register is copied to the SMBus, the PEC Register is cleared and Slave_PEC is set to 0.
              </description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>

            <!-- Slave_WriteCount -->
            <field>
              <name>SLAVE_WRITECOUNT</name>
              <description>This field is set to the number of bytes software expects to send to the Master.
              </description>
              <bitRange>[15:8]</bitRange>
              <access>read-write</access>
            </field>

            <!-- Slave_ReadCount -->
            <field>
              <name>SLAVE_READCOUNT</name>
              <description>This field is decremented each time a byte is copied from DATA to the SMBus Slave Receive Buffer Register.
              </description>
              <bitRange>[23:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>

        <!-- PEC Register -->
        <register>
          <name>PEC</name>
          <description>PEC byte
          </description>
          <addressOffset>0x14</addressOffset>
          <size>8</size>
          <access>read-write</access>
          <resetValue>0x00</resetValue>
          <resetMask>0xFF</resetMask>
        </register>

        <!-- DATA_TIMING2 -->
        <register>
          <name>DATA_TIMING2</name>
          <description>HOLD TIME START BIT  This is the value of the timing requirement tHd:Sta in the I2C specification. This is used to hold the clock until the Hold Time for the Start Bit has been satisfied
          </description>
          <addressOffset>0x18</addressOffset>
          <size>8</size>
          <access>read-write</access>
          <resetValue>0x00</resetValue>
          <resetMask>0xFF</resetMask>
        </register>

        <!-- Completion Register -->
        <register>
          <name>COMPLETION</name>
          <description>Completion Register
          </description>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>

          <fields>
            <!-- DTEN -->
            <field>
              <name>DTEN</name>
              <description>When DTEN is asserted ('1'), Device Time-out checking is enabled. When DTEN is not asserted ('0'), Device Time-out checking is disabled.
              </description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>

            <!-- MCEN -->
            <field>
              <name>MCEN</name>
              <description>When MCEN is asserted ('1'), Master Cumulative Time-Out checking is enabled. When MCEN is not asserted ('0'), Master Cumulative Time-Out checking is disabled.
              </description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>

            <!-- SCEN -->
            <field>
              <name>SCEN</name>
              <description>When SCEN is asserted ('1'), Slave Cumulative Time-Out checking is enabled. When SCEN is not asserted ('0'), Slave Cumulative Time-Out checking is disabled.
              </description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>

            <!-- BIDEN -->
            <field>
              <name>BIDEN</name>
              <description>When BIDEN is asserted ('1'), Bus Idle Detect Time-Out checking is enabled. When BIDEN is not asserted ('0'), Bus Idle Detect Time-Out checking is disabled.
              </description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>

            <!-- TIMERR -->
            <field>
              <name>TIMERR</name>
              <description>The Time-out Error Detected bit (TIMERR) is asserted ('1') whenever any of the enabled time-out error detect status bits (CHDH, CHDL, SCTO, MCTO and DTO) are asserted.
              </description>
              <bitRange>[6:6]</bitRange>
              <access>read-only</access>
            </field>

            <!-- DTO -->
            <field>
              <name>DTO</name>
              <description>DTO is the Device Time-out bit. (R/WC)
              </description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>

            <!-- MCTO -->
            <field>
              <name>MCTO</name>
              <description>MCTO is the Master Cumulative Time-out bit. (R/WC)
              </description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>

            <!-- SCTO -->
            <field>
              <name>SCTO</name>
              <description>SCTO is the Slave Cumulative Time-out bit(R/WC)
              </description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>

            <!-- CHDL -->
            <field>
              <name>CHDL</name>
              <description>CHDL is the clock high time-out detect bit(R/WC)
              </description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>

            <!-- CHDH -->
            <field>
              <name>CHDH</name>
              <description>CHDH is the bus idle time-out detect bit(R/WC)
              </description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>

            <!-- BER -->
            <field>
              <name>BER</name>
              <description>If this bit is 1, the BER bit in the Status register was set while either the Slave state machine or the Master state machine was not in the Idle state.(R/WC)
              </description>
              <bitRange>[13:13]</bitRange>
              <access>read-write</access>
            </field>

            <!-- LAB -->
            <field>
              <name>LAB</name>
              <description>If this bit is 1, the LAB bit in the Status register was set while either the Slave state machine or the Master state machine was not in the Idle state.(R/WC)
              </description>
              <bitRange>[14:14]</bitRange>
              <access>read-write</access>
            </field>

            <!-- SNAKR -->
            <field>
              <name>SNAKR</name>
              <description>If this bit is 1, the Slave state machine sent a NACK to the transmitting Master while the Slave was receiving data from the SMBus interface.
              </description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>

            <!-- STR -->
            <field>
              <name>STR</name>
              <description>0: Slave has just finished the receive phase of a transaction. \n
               1: Slave has just finished the transmit phase of a transaction.
              </description>
              <bitRange>[17:17]</bitRange>
              <access>read-only</access>
            </field>

            <!-- SPROT -->
            <field>
              <name>SPROT</name>
              <description>If this bit is 1, the WriteCount[7:0] counter in the Slave state machine either counted down to 0 before the Master sent a NACK signal, or the Slave received a NACK signal before the counter reached 0.
              </description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
            </field>

            <!-- Repeat-Read -->
            <field>
              <name>REPEAT_READ</name>
              <description>If this bit is 1, the Slave State Machine stopped because it detected a Repeat Start bit, with bit[0] of the byte containing the slave address equal to 1, indicating that the Master requested a Read operation.
              </description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>

            <!-- Repeat-Write -->
            <field>
              <name>REPEAT_WRITE</name>
              <description>If this bit is 1, the Slave State Machine stopped because it detected a Repeat Start bit, with bit[0] of the byte containing the slave address equal to 0, indicating that the Master requested a Write operation.
              </description>
              <bitRange>[21:21]</bitRange>
              <access>read-write</access>
            </field>

            <!-- MNAKX -->
            <field>
              <name>MNAKX</name>
              <description>If this bit is 1, the Master state machine received a NACK from the receiving Slave while the Master was transmitting data over the SMBus interface. (R/WC)
              </description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
            </field>

            <!-- MTR -->
            <field>
              <name>MTR</name>
              <description>0: Master has just finished the receive phase of a transaction. \n
               1: Master has just finished the transmit phase of a transaction.
              </description>
              <bitRange>[25:25]</bitRange>
              <access>read-only</access>
            </field>

            <!-- IDLE -->
            <field>
              <name>IDLE</name>
              <description>This bit is set when the I2C bus becomes idle (on the rising edge of nBB). (R/WC)
              </description>
              <bitRange>[29:29]</bitRange>
              <access>read-write</access>
            </field>

            <!-- MDONE -->
            <field>
              <name>MDONE</name>
              <description>If this bit is 1, Master State machine completed operation and returned to the Idle state. It is cleared when written with a 1. Writes of a 0 have no effect. (R/WC)
              </description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>

            <!-- SDONE -->
            <field>
              <name>SDONE</name>
              <description>If this bit is 1, Slave State machine completed operation and returned to the Idle state. It is cleared when written with a 1. Writes of a 0 have no effect.(R/WC)
              </description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>

        <!-- Idle Scaling Register -->
        <register>
          <name>IDLE_SCALING</name>
          <description>Idle Scaling Register
          </description>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x01FC01ED</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>

          <fields>
            <!-- Fair Bus Idle Min -->
            <field>
              <name>FAIR_BUS_IDLE_MIN</name>
              <description>This field defines the number of ticks of the baud clock required to satisfy the fairness protocol. The default value for this field sets the idle window to 31us, which is the appropriate value for a 100 KHz bus
              </description>
              <bitRange>[11:0]</bitRange>
              <access>read-write</access>
            </field>

            <!-- Fair Idle Delay -->
            <field>
              <name>FAIR_IDLE_DELAY</name>
              <description>This field defines the number of ticks of the baud clock required to program the delay. The default value for this field sets the delay period to 32us, which is the appropriate value for a 100 KHz bus
              </description>
              <bitRange>[27:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>

        <!-- Configuration Register -->
        <register>
          <name>CONFIGURATION</name>
          <description>Configuration Register
          </description>
          <addressOffset>0x28</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <!-- PORT SEL [3:0] -->
            <field>
              <name>PORT_SEL</name>
              <description>The PORT SEL [3:0] bits determine which one of 16 possible bus ports apply to the active 2-wire SDAT and SCLK bus pair.
              </description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>

            <!-- TCEN -->
            <field>
              <name>TCEN</name>
              <description>When the Timing Check Enable bit (TCEN) is asserted ('1'), Bus Time-Outs are enabled
              </description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>

            <!-- Slow Clock -->
            <field>
              <name>SLOW_CLOCK</name>
              <description>When this bit is 1, the base period for the Bus Clock Register is multiplied by 4, and thus the frequency is divided by 4.
              </description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
            </field>

            <!-- PECEN -->
            <field>
              <name>PECEN</name>
              <description>When the PEC Enable bit (PECEN) is asserted ('1'), Hardware PEC Support is enabled
              </description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>

            <!-- DFEN -->
            <field>
              <name>DFEN</name>
              <description>When the Digital Filter Enable bit (DFEN) is asserted ('1'), the Digital Filter is enabled. When DFEN is not asserted ('0') (default), the Digital Filter is bypassed.
              </description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>

            <!-- RESET -->
            <field>
              <name>RESET</name>
              <description>When RESET is asserted ('1'), all logic and registers except for the RESET bit itself are initialized to the power-on default state.
              </description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>

            <!-- ENAB -->
            <field>
              <name>ENAB</name>
              <description>When ENAB (Enable) is not asserted ('0') (default), the SMB Controller Core is disabled and in the lowest power consumption state (Disabled State).\n
               The ENAB bit must be asserted ('1') for normal operation.
              </description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>

            <!-- DSA -->
            <field>
              <name>DSA</name>
              <description>0: Slave Address I2C Compatibility Mode (default). 1: SMBus Address Decode Mode
              </description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>

            <!-- FAIR -->
            <field>
              <name>FAIR</name>
              <description>If this bit is 1, the MCTP Fairness protocol is in effect.
              </description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>

            <!-- GC_DIS -->
            <field>
              <name>GC_DIS</name>
              <description>This is the General Call Disable bit.\n
               0: the response to the General Call address as a slave is enabled\n
               1: the response to the General Call address as a slave is disabled.
              </description>
              <bitRange>[14:14]</bitRange>
              <access>read-only</access>
            </field>

            <!-- Flush_SXBUF -->
            <field>
              <name>FLUSH_SXBUF</name>
              <description>A write of a 1 to this bit forces the SMBus Slave Transmit Buffer Register to be marked empty. A write of 0 has no effect. This is a self-clearing bit.
              </description>
              <bitRange>[16:16]</bitRange>
              <access>write</access>
            </field>

            <!-- Flush_SRBUF -->
            <field>
              <name>FLUSH_SRBUF</name>
              <description>A write of a 1 to this bit forces the SMBus Slave Receive Buffer Register to be marked empty. A write of 0 has no effect. This is a self-clearing bit.
              </description>
              <bitRange>[17:17]</bitRange>
              <access>write</access>
            </field>

            <!-- Flush_MXBUF -->
            <field>
              <name>FLUSH_MXBUF</name>
              <description>A write of a 1 to this bit forces the SMBus Master Transmit Buffer Register to be marked empty. A write of 0 has no effect. This is a self-clearing bit.
              </description>
              <bitRange>[18:18]</bitRange>
              <access>write</access>
            </field>

            <!-- Flush_MRBUF -->
            <field>
              <name>FLUSH_MRBUF</name>
              <description>A write of a 1 to this bit forces the SMBus Master Receive Buffer Register to be marked empty. A write of 0 has no effect. This is a self-clearing bit.
              </description>
              <bitRange>[19:19]</bitRange>
              <access>write</access>
            </field>

            <!-- Enable AAS -->
            <field>
              <name>EN_AAS</name>
              <description>0: Disable the AAS Interrupt, 1: Enable the AAS Interrupt
              </description>
              <bitRange>[28:28]</bitRange>
              <access>read-only</access>
            </field>

            <!-- ENIDI -->
            <field>
              <name>ENIDI</name>
              <description>If this bit is 1, the Idle interrupt is enabled. If this bit is 0, the Idle interrupt is disabled.
              </description>
              <bitRange>[29:29]</bitRange>
              <access>read-write</access>
            </field>

            <!-- ENMI -->
            <field>
              <name>ENMI</name>
              <description>If this bit is 1, the Master Done interrupt is enabled. If this bit is 0, the Master Done interrupt is disabled.
              </description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>

            <!-- ENSI -->
            <field>
              <name>ENSI</name>
              <description>If this bit is 1, the Slave Done interrupt is enabled. If this bit is 0, the Slave Done interrupt is disabled
              </description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>

        <!-- Bus Clock Register -->
        <register>
          <name>BUS_CLOCK</name>
          <description>Bus Clock Register
          </description>
          <addressOffset>0x2C</addressOffset>
          <size>16</size>
          <access>read-write</access>
          <resetValue>0x4F4F</resetValue>
          <resetMask>0xFFFF</resetMask>

          <fields>
            <!-- LOW_PERIOD -->
            <field>
              <name>LOW_PERIOD</name>
              <description>This field defines the number of I2C Baud Clock periods that make up the low phase of the I2C/SMBus bus clock.
              </description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>

            <!-- HIGH_PERIOD -->
            <field>
              <name>HIGH_PERIOD</name>
              <description>This field defines the number of I2C Baud Clock periods that make up the high phase of the I2C/SMBus bus clock.
              </description>
              <bitRange>[15:8]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>

        <!-- Block ID Register -->
        <register>
          <name>BLOCK_ID</name>
          <description>Block ID Register
          </description>
          <addressOffset>0x30</addressOffset>
          <size>8</size>
          <access>read-only</access>
          <resetValue>0x00</resetValue>
          <resetMask>0xFF</resetMask>
        </register>

        <!-- Revision Register -->
        <register>
          <name>REVISION</name>
          <description>Revision Register
          </description>
          <addressOffset>0x34</addressOffset>
          <size>8</size>
          <access>read-only</access>
          <resetValue>0x00</resetValue>
          <resetMask>0xFF</resetMask>
        </register>

        <!-- Bit-Bang Control Register -->
        <register>
          <name>BIT_BANG_CONTROL</name>
          <description>Bit-Bang Control Register
          </description>
          <addressOffset>0x38</addressOffset>
          <size>8</size>
          <access>read-write</access>
          <resetValue>0x60</resetValue>
          <resetMask>0xFF</resetMask>

          <fields>
            <!-- BBEN -->
            <field>
              <name>BBEN</name>
              <description>Bit-Bang Mode Enable. 0 - Bit Bang Mode Disabled. 1 - Bit Bang Mode Enabled
              </description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>

            <!-- CLDIR -->
            <field>
              <name>CLDIR</name>
              <description>Bit-Bang Clock Direction. The CLDIR bit controls the direction of SCLK. 0 - Input, 1 - Output
              </description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>

            <!-- DADIR -->
            <field>
              <name>DADIR</name>
              <description>Bit-Bang Data Direction. The DADIR bit controls the direction of SDAT. 0 - Input. 1 - Output
              </description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>

            <!-- BBCLK -->
            <field>
              <name>BBCLK</name>
              <description>Bit-Bang Clock. The BBCLK bit controls the state of SCLK when BBEN = and CLDIR = '1'
              </description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>

            <!-- BBDAT -->
            <field>
              <name>BBDAT</name>
              <description>Bit-Bang Data. The BBDAT bit controls the state of SDAT when BBEN = and DADIR = '1'
              </description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>

            <!-- BBCLKI -->
            <field>
              <name>BBCLKI</name>
              <description>Bit-Bang Clock In. The BBCLKI bit always returns the state of SCLK.
              </description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
            </field>

            <!-- BBDATI -->
            <field>
              <name>BBDATI</name>
              <description>Bit-Bang Data In. The BBDATI bit always returns the state of SDAT
              </description>
              <bitRange>[6:6]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>

        <!-- Data Timing Register -->
        <register>
          <name>DATA_TIMING</name>
          <description>Data Timing Register
          </description>
          <addressOffset>0x40</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0C4D4306</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>

            <fields>

              <!-- Data Hold [7:0] -->
              <field>
                <name>DATA_HOLD</name>
                <description>The Data Hold [7:0] timer determines the SDAT hold time following SCLK driven low.
                </description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>

              <!-- Restart Setup [7:0] -->
              <field>
                <name>RESTART_SETUP</name>
                <description>The Restart Setup [7:0] timer determines the SDAT setup time from the rising edge of SCLK for a repeated START condition.
                </description>
                <bitRange>[15:8]</bitRange>
                <access>read-write</access>
              </field>

              <!-- Stop Setup [7:0] -->
              <field>
                <name>STOP_SETUP</name>
                <description>The Stop Setup [7:0] timer determines the SDAT setup time from the rising edge of SCLK for a STOP condition.
                </description>
                <bitRange>[23:16]</bitRange>
                <access>read-write</access>
              </field>

              <!-- Start Hold [7:0] -->
              <field>
                <name>START_HOLD</name>
                <description>The Start Hold [7:0] timer determines the SCLK hold time following SDAT driven low during a START condition.
                </description>
                <bitRange>[31:24]</bitRange>
                <access>read-write</access>
              </field>

            </fields>
        </register>

        <!-- Time-Out Scaling Register -->
        <register>
          <name>TIME_OUT_SCALING</name>
          <description>Time-Out Scaling Register
          </description>
          <addressOffset>0x44</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x4B9CC2C7</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>

            <!-- Clock High Time-Out [7:0] -->
            <field>
              <name>CLOCK_HIGH</name>
              <description>Clock High time out period = Clock High Time-Out [7:0] x Baud_Clock_Period x 2
              </description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>

            <!-- Slave Cum Time-Out [7:0] -->
            <field>
              <name>SLAVE_CUM</name>
              <description>Slave Cumulative Time-Out duration = Slave Cum Time-Out [7:0] x Baud_Clock_Period x 1024
              </description>
              <bitRange>[15:8]</bitRange>
              <access>read-write</access>
            </field>

            <!-- Master Cum Time-Out [7:0] -->
            <field>
              <name>MASTER_CUM</name>
              <description>Master Cumulative Time-Out duration = Master Cum Time-Out [7:0] x Baud_Clock_Periodx 512
              </description>
              <bitRange>[23:16]</bitRange>
              <access>read-write</access>
            </field>

            <!-- Bus Idle Min [7:0] -->
            <field>
              <name>BUS_IDLE_MIN</name>
              <description>Bus Idle Minimum time = Bus Idle Min [7:0] x Baud_Clock_Period
              </description>
              <bitRange>[31:24]</bitRange>
              <access>read-write</access>
            </field>

          </fields>
        </register>

        <!-- SMBus Slave Transmit Buffer Register -->
        <register>
          <name>SLAVE_TRANSMIT_BUFFER</name>
          <description>SMBus Slave Transmit Buffer Register
          </description>
          <addressOffset>0x48</addressOffset>
          <size>8</size>
          <access>read-write</access>
          <resetValue>0x00</resetValue>
          <resetMask>0xFF</resetMask>
        </register>

        <!-- SMBus Slave Receive Buffer Register -->
        <register>
          <name>SLAVE_RECEIVE_BUFFER</name>
          <description>SMBus Slave Receive Buffer Register
          </description>
          <addressOffset>0x4C</addressOffset>
          <size>8</size>
          <access>read-write</access>
          <resetValue>0x00</resetValue>
          <resetMask>0xFF</resetMask>
        </register>

        <!-- SMBus Master Transmit Bufer Register -->
        <register>
          <name>MASTER_TRANSMIT_BUFER</name>
          <description>SMBus Master Transmit Bufer Register
          </description>
          <addressOffset>0x50</addressOffset>
          <size>8</size>
          <access>read-write</access>
          <resetValue>0x00</resetValue>
          <resetMask>0xFF</resetMask>
        </register>

        <!-- SMBus Master Receive Buffer Register -->
        <register>
          <name>MASTER_RECEIVE_BUFFER</name>
          <description>SMBus Master Receive Buffer Register
          </description>
          <addressOffset>0x54</addressOffset>
          <size>8</size>
          <access>read-write</access>
          <resetValue>0x00</resetValue>
          <resetMask>0xFF</resetMask>
        </register>

      </registers>
    </peripheral>

    <!-- SMB1-->
    <peripheral derivedFrom="SMB0">
      <name>SMB1</name>
      <baseAddress>0x4000AC00</baseAddress>
    </peripheral>

    <!-- SMB2-->
    <peripheral derivedFrom="SMB0">
      <name>SMB2</name>
      <baseAddress>0x4000B000</baseAddress>
    </peripheral>

    <!-- SMB3-->
    <peripheral derivedFrom="SMB0">
      <name>SMB3</name>
      <baseAddress>0x4000B400</baseAddress>
    </peripheral>
    <!--  -->

    <peripheral>
    <!-- < Chapter 23.0>  PECI Interface -->
    <!-- 40006400  PECI                            0  PECI_EC_Only           PECI Write Data Register                             -->
    <!-- 40006404  PECI                            0  PECI_EC_Only           PECI Read Data Register                              -->
    <!-- 40006408  PECI                            0  PECI_EC_Only           PECI Control Register                                -->
    <!-- 4000640C  PECI                            0  PECI_EC_Only           PECI Status 1 Register                               -->
    <!-- 40006410  PECI                            0  PECI_EC_Only           PECI Status 2 Register                               -->
    <!-- 40006414  PECI                            0  PECI_EC_Only           PECI Error Register                                  -->
    <!-- 40006418  PECI                            0  PECI_EC_Only           PECI Interrupt Enable 1 Register                     -->
    <!-- 4000641C  PECI                            0  PECI_EC_Only           PECI Interrupt Enable 2 Register                     -->
    <!-- 40006420  PECI                            0  PECI_EC_Only           PECI Optimal Bit Time (Low Byte) Register            -->
    <!-- 40006424  PECI                            0  PECI_EC_Only           PECI Optimal Bit Time (High Byte) Register           -->
    <!-- 40006428  PECI                            0  PECI_EC_Only           PECI Reserved                                        -->
    <!-- 4000642C  PECI                            0  PECI_EC_Only           PECI Reserved                                        -->
    <!-- 40006430  PECI                            0  PECI_EC_Only           PECI Reserved                                        -->
    <!-- 40006440  PECI                            0  PECI_EC_Only           PECI Block ID Register                               -->
    <!-- 40006444  PECI                            0  PECI_EC_Only           Block Revision                                       -->
    <!--  -->
      <name>PECI</name>
      <version>1.0</version>
      <description>The MEC1322 includes a PECI Interface to allow the EC to retrieve\n
       temperature readings from PECI-compliant devices.
      </description>
      <groupName>PECI</groupName>
      <baseAddress>0x40006400</baseAddress>
      <size>32</size>
      <access>read-write</access>

      <addressBlock>
        <offset>0</offset>
        <size>0x048</size>
        <usage>registers</usage>
      </addressBlock>

      <interrupt>
        <name>PECIHOST</name>
        <description>PECIHOST Interrupt .................... Also see GIRQ 16.3</description>
        <value>25</value>
      </interrupt>

      <registers>
        <!-- Write Data Register -->
        <register>
          <name>WRITE_DATA</name>
          <description>The Write Data Register provides access to a 32-byte Transmit FIFO.
          </description>
          <addressOffset>0x00</addressOffset>
          <size>8</size>
          <access>read-write</access>
          <resetValue>0x00</resetValue>
          <resetMask>0xFF</resetMask>
        </register>

        <!-- Read Data Register -->
        <register>
          <name>READ_DATA</name>
          <description>The Read Data Register provides access to a 32-byte Receive FIFO.
          </description>
          <addressOffset>0x04</addressOffset>
          <size>8</size>
          <access>read-write</access>
          <resetValue>0x00</resetValue>
          <resetMask>0xFF</resetMask>
        </register>

        <!-- Control Register -->
        <register>
          <name>CONTROL</name>
          <description>Control Register
          </description>
          <addressOffset>0x08</addressOffset>
          <size>8</size>
          <access>read-write</access>
          <resetValue>0x01</resetValue>
          <resetMask>0xFF</resetMask>

          <fields>
            <!-- PD -->
            <field>
              <name>PD</name>
              <description>PD (Power Down) along with RST controls the Power Management Interface
              </description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>

            <!-- RST -->
            <field>
              <name>RST</name>
              <description>RST indicates that the PECI Core should be reset.
              </description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>

            <!-- FRST -->
            <field>
              <name>FRST</name>
              <description>FRST is the FIFO Reset bit.
              </description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>

            <!-- TXEN -->
            <field>
              <name>TXEN</name>
              <description>TXEN is the Transmit Enable bit.
              </description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>

            <!-- MIEN -->
            <field>
              <name>MIEN</name>
              <description>MIEN is the Master Interrupt Enable
              </description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>

          </fields>

        </register>

        <!-- Status Register 1 -->
        <register>
          <name>STATUS1</name>
          <description>Status Register 1
          </description>
          <addressOffset>0x0C</addressOffset>
          <size>8</size>
          <access>read-write</access>
          <resetValue>0x00</resetValue>
          <resetMask>0xFF</resetMask>

          <fields>
            <!-- BOF -->
            <field>
              <name>BOF</name>
              <description>BOF (Beginning of Frame) is asserted when the PECI Core begins Address Timing Negotiation. (R/WC)
              </description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>

            <!-- EOF -->
            <field>
              <name>EOF</name>
              <description>EOF (End of Frame) is asserted following Message Stop (tSTOP). (R/WC)
              </description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>

            <!-- ERR -->
            <field>
              <name>ERR</name>
              <description>ERR Indicates that an error for the current transaction has been detected.
              </description>
              <bitRange>[2:2]</bitRange>
              <access>read</access>
            </field>

            <!-- RDY -->
            <field>
              <name>RDY</name>
              <description>RDY represents the state of the READY signal function
              </description>
              <bitRange>[3:3]</bitRange>
              <access>read</access>
            </field>

            <!-- RDYLO -->
            <field>
              <name>RDYLO</name>
              <description>RDYLO is asserted '1' on the falling edge of the READY signal function (R/WC)
              </description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>

            <!-- RDYHI -->
            <field>
              <name>RDYHI</name>
              <description>RDYHI is asserted '1' on the rising edge of the READY signal function (R/WC)
              </description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>

            <!-- MINT -->
            <field>
              <name>MINT</name>
              <description>MINT is the Master Interrupt Status bit and is asserted when any interrupt status bit in the Interrupt Interface is asserted.
              </description>
              <bitRange>[7:7]</bitRange>
              <access>read</access>
            </field>

          </fields>
        </register>

        <!-- Status Register 2 -->
        <register>
          <name>STATUS2</name>
          <description>Status Register 2
          </description>
          <addressOffset>0x10</addressOffset>
          <size>8</size>
          <access>read</access>
          <resetValue>0x0A</resetValue>
          <resetMask>0xFF</resetMask>

          <fields>
            <!-- WFF -->
            <field>
              <name>WFF</name>
              <description>WFF indicates that the Write Data Register FIFO is full. WFF does not generate an interrupt.
              </description>
              <bitRange>[0:0]</bitRange>
              <access>read</access>
            </field>

            <!-- WFE -->
            <field>
              <name>WFE</name>
              <description>WFE indicates that the Write Data Register FIFO is empty.
              </description>
              <bitRange>[1:1]</bitRange>
              <access>read</access>
            </field>

            <!-- RFF -->
            <field>
              <name>RFF</name>
              <description>RFF indicates that the Read Data Register FIFO is full.
              </description>
              <bitRange>[2:2]</bitRange>
              <access>read</access>
            </field>

            <!-- RFE -->
            <field>
              <name>RFE</name>
              <description>RFE indicates that the Read Data Register FIFO is empty. RFE does not generate an interrupt.
              </description>
              <bitRange>[3:3]</bitRange>
              <access>read</access>
            </field>

            <!-- IDLE -->
            <field>
              <name>IDLE</name>
              <description>The IDLE status bit indicates when the SST/PECI bus is idle and a new transaction may begin.
              </description>
              <bitRange>[7:7]</bitRange>
              <access>read</access>
            </field>

          </fields>
        </register>

        <!-- Error Register -->
        <register>
          <name>ERROR</name>
          <description>Error Register
          </description>
          <addressOffset>0x14</addressOffset>
          <size>8</size>
          <access>read-write</access>
          <resetValue>0x000F</resetValue>
          <resetMask>0xFFFF</resetMask>

          <fields>
            <!-- FERR -->
            <field>
              <name>FERR</name>
              <description>FERR (Frame Check Sequence Error). (R/WC)
              </description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>

            <!-- BERR -->
            <field>
              <name>BERR</name>
              <description>BERR (Bus Error). Bus contention has been detected. BERR is asserted when the PECI Module reads a value that is different from what it has driven (R/WC)
              </description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>

            <!-- REQERR -->
            <field>
              <name>REQERR</name>
              <description>REQERR is asserted if PEC_AVAILABLE (READY) input is not asserted when the counts down to zero as shown in. When asserted, REQERR can generate interrupt. (R/WC)
              </description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>

            <!-- WROV -->
            <field>
              <name>WROV</name>
              <description>WROV (Write Overrun). (R/WC)
              </description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>

            <!-- WRUN -->
            <field>
              <name>WRUN</name>
              <description>WRUN (Write Underrun). (R/WC)
              </description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>

            <!-- RDOV -->
            <field>
              <name>RDOV</name>
              <description>RDOV (Read Overrun). RDOV indicates that the internal read buffer has overflowed (R/WC)
              </description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>

            <!-- CLKERR -->
            <field>
              <name>CLKERR</name>
              <description>CLKERR indicates that the READY signal function in the Hardware Interface was de-asserted in the middle of a transaction (R/WC)
              </description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>

          </fields>
        </register>

        <!-- Interrupt Enable 1 Register -->
        <register>
          <name>INT_EN1</name>
          <description>Interrupt Enable 1 Register
          </description>
          <addressOffset>0x18</addressOffset>
          <size>8</size>
          <access>read-write</access>
          <resetValue>0x00</resetValue>
          <resetMask>0xFF</resetMask>

          <fields>
            <!-- BIEN -->
            <field>
              <name>BIEN</name>
              <description>When the BIEN bit is asserted '1' the BOF interrupt is enabled.
              </description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>

            <!-- EIEN -->
            <field>
              <name>EIEN</name>
              <description>When the EIEN bit is asserted '1' the EOF interrupt is enabled.
              </description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>

            <!-- EREN -->
            <field>
              <name>EREN</name>
              <description>When the EREN bit is asserted '1' the ERR interrupt is enabled.
              </description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>

            <!-- RLEN -->
            <field>
              <name>RLEN</name>
              <description>When the RLEN bit is asserted '1' the RDYLO interrupt is enabled.
              </description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>

            <!-- RHEN -->
            <field>
              <name>RHEN</name>
              <description>When the RHEN bit is asserted '1' the RDYHI interrupt is enabled.
              </description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>

          </fields>
        </register>

        <!-- Interrupt Enable 2 Register -->
        <register>
          <name>INT_EN2</name>
          <description>Interrupt Enable 2 Register
          </description>
          <addressOffset>0x1C</addressOffset>
          <size>8</size>
          <access>read-write</access>
          <resetValue>0x00</resetValue>
          <resetMask>0xFF</resetMask>

          <fields>
            <!-- ENWFE -->
            <field>
              <name>ENWFE</name>
              <description>When the ENWFE bit is asserted '1' the WFE interrupt is enabled.
              </description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>

            <!-- ENRFF -->
            <field>
              <name>ENRFF</name>
              <description>When the ENRFF bit is asserted '1' the RFF interrupt is enabled.
              </description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>

          </fields>
        </register>

        <!-- Optimal Bit Time Register (Low Byte) -->
        <register>
          <name>OBT1</name>
          <description>Optimal Bit Time Register (Low Byte)
          </description>
          <addressOffset>0x20</addressOffset>
          <size>8</size>
          <access>read-write</access>
          <resetValue>0x16</resetValue>
          <resetMask>0xFF</resetMask>
        </register>

        <!-- Optimal Bit Time Register (High Byte) -->
        <register>
          <name>OBT2</name>
          <description>Optimal Bit Time Register (High Byte)
          </description>
          <addressOffset>0x24</addressOffset>
          <size>8</size>
          <access>read-write</access>
          <resetValue>0x00</resetValue>
          <resetMask>0xFF</resetMask>
        </register>

        <!-- Block ID Register -->
        <register>
          <name>ID</name>
          <description>Block ID Register
          </description>
          <addressOffset>0x40</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x000F</resetValue>
          <resetMask>0xFFFF</resetMask>
        </register>

        <!-- Revision Register -->
        <register>
          <name>REV</name>
          <description>Revision Register
          </description>
          <addressOffset>0x044</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x000F</resetValue>
          <resetMask>0xFFFF</resetMask>
        </register>

      </registers>
    </peripheral>
    <!--  -->

    <peripheral>
    <!-- < Chapter 24.0>  TACH -->
    <!-- 40006000  TACH                            0  TACH_EC_ONLY           TACH Control Register                                -->
    <!-- 40006004  TACH                            0  TACH_EC_ONLY           TACH Status Register                                 -->
    <!-- 40006008  TACH                            0  TACH_EC_ONLY           TACH High Limit Register                             -->
    <!-- 4000600C  TACH                            0  TACH_EC_ONLY           TACH Low Limit Register                              -->
    <!-- 40006010  TACH                            1  TACH_EC_ONLY           TACH Control Register                                -->
    <!-- 40006014  TACH                            1  TACH_EC_ONLY           TACH Status Register                                 -->
    <!-- 40006018  TACH                            1  TACH_EC_ONLY           TACH High Limit Register                             -->
    <!-- 4000601C  TACH                            1  TACH_EC_ONLY           TACH Low Limit Register                              -->
    <!--  -->
      <name>TACH</name>
      <version>1.0</version>
      <description>This block monitors TACH output signals (or locked rotor signals) from\n
       various types of fans, and determines their speed.
      </description>
      <groupName>TACH</groupName>
      <baseAddress>0x40006000</baseAddress>
      <size>32</size>
      <access>read-write</access>

      <addressBlock>
        <offset>0</offset>
        <size>0x020</size>
        <usage>registers</usage>
      </addressBlock>

      <interrupt>
        <name>TACH_0</name>
        <description>TACH_0 Interrupt ...................... Also see GIRQ 17.0</description>
        <value>26</value>
      </interrupt>

      <interrupt>
        <name>TACH_1</name>
        <description>TACH_1 Interrupt ...................... Also see GIRQ 17.1</description>
        <value>27</value>
      </interrupt>

      <registers>
        <cluster>
          <dim>2</dim>
          <dimIncrement>0x10</dimIncrement>
          <dimIndex>0,1</dimIndex>
          <name>CH[%s]</name>
          <description>Channel implemented will have these registers to determine that channel's operation.
          </description>
          <addressOffset>0x000</addressOffset>

          <!-- TACHx Control Register -->
          <register>
            <name>CONTROL</name>
            <description>TACHx Control Register
            </description>
            <addressOffset>0x00</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>

            <fields>
              <!-- TACH_OUT_OF_LIMIT_ENABLE -->
              <field>
                <name>OUT_LIMIT_ENABLE</name>
                <description>TACH_OUT_OF_LIMIT_ENABLE  This bit is used to enable the TACH_OUT_OF_LIMIT_STATUS bit in the TACHx Status Register to generate an interrupt event.\n
                 1=Enable interrupt output from Tach block\n
                 0=Disable interrupt output from Tach block (default)
                 </description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>

              <!-- TACH_ENABLE -->
              <field>
                <name>TACH_EN</name>
                <description>TACH_ENABLE  1= TACH Monitoring enabled, clocks enabled. 0= TACH Idle, clocks gated
                </description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>

              <!-- FILTER_ENABLE -->
              <field>
                <name>FILTER_EN</name>
                <description>FILTER_ENABLE  This filter is used to remove high frequency glitches from Tach Input. When this filter is enabled, Tach input pulses less than two 100kHz_- Clk periods wide get filtered.\n
                 1= Filter enabled\n
                 0= Filter disabled (default)\n
                 It is recommended that the Tach input filter always be enabled.
                </description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>

              <!-- TACH_READING_MODE_SELECT -->
              <field>
                <name>MODE_SELECT</name>
                <description>TACH_READING_MODE_SELECT\n
                 1=Counter is incremented on the rising edge of the 100kHz_Clk input. The counter is latched into the TACHX_COUNTER field and reset when the programmed number of edges is detected.\n
                 0=Counter is incremented when Tach Input transitions from low-tohigh state (default)
                </description>
                <bitRange>[10:10]</bitRange>
                <access>read-write</access>
              </field>

              <!-- TACH_EDGES -->
              <field>
                <name>EDGES</name>
                <description>TACH_EDGES A Tach signal is a square wave with a 50% duty cycle. Typically, two Tach periods represents one revolution of the fan. A Tach period consists of three Tach edges. This programmed value represents the number of Tach edges that will be used to determine the interval for which the number of 100kHz_Clk pulses will be counted\n
                 11b=9 Tach edges (4 Tach periods)\n
                 10b=5 Tach edges (2 Tach periods)\n
                 01b=3 Tach edges (1 Tach period)\n
                 00b=2 Tach edges (1/2 Tach period)
                </description>
                <bitRange>[12:11]</bitRange>
                <access>read-write</access>
              </field>

              <!-- COUNT_READY_INT_EN -->
              <field>
                <name>READY_INT_EN</name>
                <description>COUNT_READY_INT_EN 1=Enable Count Ready interrupt from Tach block, 0=Disable Count Ready interrupt from Tach block
                </description>
                <bitRange>[14:14]</bitRange>
                <access>read-write</access>
              </field>

              <!-- TACH_INPUT_INT_EN -->
              <field>
                <name>INPUT_INT_EN</name>
                <description>TACH_INPUT_INT_EN 1=Enable Tach Input toggle interrupt from Tach block, 0=Disable Tach Input toggle interrupt from Tach block
                </description>
                <bitRange>[15:15]</bitRange>
                <access>read-write</access>
              </field>

              <!-- TACHX_COUNTER -->
              <field>
                <name>COUNTER</name>
                <description>This 16-bit field contains the latched value of the internal Tach pulse counter, which may be configured by the Tach Reading Mode Select field to operate as a free-running counter or to be gated by the Tach input signal.
                </description>
                <bitRange>[31:16]</bitRange>
                <access>read</access>
              </field>
            </fields>
          </register>

          <!-- TACHx Status Register -->
          <register>
            <name>STATUS</name>
            <description>TACHx Status Register
            </description>
            <addressOffset>0x04</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0000</resetValue>
            <resetMask>0xFFFF</resetMask>

            <fields>
              <!-- TACH_OUT_OF_LIMIT_STATUS -->
              <field>
                <name>OUT_LIMIT</name>
                <description>TACH_OUT_OF_LIMIT_STATUS  1=Tach is outside of limits, 0=Tach is within limits (R/WC)
                </description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>

              <!-- TACH_PIN_STATUS -->
              <field>
                <name>PIN</name>
                <description>TACH_PIN_STATUS  1= Tach Input is high, 0= Tach Input is low
                </description>
                <bitRange>[1:1]</bitRange>
                <access>read</access>
              </field>

              <!-- TOGGLE_STATUS -->
              <field>
                <name>TOGGLE</name>
                <description>TOGGLE_STATUS  1=Tach Input changed state (this bit is set on a low-to-high or high-tolow transition), 0=Tach stable (R/WC)
                </description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>

              <!-- COUNT_READY_STATUS -->
              <field>
                <name>COUNT_READY</name>
                <description>COUNT_READY_STATUS  1=Reading ready, 0=Reading not ready
                </description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>

          <!-- TACHx High Limit Register -->
          <register>
            <name>HIGH_LIMIT</name>
            <description>This value is compared with the value in the TACHX_COUNTER field. If the value in the counter is greater than the value programmed in this register, the TACH_OUT_OF_LIMIT_STATUS bit will be set.
            </description>
            <addressOffset>0x08</addressOffset>
            <size>16</size>
            <access>read-write</access>
            <resetValue>0xFFFF</resetValue>
            <resetMask>0xFFFF</resetMask>
          </register>

          <!-- TACHx Low Limit Register -->
          <register>
            <name>LOW_LIMIT</name>
            <description>This value is compared with the value in the TACHX_COUNTER field of the TACHx Control Register. If the value in the counter is less than the value programmed in this register, the TACH_OUT_OF_LIMIT_STATUS bit will be set.
            </description>
            <addressOffset>0x0C</addressOffset>
            <size>16</size>
            <access>read-write</access>
            <resetValue>0x0000</resetValue>
            <resetMask>0xFFFF</resetMask>
          </register>

        </cluster>
      </registers>
    </peripheral>
    <!--  -->

    <peripheral>
    <!-- < Chapter 25.0>  PWM -->
    <!-- 40005800  PWM                             0  PWM_EC_Only            PWM Counter ON Time Register                         -->
    <!-- 40005804  PWM                             0  PWM_EC_Only            PWM Counter OFF Time Register                        -->
    <!-- 40005808  PWM                             0  PWM_EC_Only            PWM Configuration Register                           -->
    <!-- 4000580C  PWM                             0  PWM_EC_Only            Reserved                                             -->
    <!-- 40005810  PWM                             1  PWM_EC_Only            PWM Counter ON Time Register                         -->
    <!-- 40005814  PWM                             1  PWM_EC_Only            PWM Counter OFF Time Register                        -->
    <!-- 40005818  PWM                             1  PWM_EC_Only            PWM Configuration Register                           -->
    <!-- 4000581C  PWM                             1  PWM_EC_Only            Reserved                                             -->
    <!-- 40005820  PWM                             2  PWM_EC_Only            PWM Counter ON Time Register                         -->
    <!-- 40005824  PWM                             2  PWM_EC_Only            PWM Counter OFF Time Register                        -->
    <!-- 40005828  PWM                             2  PWM_EC_Only            PWM Configuration Register                           -->
    <!-- 4000582C  PWM                             2  PWM_EC_Only            Reserved                                             -->
    <!-- 40005830  PWM                             3  PWM_EC_Only            PWM Counter ON Time Register                         -->
    <!-- 40005834  PWM                             3  PWM_EC_Only            PWM Counter OFF Time Register                        -->
    <!-- 40005838  PWM                             3  PWM_EC_Only            PWM Configuration Register                           -->
    <!-- 4000583C  PWM                             3  PWM_EC_Only            Reserved                                             -->
    <!--  -->
      <name>PWM</name>
      <version>1.0</version>
      <description>This block generates a PWM output that can be used to control 4-wire fans,\n
       blinking LEDs, and other similar devices. Each PWM can generate an arbitrary duty cycle output\n
       at frequencies from less than 0.1 Hz to 24 MHz. The PWM controller can also used to generate the\n
       PROCHOT output and Speaker output.
      </description>
      <groupName>PWM</groupName>
      <baseAddress>0x40005800</baseAddress>
      <size>32</size>
      <access>read-write</access>

      <addressBlock>
        <offset>0</offset>
        <size>0x040</size>
        <usage>registers</usage>
      </addressBlock>

      <interrupt>
        <name>PWM_WDT0</name>
        <description>PWM_WDT0 Interrupt .................... Also see GIRQ 17.26</description>
        <value>44</value>
      </interrupt>

      <interrupt>
        <name>PWM_WDT1</name>
        <description>PWM_WDT1 Interrupt .................... Also see GIRQ 17.27</description>
        <value>45</value>
      </interrupt>

      <interrupt>
        <name>PWM_WDT2</name>
        <description>PWM_WDT2 Interrupt .................... Also see GIRQ 17.28</description>
        <value>46</value>
      </interrupt>

      <interrupt>
        <name>PWM_WDT3</name>
        <description>PWM_WDT3 Interrupt .................... Also see GIRQ 18.4</description>
        <value>85</value>
      </interrupt>

      <registers>
        <cluster>
          <dim>4</dim>
          <dimIncrement>0x10</dimIncrement>
          <dimIndex>0-3</dimIndex>
          <name>CH[%s]</name>
          <description>Channel implemented will have these registers to determine that channel's operation.
          </description>
          <addressOffset>0x000</addressOffset>

          <!-- PWMx Counter ON Time Register -->
          <register>
            <name>COUNTER_ON_TIME</name>
            <description>This field determine both the frequency and duty cycle of the PWM signal. When this field is set to zero and the PWMX_COUNTER_OFF_-TIME is not set to zero, the PWM_OUTPUT is held low (Full Off).
            </description>
            <addressOffset>0x00</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
          </register>

          <!-- PWMx Counter OFF Time Register -->
          <register>
            <name>COUNTER_OFF_TIME</name>
            <description>This field determine both the frequency and duty cycle of the PWM signal. When this field is set to zero, the PWM_OUTPUT is held high (Full On).
            </description>
            <addressOffset>0x04</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
          </register>

          <!-- PWMx Configuration Register -->
          <register>
            <name>CONFIG</name>
            <description>PWMx CONFIGURATION REGISTER
            </description>
            <addressOffset>0x08</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>

            <fields>

              <!-- PWM_ENABLE -->
              <field>
                <name>EN</name>
                <description>PWM_ENABLE 1=Enabled (default), 0=Disabled (gates clocks to save power)
                </description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>

              <!-- CLOCK_SELECT -->
              <field>
                <name>CLK_SELECT</name>
                <description>CLOCK_SELECT This bit determines the clock source used by the PWM duty cycle and frequency control logic.\n
                 1=CLOCK_LOW\n
                 0=CLOCK_HIGH
                </description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>

              <!-- INVERT -->
              <field>
                <name>INVERT</name>
                <description>INVERT 1= PWM_OUTPUT ON State is active low, 0=PWM_OUTPUT ON State is active high
                </description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>

              <!-- CLOCK_PRE_DIVIDER -->
              <field>
                <name>CLK_PRE_DIVIDER</name>
                <description>The Clock source is then divided by the value of Pre-Divider+1 and the resulting signal determines the rate at which the down counter will be decremented.
                </description>
                <bitRange>[6:3]</bitRange>
                <access>read-write</access>
              </field>

            </fields>
          </register>
        </cluster>
      </registers>
    </peripheral>
    <!--  -->

    <peripheral>
    <!-- < Chapter 26.0>  RPM-PWM Interface -->
    <!-- 4000A000  RPM Fan Control                 0  RPM_FAN                Fan Setting                                          -->
    <!-- 4000A001  RPM Fan Control                 0  RPM_FAN                PWM Divide                                           -->
    <!-- 4000A002  RPM Fan Control                 0  RPM_FAN                Fan Configuration 1                                  -->
    <!-- 4000A003  RPM Fan Control                 0  RPM_FAN                Fan Configuration 2                                  -->
    <!-- 4000A004  RPM Fan Control                 0  RPM_FAN                MCHP Reserved                       (*MCHP Reserved) -->
    <!-- 4000A005  RPM Fan Control                 0  RPM_FAN                Gain                                                 -->
    <!-- 4000A006  RPM Fan Control                 0  RPM_FAN                Fan Spin Up Configuration                            -->
    <!-- 4000A007  RPM Fan Control                 0  RPM_FAN                Fan Step                                             -->
    <!-- 4000A008  RPM Fan Control                 0  RPM_FAN                Fan Minimum Drive                                    -->
    <!-- 4000A009  RPM Fan Control                 0  RPM_FAN                Valid Tach Count                                     -->
    <!-- 4000A00A  RPM Fan Control                 0  RPM_FAN                Fan Drive Fail Band Low Byte                         -->
    <!-- 4000A00B  RPM Fan Control                 0  RPM_FAN                Fan Drive Fail Band High Byte                        -->
    <!-- 4000A00C  RPM Fan Control                 0  RPM_FAN                Tach Target Low Byte                                 -->
    <!-- 4000A00D  RPM Fan Control                 0  RPM_FAN                Tach Target High Byte                                -->
    <!-- 4000A00E  RPM Fan Control                 0  RPM_FAN                Tach Reading Low Byte                                -->
    <!-- 4000A00F  RPM Fan Control                 0  RPM_FAN                Tach Reading High Byte                               -->
    <!-- 4000A010  RPM Fan Control                 0  RPM_FAN                PWM Driver Base Frequency                            -->
    <!-- 4000A011  RPM Fan Control                 0  RPM_FAN                Fan Status                                           -->
    <!-- 4000A012  RPM Fan Control                 0  RPM_FAN                Reserved                            (*MCHP Reserved) -->
    <!-- 4000A014  RPM Fan Control                 0  RPM_FAN                RPM Fan Test                        (*MCHP Reserved) -->
    <!-- 4000A015  RPM Fan Control                 0  RPM_FAN                RPM Fan Test1                       (*MCHP Reserved) -->
    <!-- 4000A016  RPM Fan Control                 0  RPM_FAN                RPM Fan Test2                       (*MCHP Reserved) -->
    <!-- 4000A017  RPM Fan Control                 0  RPM_FAN                RPM Fan Test3                       (*MCHP Reserved) -->
    <!--  -->
      <name>FAN</name>
      <version>1.0</version>
      <description>The RPM-PWM Interface is an RPM based Fan Control Algorithm that monitors\n
       the fan's speed and automatically adjusts the drive to maintain the desired fan speed. This\n
       RPM based Fan Control Algorithm controls a PWM output based on a tachometer input.
      </description>
      <groupName>RPM</groupName>
      <baseAddress>0x4000A000</baseAddress>
      <size>32</size>
      <access>read-write</access>

      <addressBlock>
        <offset>0</offset>
        <size>0x020</size>
        <usage>registers</usage>
      </addressBlock>

      <interrupt>
        <name>RPM_Stall</name>
        <description>RPM_INT Stall Interrupt ............... Also see GIRQ 17.23</description>
        <value>41</value>
      </interrupt>

      <interrupt>
        <name>RPM_Spin</name>
        <description>RPM_INT Spin Interrupt ................ Also see GIRQ 17.24</description>
        <value>42</value>
      </interrupt>

      <registers>
        <!-- Fan Setting -->
        <register>
          <name>SETTING</name>
          <description>The Fan Driver Setting used to control the output of the Fan Driver. \n
           The contents of the register represent the weighting of each bit in determining the final duty cycle. The output drive for a PWM output is given by the following equation:\n
           - Drive = (FAN_SETTING VALUE/255) x 100%.
          </description>
          <addressOffset>0x00</addressOffset>
          <size>8</size>
          <access>read-write</access>
          <resetValue>0x00</resetValue>
          <resetMask>0xFF</resetMask>
        </register>

        <!-- PWM Divide -->
        <register>
          <name>PWM_DIVIDE</name>
          <description>The final PWM frequency is derived as the base frequency divided by the value of this register as shown in the equation below:
           - PWM_Frequency = base_clk / PWM_D \n
           Where: \n
           - base_clk = The base frequency set by the PWMx_CFG[1:0] bits \n
           - PWM_D = the divide setting set by the PWM Divide Register.
          </description>
          <addressOffset>0x01</addressOffset>
          <size>8</size>
          <access>read-write</access>
          <resetValue>0x00</resetValue>
          <resetMask>0xFF</resetMask>
        </register>

        <!-- Fan Configuration -->
        <register>
          <name>CONFIGURATION</name>
          <description>The Fan Configuration Register controls the general operation of the RPM based Fan Control Algorithm used by the fan driver.
          </description>
          <addressOffset>0x02</addressOffset>
          <size>16</size>
          <access>read-write</access>
          <resetValue>0x1C17</resetValue>
          <resetMask>0xFFFF</resetMask>

          <fields>
            <!-- UPDATE[2:0] -->
            <field>
              <name>UPDATE</name>
              <description>Determines the base time between fan driver updates.
              </description>
              <bitRange>[2:0]</bitRange>
              <access>read-write</access>
            </field>

            <!-- EDGES[1:0] -->
            <field>
              <name>EDGES</name>
              <description>Determines the minimum number of edges that must be detected on the TACH signal to determine a single rotation. A typical fan measured 5 edges (for a 2-pole fan).
              </description>
              <bitRange>[4:3]</bitRange>
              <access>read-write</access>
            </field>

            <!-- RANGE[1:0] -->
            <field>
              <name>RANGE</name>
              <description>Adjusts the range of reported and programmed tachometer reading values.
              </description>
              <bitRange>[6:5]</bitRange>
              <access>read-write</access>
            </field>

            <!-- EN_ALGO -->
            <field>
              <name>EN_ALGO</name>
              <description>Enables the RPM based Fan Control Algorithm.
              </description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>

            <!-- POLARITY -->
            <field>
              <name>POLARITY</name>
              <description>Determines the polarity of the PWM driver.\n
               0 (default) - the Polarity of the PWM driver is normal.\n
               1 - The Polarity of the PWM driver is inverted.
              </description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>

            <!-- ERR_RNG -->
            <field>
              <name>ERR_RNG</name>
              <description>Control some of the advanced options that affect the error window.
              </description>
              <bitRange>[10:9]</bitRange>
              <access>read-write</access>
            </field>

            <!-- DER_OPT -->
            <field>
              <name>DER_OPT</name>
              <description>Control some of the advanced options that affect the derivative portion of the RPM based fan control algorithm
              </description>
              <bitRange>[12:11]</bitRange>
              <access>read-write</access>
            </field>

            <!-- DIS_GLITCH -->
            <field>
              <name>DIS_GLITCH</name>
              <description>Disables the low pass glitch filter that removes high frequency noise injected on the TACH pin.\n
               0 (default) - The glitch filter is enabled.\n
               1 - The glitch filter is disabled.
              </description>
              <bitRange>[13:13]</bitRange>
              <access>read-write</access>
            </field>

            <!-- EN_RRC -->
            <field>
              <name>EN_RRC</name>
              <description>Enables the ramp rate control circuitry during the Manual Mode of operation.
              </description>
              <bitRange>[14:14]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>

        <!-- Gain -->
        <register>
          <name>GAIN</name>
          <description>Gain Register stores the gain terms used by the proportional and integral portions of the RPM based Fan Control Algorithm.
          </description>
          <addressOffset>0x05</addressOffset>
          <size>8</size>
          <access>read-write</access>
          <resetValue>0x00</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <!-- GAINP[1:0] -->
            <field>
              <name>GAINP</name>
              <description>derivative gain term
              </description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
            </field>

            <!-- GAINI[1:0] -->
            <field>
              <name>GAINI</name>
              <description>derivative gain term
              </description>
              <bitRange>[3:2]</bitRange>
              <access>read-write</access>
            </field>

            <!-- GAIND[1:0] -->
            <field>
              <name>GAIND</name>
              <description>derivative gain term
              </description>
              <bitRange>[5:4]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>

        <!-- Fan Spin Up Configuration -->
        <register>
          <name>SPIN_UP_CONFIGURATION</name>
          <description>The Fan Spin Up Configuration Register controls the settings of Spin Up Routine.
          </description>
          <addressOffset>0x06</addressOffset>
          <size>8</size>
          <access>read-write</access>
          <resetValue>0x19</resetValue>
          <resetMask>0xFF</resetMask>

          <fields>
            <!-- SPINUP_TIME[1:0] -->
            <field>
              <name>SPINUP_TIME</name>
              <description>Determines the maximum Spin Time that the Spin Up Routine will run for
              </description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
            </field>

            <!-- SPIN_LVL[2:0] -->
            <field>
              <name>SPIN_LVL</name>
              <description>Determines the final drive level that is used by the Spin Up Routine
              </description>
              <bitRange>[4:2]</bitRange>
              <access>read-write</access>
            </field>

            <!-- NOKICK -->
            <field>
              <name>NOKICK</name>
              <description>Determines if the Spin Up Routine will drive the fan to 100% duty cycle for 1/4 of the programmed spin up time before driving it at the programmed level.
              </description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>

            <!-- DRIVE_FAIL_CNT[1:0] -->
            <field>
              <name>DRIVE_FAIL_CNT</name>
              <description>Determines how many update cycles are used for the Drive Fail detection function
              </description>
              <bitRange>[7:6]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>

        <!-- Fan Step -->
        <register>
          <name>STEP</name>
          <description>FAN_STEP[5:0] The Fan Step value represents the maximum step size the fan driver will take between update times
          </description>
          <addressOffset>0x07</addressOffset>
          <size>8</size>
          <access>read-write</access>
          <resetValue>0x10</resetValue>
          <resetMask>0xFF</resetMask>
        </register>

        <!-- Fan Minimum Drive -->
        <register>
          <name>MINIMUM_DRIVE</name>
          <description>the minimum drive setting for the RPM based Fan Control Algorithm.
          </description>
          <addressOffset>0x08</addressOffset>
          <size>8</size>
          <access>read-write</access>
          <resetValue>0x66</resetValue>
          <resetMask>0xFF</resetMask>
        </register>

        <!-- Valid Tach Count -->
        <register>
          <name>VALID_TACH_COUNT</name>
          <description>The maximum TACH Reading Register value to indicate that the fan is spinning properly.
          </description>
          <addressOffset>0x09</addressOffset>
          <size>8</size>
          <access>read-write</access>
          <resetValue>0xF5</resetValue>
          <resetMask>0xFF</resetMask>
        </register>

        <!-- Fan Drive Fail Band -->
        <register>
          <name>DRIVE_FAIL_BAND</name>
          <description>[15:3] The number of Tach counts used by the Fan Drive Fail detection circuitry
          </description>
          <addressOffset>0x0A</addressOffset>
          <size>16</size>
          <access>read-write</access>
          <resetValue>0x00</resetValue>
          <resetMask>0xFF</resetMask>
        </register>

        <!-- Tach Target -->
        <register>
          <name>TACH_TARGET</name>
          <description>[12:0] The target tachometer value.
          </description>
          <addressOffset>0x0C</addressOffset>
          <size>16</size>
          <access>read-write</access>
          <resetValue>0xFFF8</resetValue>
          <resetMask>0xFFFF</resetMask>
        </register>

        <!-- Tach Reading -->
        <register>
          <name>TACH_READING</name>
          <description>[15:3] The current tachometer reading value.
          </description>
          <addressOffset>0x0E</addressOffset>
          <size>8</size>
          <access>read-write</access>
          <resetValue>0xFFF8</resetValue>
          <resetMask>0xFFFF</resetMask>
        </register>

        <!-- PWM Driver Base Frequency -->
        <register>
          <name>DRIVER_BASE_FREQUENCY</name>
          <description>[1:0] Determines the frequency range of the PWM fan driver
          </description>
          <addressOffset>0x10</addressOffset>
          <size>8</size>
          <access>read-write</access>
          <resetValue>0x00</resetValue>
          <resetMask>0xFF</resetMask>
        </register>

        <!-- Fan Status -->
        <register>
          <name>STATUS</name>
          <description>The bits in this register are routed to interrupts.
          </description>
          <addressOffset>0x11</addressOffset>
          <size>8</size>
          <access>read-write</access>
          <resetValue>0x00</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <!-- FAN_STALL -->
            <field>
              <name>FAN_STALL</name>
              <description>0 - Stalled fan not detected.\n
               1 - Stalled fan detected. (R/WC)
              </description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>

            <!-- FAN_SPIN -->
            <field>
              <name>FAN_SPIN</name>
              <description>0 - The Spin up Routine for the Fan detected a valid tachometer reading within its maximum time window.
               1 - The Spin up Routine for the Fan could not detect a valid tachometer reading within its maximum time window. (R/WC)
              </description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>

            <!-- DRIVE_FAIL -->
            <field>
              <name>DRIVE_FAIL</name>
              <description>0- The RPM-based Fan Speed Control Algorithm can drive Fan to the desired target setting.\n
               1- The RPM-based Fan Speed Control Algorithm cannot drive Fan to the desired target setting at maximum drive.(R/WC)
              </description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>

          </fields>
        </register>
      </registers>
    </peripheral>
    <!--  -->

    <peripheral>
    <!-- < Chapter 27.0>  General Purpose Serial Peripheral Interface (GP-SPI) -->
    <!-- 40009400  EC GP-SPI                       0  GP-SPI_EC_Only         SPI Enable Register                                  -->
    <!-- 40009404  EC GP-SPI                       0  GP-SPI_EC_Only         SPI Control Register                                 -->
    <!-- 40009408  EC GP-SPI                       0  GP-SPI_EC_Only         SPI Status Register                                  -->
    <!-- 4000940C  EC GP-SPI                       0  GP-SPI_EC_Only         SPI TX_Data Register                                 -->
    <!-- 40009410  EC GP-SPI                       0  GP-SPI_EC_Only         SPI RX_Data Register                                 -->
    <!-- 40009414  EC GP-SPI                       0  GP-SPI_EC_Only         SPI Clock Control Register                           -->
    <!-- 40009418  EC GP-SPI                       0  GP-SPI_EC_Only         SPI Clock Generator Register                         -->
    <!-- 40009480  EC GP-SPI                       1  GP-SPI_EC_Only         SPI Enable Register                                  -->
    <!-- 40009484  EC GP-SPI                       1  GP-SPI_EC_Only         SPI Control Register                                 -->
    <!-- 40009488  EC GP-SPI                       1  GP-SPI_EC_Only         SPI Status Register                                  -->
    <!-- 4000948C  EC GP-SPI                       1  GP-SPI_EC_Only         SPI TX_Data Register                                 -->
    <!-- 40009490  EC GP-SPI                       1  GP-SPI_EC_Only         SPI RX_Data Register                                 -->
    <!-- 40009494  EC GP-SPI                       1  GP-SPI_EC_Only         SPI Clock Control Register                           -->
    <!-- 40009498  EC GP-SPI                       1  GP-SPI_EC_Only         SPI Clock Generator Register                         -->
    <!--  -->
      <name>SPI</name>
      <version>1.0</version>
      <description>The General Purpose Serial Peripheral Interface (GP-SPI) may be used\n
       to communicate with various peripheral devices, e.g., EEPROMS, DACs, ADCs, that use a\n
       standard Serial Peripheral Interface.
      </description>
      <groupName>SPI</groupName>
      <baseAddress>0x40009400</baseAddress>
      <size>32</size>
      <access>read-write</access>

      <addressBlock>
        <offset>0</offset>
        <size>0x0A0</size>
        <usage>registers</usage>
      </addressBlock>

      <interrupt>
        <name>SPI0_TX</name>
        <description>SPI0 TX Interrupt ..................... Also see GIRQ 18.0</description>
        <value>36</value>
      </interrupt>

      <interrupt>
        <name>SPI0_RX</name>
        <description>SPI0 RX Interrupt ..................... Also see GIRQ 18.1</description>
        <value>37</value>
      </interrupt>

      <interrupt>
        <name>SPI1_TX</name>
        <description>SPI1 TX Interrupt ..................... Also see GIRQ 18.2</description>
        <value>55</value>
      </interrupt>

      <interrupt>
        <name>SPI1_RX</name>
        <description>SPI1 RX Interrupt ..................... Also see GIRQ 18.3</description>
        <value>56</value>
      </interrupt>

      <registers>
        <cluster>
          <dim>2</dim>
          <dimIncrement>0x80</dimIncrement>
          <dimIndex>0,1</dimIndex>
          <name>CH[%s]</name>
          <description>Channel implemented will have these registers to determine that channel's operation.
          </description>
          <addressOffset>0x000</addressOffset>

          <!-- SPI Enable Register -->
          <register>
            <name>ENABLE</name>
            <description>[0:0]  1=Enabled. The device is fully operational\n
             0=Disabled. Clocks are gated to conserve power and the SPDOUT and SPI_CLK signals are set to their inactive state
            </description>
            <addressOffset>0x00</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x000F</resetValue>
            <resetMask>0xFFFF</resetMask>
          </register>

          <!-- SPI Control Register -->
          <register>
            <name>CONTROL</name>
            <description>SPI Control
            </description>
            <addressOffset>0x04</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x00000002</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <!-- LSBF -->
              <field>
                <name>LSBF</name>
                <description>Least Significant Bit First\n
                 1= The data is transferred in LSB-first order.\n
                 0= The data is transferred in MSB-first order. (default)
                </description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>

              <!-- BIOEN -->
              <field>
                <name>BIOEN</name>
                <description>Bidirectional Output Enable control.\n
                 1=The SPDOUT_Direction signal configures the SPDOUT signal as an output.\n
                 0=The SPDOUT_Direction signal configures the SPDOUT signal as an input.
                </description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>

              <!-- SPDIN_SELECT -->
              <field>
                <name>SPDIN_SELECT</name>
                <description>[3:2] 1xb=SPDIN1 and SPDIN2. Select this option for Dual Mode\n
                 [3:2] 01b=SPDIN2 only. Select this option for Half Duplex\n
                 [3:2] 00b=SPDIN1 only. Select this option for Full Duplex
                </description>
                <bitRange>[3:2]</bitRange>
                <access>read-write</access>
              </field>

              <!-- SOFT_RESET -->
              <field>
                <name>SOFT_RESET</name>
                <description>Soft Reset is a self-clearing bit. Writing zero to this bit has no effect. Writing a one to this bit resets the entire SPI Interface, including all counters and registers back to their initial state.
                </description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>

              <!-- AUTO_READ -->
              <field>
                <name>AUTO_READ</name>
                <description>Auto Read Enable.\n
                 1=A read of the SPI RX_DATA Register will clear both the RXBF status bit and the TXBE status bit\n
                 0=A read of the SPI RX_DATA Register will clear the RXBF status bit. The TXBE status bit will not be modified
                </description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>

              <!-- CE -->
              <field>
                <name>CE</name>
                <description>SPI Chip Select Enable.\n
                 1= SPI_CS# output signal is asserted, i.e., driven to logic '0' \n
                 0= SPI_CS# output signal is deasserted, i.e., driven to logic '1'
                </description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>

          <!-- SPI Status Register -->
          <register>
            <name>STATUS</name>
            <description>SPI Status
            </description>
            <addressOffset>0x08</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>

            <fields>
              <!-- TXBE -->
              <field>
                <name>TXBE</name>
                <description>1=TX_Data buffer is empty, 0=TX_Data buffer is not empty
                </description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>

              <!-- RXBF -->
              <field>
                <name>RXBF</name>
                <description>1=RX_Data buffer is full, 0=RX_Data buffer is not full
                </description>
                <bitRange>[1:1]</bitRange>
                <access>read-only</access>
              </field>

              <!-- ACTIVE -->
              <field>
                <name>ACTIVE</name>
                <description>ACTIVE status
                </description>
                <bitRange>[2:2]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>

          <!-- SPI TX_Data Register -->
          <register>
            <name>TX_DATA</name>
            <description>[7:0]  A write to this register when the Tx_Data buffer is empty (TXBE in the SPI Status Register is '1') initiates a SPI transaction.
            </description>
            <addressOffset>0x0C</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
          </register>

          <!-- SPI RX_Data Register -->
          <register>
            <name>RX_DATA</name>
            <description>[7:0] This register is used to read the value returned by the external SPI device.
            </description>
            <addressOffset>0x10</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
          </register>

          <!-- SPI Clock Control Register -->
          <register>
            <name>CLOCK_Control</name>
            <description>SPI Clock Control. This register should not be changed during an active SPI transaction.
            </description>
            <addressOffset>0x14</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <!-- TCLKPH -->
              <field>
                <name>TCLKPH</name>
                <description>1=Valid data is clocked out on the first SPI_CLK edge on SPDOUT signal. The slave device should sample this data on the second and following even SPI_CLK edges (i.e., sample data on falling edge)\n
                 0=Valid data is clocked out on the SPDOUT signal prior to the first SPI_CLK edge. The slave device should sample this data on the first and following odd SPI_CLK edges (i.e., sample data on rising edge)
                </description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>

              <!-- RCLKPH -->
              <field>
                <name>RCLKPH</name>
                <description>1=Valid data on SPDIN signal is expected after the first SPI_CLK edge. This data is sampled on the second and following even SPI_CLK edges (i.e., sample data on falling edge)\n
                 0=Valid data is expected on the SPDIN signal on the first SPI_CLK edge. This data is sampled on the first and following odd SPI_-CLK edges (i.e., sample data on rising edge)
                </description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>

              <!-- CLKPOL -->
              <field>
                <name>CLKPOL</name>
                <description>1=The SPI_CLK signal is high when the interface is idle and the first clock edge is a falling edge\n
                0=The SPI_CLK is low when the interface is idle and the first clock edge is a rising edge
                </description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>

              <!-- CLKSRC -->
              <field>
                <name>CLKSRC</name>
                <description>1=2MHz, 0=48 MHz Ring Oscillator
                </description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>

            </fields>
          </register>

          <!-- SPI Clock Generator Register -->
          <register>
            <name>CLOCK_GENERATOR</name>
            <description>[5:0] PRELOAD SPI Clock Generator Preload value.
            </description>
            <addressOffset>0x18</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x00000002</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
          </register>
        </cluster>
      </registers>
    </peripheral>
    <!--  -->

    <peripheral>
    <!-- < Chapter 28.0>  Blinking/Breathing PWM -->
    <!-- 4000B800  LED                             0  EC-Only Registers      LED Configuration                                    -->
    <!-- 4000B804  LED                             0  EC-Only Registers      LED Limits                                           -->
    <!-- 4000B808  LED                             0  EC-Only Registers      LED Delay                                            -->
    <!-- 4000B80C  LED                             0  EC-Only Registers      LED Update Stepsize                                  -->
    <!-- 4000B810  LED                             0  EC-Only Registers      LED Update Interval                                  -->
    <!-- 4000B900  LED                             1  EC-Only Registers      LED Configuration                                    -->
    <!-- 4000B904  LED                             1  EC-Only Registers      LED Limits                                           -->
    <!-- 4000B908  LED                             1  EC-Only Registers      LED Delay                                            -->
    <!-- 4000B90C  LED                             1  EC-Only Registers      LED Update Stepsize                                  -->
    <!-- 4000B910  LED                             1  EC-Only Registers      LED Update Interval                                  -->
    <!-- 4000BA00  LED                             2  EC-Only Registers      LED Configuration                                    -->
    <!-- 4000BA04  LED                             2  EC-Only Registers      LED Limits                                           -->
    <!-- 4000BA08  LED                             2  EC-Only Registers      LED Delay                                            -->
    <!-- 4000BA0C  LED                             2  EC-Only Registers      LED Update Stepsize                                  -->
    <!-- 4000BA10  LED                             2  EC-Only Registers      LED Update Interval                                  -->
    <!-- 4000BB00  LED                             3  EC-Only Registers      LED Configuration                                    -->
    <!-- 4000BB04  LED                             3  EC-Only Registers      LED Limits                                           -->
    <!-- 4000BB08  LED                             3  EC-Only Registers      LED Delay                                            -->
    <!-- 4000BB0C  LED                             3  EC-Only Registers      LED Update Stepsize                                  -->
    <!-- 4000BB10  LED                             3  EC-Only Registers      LED Update Interval                                  -->
    <!--  -->
      <name>LED</name>
      <version>1.0</version>
      <description>The blinking/breathing hardware is implemented using a PWM. The PWM can be\n
       driven either by the 48 MHz clock or by a 32.768 KHz clock input. When driven by the 48 MHz clock,\n
       the PWM can be used as a standard 8-bit PWM in order to control a fan. When used to drive blinking\n
       or breathing LEDs, the 32.768 KHz clock source is used.
      </description>
      <groupName>LED</groupName>
      <baseAddress>0x4000B800</baseAddress>
      <size>32</size>
      <access>read-write</access>

      <addressBlock>
        <offset>0</offset>
        <size>0x014</size>
        <usage>registers</usage>
      </addressBlock>

      <registers>
        <cluster>
          <dim>4</dim>
          <dimIncrement>0x100</dimIncrement>
          <dimIndex>0-3</dimIndex>
          <name>CH[%s]</name>
          <description>Channel implemented will have these registers to determine that channel's operation.
          </description>
          <addressOffset>0x000</addressOffset>

          <!-- LED Configuration -->
          <register>
            <name>CONFIG</name>
            <description>LED Configuration
            </description>
            <addressOffset>0x00</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>

            <fields>
              <!-- CONTROL -->
              <field>
                <name>CONTROL</name>
                <description>CONTROL 3=PWM is always on\n
                 2=LED blinking (standard PWM)\n
                 1=LED breathing configuration\n
                 0=PWM is always off. All internal registers and counters are reset to 0. Clocks are gated
                </description>
                <bitRange>[1:0]</bitRange>
                <access>read-write</access>
              </field>

              <!-- CLOCK_SOURCE -->
              <field>
                <name>CLOCK_SOURCE</name>
                <description>1=Clock source is the 48 MHz clock, 0=Clock source is the 32.768 KHz clock
                </description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>

              <!-- SYNCHRONIZE -->
              <field>
                <name>SYNCHRONIZE</name>
                <description>SYNCHRONIZE  When this bit is '1', all counters for all LEDs are reset to their initial values. When this bit is '0' in the LED Configuration Register for all LEDs, then all counters for LEDs that are configured to blink or breathe will increment or decrement, as required. 
                </description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>

              <!-- PWM_SIZE -->
              <field>
                <name>PWM_SIZE</name>
                <description>PWM_SIZE This bit controls the behavior of PWM:\n
                 3=Reserved\n
                 2=PWM is configured as a 6-bit PWM\n
                 1=PWM is configured as a 7-bit PWM\n
                 0=PWM is configured as an 8-bit PWM
                </description>
                <bitRange>[5:4]</bitRange>
                <access>read-write</access>
              </field>

              <!-- ENABLE_UPDATE -->
              <field>
                <name>ENABLE_UPDATE</name>
                <description>ENABLE_UPDATE  This bit is set to 1 when written with a '1'. Writes of '0' have no effect. Hardware clears this bit to 0 when the breathing configuration registers are updated at the end of a PWM period. The current state of the bit is readable any time. 
                </description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>

              <!-- RESET -->
              <field>
                <name>RESET</name>
                <description>RESET  Writes of '1' to this bit resets the PWM registers to their default values. This bit is self clearing. Writes of '0' to this bit have no effect.
                </description>
                <bitRange>[7:7]</bitRange>
                <access>write</access>
              </field>

              <!-- WDT_RELOAD -->
              <field>
                <name>WDT_RELOAD</name>
                <description>WDT_RELOAD  The PWM Watchdog Timer counter reload value. On system reset, it defaults to 14h, which corresponds to a 4 second Watchdog timeout value.
                </description>
                <bitRange>[15:8]</bitRange>
                <access>read-write</access>
              </field>

              <!-- SYMMETRY -->
              <field>
                <name>SYMMETRY</name>
                <description>SYMMETRY  1=The rising and falling ramp times are in Asymmetric mode.\n
                 0=The rising and falling ramp times are in Symmetric mode.
                </description>
                <bitRange>[16:16]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>

          <!-- LED Limits -->
          <register>
            <name>LIMITS</name>
            <description>LED Limits This register may be written at any time. Values written into the register are held in an holding register, which is transferred into the actual register at the end of a PWM period. The two byte fields may be written independently. Reads of this register return the current contents and not the value of the holding register. 
            </description>
            <addressOffset>0x04</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>

            <fields>
              <!-- MINIMUM -->
              <field>
                <name>MINIMUM</name>
                <description>In breathing mode, when the current duty cycle is less than or equal to this value the breathing apparatus holds the current duty cycle for the period specified by the field LD in register LED_DELAY, then starts incrementing the current duty cycle In blinking mode, this field defines the duty cycle of the blink function. 
                </description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>

              <!-- MAXIMUM -->
              <field>
                <name>MAXIMUM</name>
                <description>In breathing mode, when the current duty cycle is greater than or equal to this value the breathing apparatus holds the current duty cycle for the period specified by the field HD in register LED_DELAY, then starts decrementing the current duty cycle 
                </description>
                <bitRange>[15:8]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>

          <!-- LED Delay -->
          <register>
            <name>DELAY</name>
            <description>LED Delay
            </description>
            <addressOffset>0x08</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>

            <fields>
              <!-- LOW_DELAY -->
              <field>
                <name>LOW</name>
                <description>The number of PWM periods to wait before updating the current duty cycle when the current duty cycle is greater than or equal to the value MIN in register LED_LIMIT. 
                </description>
                <bitRange>[11:0]</bitRange>
                <access>read-write</access>
              </field>

              <!-- HIGH_DELAY -->
              <field>
                <name>HIGH</name>
                <description>In breathing mode, the number of PWM periods to wait before updating the current duty cycle when the current duty cycle is greater than or equal to the value MAX in register LED_LIMIT. 
                </description>
                <bitRange>[23:12]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>

          <!-- LED Update Stepsize -->
          <register>
            <name>UPDATE_STEPSIZE</name>
            <description>This register has eight segment fields which provide the amount the current duty cycle is adjusted at the end of every PWM period. Segment field selection is decoded based on the segment index. The segment index equation utilized depends on the SYMMETRY bit in the LED Configuration Register Register)
             . In Symmetric Mode the Segment_Index[2:0] = Duty Cycle Bits[7:5]\n
             . In Asymmetric Mode the Segment_Index[2:0] is the bit concatenation of following: Segment_Index[2] = (FALLING RAMP TIME in Figure 30-3, "Clipping Example") and Segment_Index[1:0] = Duty Cycle Bits[7:6].
            </description>
            <addressOffset>0x0C</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>

            <fields>
              <!-- UPDATE_STEP0 -->
              <field>
                <name>STEP0</name>
                <description>Amount the current duty cycle is adjusted at the end of every PWM period when the segment index is equal to 000.
                </description>
                <bitRange>[3:0]</bitRange>
                <access>read-write</access>
              </field>

              <!-- UPDATE_STEP1 -->
              <field>
                <name>STEP1</name>
                <description>Amount the current duty cycle is adjusted at the end of every PWM period when the segment index is equal to 001.
                </description>
                <bitRange>[7:4]</bitRange>
                <access>read-write</access>
              </field>

              <!-- UPDATE_STEP2 -->
              <field>
                <name>STEP2</name>
                <description>Amount the current duty cycle is adjusted at the end of every PWM period when the segment index is equal to 010.
                </description>
                <bitRange>[11:8]</bitRange>
                <access>read-write</access>
              </field>

              <!-- UPDATE_STEP3 -->
              <field>
                <name>STEP3</name>
                <description>Amount the current duty cycle is adjusted at the end of every PWM period when the segment index is equal to 011.
                </description>
                <bitRange>[15:12]</bitRange>
                <access>read-write</access>
              </field>

              <!-- UPDATE_STEP4 -->
              <field>
                <name>STEP4</name>
                <description>Amount the current duty cycle is adjusted at the end of every PWM period when the segment index is equal to 100.
                </description>
                <bitRange>[19:16]</bitRange>
                <access>read-write</access>
              </field>

              <!-- UPDATE_STEP5 -->
              <field>
                <name>STEP5</name>
                <description>Amount the current duty cycle is adjusted at the end of every PWM period when the segment index is equal to 101
                </description>
                <bitRange>[23:20]</bitRange>
                <access>read-write</access>
              </field>

              <!-- UPDATE_STEP6 -->
              <field>
                <name>STEP6</name>
                <description>Amount the current duty cycle is adjusted at the end of every PWM period when the segment index is equal to 110.
                </description>
                <bitRange>[27:24]</bitRange>
                <access>read-write</access>
              </field>

              <!-- UPDATE_STEP7 -->
              <field>
                <name>STEP7</name>
                <description>Amount the current duty cycle is adjusted at the end of every PWM period when the segment index is equal to 111.
                </description>
                <bitRange>[31:28]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>

          <!-- LED Update Interval -->
          <register>
            <name>UPDATE_INTERVAL</name>
            <description>LED Update Interval
            </description>
            <addressOffset>0x10</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>

            <fields>

              <!-- UPDATE_INTERVAL0 -->
              <field>
                <name>INTERVAL0</name>
                <description>The number of PWM periods between updates to current duty cycle when the segment index is equal to 000b.
                </description>
                <bitRange>[3:0]</bitRange>
                <access>read-write</access>
              </field>

              <!-- UPDATE_INTERVAL1 -->
              <field>
                <name>INTERVAL1</name>
                <description>The number of PWM periods between updates to current duty cycle when the segment index is equal to 001b.
                </description>
                <bitRange>[7:4]</bitRange>
                <access>read-write</access>
              </field>

              <!-- UPDATE_INTERVAL2 -->
              <field>
                <name>INTERVAL2</name>
                <description>The number of PWM periods between updates to current duty cycle when the segment index is equal to 010b.
                </description>
                <bitRange>[11:8]</bitRange>
                <access>read-write</access>
              </field>

              <!-- UPDATE_INTERVAL3 -->
              <field>
                <name>INTERVAL3</name>
                <description>The number of PWM periods between updates to current duty cycle when the segment index is equal to 011b.
                </description>
                <bitRange>[15:12]</bitRange>
                <access>read-write</access>
              </field>

              <!-- UPDATE_INTERVAL4 -->
              <field>
                <name>INTERVAL4</name>
                <description>The number of PWM periods between updates to current duty cycle when the segment index is equal to 100b.
                </description>
                <bitRange>[19:16]</bitRange>
                <access>read-write</access>
              </field>

              <!-- UPDATE_INTERVAL5 -->
              <field>
                <name>INTERVAL5</name>
                <description>The number of PWM periods between updates to current duty cycle when the segment index is equal to 101b.
                </description>
                <bitRange>[23:20]</bitRange>
                <access>read-write</access>
              </field>

              <!-- UPDATE_INTERVAL6 -->
              <field>
                <name>UPDATE_INTERVAL6</name>
                <description>The number of PWM periods between updates to current duty cycle when the segment index is equal to 110b.
                </description>
                <bitRange>[27:24]</bitRange>
                <access>read-write</access>
              </field>

              <!-- UPDATE_INTERVAL7 -->
              <field>
                <name>INTERVAL7</name>
                <description>The number of PWM periods between updates to current duty cycle when the segment index is equal to 111b.
                </description>
                <bitRange>[31:28]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
      </registers>
    </peripheral>
    <!--  -->

    <peripheral>
    <!-- < Chapter 29.0>  PS/2 Device Interface -->
    <!-- 40009000  PS/2                            0  Registers              PS/2 Transmit Buffer Register                        -->
    <!-- 40009000  PS/2                            0  Registers              PS/2 Receive Buffer Register                         -->
    <!-- 40009004  PS/2                            0  Registers              PS/2 Control Register                                -->
    <!-- 40009008  PS/2                            0  Registers              PS/2 Status Register                                 -->
    <!-- 40009040  PS/2                            1  Registers              PS/2 Transmit Buffer Register                        -->
    <!-- 40009040  PS/2                            1  Registers              PS/2 Receive Buffer Register                         -->
    <!-- 40009044  PS/2                            1  Registers              PS/2 Control Register                                -->
    <!-- 40009048  PS/2                            1  Registers              PS/2 Status Register                                 -->
    <!-- 40009080  PS/2                            2  Registers              PS/2 Receive Buffer Register                         -->
    <!-- 40009080  PS/2                            2  Registers              PS/2 Transmit Buffer Register                        -->
    <!-- 40009084  PS/2                            2  Registers              PS/2 Control Register                                -->
    <!-- 40009088  PS/2                            2  Registers              PS/2 Status Register                                 -->
    <!-- 400090C0  PS/2                            3  Registers              PS/2 Transmit Buffer Register                        -->
    <!-- 400090C0  PS/2                            3  Registers              PS/2 Receive Buffer Register                         -->
    <!-- 400090C4  PS/2                            3  Registers              PS/2 Control Register                                -->
    <!-- 400090C8  PS/2                            3  Registers              PS/2 Status Register                                 -->
    <!--  -->
      <name>PS2</name>
      <version>1.0</version>
      <description>There are four PS/2 Ports in the MEC1320 which are directly controlled\n
       by the EC. The hardware implementation eliminates the need to bit bang I/O ports to generate\n
       PS/2 traffic, however bit banging is available via the associated GPIO pins.
      </description>
      <groupName>PS2</groupName>
      <baseAddress>0x40009000</baseAddress>
      <size>32</size>
      <access>read-write</access>

      <addressBlock>
        <offset>0</offset>
        <size>0x0100</size>
        <usage>registers</usage>
      </addressBlock>

      <interrupt>
        <name>PS2_0</name>
        <description>PS2_0 Interrupt ....................... Also see GIRQ 17.14</description>
        <value>32</value>
      </interrupt>

      <interrupt>
        <name>PS2_1</name>
        <description>PS2_1 Interrupt ....................... Also see GIRQ 17.15</description>
        <value>33</value>
      </interrupt>

      <interrupt>
        <name>PS2_2</name>
        <description>PS2_2 Interrupt ....................... Also see GIRQ 17.16</description>
        <value>34</value>
      </interrupt>

      <interrupt>
        <name>PS2_3</name>
        <description>PS2_3 Interrupt ....................... Also see GIRQ 17.17</description>
        <value>35</value>
      </interrupt>

      <registers>
        <cluster>
          <dim>4</dim>
          <dimIncrement>0x40</dimIncrement>
          <dimIndex>0-3</dimIndex>
          <name>CH[%s]</name>
          <description>Channel implemented will have these registers to determine that channel's operation.
          </description>
          <addressOffset>0x000</addressOffset>

          <!-- PS2 Transmit Buffer Register -->
          <register>
            <name>TX_DATA</name>
            <description>Writes to this register start a transmission of the data in this register to the peripheral
            </description>
            <addressOffset>0x00</addressOffset>
            <size>32</size>
            <access>write-only</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
          </register>

          <!-- PS2 Receive Buffer Register -->
          <register>
            <name>RX_DATA</name>
            <description>Data received from a peripheral are recorded in this register.
            </description>
            <addressOffset>0x00</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x000000FF</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
          </register>

          <!-- PS2 Control Register -->
          <register>
            <name>CONTROL</name>
            <description>PS2 Control Register
            </description>
            <addressOffset>0x04</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>

            <fields>
              <!-- PS2_T/R -->
              <field>
                <name>TR</name>
                <description>PS/2 Transmit/Receive \n
                 0=The P2/2 channel is enabled to receive data.\n
                 1=The PS2 channel is enabled to transmit data.
                </description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>

              <!-- PS2_EN -->
              <field>
                <name>EN</name>
                <description>PS/2 Enable. 0=The PS/2 state machine is disabled. 1=The PS/2 state machine is enabled.
                </description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>

              <!-- PARITY -->
              <field>
                <name>PARITY</name>
                <description>00b=Receiver expects Odd Parity (default). \n
                 01b=Receiver expects Even Parity.\n
                 10b=Receiver ignores level of the parity bit (10th bit is not interpreted as a parity bit).\n
                 11b=Reserved
                </description>
                <bitRange>[3:2]</bitRange>
                <access>read-write</access>
              </field>

              <!-- STOP -->
              <field>
                <name>STOP</name>
                <description>00b=Receiver expects an active high stop bit. \n
                 01b=Receiver expects an active low stop bit.\n
                 10b=Receiver ignores the level of the Stop bit (11th bit is not interpreted as a stop bit). \n
                 11b=Reserved.
                </description>
                <bitRange>[5:4]</bitRange>
                <access>read-write</access>
              </field>

            </fields>
          </register>

          <!-- PS2 Status Register -->
          <register>
            <name>STATUS</name>
            <description>PS2 Status Register
            </description>
            <addressOffset>0x08</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x000000FF</resetMask>
            <fields>
              <!-- RDATA_RDY -->
              <field>
                <name>RDATA_RDY</name>
                <description>Receive Data Ready. Reading the Receive Register clears this bit. A low to high transition on this bit generates a PS2 Activity interrupt.
                </description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>

              <!-- REC_TIMEOUT -->
              <field>
                <name>REC_TIMEOUT</name>
                <description>Receive Timeout. The REC_TIMEOUT bit is cleared when the Status Register is read. A low to high transition on this bit generates a PS2 Activity interrupt. (R/WC)
                </description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>

              <!-- PE -->
              <field>
                <name>PE</name>
                <description>Parity Error
                </description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>

              <!-- FE -->
              <field>
                <name>FE</name>
                <description>Framing Error
                </description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>

              <!-- XMIT_IDLE -->
              <field>
                <name>XMIT_IDLE</name>
                <description>Transmitter Idle. 0=The channel is actively transmitting PS/2 data. 1=The channel is not transmitting. A low to high transition on this bit generates a PS2 Activity interrupt.
                </description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>

              <!-- XMIT_TIME_OUT -->
              <field>
                <name>XMIT_TIME_OUT</name>
                <description>Transmitter Time-out. When the XMIT_TIMEOUT bit is set, the PS2_T/R bit is held clear, the PS/2 channel's CLK line is pulled low for a minimum of 300us until the PS/2 Status register is read.
                </description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>

              <!-- RX_BUSY -->
              <field>
                <name>RX_BUSY</name>
                <description>Receive Channel Busy.\n
                 0=The channel is actively receiving PS/2 data\n
                 1=The channel is idle
                </description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>

              <!-- XMIT_START_TIMEOUT -->
              <field>
                <name>XMIT_START_TIMEOUT</name>
                <description>Transmit Start Timeout.\n
                 0=No transmit start timeout detected\n
                 1=A start bit was not received within 25 ms following the transmit start event. The transmit start bit time-out condition is also indicated by the XMIT_TIMEOUT bit.
                </description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>

            </fields>
          </register>
        </cluster>
      </registers>
    </peripheral>
    <!--  -->

    <peripheral>
    <!-- < Chapter 30.0>  Keyboard Matrix Scan Support -->
    <!-- 40009C00  Keyboard Matrix Scan Support    0  Registers              Reserved                                             -->
    <!-- 40009C04  Keyboard Matrix Scan Support    0  Registers              KSO Select Register                                  -->
    <!-- 40009C08  Keyboard Matrix Scan Support    0  Registers              KSI Input Register                                   -->
    <!-- 40009C0C  Keyboard Matrix Scan Support    0  Registers              KSI Status Register                                  -->
    <!-- 40009C10  Keyboard Matrix Scan Support    0  Registers              KSI Interrupt Enable Register                        -->
    <!-- 40009C14  Keyboard Matrix Scan Support    0  Registers              Keyscan Extended Control Register                    -->
    <!--  -->
      <name>KMS</name>
      <version>1.0</version>
      <description>The Keyboard Scan Interface block provides a register interface to the EC\n
       to directly scan an external keyboard matrix of size up to 18x8.
      </description>
      <groupName>KMS</groupName>
      <baseAddress>0x40009C00</baseAddress>
      <size>32</size>
      <access>read-write</access>

      <addressBlock>
        <offset>0</offset>
        <size>0x020</size>
        <usage>registers</usage>
      </addressBlock>

      <interrupt>
        <name>KSC_INT</name>
        <description>KSC Interrupt ......................... Also see GIRQ 17.21</description>
        <value>39</value>
      </interrupt>

      <registers>
        <!-- KSO Select Register -->
        <register>
          <name>KSO_CONTROL</name>
          <description>KSO Select and control
          </description>
          <addressOffset>0x04</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <!-- KSO_SELECT -->
            <field>
              <name>SELECT</name>
              <description>This field selects a KSO line (00000b = KSO[0] etc.) for output according to the value off KSO_INVERT in this register.
              </description>
              <bitRange>[4:0]</bitRange>
              <access>read-write</access>
            </field>

            <!-- KSO_ALL -->
            <field>
              <name>ALL</name>
              <description>0=When key scan is enabled, KSO output controlled by the KSO_SELECT field.\n
               1=KSO[x] driven high when selected.
              </description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>

            <!-- KSEN -->
            <field>
              <name>KSEN</name>
              <description>0= Keyboard scan enabled, 1= Keyboard scan disabled. All KSO output buffers disabled.
              </description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>

            <!-- KSO_INVERT -->
            <field>
              <name>INVERT</name>
              <description>0= KSO[x] driven low when selected, 1= KSO[x] driven high when selected.
              </description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>

          </fields>
        </register>

        <!-- KSI INPUT Register -->
        <register>
          <name>KSI</name>
          <description>[7:0] This field returns the current state of the KSI pins.
          </description>
          <addressOffset>0x08</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
        </register>

        <!-- KSI STATUS Register -->
        <register>
          <name>KSI_STATUS</name>
          <description>[7:0] Each bit in this field is set on the falling edge of the corresponding KSI input pin.\n
           A KSI interrupt is generated when its corresponding status bit and interrupt enable bit are both set. KSI interrupts are logically ORed together to produce KSC_INT and KSC_INT_WAKE.\n
           Writing a '1' to a bit will clear it. Writing a '0' to a bit has no effect.
          </description>
          <addressOffset>0x0C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
        </register>

        <!-- KSI INTERRUPT ENABLE Register -->
        <register>
          <name>KSI_INT_EN</name>
          <description>[7:0] Each bit in KSI_INT_EN enables interrupt generation due to highto-low transition on a KSI input. An interrupt is generated when the corresponding bits in KSI_STATUS and KSI_INT_EN are both set.
          </description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
        </register>

        <!-- Keyscan Extended Control Register -->
        <register>
          <name>EXTENDED_CONTROL</name>
          <description>[0:0] PREDRIVE_ENABLE enables the PREDRIVE mode to actively drive the KSO pins high for approximately 100ns before switching to open-drain operation.\n
           0=Disable predrive on KSO pins\n
           1=Enable predrive on KSO pins.
          </description>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
        </register>
      </registers>
    </peripheral>
    <!--  -->

    <peripheral>
    <!-- < Chapter 31.0>  SMSC BC-Link Master -->
    <!-- 4000BC00  BC-Link Master                  0  Registers              BC-Link Status Register                              -->
    <!-- 4000BC04  BC-Link Master                  0  Registers              BC-Link Address Register                             -->
    <!-- 4000BC08  BC-Link Master                  0  Registers              BC-Link Data Register                                -->
    <!-- 4000BC0C  BC-Link Master                  0  Registers              BC-Link Clock Select Register                        -->
    <!--  -->
      <name>BC_LINK</name>
      <version>1.0</version>
      <description>This block provides BC-Link? connectivity to a slave device. The BC-Link\n
       protocol includes a start bit to signal the beginning of a message and a turnaround (TAR)\n
       period for bus transfer between the Master and Companion devices.
      </description>
      <groupName>BC_LINK</groupName>
      <baseAddress>0x4000BC00</baseAddress>
      <size>32</size>
      <access>read-write</access>

      <addressBlock>
        <offset>0</offset>
        <size>0x010</size>
        <usage>registers</usage>
      </addressBlock>

      <interrupt>
        <name>BCM_Err</name>
        <description>BCM_INT Err Interrupt ................. Also see GIRQ 17.29</description>
        <value>47</value>
      </interrupt>

      <interrupt>
        <name>BCM_Busy</name>
        <description>BCM_INT Busy Interrupt ................ Also see GIRQ 17.30</description>
        <value>48</value>
      </interrupt>

      <registers>
        <!-- BC-Link Status Register -->
        <register>
          <name>STATUS</name>
          <description>BC-Link Status 
          </description>
          <addressOffset>0x00</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000001</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>

          <fields>

            <!-- BUSY -->
            <field>
              <name>BUSY</name>
              <description>This bit is asserted to '1' when the BC interface is transferring data and on reset.
              </description>
              <bitRange>[0:0]</bitRange>
              <access>read</access>
            </field>

            <!-- BC_BUSY_CLR_INT_EN -->
            <field>
              <name>BUSY_CLR_INT_EN</name>
              <description>This bit is an enable for generating an interrupt when the BUSY bit in this register is cleared by hardware. When this bit is set to '1', the interrupt signal is enabled. When the this bit is cleared to '0', the interrupt is disabled. When enabled, the interrupt occurs after a BC Bus read or write. 
              </description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>

            <!-- BC_ERR_INT_EN -->
            <field>
              <name>ERR_INT_EN</name>
              <description>This bit is an enable for generating an interrupt when the BC_ERR bit is set by hardware. When this bit is '1', the interrupt signal is enabled. When this bit is '0', the interrupt is disabled. 
              </description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>

            <!-- BC_ERR -->
            <field>
              <name>ERROR</name>
              <description>This bit indicates that a BC Bus Error has occurred. (R/WC)
              </description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>

            <!-- RESET -->
            <field>
              <name>RESET</name>
              <description>When this bit is '1'the BC_Link Master Interface will be placed in reset and be held in reset until this bit is cleared to '0'. Setting RESET to '1' causes the BUSY bit to be set to '1'. The BUSY remains set to '1' until the reset operation of the BC Interface is completed, which takes approximately 48 BC clocks.
              </description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>

          </fields>

        </register>

        <!-- BC-Link Address Register -->
        <register>
          <name>ADDRESS</name>
          <description>BC-Link Address Register [7:0] Address in the Companion for the BC-Link transaction.
          </description>
          <addressOffset>0x04</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
        </register>

        <!-- BC-Link Data Register -->
        <register>
          <name>DATA</name>
          <description>BC-Link Data Register [7:0] this register hold data used in a BC-Link transaction.
          </description>
          <addressOffset>0x08</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
        </register>

        <!-- BC-Link Clock Select Register -->
        <register>
          <name>CLOCK_SELECT</name>
          <description>BC-Link Clock Select Register [7:0] DIVIDER  The BC Clock is set to the Master Clock divided by this field, or 48MHz/ (Divider +1). The clock divider bits can only can be changed when the BC Bus is in soft RESET (when either the Reset bit is set by software or when the BUSY bit is set by the interface). 
          </description>
          <addressOffset>0x0C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
        </register>

      </registers>
    </peripheral>
    <!--  -->

    <peripheral>
    <!-- < Chapter 32.0>  Trace FIFO Debug Port (TFDP) -->
    <!-- 40008C00  Trace FIFO Debug Port           0  TFDP                   Data                                                 -->
    <!-- 40008C04  Trace FIFO Debug Port           0  TFDP                   Control                                              -->
    <!--  -->
      <name>TFDP</name>
      <version>1.0</version>
      <description>The TFDP serially transmits Embedded Controller (EC)-originated \n
      diagnostic vectors to an external debug trace system.
      </description>
      <groupName>TFDP</groupName>
      <baseAddress>0x40008C00</baseAddress>
      <size>32</size>
      <access>read-write</access>

      <addressBlock>
        <offset>0</offset>
        <size>0x008</size>
        <usage>registers</usage>
      </addressBlock>

      <registers>
        <!-- Debug Data Register -->
        <register>
          <name>DATA</name>
          <description>Debug data to be shifted out on the TFDP Debug port. While data is being shifted out, the Host Interface will 'hold-off' additional writes to the data register until the transfer is complete.
          </description>
          <addressOffset>0x00</addressOffset>
          <size>16</size>
          <access>read-write</access>
          <resetValue>0x0000</resetValue>
          <resetMask>0xFFFF</resetMask>
        </register>

        <!-- Debug Control Register -->
        <register>
          <name>CONTROL</name>
          <description>Debug Control Register
          </description>
          <addressOffset>0x04</addressOffset>
          <size>8</size>
          <access>read-write</access>
          <resetValue>0x00</resetValue>
          <resetMask>0xFF</resetMask>

          <fields>
            <!-- EN -->
            <field>
              <name>EN</name>
              <description>Enable. 1=Clock enabled, 0=Clock is disabled (Default)
              </description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>

            <!-- EDGE_SEL -->
            <field>
              <name>EDGE_SEL</name>
              <description>1= Data is shifted out on the falling edge of the debug clock, 0= Data is shifted out on the rising edge of the debug clock (Default)
              </description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>

            <!-- DIVSEL -->
            <field>
              <name>DIVSEL</name>
              <description>Clock Divider Select.
              </description>
              <bitRange>[3:2]</bitRange>
              <access>read-write</access>
            </field>

            <!-- IP_DELAY -->
            <field>
              <name>IP_DELAY</name>
              <description>Inter-packet Delay. The delay is in terms of TFDP Debug output clocks.
              </description>
              <bitRange>[6:4]</bitRange>
              <access>read-write</access>
            </field>

          </fields>
        </register>
      </registers>
    </peripheral>
    <!--  -->

    <peripheral>
    <!-- < Chapter 33.0>  Analog to Digital Converter -->
    <!-- 40007C00  ADC                             0  ADC Registers          ADC Control Register                                 -->
    <!-- 40007C04  ADC                             0  ADC Registers          ADC Delay Register                                   -->
    <!-- 40007C08  ADC                             0  ADC Registers          ADC Status Register                                  -->
    <!-- 40007C0C  ADC                             0  ADC Registers          ADC Single Register                                  -->
    <!-- 40007C10  ADC                             0  ADC Registers          ADC Repeat Register                                  -->
    <!-- 40007C14  ADC                             0  ADC Registers          ADC Channel 0 Reading Registers                      -->
    <!-- 40007C18  ADC                             0  ADC Registers          ADC Channel 1 Reading Registers                      -->
    <!-- 40007C1C  ADC                             0  ADC Registers          ADC Channel 2 Reading Registers                      -->
    <!-- 40007C20  ADC                             0  ADC Registers          ADC Channel 3 Reading Registers                      -->
    <!-- 40007C24  ADC                             0  ADC Registers          ADC Channel 4 Reading Registers                      -->
    <!--  -->
      <name>ADC</name>
      <version>1.0</version>
      <description>This block is designed to convert external analog voltage readings into digital values.
      </description>
      <groupName>ADC</groupName>
      <baseAddress>0x40007C00</baseAddress>
      <size>32</size>
      <access>read-write</access>

      <addressBlock>
        <offset>0</offset>
        <size>0x080</size>
        <usage>registers</usage>
      </addressBlock>

      <interrupt>
        <name>ADC_SNGL</name>
        <description>ADC_SNGL Interrupt .................... Also see GIRQ 17.10</description>
        <value>28</value>
      </interrupt>

      <interrupt>
        <name>ADC_RPT</name>
        <description>ADC_RPT Interrupt ..................... Also see GIRQ 17.11</description>
        <value>29</value>
      </interrupt>

      <interrupt>
        <name>ADC2PWM_N1</name>
        <description>MCHP Reserved ADC2PWM_INT_N1 .......... Also see GIRQ 17.12</description>
        <value>30</value>
      </interrupt>

      <interrupt>
        <name>ADC2PWM_N2</name>
        <description>MCHP Reserved ADC2PWM_INT_N2 .......... Also see GIRQ 17.13</description>
        <value>31</value>
      </interrupt>

      <registers>
        <!-- ADC Control Register -->
        <register>
          <name>CONTROL</name>
          <description>The ADC Control Register is used to control the behavior of the Analog to Digital Converter.
          </description>
          <addressOffset>0x00</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0000</resetValue>
          <resetMask>0xFFFF</resetMask>

          <fields>
            <!-- ACTIVATE -->
            <field>
              <name>ACTIVATE</name>
              <description>0: The ADC is disabled and placed in its lowest power state. 1: ADC block is enabled for operation.
              </description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>

            <!-- START_SINGLE -->
            <field>
              <name>START_SINGLE</name>
              <description>(START_SINGLE) 0: The ADC Single Mode is disabled. 1: The ADC Single Mode is enabled. Note: This bit is self-clearing
              </description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>

            <!-- START_REPEAT -->
            <field>
              <name>START_REPEAT</name>
              <description>0: The ADC Repeat Mode is disabled. 1: The ADC Repeat Mode is enabled.
              </description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>

            <!-- POWER_SAVER_DIS -->
            <field>
              <name>POWER_SAVER_DIS</name>
              <description>0: Power saving feature is enabled. 1: Power saving feature is disabled.
              </description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>

            <!-- SOFT_RESET -->
            <field>
              <name>SOFT_RESET</name>
              <description>(SOFT_RESET) 1: writing one causes a reset of the ADC block hardware (not the registers) 0: writing zero takes the ADC block out of reset
              </description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>

            <!-- REPEAT_DONE_STAT -->
            <field>
              <name>REPEAT_DONE_STAT</name>
              <description>0: ADC repeat-sample conversion is not complete. 1: ADC repeat-sample conversion is completed.
              </description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>

            <!-- SINGLE_DONE_STAT -->
            <field>
              <name>SINGLE_DONE_STAT</name>
              <description>0: ADC single-sample conversion is not complete. 1: ADC single-sample conversion is completed.
              </description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>

          </fields>
        </register>

        <!-- ADC Delay Register -->
        <register>
          <name>DELAY</name>
          <description>The ADC Delay register determines the delay from setting Start_Repeat in the ADC Control Register and the start of a conversion cycle. This register also controls the interval between conversion cycles in repeat mode.
          </description>
          <addressOffset>0x04</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0000</resetValue>
          <resetMask>0xFFFF</resetMask>

          <fields>
            <!-- Start_Delay[15:0] -->
            <field>
              <name>START</name>
              <description>This field determines the starting delay before a conversion cycle is begun when Start_Repeat is written with a 1.
              </description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>

            <!-- Repeat_Delay[15:0] -->
            <field>
              <name>REPEAT</name>
              <description>This field determines the interval between conversion cycles when Start_Repeat is 1.
              </description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>

          </fields>
        </register>

        <!-- ADC Status Register -->
        <register>
          <name>STATUS</name>
          <description>The ADC Status Register indicates whether the ADC has completed a conversion cycle. All bits are cleared by being written with a '1'. \n
           0: conversion of the corresponding ADC channel is not complete\n
           1: conversion of the corresponding ADC channel is complete
          </description>
          <addressOffset>0x08</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0000</resetValue>
          <resetMask>0xFFFF</resetMask>

          <fields>

            <!-- CH_0 -->
            <field>
              <name>CH0</name>
              <description>ADC_Ch0_Status
              </description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>

            <!-- CH_1 -->
            <field>
              <name>CH1</name>
              <description>ADC_Ch1_Status
              </description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>

            <!-- CH_2 -->
            <field>
              <name>CH2</name>
              <description>ADC_Ch2_Status
              </description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>

            <!-- CH_3 -->
            <field>
              <name>CH3</name>
              <description>ADC_Ch3_Status
              </description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>

            <!-- CH_4 -->
            <field>
              <name>CH4</name>
              <description>ADC_Ch4_Status
              </description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>

          </fields>
        </register>

        <!-- ADC Single Register -->
        <register>
          <name>SINGLE_EN</name>
          <description>The ADC Single Register is used to control which ADC channel is captured during a Single-Sample conversion cycle initiated by the Start_Single bit in the ADC Control Register. \n
           APPLICATION NOTE: Do not change the bits in this register in the middle of a conversion cycle to insure proper operation.\n
           0: single cycle conversions for this channel are disabled\n
           1: single cycle conversions for this channel are enabled
          </description>
          <addressOffset>0x0C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0000</resetValue>
          <resetMask>0xFFFF</resetMask>

          <fields>

            <!-- CH_0 -->
            <field>
              <name>CH0</name>
              <description>ADC Ch0 single cycle conversions for this channel are 1:enabled/0:disabled
              </description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>

            <!-- CH_1 -->
            <field>
              <name>CH1</name>
              <description>ADC Ch1 single cycle conversions for this channel are 1:enabled/0:disabled
              </description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>

            <!-- CH_2 -->
            <field>
              <name>CH2</name>
              <description>ADC Ch2 single cycle conversions for this channel are 1:enabled/0:disabled
              </description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>

            <!-- CH_3 -->
            <field>
              <name>CH3</name>
              <description>ADC Ch3 single cycle conversions for this channel are 1:enabled/0:disabled
              </description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>

            <!-- CH_4 -->
            <field>
              <name>CH4</name>
              <description>ADC Ch4 single cycle conversions for this channel are 1:enabled/0:disabled
              </description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>

          </fields>
        </register>

        <!-- ADC Repeat Register -->
        <register>
          <name>REPEAT</name>
          <description>The ADC Repeat Register is used to control which ADC channels are captured during a repeat conversion cycle initiated by the Start_Repeat bit in the ADC Control Register.
          </description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0000</resetValue>
          <resetMask>0xFFFF</resetMask>

          <fields>
            <!-- CH_0 -->
            <field>
              <name>CH0</name>
              <description>ADC Ch0 repeat conversions for this channel are 1:enabled/0:disabled
              </description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>

            <!-- CH_1 -->
            <field>
              <name>CH1</name>
              <description>ADC Ch1 repeat conversions for this channel are 1:enabled/0:disabled
              </description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>

            <!-- CH_2 -->
            <field>
              <name>CH2</name>
              <description>ADC Ch2 repeat conversions for this channel are 1:enabled/0:disabled
              </description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>

            <!-- CH_3 -->
            <field>
              <name>CH3</name>
              <description>ADC Ch3 repeat conversions for this channel are 1:enabled/0:disabled
              </description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>

            <!-- CH_4 -->
            <field>
              <name>CH4</name>
              <description>ADC Ch4 repeat conversions for this channel are 1:enabled/0:disabled
              </description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>

          </fields>
        </register>

        <!-- ADC Channel x Reading Register -->
        <register>
          <dim>5</dim>
          <dimIncrement>4</dimIncrement>
          <dimIndex>0-4</dimIndex>
          <name>READ[%s]</name>
          <description>All 5 ADC channels return their results into a 32-bit reading register. In each case the low 10 bits of the reading register return the result of the Analog to Digital conversion and the upper 22 bits return 0.
          </description>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
        </register>
      </registers>
    </peripheral>
    <!--  -->

    <peripheral>
    <!-- < Chapter 35.0>  EC Subsystem Registers -->
    <!-- 4000FC00  EC_REG_BANK                     0  EC_REG_BANK            (*MCHP Reserved)                                     -->
    <!-- 4000FC04  EC_REG_BANK                     0  EC_REG_BANK            AHB Error Address (*MCHP Reserved)                   -->
    <!-- 4000FC08  EC_REG_BANK                     0  EC_REG_BANK            INPUT_MUX0 (*MCHP Reserved)                          -->
    <!-- 4000FC0C  EC_REG_BANK                     0  EC_REG_BANK            INPUT_MUX1 (*MCHP Reserved)                          -->
    <!-- 4000FC10  EC_REG_BANK                     0  EC_REG_BANK            ID (*MCHP Reserved)                                  -->
    <!-- 4000FC11  EC_REG_BANK                     0  EC_REG_BANK            (*MCHP Reserved)                                     -->
    <!-- 4000FC14  EC_REG_BANK                     0  EC_REG_BANK            AHB Error Control                                    -->
    <!-- 4000FC15  EC_REG_BANK                     0  EC_REG_BANK            (*MCHP Reserved)                                     -->
    <!-- 4000FC18  EC_REG_BANK                     0  EC_REG_BANK            Interrupt Control                                    -->
    <!-- 4000FC1C  EC_REG_BANK                     0  EC_REG_BANK            ETM Trace Enable                                     -->
    <!-- 4000FC20  EC_REG_BANK                     0  EC_REG_BANK            JTAG Enable                                          -->
    <!-- 4000FC24  EC_REG_BANK                     0  EC_REG_BANK            Private Key Lock (*MCHP Reserved)                    -->
    <!-- 4000FC28  EC_REG_BANK                     0  EC_REG_BANK            WDT Event Count                                      -->
    <!-- 4000FC2C  EC_REG_BANK                     0  EC_REG_BANK            AES HASH Byte Swap Control MCHP Reserved             -->
    <!-- 4000FC30  EC_REG_BANK                     0  EC_REG_BANK            ADC VREF PD    (*MCHP Reserved)                      -->
    <!-- 4000FC34  EC_REG_BANK                     0  EC_REG_BANK            Regulator Trim (*MCHP Reserved)                      -->
    <!-- 4000FC38  EC_REG_BANK                     0  EC_REG_BANK            ADC VREF PD                                          -->
    <!-- 4000FC3C  EC_REG_BANK                     0  EC_REG_BANK            ADC Comp Bias Current Adjust (*MCHP Reserved)        -->
    <!-- 4000FC40  EC_REG_BANK                     0  EC_REG_BANK            MISC_TRIM (*MCHP Reserved)                           -->
    <!--  -->
      <name>EC_REG_BANK</name>
      <version>1.0</version>
      <description>This block is designed to be accessed internally by the EC via the register interface.
      </description>
      <groupName>EC_REG_BANK</groupName>
      <baseAddress>0x4000FC00</baseAddress>
      <size>32</size>
      <access>read-write</access>

      <addressBlock>
        <offset>0</offset>
        <size>0x080</size>
        <usage>registers</usage>
      </addressBlock>

      <registers>
        <!-- AHB Error Control -->
        <register>
          <name>AHB_ERROR_CONTROL</name>
          <description>AHB Error Control [0:0] AHB_ERROR_DISABLE, 0: EC memory exceptions are enabled. 1: EC memory exceptions are disabled.
          </description>
          <addressOffset>0x14</addressOffset>
          <size>8</size>
          <access>read-write</access>
          <resetValue>0x00</resetValue>
          <resetMask>0xFF</resetMask>
        </register>

        <!-- Interrupt Control -->
        <register>
          <name>INTERRUPT_CONTROL</name>
          <description>Interrupt Control [0:0] NVIC_EN (NVIC_EN) This bit enables Alternate NVIC IRQ's Vectors. The Alternate NVIC Vectors provides each interrupt event with a dedicated (direct) NVIC vector.\n
           0 = Alternate NVIC vectors disabled, 1= Alternate NVIC vectors enabled
          </description>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000001</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
        </register>

        <!-- ETM TRACE Enable -->
        <register>
          <name>ETM_TRACE_ENABLE</name>
          <description>ETM TRACE Enable [0:0] TRACE_EN (TRACE_EN) This bit enables the ARM TRACE debug port (ETM/ITM). The Trace Debug Interface pins are forced to the TRACE functions.
           0 = ARM TRACE port disabled, 1= ARM TRACE port enabled
          </description>
          <addressOffset>0x1C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
        </register>

        <!-- JTAG Enable -->
        <register>
          <name>JTAG_Enable</name>
          <description>JTAG Enable [0:0] JTAG_EN (JTAG_EN) This bit enables the JTAG debug port.\n
           0 = JTAG port disabled. JTAG cannot be enabled (i.e., the TRST# pin is ignored and the JTAG signals remain in their non-JTAG state).\n
           1= JTAG port enabled. A high on TRST# enables JTAG
          </description>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
        </register>

        <!-- WDT Event Count -->
        <register>
          <name>WDT_EVENT_COUNT</name>
          <description>WDT Event Count [3:0] WDT_COUNT (WDT_COUNT) These EC R/W bits are cleared to 0 on VCC1 POR, but not on a WDT.\n
           Note: This field is written by Boot ROM firmware to indicate the number of times a WDT fired before loading a good EC code image.
          </description>
          <addressOffset>0x28</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
        </register>

        <!-- ADC VREF PD -->
        <register>
          <name>ADC_VREF_PD</name>
          <description>ADC VREF PD [0:0] ADC_VREF_PD_REF (ADC_VREF_PD_REF) ADC VREF Power down. 0=on 1=off
          </description>
          <addressOffset>0x38</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
        </register>
      </registers>
    </peripheral>
    <!--  -->

    <peripheral>
    <!-- < Chapter 36.0>  Test Mechanisms -->
    <!-- 40080000  JTAG                            0  JTAG_EC_Only           JTAG Message OBF                                     -->
    <!-- 40080004  JTAG                            0  JTAG_EC_Only           JTAG Message IBF                                     -->
    <!-- 40080008  JTAG                            0  JTAG_EC_Only           JTAG OBF Status                                      -->
    <!-- 40080009  JTAG                            0  JTAG_EC_Only           JTAG IBF Status                                      -->
    <!-- 4008000C  JTAG                            0  JTAG_EC_Only           JTAG DBG Ctrl                                        -->
    <!--  -->
      <name>JTAG</name>
      <version>1.0</version>
      <description>The Controller, which is an IEEE compliant JTAG Port, has implemented all\n
       the mandatory JTAG instructions. This interface may be used to access the embedded controller's\n
       test access port (TAP).
      </description>
      <groupName>JTAG</groupName>
      <baseAddress>0x40080000</baseAddress>
      <size>32</size>
      <access>read-write</access>

      <addressBlock>
        <offset>0</offset>
        <size>0x010</size>
        <usage>registers</usage>
      </addressBlock>

      <registers>
        <!-- JTAG Message OBF -->
        <register>
          <name>MESSAGE_OBF</name>
          <description>JTAG Message OBF
          </description>
          <addressOffset>0x00</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
        </register>

        <!-- JTAG Message IBF -->
        <register>
          <name>MESSAGE_IBF</name>
          <description>JTAG Message IBF
          </description>
          <addressOffset>0x04</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
        </register>

        <!-- JTAG OBF Status -->
        <register>
          <name>OBF_STATUS</name>
          <description>JTAG OBF Status
          </description>
          <addressOffset>0x08</addressOffset>
          <size>8</size>
          <access>read-write</access>
          <resetValue>0x00</resetValue>
          <resetMask>0xFF</resetMask>
        </register>

        <!-- JTAG IBF Status -->
        <register>
          <name>IBF_STATUS</name>
          <description>JTAG IBF Status
          </description>
          <addressOffset>0x09</addressOffset>
          <size>8</size>
          <access>read-write</access>
          <resetValue>0x00</resetValue>
          <resetMask>0xFF</resetMask>
        </register>

        <!-- JTAG DBG Ctrl -->
        <register>
          <name>DBG_CTRL</name>
          <description>JTAG DBG Ctrl
          </description>
          <addressOffset>0x0C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
        </register>

      </registers>
    </peripheral>
    <!--  -->

  </peripherals>
</device>
