<?xml version="1.0" encoding="utf-8"?>
<device schemaVersion="1.1" xmlns:xs="http://www.w3.org/2001/XMLSchema-instance" xs:noNamespaceSchemaLocation="CMSIS-SVD_Schema_1_1.xsd" >
  <name>NUC200AE_v1</name>
  <version>1.0</version>
  <description>NUC200AE_v1 SVD file</description>
  <!-- Bus Interface Properties -->
  <!-- Cortex-M0 is byte addressable -->
  <addressUnitBits>8</addressUnitBits>
  <!-- the maximum data bit width accessible within a single transfer is 32bits -->
  <width>32</width>

  <!-- Register Default Properties -->
  <!-- the size of the registers is set to a bit width of 32. This can be overruled for individual peripherals and/or registers -->
  <size>32</size>
  <!-- the access to all registers is set to be readable and writeable. This can be overruled for individual peripherals and/or registers -->
  <access>read-write</access>
  <!-- for demonstration purposes the resetValue for all registers of the device is set to be 0. This can be overruled within the description -->
  <resetValue>0</resetValue>
  <!-- the resetMask = 0 specifies that by default no register of this device has a defined reset value -->
  <resetMask>0</resetMask>

  <peripherals>
    <peripheral>
      <name>GCR</name>
      <description>GCR Register Map</description>
      <groupName>GCR</groupName>
      <baseAddress>0x50000000</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x0</offset>
        <size>0x14</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x18</offset>
        <size>0x8</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x24</offset>
        <size>0x4</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x30</offset>
        <size>0x18</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x50</offset>
        <size>0x4</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x58</offset>
        <size>0x8</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x80</offset>
        <size>0xC</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x100</offset>
        <size>0x4</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>PDID</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDID</displayName>
          <description>Part Device Identification Number Register</description>
          <addressOffset>0x0</addressOffset>
          <access>read-only</access>
          <resetValue>0x20140018</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDID</name>
              <description>Part Device Identification Number\nThis register reflects device part number code. Software can read this register to identify which device is used.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>RSTSRC</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>RSTSRC</displayName>
          <description>System Reset Source Register</description>
          <addressOffset>0x4</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFF00</resetMask>
          <fields>
            <field>
              <name>RSTS_POR</name>
              <description>Power-On Reset Flag\nThe RSTS_POR Flag is set by the "Reset Signal" from the Power-On Reset (POR) vontroller or bit CHIP_RST (IPRSTC1[0]) to indicate the previous reset source\nNote: Write 1 to clear this bit to 0.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No reset from POR or CHIP_RST (IPRSTC1[0])</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Power-on Reset (POR) or CHIP_RST (IPRSTC1[0]) had issued the reset signal to reset the system</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RSTS_RESET</name>
              <description>Reset Pin Reset Flag\nThe RSTS_RESET flag is set by the "Reset Signal" from the nRESET Pin to indicate the previous reset source\nNote: Write 1 to clear this bit to 0.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No reset from nRESET pin</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The Pin nRESET had issued the reset signal to reset the system</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RSTS_WDT</name>
              <description>Watchdog Timer Reset Flag\nThe RSTS_WDT flag is set by the "Reset Signal" from the watchdog timer or window watchdog timer to indicate the previous reset source.\nNote1: Write 1 to clear this bit to 0.\nNote2: Watchdog Timer register WTRF(WTCR[2]) bit is set if the system has been reset by WDT time-out reset. Window Watchdog Timer register WWDTRF(WWDTSR) bit is set if the system has been reset by WWDT time-out reset.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No reset from watchdog timer or window watchdog timer</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The watchdog timer or window watchdog timer had issued the reset signal to reset the system</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RSTS_LVR</name>
              <description>Low Voltage Reset Flag\nThe RSTS_LVR flag is set by the "Reset Signal" from the Low-Voltage-Reset controller to indicate the previous reset source.\nNote: Write 1 to clear this bit to 0.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No reset from LVR</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The LVR controller had issued the reset signal to reset the system</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RSTS_BOD</name>
              <description>Brown-Out Detector Reset Flag\nThe RSTS_BOD flag is set by the "Reset Signal" from the Brown-Out Detector to indicate the previous reset source.\nNote: Write 1 to clear this bit to 0.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No reset from BOD</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The BOD had issued the reset signal to reset the system</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RSTS_SYS</name>
              <description>SYS Reset Flag\nThe RSTS_SYS flag Is set by the "Reset Signal" from the Cortex-M0 kernel to indicate the previous reset source.\nNote: Write 1 to clear this bit to 0.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No reset from Cortex-M0</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The Cortex-M0 had issued the reset signal to reset the system by writing 1 to bit SYSRESETREQ (AIRCR[2], Application Interrupt and Reset Control Register, address = 0xE000ED0C) in system control registers of Cortex-M0 kernel</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RSTS_CPU</name>
              <description>CPU Reset Flag\nThe RSTS_CPU flag Is set by hardware if software writes CPU_RST (IPRSTC1[1]) 1 To reset Cortex-M0 kernel and flash memory controller (FMC).\nNote: Write 1 to clear this bit to 0.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No reset from CPU</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Cortex-M0 CPU kernel and FMC are reset by software setting CPU_RST(IPRSTC1[1]) to 1</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>IPRSTC1</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>IPRSTC1</displayName>
          <description>Peripheral Reset Control Register 1</description>
          <addressOffset>0x8</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CHIP_RST</name>
              <description>CHIP One-Shot Reset (Write Protect)\nSetting this bit will reset the whole chip, including CPU kernel and all peripherals, and this bit will automatically return to 0 after the 2 clock cycles.\nThe CHIP_RST is the same as the POR reset, all the chip controllers are reset and the chip setting from flash are also reload.\nFor the difference between CHIP_RST and SYSRESETREQ, please refer to section 5.2.2\nNote: This bit is the protected bit, and programming it needs to write "59h", "16h", and "88h" to address 0x5000_0100 to disable register protection. Refer to the register REGWRPROT at address GCR_BA+0x100.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>CHIP normal operation</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>CHIP one-shot reset</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CPU_RST</name>
              <description>CPU Kernel One-Shot Reset (Write Protect)\nSetting this bit will only reset the CPU kernel and Flash Memory Controller(FMC), and this bit will automatically return 0 after the two clock cycles\nNote: This bit is the protected bit, and programming it needs to write "59h", "16h", and "88h" to address 0x5000_0100 to disable register protection. Refer to the register REGWRPROT at address GCR_BA+0x100.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>CPU normal operation</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>CPU one-shot reset</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PDMA_RST</name>
              <description>PDMA Controller Reset (Write Protect)\nSetting this bit to 1 will generate a reset signal to the PDMA. User needs to set this bit to 0 to release from reset state.\nNote1: This bit is the protected bit, and programming it needs to write "59h", "16h", and "88h" to address 0x5000_0100 to disable register protection. Refer to the register REGWRPROT at address GCR_BA+0x100.\nNote2: Setting PDMA_RST bit to 1 will generate asynchronous reset signal to PDMA module. Users need to set PDMA_RST to 0 to release PDMA module from reset state.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PDMA controller normal operation</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PDMA controller reset</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>EBI_RST</name>
              <description>EBI Controller Reset (Write-protection Bit)\nSet this bit to 1 will generate a reset signal to the EBI. User need to set this bit to 0 to release from the reset state.\nThis bit is the protected bit, It means programming this bit needs to write "59h", "16h", "88h" to address 0x5000_0100 to disable register protection. Refer to the register REGWRPROT at address GCR_BA+0x100\n</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>EBI controller normal operation</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>EBI controller reset</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>IPRSTC2</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>IPRSTC2</displayName>
          <description>Peripheral Reset Control Register 2</description>
          <addressOffset>0xC</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>GPIO_RST</name>
              <description>GPIO Controller Reset\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO controller normal operation</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIO controller reset</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TMR0_RST</name>
              <description>Timer0 Controller Reset\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Timer0 controller normal operation</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Timer0 controller reset</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TMR1_RST</name>
              <description>Timer1 Controller Reset\n</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Timer1 controller normal operation</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Timer1 controller reset</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TMR2_RST</name>
              <description>Timer2 Controller Reset\n</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Timer2 controller normal operation</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Timer2 controller reset</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TMR3_RST</name>
              <description>Timer3 Controller Reset\n</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Timer3 controller normal operation</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Timer3 controller reset</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C0_RST</name>
              <description>I2C0 Controller Reset\n</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>I2C0 controller normal operation</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>I2C0 controller reset</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C1_RST</name>
              <description>I2C1 Controller Reset\n</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>I2C1 controller normal operation</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>I2C1 controller reset</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SPI0_RST</name>
              <description>SPI0 Controller Reset\n</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>SPI0 controller normal operation</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>SPI0 controller reset</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SPI1_RST</name>
              <description>SPI1 Controller Reset\n</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>SPI1 controller normal operation</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>SPI1 controller reset</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SPI2_RST</name>
              <description>SPI2 Controller Reset \n</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>SPI2 controller normal operation</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>SPI2 controller reset</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SPI3_RST</name>
              <description>SPI3 Controller Reset \n</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>SPI3 controller normal operation</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>SPI3 controller reset</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>UART0_RST</name>
              <description>UART0 Controller Reset\n</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>UART0 controller normal operation</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>UART0 controller reset</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>UART1_RST</name>
              <description>UART1 Controller Reset\n</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>UART1 controller normal operation</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>UART1 controller reset</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>UART2_RST</name>
              <description>UART2 Controller Reset \n</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>UART2 controller normal operation</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>UART2 controller reset</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PWM03_RST</name>
              <description>PWM03 Controller Reset\n</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM03 controller normal operation</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PWM03 controller reset</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PWM47_RST</name>
              <description>PWM47 Controller Reset\n</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM47 controller normal operation</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PWM47 controller reset</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ACMP_RST</name>
              <description>Analog Comparator Controller Reset\n</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Analog Comparator controller normal operation</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Analog Comparator controller reset</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PS2_RST</name>
              <description>PS/2 Controller Reset\n</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PS/2 controller normal operation</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PS/2 controller reset</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CAN0_RST</name>
              <description>CAN0 Controller Reset\n</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>CAN0 controller normal operation</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>CAN0 controller reset</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CAN1_RST</name>
              <description>CAN1 Controller Reset\n</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>CAN1 controller normal operation</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>CAN1 controller reset</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>USBD_RST</name>
              <description>USB Device Controller Reset\n</description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>USB device controller normal operation</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>USB device controller reset</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ADC_RST</name>
              <description>ADC Controller Reset\n</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>ADC controller normal operation</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>ADC controller reset</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>I2S_RST</name>
              <description>I2S Controller Reset\n</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>I2S controller normal operation</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>I2S controller reset</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>IPRSTC3</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>IPRSTC3</displayName>
          <description>Peripheral Reset Control Register 3</description>
          <addressOffset>0x10</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SC0_RST</name>
              <description>SC0 Controller Reset\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>SC0 controller normal operation</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>SC0 controller reset</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SC1_RST</name>
              <description>SC1 Controller Reset\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>SC1 controller normal operation</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>SC1 controller reset</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SC2_RST</name>
              <description>SC2 Controller Reset\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>SC2 controller normal operation</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>SC2 controller reset</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>BODCR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>BODCR</displayName>
          <description>Brown-out Detector Control Register</description>
          <addressOffset>0x18</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000080</resetValue>
          <resetMask>0xFFFFFFF0</resetMask>
          <fields>
            <field>
              <name>BOD_EN</name>
              <description>Brown-Out Detector Enable Bit (Write Protect)\nThe default value is set by flash memory controller user configuration register CBODEN(CONFIG0[23]) bit.\nNote: This bit is the protected bit. It means programming this needs to write "59h", "16h", "88h" to address 0x5000_0100 to disable register protection. Refer to the register REGWRPROT at address GCR_BA+0x100.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Brown-out Detector function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Brown-out Detector function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BOD_VL</name>
              <description>Brown-Out Detector Threshold Voltage Selection (Write Protect)\nThe default value is set by flash momory controller user configuration register CBOV(CONFIG0[22:21]) bit .\nNote: This bit is the protected bit. It means programming this needs to write "59h", "16h", "88h" to address 0x5000_0100 to disable register protection. Refer to the register REGWRPROT at address GCR_BA+0x100.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Brown-out voltage is 2.2V</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Brown-out voltage is 2.7V</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Brown-out voltage is 3.7V</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Brown-out voltage is 4.4V</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BOD_RSTEN</name>
              <description>Brown-Out Reset Enable Bit (Write Protect)\nWhile the Brown-out Detector function is enabled (BOD_EN high) and BOD reset function is enabled (BOD_RSTEN high), BOD will assert a signal to reset chip when the detected voltage is lower than the threshold (BOD_OUT high).\nNote1: While the BOD function is enabled (BOD_EN high) and BOD interrupt function is enabled (BOD_RSTEN low), BOD will assert an interrupt if BOD_OUT is high. BOD interrupt will keep till to the BOD_EN set to 0. BOD interrupt can be blocked by disabling the NVIC BOD interrupt or disabling BOD function (set BOD_EN low).\nNote2: The default value is set by flash controller user configuration register  CBORST(CONFIG0[20]) bit. \nNote3: This bit is the protected bit. It means programming this needs to write "59h", "16h", "88h" to address 0x5000_0100 to disable register protection. Refer to the register REGWRPROT at address GCR_BA+0x100.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Brown-out "INTERRUPT" function Enabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Brown-out "RESET" function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BOD_INTF</name>
              <description>Brown-Out Detector Interrupt Flag\nNote: Write 1 to clear this bit to 0.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Brown-out Detector does not detect any voltage draft at VDD down through or up through the voltage of BOD_VL setting</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>When Brown-out Detector detects the VDD is dropped down through the voltage of BOD_VL setting or the VDD is raised up through the voltage of BOD_VL setting, this bit is set to 1 and the Brown-out interrupt is requested if Brown-out interrupt is enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BOD_LPM</name>
              <description>Brown-Out Detector Low Power Mode (Write Protect)\nNote1: The BOD consumes about 100 uA in Normal mode, and the low power mode can reduce the current to about 1/10 but slow the BOD response.\nNote2: This bit is the protected bit, and programming it needs to write "59h", "16h", and "88h" to address 0x5000_0100 to disable register protection. Refer to the register REGWRPROT at address GCR_BA+0x100.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>BOD operated in Normal mode (default)</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>BOD Low Power mode Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BOD_OUT</name>
              <description>Brown-Out Detector Output Status\n</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Brown-out Detector output status is 0. It means the detected voltage is higher than BOD_VL setting or BOD_EN is 0</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Brown-out Detector output status is 1. It means the detected voltage is lower than BOD_VL setting. If the BOD_EN is 0, BOD function disabled , this bit always responds  to 0</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>LVR_EN</name>
              <description>Low Voltage Reset Enable Bit (Write Protect)\nThe LVR function reset the chip when the input power voltage is lower than LVR circuit setting. LVR function is enabled by default.\nNote: This bit is the protected bit, and programming it needs to write "59h", "16h", and "88h" to address 0x5000_0100 to disable register protection. Refer to the register REGWRPROT at address GCR_BA+0x100.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Low Voltage Reset function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Low Voltage Reset function Enabled - After enabling the bit, the LVR function will be active with 100us delay for LVR output stable (default)</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>TEMPCR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>TEMPCR</displayName>
          <description>Temperature Sensor Control Register</description>
          <addressOffset>0x1C</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>VTEMP_EN</name>
              <description>Temperature Sensor Enable Bit\nThis bit is used to enable/disable temperature sensor function.\nNote: After this bit is set to 1, the value of temperature can be obtained from ADC conversion result by ADC channel selecting channel 7 and alternative multiplexer channel selecting temperature sensor. Please refer to the ADC function chapter for detail ADC conversion functional description.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Temperature sensor function Disabled (default)</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Temperature sensor function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PORCR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PORCR</displayName>
          <description>Power-on-reset Controller Register</description>
          <addressOffset>0x24</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFF0000</resetMask>
          <fields>
            <field>
              <name>POR_DIS_CODE</name>
              <description>Power-On-Reset Enable Bit (Write Protect)\nWhen powered on, the POR circuit generates a reset signal to reset the whole chip function, but noise on the power may cause the POR active again. User can disable internal POR circuit to avoid unpredictable noise to cause chip reset by writing 0x5AA5 to this field.\nThe POR function will be active again when  this field is set to another value or chip is reset by other reset source, including:\nnRESET, Watchdog Timer reset, Window Watchdog Timer reset, LVR reset, BOD reset, ICE reset command and the software-chip reset function\nNote: This bit is the protected bit. It means programming this needs to write "59h", "16h", "88h" to address 0x5000_0100 to disable register protection. Refer to the register REGWRPROT at address GCR_BA+0x100.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>GPA_MFP</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>GPA_MFP</displayName>
          <description>GPIOA Multiple Function and Input Type Control Register</description>
          <addressOffset>0x30</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>GPA_MFP0</name>
              <description>PA.0 Pin Function Selection\nBit PA0_SC0PWR (ALT_MFP1[2]) and GPA_MFP[0] determine the PA.0 function.\n(PA0_SC0PWR, GPA_MFP0) value and function mapping is as following list.\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GPA_MFP1</name>
              <description>PA.1 Pin Function Selection\nBit EBI_HB_EN[4] (ALT_MFP[20]), EBI_EN (ALT_MFP[11]), PA1_SC0RST (ALT_MFP1[3]) and GPA_MFP[1] determine the PA.1 function.\n(EBI_HB_EN, EBI_EN, PA1_SC0RST, GPA_MFP1) value and function mapping is as following list.\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GPA_MFP2</name>
              <description>PA.2 Pin Function Selection\nBits EBI_HB_EN[3] (ALT_MFP[19]), EBI_EN (ALT_MFP[11]), PA2_SC0CLK (ALT_MFP1[0]) and GPA_MFP[2] determine the PA.2 function.\n(EBI_HB_EN, EBI_EN, PA2_SC0CLK, GPA_MFP2) value and function mapping is as following list.\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GPA_MFP3</name>
              <description>PA.3 Pin Function Selection\nBits EBI_HB_EN[2] (ALT_MFP[18]), EBI_EN (ALT_MFP[11]), PA3_SC0DAT (ALT_MFP1[1]) and GPA_MFP[3] determine the PA.3 function.\n(EBI_HB_EN, EBI_EN, PA3_SC0DAT, GPA_MFP3) value and function mapping is as following list.\n</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GPA_MFP4</name>
              <description>PA.4 Pin Function Selection\nBits EBI_HB_EN[1] (ALT_MFP[17]), EBI_EN (ALT_MFP[11]), PA4_SC1PWR (ALT_MFP1[7]) and GPA_MFP[4] determine the PA.4 function.\n(EBI_HB_EN, EBI_EN, PA4_SC1PWR, GPA_MFP4) value and function mapping is as following list.\n</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GPA_MFP5</name>
              <description>PA.5 Pin Function Selection\nBits EBI_HB_EN[0] (ALT_MFP[16]), EBI_EN (ALT_MFP[11]),PA5_SC1RST (ALT_MFP1[8]) and GPA_MFP[5] determine the PA.5 function.\n(EBI_HB_EN, EBI_EN, PA5_SC1RST, GPA_MFP5) value and function mapping is as following list,\n</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GPA_MFP6</name>
              <description>PA.6 Pin Function Selection\nBits EBI_EN (ALT_MFP[11]), PA6_SC1CLK (ALT_MFP1[5]) and GPA_MFP[6] determine the PA.6 function.\n(EBI_EN,  PA6_SC1CLK, GPA_MFP6) value and function mapping is as following list.\n</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GPA_MFP7</name>
              <description>PA.7 Pin Function Selection\nBits EBI_EN (ALT_MFP[11]), PA7_SC1DAT (ALT_MFP1[6]), PA7_S21 (ALT_MFP[2]) and GPA_MFP[7] determine the PA.7 function.\n(EBI_EN, PA7_SC1DAT, PA7_S21, GPA_MFP7) value and function mapping is as following list.\n</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GPA_MFP8</name>
              <description>PA.8 Pin Function Selection\nBit GPA_MFP[8] determines the PA.9 function.\n</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO function is selected to the pin PA.8</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>I2C0_SDA function is selected to the pin PA.8</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>GPA_MFP9</name>
              <description>PA.9 Pin Function Selection\nBit GPA_MFP[9] determines the PA.9 function.\n</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO function is selected</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>I2C0_SCL function is selected</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>GPA_MFP10</name>
              <description>PA.10 Pin Function Selection\nBits EBI_EN (ALT_MFP[11]), PA10_11_CAN1 (ALT_MFP[28]) and GPA_MFP[10] determine the PA.10 function.\n(EBI_EN, PA10_11_CAN1, GPA_MFP10) value and function mapping is as following list.\n</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GPA_MFP11</name>
              <description>PA.11 Pin Function Selection\nBits EBI_EN (ALT_MFP[11]), PA10_11_CAN1 (ALT_MFP[28]) and GPA_MFP[11] determine the PA.11 function.\n(EBI_EN, PA10_11_CAN1, GPA_MFP11) value and function mapping is as following list.\n</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GPA_MFP12</name>
              <description>PA.12 Pin Function Selection\nBits EBI_HB_EN[5] (ALT_MFP[21]),  EBI_EN (ALT_MFP[11]), PA12_SC2DAT (ALT_MFP1[11]) and GPA_MFP[12] determine the PA.12 function.\n(EBI_HB_EN,  EBI_EN, PA12_SC2DAT, GPA_MFP12) value and function mapping is as following list.\n</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GPA_MFP13</name>
              <description>PA.13 Pin Function Selection\nBits EBI_HB_EN[6] (ALT_MFP[22]),  EBI_EN (ALT_MFP[11]),  PA13_SC2CLK (ALT_MFP1[10]) and GPA_MFP[13] determine the PA.13 function.\n(EBI_HB_EN,  EBI_EN, PA13_SC2CLK, GPA_MFP13) value and function mapping is as following list.\n</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GPA_MFP14</name>
              <description>PA.14 Pin Function Selection\nBits EBI_HB_EN[7] (ALT_MFP[23]), EBI_EN (ALT_MFP[11]), PA14_SC2RST (ALT_MFP1[13]) and GPA_MFP[14] determine the PA.14 function.\n(EBI_HB_EN , EBI_EN,  PA14_SC2RST, GPA_MFP14) value and function mapping is as following list.\n</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GPA_MFP15</name>
              <description>PA.15 Pin Function Selection\nBits PA15_SC2PWR (ALT_MFP1[12]), PA15_I2SMCLK (ALT_MFP[9]) and GPA_MFP[15] determine the PA.15 function.\n(PA15_SC2PWR, PA15_I2SMCLK, GPA_MFP15) value and function mapping is as following list.\n</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GPA_TYPEn</name>
              <description>Trigger Function Selection\n</description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIOA[15:0] I/O input Schmitt Trigger function Disabled</description>
                    <value>0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIOA[15:0] I/O input Schmitt Trigger function Enabled</description>
                    <value>1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>GPB_MFP</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>GPB_MFP</displayName>
          <description>GPIOB Multiple Function and Input Type Control Register</description>
          <addressOffset>0x34</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>GPB_MFP0</name>
              <description>PB.0 Pin Function Selection\nBit GPB_MFP[0] determines the PB.0 function.\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO function is selected to the pin PB.0</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>UART0_RXD function is selected to the pin PB.0</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>GPB_MFP1</name>
              <description>PB.1 Pin Function Selection\nBit GPB_MFP[1] determines the PB.1 function.\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO function is selected to the pin PB.1</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>UART0_TXD function is selected to the pin PB.1</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>GPB_MFP2</name>
              <description>PB.2 Pin Function Selection\nBits EBI_nWRL_EN (ALT_MFP[13]), EBI_EN (ALT_MFP[11]), PB2_TM2 (ALT_MFP2[4]), PB2_CPO0 (ALT_MFP[30]), PB2_T2EX (ALT_MFP[26]) and GPB_MFP[2] determine the PB.2 function.\n(EBI_nWRL_EN, EBI_EN, PB2_TM2, PB2_CPO0, PB2_T2EX, GPB_MFP2) value and function mapping is as following list.\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GPB_MFP3</name>
              <description>PB.3 Pin Function Selection\nBits EBI_nWRH_EN (ALT_MFP[14]), EBI_EN (ALT_MFP[11]), PB3_TM3 (ALT_MFP2[5]), PB3_SC2CD (ALT_MFP1[14]), PB3_T3EX (ALT_MFP[27]) and GPB_MFP[3] determine the PB.3 function.\n(EBI_nWRH_EN, EBI_EN,  PB3_TM3, PB3_SC2CD, PB3_T3EX, GPB_MFP3) value and function mapping is as following list.\n</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GPB_MFP4</name>
              <description>PB.4 Pin Function Selection\nBit GPB_MFP[4] determines the PB.4 function.\n</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO function is selected to the pin PB.4</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>UART1_RXD function is selected to the pin PB.4</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>GPB_MFP5</name>
              <description>PB 5 Pin Function Selection\nBit GPB_MFP[5] determines the PB.5 function.\n</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO function is selected to the pin PB.5</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>UART1_TXD function is selected to the pin PB.5</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>GPB_MFP6</name>
              <description>PB.6 Pin Function Selection\nBit EBI_EN (ALT_MFP[11]), GPB_MFP[6] determines the PB.6 function.\n(EBI_EN, GPB_MFP6) value and function mapping is as following list.\n</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GPB_MFP7</name>
              <description>PB.7 Pin Function Selection\nBit EBI_EN (ALT_MFP[11]), GPB_MFP[7] determines the PB.7 function.\n(EBI_EN, GPB_MFP7) value and function mapping is as following list.\n</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GPB_MFP8</name>
              <description>PB.8 Pin Function Selection\nBits PB8_CLKO (ALT_MFP[29]) and GPB_MFP[8] determine the PB.8 function.\n(PB8_CLKO, GPB_MFP8) value and function mapping is as following list.\n</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GPB_MFP9</name>
              <description>PB.9 Pin Function Selection\nBits PB9_S11 (ALT_MFP[1]) and GPB_MFP[9] determine the PB.9 function.\n(PB9_S11, GPB_MFP9) value and function mapping is as following list.\n</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GPB_MFP10</name>
              <description>PB.10 Pin Function Selection\nBits PB10_S01 (ALT_MFP[0]) and GPB_MFP[10] determine the PB.10 function.\n(PB10_S01, GPB_MFP10) value and function mapping is as following list.\n</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GPB_MFP11</name>
              <description>PB.11 Pin Function Selection\nBits PB11_PWM4 (ALT_MFP[4]) and GPB_MFP[11] determine the PB.11 function.\n(PB11_PWM4, GPB_MFP11) value and function mapping is as following list.\n</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GPB_MFP12</name>
              <description>Reserved</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GPB_MFP13</name>
              <description>PB.13 Pin Function Selection\nBit EBI_EN (ALT_MFP[11]), GPB_MFP[13] determines the PB.13 function.\n(EBI_EN, GPB_MFP13) value and function mapping is as following list\n</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GPB_MFP14</name>
              <description>PB.14 Pin Function Selection\nBits PB14_15_EBI (ALT_MFP2[1]), PB14_S31 (ALT_MFP[3]) and GPB_MFP[14] determine the PB.14 function.\n(PB14_15_EBI , PB14_S31, GPB_MFP14) value and function mapping is as following list\n</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GPB_MFP15</name>
              <description>PB.15 Pin Function Selection\nBits PB14_15_EBI (ALT_MFP2[1]),  PB15_T0EX (ALT_MFP[24]), PB15_TM0 (ALT_MFP2[2]) and GPB_MFP[15] determine the PB.15 function.\n(PB14_15_EBI, PB15_T0EX, PB15_TM0, GPB_MFP15) value and function mapping is as following list.\n</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GPB_TYPEn</name>
              <description>Trigger Function Selection\n</description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIOB[15:0] I/O input Schmitt Trigger function Disabled</description>
                    <value>0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIOB[15:0] I/O input Schmitt Trigger function Enabled</description>
                    <value>1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>GPC_MFP</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>GPC_MFP</displayName>
          <description>GPIOC Multiple Function and Input Type Control Register</description>
          <addressOffset>0x38</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>GPC_MFP0</name>
              <description>PC.0 Pin Function Selection\nBits PC0_I2SLRCLK (ALT_MFP[5]) and GPC_MFP[0] determine the PC.0 function.\n(PC0_I2SLRCLK, GPC_MFP0) value and function mapping is as following list.\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GPC_MFP1</name>
              <description>PC.1 Pin Function Selection\nBits PC1_I2SBCLK (ALT_MFP[6]) and GPC_MFP[1] determine the PC.1 function.\n(PC1_I2SBCLK, GPC_MFP1) value and function mapping is as following list.\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GPC_MFP2</name>
              <description>PC.2 Pin Function Selection\nBits PC2_I2SDI (ALT_MFP[7]) and GPC_MFP[2] determine the PC.2 function.\n(PC2_I2SDI, GPC_MFP2) value and function mapping is as following list.\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GPC_MFP3</name>
              <description>PC.3 Pin Function Selection\nBits PC3_I2SDO (ALT_MFP[8]) and GPC_MFP[3] determine the PC.3 function.\n(PC3_I2SDO, GPC_MFP3) value and function mapping is as following list.\n</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GPC_MFP4</name>
              <description>PC.4 Pin Function Selection\nBit GPC_MFP[4] determines the PC.4 function.\n</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO function is selected to the pin PC.4</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>SPI0_MISO1 function is selected to the pin PC.4</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>GPC_MFP5</name>
              <description>PC.5 Pin Function Selection\nBit GPC_MFP[5] determines the PC.5 function.\n</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO function  is selected to the pin PC.5</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>SPI0_MOSI1 function is selected to the pin PC.5</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>GPC_MFP6</name>
              <description>PC.6 Pin Function Selection\nBits EBI_EN (ALT_MFP[11]). PC6_SC0CD (ALT_MFP1[4]) and GPC_MFP[6] determine the PC.6 function.\n(EBI_EN, PC6_SC0CD, GPB_MFP6) value and function mapping is as following list.\n</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GPC_MFP7</name>
              <description>PC.7 Pin Function Selection\nBits EBI_EN (ALT_MFP[11]), PC7_SC1CD (ALT_MFP1[9]) and GPC_MFP[7] determine the PC.7 function.\n(EBI_EN, PC7_SC1CD, GPC_MFP7) value and function mapping is as following list.\n</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GPC_MFP8</name>
              <description>PC.8 Pin Function Selection\nBits EBI_MCLK_EN (ALT_MFP[12]), EBI_EN (ALT_MFP[11]),  GPC_MFP[8] determine the PC.8 function.\n(EBI_MCLK_EN, EBI_EN, GPC_MFP8) value and function mapping is as following list.\n</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GPC_MFP9</name>
              <description>PC.9 Pin Function Selection\nBit GPC_MFP[9] determines the PC.9 function.\n</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO function is selected to the pin PC.9</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>SPI1_CLK function is selected to the pin PC.9</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>GPC_MFP10</name>
              <description>PC.10 Pin Function Selection\nBit GPC_MFP[10] determines the PC.10 function.\n</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO function is selected to the pin PC.10</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>SPI1_MISO0 function is selected to the pin PC.10</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>GPC_MFP11</name>
              <description>PC.11 Pin Function Selection\nBit GPC_MFP[11] determines the PC.11 function.\n</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO function is selected to the pin PC.11</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>SPI1_MOSI0 function is selected to the pin PC.11</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>GPC_MFP12</name>
              <description>PC.12 Pin Function Selection\nBit GPC_MFP[12] determines the PC.12 function.\n</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO function is selected to the pin PC.12</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>SPI1_MISO1 function is selected to the pin PC.12</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>GPC_MFP13</name>
              <description>PC.13 Pin Function Selection\nBit GPC_MFP[13] determines the PC.13 function.\n</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO function is selected to the pin PC.13</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>SPI1_MOSI1 function is selected to the pin PC.13</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>GPC_MFP14</name>
              <description>PC.14 Pin Function Selection\nBits EBI_EN (ALT_MFP[11]) and GPC_MFP[14] determine the PC.14 function.\n(EBI_EN, GPC_MFP14) value and function mapping is as following list\n</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GPC_MFP15</name>
              <description>PC.15 Pin Function Selection\nBits EBI_EN (ALT_MFP[11]) and GPC_MFP[15] determine the PC.15 function.\n(EBI_EN, GPC_MFP15) value and function mapping is as following list\n</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GPC_TYPEn</name>
              <description>Trigger Function Selection\n</description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIOC[15:0] I/O input Schmitt Trigger function Disabled</description>
                    <value>0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIOC[15:0] I/O input Schmitt Trigger function Enabled</description>
                    <value>1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>GPD_MFP</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>GPD_MFP</displayName>
          <description>GPIOD Multiple Function and Input Type Control Register</description>
          <addressOffset>0x3C</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>GPD_MFP0</name>
              <description>PD.0 Pin Function Selection\nBit GPD_MFP[0] determines the PD.0 function.\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIOfunction is selected to the pin PD.0</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>SPI2_SS0 function is selected to the pin PD.0</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>GPD_MFP1</name>
              <description>PD.1 Pin Function Selection\nBit GPD_MFP[1] determines the PD.1 function.\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO function is selected to the pin PD.1</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>SPI2_CLK function is selected to the pin PD.1</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>GPD_MFP2</name>
              <description>PD.2 Pin Function Selection\nBit GPD_MFP[2] determines the PD.5 function.\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO function is selected to the pin PD.2</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>SPI2_MISO0 function is selected to the pin PD.2</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>GPD_MFP3</name>
              <description>PD.3 Pin Function Selection\nBit GPD_MFP[3] determines the PD.3 function.\n</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO function is selected to the pin PD.3</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>SPI2_MOSI0 function is selected to the pin PD.3</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>GPD_MFP4</name>
              <description>PD.4 Pin Function Selection \nBit GPD_MFP[4] determines the PD.4 function.\n</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO function is selected to the pin PD.4</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>SPI2_MISO1 function is selected to the pin PD.4</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>GPD_MFP5</name>
              <description>PD.5 Pin Function Selection \nBit GPD_MFP[5] determines the PD.5 function.\n</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO function is selected to the pin PD.5</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>SPI2_MOSI1 function is selected to the pin PD.5</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>GPD_MFP6</name>
              <description>PD.6 Pin Function Selection\nBit GPD_MFP[6] determines the PD.6 function.\n</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The GPIO function is selected to the pin PD.6</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The CAN0_RXD function is selected to the pin PD.6</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>GPD_MFP7</name>
              <description>PD.7 Pin Function Selection \nBit GPD_MFP[7] determines the PD.5 function.\n</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The GPIO function is selected to the pin PD.7</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The CAN0_TXD function is selected to the pin PD.7</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>GPD_MFP8</name>
              <description>PD.8 Pin Function Selection\nBit GPD_MFP[8] determines the PD.8 function.\n</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO function is selected to the pin PD.8</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>SPI3_SS0 function is selected to the pin PD.8</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>GPD_MFP9</name>
              <description>PD.9 Pin Function Selection\nBit GPD_MFP[9] determines the PD.9 function.\n</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO  is function is selected to the pin PD.9</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>SPI3_CLK function is selected to the pin PD.9</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>GPD_MFP10</name>
              <description>PD.10 Pin Function Selection \nBit GPD_MFP[10] determines the PD.10 function.\n</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO function is selected to the pin PD.10</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>SPI3_MISO0 function is selected to the pin PD.10</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>GPD_MFP11</name>
              <description>PD.11 Pin Function Selection\nBit GPD_MFP[11] determines the PD.11 function.\n</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO function is selected to the pin PD.11</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>SPI3_MOSI0 function is selected to the pin PD.11</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>GPD_MFP12</name>
              <description>PD.12 Pin Function Selection \nBit GPD_MFP[12] determines the PD.12 function.\n</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO function is selected to the pin PD.12</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>SPI3_MISO1 function is selected to the pin PD.12</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>GPD_MFP13</name>
              <description>PD.13 Pin Function Selection \nBit GPD_MFP[13] determines the PD.13 function.\n</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO function is selected to the pin PD.13</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>SPI3_MOSI1 function is selected to the pin PD.13</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>GPD_MFP14</name>
              <description>PD.14 Pin Function Selection \nBits PD14_15_CAN1 (ALT_MFP2[0]) and GPD_MFP[14] determine the PD.14 function.\n(PD14_15_CAN1, GPD_MFP14) value and function mapping is as following list.\n</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GPD_MFP15</name>
              <description>PD.15 Pin Function Selection \nBits PD14_15_CAN1 (ALT_MFP2[0]) and GPD_MFP[15] determine the PD.15 function.\n(PD14_15_CAN1, GPD_MFP15) value and function mapping is as following list.\n</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GPD_TYPEn</name>
              <description>Trigger Function Selection\n</description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIOD[15:0] I/O input Schmitt Trigger function Disabled</description>
                    <value>0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIOD[15:0] I/O input Schmitt Trigger function Enabled</description>
                    <value>1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>GPE_MFP</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>GPE_MFP</displayName>
          <description>GPIOE Multiple Function and Input Type Control Register</description>
          <addressOffset>0x40</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>GPE_MFP0</name>
              <description>PE.0 Pin Function Selection\nBit GPE_MFP[0] determines the PE.0 function.\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO function is selected to the pin PE.0</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PWM6 function is selected to the pin PE.0</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>GPE_MFP1</name>
              <description>PE.1 Pin Function Selection \nBit GPE_MFP[1] determines the PE.1 function.\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO function is selected to the pin PE.1</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PWM7 function is selected to the pin PE.1</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>GPE_MFP5</name>
              <description>PE.5 Pin Function Selection\nBits PE5_T1EX (ALT_MFP[25]), PE5_TM1 (ALT_MFP2[3]) and GPE_MFP5 determine the PE.5 function.\n(PE5_T1EX, PE5_TM1, GPE_MFP5) value and function mapping is as following list.\n</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GPE_TYPEn</name>
              <description>Trigger Function Selection\n</description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIOE[15:0] I/O input Schmitt Trigger function Disabled</description>
                    <value>0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIOE[15:0] I/O input Schmitt Trigger function Enabled</description>
                    <value>1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>GPF_MFP</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>GPF_MFP</displayName>
          <description>GPIOF Multiple Function and Input Type Control Register</description>
          <addressOffset>0x44</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFF0</resetMask>
          <fields>
            <field>
              <name>GPF_MFP0</name>
              <description>PF.0 Pin Function Selection\nBit GPF_MFP[0] determines the PF.0 function\nNote: This bit is read only and is decided by user configuration CGPFMFP (CONFIG0[27]).</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO function is selected to the pin PF.0</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>XT1_OUT function is selected to the pin PF.0</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>GPF_MFP1</name>
              <description>PF.1 Pin Function Selection \nBit GPF_MFP[1] determines the PF.1 function.\nNote: This bit is read only and is decided by user configuration CGPFMFP (CONFIG0[27]).</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO function is selected to the pin PF.1</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>XT1_IN function is selected to the pin PF.1</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>GPF_MFP2</name>
              <description>PF.2 Pin Function Selection\nBit GPF_MFP[2] determines the PF.2 function.\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO function is selected to the pin PF.2</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PS/2_DAT function is selected to the pin PF.2</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>GPF_MFP3</name>
              <description>PF.3 Pin Function Selection \nBit GPF_MFP[3] determines the PF.3 function.\n</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO function is selected to the pin PF.3</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PS/2_CLK function is selected to the pin PF.3</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>GPF_TYPEn</name>
              <description>Trigger Function Selection\n</description>
              <bitOffset>16</bitOffset>
              <bitWidth>4</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIOF[3:0] I/O input Schmitt Trigger function Disabled</description>
                    <value>0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIOF[3:0] I/O input Schmitt Trigger function Enabled</description>
                    <value>1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>ALT_MFP</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>ALT_MFP</displayName>
          <description>Alternative Multiple Function Pin Control Register</description>
          <addressOffset>0x50</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PB10_S01</name>
              <description>PB.10 Pin Alternative Function Selection\nBits PB10_S01 (ALT_MFP[0]) and GPB_MFP[10] determine the PB.10 function.\n(PB10_S01, GPB_MFP10) value and function mapping is as following list.\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PB9_S11</name>
              <description>PB.9 Pin Alternative Function Selection\nBits PB9_S11 (ALT_MFP[1]) and GPB_MFP[9] determine the PB.9 function.\n(PB9_S11, GPB_MFP9) value and function mapping is as following list.\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PA7_S21</name>
              <description>PA.7 Pin Alternative Function Selection\nBits EBI_EN (ALT_MFP[11]), PA7_SC1DAT (ALT_MFP1[6]), PA7_S21 (ALT_MFP[2]) and GPA_MFP[7] determine the PA.7 function.\n(EBI_EN, PA7_SC1DAT, PA7_S21, GPA_MFP7) value and function mapping is as following list.\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PB14_S31</name>
              <description>PB.14 Pin Alternative Function Selection\nBits PB14_15_EBI (ALT_MFP2[1]), PB14_S31 (ALT_MFP[3]) and GPB_MFP[14] determine the PB.14 function.\n(PB14_15_EBI , PB14_S31, GPB_MFP14) value and function mapping is as following list\n</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PB11_PWM4</name>
              <description>PB.11 Pin Alternative Function Selection\nBits PB11_PWM4 (ALT_MFP[4]) and GPB_MFP[11] determine the PB.11 function.\n(PB11_PWM4, GPB_MFP11) value and function mapping is as following list.\n</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PC0_I2SLRCLK</name>
              <description>Bits PC0_I2SLRCLK (ALT_MFP[5]) And GPC_MFP[0] Determine The PC.0 Function\nBits PC0_I2SLRCLK (ALT_MFP[5]) and GPC_MFP[0] determine the PC.0 function.\n(PC0_I2SLRCLK, GPC_MFP0) value and function mapping is as following list.\n</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PC1_I2SBCLK</name>
              <description>PC.1 Pin Alternative Function Selection\nBits PC1_I2SBCLK (ALT_MFP[6]) and GPC_MFP[1] determine the PC.1 function.\n(PC1_I2SBCLK, GPC_MFP1) value and function mapping is as following list.\n</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PC2_I2SDI</name>
              <description>PC.2 Pin Alternative Function Selection\nBits PC2_I2SDI (ALT_MFP[7]) and GPC_MFP[2] determine the PC.2 function.\n(PC2_I2SDI, GPC_MFP2) value and function mapping is as following list.\n</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PC3_I2SDO</name>
              <description>PC.3 Pin Alternative Function Selection\nBits PC3_I2SDO (ALT_MFP[8]) and GPC_MFP[3] determine the PC.3 function.\n(PC3_I2SDO, GPC_MFP3) value and function mapping is as following list.\n</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PA15_I2SMCLK</name>
              <description>PA.15 Pin Alternative Function Selection\nBits PA15_SC2PWR (ALT_MFP1[12]), PA15_I2SMCLK (ALT_MFP[9]) and GPA_MFP[15] determine the PA.15 function.\n(PA15_SC2PWR, PA15_I2SMCLK, GPA_MFP15) value and function mapping is as following list.\n</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EBI_EN</name>
              <description>EBI_EN is use to switch GPIO function to EBI function (AD[15:0], ALE, RE, WE, CS, MCLK), it need additional registers EBI_EN[7:0] and EBI_MCLK_EN for some GPIO to switch to EBI function(AD[15:8], MCLK)</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EBI_MCLK_EN</name>
              <description>Bits EBI_MCLK_EN (ALT_MFP[12]), EBI_EN (ALT_MFP[11]),  GPC_MFP[8] determine the PC.8 function.\n(EBI_MCLK_EN, EBI_EN, GPC_MFP8) value and function mapping is as following list.\n</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EBI_nWRL_EN</name>
              <description>Bits EBI_nWRL_EN (ALT_MFP[13]), EBI_EN (ALT_MFP[11]), PB2_TM2 (ALT_MFP2[4]), PB2_CPO0 (ALT_MFP[30]), PB2_T2EX (ALT_MFP[26]) and GPB_MFP[2] determine the PB.2 function.\n(EBI_nWRL_EN, EBI_EN, PB2_TM2, PB2_CPO0, PB2_T2EX, GPB_MFP2) value and function mapping is as following list.\n</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EBI_nWRH_EN</name>
              <description>Bits EBI_nWRH_EN (ALT_MFP[14]), EBI_EN (ALT_MFP[11]), PB3_TM3 (ALT_MFP2[5]), PB3_SC2CD (ALT_MFP1[14]), PB3_T3EX (ALT_MFP[27]) and GPB_MFP[3] determine the PB.3 function.\n(EBI_nWRH_EN, EBI_EN,  PB3_TM3, PB3_SC2CD, PB3_T3EX, GPB_MFP3) value and function mapping is as following list.\n</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EBI_HB_EN0</name>
              <description>Bits EBI_HB_EN[0] (ALT_MFP[16]), EBI_EN (ALT_MFP[11]),PA5_SC1RST (ALT_MFP1[8]) and GPA_MFP[5] determine the PA.5 function.\n(EBI_HB_EN, EBI_EN, PA5_SC1RST, GPA_MFP5) value and function mapping is as following list,\n</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EBI_HB_EN1</name>
              <description>Bits EBI_HB_EN[1] (ALT_MFP[17]), EBI_EN (ALT_MFP[11]), PA4_SC1PWR (ALT_MFP1[7]) and GPA_MFP[4] determine the PA.4 function.\n(EBI_HB_EN, EBI_EN, PA4_SC1PWR, GPA_MFP4) value and function mapping is as following list.\n</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EBI_HB_EN2</name>
              <description>Bits EBI_HB_EN[2] (ALT_MFP[18]), EBI_EN (ALT_MFP[11]), PA3_SC0DAT (ALT_MFP1[1]) and GPA_MFP[3] determine the PA.3 function.\n(EBI_HB_EN, EBI_EN PA3_SC0DAT, GPA_MFP3) value and function mapping is as following list.\n</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EBI_HB_EN3</name>
              <description>Bits EBI_HB_EN[3] (ALT_MFP[19]), EBI_EN (ALT_MFP[11]), PA2_SC0CLK (ALT_MFP1[0]) and GPA_MFP[2] determine the PA.2 function.\n(EBI_HB_EN, EBI_EN, PA2_SC0CLK, GPA_MFP2) value and function mapping is as following list.\n</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EBI_HB_EN4</name>
              <description>Bit EBI_HB_EN[4] (ALT_MFP[20]), EBI_EN (ALT_MFP[11]), PA1_SC0RST (ALT_MFP1[3]) and GPA_MFP[1] determine the PA.1 function.\n(EBI_HB_EN, EBI_EN, PA1_SC0RST, GPA_MFP1) value and function mapping is as following list.\n</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EBI_HB_EN5</name>
              <description>Bits EBI_HB_EN[5] (ALT_MFP[21]), EBI_EN (ALT_MFP[11]), PA12_SC2DAT (ALT_MFP1[11]) and GPA_MFP[12] determine the PA.12 function.\n(EBI_HB_EN, EBI_EN, PA12_SC2DAT, GPA_MFP12) value and function mapping is as following list.\n</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EBI_HB_EN6</name>
              <description>Bits EBI_HB_EN[6] (ALT_MFP[22]), EBI_EN (ALT_MFP[11]), PA13_SC2CLK (ALT_MFP1[10]) and GPA_MFP[13] determine the PA.13 function.\n(EBI_HB_EN, EBI_EN, PA13_SC2CLK, GPA_MFP13) value and function mapping is as following list.\n</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EBI_HB_EN7</name>
              <description>Bits EBI_HB_EN[7] (ALT_MFP[23]), EBI_EN (ALT_MFP[11]), PA14_SC2RST (ALT_MFP1[13]) and GPA_MFP[14] determine the PA.14 function.\n(EBI_HB_EN, EBI_EN, PA14_SC2RST, GPA_MFP14) value and function mapping is as following list.\n</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PB15_T0EX</name>
              <description>PB.15 Pin Alternative Function Selection\nBits PB14_15_EBI (ALT_MFP2[1]),  PB15_T0EX (ALT_MFP[24]), PB15_TM0 (ALT_MFP2[2]) and GPB_MFP[15] determine the PB.15 function.\n(PB14_15_EBI, PB15_T0EX, PB15_TM0, GPB_MFP15) value and function mapping is as following list.\n</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PE5_T1EX</name>
              <description>PE.5 Pin Alternative Function Selection\nBits PE5_T1EX (ALT_MFP[25]), PE5_TM1 (ALT_MFP2[3]) and GPE_MFP5 determine the PE.5 function.\n(PE5_T1EX, PE5_TM1, GPE_MFP5) value and function mapping is as following list.\n</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PB2_T2EX</name>
              <description>PB.2 Pin Alternative Function Selection\nBits PB2_TM2 (ALT_MFP2[4]), PB2_CPO0 (ALT_MFP[30]), PB2_T2EX (ALT_MFP[26]) and GPB_MFP[2] determine the PB.2 function.\n(PB2_TM2, PB2_CPO0, PB2_T2EX, GPB_MFP2) value and function mapping is as following list.\n</description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PB3_T3EX</name>
              <description>PB.3 Pin Alternative Function Selection\nBits PB3_TM3 (ALT_MFP2[5]), PB3_SC2CD (ALT_MFP1[14]), PB3_T3EX (ALT_MFP[27]) and GPB_MFP[3] determine the PB.3 function.\n(PB3_TM3, PB3_SC2CD, PB3_T3EX, GPB_MFP3) value and function mapping is as following list.\n</description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PA10_11_CAN1</name>
              <description>PA.10 And PA.11 Pin Alternative Function Selection\nBits PA10_11_CAN1 (ALT_MFP[28]) and GPA_MFP[11] determine the PA.11 function.\n(PA10_11_CAN1, GPA_MFP11) value and function mapping is as following list.\n</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PB8_CLKO</name>
              <description>PB.8 Pin Alternative Function Selection\nBits PB8_CLKO (ALT_MFP[29]) and GPB_MFP[8] determine the PB.8 function.\n(PB8_CLKO, GPB_MFP8) value and function mapping is as following list.\n</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PB2_CPO0</name>
              <description>PB.2 Pin Alternative Function Selection\nBits PB2_TM2 (ALT_MFP2[4]), PB2_CPO0 (ALT_MFP[30]), PB2_T2EX (ALT_MFP[26]) and GPB_MFP[2] determine the PB.2 function.\n(PB2_TM2, PB2_CPO0, PB2_T2EX, GPB_MFP2) value and function mapping is as following list.\n</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>ALT_MFP1</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>ALT_MFP1</displayName>
          <description>Alternative Multiple Function Pin Control Register 1</description>
          <addressOffset>0x58</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PA2_SC0CLK</name>
              <description>PA.2 Pin Alternative Function Selection\nBits EBI_HB_EN[3] (ALT_MFP[19]), EBI_EN (ALT_MFP[11]), PA2_SC0CLK (ALT_MFP1[0]) and GPA_MFP[2] determine the PA.2 function.\n(EBI_HB_EN, EBI_EN, PA2_SC0CLK, GPA_MFP2) value and function mapping is as following list.\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PA3_SC0DAT</name>
              <description>PA.3 Pin Alternative Function Selection\nBits EBI_HB_EN[2] (ALT_MFP[18]), EBI_EN (ALT_MFP[11]), PA3_SC0DAT (ALT_MFP1[1]) and GPA_MFP[3] determine the PA.3 function.\n(EBI_HB_EN, EBI_EN PA3_SC0DAT, GPA_MFP3) value and function mapping is as following list.\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PA0_SC0PWR</name>
              <description>PA.0 Pin Alternative Function Selection\nBit PA0_SC0PWR (ALT_MFP1[2]) and GPA_MFP[0] determine the PA.0 function.\n(PA0_SC0PWR, GPA_MFP0) value and function mapping is as following list.\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PA1_SC0RST</name>
              <description>PA.1 Pin Alternative Function Selection\nBit EBI_HB_EN[4] (ALT_MFP[20]), EBI_EN (ALT_MFP[11]), PA1_SC0RST (ALT_MFP1[3]) and GPA_MFP[1] determine the PA.1 function.\n(EBI_HB_EN, EBI_EN, PA1_SC0RST, GPA_MFP1) value and function mapping is as following list.\n</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PC6_SC0CD</name>
              <description>PC.6 Pin Alternative Function Selection\nBits EBI_EN (ALT_MFP[11]), PC6_SC0CD (ALT_MFP1[4]) and GPC_MFP[6] determine the PC.6 function.\n(EBI_EN, PC6_SC0CD, GPB_MFP6) value and function mapping is as following list.\n</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PA6_SC1CLK</name>
              <description>PA.6 Pin Alternative Function Selection\nBits EBI_EN (ALT_MFP[11]), PA6_SC1CLK (ALT_MFP1[5]) and GPA_MFP[6] determine the PA.6 function.\n(EBI_EN , PA6_SC1CLK, GPA_MFP6) value and function mapping is as following list.\n</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PA7_SC1DAT</name>
              <description>PA.7 Pin Alternative Function Selection\nBits EBI_EN (ALT_MFP[11]), PA7_SC1DAT (ALT_MFP1[6]), PA7_S21 (ALT_MFP[2]) and GPA_MFP[7] determine the PA.7 function.\n(EBI_EN, PA7_SC1DAT, PA7_S21, GPA_MFP7) value and function mapping is as following list.\n</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PA4_SC1PWR</name>
              <description>PA.4 Pin Alternative Function Selection\nBits EBI_HB_EN[1] (ALT_MFP[17]), EBI_EN (ALT_MFP[11]),PA5_SC1RST (ALT_MFP1[8]) and GPA_MFP[5] determine the PA.5 function.\n(EBI_HB_EN, EBI_EN, PA5_SC1RST, GPA_MFP5) value and function mapping is as following list.\n</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PA5_SC1RST</name>
              <description>PA.5 Pin Alternative Function Selection\nBits EBI_HB_EN[1] (ALT_MFP[17]), EBI_EN (ALT_MFP[11]),PA5_SC1RST (ALT_MFP1[8]) and GPA_MFP[5] determine the PA.5 function.\n(EBI_HB_EN , EBI_EN, PA5_SC1RST, GPA_MFP5) value and function mapping is as following list.\n</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PC7_SC1CD</name>
              <description>PC.7 Pin Alternative Function Selection\nBits EBI_EN (ALT_MFP[11]), PC7_SC1CD (ALT_MFP1[9]) and GPC_MFP[7] determine the PC.7 function.\n(EBI_EN, PC7_SC1CD, GPC_MFP7) value and function mapping is as following list.\n</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PA13_SC2CLK</name>
              <description>PA.13 Pin Alternative Function Selection\nBits EBI_HB_EN[6] (ALT_MFP[22]), EBI_EN (ALT_MFP[11]), PA13_SC2CLK (ALT_MFP1[10]) and GPA_MFP[13] determine the PA.13 function.\n(EBI_HB_EN, EBI_EN, PA13_SC2CLK, GPA_MFP13) value and function mapping is as following list.\n</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PA12_SC2DAT</name>
              <description>PA.12 Pin Alternative Function Selection\nBits EBI_HB_EN[5] (ALT_MFP[21]), EBI_EN (ALT_MFP[11]), PA12_SC2DAT (ALT_MFP1[11]) and GPA_MFP[12] determine the PA.12 function.\n(EBI_HB_EN, EBI_EN, PA12_SC2DAT, GPA_MFP12) value and function mapping is as following list.\n</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PA15_SC2PWR</name>
              <description>PA.15 Pin Alternative Function Selection\nBits PA15_SC2PWR (ALT_MFP1[12]), PA15_I2SMCLK (ALT_MFP[9]) and GPA_MFP[15] determine the PA.15 function.\n(PA15_SC2PWR, PA15_I2SMCLK, GPA_MFP15) value and function mapping is as following list.\n</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PA14_SC2RST</name>
              <description>PA.14 Pin Alternative Function Selection\nBits EBI_HB_EN[7] (ALT_MFP[23]), EBI_EN (ALT_MFP[11]), PA14_SC2RST (ALT_MFP1[13]) and GPA_MFP[14] determine the PA.14 function.\n(EBI_HB_EN, EBI_EN, PA14_SC2RST, GPA_MFP14) value and function mapping is as following list.\n</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PB3_SC2CD</name>
              <description>PB.3 Pin Alternative Function Selection\nBits EBI_nWRH_EN (ALT_MFP[14]), EBI_EN (ALT_MFP[11]), PB3_TM3 (ALT_MFP2[5]), PB3_SC2CD (ALT_MFP1[14]), PB3_T3EX (ALT_MFP[27]) and GPB_MFP[3] determine the PB.3 function.\n(EBI_nWRH_EN, EBI_EN PB3_TM3, PB3_SC2CD, PB3_T3EX, GPB_MFP3) value and function mapping is as following list.\n</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>ALT_MFP2</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>ALT_MFP2</displayName>
          <description>Alternative Multiple Function Pin Control Register 2</description>
          <addressOffset>0x5C</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PD14_15_CAN1</name>
              <description>PD.14 And PD.15 Pin Alternative Function Selection\nBits PD14_15_CAN1 (ALT_MFP2[0]) and GPD_MFP[15] determine the PD.15 function.\n(PD14_15_CAN1, GPD_MFP15) value and function mapping is as following list.\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PB14_15_EBI</name>
              <description>Bits PB15_T0EX (ALT_MFP[24]), PB14_15_EBI (ALT_MFP2[1]), PB15_TM0 (ALT_MFP2[2]) and GPB_MFP[15] determine the PB.15 function.\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PB15_TM0</name>
              <description>PB.15 Pin Alternative Function Selection\nBits PB14_15_EBI (ALT_MFP2[1]),  PB15_T0EX (ALT_MFP[24]), PB15_TM0 (ALT_MFP2[2]) and GPB_MFP[15] determine the PB.15 function.\n(PB14_15_EBI, PB15_T0EX, PB15_TM0, GPB_MFP15) value and function mapping is as following list.\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PE5_TM1</name>
              <description>PE.5 Pin Alternative Function Selection\nBits PE5_T1EX (ALT_MFP[25]), PE5_TM1 (ALT_MFP2[3]) and GPE_MFP5 determine the PE.5 function.\n(PE5_T1EX, PE5_TM1, GPE_MFP5) value and function mapping is as following list.\n</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PB2_TM2</name>
              <description>PB.2 Pin Alternative Function Selection\nBits EBI_nWRL_EN (ALT_MFP[13]), EBI_EN (ALT_MFP[11]), PB2_TM2 (ALT_MFP2[4]), PB2_CPO0 (ALT_MFP[30]), PB2_T2EX (ALT_MFP[26]) and GPB_MFP[2] determine the PB.2 function.\n(EBI_nWRL_EN, EBI_EN, PB2_TM2, PB2_CPO0, PB2_T2EX, GPB_MFP2) value and function mapping is as following list.\n</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PB3_TM3</name>
              <description>PB.3 Pin Alternative Function Selection\nBits EBI_nWRH_EN (ALT_MFP[14]), EBI_EN (ALT_MFP[11]), PB3_TM3 (ALT_MFP2[5]), PB3_SC2CD (ALT_MFP1[14]), PB3_T3EX (ALT_MFP[27]) and GPB_MFP[3] determine the PB.3 function.\n(EBI_nWRH_EN, EBI_EN PB3_TM3, PB3_SC2CD, PB3_T3EX, GPB_MFP3) value and function mapping is as following list.\n</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>IRCTRIMCTL</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>IRCTRIMCTL</displayName>
          <description>IRC Trim Control Register</description>
          <addressOffset>0x80</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TRIM_SEL</name>
              <description>Trim Frequency Selection\nThis field indicates the target frequency of internal 22.1184 MHz high speed oscillator will trim to precise 22.1184MHz or 24MHz automatically.\nIf no any target frequency is selected (TRIM_SEL is 00), the HIRC auto trim function is disabled.\nDuring auto trim operation, if clock error detected because of CLKERR_STOP_EN is set to 1 or trim retry limitation counts reached, this field will be cleared to 00 automatically.\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>HIRC auto trim function Disabled</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>HIRC auto trim function Enabled and HIRC trimmed to 22.1184 MHz</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>HIRC auto trim function Enabled and HIRC trimmed to 24 MHz</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Reserved</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TRIM_LOOP</name>
              <description>Trim Calculation Loop\nThis field defines that trim value calculation is based on how many 32.768 kHz clocks in.\nFor example, if TRIM_LOOP is set as 00, auto trim circuit will calculate trim value based on the average frequency difference in 4 32.768 kHz clock.\n</description>
              <bitOffset>4</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Trim value calculation is based on average difference in 4 clocks</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Trim value calculation is based on average difference in 8 clocks</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Trim value calculation is based on average difference in 16 clocks</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Trim value calculation is based on average difference in 32 clocks</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TRIM_RETRY_CNT</name>
              <description>Trim Value Update Limitation Count\nThe field defines that how many times of HIRC trim value is updated by auto trim circuit before the HIRC frequency locked.\nOnce the HIRC locked, the internal trim value update counter will be reset.\nIf the trim value update counter reached this limitation value and frequency of HIRC still doesn't lock, the auto trim operation will be disabled and TRIM_SEL will be cleared to 00.\n</description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Trim retry count limitation is 64</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Trim retry count limitation is 128</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Trim retry count limitation is 256</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Trim retry count limitation is 512</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CLKERR_STOP_EN</name>
              <description>Clock Error Stop Enable Bit\n</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The trim operation is kept going if clock is inaccuracy</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The trim operation is stopped if clock is inaccuracy</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>IRCTRIMIEN</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>IRCTRIMIEN</displayName>
          <description>IRC Trim Interrupt Enable Register</description>
          <addressOffset>0x84</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TRIM_FAIL_IEN</name>
              <description>Trim Failure Interrupt Enable Bit\nThis bit controls if an interrupt will be triggered while HIRC trim value update limitation count reached and HIRC frequency still not locked on target frequency set by TRIM_SEL (IRCTRIMCTL[1:0]).\nIf this bit is high and TRIM_FAIL_INT (IRCTRIMINT[1]) is set during auto trim operation. An interrupt will be triggered to notify that HIRC trim value update limitation count was reached.\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>TRIM_FAIL_INT (IRCTRIMINT[1]) status to trigger an interrupt to CPU Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>TRIM_FAIL_INT (IRCTRIMINT[1]) status to trigger an interrupt to CPU Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CLKERR_IEN</name>
              <description>Clock Error Interrupt Enable Bit\nThis bit controls if CPU would get an interrupt while clock is inaccuracy during auto trim operation.\nIf this bit is set to1, and CLKERR_INT (IRCTRIMINT[2]) is set during auto trim operation. An interrupt will be triggered to notify the clock frequency is inaccuracy.\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>CLKERR_INT (IRCTRIMINT[2]) status to trigger an interrupt to CPU Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>CLKERR_INT (IRCTRIMINT[2]) status to trigger an interrupt to CPU Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>IRCTRIMINT</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>IRCTRIMINT</displayName>
          <description>IRC Trim Interrupt Status Register</description>
          <addressOffset>0x88</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>FREQ_LOCK</name>
              <description>HIRC Frequency Lock Status\nThis bit indicates the internal 22.1184 MHz high speed oscillator frequency is locked.\nThis is a status bit and doesn't trigger any interrupt.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TRIM_FAIL_INT</name>
              <description>Trim Failure Interrupt Status\nThis bit indicates that internal 22.1184 MHz high speed oscillator trim value update limitation count reached and the internal 22.1184 MHz high speed oscillator clock frequency still doesn't be locked. Once this bit is set, the auto trim operation stopped and TRIM_SEL (IRCTRIMCTL[1:0]) will be cleared to 00 by hardware automatically.\nIf this bit is set and TRIM_FAIL_IEN (IRCTRIMIEN[1]) is high, an interrupt will be triggered to notify that HIRC trim value update limitation count was reached. Write 1 to clear this to 0.\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Trim value update limitation count did not reach</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Trim value update limitation count reached and internal 22.1184 MHz high speed oscillator frequency was still not locked</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CLKERR_INT</name>
              <description>Clock Error Interrupt Status\nWhen the frequency of external 32.768 kHz low speed crystal or internal 22.1184 MHz high speed oscillator is shift larger to unreasonable value, this bit will be set and to be an indicate that clock frequency is inaccuracy\nOnce this bit is set to 1, the auto trim operation stopped and TRIM_SEL (IRCTRIMCTL[1:0]) will be cleared to 00 by hardware automatically if CLKERR_STOP_EN (IRCTRIMCTL[8]) is set to 1.\nIf this bit is set and CLKERR_IEN (IRCTRIMIEN [2]) is high, an interrupt will be triggered to notify the clock frequency is inaccuracy. Write 1 to clear this to 0.\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Clock frequency is accurate</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Clock frequency is inaccurate</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>REGWRPROT</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>REGWRPROT</displayName>
          <description>Register Write Protection Register</description>
          <addressOffset>0x100</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>REGWRPROT</name>
              <description>Register Write-Protection Code (Write Only)\nSome registers have write-protection function. Writing these registers have to disable the protected function by writing the sequence value "59h", "16h", "88h" to this field. After this sequence is completed, the REGPROTDIS bit will be set to 1 and write-protection registers can be normal write.\nRegister Write-Protection Disable Index (Read Only)\nThe Protected registers are:\nIPRSTC1: address 0x5000_0008\nBODCR: address 0x5000_0018\nPORCR: address 0x5000_0024\nPWRCON: address 0x5000_0200 (bit[6] is not protected for power wake-up interrupt clear) \nAPBCLK bit[0]: address 0x5000_0208 (bit[0] is Watchdog Timer clock enable)\nCLKSEL0: address 0x5000_0210 (for HCLK and CPU STCLK clock source selection)\nCLKSEL1 bit[1:0]: address 0x5000_0214 (for Watchdog Timer clock source selection)\nNMI_SEL bit[8]: address 0x5000_0380 (for NMI_EN interrupt enable)\nISPCON: address 0x5000_C000 (Flash ISP Control register)\nISPTRG: address 0x5000_C010 (ISP Trigger Control register)\nWTCR: address 0x4000_4000\nFATCON: address 0x5000_C018\nNote: The bits which are write-protected will be noted as" (Write Protect)" beside the description.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Write-protection is enabled for writing protected registers. Any write to the protected register is ignored</description>
                    <value>0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Write-protection is disabled for writing protected registers</description>
                    <value>1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>SCS</name>
      <description>SYST_NVIC_SCS Register Map</description>
      <groupName>SYST_NVIC_SCS</groupName>
      <baseAddress>0xE000E000</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x10</offset>
        <size>0xC</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x100</offset>
        <size>0x4</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x180</offset>
        <size>0x4</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x200</offset>
        <size>0x4</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x280</offset>
        <size>0x4</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x400</offset>
        <size>0x20</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0xD00</offset>
        <size>0x8</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0xD0C</offset>
        <size>0x8</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0xD1C</offset>
        <size>0x8</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>SYST_CSR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SYST_CSR</displayName>
          <description>SysTick Control and Status Register</description>
          <addressOffset>0x10</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ENABLE</name>
              <description>System Tick Counter Enabled\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Counter Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Counter will operate in a multi-shot manner</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TICKINT</name>
              <description>System Tick Interrupt Enabled\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Counting down to 0 does not cause the SysTick exception to be pended. Software can use COUNTFLAG to determine if a count to 0 has occurred</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Counting down to 0 will cause the SysTick exception to be pended. Clearing the SysTick Current Value register by a write in software will not cause SysTick to be pended</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CLKSRC</name>
              <description>System Tick Clock Source Selection\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Clock source is (optional) external reference clock</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Core clock used for SysTick</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>COUNTFLAG</name>
              <description>Returns 1 If Timer Counted To 0 Since Last Time This Register Was Read\nCOUNTFLAG is set by a count transition from 1 to 0.\nCOUNTFLAG is cleared on read or by a write to the Current Value register.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SYST_RVR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SYST_RVR</displayName>
          <description>SysTick Reload Value Register</description>
          <addressOffset>0x14</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>RELOAD</name>
              <description>Value to load into the Current Value register when the counter reaches 0.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SYST_CVR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SYST_CVR</displayName>
          <description>SysTick Current Value Register</description>
          <addressOffset>0x18</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>CURRENT</name>
              <description>System Tick Current Value\nCurrent counter value. This is the value of the counter at the time it is sampled. The counter does not provide read-modify-write protection. The register is write-clear. A software write of any value will clear the register to 0.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>NVIC_ISER</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>NVIC_ISER</displayName>
          <description>IRQ0 ~ IRQ31 Set-enable Control Register</description>
          <addressOffset>0x100</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SETENA</name>
              <description>Interrupt Enable Register\nEnable one or more interrupts. Each bit represents an interrupt number from IRQ0 ~ IRQ31 (Vector number from 16 ~ 47).\nWrite Operation:\nRead value indicates the current enable status.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect.\nAssociated interrupt status is Disabled</description>
                    <value>0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Write 1 to enable associated interrupt.\nAssociated interrupt status is Enabled</description>
                    <value>1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>NVIC_ICER</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>NVIC_ICER</displayName>
          <description>IRQ0 ~ IRQ31 Clear-enable Control Register</description>
          <addressOffset>0x180</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CLRENA</name>
              <description>Interrupt Disable Bits\nDisable one or more interrupts. Each bit represents an interrupt number from IRQ0 ~ IRQ31 (Vector number from 16 ~ 47).\nWrite Operation:\nRead value indicates the current enable status.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect.\nAssociated interrupt status is Disabled</description>
                    <value>0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Write 1 to disable associated interrupt.\nAssociated interrupt status is Enabled</description>
                    <value>1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>NVIC_ISPR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>NVIC_ISPR</displayName>
          <description>IRQ0 ~ IRQ31 Set-pending Control Register</description>
          <addressOffset>0x200</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SETPEND</name>
              <description>Set Interrupt Pending Register\nWrite Operation:\nRead value indicates the current pending status.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect.\nAssociated interrupt in not in pending status</description>
                    <value>0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Write 1 to set pending state. Each bit represents an interrupt number from IRQ0 ~ IRQ31 (Vector number from 16 ~ 47).\nAssociated interrupt is in pending status</description>
                    <value>1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>NVIC_ICPR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>NVIC_ICPR</displayName>
          <description>IRQ0 ~ IRQ31 Clear-pending Control Register</description>
          <addressOffset>0x280</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CLRPEND</name>
              <description>Clear Interrupt Pending Register\nWrite Operation:\nRead value indicates the current pending status.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect.\nAssociated interrupt in not in pending status</description>
                    <value>0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Write 1 to clear pending state. Each bit represents an interrupt number from IRQ0 ~ IRQ31 (Vector number from 16 ~ 47).\nAssociated interrupt is in pending status</description>
                    <value>1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>NVIC_IPR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>NVIC_IPR0</displayName>
          <description>IRQ0 ~ IRQ3 Priority Control Register</description>
          <addressOffset>0x400</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PRI_0</name>
              <description>Priority Of IRQ0\n"0" denotes the highest priority and "3" denotes the lowest priority.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PRI_1</name>
              <description>Priority Of IRQ1\n"0" denotes the highest priority and "3" denotes the lowest priority.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PRI_2</name>
              <description>Priority Of IRQ2\n"0" denotes the highest priority and "3" denotes the lowest priority.</description>
              <bitOffset>22</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PRI_3</name>
              <description>Priority Of IRQ3\n"0" denotes the highest priority and "3" denotes the lowest priority.</description>
              <bitOffset>30</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>NVIC_IPR1</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>NVIC_IPR1</displayName>
          <description>IRQ4 ~ IRQ7 Priority Control Register</description>
          <addressOffset>0x404</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PRI_4</name>
              <description>Priority Of IRQ4\n"0" denotes the highest priority and "3" denotes the lowest priority.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PRI_5</name>
              <description>Priority Of IRQ5\n"0" denotes the highest priority and "3" denotes the lowest priority.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PRI_6</name>
              <description>Priority Of IRQ6\n"0" denotes the highest priority and "3" denotes the lowest priority.</description>
              <bitOffset>22</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PRI_7</name>
              <description>Priority Of IRQ7\n"0" denotes the highest priority and "3" denotes the lowest priority.</description>
              <bitOffset>30</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>NVIC_IPR2</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>NVIC_IPR2</displayName>
          <description>IRQ8 ~ IRQ11 Priority Control Register</description>
          <addressOffset>0x408</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PRI_8</name>
              <description>Priority Of IRQ8\n"0" denotes the highest priority and "3" denotes the lowest priority.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PRI_9</name>
              <description>Priority Of IRQ9\n"0" denotes the highest priority and "3" denotes the lowest priority.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PRI_10</name>
              <description>Priority Of IRQ10\n"0" denotes the highest priority and "3" denotes the lowest priority.</description>
              <bitOffset>22</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PRI_11</name>
              <description>Priority Of IRQ11\n"0" denotes the highest priority and "3" denotes the lowest priority.</description>
              <bitOffset>30</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>NVIC_IPR3</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>NVIC_IPR3</displayName>
          <description>IRQ12 ~ IRQ15 Priority Control Register</description>
          <addressOffset>0x40C</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PRI_12</name>
              <description>Priority Of IRQ12\n"0" denotes the highest priority and "3" denotes the lowest priority.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PRI_13</name>
              <description>Priority Of IRQ13\n"0" denotes the highest priority and "3" denotes the lowest priority</description>
              <bitOffset>14</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PRI_14</name>
              <description>Priority Of IRQ14\n"0" denotes the highest priority and "3" denotes the lowest priority.</description>
              <bitOffset>22</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PRI_15</name>
              <description>Priority Of IRQ15\n"0" denotes the highest priority and "3" denotes the lowest priority.</description>
              <bitOffset>30</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>NVIC_IPR4</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>NVIC_IPR4</displayName>
          <description>IRQ16 ~ IRQ19 Priority Control Register</description>
          <addressOffset>0x410</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PRI_16</name>
              <description>Priority Of IRQ16\n"0" denotes the highest priority and "3" denotes the lowest priority.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PRI_17</name>
              <description>Priority Of IRQ17\n"0" denotes the highest priority and "3" denotes the lowest priority.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PRI_18</name>
              <description>Priority Of IRQ18\n"0" denotes the highest priority and "3" denotes the lowest priority.</description>
              <bitOffset>22</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PRI_19</name>
              <description>Priority Of IRQ19\n"0" denotes the highest priority and "3" denotes the lowest priority.</description>
              <bitOffset>30</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>NVIC_IPR5</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>NVIC_IPR5</displayName>
          <description>IRQ20 ~ IRQ23 Priority Control Register</description>
          <addressOffset>0x414</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PRI_20</name>
              <description>Priority Of IRQ20\n"0" denotes the highest priority and "3" denotes the lowest priority.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PRI_21</name>
              <description>Priority Of IRQ21\n"0" denotes the highest priority and "3" denotes the lowest priority</description>
              <bitOffset>14</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PRI_22</name>
              <description>Priority Of IRQ22\n"0" denotes the highest priority and "3" denotes the lowest priority.</description>
              <bitOffset>22</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PRI_23</name>
              <description>Priority Of IRQ23\n"0" denotes the highest priority and "3" denotes the lowest priority.</description>
              <bitOffset>30</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>NVIC_IPR6</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>NVIC_IPR6</displayName>
          <description>IRQ24 ~ IRQ27 Priority Control Register</description>
          <addressOffset>0x418</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PRI_24</name>
              <description>Priority Of IRQ24\n"0" denotes the highest priority and "3" denotes the lowest priority.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PRI_25</name>
              <description>Priority Of IRQ25\n"0" denotes the highest priority and "3" denotes the lowest priority.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PRI_26</name>
              <description>Priority Of IRQ26\n"0" denotes the highest priority and "3" denotes the lowest priority.</description>
              <bitOffset>22</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PRI_27</name>
              <description>Priority Of IRQ27\n"0" denotes the highest priority and "3" denotes the lowest priority.</description>
              <bitOffset>30</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>NVIC_IPR7</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>NVIC_IPR7</displayName>
          <description>IRQ28 ~ IRQ31 Priority Control Register</description>
          <addressOffset>0x41C</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PRI_28</name>
              <description>Priority Of IRQ28\n"0" denotes the highest priority and "3" denotes the lowest priority.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PRI_29</name>
              <description>Priority Of IRQ29\n"0" denotes the highest priority and "3" denotes the lowest priority.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PRI_30</name>
              <description>Priority Of IRQ30\n"0" denotes the highest priority and "3" denotes the lowest priority.</description>
              <bitOffset>22</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PRI_31</name>
              <description>Priority Of IRQ31\n"0" denotes the highest priority and "3" denotes the lowest priority.</description>
              <bitOffset>30</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CPUID</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CPUID</displayName>
          <description>CPUID Register</description>
          <addressOffset>0xD00</addressOffset>
          <access>read-only</access>
          <resetValue>0x410CC200</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>REVISION</name>
              <description>Revision Number\nRead as 0x0</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PARTNO</name>
              <description>Part Number Of The Processor\nRead as 0xC20.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>12</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PART</name>
              <description>Architecture Of The Processor\nRead as 0xC for ARMv6-M parts</description>
              <bitOffset>16</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>IMPLEMENTER</name>
              <description>Implementer Code Assigned By ARM\n</description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>ICSR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>ICSR</displayName>
          <description>Interrupt Control and State Register</description>
          <addressOffset>0xD04</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>VECTACTIVE</name>
              <description>Contains The Active Exception Number\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>6</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Thread mode</description>
                    <value>0</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>VECTPENDING</name>
              <description>Indicates The Exception Number Of The Highest Priority Pending Enabled Exception:\n</description>
              <bitOffset>12</bitOffset>
              <bitWidth>6</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No pending exceptions</description>
                    <value>0</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ISRPENDING</name>
              <description>Interrupt Pending Flag, Excluding NMI And Faults:\nThis bit is read only.</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Interrupt not pending</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Interrupt pending</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ISRPREEMPT</name>
              <description>If Set, A Pending Exception Will Be Serviced On Exit From The Debug Halt State\nThis bit is read only.</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PENDSTCLR</name>
              <description>SysTick Exception Clear-Pending Bit\nWrite Operation:\nThis is a write only bit. When you want to clear PENDST bit, you must "write 0 to PENDSTSET and write 1 to PENDSTCLR" at the same time.</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Removes the pending state from the SysTick exception</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PENDSTSET</name>
              <description>SysTick Exception Set-Pending Bit\nWrite Operation:\n</description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect.\nSysTick exception is not pending</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Changes SysTick exception state to pending.\nSysTick exception is pending</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PENDSVCLR</name>
              <description>PendSV Clear-Pending Bit\nWrite Operation:\nThis is a write only bit. When you want to clear PENDSV bit, you must "write 0 to PENDSVSET and write 1 to PENDSVCLR" at the same time.</description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Removes the pending state from the PendSV exception</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PENDSVSET</name>
              <description>PendSV Set-Pending Bit\nWrite Operation:\nNote: Writing 1 to this bit is the only way to set the PendSV exception state to pending.</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect.\nPendSV exception is not pending</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Changes PendSV exception state to pending.\nPendSV exception is pending</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>NMIPENDSET</name>
              <description>NMI Set-Pending Bit\nWrite Operation:\nBecause NMI is the highest-priority exception, normally the processor enters the NMI exception handler as soon as it detects a write of 1 to this bit. Entering the handler then clears this bit to 0. This means a read of this bit by the NMI exception handler returns 1 only if the NMI signal is reasserted while the processor is executing that handler.</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect.\nNMI exception not pending</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Changes NMI exception state to pending.\nNMI exception pending</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>AIRCR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>AIRCR</displayName>
          <description>Application Interrupt and Reset Control Register</description>
          <addressOffset>0xD0C</addressOffset>
          <access>read-write</access>
          <resetValue>0xFA050000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>VECTCLRACTIVE</name>
              <description>Exception Active Status Clear Bit\nReserved for debug use. When writing to the register, user must write 0 to this bit, otherwise behavior is unpredictable.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SYSRESETREQ</name>
              <description>System Reset Request\nWriting this bit 1 will cause a reset signal to be asserted to the chip to indicate a reset is requested.\nThe bit is a write only bit and self-clears as part of the reset sequence.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>VECTORKEY</name>
              <description>Register Access Key\nWrite Operation:\nWhen writing to this register, the VECTORKEY field need to be set to 0x05FA, otherwise the write operation would be ignored. The VECTORKEY filed is used to prevent accidental write to this register from resetting the system or clearing of the exception status.\nRead Operation:\nRead as 0xFA05.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SCR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SCR</displayName>
          <description>System Control Register</description>
          <addressOffset>0xD10</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SLEEPONEXIT</name>
              <description>Sleep-On-Exit Enable Bit\nThis bit indicates sleep-on-exit when returning from Handler mode to Thread mode.\nSetting this bit to 1 enables an interrupt driven application to avoid returning to an empty main application..</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Do not sleep when returning to Thread mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enter Sleep or Deep Sleep when returning from ISR to Thread mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SLEEPDEEP</name>
              <description>Processor Deep Sleep And Sleep Mode Selection\nControls whether the processor uses sleep or deep sleep as its low power mode:\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Sleep mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Deep Sleep mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SEVONPEND</name>
              <description>Send Event On Pending Bit\nWhen an event or interrupt enters pending state, the event signal wakes up the processor from WFE. If the processor is not waiting for an event, the event is registered and affects the next WFE.\nThe processor also wakes up on execution of an SEV instruction or an external event.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Only enabled interrupts or events can wake-up the processor, disabled interrupts are excluded</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enabled events and all interrupts, including disabled interrupts, can wake-up the processor</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SHPR2</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SHPR2</displayName>
          <description>System Handler Priority Register 2</description>
          <addressOffset>0xD1C</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PRI_11</name>
              <description>Priority Of System Handler 11 - SVCall\n"0" denotes the highest priority and "3" denotes the lowest priority</description>
              <bitOffset>30</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SHPR3</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SHPR3</displayName>
          <description>System Handler Priority Register 3</description>
          <addressOffset>0xD20</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PRI_14</name>
              <description>Priority Of System Handler 14 - PendSV\n"0" denotes the highest priority and "3" denotes the lowest priority</description>
              <bitOffset>22</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PRI_15</name>
              <description>Priority Of System Handler 15 - SysTick\n"0" denotes the highest priority and "3" denotes the lowest priority</description>
              <bitOffset>30</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>INT</name>
      <description>INT Register Map</description>
      <groupName>INT</groupName>
      <baseAddress>0x50000300</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x0</offset>
        <size>0x8C</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>IRQ0_SRC</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>IRQ0_SRC</displayName>
          <description>IRQ0 (BOD) Interrupt Source Identity</description>
          <addressOffset>0x0</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>INT_SRC</name>
              <description>Interrupt Source\nDefine the interrupt sources for interrupt event.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="IRQ0_SRC">
          <name>IRQ1_SRC</name>
          <displayName>IRQ1_SRC</displayName>
          <description>IRQ1 (WDT) Interrupt Source Identity</description>
          <addressOffset>0x4</addressOffset>
       </register>
       <register derivedFrom="IRQ0_SRC">
          <name>IRQ2_SRC</name>
          <displayName>IRQ2_SRC</displayName>
          <description>IRQ2 (EINT0) Interrupt Source Identity</description>
          <addressOffset>0x8</addressOffset>
       </register>
       <register derivedFrom="IRQ0_SRC">
          <name>IRQ3_SRC</name>
          <displayName>IRQ3_SRC</displayName>
          <description>IRQ3 (EINT1) Interrupt Source Identity</description>
          <addressOffset>0xC</addressOffset>
       </register>
       <register derivedFrom="IRQ0_SRC">
          <name>IRQ4_SRC</name>
          <displayName>IRQ4_SRC</displayName>
          <description>IRQ4 (GPA/B) Interrupt Source Identity</description>
          <addressOffset>0x10</addressOffset>
       </register>
       <register derivedFrom="IRQ0_SRC">
          <name>IRQ5_SRC</name>
          <displayName>IRQ5_SRC</displayName>
          <description>IRQ5 (GPC/D/E/F) Interrupt Source Identity</description>
          <addressOffset>0x14</addressOffset>
       </register>
       <register derivedFrom="IRQ0_SRC">
          <name>IRQ6_SRC</name>
          <displayName>IRQ6_SRC</displayName>
          <description>IRQ6 (PWMA) Interrupt Source Identity</description>
          <addressOffset>0x18</addressOffset>
       </register>
       <register derivedFrom="IRQ0_SRC">
          <name>IRQ7_SRC</name>
          <displayName>IRQ7_SRC</displayName>
          <description>IRQ7 (PWMB) Interrupt Source Identity</description>
          <addressOffset>0x1C</addressOffset>
       </register>
       <register derivedFrom="IRQ0_SRC">
          <name>IRQ8_SRC</name>
          <displayName>IRQ8_SRC</displayName>
          <description>IRQ8 (TMR0) Interrupt Source Identity</description>
          <addressOffset>0x20</addressOffset>
       </register>
       <register derivedFrom="IRQ0_SRC">
          <name>IRQ9_SRC</name>
          <displayName>IRQ9_SRC</displayName>
          <description>IRQ9 (TMR1) Interrupt Source Identity</description>
          <addressOffset>0x24</addressOffset>
       </register>
       <register derivedFrom="IRQ0_SRC">
          <name>IRQ10_SRC</name>
          <displayName>IRQ10_SRC</displayName>
          <description>IRQ10 (TMR2) Interrupt Source Identity</description>
          <addressOffset>0x28</addressOffset>
       </register>
       <register derivedFrom="IRQ0_SRC">
          <name>IRQ11_SRC</name>
          <displayName>IRQ11_SRC</displayName>
          <description>IRQ11 (TMR3) Interrupt Source Identity</description>
          <addressOffset>0x2C</addressOffset>
       </register>
       <register derivedFrom="IRQ0_SRC">
          <name>IRQ12_SRC</name>
          <displayName>IRQ12_SRC</displayName>
          <description>IRQ12 (UART0/2) Interrupt Source Identity</description>
          <addressOffset>0x30</addressOffset>
       </register>
       <register derivedFrom="IRQ0_SRC">
          <name>IRQ13_SRC</name>
          <displayName>IRQ13_SRC</displayName>
          <description>IRQ13 (UART1) Interrupt Source Identity</description>
          <addressOffset>0x34</addressOffset>
       </register>
       <register derivedFrom="IRQ0_SRC">
          <name>IRQ14_SRC</name>
          <displayName>IRQ14_SRC</displayName>
          <description>IRQ14 (SPI0) Interrupt Source Identity</description>
          <addressOffset>0x38</addressOffset>
       </register>
       <register derivedFrom="IRQ0_SRC">
          <name>IRQ15_SRC</name>
          <displayName>IRQ15_SRC</displayName>
          <description>IRQ15 (SPI1) Interrupt Source Identity</description>
          <addressOffset>0x3C</addressOffset>
       </register>
       <register derivedFrom="IRQ0_SRC">
          <name>IRQ16_SRC</name>
          <displayName>IRQ16_SRC</displayName>
          <description>IRQ16 (SPI2) Interrupt Source Identity</description>
          <addressOffset>0x40</addressOffset>
       </register>
       <register derivedFrom="IRQ0_SRC">
          <name>IRQ17_SRC</name>
          <displayName>IRQ17_SRC</displayName>
          <description>IRQ17 (SPI3) Interrupt Source Identity</description>
          <addressOffset>0x44</addressOffset>
       </register>
       <register derivedFrom="IRQ0_SRC">
          <name>IRQ18_SRC</name>
          <displayName>IRQ18_SRC</displayName>
          <description>IRQ18 (I2C0) Interrupt Source Identity</description>
          <addressOffset>0x48</addressOffset>
       </register>
       <register derivedFrom="IRQ0_SRC">
          <name>IRQ19_SRC</name>
          <displayName>IRQ19_SRC</displayName>
          <description>IRQ19 (I2C1) Interrupt Source Identity</description>
          <addressOffset>0x4C</addressOffset>
       </register>
       <register derivedFrom="IRQ0_SRC">
          <name>IRQ20_SRC</name>
          <displayName>IRQ20_SRC</displayName>
          <description>Reserved</description>
          <addressOffset>0x50</addressOffset>
       </register>
       <register derivedFrom="IRQ0_SRC">
          <name>IRQ21_SRC</name>
          <displayName>IRQ21_SRC</displayName>
          <description>Reserved</description>
          <addressOffset>0x54</addressOffset>
       </register>
       <register derivedFrom="IRQ0_SRC">
          <name>IRQ22_SRC</name>
          <displayName>IRQ22_SRC</displayName>
          <description>IRQ22 (SC0/1/2) Interrupt Source Identity</description>
          <addressOffset>0x58</addressOffset>
       </register>
       <register derivedFrom="IRQ0_SRC">
          <name>IRQ23_SRC</name>
          <displayName>IRQ23_SRC</displayName>
          <description>IRQ23 (USBD) Interrupt Source Identity</description>
          <addressOffset>0x5C</addressOffset>
       </register>
       <register derivedFrom="IRQ0_SRC">
          <name>IRQ24_SRC</name>
          <displayName>IRQ24_SRC</displayName>
          <description>IRQ24 (PS/2) Interrupt Source Identity</description>
          <addressOffset>0x60</addressOffset>
       </register>
       <register derivedFrom="IRQ0_SRC">
          <name>IRQ25_SRC</name>
          <displayName>IRQ25_SRC</displayName>
          <description>IRQ25 (ACMP) Interrupt Source Identity</description>
          <addressOffset>0x64</addressOffset>
       </register>
       <register derivedFrom="IRQ0_SRC">
          <name>IRQ26_SRC</name>
          <displayName>IRQ26_SRC</displayName>
          <description>IRQ26 (PDMA) Interrupt Source Identity</description>
          <addressOffset>0x68</addressOffset>
       </register>
       <register derivedFrom="IRQ0_SRC">
          <name>IRQ27_SRC</name>
          <displayName>IRQ27_SRC</displayName>
          <description>IRQ27 (I2S) Interrupt Source Identity</description>
          <addressOffset>0x6C</addressOffset>
       </register>
       <register derivedFrom="IRQ0_SRC">
          <name>IRQ28_SRC</name>
          <displayName>IRQ28_SRC</displayName>
          <description>IRQ28 (PWRWU) Interrupt Source Identity</description>
          <addressOffset>0x70</addressOffset>
       </register>
       <register derivedFrom="IRQ0_SRC">
          <name>IRQ29_SRC</name>
          <displayName>IRQ29_SRC</displayName>
          <description>IRQ29 (ADC) Interrupt Source Identity</description>
          <addressOffset>0x74</addressOffset>
       </register>
       <register derivedFrom="IRQ0_SRC">
          <name>IRQ30_SRC</name>
          <displayName>IRQ30_SRC</displayName>
          <description>IRQ30 (IRC) Interrupt Source Identity</description>
          <addressOffset>0x78</addressOffset>
       </register>
       <register derivedFrom="IRQ0_SRC">
          <name>IRQ31_SRC</name>
          <displayName>IRQ31_SRC</displayName>
          <description>IRQ31 (RTC) Interrupt Source Identity</description>
          <addressOffset>0x7C</addressOffset>
       </register>
       <register>
          <name>NMI_SEL</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>NMI_SEL</displayName>
          <description>NMI Source Interrupt Select Control Register</description>
          <addressOffset>0x80</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>NMI_SEL</name>
              <description>NMI Interrupt Source Selection\nThe NMI interrupt to Cortex-M0 can be selected from one of the peripheral interrupt by setting NMI_SEL.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>NMI_EN</name>
              <description>NMI Interrupt Enable Bit (Write Protect)\nNote: This bit is the protected bit, and programming it needs to write "59h", "16h", and "88h" to address 0x5000_0100 to disable register protection. Refer to the register REGWRPROT at address GCR_BA+0x100.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>NMI interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>NMI interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>MCU_IRQ</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>MCU_IRQ</displayName>
          <description>MCU Interrupt Request Source Register</description>
          <addressOffset>0x84</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MCU_IRQ</name>
              <description>MCU IRQ Source Register\nThe MCU_IRQ collects all the interrupts from the peripherals and generates the synchronous interrupt to Cortex-M0. There are two modes to generate interrupt to Cortex-M0, the normal mode and test mode.\nThe MCU_IRQ collects all interrupts from each peripheral and synchronizes them and interrupts the Cortex-M0.\nWhen the MCU_IRQ[n] is 0: Set MCU_IRQ[n] 1 will generate an interrupt to Cortex-M0 NVIC[n].\nWhen the MCU_IRQ[n] is 1 (mean an interrupt is assert), setting 1 to the MCU_IRQ[n] 1 will clear the interrupt and setting MCU_IRQ[n] 0: has no effect</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>MCU_IRQCR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>MCU_IRQCR</displayName>
          <description>MCU Interrupt Request Control Register</description>
          <addressOffset>0x88</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>FAST_IRQ</name>
              <description>Fast IRQ Latency Enable Bit\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>MCU IRQ latency is fixed at 13 clock cycles of HCLK, MCU will enter IRQ handler after this fixed latency when interrupt happened</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>MCU IRQ latency will not fixed, MCU will enter IRQ handler as soon as possible when interrupt happened</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>CLK</name>
      <description>CLK Register Map</description>
      <groupName>CLK</groupName>
      <baseAddress>0x50000200</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x0</offset>
        <size>0x28</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x30</offset>
        <size>0xC</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>PWRCON</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PWRCON</displayName>
          <description>System Power-down Control Register</description>
          <addressOffset>0x0</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000010</resetValue>
          <resetMask>0xFFFFFFF0</resetMask>
          <fields>
            <field>
              <name>XTL12M_EN</name>
              <description>4~24 MHz External High Speed Crystal Oscillator (HXT) Enable Bit (Write Protect)\nThe bit default value is set by flash controller user configuration register CONFIG0 [26:24]. When the default clock source is from 4~24 MHz external high speed crystal oscillator, this  bit is set to 1 automatically.\nNote: This bit is the protected bit, and programming it needs to write "59h", "16h", and "88h" to address 0x5000_0100 to disable register protection. Refer to the register REGWRPROT at address GCR_BA+0x100.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>4 ~ 24 MHz external high speed crystal oscillators (HXT) Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>4~24 MHz external high speed crystal oscillator (HXT) Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>XTL32K_EN</name>
              <description>32.768 KHz External Low Speed Crystal Oscillator (LXT) Enable Bit (Write Protect)\nNote: This bit is the protected bit, and programming it needs to write "59h", "16h", and "88h" to address 0x5000_0100 to disable register protection. Refer to the register REGWRPROT at address GCR_BA+0x100.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>32.768 kHz external low speed crystal oscillator (LXT) Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>32.768 kHz external low speed crystal oscillator (LXT) Enabled (Normal operation)</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>OSC22M_EN</name>
              <description>22.1184 MHz Internal High Speed RC Oscillator (HIRC) Enable Bit (Write Protect)\nNote: This bit is the protected bit, and programming it needs to write "59h", "16h", and "88h" to address 0x5000_0100 to disable register protection. Refer to the register REGWRPROT at address GCR_BA+0x100.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>22.1184 MHz internal high speed RC oscillator (HIRC) Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>22.1184 MHz internal high speed RC oscillator (HIRC) Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>OSC10K_EN</name>
              <description>10 KHz Internal Low Speed RC Oscillator (LIRC) Enable Bit (Write Protect)\nNote: This bit is the protected bit, and programming it needs to write "59h", "16h", and "88h" to address 0x5000_0100 to disable register protection. Refer to the register REGWRPROT at address GCR_BA+0x100.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>10 kHz internal low speed RC oscillator (LIRC) Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>10 kHz internal low speed RC oscillator (LIRC) Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PD_WU_DLY</name>
              <description>Wake-Up Delay Counter Enable Bit (Write Protect)\nWhen the chip wakes up from Power-down mode, the clock control will delay certain clock cycles to wait system clock stable.\nThe delayed clock cycle is 4096 clock cycles when chip work at external 4~24 MHz high speed crystal, and 256 clock cycles when chip work at internal 22.1184 MHz high speed oscillator.\nNote: This bit is the protected bit, and programming it needs to write "59h", "16h", and "88h" to address 0x5000_0100 to disable register protection. Refer to the register REGWRPROT at address GCR_BA+0x100.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Clock cycles delay Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Clock cycles delay Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PD_WU_INT_EN</name>
              <description>Power-Down Mode Wake-Up Interrupt Enable Bit (Write Protect)\nNote1: The interrupt will occur when both PD_WU_STS and PD_WU_INT_EN are high.\nNote2: This bit is the protected bit, and programming it needs to write "59h", "16h", and "88h" to address 0x5000_0100 to disable register protection. Refer to the register REGWRPROT at address GCR_BA+0x100.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Power-down mode wake-up interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Power-down mode wake-up interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PD_WU_STS</name>
              <description>Power-Down Mode Wake-Up Interrupt Status\nSet by "Power-down wake-up event", it indicates that resume from Power-down mode" \nThe flag is set if the GPIO, USB, UART, WDT, I2C, TIMER, ACMP, BOD or RTC wake-up occurred\nWrite 1 to clear the bit to 0.\nNote: This bit is working only if PD_WU_INT_EN (PWRCON[5]) set to 1.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PWR_DOWN_EN</name>
              <description>System Power-Down Enable Bit (Write Protect)\nWhen this bit is set to 1, Power-down mode is enabled and chip Power-down behavior will depends on the PD_WAIT_CPU bit\n(a) If the PD_WAIT_CPU is 0, the chip enters Power-down mode immediately after the PWR_DOWN_EN bit set.\n(b) if the PD_WAIT_CPU is 1, the chip keeps active till the CPU sleep mode is also active and then the chip enters Power-down mode (recommend)\nWhen chip wakes up from Power-down mode, this bit is cleared by hardware. User needs to set this bit again for next Power-down.\nIn Power-down mode, 4~24 MHz external high speed crystal oscillator and the 22.1184 MHz internal high speed RC oscillator will be disabled in this mode, but the 32.768 kHz external low speed crystal oscillator and 10 kHz internal low speed oscillator are not controlled by Power-down mode.\nIn Power- down mode, the PLL and system clock are disabled, and ignored the clock source selection. The clocks of peripheral are not controlled by Power-down mode, if the peripheral clock source is from 32.768 kHz external low speed crystal oscillator or the internal 10 kHz low speed oscillator.\nNote: This bit is the protected bit, and programming it needs to write "59h", "16h", and "88h" to address 0x5000_0100 to disable register protection. Refer to the register REGWRPROT at address GCR_BA+0x100.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Chip operating normally or chip in Idle mode because of WFI command</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Chip enters Power-down mode instantly or waits CPU sleep command WFI</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PD_WAIT_CPU</name>
              <description>Power-Down Entry Condition Control (Write Protect)\nNote: This bit is the protected bit, and programming it needs to write "59h", "16h", and "88h" to address 0x5000_0100 to disable register protection. Refer to the register REGWRPROT at address GCR_BA+0x100.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Chip enters Power-down mode when the PWR_DOWN_EN bit is set to 1</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Chip enters Power- down mode when the both PD_WAIT_CPU and PWR_DOWN_EN bits are set to 1 and CPU run WFI instruction</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>AHBCLK</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>AHBCLK</displayName>
          <description>AHB Devices Clock Enable Control Register</description>
          <addressOffset>0x4</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000005</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_EN</name>
              <description>PDMA Controller Clock Enable Bit\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PDMA peripherial clock Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PDMA peripherial clock Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ISP_EN</name>
              <description>Flash ISP Controller Clock Enable Bit\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Flash ISP peripherial clock Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Flash ISP peripherial clock Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>EBI_EN</name>
              <description>EBI Controller Clock Enable Control\n</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>EBI engine clock Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>EBI engine clock Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>APBCLK</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>APBCLK</displayName>
          <description>APB Devices Clock Enable Control Register</description>
          <addressOffset>0x8</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFF0</resetMask>
          <fields>
            <field>
              <name>WDT_EN</name>
              <description>Watchdog Timer Clock Enable Bit (Write Protect)\nNote: This bit is the protected bit, and programming it needs to write "59h", "16h", and "88h" to address 0x5000_0100 to disable register protection. Refer to the register REGWRPROT at address GCR_BA+0x100.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Watchdog Timer clock Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Watchdog Timer clock Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RTC_EN</name>
              <description>Real-Time-Clock APB Interface Clock Enable Bit\nThis bit is used to control the RTC APB clock only, The RTC peripheral clock source is selected from RTC_SEL_10K(CLKSEL2[18]). It can be selected to the 32.768 kHz external low speed crystal oscillator or 10 kHz internal low speed RC oscillator.\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RTC clock Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RTC clock Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TMR0_EN</name>
              <description>Timer0 Clock Enable Bit\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Timer0 clock Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Timer0 clock Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TMR1_EN</name>
              <description>Timer1 Clock Enable Bit\n</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Timer1 clock Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Timer1 clock Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TMR2_EN</name>
              <description>Timer2 Clock Enable Bit\n</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Timer2 clock Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Timer2 clock Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TMR3_EN</name>
              <description>Timer3 Clock Enable Bit\n</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Timer3 clock Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Timer3 clock Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>FDIV_EN</name>
              <description>Frequency Divider Output Clock Enable Bit\n</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>FDIV clock Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>FDIV clock Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C0_EN</name>
              <description>I2C0 Clock Enable Bit\n</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>I2C0 clock Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>I2C0 clock Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C1_EN</name>
              <description>I2C1 Clock Enable Bit\n</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>I2C1 clock Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>I2C1 clock Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SPI0_EN</name>
              <description>SPI0 Clock Enable Bit\n</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>SPI0 clock Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>SPI0 clock Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SPI1_EN</name>
              <description>SPI1 Clock Enable Bit\n</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>SPI1 clock Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>SPI1 clock Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SPI2_EN</name>
              <description>SPI2 Clock Enable Bit\n</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>SPI2 clock Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>SPI2 clock Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SPI3_EN</name>
              <description>SPI3 Clock Enable Bit\n</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>SPI3 clock Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>SPI3 clock Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>UART0_EN</name>
              <description>UART0 Clock Enable Bit\n</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>UART0 clock Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>UART0 clock Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>UART1_EN</name>
              <description>UART1 Clock Enable Bit\n</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>UART1 clock Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>UART1 clock Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>UART2_EN</name>
              <description>UART2 Clock Enable Bit\n</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>UART2 clock Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>UART2 clock Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PWM01_EN</name>
              <description>PWM_01 Clock Enable Bit\n</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM01 clock Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PWM01 clock Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PWM23_EN</name>
              <description>PWM_23 Clock Enable Bit\n</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM23 clock Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PWM23 clock Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PWM45_EN</name>
              <description>PWM_45 Clock Enable Bit\n</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM45 clock Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PWM45 clock Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PWM67_EN</name>
              <description>PWM_67 Clock Enable Bit\n</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM67 clock Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PWM67 clock Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CAN0_EN</name>
              <description>CAN Bus Controller-0 Clock Enable Bit\n</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>CAN0 clock Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>CAN0 clock Enable</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CAN1_EN</name>
              <description>CAN Bus Controller-1 Clock Enable Bit\n</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>CAN1 clock Disable</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>CAN1 clock Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>USBD_EN</name>
              <description>USB 2.0 FS Device Controller Clock Enable Bit\n</description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>USB clock Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>USB clock Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ADC_EN</name>
              <description>Analog-Digital-Converter (ADC) Clock Enable Bit\n</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>ADC clock Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>ADC clock Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>I2S_EN</name>
              <description>I2S Clock Enable Bit\n</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>I2S clock Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>I2S clock Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ACMP_EN</name>
              <description>Analog Comparator Clock Enable Bit\n</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Analog Comparator clock Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Analog Comparator clock Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PS2_EN</name>
              <description>PS/2 Clock Enable Bit\n</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PS/2 clock Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PS/2 clock Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CLKSTATUS</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CLKSTATUS</displayName>
          <description>Clock Status Monitor Register</description>
          <addressOffset>0xC</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFF00</resetMask>
          <fields>
            <field>
              <name>XTL12M_STB</name>
              <description>4~24 MHz External High Speed Crystal Oscillator (HXT) Clock Source Stable Flag (Read Only)\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>4~24 MHz external high speed crystal oscillator (HXT) clock is not stable or disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>4~24 MHz external high speed crystal oscillator (HXT) clock is stable and enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>XTL32K_STB</name>
              <description>32.768 KHz External Low Speed Crystallator Oscillator (LXT) Clock Source Stable Flag (Read Only)\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>32.768 kHz external low speed crystal oscillator (LXT) clock is not stable or disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>32.768 kHz external low speed crystal oscillator (LXT) clock is stable and enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>PLL_STB</name>
              <description>Internal PLL Clock Source Stable Flag (Read Only)\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Internal PLL clock is not stable or disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Internal PLL clock is stable in normal mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>OSC10K_STB</name>
              <description>Internal 10 KHz Low Speed Oscillator (LIRC) Clock Source Stable Flag (Read Only)\n</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>10 kHz internal low speed RC oscillator (LIRC) clock  is not stable or disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>10 kHz internal low speed RC oscillator (LIRC) clock is stable and enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>OSC22M_STB</name>
              <description>22.1184 MHz Internal High Speed RC Oscillator (HIRC) Clock Source Stable Flag (Read Only)\n</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>22.1184 MHz internal high speed RC oscillator (HIRC) clock is not stable or disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>22.1184 MHz internal high speed RC oscillator (HIRC) clock is stable and enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>CLK_SW_FAIL</name>
              <description>Clock Switching Fail Flag (Read Only)\nThis bit is an index that if current system clock source is match as user defined at HCLK_S (CLKSEL[2:0]). When user switch system clock, the system clock source will keep old clock until the new clock is stable. During the period that waiting new clock stable, this bit will be an index shows system clock source is not match as user wanted.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Clock switching success</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Clock switching failure</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CLKSEL0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CLKSEL0</displayName>
          <description>Clock Source Select Control Register 0</description>
          <addressOffset>0x10</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000030</resetValue>
          <resetMask>0xFFFFFFF0</resetMask>
          <fields>
            <field>
              <name>HCLK_S</name>
              <description>HCLK Clock Source Select (Write Protect)\nBefore clock switching, the related clock sources (both pre-select and new-select) must be enabled\nThe 3-bit default value is reloaded from the value of CFOSC (CONFIG0[26:24]) in user configuration register of Flash controller by any reset. Therefore the default value is either 000b or 111b.\nThese bits are protected bit, It means programming this bit needs to write "59h", "16h", "88h" to address 0x5000_0100 to disable register protection. Refer to the register REGWRPROT at address GCR_BA+0x100.\nNote: This bit is the protected bit, and programming it needs to write "59h", "16h", and "88h" to address 0x5000_0100 to disable register protection. Refer to the register REGWRPROT at address GCR_BA+0x100.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Clock source from 4~24 MHz external high speed crystal oscillator clock</description>
                    <value>#000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Clock source from 32.768 kHz external low speed crystal oscillator clock</description>
                    <value>#001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Clock source from PLL clock</description>
                    <value>#010</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Clock source from 10 kHz internal low speed RC oscillator clock</description>
                    <value>#011</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>7</name>
                    <description>Clock source from  22.1184 MHz internalhigh speed RC oscillator clock</description>
                    <value>#111</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>STCLK_S</name>
              <description>Cortex-M0 SysTick Clock Source Select (Write Protect)\n</description>
              <bitOffset>3</bitOffset>
              <bitWidth>3</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Clock source from 4~24 MHz external high speed crystal oscillator clock</description>
                    <value>#000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Clock source from 32.768 kHz external low speed crystal oscillator clock</description>
                    <value>#001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Clock source from 4~24 MHz external high speed crystal oscillator clock/2</description>
                    <value>#010</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Clock source from HCLK/2</description>
                    <value>#011</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>7</name>
                    <description>Clock source from 22.1184 MHz internal high speed RC oscillator clock/2</description>
                    <value>#111</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CLKSEL1</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CLKSEL1</displayName>
          <description>Clock Source Select Control Register 1</description>
          <addressOffset>0x14</addressOffset>
          <access>read-write</access>
          <resetValue>0xFFFFFFFF</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WDT_S</name>
              <description>Watchdog Timer Clock Source Select (Write Protect)\nNote: This bit is the protected bit, and programming it needs to write "59h", "16h", and "88h" to address 0x5000_0100 to disable register protection. Refer to the register REGWRPROT at address GCR_BA+0x100.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Reserved</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Clock source from 32.768 kHz external low speed crystal oscillator clock</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Clock source from HCLK/2048 clock</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Clock source from 10 kHz internal low speed RC oscillator clock</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ADC_S</name>
              <description>ADC Clock Source Select\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Clock source from 4~24 MHz external high speed crystal oscillator clock</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Clock source from PLL clock</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Clock source from HCLK</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Clock source from 22.1184 MHz internal high speed RC oscillator clock</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SPI0_S</name>
              <description>SPI0 Clock Source Selection\n</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Clock source from PLL clock</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Clock source from HCLK</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SPI1_S</name>
              <description>SPI1 Clock Source Selection\n</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Clock source from PLL clock</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Clock source from HCLK</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SPI2_S</name>
              <description>SPI2 Clock Source Selection\n</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Clock source from PLL clock</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Clock source from HCLK</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SPI3_S</name>
              <description>SPI3 Clock Source Selection\n</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Clock source from PLL clock</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Clock source from HCLK</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TMR0_S</name>
              <description>TIMER0 Clock Source Selection\n</description>
              <bitOffset>8</bitOffset>
              <bitWidth>3</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Clock source from 4~24 MHz external high speed crystal oscillator clock</description>
                    <value>#000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Clock source from 32.768 kHz external low speed crystal oscillator clock</description>
                    <value>#001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Clock source from HCLK</description>
                    <value>#010</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Clock source from external trigger</description>
                    <value>#011</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>5</name>
                    <description>Clock source from 10 kHz internal low speed RC oscillator clock</description>
                    <value>#101</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>7</name>
                    <description>Clock source from 22.1184 MHz internal high speed RC oscillator clock</description>
                    <value>#111</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TMR1_S</name>
              <description>TIMER1 Clock Source Selection\n</description>
              <bitOffset>12</bitOffset>
              <bitWidth>3</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Clock source from 4~24 MHz external high speed crystal oscillator clock</description>
                    <value>#000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Clock source from 32.768 kHz external low speed crystal oscillator clock</description>
                    <value>#001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Clock source from HCLK</description>
                    <value>#010</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Clock source from external trigger</description>
                    <value>#011</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>5</name>
                    <description>Clock source from 10 kHz internal low speed RC oscillator clock</description>
                    <value>#101</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>7</name>
                    <description>Clock source from 22.1184 MHz internal high speed RC oscillator clock</description>
                    <value>#111</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TMR2_S</name>
              <description>TIMER2 Clock Source Selection\n</description>
              <bitOffset>16</bitOffset>
              <bitWidth>3</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Clock source from external 4~24 MHz high speed crystal oscillator clock</description>
                    <value>#000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Clock source from external 32.768 kHz low speed crystal oscillator clock</description>
                    <value>#001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Clock source from HCLK</description>
                    <value>#010</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Clock source from external trigger</description>
                    <value>#011</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>5</name>
                    <description>Clock source from internal 10 kHz low speed RC oscillator clock</description>
                    <value>#101</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>7</name>
                    <description>Clock source from internal 22.1184 MHz high speed RC oscillator clock</description>
                    <value>#111</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TMR3_S</name>
              <description>TIMER3 Clock Source Selection\n</description>
              <bitOffset>20</bitOffset>
              <bitWidth>3</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Clock source from 4~24 MHz external high speed crystal oscillator clock</description>
                    <value>#000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Clock source from 32.768 kHz external low speed crystal oscillator clock</description>
                    <value>#001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Clock source from HCLK</description>
                    <value>#010</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Clock source from external trigger</description>
                    <value>#011</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>5</name>
                    <description>Clock source from 10 kHz internal low speed RC oscillator clock</description>
                    <value>#101</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>7</name>
                    <description>Clock source from 22.1184 MHz internal high speed RC oscillator clock</description>
                    <value>#111</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>UART_S</name>
              <description>UART Clock Source Selection\n</description>
              <bitOffset>24</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Clock source from 4~24 MHz external high speed crystal oscillator clock</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Clock source from PLL clock</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Clock source from 22.1184 MHz internal high speed RC oscillator clock</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PWM01_S</name>
              <description>PWM0 And PWM1 Clock Source Selection\nPWM0 and PWM1 used the same peripheral clock source; both of them used the same prescaler. The peripheral clock source of PWM0 and PWM1 is defined by PWM01_S (CLKSEL1[29:28]) and PWM01_S_E (CLKSEL2[8]).\n</description>
              <bitOffset>28</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PWM23_S</name>
              <description>PWM2 And PWM3 Clock Source Selection\nPWM2 and PWM3 used the same peripheral clock source; both of them used the same prescaler. The peripheral clock source of PWM2 and PWM3 is defined by PWM23_S (CLKSEL1[31:30]) and PWM23_S_E (CLKSEL2[9]).\n</description>
              <bitOffset>30</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Clock source from 4~24 MHz external high speed crystal oscillator clock.\nReserved</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Clock source from 32.768 kHz external low speed crystal oscillator clock.\nReserved</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Clock source from HCLK.\nReserved</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Clock source from 22.1184 MHz internal high speed RC oscillator clock.\nClock source from 10 kHz internal low speed RC oscillator clock</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CLKDIV</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CLKDIV</displayName>
          <description>Clock Divider Number Register</description>
          <addressOffset>0x18</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>HCLK_N</name>
              <description>HCLK Clock Divide Number From HCLK Clock Source\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>USB_N</name>
              <description>USB Clock Divide Number From PLL Clock\n</description>
              <bitOffset>4</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>UART_N</name>
              <description>UART Clock Divide Number From UART Clock Source\n</description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ADC_N</name>
              <description>ADC Clock Divide Number From ADC Clock Source\n</description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CLKSEL2</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CLKSEL2</displayName>
          <description>Clock Source Select Control Register 2</description>
          <addressOffset>0x1C</addressOffset>
          <access>read-write</access>
          <resetValue>0x000200FF</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>I2S_S</name>
              <description>I2S Clock Source Selection\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Clock source from 4~24 MHz external high speed crystal oscillator clock</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Clock source from PLL clock</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Clock source from HCLK</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Clock source from 22.1184 MHz internal high speed RC oscillator clock</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>FRQDIV_S</name>
              <description>Clock Divider Clock Source Selection\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Clock source from 4~24 MHz external high speed crystal oscillator clock</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Clock source from 32.768 kHz external low speed crystal oscillator clock</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Clock source from HCLK</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Clock source from 22.1184 MHz internal high speed RC oscillator clock</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PWM45_S</name>
              <description>PWM4 And PWM5 Clock Source Selection\nPWM4 and PWM5 used the same peripheral clock source; both of them used the same prescaler. The peripheral clock source of PWM4 and PWM5 is defined by PWM45_S (CLKSEL2[5:4]) and PWM45_S_E (CLKSEL2[10]).\n</description>
              <bitOffset>4</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Clock source from 4~24 MHz external high speed crystal oscillator clock.\nReserved</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Clock source from 32.768 kHz external low speed crystal oscillator clock.\nReserved</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Clock source from HCLK.\nReserved</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Clock source from 22.1184 MHz internal high speed RC oscillator clock.\nClock source from 10 kHz internal low speed RC oscillator clock</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PWM67_S</name>
              <description>PWM6 And PWM7 Clock Source Selection\nPWM6 and PWM7 used the same peripheral clock source; both of them used the same prescaler. The peripheral clock source of PWM6 and PWM7 is defined by PWM67_S (CLKSEL2[7:6]) and PWM67_S_E (CLKSEL2[11]).\n</description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Clock source from 4~24 MHz external high speed crystal oscillator clock.\nReserved</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Clock source from 32.768 kHz external low speed crystal oscillator clock.\nReserved</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Clock source from HCLK.\nReserved</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Clock source from 22.1184 MHz internal high speed RC oscillator clock.\nClock source from 10 kHz internal low speed RC oscillator clock</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PWM01_S_E</name>
              <description>PWM0 And PWM1 Clock Source Selection Extend\nPWM0 and PWM1 used the same peripheral clock source; both of them used the same prescaler. The peripheral clock source of PWM0 and PWM1 is defined by PWM01_S (CLKSEL1[29:28]) and PWM01_S_E (CLKSEL2[8]).\n</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PWM23_S_E</name>
              <description>PWM2 And PWM3 Clock Source Selection Extend\nPWM2 and PWM3 used the same peripheral clock source; both of them used the same prescaler. The perpherial clock source of PWM2 and PWM3 is defined by PWM23_S (CLKSEL1[31:30]) and PWM23_S_E (CLKSEL2[9]).\n</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PWM45_S_E</name>
              <description>PWM4 And PWM5 Clock Source Selection Extend\nPWM4 and PWM5 used the same peripheral clock source; both of them used the same prescaler. The peripheral clock source of PWM4 and PWM5 is defined by PWM45_S (CLKSEL2[5:4]) and PWM45_S_E (CLKSEL2[10]).\n</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PWM67_S_E</name>
              <description>PWM6 And PWM7 Clock Source Selection Extend\nPWM6 and PWM7 used the same peripheral clock source; both of them used the same prescaler. The peripheral clock source of PWM6 and PWM7 is defined by PWM67_S (CLKSEL2[7:6]) and PWM67_S_E (CLKSEL2[11]).\n</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>WWDT_S</name>
              <description>Window Watchdog Timer Clock Source Selection\n</description>
              <bitOffset>16</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Clock source from HCLK/2048 clock</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Clock source from 10 kHz internal low speed RC oscillator clock</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RTC_SEL_10K</name>
              <description>RTC Clock Source Selection\n</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Clock source from 32.768 kHz external low speed crystal oscillator clock</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Clock source from 10 kHz internal low speed RC oscillator clock</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PLLCON</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PLLCON</displayName>
          <description>PLL Control Register</description>
          <addressOffset>0x20</addressOffset>
          <access>read-write</access>
          <resetValue>0x0005C22E</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>FB_DV</name>
              <description>PLL Feedback Divider Control Bits\nRefer to the formulas below the table.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>9</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>IN_DV</name>
              <description>PLL Input Divider Control Bits\nRefer to the formulas below the table.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OUT_DV</name>
              <description>PLL Output Divider Control Bits\nRefer to the formulas below the table.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PD</name>
              <description>Power-Down Mode\nIf the PWR_DOWN_EN bit is set to 1 in PWRCON register, the PLL will enter Power-down mode too.\n</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PLL is in Normal mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PLL is in Power-down mode (default)</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BP</name>
              <description>PLL Bypass Control\n</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PLL is in Normal mode (default)</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PLL clock output is same as PLL source clock input</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>OE</name>
              <description>PLL OE (FOUT Enable) Pin Control\n</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PLL FOUT Enabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PLL FOUT is fixed low</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PLL_SRC</name>
              <description>PLL Source Clock Selection\n</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PLL source clock from 4~24 MHz external high speed crystal oscillator</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PLL source clock from 22.1184 MHz internal high speed RC oscillator</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>FRQDIV</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>FRQDIV</displayName>
          <description>Frequency Divider Control Register</description>
          <addressOffset>0x24</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>FSEL</name>
              <description>Divider Output Frequency Selection Bits\nThe formula of output frequency is\nFin is the input clock frequency.\nFout is the frequency of divider output clock.\nN is the 4-bit value of FSEL[3:0].</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DIVIDER_EN</name>
              <description>Frequency Divider Enable Bit\n</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Frequency Divider function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Frequency Divider function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DIVIDER1</name>
              <description>Frequency Divider One Enable Bit\n</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Frequency divider will output clock with source frequency divided by FSEL</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Frequency divider will output clock with source frequency</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CLKO_1HZ_EN</name>
              <description>Clock Output 1Hz Enable Bit\n</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>1 Hz clock output for 32.768 kHz external low speed crystal oscillator clock frequency compensation Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>1 Hz clock output for 32.768 kHz external low speed crystal oscillator clock frequency compensation Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>APBCLK1</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>APBCLK1</displayName>
          <description>APB Devices Clock Enable Control Register 1</description>
          <addressOffset>0x30</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SC0_EN</name>
              <description>SC0 Clock Enable Bit\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>SC0 Clock Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>SC0 Clock Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SC1_EN</name>
              <description>SC1 Clock Enable Bit\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>SC1 clock Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>SC1 clock Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SC2_EN</name>
              <description>SC2 Clock Enable Bit\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>SC2 clock Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>SC2 clock Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CLKSEL3</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CLKSEL3</displayName>
          <description>Clock Source Select Control Register 3</description>
          <addressOffset>0x34</addressOffset>
          <access>read-write</access>
          <resetValue>0x0000003F</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SC0_S</name>
              <description>SC0 Clock Source Selection\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Clock source from 4~24 MHz external high speed crystal oscillator clock</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Clock source from PLL clock</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Clock source from HCLK</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Clock source from 22.1184 MHz internal high speed RC oscillator clock</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SC1_S</name>
              <description>SC1 Clock Source Selection\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Clock source from 4~24 MHz external high speed crystal oscillator clock</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Clock source from PLL clock</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Clock source from HCLK</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Clock source from 22.1184 MHz internal high speed RC oscillator clock</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SC2_S</name>
              <description>SC2 Clock Source Selection\n</description>
              <bitOffset>4</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Clock source from 4~24 MHz external high speed crystal oscillator clock</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Clock source from PLL clock</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Clock source from HCLK</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Clock source from 22.1184 MHz internal high speed RC oscillator clock</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CLKDIV1</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CLKDIV1</displayName>
          <description>Clock Divider Number Register 1</description>
          <addressOffset>0x38</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SC0_N</name>
              <description>SC0 Clock Divide Number From SC0 Clock Source\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SC1_N</name>
              <description>SC1 Clock Divide Number From SC1 Clock Source\n</description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SC2_N</name>
              <description>SC2 Clock Divide Number From SC2 Clock Source\n</description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>FMC</name>
      <description>FMC Register Map</description>
      <groupName>FMC</groupName>
      <baseAddress>0x5000C000</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x0</offset>
        <size>0x1C</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x40</offset>
        <size>0x4</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>ISPCON</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>ISPCON</displayName>
          <description>ISP Control Register</description>
          <addressOffset>0x0</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ISPEN</name>
              <description>ISP Enable Bit (Write Protect )\nISP function enable bit. Set this bit to enable ISP function.\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>ISP function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>ISP function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BS</name>
              <description>Boot Select (Write Protect )\nSet/clear this bit to select next booting from LDROM/APROM, respectively. This bit also functions as chip booting status flag, which can be used to check where chip booted from. This bit is initiated with the inversed value of CBS in CONFIG0 after any reset is happened except CPU reset (RSTS_CPU is 1) or system reset (RSTS_SYS) is happened\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Boot from APROM</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Boot from LDROM</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>APUEN</name>
              <description>APROM Update Enable Bit (Write Protect)\n</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>APROM cannot be updated when chip runs in APROM</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>APROM can be updated when chip runs in APROM</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CFGUEN</name>
              <description>Enable Config Update By ISP (Write Protect)\n</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>ISP update config-bit Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>ISP update config-bit Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>LDUEN</name>
              <description>LDROM Update Enable Bit (Write Protect)\n</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>LDROM cannot be updated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>LDROM can be updated when chip runs in APROM</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ISPFF</name>
              <description>ISP Fail Flag (Write Protect)\nThis bit is set by hardware when a triggered ISP meets any of the following conditions:\n(1) APROM writes to itself if APUEN is set to 0\n(2) LDROM writes to itself if LDUEN is set to 0\n(3) CONFIG is erased/programmed if CFGUEN is set to 0\n(4) Destination address is illegal, such as over an available range\nWrite 1 to clear to this bit to 0.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>ISPADR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>ISPADR</displayName>
          <description>ISP Address Register</description>
          <addressOffset>0x4</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ISPADR</name>
              <description>ISP Address\nThe NuMicro( NUC230/240 series has a maximum of 32Kx32 (128 KB) embedded Flash, which supports word program only. ISPADR[1:0] must be kept 00b for ISP operation.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>ISPDAT</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>ISPDAT</displayName>
          <description>ISP Data Register</description>
          <addressOffset>0x8</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ISPDAT</name>
              <description>ISP Data\nWrite data to this register before ISP program operation\nRead data from this register after ISP read operation</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>ISPCMD</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>ISPCMD</displayName>
          <description>ISP Command Register</description>
          <addressOffset>0xC</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ISPCMD</name>
              <description>ISP Command\nISP command table is shown below:\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>6</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Read</description>
                    <value>0x00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>4</name>
                    <description>Read Unique ID</description>
                    <value>0x04</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>11</name>
                    <description>Read Company ID (0xDA)</description>
                    <value>0x0b</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>33</name>
                    <description>Program</description>
                    <value>0x21</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>34</name>
                    <description>Page Erase</description>
                    <value>0x22</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>46</name>
                    <description>Set Vector Page Re-Map</description>
                    <value>0x2e</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>ISPTRG</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>ISPTRG</displayName>
          <description>ISP Trigger Control Register</description>
          <addressOffset>0x10</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ISPGO</name>
              <description>ISP Start Trigger (Write-Protection Bit)\nWrite 1 to start ISP operation and this bit will be cleared to 0 by hardware automatically when ISP operation is finished.\nThis bit is the protected bit, It means programming this bit needs to write "59h", "16h", "88h" to address 0x5000_0100 to disable register protection. Refer to the register REGWRPROT at address GCR_BA+0x100</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>ISP operation finished</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>ISP progressed</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>DFBADR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>DFBADR</displayName>
          <description>Data Flash Base Address</description>
          <addressOffset>0x14</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFF00000</resetMask>
          <fields>
            <field>
              <name>DFBADR</name>
              <description>Data Flash Base Address\nThis register indicates Data Flash start address. It is read only.\nFor 128 KB flash memory device, the Data Flash size is defined by user configuration, register content is loaded from CONFIG1 when chip is powered on but for 64/32 KB device, it is fixed at 0x0001_F000.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>FATCON</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>FATCON</displayName>
          <description>Flash Access Time Control Register</description>
          <addressOffset>0x18</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>FOMSEL0</name>
              <description>Chip Frequency Optimization Mode Select 0 (Write-Protection Bit)\nWhen CPU frequency is lower than 72 MHz, user can modify flash access delay cycle by FOMSEL1 and FOMSEL0 to improve system performance.\n</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FOMSEL1</name>
              <description>Chip Frequency Optimization Mode Select1 (Write-protection Bit)</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>ISPSTA</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>ISPSTA</displayName>
          <description>ISP Status Register</description>
          <addressOffset>0x40</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ISPGO</name>
              <description>ISP Start Trigger (Read Only)\nWrite 1 to start ISP operation and this bit will be cleared to 0 by hardware automatically when ISP operation is finished.\nNote: This bit is the same as ISPTRG bit0</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>ISP operation finished</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>ISP operation progressed</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>CBS</name>
              <description>Chip Boot Selection (Read Only)\nThis is a mirror of CBS in CONFIG0.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ISPFF</name>
              <description>ISP Fail Flag (Write-Protection Bit)\nThis bit is set by hardware when a triggered ISP meets any of the following conditions:\n(1) APROM writes to itself\n(2) LDROM writes to itself\n(3) CONFIG is erased/programmed if CFGUEN is set to 0\n(4) Destination address is illegal, such as over an available range\nWrite 1 to clear this bit.\nNote: The function of this bit is the same as ISPCON bit6</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>VECMAP</name>
              <description>Vector Page Mapping Address (Read Only)\nThe current flash address space 0x0000_0000~0x0000_01FF is mapping to address {VECMAP[11:0], 9'h000} ~ {VECMAP[11:0], 9'h1FF}</description>
              <bitOffset>9</bitOffset>
              <bitWidth>12</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>EBI</name>
      <description>EBI Register Map</description>
      <groupName>EBI</groupName>
      <baseAddress>0x50010000</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x0</offset>
        <size>0xC</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>EBICON</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>EBICON</displayName>
          <description>External Bus Interface General Control Register</description>
          <addressOffset>0x0</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ExtEN</name>
              <description>EBI Enable\nThis bit is the functional enable bit for EBI.\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>EBI function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>EBI function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ExtBW16</name>
              <description>EBI Data Width 16-bit/8-bit\nThis bit defines if the data bus is 8-bit or 16-bit.\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>EBI data width is 8-bit</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>EBI data width is 16-bit</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>MCLKDIV</name>
              <description>External Output Clock Divider\n</description>
              <bitOffset>8</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ExttALE</name>
              <description>Expand Time of ALE\nThis field is used for control the ALE pulse width (tALE) for latch the address \n</description>
              <bitOffset>16</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>EXTIME</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>EXTIME</displayName>
          <description>External Bus Interface Timing Control Register</description>
          <addressOffset>0x4</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ExttACC</name>
              <description>EBI Data Access Time\nExttACC defines data access time (tACC).\n</description>
              <bitOffset>3</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ExttAHD</name>
              <description>EBI Data Access Hold Time\nExttAHD defines data access hold time (tAHD).\n</description>
              <bitOffset>8</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ExtIW2X</name>
              <description>Idle State Cycle After Write\nWhen write action is finished, idle state is inserted and nCS signal return to high if ExtIW2X is not zero.\n</description>
              <bitOffset>12</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ExtIR2R</name>
              <description>Idle State Cycle Between Read-Read\nWhen read action is finished and the next action is going to read, idle state is inserted and nCS signal return to high if ExtIR2R is not zero.\n</description>
              <bitOffset>24</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>EBICON2</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>EBICON2</displayName>
          <description>External Bus Interface General Control Register 2</description>
          <addressOffset>0x8</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WBUFF_EN</name>
              <description>EBI Write Buffer Enable\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>EBI write buffer disable</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>EBI write buffer enable</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RAHD_OFF</name>
              <description>Access Hold Time Disable Control When Read\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>tAHD is controlled by ExttAHD when read through EBI</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>No tAHD when read through EBI</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>WAHD_OFF</name>
              <description>Access Hold Time Disable Control When Write\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>tAHD is controlled by ExttAHD when write through EBI</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>No tAHD when write through EBI</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>GPIO</name>
      <description>GPIO Register Map</description>
      <groupName>GPIO</groupName>
      <baseAddress>0x50004000</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x0</offset>
        <size>0x24</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x40</offset>
        <size>0x24</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x80</offset>
        <size>0x24</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0xC0</offset>
        <size>0x24</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x100</offset>
        <size>0x24</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x140</offset>
        <size>0x24</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x180</offset>
        <size>0x4</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x200</offset>
        <size>0x150</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>GPIOA_PMD</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>GPIOA_PMD</displayName>
          <description>GPIO Port A Pin I/O Mode Control</description>
          <addressOffset>0x0</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>PMD0</name>
              <description>GPIOx I/O Pin[N] Mode Control\nDetermine each I/O mode of GPIOx pins.\nThe initial value of this field is defined by CIOINI (CONFIG0[10]). If CIOINI is set to 1, the default value is 0xFFFF_FFFF and all pins will be Quasi-bidirectional mode after chip is powered on. If CIOINI is cleared to 0, the default value is 0x0000_0000 and all pins will be input only mode after chip is powered on.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO port [n] pin is in Input mode</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIO port [n] pin is in Push-pull Output mode</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>GPIO port [n] pin is in Open-drain Output mode</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>GPIO port [n] pin is in Quasi-bidirectional mode</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PMD1</name>
              <description>GPIOx I/O Pin[N] Mode Control\nDetermine each I/O mode of GPIOx pins.\nThe initial value of this field is defined by CIOINI (CONFIG0[10]). If CIOINI is set to 1, the default value is 0xFFFF_FFFF and all pins will be Quasi-bidirectional mode after chip is powered on. If CIOINI is cleared to 0, the default value is 0x0000_0000 and all pins will be input only mode after chip is powered on.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO port [n] pin is in Input mode</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIO port [n] pin is in Push-pull Output mode</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>GPIO port [n] pin is in Open-drain Output mode</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>GPIO port [n] pin is in Quasi-bidirectional mode</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PMD2</name>
              <description>GPIOx I/O Pin[N] Mode Control\nDetermine each I/O mode of GPIOx pins.\nThe initial value of this field is defined by CIOINI (CONFIG0[10]). If CIOINI is set to 1, the default value is 0xFFFF_FFFF and all pins will be Quasi-bidirectional mode after chip is powered on. If CIOINI is cleared to 0, the default value is 0x0000_0000 and all pins will be input only mode after chip is powered on.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO port [n] pin is in Input mode</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIO port [n] pin is in Push-pull Output mode</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>GPIO port [n] pin is in Open-drain Output mode</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>GPIO port [n] pin is in Quasi-bidirectional mode</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PMD3</name>
              <description>GPIOx I/O Pin[N] Mode Control\nDetermine each I/O mode of GPIOx pins.\nThe initial value of this field is defined by CIOINI (CONFIG0[10]). If CIOINI is set to 1, the default value is 0xFFFF_FFFF and all pins will be Quasi-bidirectional mode after chip is powered on. If CIOINI is cleared to 0, the default value is 0x0000_0000 and all pins will be input only mode after chip is powered on.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO port [n] pin is in Input mode</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIO port [n] pin is in Push-pull Output mode</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>GPIO port [n] pin is in Open-drain Output mode</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>GPIO port [n] pin is in Quasi-bidirectional mode</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PMD4</name>
              <description>GPIOx I/O Pin[N] Mode Control\nDetermine each I/O mode of GPIOx pins.\nThe initial value of this field is defined by CIOINI (CONFIG0[10]). If CIOINI is set to 1, the default value is 0xFFFF_FFFF and all pins will be Quasi-bidirectional mode after chip is powered on. If CIOINI is cleared to 0, the default value is 0x0000_0000 and all pins will be input only mode after chip is powered on.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO port [n] pin is in Input mode</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIO port [n] pin is in Push-pull Output mode</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>GPIO port [n] pin is in Open-drain Output mode</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>GPIO port [n] pin is in Quasi-bidirectional mode</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PMD5</name>
              <description>GPIOx I/O Pin[N] Mode Control\nDetermine each I/O mode of GPIOx pins.\nThe initial value of this field is defined by CIOINI (CONFIG0[10]). If CIOINI is set to 1, the default value is 0xFFFF_FFFF and all pins will be Quasi-bidirectional mode after chip is powered on. If CIOINI is cleared to 0, the default value is 0x0000_0000 and all pins will be input only mode after chip is powered on.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO port [n] pin is in Input mode</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIO port [n] pin is in Push-pull Output mode</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>GPIO port [n] pin is in Open-drain Output mode</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>GPIO port [n] pin is in Quasi-bidirectional mode</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PMD6</name>
              <description>GPIOx I/O Pin[N] Mode Control\nDetermine each I/O mode of GPIOx pins.\nThe initial value of this field is defined by CIOINI (CONFIG0[10]). If CIOINI is set to 1, the default value is 0xFFFF_FFFF and all pins will be Quasi-bidirectional mode after chip is powered on. If CIOINI is cleared to 0, the default value is 0x0000_0000 and all pins will be input only mode after chip is powered on.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO port [n] pin is in Input mode</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIO port [n] pin is in Push-pull Output mode</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>GPIO port [n] pin is in Open-drain Output mode</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>GPIO port [n] pin is in Quasi-bidirectional mode</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PMD7</name>
              <description>GPIOx I/O Pin[N] Mode Control\nDetermine each I/O mode of GPIOx pins.\nThe initial value of this field is defined by CIOINI (CONFIG0[10]). If CIOINI is set to 1, the default value is 0xFFFF_FFFF and all pins will be Quasi-bidirectional mode after chip is powered on. If CIOINI is cleared to 0, the default value is 0x0000_0000 and all pins will be input only mode after chip is powered on.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO port [n] pin is in Input mode</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIO port [n] pin is in Push-pull Output mode</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>GPIO port [n] pin is in Open-drain Output mode</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>GPIO port [n] pin is in Quasi-bidirectional mode</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PMD8</name>
              <description>GPIOx I/O Pin[N] Mode Control\nDetermine each I/O mode of GPIOx pins.\nThe initial value of this field is defined by CIOINI (CONFIG0[10]). If CIOINI is set to 1, the default value is 0xFFFF_FFFF and all pins will be Quasi-bidirectional mode after chip is powered on. If CIOINI is cleared to 0, the default value is 0x0000_0000 and all pins will be input only mode after chip is powered on.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO port [n] pin is in Input mode</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIO port [n] pin is in Push-pull Output mode</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>GPIO port [n] pin is in Open-drain Output mode</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>GPIO port [n] pin is in Quasi-bidirectional mode</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PMD9</name>
              <description>GPIOx I/O Pin[N] Mode Control\nDetermine each I/O mode of GPIOx pins.\nThe initial value of this field is defined by CIOINI (CONFIG0[10]). If CIOINI is set to 1, the default value is 0xFFFF_FFFF and all pins will be Quasi-bidirectional mode after chip is powered on. If CIOINI is cleared to 0, the default value is 0x0000_0000 and all pins will be input only mode after chip is powered on.</description>
              <bitOffset>18</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO port [n] pin is in Input mode</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIO port [n] pin is in Push-pull Output mode</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>GPIO port [n] pin is in Open-drain Output mode</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>GPIO port [n] pin is in Quasi-bidirectional mode</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PMD10</name>
              <description>GPIOx I/O Pin[N] Mode Control\nDetermine each I/O mode of GPIOx pins.\nThe initial value of this field is defined by CIOINI (CONFIG0[10]). If CIOINI is set to 1, the default value is 0xFFFF_FFFF and all pins will be Quasi-bidirectional mode after chip is powered on. If CIOINI is cleared to 0, the default value is 0x0000_0000 and all pins will be input only mode after chip is powered on.</description>
              <bitOffset>20</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO port [n] pin is in Input mode</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIO port [n] pin is in Push-pull Output mode</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>GPIO port [n] pin is in Open-drain Output mode</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>GPIO port [n] pin is in Quasi-bidirectional mode</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PMD11</name>
              <description>GPIOx I/O Pin[N] Mode Control\nDetermine each I/O mode of GPIOx pins.\nThe initial value of this field is defined by CIOINI (CONFIG0[10]). If CIOINI is set to 1, the default value is 0xFFFF_FFFF and all pins will be Quasi-bidirectional mode after chip is powered on. If CIOINI is cleared to 0, the default value is 0x0000_0000 and all pins will be input only mode after chip is powered on.</description>
              <bitOffset>22</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO port [n] pin is in Input mode</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIO port [n] pin is in Push-pull Output mode</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>GPIO port [n] pin is in Open-drain Output mode</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>GPIO port [n] pin is in Quasi-bidirectional mode</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PMD12</name>
              <description>GPIOx I/O Pin[N] Mode Control\nDetermine each I/O mode of GPIOx pins.\nThe initial value of this field is defined by CIOINI (CONFIG0[10]). If CIOINI is set to 1, the default value is 0xFFFF_FFFF and all pins will be Quasi-bidirectional mode after chip is powered on. If CIOINI is cleared to 0, the default value is 0x0000_0000 and all pins will be input only mode after chip is powered on.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO port [n] pin is in Input mode</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIO port [n] pin is in Push-pull Output mode</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>GPIO port [n] pin is in Open-drain Output mode</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>GPIO port [n] pin is in Quasi-bidirectional mode</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PMD13</name>
              <description>GPIOx I/O Pin[N] Mode Control\nDetermine each I/O mode of GPIOx pins.\nThe initial value of this field is defined by CIOINI (CONFIG0[10]). If CIOINI is set to 1, the default value is 0xFFFF_FFFF and all pins will be Quasi-bidirectional mode after chip is powered on. If CIOINI is cleared to 0, the default value is 0x0000_0000 and all pins will be input only mode after chip is powered on.</description>
              <bitOffset>26</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO port [n] pin is in Input mode</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIO port [n] pin is in Push-pull Output mode</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>GPIO port [n] pin is in Open-drain Output mode</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>GPIO port [n] pin is in Quasi-bidirectional mode</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PMD14</name>
              <description>GPIOx I/O Pin[N] Mode Control\nDetermine each I/O mode of GPIOx pins.\nThe initial value of this field is defined by CIOINI (CONFIG0[10]). If CIOINI is set to 1, the default value is 0xFFFF_FFFF and all pins will be Quasi-bidirectional mode after chip is powered on. If CIOINI is cleared to 0, the default value is 0x0000_0000 and all pins will be input only mode after chip is powered on.</description>
              <bitOffset>28</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO port [n] pin is in Input mode</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIO port [n] pin is in Push-pull Output mode</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>GPIO port [n] pin is in Open-drain Output mode</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>GPIO port [n] pin is in Quasi-bidirectional mode</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PMD15</name>
              <description>GPIOx I/O Pin[N] Mode Control\nDetermine each I/O mode of GPIOx pins.\nThe initial value of this field is defined by CIOINI (CONFIG0[10]). If CIOINI is set to 1, the default value is 0xFFFF_FFFF and all pins will be Quasi-bidirectional mode after chip is powered on. If CIOINI is cleared to 0, the default value is 0x0000_0000 and all pins will be input only mode after chip is powered on.</description>
              <bitOffset>30</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO port [n] pin is in Input mode</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIO port [n] pin is in Push-pull Output mode</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>GPIO port [n] pin is in Open-drain Output mode</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>GPIO port [n] pin is in Quasi-bidirectional mode</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>GPIOA_OFFD</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>GPIOA_OFFD</displayName>
          <description>GPIO Port A Pin Digital Input Path Disable Control</description>
          <addressOffset>0x4</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>OFFD</name>
              <description>GPIOx Pin[N] Digital Input Path Disable Bit\nEach of these bits is used to control if the digital input path of corresponding GPIO pin is disabled. If input is analog signal, users can disable GPIO digital input path to avoid current leakage.\n</description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>I/O digital input path Enabled</description>
                    <value>0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>I/O digital input path Disabled (digital input tied to low)</description>
                    <value>1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>GPIOA_DOUT</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>GPIOA_DOUT</displayName>
          <description>GPIO Port A Data Output Value</description>
          <addressOffset>0x8</addressOffset>
          <access>read-write</access>
          <resetValue>0x0000FFFF</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DOUT0</name>
              <description>GPIOx Pin[N] Output Value\nEach of these bits controls the status of a GPIO pin when the GPIO pin is configured as Push-pull output, open-drain output or quasi-bidirectional mode.\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO port [A/B/C/D/E/F] Pin[n] will drive Low if the GPIO pin is configured as Push-pull output, Open-drain output or Quasi-bidirectional mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIO port [A/B/C/D/E/F] Pin[n] will drive High if the GPIO pin is configured as Push-pull output or Quasi-bidirectional mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DOUT1</name>
              <description>GPIOx Pin[N] Output Value\nEach of these bits controls the status of a GPIO pin when the GPIO pin is configured as Push-pull output, open-drain output or quasi-bidirectional mode.\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO port [A/B/C/D/E/F] Pin[n] will drive Low if the GPIO pin is configured as Push-pull output, Open-drain output or Quasi-bidirectional mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIO port [A/B/C/D/E/F] Pin[n] will drive High if the GPIO pin is configured as Push-pull output or Quasi-bidirectional mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DOUT2</name>
              <description>GPIOx Pin[N] Output Value\nEach of these bits controls the status of a GPIO pin when the GPIO pin is configured as Push-pull output, open-drain output or quasi-bidirectional mode.\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO port [A/B/C/D/E/F] Pin[n] will drive Low if the GPIO pin is configured as Push-pull output, Open-drain output or Quasi-bidirectional mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIO port [A/B/C/D/E/F] Pin[n] will drive High if the GPIO pin is configured as Push-pull output or Quasi-bidirectional mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DOUT3</name>
              <description>GPIOx Pin[N] Output Value\nEach of these bits controls the status of a GPIO pin when the GPIO pin is configured as Push-pull output, open-drain output or quasi-bidirectional mode.\n</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO port [A/B/C/D/E/F] Pin[n] will drive Low if the GPIO pin is configured as Push-pull output, Open-drain output or Quasi-bidirectional mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIO port [A/B/C/D/E/F] Pin[n] will drive High if the GPIO pin is configured as Push-pull output or Quasi-bidirectional mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DOUT4</name>
              <description>GPIOx Pin[N] Output Value\nEach of these bits controls the status of a GPIO pin when the GPIO pin is configured as Push-pull output, open-drain output or quasi-bidirectional mode.\n</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO port [A/B/C/D/E/F] Pin[n] will drive Low if the GPIO pin is configured as Push-pull output, Open-drain output or Quasi-bidirectional mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIO port [A/B/C/D/E/F] Pin[n] will drive High if the GPIO pin is configured as Push-pull output or Quasi-bidirectional mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DOUT5</name>
              <description>GPIOx Pin[N] Output Value\nEach of these bits controls the status of a GPIO pin when the GPIO pin is configured as Push-pull output, open-drain output or quasi-bidirectional mode.\n</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO port [A/B/C/D/E/F] Pin[n] will drive Low if the GPIO pin is configured as Push-pull output, Open-drain output or Quasi-bidirectional mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIO port [A/B/C/D/E/F] Pin[n] will drive High if the GPIO pin is configured as Push-pull output or Quasi-bidirectional mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DOUT6</name>
              <description>GPIOx Pin[N] Output Value\nEach of these bits controls the status of a GPIO pin when the GPIO pin is configured as Push-pull output, open-drain output or quasi-bidirectional mode.\n</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO port [A/B/C/D/E/F] Pin[n] will drive Low if the GPIO pin is configured as Push-pull output, Open-drain output or Quasi-bidirectional mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIO port [A/B/C/D/E/F] Pin[n] will drive High if the GPIO pin is configured as Push-pull output or Quasi-bidirectional mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DOUT7</name>
              <description>GPIOx Pin[N] Output Value\nEach of these bits controls the status of a GPIO pin when the GPIO pin is configured as Push-pull output, open-drain output or quasi-bidirectional mode.\n</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO port [A/B/C/D/E/F] Pin[n] will drive Low if the GPIO pin is configured as Push-pull output, Open-drain output or Quasi-bidirectional mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIO port [A/B/C/D/E/F] Pin[n] will drive High if the GPIO pin is configured as Push-pull output or Quasi-bidirectional mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DOUT8</name>
              <description>GPIOx Pin[N] Output Value\nEach of these bits controls the status of a GPIO pin when the GPIO pin is configured as Push-pull output, open-drain output or quasi-bidirectional mode.\n</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO port [A/B/C/D/E/F] Pin[n] will drive Low if the GPIO pin is configured as Push-pull output, Open-drain output or Quasi-bidirectional mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIO port [A/B/C/D/E/F] Pin[n] will drive High if the GPIO pin is configured as Push-pull output or Quasi-bidirectional mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DOUT9</name>
              <description>GPIOx Pin[N] Output Value\nEach of these bits controls the status of a GPIO pin when the GPIO pin is configured as Push-pull output, open-drain output or quasi-bidirectional mode.\n</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO port [A/B/C/D/E/F] Pin[n] will drive Low if the GPIO pin is configured as Push-pull output, Open-drain output or Quasi-bidirectional mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIO port [A/B/C/D/E/F] Pin[n] will drive High if the GPIO pin is configured as Push-pull output or Quasi-bidirectional mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DOUT10</name>
              <description>GPIOx Pin[N] Output Value\nEach of these bits controls the status of a GPIO pin when the GPIO pin is configured as Push-pull output, open-drain output or quasi-bidirectional mode.\n</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO port [A/B/C/D/E/F] Pin[n] will drive Low if the GPIO pin is configured as Push-pull output, Open-drain output or Quasi-bidirectional mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIO port [A/B/C/D/E/F] Pin[n] will drive High if the GPIO pin is configured as Push-pull output or Quasi-bidirectional mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DOUT11</name>
              <description>GPIOx Pin[N] Output Value\nEach of these bits controls the status of a GPIO pin when the GPIO pin is configured as Push-pull output, open-drain output or quasi-bidirectional mode.\n</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO port [A/B/C/D/E/F] Pin[n] will drive Low if the GPIO pin is configured as Push-pull output, Open-drain output or Quasi-bidirectional mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIO port [A/B/C/D/E/F] Pin[n] will drive High if the GPIO pin is configured as Push-pull output or Quasi-bidirectional mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DOUT12</name>
              <description>GPIOx Pin[N] Output Value\nEach of these bits controls the status of a GPIO pin when the GPIO pin is configured as Push-pull output, open-drain output or quasi-bidirectional mode.\n</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO port [A/B/C/D/E/F] Pin[n] will drive Low if the GPIO pin is configured as Push-pull output, Open-drain output or Quasi-bidirectional mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIO port [A/B/C/D/E/F] Pin[n] will drive High if the GPIO pin is configured as Push-pull output or Quasi-bidirectional mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DOUT13</name>
              <description>GPIOx Pin[N] Output Value\nEach of these bits controls the status of a GPIO pin when the GPIO pin is configured as Push-pull output, open-drain output or quasi-bidirectional mode.\n</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO port [A/B/C/D/E/F] Pin[n] will drive Low if the GPIO pin is configured as Push-pull output, Open-drain output or Quasi-bidirectional mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIO port [A/B/C/D/E/F] Pin[n] will drive High if the GPIO pin is configured as Push-pull output or Quasi-bidirectional mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DOUT14</name>
              <description>GPIOx Pin[N] Output Value\nEach of these bits controls the status of a GPIO pin when the GPIO pin is configured as Push-pull output, open-drain output or quasi-bidirectional mode.\n</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO port [A/B/C/D/E/F] Pin[n] will drive Low if the GPIO pin is configured as Push-pull output, Open-drain output or Quasi-bidirectional mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIO port [A/B/C/D/E/F] Pin[n] will drive High if the GPIO pin is configured as Push-pull output or Quasi-bidirectional mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DOUT15</name>
              <description>GPIOx Pin[N] Output Value\nEach of these bits controls the status of a GPIO pin when the GPIO pin is configured as Push-pull output, open-drain output or quasi-bidirectional mode.\n</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO port [A/B/C/D/E/F] Pin[n] will drive Low if the GPIO pin is configured as Push-pull output, Open-drain output or Quasi-bidirectional mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIO port [A/B/C/D/E/F] Pin[n] will drive High if the GPIO pin is configured as Push-pull output or Quasi-bidirectional mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>GPIOA_DMASK</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>GPIOA_DMASK</displayName>
          <description>GPIO Port A Data Output Write Mask</description>
          <addressOffset>0xC</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DMASK0</name>
              <description>Port [A/B/C/D/E/F] Data Output Write Mask\nThese bits are used to protect the corresponding register of  GPIOx_DOUT[n] bit. When the  DMASK[n] bit is set to 1, the corresponding GPIOx_DOUT[n] bit is protected. If the write signal is masked, write data to the protect bit is ignored\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Corresponding GPIOx_DOUT[n] bit can be updated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Corresponding GPIOx_DOUT[n] bit protected</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DMASK1</name>
              <description>Port [A/B/C/D/E/F] Data Output Write Mask\nThese bits are used to protect the corresponding register of  GPIOx_DOUT[n] bit. When the  DMASK[n] bit is set to 1, the corresponding GPIOx_DOUT[n] bit is protected. If the write signal is masked, write data to the protect bit is ignored\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Corresponding GPIOx_DOUT[n] bit can be updated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Corresponding GPIOx_DOUT[n] bit protected</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DMASK2</name>
              <description>Port [A/B/C/D/E/F] Data Output Write Mask\nThese bits are used to protect the corresponding register of  GPIOx_DOUT[n] bit. When the  DMASK[n] bit is set to 1, the corresponding GPIOx_DOUT[n] bit is protected. If the write signal is masked, write data to the protect bit is ignored\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Corresponding GPIOx_DOUT[n] bit can be updated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Corresponding GPIOx_DOUT[n] bit protected</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DMASK3</name>
              <description>Port [A/B/C/D/E/F] Data Output Write Mask\nThese bits are used to protect the corresponding register of  GPIOx_DOUT[n] bit. When the  DMASK[n] bit is set to 1, the corresponding GPIOx_DOUT[n] bit is protected. If the write signal is masked, write data to the protect bit is ignored\n</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Corresponding GPIOx_DOUT[n] bit can be updated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Corresponding GPIOx_DOUT[n] bit protected</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DMASK4</name>
              <description>Port [A/B/C/D/E/F] Data Output Write Mask\nThese bits are used to protect the corresponding register of  GPIOx_DOUT[n] bit. When the  DMASK[n] bit is set to 1, the corresponding GPIOx_DOUT[n] bit is protected. If the write signal is masked, write data to the protect bit is ignored\n</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Corresponding GPIOx_DOUT[n] bit can be updated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Corresponding GPIOx_DOUT[n] bit protected</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DMASK5</name>
              <description>Port [A/B/C/D/E/F] Data Output Write Mask\nThese bits are used to protect the corresponding register of  GPIOx_DOUT[n] bit. When the  DMASK[n] bit is set to 1, the corresponding GPIOx_DOUT[n] bit is protected. If the write signal is masked, write data to the protect bit is ignored\n</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Corresponding GPIOx_DOUT[n] bit can be updated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Corresponding GPIOx_DOUT[n] bit protected</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DMASK6</name>
              <description>Port [A/B/C/D/E/F] Data Output Write Mask\nThese bits are used to protect the corresponding register of  GPIOx_DOUT[n] bit. When the  DMASK[n] bit is set to 1, the corresponding GPIOx_DOUT[n] bit is protected. If the write signal is masked, write data to the protect bit is ignored\n</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Corresponding GPIOx_DOUT[n] bit can be updated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Corresponding GPIOx_DOUT[n] bit protected</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DMASK7</name>
              <description>Port [A/B/C/D/E/F] Data Output Write Mask\nThese bits are used to protect the corresponding register of  GPIOx_DOUT[n] bit. When the  DMASK[n] bit is set to 1, the corresponding GPIOx_DOUT[n] bit is protected. If the write signal is masked, write data to the protect bit is ignored\n</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Corresponding GPIOx_DOUT[n] bit can be updated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Corresponding GPIOx_DOUT[n] bit protected</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DMASK8</name>
              <description>Port [A/B/C/D/E/F] Data Output Write Mask\nThese bits are used to protect the corresponding register of  GPIOx_DOUT[n] bit. When the  DMASK[n] bit is set to 1, the corresponding GPIOx_DOUT[n] bit is protected. If the write signal is masked, write data to the protect bit is ignored\n</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Corresponding GPIOx_DOUT[n] bit can be updated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Corresponding GPIOx_DOUT[n] bit protected</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DMASK9</name>
              <description>Port [A/B/C/D/E/F] Data Output Write Mask\nThese bits are used to protect the corresponding register of  GPIOx_DOUT[n] bit. When the  DMASK[n] bit is set to 1, the corresponding GPIOx_DOUT[n] bit is protected. If the write signal is masked, write data to the protect bit is ignored\n</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Corresponding GPIOx_DOUT[n] bit can be updated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Corresponding GPIOx_DOUT[n] bit protected</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DMASK10</name>
              <description>Port [A/B/C/D/E/F] Data Output Write Mask\nThese bits are used to protect the corresponding register of  GPIOx_DOUT[n] bit. When the  DMASK[n] bit is set to 1, the corresponding GPIOx_DOUT[n] bit is protected. If the write signal is masked, write data to the protect bit is ignored\n</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Corresponding GPIOx_DOUT[n] bit can be updated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Corresponding GPIOx_DOUT[n] bit protected</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DMASK11</name>
              <description>Port [A/B/C/D/E/F] Data Output Write Mask\nThese bits are used to protect the corresponding register of  GPIOx_DOUT[n] bit. When the  DMASK[n] bit is set to 1, the corresponding GPIOx_DOUT[n] bit is protected. If the write signal is masked, write data to the protect bit is ignored\n</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Corresponding GPIOx_DOUT[n] bit can be updated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Corresponding GPIOx_DOUT[n] bit protected</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DMASK12</name>
              <description>Port [A/B/C/D/E/F] Data Output Write Mask\nThese bits are used to protect the corresponding register of  GPIOx_DOUT[n] bit. When the  DMASK[n] bit is set to 1, the corresponding GPIOx_DOUT[n] bit is protected. If the write signal is masked, write data to the protect bit is ignored\n</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Corresponding GPIOx_DOUT[n] bit can be updated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Corresponding GPIOx_DOUT[n] bit protected</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DMASK13</name>
              <description>Port [A/B/C/D/E/F] Data Output Write Mask\nThese bits are used to protect the corresponding register of  GPIOx_DOUT[n] bit. When the  DMASK[n] bit is set to 1, the corresponding GPIOx_DOUT[n] bit is protected. If the write signal is masked, write data to the protect bit is ignored\n</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Corresponding GPIOx_DOUT[n] bit can be updated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Corresponding GPIOx_DOUT[n] bit protected</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DMASK14</name>
              <description>Port [A/B/C/D/E/F] Data Output Write Mask\nThese bits are used to protect the corresponding register of  GPIOx_DOUT[n] bit. When the  DMASK[n] bit is set to 1, the corresponding GPIOx_DOUT[n] bit is protected. If the write signal is masked, write data to the protect bit is ignored\n</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Corresponding GPIOx_DOUT[n] bit can be updated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Corresponding GPIOx_DOUT[n] bit protected</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DMASK15</name>
              <description>Port [A/B/C/D/E/F] Data Output Write Mask\nThese bits are used to protect the corresponding register of  GPIOx_DOUT[n] bit. When the  DMASK[n] bit is set to 1, the corresponding GPIOx_DOUT[n] bit is protected. If the write signal is masked, write data to the protect bit is ignored\n</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Corresponding GPIOx_DOUT[n] bit can be updated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Corresponding GPIOx_DOUT[n] bit protected</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>GPIOA_PIN</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>GPIOA_PIN</displayName>
          <description>GPIO Port A Pin Value</description>
          <addressOffset>0x10</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFF0000</resetMask>
          <fields>
            <field>
              <name>PIN0</name>
              <description>Port [A/B/C/D/E/F] Pin Values\nEach bit of the register reflects the actual status of the respective GPIO pin. If the bit is 1, it indicates the corresponding pin status is high, else the pin status is low\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PIN1</name>
              <description>Port [A/B/C/D/E/F] Pin Values\nEach bit of the register reflects the actual status of the respective GPIO pin. If the bit is 1, it indicates the corresponding pin status is high, else the pin status is low\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PIN2</name>
              <description>Port [A/B/C/D/E/F] Pin Values\nEach bit of the register reflects the actual status of the respective GPIO pin. If the bit is 1, it indicates the corresponding pin status is high, else the pin status is low\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PIN3</name>
              <description>Port [A/B/C/D/E/F] Pin Values\nEach bit of the register reflects the actual status of the respective GPIO pin. If the bit is 1, it indicates the corresponding pin status is high, else the pin status is low\n</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PIN4</name>
              <description>Port [A/B/C/D/E/F] Pin Values\nEach bit of the register reflects the actual status of the respective GPIO pin. If the bit is 1, it indicates the corresponding pin status is high, else the pin status is low\n</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PIN5</name>
              <description>Port [A/B/C/D/E/F] Pin Values\nEach bit of the register reflects the actual status of the respective GPIO pin. If the bit is 1, it indicates the corresponding pin status is high, else the pin status is low\n</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PIN6</name>
              <description>Port [A/B/C/D/E/F] Pin Values\nEach bit of the register reflects the actual status of the respective GPIO pin. If the bit is 1, it indicates the corresponding pin status is high, else the pin status is low\n</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PIN7</name>
              <description>Port [A/B/C/D/E/F] Pin Values\nEach bit of the register reflects the actual status of the respective GPIO pin. If the bit is 1, it indicates the corresponding pin status is high, else the pin status is low\n</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PIN8</name>
              <description>Port [A/B/C/D/E/F] Pin Values\nEach bit of the register reflects the actual status of the respective GPIO pin. If the bit is 1, it indicates the corresponding pin status is high, else the pin status is low\n</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PIN9</name>
              <description>Port [A/B/C/D/E/F] Pin Values\nEach bit of the register reflects the actual status of the respective GPIO pin. If the bit is 1, it indicates the corresponding pin status is high, else the pin status is low\n</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PIN10</name>
              <description>Port [A/B/C/D/E/F] Pin Values\nEach bit of the register reflects the actual status of the respective GPIO pin. If the bit is 1, it indicates the corresponding pin status is high, else the pin status is low\n</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PIN11</name>
              <description>Port [A/B/C/D/E/F] Pin Values\nEach bit of the register reflects the actual status of the respective GPIO pin. If the bit is 1, it indicates the corresponding pin status is high, else the pin status is low\n</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PIN12</name>
              <description>Port [A/B/C/D/E/F] Pin Values\nEach bit of the register reflects the actual status of the respective GPIO pin. If the bit is 1, it indicates the corresponding pin status is high, else the pin status is low\n</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PIN13</name>
              <description>Port [A/B/C/D/E/F] Pin Values\nEach bit of the register reflects the actual status of the respective GPIO pin. If the bit is 1, it indicates the corresponding pin status is high, else the pin status is low\n</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PIN14</name>
              <description>Port [A/B/C/D/E/F] Pin Values\nEach bit of the register reflects the actual status of the respective GPIO pin. If the bit is 1, it indicates the corresponding pin status is high, else the pin status is low\n</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PIN15</name>
              <description>Port [A/B/C/D/E/F] Pin Values\nEach bit of the register reflects the actual status of the respective GPIO pin. If the bit is 1, it indicates the corresponding pin status is high, else the pin status is low\n</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>GPIOA_DBEN</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>GPIOA_DBEN</displayName>
          <description>GPIO Port A De-bounce Enable</description>
          <addressOffset>0x14</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DBEN0</name>
              <description>Port [A/B/C/D/E/F] Input Signal De-Bounce Enable Bit\nDBEN[n] is used to enable the de-bounce function for each corresponding bit. If the input signal pulse width cannot be sampled by continuous two de-bounce sample cycle, the input signal transition is seen as the signal bounce and will not trigger the interrupt. The de-bounce clock source is controlled by DBNCECON[4], one de-bounce sample cycle period is controlled by DBNCECON[3:0]\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Bit[n] de-bounce function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Bit[n] de-bounce function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DBEN1</name>
              <description>Port [A/B/C/D/E/F] Input Signal De-Bounce Enable Bit\nDBEN[n] is used to enable the de-bounce function for each corresponding bit. If the input signal pulse width cannot be sampled by continuous two de-bounce sample cycle, the input signal transition is seen as the signal bounce and will not trigger the interrupt. The de-bounce clock source is controlled by DBNCECON[4], one de-bounce sample cycle period is controlled by DBNCECON[3:0]\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Bit[n] de-bounce function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Bit[n] de-bounce function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DBEN2</name>
              <description>Port [A/B/C/D/E/F] Input Signal De-Bounce Enable Bit\nDBEN[n] is used to enable the de-bounce function for each corresponding bit. If the input signal pulse width cannot be sampled by continuous two de-bounce sample cycle, the input signal transition is seen as the signal bounce and will not trigger the interrupt. The de-bounce clock source is controlled by DBNCECON[4], one de-bounce sample cycle period is controlled by DBNCECON[3:0]\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Bit[n] de-bounce function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Bit[n] de-bounce function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DBEN3</name>
              <description>Port [A/B/C/D/E/F] Input Signal De-Bounce Enable Bit\nDBEN[n] is used to enable the de-bounce function for each corresponding bit. If the input signal pulse width cannot be sampled by continuous two de-bounce sample cycle, the input signal transition is seen as the signal bounce and will not trigger the interrupt. The de-bounce clock source is controlled by DBNCECON[4], one de-bounce sample cycle period is controlled by DBNCECON[3:0]\n</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Bit[n] de-bounce function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Bit[n] de-bounce function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DBEN4</name>
              <description>Port [A/B/C/D/E/F] Input Signal De-Bounce Enable Bit\nDBEN[n] is used to enable the de-bounce function for each corresponding bit. If the input signal pulse width cannot be sampled by continuous two de-bounce sample cycle, the input signal transition is seen as the signal bounce and will not trigger the interrupt. The de-bounce clock source is controlled by DBNCECON[4], one de-bounce sample cycle period is controlled by DBNCECON[3:0]\n</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Bit[n] de-bounce function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Bit[n] de-bounce function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DBEN5</name>
              <description>Port [A/B/C/D/E/F] Input Signal De-Bounce Enable Bit\nDBEN[n] is used to enable the de-bounce function for each corresponding bit. If the input signal pulse width cannot be sampled by continuous two de-bounce sample cycle, the input signal transition is seen as the signal bounce and will not trigger the interrupt. The de-bounce clock source is controlled by DBNCECON[4], one de-bounce sample cycle period is controlled by DBNCECON[3:0]\n</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Bit[n] de-bounce function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Bit[n] de-bounce function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DBEN6</name>
              <description>Port [A/B/C/D/E/F] Input Signal De-Bounce Enable Bit\nDBEN[n] is used to enable the de-bounce function for each corresponding bit. If the input signal pulse width cannot be sampled by continuous two de-bounce sample cycle, the input signal transition is seen as the signal bounce and will not trigger the interrupt. The de-bounce clock source is controlled by DBNCECON[4], one de-bounce sample cycle period is controlled by DBNCECON[3:0]\n</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Bit[n] de-bounce function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Bit[n] de-bounce function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DBEN7</name>
              <description>Port [A/B/C/D/E/F] Input Signal De-Bounce Enable Bit\nDBEN[n] is used to enable the de-bounce function for each corresponding bit. If the input signal pulse width cannot be sampled by continuous two de-bounce sample cycle, the input signal transition is seen as the signal bounce and will not trigger the interrupt. The de-bounce clock source is controlled by DBNCECON[4], one de-bounce sample cycle period is controlled by DBNCECON[3:0]\n</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Bit[n] de-bounce function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Bit[n] de-bounce function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DBEN8</name>
              <description>Port [A/B/C/D/E/F] Input Signal De-Bounce Enable Bit\nDBEN[n] is used to enable the de-bounce function for each corresponding bit. If the input signal pulse width cannot be sampled by continuous two de-bounce sample cycle, the input signal transition is seen as the signal bounce and will not trigger the interrupt. The de-bounce clock source is controlled by DBNCECON[4], one de-bounce sample cycle period is controlled by DBNCECON[3:0]\n</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Bit[n] de-bounce function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Bit[n] de-bounce function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DBEN9</name>
              <description>Port [A/B/C/D/E/F] Input Signal De-Bounce Enable Bit\nDBEN[n] is used to enable the de-bounce function for each corresponding bit. If the input signal pulse width cannot be sampled by continuous two de-bounce sample cycle, the input signal transition is seen as the signal bounce and will not trigger the interrupt. The de-bounce clock source is controlled by DBNCECON[4], one de-bounce sample cycle period is controlled by DBNCECON[3:0]\n</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Bit[n] de-bounce function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Bit[n] de-bounce function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DBEN10</name>
              <description>Port [A/B/C/D/E/F] Input Signal De-Bounce Enable Bit\nDBEN[n] is used to enable the de-bounce function for each corresponding bit. If the input signal pulse width cannot be sampled by continuous two de-bounce sample cycle, the input signal transition is seen as the signal bounce and will not trigger the interrupt. The de-bounce clock source is controlled by DBNCECON[4], one de-bounce sample cycle period is controlled by DBNCECON[3:0]\n</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Bit[n] de-bounce function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Bit[n] de-bounce function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DBEN11</name>
              <description>Port [A/B/C/D/E/F] Input Signal De-Bounce Enable Bit\nDBEN[n] is used to enable the de-bounce function for each corresponding bit. If the input signal pulse width cannot be sampled by continuous two de-bounce sample cycle, the input signal transition is seen as the signal bounce and will not trigger the interrupt. The de-bounce clock source is controlled by DBNCECON[4], one de-bounce sample cycle period is controlled by DBNCECON[3:0]\n</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Bit[n] de-bounce function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Bit[n] de-bounce function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DBEN12</name>
              <description>Port [A/B/C/D/E/F] Input Signal De-Bounce Enable Bit\nDBEN[n] is used to enable the de-bounce function for each corresponding bit. If the input signal pulse width cannot be sampled by continuous two de-bounce sample cycle, the input signal transition is seen as the signal bounce and will not trigger the interrupt. The de-bounce clock source is controlled by DBNCECON[4], one de-bounce sample cycle period is controlled by DBNCECON[3:0]\n</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Bit[n] de-bounce function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Bit[n] de-bounce function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DBEN13</name>
              <description>Port [A/B/C/D/E/F] Input Signal De-Bounce Enable Bit\nDBEN[n] is used to enable the de-bounce function for each corresponding bit. If the input signal pulse width cannot be sampled by continuous two de-bounce sample cycle, the input signal transition is seen as the signal bounce and will not trigger the interrupt. The de-bounce clock source is controlled by DBNCECON[4], one de-bounce sample cycle period is controlled by DBNCECON[3:0]\n</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Bit[n] de-bounce function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Bit[n] de-bounce function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DBEN14</name>
              <description>Port [A/B/C/D/E/F] Input Signal De-Bounce Enable Bit\nDBEN[n] is used to enable the de-bounce function for each corresponding bit. If the input signal pulse width cannot be sampled by continuous two de-bounce sample cycle, the input signal transition is seen as the signal bounce and will not trigger the interrupt. The de-bounce clock source is controlled by DBNCECON[4], one de-bounce sample cycle period is controlled by DBNCECON[3:0]\n</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Bit[n] de-bounce function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Bit[n] de-bounce function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DBEN15</name>
              <description>Port [A/B/C/D/E/F] Input Signal De-Bounce Enable Bit\nDBEN[n] is used to enable the de-bounce function for each corresponding bit. If the input signal pulse width cannot be sampled by continuous two de-bounce sample cycle, the input signal transition is seen as the signal bounce and will not trigger the interrupt. The de-bounce clock source is controlled by DBNCECON[4], one de-bounce sample cycle period is controlled by DBNCECON[3:0]\n</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Bit[n] de-bounce function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Bit[n] de-bounce function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>GPIOA_IMD</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>GPIOA_IMD</displayName>
          <description>GPIO Port A Interrupt Mode Control</description>
          <addressOffset>0x18</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>IMD0</name>
              <description>Port [A/B/C/D/E/F] Edge Or Level Detection Interrupt Control\nIMD[n] is used to control the interrupt is by level trigger or by edge trigger. If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce. If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrupt.\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Edge trigger interrupt</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Level trigger interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IMD1</name>
              <description>Port [A/B/C/D/E/F] Edge Or Level Detection Interrupt Control\nIMD[n] is used to control the interrupt is by level trigger or by edge trigger. If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce. If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrupt.\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Edge trigger interrupt</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Level trigger interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IMD2</name>
              <description>Port [A/B/C/D/E/F] Edge Or Level Detection Interrupt Control\nIMD[n] is used to control the interrupt is by level trigger or by edge trigger. If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce. If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrupt.\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Edge trigger interrupt</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Level trigger interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IMD3</name>
              <description>Port [A/B/C/D/E/F] Edge Or Level Detection Interrupt Control\nIMD[n] is used to control the interrupt is by level trigger or by edge trigger. If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce. If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrupt.\n</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Edge trigger interrupt</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Level trigger interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IMD4</name>
              <description>Port [A/B/C/D/E/F] Edge Or Level Detection Interrupt Control\nIMD[n] is used to control the interrupt is by level trigger or by edge trigger. If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce. If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrupt.\n</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Edge trigger interrupt</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Level trigger interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IMD5</name>
              <description>Port [A/B/C/D/E/F] Edge Or Level Detection Interrupt Control\nIMD[n] is used to control the interrupt is by level trigger or by edge trigger. If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce. If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrupt.\n</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Edge trigger interrupt</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Level trigger interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IMD6</name>
              <description>Port [A/B/C/D/E/F] Edge Or Level Detection Interrupt Control\nIMD[n] is used to control the interrupt is by level trigger or by edge trigger. If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce. If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrupt.\n</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Edge trigger interrupt</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Level trigger interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IMD7</name>
              <description>Port [A/B/C/D/E/F] Edge Or Level Detection Interrupt Control\nIMD[n] is used to control the interrupt is by level trigger or by edge trigger. If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce. If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrupt.\n</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Edge trigger interrupt</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Level trigger interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IMD8</name>
              <description>Port [A/B/C/D/E/F] Edge Or Level Detection Interrupt Control\nIMD[n] is used to control the interrupt is by level trigger or by edge trigger. If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce. If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrupt.\n</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Edge trigger interrupt</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Level trigger interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IMD9</name>
              <description>Port [A/B/C/D/E/F] Edge Or Level Detection Interrupt Control\nIMD[n] is used to control the interrupt is by level trigger or by edge trigger. If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce. If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrupt.\n</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Edge trigger interrupt</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Level trigger interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IMD10</name>
              <description>Port [A/B/C/D/E/F] Edge Or Level Detection Interrupt Control\nIMD[n] is used to control the interrupt is by level trigger or by edge trigger. If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce. If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrupt.\n</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Edge trigger interrupt</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Level trigger interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IMD11</name>
              <description>Port [A/B/C/D/E/F] Edge Or Level Detection Interrupt Control\nIMD[n] is used to control the interrupt is by level trigger or by edge trigger. If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce. If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrupt.\n</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Edge trigger interrupt</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Level trigger interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IMD12</name>
              <description>Port [A/B/C/D/E/F] Edge Or Level Detection Interrupt Control\nIMD[n] is used to control the interrupt is by level trigger or by edge trigger. If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce. If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrupt.\n</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Edge trigger interrupt</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Level trigger interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IMD13</name>
              <description>Port [A/B/C/D/E/F] Edge Or Level Detection Interrupt Control\nIMD[n] is used to control the interrupt is by level trigger or by edge trigger. If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce. If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrupt.\n</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Edge trigger interrupt</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Level trigger interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IMD14</name>
              <description>Port [A/B/C/D/E/F] Edge Or Level Detection Interrupt Control\nIMD[n] is used to control the interrupt is by level trigger or by edge trigger. If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce. If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrupt.\n</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Edge trigger interrupt</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Level trigger interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IMD15</name>
              <description>Port [A/B/C/D/E/F] Edge Or Level Detection Interrupt Control\nIMD[n] is used to control the interrupt is by level trigger or by edge trigger. If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce. If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrupt.\n</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Edge trigger interrupt</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Level trigger interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>GPIOA_IEN</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>GPIOA_IEN</displayName>
          <description>GPIO Port A Interrupt Enable</description>
          <addressOffset>0x1C</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>IF_EN0</name>
              <description>Port [A/B/C/D/E/F] Interrupt Enabled By Input Falling Edge Or Input Level Low\nIF_EN[n] is used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wake-up function\nWhen setting the IF_EN[n] bit to 1:\nIf the interrupt is level trigger, the input PIN[n] state at level "low" will generate the interrupt.\nIf the interrupt is edge trigger, the input PIN[n] state change from "high-to-low" will generate the interrupt.\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PIN[n] state low-level or high-to-low change interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PIN[n] state low-level or high-to-low change interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IF_EN1</name>
              <description>Port [A/B/C/D/E/F] Interrupt Enabled By Input Falling Edge Or Input Level Low\nIF_EN[n] is used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wake-up function\nWhen setting the IF_EN[n] bit to 1:\nIf the interrupt is level trigger, the input PIN[n] state at level "low" will generate the interrupt.\nIf the interrupt is edge trigger, the input PIN[n] state change from "high-to-low" will generate the interrupt.\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PIN[n] state low-level or high-to-low change interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PIN[n] state low-level or high-to-low change interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IF_EN2</name>
              <description>Port [A/B/C/D/E/F] Interrupt Enabled By Input Falling Edge Or Input Level Low\nIF_EN[n] is used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wake-up function\nWhen setting the IF_EN[n] bit to 1:\nIf the interrupt is level trigger, the input PIN[n] state at level "low" will generate the interrupt.\nIf the interrupt is edge trigger, the input PIN[n] state change from "high-to-low" will generate the interrupt.\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PIN[n] state low-level or high-to-low change interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PIN[n] state low-level or high-to-low change interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IF_EN3</name>
              <description>Port [A/B/C/D/E/F] Interrupt Enabled By Input Falling Edge Or Input Level Low\nIF_EN[n] is used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wake-up function\nWhen setting the IF_EN[n] bit to 1:\nIf the interrupt is level trigger, the input PIN[n] state at level "low" will generate the interrupt.\nIf the interrupt is edge trigger, the input PIN[n] state change from "high-to-low" will generate the interrupt.\n</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PIN[n] state low-level or high-to-low change interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PIN[n] state low-level or high-to-low change interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IF_EN4</name>
              <description>Port [A/B/C/D/E/F] Interrupt Enabled By Input Falling Edge Or Input Level Low\nIF_EN[n] is used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wake-up function\nWhen setting the IF_EN[n] bit to 1:\nIf the interrupt is level trigger, the input PIN[n] state at level "low" will generate the interrupt.\nIf the interrupt is edge trigger, the input PIN[n] state change from "high-to-low" will generate the interrupt.\n</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PIN[n] state low-level or high-to-low change interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PIN[n] state low-level or high-to-low change interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IF_EN5</name>
              <description>Port [A/B/C/D/E/F] Interrupt Enabled By Input Falling Edge Or Input Level Low\nIF_EN[n] is used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wake-up function\nWhen setting the IF_EN[n] bit to 1:\nIf the interrupt is level trigger, the input PIN[n] state at level "low" will generate the interrupt.\nIf the interrupt is edge trigger, the input PIN[n] state change from "high-to-low" will generate the interrupt.\n</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PIN[n] state low-level or high-to-low change interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PIN[n] state low-level or high-to-low change interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IF_EN6</name>
              <description>Port [A/B/C/D/E/F] Interrupt Enabled By Input Falling Edge Or Input Level Low\nIF_EN[n] is used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wake-up function\nWhen setting the IF_EN[n] bit to 1:\nIf the interrupt is level trigger, the input PIN[n] state at level "low" will generate the interrupt.\nIf the interrupt is edge trigger, the input PIN[n] state change from "high-to-low" will generate the interrupt.\n</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PIN[n] state low-level or high-to-low change interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PIN[n] state low-level or high-to-low change interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IF_EN7</name>
              <description>Port [A/B/C/D/E/F] Interrupt Enabled By Input Falling Edge Or Input Level Low\nIF_EN[n] is used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wake-up function\nWhen setting the IF_EN[n] bit to 1:\nIf the interrupt is level trigger, the input PIN[n] state at level "low" will generate the interrupt.\nIf the interrupt is edge trigger, the input PIN[n] state change from "high-to-low" will generate the interrupt.\n</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PIN[n] state low-level or high-to-low change interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PIN[n] state low-level or high-to-low change interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IF_EN8</name>
              <description>Port [A/B/C/D/E/F] Interrupt Enabled By Input Falling Edge Or Input Level Low\nIF_EN[n] is used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wake-up function\nWhen setting the IF_EN[n] bit to 1:\nIf the interrupt is level trigger, the input PIN[n] state at level "low" will generate the interrupt.\nIf the interrupt is edge trigger, the input PIN[n] state change from "high-to-low" will generate the interrupt.\n</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PIN[n] state low-level or high-to-low change interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PIN[n] state low-level or high-to-low change interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IF_EN9</name>
              <description>Port [A/B/C/D/E/F] Interrupt Enabled By Input Falling Edge Or Input Level Low\nIF_EN[n] is used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wake-up function\nWhen setting the IF_EN[n] bit to 1:\nIf the interrupt is level trigger, the input PIN[n] state at level "low" will generate the interrupt.\nIf the interrupt is edge trigger, the input PIN[n] state change from "high-to-low" will generate the interrupt.\n</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PIN[n] state low-level or high-to-low change interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PIN[n] state low-level or high-to-low change interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IF_EN10</name>
              <description>Port [A/B/C/D/E/F] Interrupt Enabled By Input Falling Edge Or Input Level Low\nIF_EN[n] is used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wake-up function\nWhen setting the IF_EN[n] bit to 1:\nIf the interrupt is level trigger, the input PIN[n] state at level "low" will generate the interrupt.\nIf the interrupt is edge trigger, the input PIN[n] state change from "high-to-low" will generate the interrupt.\n</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PIN[n] state low-level or high-to-low change interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PIN[n] state low-level or high-to-low change interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IF_EN11</name>
              <description>Port [A/B/C/D/E/F] Interrupt Enabled By Input Falling Edge Or Input Level Low\nIF_EN[n] is used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wake-up function\nWhen setting the IF_EN[n] bit to 1:\nIf the interrupt is level trigger, the input PIN[n] state at level "low" will generate the interrupt.\nIf the interrupt is edge trigger, the input PIN[n] state change from "high-to-low" will generate the interrupt.\n</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PIN[n] state low-level or high-to-low change interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PIN[n] state low-level or high-to-low change interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IF_EN12</name>
              <description>Port [A/B/C/D/E/F] Interrupt Enabled By Input Falling Edge Or Input Level Low\nIF_EN[n] is used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wake-up function\nWhen setting the IF_EN[n] bit to 1:\nIf the interrupt is level trigger, the input PIN[n] state at level "low" will generate the interrupt.\nIf the interrupt is edge trigger, the input PIN[n] state change from "high-to-low" will generate the interrupt.\n</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PIN[n] state low-level or high-to-low change interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PIN[n] state low-level or high-to-low change interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IF_EN13</name>
              <description>Port [A/B/C/D/E/F] Interrupt Enabled By Input Falling Edge Or Input Level Low\nIF_EN[n] is used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wake-up function\nWhen setting the IF_EN[n] bit to 1:\nIf the interrupt is level trigger, the input PIN[n] state at level "low" will generate the interrupt.\nIf the interrupt is edge trigger, the input PIN[n] state change from "high-to-low" will generate the interrupt.\n</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PIN[n] state low-level or high-to-low change interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PIN[n] state low-level or high-to-low change interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IF_EN14</name>
              <description>Port [A/B/C/D/E/F] Interrupt Enabled By Input Falling Edge Or Input Level Low\nIF_EN[n] is used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wake-up function\nWhen setting the IF_EN[n] bit to 1:\nIf the interrupt is level trigger, the input PIN[n] state at level "low" will generate the interrupt.\nIf the interrupt is edge trigger, the input PIN[n] state change from "high-to-low" will generate the interrupt.\n</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PIN[n] state low-level or high-to-low change interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PIN[n] state low-level or high-to-low change interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IF_EN15</name>
              <description>Port [A/B/C/D/E/F] Interrupt Enabled By Input Falling Edge Or Input Level Low\nIF_EN[n] is used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wake-up function\nWhen setting the IF_EN[n] bit to 1:\nIf the interrupt is level trigger, the input PIN[n] state at level "low" will generate the interrupt.\nIf the interrupt is edge trigger, the input PIN[n] state change from "high-to-low" will generate the interrupt.\n</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PIN[n] state low-level or high-to-low change interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PIN[n] state low-level or high-to-low change interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IR_EN0</name>
              <description>Port [A/B/C/D/E/F] Interrupt Enabled By Input Rising Edge Or Input Level High\nIR_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wake-up function \nWhen setting the IR_EN[n] bit to 1:\nIf the interrupt is level trigger, the input PIN[n] state at level "high" will generate the interrupt.\nIf the interrupt is edge trigger, the input PIN[n] state change from "low-to-high" will generate the interrupt.\n</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PIN[n] level-high or low-to-high interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PIN[n] level-high or low-to-high interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IR_EN1</name>
              <description>Port [A/B/C/D/E/F] Interrupt Enabled By Input Rising Edge Or Input Level High\nIR_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wake-up function \nWhen setting the IR_EN[n] bit to 1:\nIf the interrupt is level trigger, the input PIN[n] state at level "high" will generate the interrupt.\nIf the interrupt is edge trigger, the input PIN[n] state change from "low-to-high" will generate the interrupt.\n</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PIN[n] level-high or low-to-high interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PIN[n] level-high or low-to-high interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IR_EN2</name>
              <description>Port [A/B/C/D/E/F] Interrupt Enabled By Input Rising Edge Or Input Level High\nIR_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wake-up function \nWhen setting the IR_EN[n] bit to 1:\nIf the interrupt is level trigger, the input PIN[n] state at level "high" will generate the interrupt.\nIf the interrupt is edge trigger, the input PIN[n] state change from "low-to-high" will generate the interrupt.\n</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PIN[n] level-high or low-to-high interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PIN[n] level-high or low-to-high interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IR_EN3</name>
              <description>Port [A/B/C/D/E/F] Interrupt Enabled By Input Rising Edge Or Input Level High\nIR_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wake-up function \nWhen setting the IR_EN[n] bit to 1:\nIf the interrupt is level trigger, the input PIN[n] state at level "high" will generate the interrupt.\nIf the interrupt is edge trigger, the input PIN[n] state change from "low-to-high" will generate the interrupt.\n</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PIN[n] level-high or low-to-high interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PIN[n] level-high or low-to-high interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IR_EN4</name>
              <description>Port [A/B/C/D/E/F] Interrupt Enabled By Input Rising Edge Or Input Level High\nIR_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wake-up function \nWhen setting the IR_EN[n] bit to 1:\nIf the interrupt is level trigger, the input PIN[n] state at level "high" will generate the interrupt.\nIf the interrupt is edge trigger, the input PIN[n] state change from "low-to-high" will generate the interrupt.\n</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PIN[n] level-high or low-to-high interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PIN[n] level-high or low-to-high interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IR_EN5</name>
              <description>Port [A/B/C/D/E/F] Interrupt Enabled By Input Rising Edge Or Input Level High\nIR_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wake-up function \nWhen setting the IR_EN[n] bit to 1:\nIf the interrupt is level trigger, the input PIN[n] state at level "high" will generate the interrupt.\nIf the interrupt is edge trigger, the input PIN[n] state change from "low-to-high" will generate the interrupt.\n</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PIN[n] level-high or low-to-high interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PIN[n] level-high or low-to-high interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IR_EN6</name>
              <description>Port [A/B/C/D/E/F] Interrupt Enabled By Input Rising Edge Or Input Level High\nIR_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wake-up function \nWhen setting the IR_EN[n] bit to 1:\nIf the interrupt is level trigger, the input PIN[n] state at level "high" will generate the interrupt.\nIf the interrupt is edge trigger, the input PIN[n] state change from "low-to-high" will generate the interrupt.\n</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PIN[n] level-high or low-to-high interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PIN[n] level-high or low-to-high interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IR_EN7</name>
              <description>Port [A/B/C/D/E/F] Interrupt Enabled By Input Rising Edge Or Input Level High\nIR_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wake-up function \nWhen setting the IR_EN[n] bit to 1:\nIf the interrupt is level trigger, the input PIN[n] state at level "high" will generate the interrupt.\nIf the interrupt is edge trigger, the input PIN[n] state change from "low-to-high" will generate the interrupt.\n</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PIN[n] level-high or low-to-high interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PIN[n] level-high or low-to-high interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IR_EN8</name>
              <description>Port [A/B/C/D/E/F] Interrupt Enabled By Input Rising Edge Or Input Level High\nIR_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wake-up function \nWhen setting the IR_EN[n] bit to 1:\nIf the interrupt is level trigger, the input PIN[n] state at level "high" will generate the interrupt.\nIf the interrupt is edge trigger, the input PIN[n] state change from "low-to-high" will generate the interrupt.\n</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PIN[n] level-high or low-to-high interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PIN[n] level-high or low-to-high interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IR_EN9</name>
              <description>Port [A/B/C/D/E/F] Interrupt Enabled By Input Rising Edge Or Input Level High\nIR_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wake-up function \nWhen setting the IR_EN[n] bit to 1:\nIf the interrupt is level trigger, the input PIN[n] state at level "high" will generate the interrupt.\nIf the interrupt is edge trigger, the input PIN[n] state change from "low-to-high" will generate the interrupt.\n</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PIN[n] level-high or low-to-high interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PIN[n] level-high or low-to-high interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IR_EN10</name>
              <description>Port [A/B/C/D/E/F] Interrupt Enabled By Input Rising Edge Or Input Level High\nIR_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wake-up function \nWhen setting the IR_EN[n] bit to 1:\nIf the interrupt is level trigger, the input PIN[n] state at level "high" will generate the interrupt.\nIf the interrupt is edge trigger, the input PIN[n] state change from "low-to-high" will generate the interrupt.\n</description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PIN[n] level-high or low-to-high interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PIN[n] level-high or low-to-high interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IR_EN11</name>
              <description>Port [A/B/C/D/E/F] Interrupt Enabled By Input Rising Edge Or Input Level High\nIR_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wake-up function \nWhen setting the IR_EN[n] bit to 1:\nIf the interrupt is level trigger, the input PIN[n] state at level "high" will generate the interrupt.\nIf the interrupt is edge trigger, the input PIN[n] state change from "low-to-high" will generate the interrupt.\n</description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PIN[n] level-high or low-to-high interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PIN[n] level-high or low-to-high interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IR_EN12</name>
              <description>Port [A/B/C/D/E/F] Interrupt Enabled By Input Rising Edge Or Input Level High\nIR_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wake-up function \nWhen setting the IR_EN[n] bit to 1:\nIf the interrupt is level trigger, the input PIN[n] state at level "high" will generate the interrupt.\nIf the interrupt is edge trigger, the input PIN[n] state change from "low-to-high" will generate the interrupt.\n</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PIN[n] level-high or low-to-high interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PIN[n] level-high or low-to-high interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IR_EN13</name>
              <description>Port [A/B/C/D/E/F] Interrupt Enabled By Input Rising Edge Or Input Level High\nIR_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wake-up function \nWhen setting the IR_EN[n] bit to 1:\nIf the interrupt is level trigger, the input PIN[n] state at level "high" will generate the interrupt.\nIf the interrupt is edge trigger, the input PIN[n] state change from "low-to-high" will generate the interrupt.\n</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PIN[n] level-high or low-to-high interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PIN[n] level-high or low-to-high interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IR_EN14</name>
              <description>Port [A/B/C/D/E/F] Interrupt Enabled By Input Rising Edge Or Input Level High\nIR_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wake-up function \nWhen setting the IR_EN[n] bit to 1:\nIf the interrupt is level trigger, the input PIN[n] state at level "high" will generate the interrupt.\nIf the interrupt is edge trigger, the input PIN[n] state change from "low-to-high" will generate the interrupt.\n</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PIN[n] level-high or low-to-high interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PIN[n] level-high or low-to-high interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IR_EN15</name>
              <description>Port [A/B/C/D/E/F] Interrupt Enabled By Input Rising Edge Or Input Level High\nIR_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wake-up function \nWhen setting the IR_EN[n] bit to 1:\nIf the interrupt is level trigger, the input PIN[n] state at level "high" will generate the interrupt.\nIf the interrupt is edge trigger, the input PIN[n] state change from "low-to-high" will generate the interrupt.\n</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PIN[n] level-high or low-to-high interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PIN[n] level-high or low-to-high interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>GPIOA_ISRC</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>GPIOA_ISRC</displayName>
          <description>GPIO Port A Interrupt Source Flag</description>
          <addressOffset>0x20</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ISRC0</name>
              <description>Port [A/B/C/D/E/F] Interrupt Source Flag\nRead :\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No interrupt at GPIOx[n].\nNo action</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIOx[n] generates an interrupt.\nClear the corresponding pending interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ISRC1</name>
              <description>Port [A/B/C/D/E/F] Interrupt Source Flag\nRead :\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No interrupt at GPIOx[n].\nNo action</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIOx[n] generates an interrupt.\nClear the corresponding pending interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ISRC2</name>
              <description>Port [A/B/C/D/E/F] Interrupt Source Flag\nRead :\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No interrupt at GPIOx[n].\nNo action</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIOx[n] generates an interrupt.\nClear the corresponding pending interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ISRC3</name>
              <description>Port [A/B/C/D/E/F] Interrupt Source Flag\nRead :\n</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No interrupt at GPIOx[n].\nNo action</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIOx[n] generates an interrupt.\nClear the corresponding pending interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ISRC4</name>
              <description>Port [A/B/C/D/E/F] Interrupt Source Flag\nRead :\n</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No interrupt at GPIOx[n].\nNo action</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIOx[n] generates an interrupt.\nClear the corresponding pending interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ISRC5</name>
              <description>Port [A/B/C/D/E/F] Interrupt Source Flag\nRead :\n</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No interrupt at GPIOx[n].\nNo action</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIOx[n] generates an interrupt.\nClear the corresponding pending interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ISRC6</name>
              <description>Port [A/B/C/D/E/F] Interrupt Source Flag\nRead :\n</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No interrupt at GPIOx[n].\nNo action</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIOx[n] generates an interrupt.\nClear the corresponding pending interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ISRC7</name>
              <description>Port [A/B/C/D/E/F] Interrupt Source Flag\nRead :\n</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No interrupt at GPIOx[n].\nNo action</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIOx[n] generates an interrupt.\nClear the corresponding pending interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ISRC8</name>
              <description>Port [A/B/C/D/E/F] Interrupt Source Flag\nRead :\n</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No interrupt at GPIOx[n].\nNo action</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIOx[n] generates an interrupt.\nClear the corresponding pending interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ISRC9</name>
              <description>Port [A/B/C/D/E/F] Interrupt Source Flag\nRead :\n</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No interrupt at GPIOx[n].\nNo action</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIOx[n] generates an interrupt.\nClear the corresponding pending interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ISRC10</name>
              <description>Port [A/B/C/D/E/F] Interrupt Source Flag\nRead :\n</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No interrupt at GPIOx[n].\nNo action</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIOx[n] generates an interrupt.\nClear the corresponding pending interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ISRC11</name>
              <description>Port [A/B/C/D/E/F] Interrupt Source Flag\nRead :\n</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No interrupt at GPIOx[n].\nNo action</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIOx[n] generates an interrupt.\nClear the corresponding pending interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ISRC12</name>
              <description>Port [A/B/C/D/E/F] Interrupt Source Flag\nRead :\n</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No interrupt at GPIOx[n].\nNo action</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIOx[n] generates an interrupt.\nClear the corresponding pending interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ISRC13</name>
              <description>Port [A/B/C/D/E/F] Interrupt Source Flag\nRead :\n</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No interrupt at GPIOx[n].\nNo action</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIOx[n] generates an interrupt.\nClear the corresponding pending interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ISRC14</name>
              <description>Port [A/B/C/D/E/F] Interrupt Source Flag\nRead :\n</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No interrupt at GPIOx[n].\nNo action</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIOx[n] generates an interrupt.\nClear the corresponding pending interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ISRC15</name>
              <description>Port [A/B/C/D/E/F] Interrupt Source Flag\nRead :\n</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No interrupt at GPIOx[n].\nNo action</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIOx[n] generates an interrupt.\nClear the corresponding pending interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="GPIOA_PMD">
          <name>GPIOB_PMD</name>
          <displayName>GPIOB_PMD</displayName>
          <description>GPIO Port B Pin I/O Mode Control</description>
          <addressOffset>0x40</addressOffset>
       </register>
       <register derivedFrom="GPIOA_OFFD">
          <name>GPIOB_OFFD</name>
          <displayName>GPIOB_OFFD</displayName>
          <description>GPIO Port B Pin Digital Input Path Disable Control</description>
          <addressOffset>0x44</addressOffset>
       </register>
       <register derivedFrom="GPIOA_DOUT">
          <name>GPIOB_DOUT</name>
          <displayName>GPIOB_DOUT</displayName>
          <description>GPIO Port B Data Output Value</description>
          <addressOffset>0x48</addressOffset>
       </register>
       <register derivedFrom="GPIOA_DMASK">
          <name>GPIOB_DMASK</name>
          <displayName>GPIOB_DMASK</displayName>
          <description>GPIO Port B Data Output Write Mask</description>
          <addressOffset>0x4C</addressOffset>
       </register>
       <register derivedFrom="GPIOA_PIN">
          <name>GPIOB_PIN</name>
          <displayName>GPIOB_PIN</displayName>
          <description>GPIO Port B Pin Value</description>
          <addressOffset>0x50</addressOffset>
       </register>
       <register derivedFrom="GPIOA_DBEN">
          <name>GPIOB_DBEN</name>
          <displayName>GPIOB_DBEN</displayName>
          <description>GPIO Port B De-bounce Enable</description>
          <addressOffset>0x54</addressOffset>
       </register>
       <register derivedFrom="GPIOA_IMD">
          <name>GPIOB_IMD</name>
          <displayName>GPIOB_IMD</displayName>
          <description>GPIO Port B Interrupt Mode Control</description>
          <addressOffset>0x58</addressOffset>
       </register>
       <register derivedFrom="GPIOA_IEN">
          <name>GPIOB_IEN</name>
          <displayName>GPIOB_IEN</displayName>
          <description>GPIO Port B Interrupt Enable</description>
          <addressOffset>0x5C</addressOffset>
       </register>
       <register derivedFrom="GPIOA_ISRC">
          <name>GPIOB_ISRC</name>
          <displayName>GPIOB_ISRC</displayName>
          <description>GPIO Port B Interrupt Source Flag</description>
          <addressOffset>0x60</addressOffset>
       </register>
       <register derivedFrom="GPIOA_PMD">
          <name>GPIOC_PMD</name>
          <displayName>GPIOC_PMD</displayName>
          <description>GPIO Port C Pin I/O Mode Control</description>
          <addressOffset>0x80</addressOffset>
       </register>
       <register derivedFrom="GPIOA_OFFD">
          <name>GPIOC_OFFD</name>
          <displayName>GPIOC_OFFD</displayName>
          <description>GPIO Port C Pin Digital Input Path Disable Control</description>
          <addressOffset>0x84</addressOffset>
       </register>
       <register derivedFrom="GPIOA_DOUT">
          <name>GPIOC_DOUT</name>
          <displayName>GPIOC_DOUT</displayName>
          <description>GPIO Port C Data Output Value</description>
          <addressOffset>0x88</addressOffset>
       </register>
       <register derivedFrom="GPIOA_DMASK">
          <name>GPIOC_DMASK</name>
          <displayName>GPIOC_DMASK</displayName>
          <description>GPIO Port C Data Output Write Mask</description>
          <addressOffset>0x8C</addressOffset>
       </register>
       <register derivedFrom="GPIOA_PIN">
          <name>GPIOC_PIN</name>
          <displayName>GPIOC_PIN</displayName>
          <description>GPIO Port C Pin Value</description>
          <addressOffset>0x90</addressOffset>
       </register>
       <register derivedFrom="GPIOA_DBEN">
          <name>GPIOC_DBEN</name>
          <displayName>GPIOC_DBEN</displayName>
          <description>GPIO Port C De-bounce Enable</description>
          <addressOffset>0x94</addressOffset>
       </register>
       <register derivedFrom="GPIOA_IMD">
          <name>GPIOC_IMD</name>
          <displayName>GPIOC_IMD</displayName>
          <description>GPIO Port C Interrupt Mode Control</description>
          <addressOffset>0x98</addressOffset>
       </register>
       <register derivedFrom="GPIOA_IEN">
          <name>GPIOC_IEN</name>
          <displayName>GPIOC_IEN</displayName>
          <description>GPIO Port C Interrupt Enable</description>
          <addressOffset>0x9C</addressOffset>
       </register>
       <register derivedFrom="GPIOA_ISRC">
          <name>GPIOC_ISRC</name>
          <displayName>GPIOC_ISRC</displayName>
          <description>GPIO Port C Interrupt Source Flag</description>
          <addressOffset>0xA0</addressOffset>
       </register>
       <register derivedFrom="GPIOA_PMD">
          <name>GPIOD_PMD</name>
          <displayName>GPIOD_PMD</displayName>
          <description>GPIO Port D Pin I/O Mode Control</description>
          <addressOffset>0xC0</addressOffset>
       </register>
       <register derivedFrom="GPIOA_OFFD">
          <name>GPIOD_OFFD</name>
          <displayName>GPIOD_OFFD</displayName>
          <description>GPIO Port D Pin Digital Input Path Disable Control</description>
          <addressOffset>0xC4</addressOffset>
       </register>
       <register derivedFrom="GPIOA_DOUT">
          <name>GPIOD_DOUT</name>
          <displayName>GPIOD_DOUT</displayName>
          <description>GPIO Port D Data Output Value</description>
          <addressOffset>0xC8</addressOffset>
       </register>
       <register derivedFrom="GPIOA_DMASK">
          <name>GPIOD_DMASK</name>
          <displayName>GPIOD_DMASK</displayName>
          <description>GPIO Port D Data Output Write Mask</description>
          <addressOffset>0xCC</addressOffset>
       </register>
       <register derivedFrom="GPIOA_PIN">
          <name>GPIOD_PIN</name>
          <displayName>GPIOD_PIN</displayName>
          <description>GPIO Port D Pin Value</description>
          <addressOffset>0xD0</addressOffset>
       </register>
       <register derivedFrom="GPIOA_DBEN">
          <name>GPIOD_DBEN</name>
          <displayName>GPIOD_DBEN</displayName>
          <description>GPIO Port D De-bounce Enable</description>
          <addressOffset>0xD4</addressOffset>
       </register>
       <register derivedFrom="GPIOA_IMD">
          <name>GPIOD_IMD</name>
          <displayName>GPIOD_IMD</displayName>
          <description>GPIO Port D Interrupt Mode Control</description>
          <addressOffset>0xD8</addressOffset>
       </register>
       <register derivedFrom="GPIOA_IEN">
          <name>GPIOD_IEN</name>
          <displayName>GPIOD_IEN</displayName>
          <description>GPIO Port D Interrupt Enable</description>
          <addressOffset>0xDC</addressOffset>
       </register>
       <register derivedFrom="GPIOA_ISRC">
          <name>GPIOD_ISRC</name>
          <displayName>GPIOD_ISRC</displayName>
          <description>GPIO Port D Interrupt Source Flag</description>
          <addressOffset>0xE0</addressOffset>
       </register>
       <register derivedFrom="GPIOA_PMD">
          <name>GPIOE_PMD</name>
          <displayName>GPIOE_PMD</displayName>
          <description>GPIO Port E Pin I/O Mode Control</description>
          <addressOffset>0x100</addressOffset>
       </register>
       <register derivedFrom="GPIOA_OFFD">
          <name>GPIOE_OFFD</name>
          <displayName>GPIOE_OFFD</displayName>
          <description>GPIO Port E Pin Digital Input Path Disable Control</description>
          <addressOffset>0x104</addressOffset>
       </register>
       <register derivedFrom="GPIOA_DOUT">
          <name>GPIOE_DOUT</name>
          <displayName>GPIOE_DOUT</displayName>
          <description>GPIO Port E Data Output Value</description>
          <addressOffset>0x108</addressOffset>
       </register>
       <register derivedFrom="GPIOA_DMASK">
          <name>GPIOE_DMASK</name>
          <displayName>GPIOE_DMASK</displayName>
          <description>GPIO Port E Data Output Write Mask</description>
          <addressOffset>0x10C</addressOffset>
       </register>
       <register derivedFrom="GPIOA_PIN">
          <name>GPIOE_PIN</name>
          <displayName>GPIOE_PIN</displayName>
          <description>GPIO Port E Pin Value</description>
          <addressOffset>0x110</addressOffset>
       </register>
       <register derivedFrom="GPIOA_DBEN">
          <name>GPIOE_DBEN</name>
          <displayName>GPIOE_DBEN</displayName>
          <description>GPIO Port E De-bounce Enable</description>
          <addressOffset>0x114</addressOffset>
       </register>
       <register derivedFrom="GPIOA_IMD">
          <name>GPIOE_IMD</name>
          <displayName>GPIOE_IMD</displayName>
          <description>GPIO Port E Interrupt Mode Control</description>
          <addressOffset>0x118</addressOffset>
       </register>
       <register derivedFrom="GPIOA_IEN">
          <name>GPIOE_IEN</name>
          <displayName>GPIOE_IEN</displayName>
          <description>GPIO Port E Interrupt Enable</description>
          <addressOffset>0x11C</addressOffset>
       </register>
       <register derivedFrom="GPIOA_ISRC">
          <name>GPIOE_ISRC</name>
          <displayName>GPIOE_ISRC</displayName>
          <description>GPIO Port E Interrupt Source Flag</description>
          <addressOffset>0x120</addressOffset>
       </register>
       <register derivedFrom="GPIOA_PMD">
          <name>GPIOF_PMD</name>
          <displayName>GPIOF_PMD</displayName>
          <description>GPIO Port F Pin I/O Mode Control</description>
          <addressOffset>0x140</addressOffset>
       </register>
       <register derivedFrom="GPIOA_OFFD">
          <name>GPIOF_OFFD</name>
          <displayName>GPIOF_OFFD</displayName>
          <description>GPIO Port F Pin Digital Input Path Disable Control</description>
          <addressOffset>0x144</addressOffset>
       </register>
       <register derivedFrom="GPIOA_DOUT">
          <name>GPIOF_DOUT</name>
          <displayName>GPIOF_DOUT</displayName>
          <description>GPIO Port F Data Output Value</description>
          <addressOffset>0x148</addressOffset>
       </register>
       <register derivedFrom="GPIOA_DMASK">
          <name>GPIOF_DMASK</name>
          <displayName>GPIOF_DMASK</displayName>
          <description>GPIO Port F Data Output Write Mask</description>
          <addressOffset>0x14C</addressOffset>
       </register>
       <register derivedFrom="GPIOA_PIN">
          <name>GPIOF_PIN</name>
          <displayName>GPIOF_PIN</displayName>
          <description>GPIO Port F Pin Value</description>
          <addressOffset>0x150</addressOffset>
       </register>
       <register derivedFrom="GPIOA_DBEN">
          <name>GPIOF_DBEN</name>
          <displayName>GPIOF_DBEN</displayName>
          <description>GPIO Port F De-bounce Enable</description>
          <addressOffset>0x154</addressOffset>
       </register>
       <register derivedFrom="GPIOA_IMD">
          <name>GPIOF_IMD</name>
          <displayName>GPIOF_IMD</displayName>
          <description>GPIO Port F Interrupt Mode Control</description>
          <addressOffset>0x158</addressOffset>
       </register>
       <register derivedFrom="GPIOA_IEN">
          <name>GPIOF_IEN</name>
          <displayName>GPIOF_IEN</displayName>
          <description>GPIO Port F Interrupt Enable</description>
          <addressOffset>0x15C</addressOffset>
       </register>
       <register derivedFrom="GPIOA_ISRC">
          <name>GPIOF_ISRC</name>
          <displayName>GPIOF_ISRC</displayName>
          <description>GPIO Port F Interrupt Source Flag</description>
          <addressOffset>0x160</addressOffset>
       </register>
       <register>
          <name>DBNCECON</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>DBNCECON</displayName>
          <description>External Interrupt De-bounce Control</description>
          <addressOffset>0x180</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000020</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DBCLKSEL</name>
              <description>De-Bounce Sampling Cycle Selection\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DBCLKSRC</name>
              <description>De-Bounce Counter Clock Source Selection\n</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>De-bounce counter clock source is the HCLK</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>De-bounce counter clock source is the internal 10 kHz low speed oscillator</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ICLK_ON</name>
              <description>Interrupt Clock On Mode\nIt is recommended to disable this bit to save system power if no special application concern.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Edge detection circuit is active only if I/O pin corresponding GPIOx_IEN bit is set to 1</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>All I/O pins edge detection circuit is always active after reset</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PA0_PDIO</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PA0_PDIO</displayName>
          <description>GPIO PA.n Pin Data Input/Output</description>
          <addressOffset>0x200</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFF0</resetMask>
          <fields>
            <field>
              <name>Pxn_PDIO</name>
              <description>GPIO Px.N Pin Data Input/Output\nWrite this bit can control one GPIO pin output value\nRead this register to get GPIO pin status.\nFor example: writing PA0_PDIO will reflect the written value to bit GPIOA_DOUT[0], read PA0_PDIO will return the value of GPIOA_PIN[0]\nNote: The write operation will not be affected by register GPIOx_DMASK</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Corresponding GPIO pin set to low</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Corresponding GPIO pin set to high</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PA0_PDIO">
          <name>PA1_PDIO</name>
          <displayName>PA1_PDIO</displayName>
          <description>GPIO PA.n Pin Data Input/Output</description>
          <addressOffset>0x204</addressOffset>
       </register>
       <register derivedFrom="PA0_PDIO">
          <name>PA2_PDIO</name>
          <displayName>PA2_PDIO</displayName>
          <description>GPIO PA.n Pin Data Input/Output</description>
          <addressOffset>0x208</addressOffset>
       </register>
       <register derivedFrom="PA0_PDIO">
          <name>PA3_PDIO</name>
          <displayName>PA3_PDIO</displayName>
          <description>GPIO PA.n Pin Data Input/Output</description>
          <addressOffset>0x20C</addressOffset>
       </register>
       <register derivedFrom="PA0_PDIO">
          <name>PA4_PDIO</name>
          <displayName>PA4_PDIO</displayName>
          <description>GPIO PA.n Pin Data Input/Output</description>
          <addressOffset>0x210</addressOffset>
       </register>
       <register derivedFrom="PA0_PDIO">
          <name>PA5_PDIO</name>
          <displayName>PA5_PDIO</displayName>
          <description>GPIO PA.n Pin Data Input/Output</description>
          <addressOffset>0x214</addressOffset>
       </register>
       <register derivedFrom="PA0_PDIO">
          <name>PA6_PDIO</name>
          <displayName>PA6_PDIO</displayName>
          <description>GPIO PA.n Pin Data Input/Output</description>
          <addressOffset>0x218</addressOffset>
       </register>
       <register derivedFrom="PA0_PDIO">
          <name>PA7_PDIO</name>
          <displayName>PA7_PDIO</displayName>
          <description>GPIO PA.n Pin Data Input/Output</description>
          <addressOffset>0x21C</addressOffset>
       </register>
       <register derivedFrom="PA0_PDIO">
          <name>PA8_PDIO</name>
          <displayName>PA8_PDIO</displayName>
          <description>GPIO PA.n Pin Data Input/Output</description>
          <addressOffset>0x220</addressOffset>
       </register>
       <register derivedFrom="PA0_PDIO">
          <name>PA9_PDIO</name>
          <displayName>PA9_PDIO</displayName>
          <description>GPIO PA.n Pin Data Input/Output</description>
          <addressOffset>0x224</addressOffset>
       </register>
       <register derivedFrom="PA0_PDIO">
          <name>PA10_PDIO</name>
          <displayName>PA10_PDIO</displayName>
          <description>GPIO PA.n Pin Data Input/Output</description>
          <addressOffset>0x228</addressOffset>
       </register>
       <register derivedFrom="PA0_PDIO">
          <name>PA11_PDIO</name>
          <displayName>PA11_PDIO</displayName>
          <description>GPIO PA.n Pin Data Input/Output</description>
          <addressOffset>0x22C</addressOffset>
       </register>
       <register derivedFrom="PA0_PDIO">
          <name>PA12_PDIO</name>
          <displayName>PA12_PDIO</displayName>
          <description>GPIO PA.n Pin Data Input/Output</description>
          <addressOffset>0x230</addressOffset>
       </register>
       <register derivedFrom="PA0_PDIO">
          <name>PA13_PDIO</name>
          <displayName>PA13_PDIO</displayName>
          <description>GPIO PA.n Pin Data Input/Output</description>
          <addressOffset>0x234</addressOffset>
       </register>
       <register derivedFrom="PA0_PDIO">
          <name>PA14_PDIO</name>
          <displayName>PA14_PDIO</displayName>
          <description>GPIO PA.n Pin Data Input/Output</description>
          <addressOffset>0x238</addressOffset>
       </register>
       <register derivedFrom="PA0_PDIO">
          <name>PA15_PDIO</name>
          <displayName>PA15_PDIO</displayName>
          <description>GPIO PA.n Pin Data Input/Output</description>
          <addressOffset>0x23C</addressOffset>
       </register>
       <register derivedFrom="PA0_PDIO">
          <name>PB0_PDIO</name>
          <displayName>PB0_PDIO</displayName>
          <description>GPIO PB.n Pin Data Input/Output</description>
          <addressOffset>0x240</addressOffset>
       </register>
       <register derivedFrom="PB0_PDIO">
          <name>PB1_PDIO</name>
          <displayName>PB1_PDIO</displayName>
          <description>GPIO PB.n Pin Data Input/Output</description>
          <addressOffset>0x244</addressOffset>
       </register>
       <register derivedFrom="PB0_PDIO">
          <name>PB2_PDIO</name>
          <displayName>PB2_PDIO</displayName>
          <description>GPIO PB.n Pin Data Input/Output</description>
          <addressOffset>0x248</addressOffset>
       </register>
       <register derivedFrom="PB0_PDIO">
          <name>PB3_PDIO</name>
          <displayName>PB3_PDIO</displayName>
          <description>GPIO PB.n Pin Data Input/Output</description>
          <addressOffset>0x24C</addressOffset>
       </register>
       <register derivedFrom="PB0_PDIO">
          <name>PB4_PDIO</name>
          <displayName>PB4_PDIO</displayName>
          <description>GPIO PB.n Pin Data Input/Output</description>
          <addressOffset>0x250</addressOffset>
       </register>
       <register derivedFrom="PB0_PDIO">
          <name>PB5_PDIO</name>
          <displayName>PB5_PDIO</displayName>
          <description>GPIO PB.n Pin Data Input/Output</description>
          <addressOffset>0x254</addressOffset>
       </register>
       <register derivedFrom="PB0_PDIO">
          <name>PB6_PDIO</name>
          <displayName>PB6_PDIO</displayName>
          <description>GPIO PB.n Pin Data Input/Output</description>
          <addressOffset>0x258</addressOffset>
       </register>
       <register derivedFrom="PB0_PDIO">
          <name>PB7_PDIO</name>
          <displayName>PB7_PDIO</displayName>
          <description>GPIO PB.n Pin Data Input/Output</description>
          <addressOffset>0x25C</addressOffset>
       </register>
       <register derivedFrom="PB0_PDIO">
          <name>PB8_PDIO</name>
          <displayName>PB8_PDIO</displayName>
          <description>GPIO PB.n Pin Data Input/Output</description>
          <addressOffset>0x260</addressOffset>
       </register>
       <register derivedFrom="PB0_PDIO">
          <name>PB9_PDIO</name>
          <displayName>PB9_PDIO</displayName>
          <description>GPIO PB.n Pin Data Input/Output</description>
          <addressOffset>0x264</addressOffset>
       </register>
       <register derivedFrom="PB0_PDIO">
          <name>PB10_PDIO</name>
          <displayName>PB10_PDIO</displayName>
          <description>GPIO PB.n Pin Data Input/Output</description>
          <addressOffset>0x268</addressOffset>
       </register>
       <register derivedFrom="PB0_PDIO">
          <name>PB11_PDIO</name>
          <displayName>PB11_PDIO</displayName>
          <description>GPIO PB.n Pin Data Input/Output</description>
          <addressOffset>0x26C</addressOffset>
       </register>
       <register derivedFrom="PB0_PDIO">
          <name>PB12_PDIO</name>
          <displayName>PB12_PDIO</displayName>
          <description>GPIO PB.n Pin Data Input/Output</description>
          <addressOffset>0x270</addressOffset>
       </register>
       <register derivedFrom="PB0_PDIO">
          <name>PB13_PDIO</name>
          <displayName>PB13_PDIO</displayName>
          <description>GPIO PB.n Pin Data Input/Output</description>
          <addressOffset>0x274</addressOffset>
       </register>
       <register derivedFrom="PB0_PDIO">
          <name>PB14_PDIO</name>
          <displayName>PB14_PDIO</displayName>
          <description>GPIO PB.n Pin Data Input/Output</description>
          <addressOffset>0x278</addressOffset>
       </register>
       <register derivedFrom="PB0_PDIO">
          <name>PB15_PDIO</name>
          <displayName>PB15_PDIO</displayName>
          <description>GPIO PB.n Pin Data Input/Output</description>
          <addressOffset>0x27C</addressOffset>
       </register>
       <register derivedFrom="PA0_PDIO">
          <name>PC0_PDIO</name>
          <displayName>PC0_PDIO</displayName>
          <description>GPIO PC.n Pin Data Input/Output</description>
          <addressOffset>0x280</addressOffset>
       </register>
       <register derivedFrom="PC0_PDIO">
          <name>PC1_PDIO</name>
          <displayName>PC1_PDIO</displayName>
          <description>GPIO PC.n Pin Data Input/Output</description>
          <addressOffset>0x284</addressOffset>
       </register>
       <register derivedFrom="PC0_PDIO">
          <name>PC2_PDIO</name>
          <displayName>PC2_PDIO</displayName>
          <description>GPIO PC.n Pin Data Input/Output</description>
          <addressOffset>0x288</addressOffset>
       </register>
       <register derivedFrom="PC0_PDIO">
          <name>PC3_PDIO</name>
          <displayName>PC3_PDIO</displayName>
          <description>GPIO PC.n Pin Data Input/Output</description>
          <addressOffset>0x28C</addressOffset>
       </register>
       <register derivedFrom="PC0_PDIO">
          <name>PC4_PDIO</name>
          <displayName>PC4_PDIO</displayName>
          <description>GPIO PC.n Pin Data Input/Output</description>
          <addressOffset>0x290</addressOffset>
       </register>
       <register derivedFrom="PC0_PDIO">
          <name>PC5_PDIO</name>
          <displayName>PC5_PDIO</displayName>
          <description>GPIO PC.n Pin Data Input/Output</description>
          <addressOffset>0x294</addressOffset>
       </register>
       <register derivedFrom="PC0_PDIO">
          <name>PC6_PDIO</name>
          <displayName>PC6_PDIO</displayName>
          <description>GPIO PC.n Pin Data Input/Output</description>
          <addressOffset>0x298</addressOffset>
       </register>
       <register derivedFrom="PC0_PDIO">
          <name>PC7_PDIO</name>
          <displayName>PC7_PDIO</displayName>
          <description>GPIO PC.n Pin Data Input/Output</description>
          <addressOffset>0x29C</addressOffset>
       </register>
       <register derivedFrom="PC0_PDIO">
          <name>PC8_PDIO</name>
          <displayName>PC8_PDIO</displayName>
          <description>GPIO PC.n Pin Data Input/Output</description>
          <addressOffset>0x2A0</addressOffset>
       </register>
       <register derivedFrom="PC0_PDIO">
          <name>PC9_PDIO</name>
          <displayName>PC9_PDIO</displayName>
          <description>GPIO PC.n Pin Data Input/Output</description>
          <addressOffset>0x2A4</addressOffset>
       </register>
       <register derivedFrom="PC0_PDIO">
          <name>PC10_PDIO</name>
          <displayName>PC10_PDIO</displayName>
          <description>GPIO PC.n Pin Data Input/Output</description>
          <addressOffset>0x2A8</addressOffset>
       </register>
       <register derivedFrom="PC0_PDIO">
          <name>PC11_PDIO</name>
          <displayName>PC11_PDIO</displayName>
          <description>GPIO PC.n Pin Data Input/Output</description>
          <addressOffset>0x2AC</addressOffset>
       </register>
       <register derivedFrom="PC0_PDIO">
          <name>PC12_PDIO</name>
          <displayName>PC12_PDIO</displayName>
          <description>GPIO PC.n Pin Data Input/Output</description>
          <addressOffset>0x2B0</addressOffset>
       </register>
       <register derivedFrom="PC0_PDIO">
          <name>PC13_PDIO</name>
          <displayName>PC13_PDIO</displayName>
          <description>GPIO PC.n Pin Data Input/Output</description>
          <addressOffset>0x2B4</addressOffset>
       </register>
       <register derivedFrom="PC0_PDIO">
          <name>PC14_PDIO</name>
          <displayName>PC14_PDIO</displayName>
          <description>GPIO PC.n Pin Data Input/Output</description>
          <addressOffset>0x2B8</addressOffset>
       </register>
       <register derivedFrom="PC0_PDIO">
          <name>PC15_PDIO</name>
          <displayName>PC15_PDIO</displayName>
          <description>GPIO PC.n Pin Data Input/Output</description>
          <addressOffset>0x2BC</addressOffset>
       </register>
       <register derivedFrom="PA0_PDIO">
          <name>PD0_PDIO</name>
          <displayName>PD0_PDIO</displayName>
          <description>GPIO PD.n Pin Data Input/Output</description>
          <addressOffset>0x2C0</addressOffset>
       </register>
       <register derivedFrom="PD0_PDIO">
          <name>PD1_PDIO</name>
          <displayName>PD1_PDIO</displayName>
          <description>GPIO PD.n Pin Data Input/Output</description>
          <addressOffset>0x2C4</addressOffset>
       </register>
       <register derivedFrom="PD0_PDIO">
          <name>PD2_PDIO</name>
          <displayName>PD2_PDIO</displayName>
          <description>GPIO PD.n Pin Data Input/Output</description>
          <addressOffset>0x2C8</addressOffset>
       </register>
       <register derivedFrom="PD0_PDIO">
          <name>PD3_PDIO</name>
          <displayName>PD3_PDIO</displayName>
          <description>GPIO PD.n Pin Data Input/Output</description>
          <addressOffset>0x2CC</addressOffset>
       </register>
       <register derivedFrom="PD0_PDIO">
          <name>PD4_PDIO</name>
          <displayName>PD4_PDIO</displayName>
          <description>GPIO PD.n Pin Data Input/Output</description>
          <addressOffset>0x2D0</addressOffset>
       </register>
       <register derivedFrom="PD0_PDIO">
          <name>PD5_PDIO</name>
          <displayName>PD5_PDIO</displayName>
          <description>GPIO PD.n Pin Data Input/Output</description>
          <addressOffset>0x2D4</addressOffset>
       </register>
       <register derivedFrom="PD0_PDIO">
          <name>PD6_PDIO</name>
          <displayName>PD6_PDIO</displayName>
          <description>GPIO PD.n Pin Data Input/Output</description>
          <addressOffset>0x2D8</addressOffset>
       </register>
       <register derivedFrom="PD0_PDIO">
          <name>PD7_PDIO</name>
          <displayName>PD7_PDIO</displayName>
          <description>GPIO PD.n Pin Data Input/Output</description>
          <addressOffset>0x2DC</addressOffset>
       </register>
       <register derivedFrom="PD0_PDIO">
          <name>PD8_PDIO</name>
          <displayName>PD8_PDIO</displayName>
          <description>GPIO PD.n Pin Data Input/Output</description>
          <addressOffset>0x2E0</addressOffset>
       </register>
       <register derivedFrom="PD0_PDIO">
          <name>PD9_PDIO</name>
          <displayName>PD9_PDIO</displayName>
          <description>GPIO PD.n Pin Data Input/Output</description>
          <addressOffset>0x2E4</addressOffset>
       </register>
       <register derivedFrom="PD0_PDIO">
          <name>PD10_PDIO</name>
          <displayName>PD10_PDIO</displayName>
          <description>GPIO PD.n Pin Data Input/Output</description>
          <addressOffset>0x2E8</addressOffset>
       </register>
       <register derivedFrom="PD0_PDIO">
          <name>PD11_PDIO</name>
          <displayName>PD11_PDIO</displayName>
          <description>GPIO PD.n Pin Data Input/Output</description>
          <addressOffset>0x2EC</addressOffset>
       </register>
       <register derivedFrom="PD0_PDIO">
          <name>PD12_PDIO</name>
          <displayName>PD12_PDIO</displayName>
          <description>GPIO PD.n Pin Data Input/Output</description>
          <addressOffset>0x2F0</addressOffset>
       </register>
       <register derivedFrom="PD0_PDIO">
          <name>PD13_PDIO</name>
          <displayName>PD13_PDIO</displayName>
          <description>GPIO PD.n Pin Data Input/Output</description>
          <addressOffset>0x2F4</addressOffset>
       </register>
       <register derivedFrom="PD0_PDIO">
          <name>PD14_PDIO</name>
          <displayName>PD14_PDIO</displayName>
          <description>GPIO PD.n Pin Data Input/Output</description>
          <addressOffset>0x2F8</addressOffset>
       </register>
       <register derivedFrom="PD0_PDIO">
          <name>PD15_PDIO</name>
          <displayName>PD15_PDIO</displayName>
          <description>GPIO PD.n Pin Data Input/Output</description>
          <addressOffset>0x2FC</addressOffset>
       </register>
       <register derivedFrom="PA0_PDIO">
          <name>PE0_PDIO</name>
          <displayName>PE0_PDIO</displayName>
          <description>GPIO PE.n Pin Data Input/Output</description>
          <addressOffset>0x300</addressOffset>
       </register>
       <register derivedFrom="PE0_PDIO">
          <name>PE1_PDIO</name>
          <displayName>PE1_PDIO</displayName>
          <description>GPIO PE.n Pin Data Input/Output</description>
          <addressOffset>0x304</addressOffset>
       </register>
       <register derivedFrom="PE0_PDIO">
          <name>PE2_PDIO</name>
          <displayName>PE2_PDIO</displayName>
          <description>GPIO PE.n Pin Data Input/Output</description>
          <addressOffset>0x308</addressOffset>
       </register>
       <register derivedFrom="PE0_PDIO">
          <name>PE3_PDIO</name>
          <displayName>PE3_PDIO</displayName>
          <description>GPIO PE.n Pin Data Input/Output</description>
          <addressOffset>0x30C</addressOffset>
       </register>
       <register derivedFrom="PE0_PDIO">
          <name>PE4_PDIO</name>
          <displayName>PE4_PDIO</displayName>
          <description>GPIO PE.n Pin Data Input/Output</description>
          <addressOffset>0x310</addressOffset>
       </register>
       <register derivedFrom="PE0_PDIO">
          <name>PE5_PDIO</name>
          <displayName>PE5_PDIO</displayName>
          <description>GPIO PE.n Pin Data Input/Output</description>
          <addressOffset>0x314</addressOffset>
       </register>
       <register derivedFrom="PE0_PDIO">
          <name>PE6_PDIO</name>
          <displayName>PE6_PDIO</displayName>
          <description>GPIO PE.n Pin Data Input/Output</description>
          <addressOffset>0x318</addressOffset>
       </register>
       <register derivedFrom="PE0_PDIO">
          <name>PE7_PDIO</name>
          <displayName>PE7_PDIO</displayName>
          <description>GPIO PE.n Pin Data Input/Output</description>
          <addressOffset>0x31C</addressOffset>
       </register>
       <register derivedFrom="PE0_PDIO">
          <name>PE8_PDIO</name>
          <displayName>PE8_PDIO</displayName>
          <description>GPIO PE.n Pin Data Input/Output</description>
          <addressOffset>0x320</addressOffset>
       </register>
       <register derivedFrom="PE0_PDIO">
          <name>PE9_PDIO</name>
          <displayName>PE9_PDIO</displayName>
          <description>GPIO PE.n Pin Data Input/Output</description>
          <addressOffset>0x324</addressOffset>
       </register>
       <register derivedFrom="PE0_PDIO">
          <name>PE10_PDIO</name>
          <displayName>PE10_PDIO</displayName>
          <description>GPIO PE.n Pin Data Input/Output</description>
          <addressOffset>0x328</addressOffset>
       </register>
       <register derivedFrom="PE0_PDIO">
          <name>PE11_PDIO</name>
          <displayName>PE11_PDIO</displayName>
          <description>GPIO PE.n Pin Data Input/Output</description>
          <addressOffset>0x32C</addressOffset>
       </register>
       <register derivedFrom="PE0_PDIO">
          <name>PE12_PDIO</name>
          <displayName>PE12_PDIO</displayName>
          <description>GPIO PE.n Pin Data Input/Output</description>
          <addressOffset>0x330</addressOffset>
       </register>
       <register derivedFrom="PE0_PDIO">
          <name>PE13_PDIO</name>
          <displayName>PE13_PDIO</displayName>
          <description>GPIO PE.n Pin Data Input/Output</description>
          <addressOffset>0x334</addressOffset>
       </register>
       <register derivedFrom="PE0_PDIO">
          <name>PE14_PDIO</name>
          <displayName>PE14_PDIO</displayName>
          <description>GPIO PE.n Pin Data Input/Output</description>
          <addressOffset>0x338</addressOffset>
       </register>
       <register derivedFrom="PE0_PDIO">
          <name>PE15_PDIO</name>
          <displayName>PE15_PDIO</displayName>
          <description>GPIO PE.n Pin Data Input/Output</description>
          <addressOffset>0x33C</addressOffset>
       </register>
       <register derivedFrom="PA0_PDIO">
          <name>PF0_PDIO</name>
          <displayName>PF0_PDIO</displayName>
          <description>GPIO PF.n Pin Data Input/Output</description>
          <addressOffset>0x340</addressOffset>
       </register>
       <register derivedFrom="PF0_PDIO">
          <name>PF1_PDIO</name>
          <displayName>PF1_PDIO</displayName>
          <description>GPIO PF.n Pin Data Input/Output</description>
          <addressOffset>0x344</addressOffset>
       </register>
       <register derivedFrom="PF0_PDIO">
          <name>PF2_PDIO</name>
          <displayName>PF2_PDIO</displayName>
          <description>GPIO PF.n Pin Data Input/Output</description>
          <addressOffset>0x348</addressOffset>
       </register>
       <register derivedFrom="PF0_PDIO">
          <name>PF3_PDIO</name>
          <displayName>PF3_PDIO</displayName>
          <description>GPIO PF.n Pin Data Input/Output</description>
          <addressOffset>0x34C</addressOffset>
       </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>CRC</name>
      <description>PDMA Register Map</description>
      <groupName>PDMA</groupName>
      <baseAddress>0x50008E00</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x0</offset>
        <size>0x8</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0xC</offset>
        <size>0x4</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x14</offset>
        <size>0x4</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x1C</offset>
        <size>0xC</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x80</offset>
        <size>0xC</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>CRC_CTL</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CRC_CTL</displayName>
          <description>CRC Control Register</description>
          <addressOffset>0x0</addressOffset>
          <access>read-write</access>
          <resetValue>0x20000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CRCCEN</name>
              <description>CRC Channel Enable Bit\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>CRC operation Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CRC_RST</name>
              <description>CRC Engine Reset\nNote: When operated in CPU PIO mode, setting this bit will reload the initial seed value (CRC_SEED register).</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reset the internal CRC state machine and internal buffer. The others contents of CRC_CTL register will not be cleared. This bit will be cleared automatically</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TRIG_EN</name>
              <description>Trigger Enable Bit\nThis bit is used to trigger the CRC DMA transfer.\nNote1: If this bit asserts which indicates the CRC engine operation in CRC DMA mode, do not fill in any data in CRC_WDATA register.\nNote2: When CRC DMA transfer completed, this bit will be cleared automatically.\nNote3: If the bus error occurs when CRC DMA transfer data, all CRC DMA transfer will be stopped. Software must reset all DMA channel before trigger DMA again.</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>CRC DMA data read or write transfer Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>WDATA_RVS</name>
              <description>Write Data Order Reverse\nThis bit is used to enable the bit order reverse function for write data value in CRC_WDATA register.\nNote: If the write data is 0xAABBCCDD, the bit order reverse for CRC write data in is 0x55DD33BB</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Bit order reverse for CRC write data in Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Bit order reverse for CRC write data in Enabled (per byte)</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CHECKSUM_RVS</name>
              <description>Checksum Reverse\nThis bit is used to enable the bit order reverse function for write data value in CRC_CHECKSUM register.\nNote: If the checksum result is 0XDD7B0F2E, the bit order reverse for CRC checksum is 0x74F0DEBB</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Bit order reverse for CRC checksum Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Bit order reverse for CRC checksum Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>WDATA_COM</name>
              <description>Write Data 1's Complement\nThis bit is used to enable the 1's complement function for write data value in CRC_WDATA register.\n</description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>1's complement for CRC write data in Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>1's complement for CRC write data in Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CHECKSUM_COM</name>
              <description>Checksum 1's Complement\nThis bit is used to enable the 1's complement function for checksum result in CRC_CHECKSUM register.\n</description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>1's complement for CRC checksum Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>1's complement for CRC checksum Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CPU_WDLEN</name>
              <description>CPU Write Data Length\nThis field indicates the CPU write data length only when operating in CPU PIO mode.\nNote1: This field is only valid when operating in CPU PIO mode.\nNote2: When the write data length is 8-bit mode, the valid data in CRC_WDATA register is only CRC_WDATA [7:0] bits; if the write data length is 16-bit mode, the valid data in CRC_WDATA register is only CRC_WDATA [15:0].</description>
              <bitOffset>28</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The write data length is 8-bit mode</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The write data length is 16-bit mode</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>The write data length is 32-bit mode</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Reserved</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CRC_MODE</name>
              <description>CRC Polynomial Mode\nThis field indicates the CRC operation polynomial mode.\n</description>
              <bitOffset>30</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>CRC-CCITT Polynomial Mode</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>CRC-8 Polynomial Mode</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>CRC-16 Polynomial Mode</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>CRC-32 Polynomial Mode</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CRC_DMASAR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CRC_DMASAR</displayName>
          <description>CRC DMA Source Address Register</description>
          <addressOffset>0x4</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CRC_DMASAR</name>
              <description>CRC DMA Transfer Source Address Register\nThis field indicates a 32-bit source address of CRC DMA.\nNote: The source address must be word alignment</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CRC_DMABCR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CRC_DMABCR</displayName>
          <description>CRC DMA Transfer Byte Count Register</description>
          <addressOffset>0xC</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CRC_DMABCR</name>
              <description>CRC DMA Transfer Byte Count Register\nThis field indicates a 16-bit total transfer byte count number of CRC DMA\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CRC_DMACSAR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CRC_DMACSAR</displayName>
          <description>CRC DMA Current Source Address Register</description>
          <addressOffset>0x14</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CRC_DMACSAR</name>
              <description>CRC DMA Current Source Address Register (Read Only)\nThis field indicates the current source address where the CRC DMA transfer just occurs.\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CRC_DMACBCR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CRC_DMACBCR</displayName>
          <description>CRC DMA Current Transfer Byte Count Register</description>
          <addressOffset>0x1C</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CRC_DMACBCR</name>
              <description>CRC DMA Current Remained Byte Count Register (Read Only)\nThis field indicates the current remained byte count of CRC DMA.\nNote: Setting CRC_RST (CRC_CTL[1]) bit to 1 will clear this register value.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CRC_DMAIER</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CRC_DMAIER</displayName>
          <description>CRC DMA Interrupt Enable Register</description>
          <addressOffset>0x20</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000001</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CRC_TABORT_IE</name>
              <description>CRC DMA Read/Write Target Abort Interrupt Enable Bit\nEnable this bit will generate the CRC DMA Target Abort interrupt signal while CRC_TARBOT_IF (CRC_DMAISR[0]) bit is set to 1.\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Target abort interrupt generation Disabled during CRC DMA transfer</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Target abort interrupt generation Enabled during CRC DMA transfer</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CRC_BLKD_IE</name>
              <description>CRC DMA Block Transfer Done Interrupt Enable Bit\nEnable this bit will generate the CRC DMA Transfer Done interrupt signal while CRC_BLKD_IF (CRC_DMAISR[1]) bit is set to 1.\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Interrupt generator Disabled when CRC DMA transfer done</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Interrupt generator Enabled when CRC DMA transfer done</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CRC_DMAISR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CRC_DMAISR</displayName>
          <description>CRC DMA Interrupt Status Register</description>
          <addressOffset>0x24</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CRC_TABORT_IF</name>
              <description>CRC DMA Read/Write Target Abort Interrupt Flag\nThis bit indicates that CRC bus has error or not during CRC DMA transfer.\nIt is cleared by writing 1 to it through software.\nNote: The bit filed indicate bus master received error response or not. If bus master received error response, it means that CRC transfer target abort is happened. DMA will stop transfer and respond this event to software then CRC state machine goes to IDLE state. When target abort occurred, software must reset DMA before transfer those data again.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No bus error response received during CRC DMA transfer</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Bus error response received during CRC DMA transfer</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CRC_BLKD_IF</name>
              <description>CRC DMA Block Transfer Done Interrupt Flag\nThis bit indicates that CRC DMA transfer has finished or not.\nIt is cleared by writing 1 to it through software..\n(When CRC DMA transfer done, TRIG_EN (CRC_CTL[23]) bit will be cleared automatically)</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Not finished if TRIG_EN (CRC_CTL[23]) bit has enabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>CRC transfer done if TRIG_EN (CRC_CTL[23]) bit has enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CRC_WDATA</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CRC_WDATA</displayName>
          <description>CRC Write Data Register</description>
          <addressOffset>0x80</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CRC_WDATA</name>
              <description>CRC Write Data Register\nWhen operating in CPU PIO mode, software can write data to this field to perform CRC operation.\nWhen operating in DMA mode, this field indicates the DMA read data from memory and cannot be written.\nNote: When the write data length is 8-bit mode, the valid data in CRC_WDATA register is only CRC_WDATA [7:0] bits; if the write data length is 16-bit mode, the valid data in CRC_WDATA register is only CRC_WDATA [15:0].</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CRC_SEED</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CRC_SEED</displayName>
          <description>CRC Seed Register</description>
          <addressOffset>0x84</addressOffset>
          <access>read-write</access>
          <resetValue>0xFFFFFFFF</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CRC_SEED</name>
              <description>CRC Seed Register\nThis field indicates the CRC seed value.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CRC_CHECKSUM</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CRC_CHECKSUM</displayName>
          <description>CRC Checksum Register</description>
          <addressOffset>0x88</addressOffset>
          <access>read-only</access>
          <resetValue>0xFFFFFFFF</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CRC_CHECKSUM</name>
              <description>CRC Checksum Register\nThis fields indicates the CRC checksum result</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>PDMA_CH0</name>
      <description>PDMA Register Map</description>
      <groupName>PDMA</groupName>
      <baseAddress>0x50008000</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x0</offset>
        <size>0x28</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x80</offset>
        <size>0x4</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>PDMA_CSR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_CSR0</displayName>
          <description>PDMA Channel x Control Register</description>
          <addressOffset>0x0</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMACEN</name>
              <description>PDMA Channel Enable Bit\nSetting this bit to 1 enables PDMA operation. If this bit is cleared, PDMA will ignore all PDMA request and force Bus Master into IDLE state.\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_RST</name>
              <description>Software Engine Reset\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reset the internal state machine, pointers and internal buffer. The contents of control register will not be cleared. This bit will be automatically cleared after few clock cycles</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>MODE_SEL</name>
              <description>PDMA Mode Selection\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Memory to Memory mode (Memory-to-Memory)</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Peripheral to Memory mode (Peripheral-to-Memory)</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Memory to Peripheral mode (Memory-to-Peripheral)</description>
                    <value>#10</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SAD_SEL</name>
              <description>Transfer Source Address Direction Selection\n</description>
              <bitOffset>4</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Transfer source address is increasing successively</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reserved</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Transfer source address is fixed (This feature can be used when data where transferred from a single source to multiple destinations)</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Reserved</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DAD_SEL</name>
              <description>Transfer Destination Address Direction Selection\n</description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Transfer destination address is increasing successively</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reserved</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Transfer destination address is fixed. (This feature can be used when data where transferred from multiple sources to a single destination)</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Reserved</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>APB_TWS</name>
              <description>Peripheral Transfer Width Selection\nNote: This field is meaningful only when MODE_SEL (PDMA_CSRx[3:2]) is Peripheral to Memory mode (Peripheral-to-Memory) or Memory to Peripheral mode (Memory-to-Peripheral).</description>
              <bitOffset>19</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>One word (32-bit) is transferred for every PDMA operation</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>One byte (8-bit) is transferred for every PDMA operation</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>One half-word (16-bit) is transferred for every PDMA operation</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Reserved</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TRIG_EN</name>
              <description>Trigger Enable Bit\nNote: When PDMA transfer completed, this bit will be cleared automatically.\nIf the bus error occurs, all PDMA transfer will be stopped. Software must reset all PDMA channel, and then trigger again.</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PDMA data read or write transfer Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PDMA_CSR0">
          <name>PDMA_CSR1</name>
          <displayName>PDMA_CSR1</displayName>
          <description>PDMA Channel x Control Register</description>
          <alternateRegister>PDMA_CSR0</alternateRegister>
          <addressOffset>0x0</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSR0">
          <name>PDMA_CSR2</name>
          <displayName>PDMA_CSR2</displayName>
          <description>PDMA Channel x Control Register</description>
          <alternateRegister>PDMA_CSR0</alternateRegister>
          <addressOffset>0x0</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSR0">
          <name>PDMA_CSR3</name>
          <displayName>PDMA_CSR3</displayName>
          <description>PDMA Channel x Control Register</description>
          <alternateRegister>PDMA_CSR0</alternateRegister>
          <addressOffset>0x0</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSR0">
          <name>PDMA_CSR4</name>
          <displayName>PDMA_CSR4</displayName>
          <description>PDMA Channel x Control Register</description>
          <alternateRegister>PDMA_CSR0</alternateRegister>
          <addressOffset>0x0</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSR0">
          <name>PDMA_CSR5</name>
          <displayName>PDMA_CSR5</displayName>
          <description>PDMA Channel x Control Register</description>
          <alternateRegister>PDMA_CSR0</alternateRegister>
          <addressOffset>0x0</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSR0">
          <name>PDMA_CSR6</name>
          <displayName>PDMA_CSR6</displayName>
          <description>PDMA Channel x Control Register</description>
          <alternateRegister>PDMA_CSR0</alternateRegister>
          <addressOffset>0x0</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSR0">
          <name>PDMA_CSR7</name>
          <displayName>PDMA_CSR7</displayName>
          <description>PDMA Channel x Control Register</description>
          <alternateRegister>PDMA_CSR0</alternateRegister>
          <addressOffset>0x0</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSR0">
          <name>PDMA_CSR8</name>
          <displayName>PDMA_CSR8</displayName>
          <description>PDMA Channel x Control Register</description>
          <alternateRegister>PDMA_CSR0</alternateRegister>
          <addressOffset>0x0</addressOffset>
       </register>
       <register>
          <name>PDMA_SAR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_SAR0</displayName>
          <description>PDMA Channel x Source Address Register</description>
          <addressOffset>0x4</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_SAR</name>
              <description>PDMA Transfer Source Address Register\nThis field indicates a 32-bit source address of PDMA.\nNote: The source address must be word alignment.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PDMA_SAR0">
          <name>PDMA_SAR1</name>
          <displayName>PDMA_SAR1</displayName>
          <description>PDMA Channel x Source Address Register</description>
          <alternateRegister>PDMA_SAR0</alternateRegister>
          <addressOffset>0x4</addressOffset>
       </register>
       <register derivedFrom="PDMA_SAR0">
          <name>PDMA_SAR2</name>
          <displayName>PDMA_SAR2</displayName>
          <description>PDMA Channel x Source Address Register</description>
          <alternateRegister>PDMA_SAR0</alternateRegister>
          <addressOffset>0x4</addressOffset>
       </register>
       <register derivedFrom="PDMA_SAR0">
          <name>PDMA_SAR3</name>
          <displayName>PDMA_SAR3</displayName>
          <description>PDMA Channel x Source Address Register</description>
          <alternateRegister>PDMA_SAR0</alternateRegister>
          <addressOffset>0x4</addressOffset>
       </register>
       <register derivedFrom="PDMA_SAR0">
          <name>PDMA_SAR4</name>
          <displayName>PDMA_SAR4</displayName>
          <description>PDMA Channel x Source Address Register</description>
          <alternateRegister>PDMA_SAR0</alternateRegister>
          <addressOffset>0x4</addressOffset>
       </register>
       <register derivedFrom="PDMA_SAR0">
          <name>PDMA_SAR5</name>
          <displayName>PDMA_SAR5</displayName>
          <description>PDMA Channel x Source Address Register</description>
          <alternateRegister>PDMA_SAR0</alternateRegister>
          <addressOffset>0x4</addressOffset>
       </register>
       <register derivedFrom="PDMA_SAR0">
          <name>PDMA_SAR6</name>
          <displayName>PDMA_SAR6</displayName>
          <description>PDMA Channel x Source Address Register</description>
          <alternateRegister>PDMA_SAR0</alternateRegister>
          <addressOffset>0x4</addressOffset>
       </register>
       <register derivedFrom="PDMA_SAR0">
          <name>PDMA_SAR7</name>
          <displayName>PDMA_SAR7</displayName>
          <description>PDMA Channel x Source Address Register</description>
          <alternateRegister>PDMA_SAR0</alternateRegister>
          <addressOffset>0x4</addressOffset>
       </register>
       <register derivedFrom="PDMA_SAR0">
          <name>PDMA_SAR8</name>
          <displayName>PDMA_SAR8</displayName>
          <description>PDMA Channel x Source Address Register</description>
          <alternateRegister>PDMA_SAR0</alternateRegister>
          <addressOffset>0x4</addressOffset>
       </register>
       <register>
          <name>PDMA_DAR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_DAR0</displayName>
          <description>PDMA Channel x Destination Address Register</description>
          <addressOffset>0x8</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_DAR</name>
              <description>PDMA Transfer Destination Address Register\nThis field indicates a 32-bit destination address of PDMA.\nNote: The destination address must be word alignment</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PDMA_DAR0">
          <name>PDMA_DAR1</name>
          <displayName>PDMA_DAR1</displayName>
          <description>PDMA Channel x Destination Address Register</description>
          <alternateRegister>PDMA_DAR0</alternateRegister>
          <addressOffset>0x8</addressOffset>
       </register>
       <register derivedFrom="PDMA_DAR0">
          <name>PDMA_DAR2</name>
          <displayName>PDMA_DAR2</displayName>
          <description>PDMA Channel x Destination Address Register</description>
          <alternateRegister>PDMA_DAR0</alternateRegister>
          <addressOffset>0x8</addressOffset>
       </register>
       <register derivedFrom="PDMA_DAR0">
          <name>PDMA_DAR3</name>
          <displayName>PDMA_DAR3</displayName>
          <description>PDMA Channel x Destination Address Register</description>
          <alternateRegister>PDMA_DAR0</alternateRegister>
          <addressOffset>0x8</addressOffset>
       </register>
       <register derivedFrom="PDMA_DAR0">
          <name>PDMA_DAR4</name>
          <displayName>PDMA_DAR4</displayName>
          <description>PDMA Channel x Destination Address Register</description>
          <alternateRegister>PDMA_DAR0</alternateRegister>
          <addressOffset>0x8</addressOffset>
       </register>
       <register derivedFrom="PDMA_DAR0">
          <name>PDMA_DAR5</name>
          <displayName>PDMA_DAR5</displayName>
          <description>PDMA Channel x Destination Address Register</description>
          <alternateRegister>PDMA_DAR0</alternateRegister>
          <addressOffset>0x8</addressOffset>
       </register>
       <register derivedFrom="PDMA_DAR0">
          <name>PDMA_DAR6</name>
          <displayName>PDMA_DAR6</displayName>
          <description>PDMA Channel x Destination Address Register</description>
          <alternateRegister>PDMA_DAR0</alternateRegister>
          <addressOffset>0x8</addressOffset>
       </register>
       <register derivedFrom="PDMA_DAR0">
          <name>PDMA_DAR7</name>
          <displayName>PDMA_DAR7</displayName>
          <description>PDMA Channel x Destination Address Register</description>
          <alternateRegister>PDMA_DAR0</alternateRegister>
          <addressOffset>0x8</addressOffset>
       </register>
       <register derivedFrom="PDMA_DAR0">
          <name>PDMA_DAR8</name>
          <displayName>PDMA_DAR8</displayName>
          <description>PDMA Channel x Destination Address Register</description>
          <alternateRegister>PDMA_DAR0</alternateRegister>
          <addressOffset>0x8</addressOffset>
       </register>
       <register>
          <name>PDMA_BCR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_BCR0</displayName>
          <description>PDMA Channel x Transfer Byte Count Register</description>
          <addressOffset>0xC</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_BCR</name>
              <description>PDMA Transfer Byte Count Register\nThis field indicates a 16-bit transfer byte count number of PDMA; it must be word alignment.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PDMA_BCR0">
          <name>PDMA_BCR1</name>
          <displayName>PDMA_BCR1</displayName>
          <description>PDMA Channel x Transfer Byte Count Register</description>
          <alternateRegister>PDMA_BCR0</alternateRegister>
          <addressOffset>0xC</addressOffset>
       </register>
       <register derivedFrom="PDMA_BCR0">
          <name>PDMA_BCR2</name>
          <displayName>PDMA_BCR2</displayName>
          <description>PDMA Channel x Transfer Byte Count Register</description>
          <alternateRegister>PDMA_BCR0</alternateRegister>
          <addressOffset>0xC</addressOffset>
       </register>
       <register derivedFrom="PDMA_BCR0">
          <name>PDMA_BCR3</name>
          <displayName>PDMA_BCR3</displayName>
          <description>PDMA Channel x Transfer Byte Count Register</description>
          <alternateRegister>PDMA_BCR0</alternateRegister>
          <addressOffset>0xC</addressOffset>
       </register>
       <register derivedFrom="PDMA_BCR0">
          <name>PDMA_BCR4</name>
          <displayName>PDMA_BCR4</displayName>
          <description>PDMA Channel x Transfer Byte Count Register</description>
          <alternateRegister>PDMA_BCR0</alternateRegister>
          <addressOffset>0xC</addressOffset>
       </register>
       <register derivedFrom="PDMA_BCR0">
          <name>PDMA_BCR5</name>
          <displayName>PDMA_BCR5</displayName>
          <description>PDMA Channel x Transfer Byte Count Register</description>
          <alternateRegister>PDMA_BCR0</alternateRegister>
          <addressOffset>0xC</addressOffset>
       </register>
       <register derivedFrom="PDMA_BCR0">
          <name>PDMA_BCR6</name>
          <displayName>PDMA_BCR6</displayName>
          <description>PDMA Channel x Transfer Byte Count Register</description>
          <alternateRegister>PDMA_BCR0</alternateRegister>
          <addressOffset>0xC</addressOffset>
       </register>
       <register derivedFrom="PDMA_BCR0">
          <name>PDMA_BCR7</name>
          <displayName>PDMA_BCR7</displayName>
          <description>PDMA Channel x Transfer Byte Count Register</description>
          <alternateRegister>PDMA_BCR0</alternateRegister>
          <addressOffset>0xC</addressOffset>
       </register>
       <register derivedFrom="PDMA_BCR0">
          <name>PDMA_BCR8</name>
          <displayName>PDMA_BCR8</displayName>
          <description>PDMA Channel x Transfer Byte Count Register</description>
          <alternateRegister>PDMA_BCR0</alternateRegister>
          <addressOffset>0xC</addressOffset>
       </register>
       <register>
          <name>PDMA_POINT0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_POINT0</displayName>
          <description>PDMA Channel x Internal Buffer Pointer Register</description>
          <addressOffset>0x10</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_POINT</name>
              <description>PDMA Internal Buffer Pointer Register (Read Only)\nThis field indicates the internal buffer pointer.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PDMA_POINT0">
          <name>PDMA_POINT1</name>
          <displayName>PDMA_POINT1</displayName>
          <description>PDMA Channel x Internal Buffer Pointer Register</description>
          <alternateRegister>PDMA_POINT0</alternateRegister>
          <addressOffset>0x10</addressOffset>
       </register>
       <register derivedFrom="PDMA_POINT0">
          <name>PDMA_POINT2</name>
          <displayName>PDMA_POINT2</displayName>
          <description>PDMA Channel x Internal Buffer Pointer Register</description>
          <alternateRegister>PDMA_POINT0</alternateRegister>
          <addressOffset>0x10</addressOffset>
       </register>
       <register derivedFrom="PDMA_POINT0">
          <name>PDMA_POINT3</name>
          <displayName>PDMA_POINT3</displayName>
          <description>PDMA Channel x Internal Buffer Pointer Register</description>
          <alternateRegister>PDMA_POINT0</alternateRegister>
          <addressOffset>0x10</addressOffset>
       </register>
       <register derivedFrom="PDMA_POINT0">
          <name>PDMA_POINT4</name>
          <displayName>PDMA_POINT4</displayName>
          <description>PDMA Channel x Internal Buffer Pointer Register</description>
          <alternateRegister>PDMA_POINT0</alternateRegister>
          <addressOffset>0x10</addressOffset>
       </register>
       <register derivedFrom="PDMA_POINT0">
          <name>PDMA_POINT5</name>
          <displayName>PDMA_POINT5</displayName>
          <description>PDMA Channel x Internal Buffer Pointer Register</description>
          <alternateRegister>PDMA_POINT0</alternateRegister>
          <addressOffset>0x10</addressOffset>
       </register>
       <register derivedFrom="PDMA_POINT0">
          <name>PDMA_POINT6</name>
          <displayName>PDMA_POINT6</displayName>
          <description>PDMA Channel x Internal Buffer Pointer Register</description>
          <alternateRegister>PDMA_POINT0</alternateRegister>
          <addressOffset>0x10</addressOffset>
       </register>
       <register derivedFrom="PDMA_POINT0">
          <name>PDMA_POINT7</name>
          <displayName>PDMA_POINT7</displayName>
          <description>PDMA Channel x Internal Buffer Pointer Register</description>
          <alternateRegister>PDMA_POINT0</alternateRegister>
          <addressOffset>0x10</addressOffset>
       </register>
       <register derivedFrom="PDMA_POINT0">
          <name>PDMA_POINT8</name>
          <displayName>PDMA_POINT8</displayName>
          <description>PDMA Channel x Internal Buffer Pointer Register</description>
          <alternateRegister>PDMA_POINT0</alternateRegister>
          <addressOffset>0x10</addressOffset>
       </register>
       <register>
          <name>PDMA_CSAR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_CSAR0</displayName>
          <description>PDMA Channel x Current Source Address Register</description>
          <addressOffset>0x14</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_CSAR</name>
              <description>PDMA Current Source Address Register (Read Only)\nThis field indicates the source address where the PDMA transfer just occurred.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PDMA_CSAR0">
          <name>PDMA_CSAR1</name>
          <displayName>PDMA_CSAR1</displayName>
          <description>PDMA Channel x Current Source Address Register</description>
          <alternateRegister>PDMA_CSAR0</alternateRegister>
          <addressOffset>0x14</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSAR0">
          <name>PDMA_CSAR2</name>
          <displayName>PDMA_CSAR2</displayName>
          <description>PDMA Channel x Current Source Address Register</description>
          <alternateRegister>PDMA_CSAR0</alternateRegister>
          <addressOffset>0x14</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSAR0">
          <name>PDMA_CSAR3</name>
          <displayName>PDMA_CSAR3</displayName>
          <description>PDMA Channel x Current Source Address Register</description>
          <alternateRegister>PDMA_CSAR0</alternateRegister>
          <addressOffset>0x14</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSAR0">
          <name>PDMA_CSAR4</name>
          <displayName>PDMA_CSAR4</displayName>
          <description>PDMA Channel x Current Source Address Register</description>
          <alternateRegister>PDMA_CSAR0</alternateRegister>
          <addressOffset>0x14</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSAR0">
          <name>PDMA_CSAR5</name>
          <displayName>PDMA_CSAR5</displayName>
          <description>PDMA Channel x Current Source Address Register</description>
          <alternateRegister>PDMA_CSAR0</alternateRegister>
          <addressOffset>0x14</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSAR0">
          <name>PDMA_CSAR6</name>
          <displayName>PDMA_CSAR6</displayName>
          <description>PDMA Channel x Current Source Address Register</description>
          <alternateRegister>PDMA_CSAR0</alternateRegister>
          <addressOffset>0x14</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSAR0">
          <name>PDMA_CSAR7</name>
          <displayName>PDMA_CSAR7</displayName>
          <description>PDMA Channel x Current Source Address Register</description>
          <alternateRegister>PDMA_CSAR0</alternateRegister>
          <addressOffset>0x14</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSAR0">
          <name>PDMA_CSAR8</name>
          <displayName>PDMA_CSAR8</displayName>
          <description>PDMA Channel x Current Source Address Register</description>
          <alternateRegister>PDMA_CSAR0</alternateRegister>
          <addressOffset>0x14</addressOffset>
       </register>
       <register>
          <name>PDMA_CDAR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_CDAR0</displayName>
          <description>PDMA Channel x Current Destination Address Register</description>
          <addressOffset>0x18</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_CDAR</name>
              <description>PDMA Current Destination Address Register (Read Only)\nThis field indicates the destination address where the PDMA transfer just occurred.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PDMA_CDAR0">
          <name>PDMA_CDAR1</name>
          <displayName>PDMA_CDAR1</displayName>
          <description>PDMA Channel x Current Destination Address Register</description>
          <alternateRegister>PDMA_CDAR0</alternateRegister>
          <addressOffset>0x18</addressOffset>
       </register>
       <register derivedFrom="PDMA_CDAR0">
          <name>PDMA_CDAR2</name>
          <displayName>PDMA_CDAR2</displayName>
          <description>PDMA Channel x Current Destination Address Register</description>
          <alternateRegister>PDMA_CDAR0</alternateRegister>
          <addressOffset>0x18</addressOffset>
       </register>
       <register derivedFrom="PDMA_CDAR0">
          <name>PDMA_CDAR3</name>
          <displayName>PDMA_CDAR3</displayName>
          <description>PDMA Channel x Current Destination Address Register</description>
          <alternateRegister>PDMA_CDAR0</alternateRegister>
          <addressOffset>0x18</addressOffset>
       </register>
       <register derivedFrom="PDMA_CDAR0">
          <name>PDMA_CDAR4</name>
          <displayName>PDMA_CDAR4</displayName>
          <description>PDMA Channel x Current Destination Address Register</description>
          <alternateRegister>PDMA_CDAR0</alternateRegister>
          <addressOffset>0x18</addressOffset>
       </register>
       <register derivedFrom="PDMA_CDAR0">
          <name>PDMA_CDAR5</name>
          <displayName>PDMA_CDAR5</displayName>
          <description>PDMA Channel x Current Destination Address Register</description>
          <alternateRegister>PDMA_CDAR0</alternateRegister>
          <addressOffset>0x18</addressOffset>
       </register>
       <register derivedFrom="PDMA_CDAR0">
          <name>PDMA_CDAR6</name>
          <displayName>PDMA_CDAR6</displayName>
          <description>PDMA Channel x Current Destination Address Register</description>
          <alternateRegister>PDMA_CDAR0</alternateRegister>
          <addressOffset>0x18</addressOffset>
       </register>
       <register derivedFrom="PDMA_CDAR0">
          <name>PDMA_CDAR7</name>
          <displayName>PDMA_CDAR7</displayName>
          <description>PDMA Channel x Current Destination Address Register</description>
          <alternateRegister>PDMA_CDAR0</alternateRegister>
          <addressOffset>0x18</addressOffset>
       </register>
       <register derivedFrom="PDMA_CDAR0">
          <name>PDMA_CDAR8</name>
          <displayName>PDMA_CDAR8</displayName>
          <description>PDMA Channel x Current Destination Address Register</description>
          <alternateRegister>PDMA_CDAR0</alternateRegister>
          <addressOffset>0x18</addressOffset>
       </register>
       <register>
          <name>PDMA_CBCR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_CBCR0</displayName>
          <description>PDMA Channel x Current Transfer Byte Count Register</description>
          <addressOffset>0x1C</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_CBCR</name>
              <description>PDMA Current Byte Count Register (Read Only)\nThis field indicates the current remained byte count of PDMA.\nNote: This field value will be cleared to 0, when software set SW_RST (PDMA_CSRx[1]) to "1".</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PDMA_CBCR0">
          <name>PDMA_CBCR1</name>
          <displayName>PDMA_CBCR1</displayName>
          <description>PDMA Channel x Current Transfer Byte Count Register</description>
          <alternateRegister>PDMA_CBCR0</alternateRegister>
          <addressOffset>0x1C</addressOffset>
       </register>
       <register derivedFrom="PDMA_CBCR0">
          <name>PDMA_CBCR2</name>
          <displayName>PDMA_CBCR2</displayName>
          <description>PDMA Channel x Current Transfer Byte Count Register</description>
          <alternateRegister>PDMA_CBCR0</alternateRegister>
          <addressOffset>0x1C</addressOffset>
       </register>
       <register derivedFrom="PDMA_CBCR0">
          <name>PDMA_CBCR3</name>
          <displayName>PDMA_CBCR3</displayName>
          <description>PDMA Channel x Current Transfer Byte Count Register</description>
          <alternateRegister>PDMA_CBCR0</alternateRegister>
          <addressOffset>0x1C</addressOffset>
       </register>
       <register derivedFrom="PDMA_CBCR0">
          <name>PDMA_CBCR4</name>
          <displayName>PDMA_CBCR4</displayName>
          <description>PDMA Channel x Current Transfer Byte Count Register</description>
          <alternateRegister>PDMA_CBCR0</alternateRegister>
          <addressOffset>0x1C</addressOffset>
       </register>
       <register derivedFrom="PDMA_CBCR0">
          <name>PDMA_CBCR5</name>
          <displayName>PDMA_CBCR5</displayName>
          <description>PDMA Channel x Current Transfer Byte Count Register</description>
          <alternateRegister>PDMA_CBCR0</alternateRegister>
          <addressOffset>0x1C</addressOffset>
       </register>
       <register derivedFrom="PDMA_CBCR0">
          <name>PDMA_CBCR6</name>
          <displayName>PDMA_CBCR6</displayName>
          <description>PDMA Channel x Current Transfer Byte Count Register</description>
          <alternateRegister>PDMA_CBCR0</alternateRegister>
          <addressOffset>0x1C</addressOffset>
       </register>
       <register derivedFrom="PDMA_CBCR0">
          <name>PDMA_CBCR7</name>
          <displayName>PDMA_CBCR7</displayName>
          <description>PDMA Channel x Current Transfer Byte Count Register</description>
          <alternateRegister>PDMA_CBCR0</alternateRegister>
          <addressOffset>0x1C</addressOffset>
       </register>
       <register derivedFrom="PDMA_CBCR0">
          <name>PDMA_CBCR8</name>
          <displayName>PDMA_CBCR8</displayName>
          <description>PDMA Channel x Current Transfer Byte Count Register</description>
          <alternateRegister>PDMA_CBCR0</alternateRegister>
          <addressOffset>0x1C</addressOffset>
       </register>
       <register>
          <name>PDMA_IER0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_IER0</displayName>
          <description>PDMA Channel x Interrupt Enable Register</description>
          <addressOffset>0x20</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000001</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TABORT_IE</name>
              <description>PDMA Read/Write Target Abort Interrupt Enable Bit\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Target abort interrupt generation Disabled during PDMA transfer</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Target abort interrupt generation Enabled during PDMA transfer</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BLKD_IE</name>
              <description>PDMA Block Transfer Done Interrupt Enable Bit\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Interrupt generator Disabled when PDMA transfer is done</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Interrupt generator Enabled when PDMA transfer is done</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PDMA_IER0">
          <name>PDMA_IER1</name>
          <displayName>PDMA_IER1</displayName>
          <description>PDMA Channel x Interrupt Enable Register</description>
          <alternateRegister>PDMA_IER0</alternateRegister>
          <addressOffset>0x20</addressOffset>
       </register>
       <register derivedFrom="PDMA_IER0">
          <name>PDMA_IER2</name>
          <displayName>PDMA_IER2</displayName>
          <description>PDMA Channel x Interrupt Enable Register</description>
          <alternateRegister>PDMA_IER0</alternateRegister>
          <addressOffset>0x20</addressOffset>
       </register>
       <register derivedFrom="PDMA_IER0">
          <name>PDMA_IER3</name>
          <displayName>PDMA_IER3</displayName>
          <description>PDMA Channel x Interrupt Enable Register</description>
          <alternateRegister>PDMA_IER0</alternateRegister>
          <addressOffset>0x20</addressOffset>
       </register>
       <register derivedFrom="PDMA_IER0">
          <name>PDMA_IER4</name>
          <displayName>PDMA_IER4</displayName>
          <description>PDMA Channel x Interrupt Enable Register</description>
          <alternateRegister>PDMA_IER0</alternateRegister>
          <addressOffset>0x20</addressOffset>
       </register>
       <register derivedFrom="PDMA_IER0">
          <name>PDMA_IER5</name>
          <displayName>PDMA_IER5</displayName>
          <description>PDMA Channel x Interrupt Enable Register</description>
          <alternateRegister>PDMA_IER0</alternateRegister>
          <addressOffset>0x20</addressOffset>
       </register>
       <register derivedFrom="PDMA_IER0">
          <name>PDMA_IER6</name>
          <displayName>PDMA_IER6</displayName>
          <description>PDMA Channel x Interrupt Enable Register</description>
          <alternateRegister>PDMA_IER0</alternateRegister>
          <addressOffset>0x20</addressOffset>
       </register>
       <register derivedFrom="PDMA_IER0">
          <name>PDMA_IER7</name>
          <displayName>PDMA_IER7</displayName>
          <description>PDMA Channel x Interrupt Enable Register</description>
          <alternateRegister>PDMA_IER0</alternateRegister>
          <addressOffset>0x20</addressOffset>
       </register>
       <register derivedFrom="PDMA_IER0">
          <name>PDMA_IER8</name>
          <displayName>PDMA_IER8</displayName>
          <description>PDMA Channel x Interrupt Enable Register</description>
          <alternateRegister>PDMA_IER0</alternateRegister>
          <addressOffset>0x20</addressOffset>
       </register>
       <register>
          <name>PDMA_ISR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_ISR0</displayName>
          <description>PDMA Channel x Interrupt Status Register</description>
          <addressOffset>0x24</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TABORT_IF</name>
              <description>PDMA Read/Write Target Abort Interrupt Flag\nWrite 1 to clear this bit to 0.\nNote: This bit filed indicates bus master received ERROR response or not. If bus master received ERROR response, it means that target abort is happened. PDMA controller will stop transfer and respond this event to software then goes to IDLE state. When target abort occurred, software must reset PDMA, and then transfer those data again.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No bus ERROR response received</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Bus ERROR response received</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BLKD_IF</name>
              <description>PDMA Block Transfer Done Interrupt Flag\nThis bit indicates that PDMA has finished all transfers.\nWrite 1 to clear this bit to 0.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Not finished</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Done</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PDMA_ISR0">
          <name>PDMA_ISR1</name>
          <displayName>PDMA_ISR1</displayName>
          <description>PDMA Channel x Interrupt Status Register</description>
          <alternateRegister>PDMA_ISR0</alternateRegister>
          <addressOffset>0x24</addressOffset>
       </register>
       <register derivedFrom="PDMA_ISR0">
          <name>PDMA_ISR2</name>
          <displayName>PDMA_ISR2</displayName>
          <description>PDMA Channel x Interrupt Status Register</description>
          <alternateRegister>PDMA_ISR0</alternateRegister>
          <addressOffset>0x24</addressOffset>
       </register>
       <register derivedFrom="PDMA_ISR0">
          <name>PDMA_ISR3</name>
          <displayName>PDMA_ISR3</displayName>
          <description>PDMA Channel x Interrupt Status Register</description>
          <alternateRegister>PDMA_ISR0</alternateRegister>
          <addressOffset>0x24</addressOffset>
       </register>
       <register derivedFrom="PDMA_ISR0">
          <name>PDMA_ISR4</name>
          <displayName>PDMA_ISR4</displayName>
          <description>PDMA Channel x Interrupt Status Register</description>
          <alternateRegister>PDMA_ISR0</alternateRegister>
          <addressOffset>0x24</addressOffset>
       </register>
       <register derivedFrom="PDMA_ISR0">
          <name>PDMA_ISR5</name>
          <displayName>PDMA_ISR5</displayName>
          <description>PDMA Channel x Interrupt Status Register</description>
          <alternateRegister>PDMA_ISR0</alternateRegister>
          <addressOffset>0x24</addressOffset>
       </register>
       <register derivedFrom="PDMA_ISR0">
          <name>PDMA_ISR6</name>
          <displayName>PDMA_ISR6</displayName>
          <description>PDMA Channel x Interrupt Status Register</description>
          <alternateRegister>PDMA_ISR0</alternateRegister>
          <addressOffset>0x24</addressOffset>
       </register>
       <register derivedFrom="PDMA_ISR0">
          <name>PDMA_ISR7</name>
          <displayName>PDMA_ISR7</displayName>
          <description>PDMA Channel x Interrupt Status Register</description>
          <alternateRegister>PDMA_ISR0</alternateRegister>
          <addressOffset>0x24</addressOffset>
       </register>
       <register derivedFrom="PDMA_ISR0">
          <name>PDMA_ISR8</name>
          <displayName>PDMA_ISR8</displayName>
          <description>PDMA Channel x Interrupt Status Register</description>
          <alternateRegister>PDMA_ISR0</alternateRegister>
          <addressOffset>0x24</addressOffset>
       </register>
       <register>
          <name>PDMA_SBUF0_C0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_SBUF0_C0</displayName>
          <description>PDMA Channel x Shared Buffer FIFO 0 Register</description>
          <addressOffset>0x80</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_SBUF0</name>
              <description>PDMA Shared Buffer FIFO 0 (Read Only)\nEach channel has its own 1 word internal buffer.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PDMA_SBUF0_C0">
          <name>PDMA_SBUF0_C1</name>
          <displayName>PDMA_SBUF0_C1</displayName>
          <description>PDMA Channel x Shared Buffer FIFO 0 Register</description>
          <alternateRegister>PDMA_SBUF0_C0</alternateRegister>
          <addressOffset>0x80</addressOffset>
       </register>
       <register derivedFrom="PDMA_SBUF0_C0">
          <name>PDMA_SBUF0_C2</name>
          <displayName>PDMA_SBUF0_C2</displayName>
          <description>PDMA Channel x Shared Buffer FIFO 0 Register</description>
          <alternateRegister>PDMA_SBUF0_C0</alternateRegister>
          <addressOffset>0x80</addressOffset>
       </register>
       <register derivedFrom="PDMA_SBUF0_C0">
          <name>PDMA_SBUF0_C3</name>
          <displayName>PDMA_SBUF0_C3</displayName>
          <description>PDMA Channel x Shared Buffer FIFO 0 Register</description>
          <alternateRegister>PDMA_SBUF0_C0</alternateRegister>
          <addressOffset>0x80</addressOffset>
       </register>
       <register derivedFrom="PDMA_SBUF0_C0">
          <name>PDMA_SBUF0_C4</name>
          <displayName>PDMA_SBUF0_C4</displayName>
          <description>PDMA Channel x Shared Buffer FIFO 0 Register</description>
          <alternateRegister>PDMA_SBUF0_C0</alternateRegister>
          <addressOffset>0x80</addressOffset>
       </register>
       <register derivedFrom="PDMA_SBUF0_C0">
          <name>PDMA_SBUF0_C5</name>
          <displayName>PDMA_SBUF0_C5</displayName>
          <description>PDMA Channel x Shared Buffer FIFO 0 Register</description>
          <alternateRegister>PDMA_SBUF0_C0</alternateRegister>
          <addressOffset>0x80</addressOffset>
       </register>
       <register derivedFrom="PDMA_SBUF0_C0">
          <name>PDMA_SBUF0_C6</name>
          <displayName>PDMA_SBUF0_C6</displayName>
          <description>PDMA Channel x Shared Buffer FIFO 0 Register</description>
          <alternateRegister>PDMA_SBUF0_C0</alternateRegister>
          <addressOffset>0x80</addressOffset>
       </register>
       <register derivedFrom="PDMA_SBUF0_C0">
          <name>PDMA_SBUF0_C7</name>
          <displayName>PDMA_SBUF0_C7</displayName>
          <description>PDMA Channel x Shared Buffer FIFO 0 Register</description>
          <alternateRegister>PDMA_SBUF0_C0</alternateRegister>
          <addressOffset>0x80</addressOffset>
       </register>
       <register derivedFrom="PDMA_SBUF0_C0">
          <name>PDMA_SBUF0_C8</name>
          <displayName>PDMA_SBUF0_C8</displayName>
          <description>PDMA Channel x Shared Buffer FIFO 0 Register</description>
          <alternateRegister>PDMA_SBUF0_C0</alternateRegister>
          <addressOffset>0x80</addressOffset>
       </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>PDMA_CH1</name>
      <description>PDMA Register Map</description>
      <groupName>PDMA</groupName>
      <baseAddress>0x50008100</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x0</offset>
        <size>0x28</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x80</offset>
        <size>0x4</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>PDMA_CSR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_CSR0</displayName>
          <description>PDMA Channel x Control Register</description>
          <addressOffset>0x0</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMACEN</name>
              <description>PDMA Channel Enable Bit\nSetting this bit to 1 enables PDMA operation. If this bit is cleared, PDMA will ignore all PDMA request and force Bus Master into IDLE state.\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_RST</name>
              <description>Software Engine Reset\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reset the internal state machine, pointers and internal buffer. The contents of control register will not be cleared. This bit will be automatically cleared after few clock cycles</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>MODE_SEL</name>
              <description>PDMA Mode Selection\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Memory to Memory mode (Memory-to-Memory)</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Peripheral to Memory mode (Peripheral-to-Memory)</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Memory to Peripheral mode (Memory-to-Peripheral)</description>
                    <value>#10</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SAD_SEL</name>
              <description>Transfer Source Address Direction Selection\n</description>
              <bitOffset>4</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Transfer source address is increasing successively</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reserved</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Transfer source address is fixed (This feature can be used when data where transferred from a single source to multiple destinations)</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Reserved</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DAD_SEL</name>
              <description>Transfer Destination Address Direction Selection\n</description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Transfer destination address is increasing successively</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reserved</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Transfer destination address is fixed. (This feature can be used when data where transferred from multiple sources to a single destination)</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Reserved</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>APB_TWS</name>
              <description>Peripheral Transfer Width Selection\nNote: This field is meaningful only when MODE_SEL (PDMA_CSRx[3:2]) is Peripheral to Memory mode (Peripheral-to-Memory) or Memory to Peripheral mode (Memory-to-Peripheral).</description>
              <bitOffset>19</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>One word (32-bit) is transferred for every PDMA operation</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>One byte (8-bit) is transferred for every PDMA operation</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>One half-word (16-bit) is transferred for every PDMA operation</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Reserved</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TRIG_EN</name>
              <description>Trigger Enable Bit\nNote: When PDMA transfer completed, this bit will be cleared automatically.\nIf the bus error occurs, all PDMA transfer will be stopped. Software must reset all PDMA channel, and then trigger again.</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PDMA data read or write transfer Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PDMA_CSR0">
          <name>PDMA_CSR1</name>
          <displayName>PDMA_CSR1</displayName>
          <description>PDMA Channel x Control Register</description>
          <alternateRegister>PDMA_CSR0</alternateRegister>
          <addressOffset>0x0</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSR0">
          <name>PDMA_CSR2</name>
          <displayName>PDMA_CSR2</displayName>
          <description>PDMA Channel x Control Register</description>
          <alternateRegister>PDMA_CSR0</alternateRegister>
          <addressOffset>0x0</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSR0">
          <name>PDMA_CSR3</name>
          <displayName>PDMA_CSR3</displayName>
          <description>PDMA Channel x Control Register</description>
          <alternateRegister>PDMA_CSR0</alternateRegister>
          <addressOffset>0x0</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSR0">
          <name>PDMA_CSR4</name>
          <displayName>PDMA_CSR4</displayName>
          <description>PDMA Channel x Control Register</description>
          <alternateRegister>PDMA_CSR0</alternateRegister>
          <addressOffset>0x0</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSR0">
          <name>PDMA_CSR5</name>
          <displayName>PDMA_CSR5</displayName>
          <description>PDMA Channel x Control Register</description>
          <alternateRegister>PDMA_CSR0</alternateRegister>
          <addressOffset>0x0</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSR0">
          <name>PDMA_CSR6</name>
          <displayName>PDMA_CSR6</displayName>
          <description>PDMA Channel x Control Register</description>
          <alternateRegister>PDMA_CSR0</alternateRegister>
          <addressOffset>0x0</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSR0">
          <name>PDMA_CSR7</name>
          <displayName>PDMA_CSR7</displayName>
          <description>PDMA Channel x Control Register</description>
          <alternateRegister>PDMA_CSR0</alternateRegister>
          <addressOffset>0x0</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSR0">
          <name>PDMA_CSR8</name>
          <displayName>PDMA_CSR8</displayName>
          <description>PDMA Channel x Control Register</description>
          <alternateRegister>PDMA_CSR0</alternateRegister>
          <addressOffset>0x0</addressOffset>
       </register>
       <register>
          <name>PDMA_SAR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_SAR0</displayName>
          <description>PDMA Channel x Source Address Register</description>
          <addressOffset>0x4</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_SAR</name>
              <description>PDMA Transfer Source Address Register\nThis field indicates a 32-bit source address of PDMA.\nNote: The source address must be word alignment.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PDMA_SAR0">
          <name>PDMA_SAR1</name>
          <displayName>PDMA_SAR1</displayName>
          <description>PDMA Channel x Source Address Register</description>
          <alternateRegister>PDMA_SAR0</alternateRegister>
          <addressOffset>0x4</addressOffset>
       </register>
       <register derivedFrom="PDMA_SAR0">
          <name>PDMA_SAR2</name>
          <displayName>PDMA_SAR2</displayName>
          <description>PDMA Channel x Source Address Register</description>
          <alternateRegister>PDMA_SAR0</alternateRegister>
          <addressOffset>0x4</addressOffset>
       </register>
       <register derivedFrom="PDMA_SAR0">
          <name>PDMA_SAR3</name>
          <displayName>PDMA_SAR3</displayName>
          <description>PDMA Channel x Source Address Register</description>
          <alternateRegister>PDMA_SAR0</alternateRegister>
          <addressOffset>0x4</addressOffset>
       </register>
       <register derivedFrom="PDMA_SAR0">
          <name>PDMA_SAR4</name>
          <displayName>PDMA_SAR4</displayName>
          <description>PDMA Channel x Source Address Register</description>
          <alternateRegister>PDMA_SAR0</alternateRegister>
          <addressOffset>0x4</addressOffset>
       </register>
       <register derivedFrom="PDMA_SAR0">
          <name>PDMA_SAR5</name>
          <displayName>PDMA_SAR5</displayName>
          <description>PDMA Channel x Source Address Register</description>
          <alternateRegister>PDMA_SAR0</alternateRegister>
          <addressOffset>0x4</addressOffset>
       </register>
       <register derivedFrom="PDMA_SAR0">
          <name>PDMA_SAR6</name>
          <displayName>PDMA_SAR6</displayName>
          <description>PDMA Channel x Source Address Register</description>
          <alternateRegister>PDMA_SAR0</alternateRegister>
          <addressOffset>0x4</addressOffset>
       </register>
       <register derivedFrom="PDMA_SAR0">
          <name>PDMA_SAR7</name>
          <displayName>PDMA_SAR7</displayName>
          <description>PDMA Channel x Source Address Register</description>
          <alternateRegister>PDMA_SAR0</alternateRegister>
          <addressOffset>0x4</addressOffset>
       </register>
       <register derivedFrom="PDMA_SAR0">
          <name>PDMA_SAR8</name>
          <displayName>PDMA_SAR8</displayName>
          <description>PDMA Channel x Source Address Register</description>
          <alternateRegister>PDMA_SAR0</alternateRegister>
          <addressOffset>0x4</addressOffset>
       </register>
       <register>
          <name>PDMA_DAR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_DAR0</displayName>
          <description>PDMA Channel x Destination Address Register</description>
          <addressOffset>0x8</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_DAR</name>
              <description>PDMA Transfer Destination Address Register\nThis field indicates a 32-bit destination address of PDMA.\nNote: The destination address must be word alignment</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PDMA_DAR0">
          <name>PDMA_DAR1</name>
          <displayName>PDMA_DAR1</displayName>
          <description>PDMA Channel x Destination Address Register</description>
          <alternateRegister>PDMA_DAR0</alternateRegister>
          <addressOffset>0x8</addressOffset>
       </register>
       <register derivedFrom="PDMA_DAR0">
          <name>PDMA_DAR2</name>
          <displayName>PDMA_DAR2</displayName>
          <description>PDMA Channel x Destination Address Register</description>
          <alternateRegister>PDMA_DAR0</alternateRegister>
          <addressOffset>0x8</addressOffset>
       </register>
       <register derivedFrom="PDMA_DAR0">
          <name>PDMA_DAR3</name>
          <displayName>PDMA_DAR3</displayName>
          <description>PDMA Channel x Destination Address Register</description>
          <alternateRegister>PDMA_DAR0</alternateRegister>
          <addressOffset>0x8</addressOffset>
       </register>
       <register derivedFrom="PDMA_DAR0">
          <name>PDMA_DAR4</name>
          <displayName>PDMA_DAR4</displayName>
          <description>PDMA Channel x Destination Address Register</description>
          <alternateRegister>PDMA_DAR0</alternateRegister>
          <addressOffset>0x8</addressOffset>
       </register>
       <register derivedFrom="PDMA_DAR0">
          <name>PDMA_DAR5</name>
          <displayName>PDMA_DAR5</displayName>
          <description>PDMA Channel x Destination Address Register</description>
          <alternateRegister>PDMA_DAR0</alternateRegister>
          <addressOffset>0x8</addressOffset>
       </register>
       <register derivedFrom="PDMA_DAR0">
          <name>PDMA_DAR6</name>
          <displayName>PDMA_DAR6</displayName>
          <description>PDMA Channel x Destination Address Register</description>
          <alternateRegister>PDMA_DAR0</alternateRegister>
          <addressOffset>0x8</addressOffset>
       </register>
       <register derivedFrom="PDMA_DAR0">
          <name>PDMA_DAR7</name>
          <displayName>PDMA_DAR7</displayName>
          <description>PDMA Channel x Destination Address Register</description>
          <alternateRegister>PDMA_DAR0</alternateRegister>
          <addressOffset>0x8</addressOffset>
       </register>
       <register derivedFrom="PDMA_DAR0">
          <name>PDMA_DAR8</name>
          <displayName>PDMA_DAR8</displayName>
          <description>PDMA Channel x Destination Address Register</description>
          <alternateRegister>PDMA_DAR0</alternateRegister>
          <addressOffset>0x8</addressOffset>
       </register>
       <register>
          <name>PDMA_BCR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_BCR0</displayName>
          <description>PDMA Channel x Transfer Byte Count Register</description>
          <addressOffset>0xC</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_BCR</name>
              <description>PDMA Transfer Byte Count Register\nThis field indicates a 16-bit transfer byte count number of PDMA; it must be word alignment.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PDMA_BCR0">
          <name>PDMA_BCR1</name>
          <displayName>PDMA_BCR1</displayName>
          <description>PDMA Channel x Transfer Byte Count Register</description>
          <alternateRegister>PDMA_BCR0</alternateRegister>
          <addressOffset>0xC</addressOffset>
       </register>
       <register derivedFrom="PDMA_BCR0">
          <name>PDMA_BCR2</name>
          <displayName>PDMA_BCR2</displayName>
          <description>PDMA Channel x Transfer Byte Count Register</description>
          <alternateRegister>PDMA_BCR0</alternateRegister>
          <addressOffset>0xC</addressOffset>
       </register>
       <register derivedFrom="PDMA_BCR0">
          <name>PDMA_BCR3</name>
          <displayName>PDMA_BCR3</displayName>
          <description>PDMA Channel x Transfer Byte Count Register</description>
          <alternateRegister>PDMA_BCR0</alternateRegister>
          <addressOffset>0xC</addressOffset>
       </register>
       <register derivedFrom="PDMA_BCR0">
          <name>PDMA_BCR4</name>
          <displayName>PDMA_BCR4</displayName>
          <description>PDMA Channel x Transfer Byte Count Register</description>
          <alternateRegister>PDMA_BCR0</alternateRegister>
          <addressOffset>0xC</addressOffset>
       </register>
       <register derivedFrom="PDMA_BCR0">
          <name>PDMA_BCR5</name>
          <displayName>PDMA_BCR5</displayName>
          <description>PDMA Channel x Transfer Byte Count Register</description>
          <alternateRegister>PDMA_BCR0</alternateRegister>
          <addressOffset>0xC</addressOffset>
       </register>
       <register derivedFrom="PDMA_BCR0">
          <name>PDMA_BCR6</name>
          <displayName>PDMA_BCR6</displayName>
          <description>PDMA Channel x Transfer Byte Count Register</description>
          <alternateRegister>PDMA_BCR0</alternateRegister>
          <addressOffset>0xC</addressOffset>
       </register>
       <register derivedFrom="PDMA_BCR0">
          <name>PDMA_BCR7</name>
          <displayName>PDMA_BCR7</displayName>
          <description>PDMA Channel x Transfer Byte Count Register</description>
          <alternateRegister>PDMA_BCR0</alternateRegister>
          <addressOffset>0xC</addressOffset>
       </register>
       <register derivedFrom="PDMA_BCR0">
          <name>PDMA_BCR8</name>
          <displayName>PDMA_BCR8</displayName>
          <description>PDMA Channel x Transfer Byte Count Register</description>
          <alternateRegister>PDMA_BCR0</alternateRegister>
          <addressOffset>0xC</addressOffset>
       </register>
       <register>
          <name>PDMA_POINT0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_POINT0</displayName>
          <description>PDMA Channel x Internal Buffer Pointer Register</description>
          <addressOffset>0x10</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_POINT</name>
              <description>PDMA Internal Buffer Pointer Register (Read Only)\nThis field indicates the internal buffer pointer.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PDMA_POINT0">
          <name>PDMA_POINT1</name>
          <displayName>PDMA_POINT1</displayName>
          <description>PDMA Channel x Internal Buffer Pointer Register</description>
          <alternateRegister>PDMA_POINT0</alternateRegister>
          <addressOffset>0x10</addressOffset>
       </register>
       <register derivedFrom="PDMA_POINT0">
          <name>PDMA_POINT2</name>
          <displayName>PDMA_POINT2</displayName>
          <description>PDMA Channel x Internal Buffer Pointer Register</description>
          <alternateRegister>PDMA_POINT0</alternateRegister>
          <addressOffset>0x10</addressOffset>
       </register>
       <register derivedFrom="PDMA_POINT0">
          <name>PDMA_POINT3</name>
          <displayName>PDMA_POINT3</displayName>
          <description>PDMA Channel x Internal Buffer Pointer Register</description>
          <alternateRegister>PDMA_POINT0</alternateRegister>
          <addressOffset>0x10</addressOffset>
       </register>
       <register derivedFrom="PDMA_POINT0">
          <name>PDMA_POINT4</name>
          <displayName>PDMA_POINT4</displayName>
          <description>PDMA Channel x Internal Buffer Pointer Register</description>
          <alternateRegister>PDMA_POINT0</alternateRegister>
          <addressOffset>0x10</addressOffset>
       </register>
       <register derivedFrom="PDMA_POINT0">
          <name>PDMA_POINT5</name>
          <displayName>PDMA_POINT5</displayName>
          <description>PDMA Channel x Internal Buffer Pointer Register</description>
          <alternateRegister>PDMA_POINT0</alternateRegister>
          <addressOffset>0x10</addressOffset>
       </register>
       <register derivedFrom="PDMA_POINT0">
          <name>PDMA_POINT6</name>
          <displayName>PDMA_POINT6</displayName>
          <description>PDMA Channel x Internal Buffer Pointer Register</description>
          <alternateRegister>PDMA_POINT0</alternateRegister>
          <addressOffset>0x10</addressOffset>
       </register>
       <register derivedFrom="PDMA_POINT0">
          <name>PDMA_POINT7</name>
          <displayName>PDMA_POINT7</displayName>
          <description>PDMA Channel x Internal Buffer Pointer Register</description>
          <alternateRegister>PDMA_POINT0</alternateRegister>
          <addressOffset>0x10</addressOffset>
       </register>
       <register derivedFrom="PDMA_POINT0">
          <name>PDMA_POINT8</name>
          <displayName>PDMA_POINT8</displayName>
          <description>PDMA Channel x Internal Buffer Pointer Register</description>
          <alternateRegister>PDMA_POINT0</alternateRegister>
          <addressOffset>0x10</addressOffset>
       </register>
       <register>
          <name>PDMA_CSAR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_CSAR0</displayName>
          <description>PDMA Channel x Current Source Address Register</description>
          <addressOffset>0x14</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_CSAR</name>
              <description>PDMA Current Source Address Register (Read Only)\nThis field indicates the source address where the PDMA transfer just occurred.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PDMA_CSAR0">
          <name>PDMA_CSAR1</name>
          <displayName>PDMA_CSAR1</displayName>
          <description>PDMA Channel x Current Source Address Register</description>
          <alternateRegister>PDMA_CSAR0</alternateRegister>
          <addressOffset>0x14</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSAR0">
          <name>PDMA_CSAR2</name>
          <displayName>PDMA_CSAR2</displayName>
          <description>PDMA Channel x Current Source Address Register</description>
          <alternateRegister>PDMA_CSAR0</alternateRegister>
          <addressOffset>0x14</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSAR0">
          <name>PDMA_CSAR3</name>
          <displayName>PDMA_CSAR3</displayName>
          <description>PDMA Channel x Current Source Address Register</description>
          <alternateRegister>PDMA_CSAR0</alternateRegister>
          <addressOffset>0x14</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSAR0">
          <name>PDMA_CSAR4</name>
          <displayName>PDMA_CSAR4</displayName>
          <description>PDMA Channel x Current Source Address Register</description>
          <alternateRegister>PDMA_CSAR0</alternateRegister>
          <addressOffset>0x14</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSAR0">
          <name>PDMA_CSAR5</name>
          <displayName>PDMA_CSAR5</displayName>
          <description>PDMA Channel x Current Source Address Register</description>
          <alternateRegister>PDMA_CSAR0</alternateRegister>
          <addressOffset>0x14</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSAR0">
          <name>PDMA_CSAR6</name>
          <displayName>PDMA_CSAR6</displayName>
          <description>PDMA Channel x Current Source Address Register</description>
          <alternateRegister>PDMA_CSAR0</alternateRegister>
          <addressOffset>0x14</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSAR0">
          <name>PDMA_CSAR7</name>
          <displayName>PDMA_CSAR7</displayName>
          <description>PDMA Channel x Current Source Address Register</description>
          <alternateRegister>PDMA_CSAR0</alternateRegister>
          <addressOffset>0x14</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSAR0">
          <name>PDMA_CSAR8</name>
          <displayName>PDMA_CSAR8</displayName>
          <description>PDMA Channel x Current Source Address Register</description>
          <alternateRegister>PDMA_CSAR0</alternateRegister>
          <addressOffset>0x14</addressOffset>
       </register>
       <register>
          <name>PDMA_CDAR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_CDAR0</displayName>
          <description>PDMA Channel x Current Destination Address Register</description>
          <addressOffset>0x18</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_CDAR</name>
              <description>PDMA Current Destination Address Register (Read Only)\nThis field indicates the destination address where the PDMA transfer just occurred.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PDMA_CDAR0">
          <name>PDMA_CDAR1</name>
          <displayName>PDMA_CDAR1</displayName>
          <description>PDMA Channel x Current Destination Address Register</description>
          <alternateRegister>PDMA_CDAR0</alternateRegister>
          <addressOffset>0x18</addressOffset>
       </register>
       <register derivedFrom="PDMA_CDAR0">
          <name>PDMA_CDAR2</name>
          <displayName>PDMA_CDAR2</displayName>
          <description>PDMA Channel x Current Destination Address Register</description>
          <alternateRegister>PDMA_CDAR0</alternateRegister>
          <addressOffset>0x18</addressOffset>
       </register>
       <register derivedFrom="PDMA_CDAR0">
          <name>PDMA_CDAR3</name>
          <displayName>PDMA_CDAR3</displayName>
          <description>PDMA Channel x Current Destination Address Register</description>
          <alternateRegister>PDMA_CDAR0</alternateRegister>
          <addressOffset>0x18</addressOffset>
       </register>
       <register derivedFrom="PDMA_CDAR0">
          <name>PDMA_CDAR4</name>
          <displayName>PDMA_CDAR4</displayName>
          <description>PDMA Channel x Current Destination Address Register</description>
          <alternateRegister>PDMA_CDAR0</alternateRegister>
          <addressOffset>0x18</addressOffset>
       </register>
       <register derivedFrom="PDMA_CDAR0">
          <name>PDMA_CDAR5</name>
          <displayName>PDMA_CDAR5</displayName>
          <description>PDMA Channel x Current Destination Address Register</description>
          <alternateRegister>PDMA_CDAR0</alternateRegister>
          <addressOffset>0x18</addressOffset>
       </register>
       <register derivedFrom="PDMA_CDAR0">
          <name>PDMA_CDAR6</name>
          <displayName>PDMA_CDAR6</displayName>
          <description>PDMA Channel x Current Destination Address Register</description>
          <alternateRegister>PDMA_CDAR0</alternateRegister>
          <addressOffset>0x18</addressOffset>
       </register>
       <register derivedFrom="PDMA_CDAR0">
          <name>PDMA_CDAR7</name>
          <displayName>PDMA_CDAR7</displayName>
          <description>PDMA Channel x Current Destination Address Register</description>
          <alternateRegister>PDMA_CDAR0</alternateRegister>
          <addressOffset>0x18</addressOffset>
       </register>
       <register derivedFrom="PDMA_CDAR0">
          <name>PDMA_CDAR8</name>
          <displayName>PDMA_CDAR8</displayName>
          <description>PDMA Channel x Current Destination Address Register</description>
          <alternateRegister>PDMA_CDAR0</alternateRegister>
          <addressOffset>0x18</addressOffset>
       </register>
       <register>
          <name>PDMA_CBCR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_CBCR0</displayName>
          <description>PDMA Channel x Current Transfer Byte Count Register</description>
          <addressOffset>0x1C</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_CBCR</name>
              <description>PDMA Current Byte Count Register (Read Only)\nThis field indicates the current remained byte count of PDMA.\nNote: This field value will be cleared to 0, when software set SW_RST (PDMA_CSRx[1]) to "1".</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PDMA_CBCR0">
          <name>PDMA_CBCR1</name>
          <displayName>PDMA_CBCR1</displayName>
          <description>PDMA Channel x Current Transfer Byte Count Register</description>
          <alternateRegister>PDMA_CBCR0</alternateRegister>
          <addressOffset>0x1C</addressOffset>
       </register>
       <register derivedFrom="PDMA_CBCR0">
          <name>PDMA_CBCR2</name>
          <displayName>PDMA_CBCR2</displayName>
          <description>PDMA Channel x Current Transfer Byte Count Register</description>
          <alternateRegister>PDMA_CBCR0</alternateRegister>
          <addressOffset>0x1C</addressOffset>
       </register>
       <register derivedFrom="PDMA_CBCR0">
          <name>PDMA_CBCR3</name>
          <displayName>PDMA_CBCR3</displayName>
          <description>PDMA Channel x Current Transfer Byte Count Register</description>
          <alternateRegister>PDMA_CBCR0</alternateRegister>
          <addressOffset>0x1C</addressOffset>
       </register>
       <register derivedFrom="PDMA_CBCR0">
          <name>PDMA_CBCR4</name>
          <displayName>PDMA_CBCR4</displayName>
          <description>PDMA Channel x Current Transfer Byte Count Register</description>
          <alternateRegister>PDMA_CBCR0</alternateRegister>
          <addressOffset>0x1C</addressOffset>
       </register>
       <register derivedFrom="PDMA_CBCR0">
          <name>PDMA_CBCR5</name>
          <displayName>PDMA_CBCR5</displayName>
          <description>PDMA Channel x Current Transfer Byte Count Register</description>
          <alternateRegister>PDMA_CBCR0</alternateRegister>
          <addressOffset>0x1C</addressOffset>
       </register>
       <register derivedFrom="PDMA_CBCR0">
          <name>PDMA_CBCR6</name>
          <displayName>PDMA_CBCR6</displayName>
          <description>PDMA Channel x Current Transfer Byte Count Register</description>
          <alternateRegister>PDMA_CBCR0</alternateRegister>
          <addressOffset>0x1C</addressOffset>
       </register>
       <register derivedFrom="PDMA_CBCR0">
          <name>PDMA_CBCR7</name>
          <displayName>PDMA_CBCR7</displayName>
          <description>PDMA Channel x Current Transfer Byte Count Register</description>
          <alternateRegister>PDMA_CBCR0</alternateRegister>
          <addressOffset>0x1C</addressOffset>
       </register>
       <register derivedFrom="PDMA_CBCR0">
          <name>PDMA_CBCR8</name>
          <displayName>PDMA_CBCR8</displayName>
          <description>PDMA Channel x Current Transfer Byte Count Register</description>
          <alternateRegister>PDMA_CBCR0</alternateRegister>
          <addressOffset>0x1C</addressOffset>
       </register>
       <register>
          <name>PDMA_IER0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_IER0</displayName>
          <description>PDMA Channel x Interrupt Enable Register</description>
          <addressOffset>0x20</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000001</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TABORT_IE</name>
              <description>PDMA Read/Write Target Abort Interrupt Enable Bit\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Target abort interrupt generation Disabled during PDMA transfer</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Target abort interrupt generation Enabled during PDMA transfer</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BLKD_IE</name>
              <description>PDMA Block Transfer Done Interrupt Enable Bit\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Interrupt generator Disabled when PDMA transfer is done</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Interrupt generator Enabled when PDMA transfer is done</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PDMA_IER0">
          <name>PDMA_IER1</name>
          <displayName>PDMA_IER1</displayName>
          <description>PDMA Channel x Interrupt Enable Register</description>
          <alternateRegister>PDMA_IER0</alternateRegister>
          <addressOffset>0x20</addressOffset>
       </register>
       <register derivedFrom="PDMA_IER0">
          <name>PDMA_IER2</name>
          <displayName>PDMA_IER2</displayName>
          <description>PDMA Channel x Interrupt Enable Register</description>
          <alternateRegister>PDMA_IER0</alternateRegister>
          <addressOffset>0x20</addressOffset>
       </register>
       <register derivedFrom="PDMA_IER0">
          <name>PDMA_IER3</name>
          <displayName>PDMA_IER3</displayName>
          <description>PDMA Channel x Interrupt Enable Register</description>
          <alternateRegister>PDMA_IER0</alternateRegister>
          <addressOffset>0x20</addressOffset>
       </register>
       <register derivedFrom="PDMA_IER0">
          <name>PDMA_IER4</name>
          <displayName>PDMA_IER4</displayName>
          <description>PDMA Channel x Interrupt Enable Register</description>
          <alternateRegister>PDMA_IER0</alternateRegister>
          <addressOffset>0x20</addressOffset>
       </register>
       <register derivedFrom="PDMA_IER0">
          <name>PDMA_IER5</name>
          <displayName>PDMA_IER5</displayName>
          <description>PDMA Channel x Interrupt Enable Register</description>
          <alternateRegister>PDMA_IER0</alternateRegister>
          <addressOffset>0x20</addressOffset>
       </register>
       <register derivedFrom="PDMA_IER0">
          <name>PDMA_IER6</name>
          <displayName>PDMA_IER6</displayName>
          <description>PDMA Channel x Interrupt Enable Register</description>
          <alternateRegister>PDMA_IER0</alternateRegister>
          <addressOffset>0x20</addressOffset>
       </register>
       <register derivedFrom="PDMA_IER0">
          <name>PDMA_IER7</name>
          <displayName>PDMA_IER7</displayName>
          <description>PDMA Channel x Interrupt Enable Register</description>
          <alternateRegister>PDMA_IER0</alternateRegister>
          <addressOffset>0x20</addressOffset>
       </register>
       <register derivedFrom="PDMA_IER0">
          <name>PDMA_IER8</name>
          <displayName>PDMA_IER8</displayName>
          <description>PDMA Channel x Interrupt Enable Register</description>
          <alternateRegister>PDMA_IER0</alternateRegister>
          <addressOffset>0x20</addressOffset>
       </register>
       <register>
          <name>PDMA_ISR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_ISR0</displayName>
          <description>PDMA Channel x Interrupt Status Register</description>
          <addressOffset>0x24</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TABORT_IF</name>
              <description>PDMA Read/Write Target Abort Interrupt Flag\nWrite 1 to clear this bit to 0.\nNote: This bit filed indicates bus master received ERROR response or not. If bus master received ERROR response, it means that target abort is happened. PDMA controller will stop transfer and respond this event to software then goes to IDLE state. When target abort occurred, software must reset PDMA, and then transfer those data again.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No bus ERROR response received</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Bus ERROR response received</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BLKD_IF</name>
              <description>PDMA Block Transfer Done Interrupt Flag\nThis bit indicates that PDMA has finished all transfers.\nWrite 1 to clear this bit to 0.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Not finished</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Done</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PDMA_ISR0">
          <name>PDMA_ISR1</name>
          <displayName>PDMA_ISR1</displayName>
          <description>PDMA Channel x Interrupt Status Register</description>
          <alternateRegister>PDMA_ISR0</alternateRegister>
          <addressOffset>0x24</addressOffset>
       </register>
       <register derivedFrom="PDMA_ISR0">
          <name>PDMA_ISR2</name>
          <displayName>PDMA_ISR2</displayName>
          <description>PDMA Channel x Interrupt Status Register</description>
          <alternateRegister>PDMA_ISR0</alternateRegister>
          <addressOffset>0x24</addressOffset>
       </register>
       <register derivedFrom="PDMA_ISR0">
          <name>PDMA_ISR3</name>
          <displayName>PDMA_ISR3</displayName>
          <description>PDMA Channel x Interrupt Status Register</description>
          <alternateRegister>PDMA_ISR0</alternateRegister>
          <addressOffset>0x24</addressOffset>
       </register>
       <register derivedFrom="PDMA_ISR0">
          <name>PDMA_ISR4</name>
          <displayName>PDMA_ISR4</displayName>
          <description>PDMA Channel x Interrupt Status Register</description>
          <alternateRegister>PDMA_ISR0</alternateRegister>
          <addressOffset>0x24</addressOffset>
       </register>
       <register derivedFrom="PDMA_ISR0">
          <name>PDMA_ISR5</name>
          <displayName>PDMA_ISR5</displayName>
          <description>PDMA Channel x Interrupt Status Register</description>
          <alternateRegister>PDMA_ISR0</alternateRegister>
          <addressOffset>0x24</addressOffset>
       </register>
       <register derivedFrom="PDMA_ISR0">
          <name>PDMA_ISR6</name>
          <displayName>PDMA_ISR6</displayName>
          <description>PDMA Channel x Interrupt Status Register</description>
          <alternateRegister>PDMA_ISR0</alternateRegister>
          <addressOffset>0x24</addressOffset>
       </register>
       <register derivedFrom="PDMA_ISR0">
          <name>PDMA_ISR7</name>
          <displayName>PDMA_ISR7</displayName>
          <description>PDMA Channel x Interrupt Status Register</description>
          <alternateRegister>PDMA_ISR0</alternateRegister>
          <addressOffset>0x24</addressOffset>
       </register>
       <register derivedFrom="PDMA_ISR0">
          <name>PDMA_ISR8</name>
          <displayName>PDMA_ISR8</displayName>
          <description>PDMA Channel x Interrupt Status Register</description>
          <alternateRegister>PDMA_ISR0</alternateRegister>
          <addressOffset>0x24</addressOffset>
       </register>
       <register>
          <name>PDMA_SBUF0_C0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_SBUF0_C0</displayName>
          <description>PDMA Channel x Shared Buffer FIFO 0 Register</description>
          <addressOffset>0x80</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_SBUF0</name>
              <description>PDMA Shared Buffer FIFO 0 (Read Only)\nEach channel has its own 1 word internal buffer.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PDMA_SBUF0_C0">
          <name>PDMA_SBUF0_C1</name>
          <displayName>PDMA_SBUF0_C1</displayName>
          <description>PDMA Channel x Shared Buffer FIFO 0 Register</description>
          <alternateRegister>PDMA_SBUF0_C0</alternateRegister>
          <addressOffset>0x80</addressOffset>
       </register>
       <register derivedFrom="PDMA_SBUF0_C0">
          <name>PDMA_SBUF0_C2</name>
          <displayName>PDMA_SBUF0_C2</displayName>
          <description>PDMA Channel x Shared Buffer FIFO 0 Register</description>
          <alternateRegister>PDMA_SBUF0_C0</alternateRegister>
          <addressOffset>0x80</addressOffset>
       </register>
       <register derivedFrom="PDMA_SBUF0_C0">
          <name>PDMA_SBUF0_C3</name>
          <displayName>PDMA_SBUF0_C3</displayName>
          <description>PDMA Channel x Shared Buffer FIFO 0 Register</description>
          <alternateRegister>PDMA_SBUF0_C0</alternateRegister>
          <addressOffset>0x80</addressOffset>
       </register>
       <register derivedFrom="PDMA_SBUF0_C0">
          <name>PDMA_SBUF0_C4</name>
          <displayName>PDMA_SBUF0_C4</displayName>
          <description>PDMA Channel x Shared Buffer FIFO 0 Register</description>
          <alternateRegister>PDMA_SBUF0_C0</alternateRegister>
          <addressOffset>0x80</addressOffset>
       </register>
       <register derivedFrom="PDMA_SBUF0_C0">
          <name>PDMA_SBUF0_C5</name>
          <displayName>PDMA_SBUF0_C5</displayName>
          <description>PDMA Channel x Shared Buffer FIFO 0 Register</description>
          <alternateRegister>PDMA_SBUF0_C0</alternateRegister>
          <addressOffset>0x80</addressOffset>
       </register>
       <register derivedFrom="PDMA_SBUF0_C0">
          <name>PDMA_SBUF0_C6</name>
          <displayName>PDMA_SBUF0_C6</displayName>
          <description>PDMA Channel x Shared Buffer FIFO 0 Register</description>
          <alternateRegister>PDMA_SBUF0_C0</alternateRegister>
          <addressOffset>0x80</addressOffset>
       </register>
       <register derivedFrom="PDMA_SBUF0_C0">
          <name>PDMA_SBUF0_C7</name>
          <displayName>PDMA_SBUF0_C7</displayName>
          <description>PDMA Channel x Shared Buffer FIFO 0 Register</description>
          <alternateRegister>PDMA_SBUF0_C0</alternateRegister>
          <addressOffset>0x80</addressOffset>
       </register>
       <register derivedFrom="PDMA_SBUF0_C0">
          <name>PDMA_SBUF0_C8</name>
          <displayName>PDMA_SBUF0_C8</displayName>
          <description>PDMA Channel x Shared Buffer FIFO 0 Register</description>
          <alternateRegister>PDMA_SBUF0_C0</alternateRegister>
          <addressOffset>0x80</addressOffset>
       </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>PDMA_CH2</name>
      <description>PDMA Register Map</description>
      <groupName>PDMA</groupName>
      <baseAddress>0x50008200</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x0</offset>
        <size>0x28</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x80</offset>
        <size>0x4</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>PDMA_CSR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_CSR0</displayName>
          <description>PDMA Channel x Control Register</description>
          <addressOffset>0x0</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMACEN</name>
              <description>PDMA Channel Enable Bit\nSetting this bit to 1 enables PDMA operation. If this bit is cleared, PDMA will ignore all PDMA request and force Bus Master into IDLE state.\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_RST</name>
              <description>Software Engine Reset\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reset the internal state machine, pointers and internal buffer. The contents of control register will not be cleared. This bit will be automatically cleared after few clock cycles</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>MODE_SEL</name>
              <description>PDMA Mode Selection\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Memory to Memory mode (Memory-to-Memory)</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Peripheral to Memory mode (Peripheral-to-Memory)</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Memory to Peripheral mode (Memory-to-Peripheral)</description>
                    <value>#10</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SAD_SEL</name>
              <description>Transfer Source Address Direction Selection\n</description>
              <bitOffset>4</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Transfer source address is increasing successively</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reserved</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Transfer source address is fixed (This feature can be used when data where transferred from a single source to multiple destinations)</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Reserved</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DAD_SEL</name>
              <description>Transfer Destination Address Direction Selection\n</description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Transfer destination address is increasing successively</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reserved</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Transfer destination address is fixed. (This feature can be used when data where transferred from multiple sources to a single destination)</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Reserved</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>APB_TWS</name>
              <description>Peripheral Transfer Width Selection\nNote: This field is meaningful only when MODE_SEL (PDMA_CSRx[3:2]) is Peripheral to Memory mode (Peripheral-to-Memory) or Memory to Peripheral mode (Memory-to-Peripheral).</description>
              <bitOffset>19</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>One word (32-bit) is transferred for every PDMA operation</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>One byte (8-bit) is transferred for every PDMA operation</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>One half-word (16-bit) is transferred for every PDMA operation</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Reserved</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TRIG_EN</name>
              <description>Trigger Enable Bit\nNote: When PDMA transfer completed, this bit will be cleared automatically.\nIf the bus error occurs, all PDMA transfer will be stopped. Software must reset all PDMA channel, and then trigger again.</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PDMA data read or write transfer Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PDMA_CSR0">
          <name>PDMA_CSR1</name>
          <displayName>PDMA_CSR1</displayName>
          <description>PDMA Channel x Control Register</description>
          <alternateRegister>PDMA_CSR0</alternateRegister>
          <addressOffset>0x0</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSR0">
          <name>PDMA_CSR2</name>
          <displayName>PDMA_CSR2</displayName>
          <description>PDMA Channel x Control Register</description>
          <alternateRegister>PDMA_CSR0</alternateRegister>
          <addressOffset>0x0</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSR0">
          <name>PDMA_CSR3</name>
          <displayName>PDMA_CSR3</displayName>
          <description>PDMA Channel x Control Register</description>
          <alternateRegister>PDMA_CSR0</alternateRegister>
          <addressOffset>0x0</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSR0">
          <name>PDMA_CSR4</name>
          <displayName>PDMA_CSR4</displayName>
          <description>PDMA Channel x Control Register</description>
          <alternateRegister>PDMA_CSR0</alternateRegister>
          <addressOffset>0x0</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSR0">
          <name>PDMA_CSR5</name>
          <displayName>PDMA_CSR5</displayName>
          <description>PDMA Channel x Control Register</description>
          <alternateRegister>PDMA_CSR0</alternateRegister>
          <addressOffset>0x0</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSR0">
          <name>PDMA_CSR6</name>
          <displayName>PDMA_CSR6</displayName>
          <description>PDMA Channel x Control Register</description>
          <alternateRegister>PDMA_CSR0</alternateRegister>
          <addressOffset>0x0</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSR0">
          <name>PDMA_CSR7</name>
          <displayName>PDMA_CSR7</displayName>
          <description>PDMA Channel x Control Register</description>
          <alternateRegister>PDMA_CSR0</alternateRegister>
          <addressOffset>0x0</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSR0">
          <name>PDMA_CSR8</name>
          <displayName>PDMA_CSR8</displayName>
          <description>PDMA Channel x Control Register</description>
          <alternateRegister>PDMA_CSR0</alternateRegister>
          <addressOffset>0x0</addressOffset>
       </register>
       <register>
          <name>PDMA_SAR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_SAR0</displayName>
          <description>PDMA Channel x Source Address Register</description>
          <addressOffset>0x4</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_SAR</name>
              <description>PDMA Transfer Source Address Register\nThis field indicates a 32-bit source address of PDMA.\nNote: The source address must be word alignment.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PDMA_SAR0">
          <name>PDMA_SAR1</name>
          <displayName>PDMA_SAR1</displayName>
          <description>PDMA Channel x Source Address Register</description>
          <alternateRegister>PDMA_SAR0</alternateRegister>
          <addressOffset>0x4</addressOffset>
       </register>
       <register derivedFrom="PDMA_SAR0">
          <name>PDMA_SAR2</name>
          <displayName>PDMA_SAR2</displayName>
          <description>PDMA Channel x Source Address Register</description>
          <alternateRegister>PDMA_SAR0</alternateRegister>
          <addressOffset>0x4</addressOffset>
       </register>
       <register derivedFrom="PDMA_SAR0">
          <name>PDMA_SAR3</name>
          <displayName>PDMA_SAR3</displayName>
          <description>PDMA Channel x Source Address Register</description>
          <alternateRegister>PDMA_SAR0</alternateRegister>
          <addressOffset>0x4</addressOffset>
       </register>
       <register derivedFrom="PDMA_SAR0">
          <name>PDMA_SAR4</name>
          <displayName>PDMA_SAR4</displayName>
          <description>PDMA Channel x Source Address Register</description>
          <alternateRegister>PDMA_SAR0</alternateRegister>
          <addressOffset>0x4</addressOffset>
       </register>
       <register derivedFrom="PDMA_SAR0">
          <name>PDMA_SAR5</name>
          <displayName>PDMA_SAR5</displayName>
          <description>PDMA Channel x Source Address Register</description>
          <alternateRegister>PDMA_SAR0</alternateRegister>
          <addressOffset>0x4</addressOffset>
       </register>
       <register derivedFrom="PDMA_SAR0">
          <name>PDMA_SAR6</name>
          <displayName>PDMA_SAR6</displayName>
          <description>PDMA Channel x Source Address Register</description>
          <alternateRegister>PDMA_SAR0</alternateRegister>
          <addressOffset>0x4</addressOffset>
       </register>
       <register derivedFrom="PDMA_SAR0">
          <name>PDMA_SAR7</name>
          <displayName>PDMA_SAR7</displayName>
          <description>PDMA Channel x Source Address Register</description>
          <alternateRegister>PDMA_SAR0</alternateRegister>
          <addressOffset>0x4</addressOffset>
       </register>
       <register derivedFrom="PDMA_SAR0">
          <name>PDMA_SAR8</name>
          <displayName>PDMA_SAR8</displayName>
          <description>PDMA Channel x Source Address Register</description>
          <alternateRegister>PDMA_SAR0</alternateRegister>
          <addressOffset>0x4</addressOffset>
       </register>
       <register>
          <name>PDMA_DAR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_DAR0</displayName>
          <description>PDMA Channel x Destination Address Register</description>
          <addressOffset>0x8</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_DAR</name>
              <description>PDMA Transfer Destination Address Register\nThis field indicates a 32-bit destination address of PDMA.\nNote: The destination address must be word alignment</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PDMA_DAR0">
          <name>PDMA_DAR1</name>
          <displayName>PDMA_DAR1</displayName>
          <description>PDMA Channel x Destination Address Register</description>
          <alternateRegister>PDMA_DAR0</alternateRegister>
          <addressOffset>0x8</addressOffset>
       </register>
       <register derivedFrom="PDMA_DAR0">
          <name>PDMA_DAR2</name>
          <displayName>PDMA_DAR2</displayName>
          <description>PDMA Channel x Destination Address Register</description>
          <alternateRegister>PDMA_DAR0</alternateRegister>
          <addressOffset>0x8</addressOffset>
       </register>
       <register derivedFrom="PDMA_DAR0">
          <name>PDMA_DAR3</name>
          <displayName>PDMA_DAR3</displayName>
          <description>PDMA Channel x Destination Address Register</description>
          <alternateRegister>PDMA_DAR0</alternateRegister>
          <addressOffset>0x8</addressOffset>
       </register>
       <register derivedFrom="PDMA_DAR0">
          <name>PDMA_DAR4</name>
          <displayName>PDMA_DAR4</displayName>
          <description>PDMA Channel x Destination Address Register</description>
          <alternateRegister>PDMA_DAR0</alternateRegister>
          <addressOffset>0x8</addressOffset>
       </register>
       <register derivedFrom="PDMA_DAR0">
          <name>PDMA_DAR5</name>
          <displayName>PDMA_DAR5</displayName>
          <description>PDMA Channel x Destination Address Register</description>
          <alternateRegister>PDMA_DAR0</alternateRegister>
          <addressOffset>0x8</addressOffset>
       </register>
       <register derivedFrom="PDMA_DAR0">
          <name>PDMA_DAR6</name>
          <displayName>PDMA_DAR6</displayName>
          <description>PDMA Channel x Destination Address Register</description>
          <alternateRegister>PDMA_DAR0</alternateRegister>
          <addressOffset>0x8</addressOffset>
       </register>
       <register derivedFrom="PDMA_DAR0">
          <name>PDMA_DAR7</name>
          <displayName>PDMA_DAR7</displayName>
          <description>PDMA Channel x Destination Address Register</description>
          <alternateRegister>PDMA_DAR0</alternateRegister>
          <addressOffset>0x8</addressOffset>
       </register>
       <register derivedFrom="PDMA_DAR0">
          <name>PDMA_DAR8</name>
          <displayName>PDMA_DAR8</displayName>
          <description>PDMA Channel x Destination Address Register</description>
          <alternateRegister>PDMA_DAR0</alternateRegister>
          <addressOffset>0x8</addressOffset>
       </register>
       <register>
          <name>PDMA_BCR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_BCR0</displayName>
          <description>PDMA Channel x Transfer Byte Count Register</description>
          <addressOffset>0xC</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_BCR</name>
              <description>PDMA Transfer Byte Count Register\nThis field indicates a 16-bit transfer byte count number of PDMA; it must be word alignment.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PDMA_BCR0">
          <name>PDMA_BCR1</name>
          <displayName>PDMA_BCR1</displayName>
          <description>PDMA Channel x Transfer Byte Count Register</description>
          <alternateRegister>PDMA_BCR0</alternateRegister>
          <addressOffset>0xC</addressOffset>
       </register>
       <register derivedFrom="PDMA_BCR0">
          <name>PDMA_BCR2</name>
          <displayName>PDMA_BCR2</displayName>
          <description>PDMA Channel x Transfer Byte Count Register</description>
          <alternateRegister>PDMA_BCR0</alternateRegister>
          <addressOffset>0xC</addressOffset>
       </register>
       <register derivedFrom="PDMA_BCR0">
          <name>PDMA_BCR3</name>
          <displayName>PDMA_BCR3</displayName>
          <description>PDMA Channel x Transfer Byte Count Register</description>
          <alternateRegister>PDMA_BCR0</alternateRegister>
          <addressOffset>0xC</addressOffset>
       </register>
       <register derivedFrom="PDMA_BCR0">
          <name>PDMA_BCR4</name>
          <displayName>PDMA_BCR4</displayName>
          <description>PDMA Channel x Transfer Byte Count Register</description>
          <alternateRegister>PDMA_BCR0</alternateRegister>
          <addressOffset>0xC</addressOffset>
       </register>
       <register derivedFrom="PDMA_BCR0">
          <name>PDMA_BCR5</name>
          <displayName>PDMA_BCR5</displayName>
          <description>PDMA Channel x Transfer Byte Count Register</description>
          <alternateRegister>PDMA_BCR0</alternateRegister>
          <addressOffset>0xC</addressOffset>
       </register>
       <register derivedFrom="PDMA_BCR0">
          <name>PDMA_BCR6</name>
          <displayName>PDMA_BCR6</displayName>
          <description>PDMA Channel x Transfer Byte Count Register</description>
          <alternateRegister>PDMA_BCR0</alternateRegister>
          <addressOffset>0xC</addressOffset>
       </register>
       <register derivedFrom="PDMA_BCR0">
          <name>PDMA_BCR7</name>
          <displayName>PDMA_BCR7</displayName>
          <description>PDMA Channel x Transfer Byte Count Register</description>
          <alternateRegister>PDMA_BCR0</alternateRegister>
          <addressOffset>0xC</addressOffset>
       </register>
       <register derivedFrom="PDMA_BCR0">
          <name>PDMA_BCR8</name>
          <displayName>PDMA_BCR8</displayName>
          <description>PDMA Channel x Transfer Byte Count Register</description>
          <alternateRegister>PDMA_BCR0</alternateRegister>
          <addressOffset>0xC</addressOffset>
       </register>
       <register>
          <name>PDMA_POINT0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_POINT0</displayName>
          <description>PDMA Channel x Internal Buffer Pointer Register</description>
          <addressOffset>0x10</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_POINT</name>
              <description>PDMA Internal Buffer Pointer Register (Read Only)\nThis field indicates the internal buffer pointer.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PDMA_POINT0">
          <name>PDMA_POINT1</name>
          <displayName>PDMA_POINT1</displayName>
          <description>PDMA Channel x Internal Buffer Pointer Register</description>
          <alternateRegister>PDMA_POINT0</alternateRegister>
          <addressOffset>0x10</addressOffset>
       </register>
       <register derivedFrom="PDMA_POINT0">
          <name>PDMA_POINT2</name>
          <displayName>PDMA_POINT2</displayName>
          <description>PDMA Channel x Internal Buffer Pointer Register</description>
          <alternateRegister>PDMA_POINT0</alternateRegister>
          <addressOffset>0x10</addressOffset>
       </register>
       <register derivedFrom="PDMA_POINT0">
          <name>PDMA_POINT3</name>
          <displayName>PDMA_POINT3</displayName>
          <description>PDMA Channel x Internal Buffer Pointer Register</description>
          <alternateRegister>PDMA_POINT0</alternateRegister>
          <addressOffset>0x10</addressOffset>
       </register>
       <register derivedFrom="PDMA_POINT0">
          <name>PDMA_POINT4</name>
          <displayName>PDMA_POINT4</displayName>
          <description>PDMA Channel x Internal Buffer Pointer Register</description>
          <alternateRegister>PDMA_POINT0</alternateRegister>
          <addressOffset>0x10</addressOffset>
       </register>
       <register derivedFrom="PDMA_POINT0">
          <name>PDMA_POINT5</name>
          <displayName>PDMA_POINT5</displayName>
          <description>PDMA Channel x Internal Buffer Pointer Register</description>
          <alternateRegister>PDMA_POINT0</alternateRegister>
          <addressOffset>0x10</addressOffset>
       </register>
       <register derivedFrom="PDMA_POINT0">
          <name>PDMA_POINT6</name>
          <displayName>PDMA_POINT6</displayName>
          <description>PDMA Channel x Internal Buffer Pointer Register</description>
          <alternateRegister>PDMA_POINT0</alternateRegister>
          <addressOffset>0x10</addressOffset>
       </register>
       <register derivedFrom="PDMA_POINT0">
          <name>PDMA_POINT7</name>
          <displayName>PDMA_POINT7</displayName>
          <description>PDMA Channel x Internal Buffer Pointer Register</description>
          <alternateRegister>PDMA_POINT0</alternateRegister>
          <addressOffset>0x10</addressOffset>
       </register>
       <register derivedFrom="PDMA_POINT0">
          <name>PDMA_POINT8</name>
          <displayName>PDMA_POINT8</displayName>
          <description>PDMA Channel x Internal Buffer Pointer Register</description>
          <alternateRegister>PDMA_POINT0</alternateRegister>
          <addressOffset>0x10</addressOffset>
       </register>
       <register>
          <name>PDMA_CSAR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_CSAR0</displayName>
          <description>PDMA Channel x Current Source Address Register</description>
          <addressOffset>0x14</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_CSAR</name>
              <description>PDMA Current Source Address Register (Read Only)\nThis field indicates the source address where the PDMA transfer just occurred.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PDMA_CSAR0">
          <name>PDMA_CSAR1</name>
          <displayName>PDMA_CSAR1</displayName>
          <description>PDMA Channel x Current Source Address Register</description>
          <alternateRegister>PDMA_CSAR0</alternateRegister>
          <addressOffset>0x14</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSAR0">
          <name>PDMA_CSAR2</name>
          <displayName>PDMA_CSAR2</displayName>
          <description>PDMA Channel x Current Source Address Register</description>
          <alternateRegister>PDMA_CSAR0</alternateRegister>
          <addressOffset>0x14</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSAR0">
          <name>PDMA_CSAR3</name>
          <displayName>PDMA_CSAR3</displayName>
          <description>PDMA Channel x Current Source Address Register</description>
          <alternateRegister>PDMA_CSAR0</alternateRegister>
          <addressOffset>0x14</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSAR0">
          <name>PDMA_CSAR4</name>
          <displayName>PDMA_CSAR4</displayName>
          <description>PDMA Channel x Current Source Address Register</description>
          <alternateRegister>PDMA_CSAR0</alternateRegister>
          <addressOffset>0x14</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSAR0">
          <name>PDMA_CSAR5</name>
          <displayName>PDMA_CSAR5</displayName>
          <description>PDMA Channel x Current Source Address Register</description>
          <alternateRegister>PDMA_CSAR0</alternateRegister>
          <addressOffset>0x14</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSAR0">
          <name>PDMA_CSAR6</name>
          <displayName>PDMA_CSAR6</displayName>
          <description>PDMA Channel x Current Source Address Register</description>
          <alternateRegister>PDMA_CSAR0</alternateRegister>
          <addressOffset>0x14</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSAR0">
          <name>PDMA_CSAR7</name>
          <displayName>PDMA_CSAR7</displayName>
          <description>PDMA Channel x Current Source Address Register</description>
          <alternateRegister>PDMA_CSAR0</alternateRegister>
          <addressOffset>0x14</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSAR0">
          <name>PDMA_CSAR8</name>
          <displayName>PDMA_CSAR8</displayName>
          <description>PDMA Channel x Current Source Address Register</description>
          <alternateRegister>PDMA_CSAR0</alternateRegister>
          <addressOffset>0x14</addressOffset>
       </register>
       <register>
          <name>PDMA_CDAR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_CDAR0</displayName>
          <description>PDMA Channel x Current Destination Address Register</description>
          <addressOffset>0x18</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_CDAR</name>
              <description>PDMA Current Destination Address Register (Read Only)\nThis field indicates the destination address where the PDMA transfer just occurred.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PDMA_CDAR0">
          <name>PDMA_CDAR1</name>
          <displayName>PDMA_CDAR1</displayName>
          <description>PDMA Channel x Current Destination Address Register</description>
          <alternateRegister>PDMA_CDAR0</alternateRegister>
          <addressOffset>0x18</addressOffset>
       </register>
       <register derivedFrom="PDMA_CDAR0">
          <name>PDMA_CDAR2</name>
          <displayName>PDMA_CDAR2</displayName>
          <description>PDMA Channel x Current Destination Address Register</description>
          <alternateRegister>PDMA_CDAR0</alternateRegister>
          <addressOffset>0x18</addressOffset>
       </register>
       <register derivedFrom="PDMA_CDAR0">
          <name>PDMA_CDAR3</name>
          <displayName>PDMA_CDAR3</displayName>
          <description>PDMA Channel x Current Destination Address Register</description>
          <alternateRegister>PDMA_CDAR0</alternateRegister>
          <addressOffset>0x18</addressOffset>
       </register>
       <register derivedFrom="PDMA_CDAR0">
          <name>PDMA_CDAR4</name>
          <displayName>PDMA_CDAR4</displayName>
          <description>PDMA Channel x Current Destination Address Register</description>
          <alternateRegister>PDMA_CDAR0</alternateRegister>
          <addressOffset>0x18</addressOffset>
       </register>
       <register derivedFrom="PDMA_CDAR0">
          <name>PDMA_CDAR5</name>
          <displayName>PDMA_CDAR5</displayName>
          <description>PDMA Channel x Current Destination Address Register</description>
          <alternateRegister>PDMA_CDAR0</alternateRegister>
          <addressOffset>0x18</addressOffset>
       </register>
       <register derivedFrom="PDMA_CDAR0">
          <name>PDMA_CDAR6</name>
          <displayName>PDMA_CDAR6</displayName>
          <description>PDMA Channel x Current Destination Address Register</description>
          <alternateRegister>PDMA_CDAR0</alternateRegister>
          <addressOffset>0x18</addressOffset>
       </register>
       <register derivedFrom="PDMA_CDAR0">
          <name>PDMA_CDAR7</name>
          <displayName>PDMA_CDAR7</displayName>
          <description>PDMA Channel x Current Destination Address Register</description>
          <alternateRegister>PDMA_CDAR0</alternateRegister>
          <addressOffset>0x18</addressOffset>
       </register>
       <register derivedFrom="PDMA_CDAR0">
          <name>PDMA_CDAR8</name>
          <displayName>PDMA_CDAR8</displayName>
          <description>PDMA Channel x Current Destination Address Register</description>
          <alternateRegister>PDMA_CDAR0</alternateRegister>
          <addressOffset>0x18</addressOffset>
       </register>
       <register>
          <name>PDMA_CBCR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_CBCR0</displayName>
          <description>PDMA Channel x Current Transfer Byte Count Register</description>
          <addressOffset>0x1C</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_CBCR</name>
              <description>PDMA Current Byte Count Register (Read Only)\nThis field indicates the current remained byte count of PDMA.\nNote: This field value will be cleared to 0, when software set SW_RST (PDMA_CSRx[1]) to "1".</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PDMA_CBCR0">
          <name>PDMA_CBCR1</name>
          <displayName>PDMA_CBCR1</displayName>
          <description>PDMA Channel x Current Transfer Byte Count Register</description>
          <alternateRegister>PDMA_CBCR0</alternateRegister>
          <addressOffset>0x1C</addressOffset>
       </register>
       <register derivedFrom="PDMA_CBCR0">
          <name>PDMA_CBCR2</name>
          <displayName>PDMA_CBCR2</displayName>
          <description>PDMA Channel x Current Transfer Byte Count Register</description>
          <alternateRegister>PDMA_CBCR0</alternateRegister>
          <addressOffset>0x1C</addressOffset>
       </register>
       <register derivedFrom="PDMA_CBCR0">
          <name>PDMA_CBCR3</name>
          <displayName>PDMA_CBCR3</displayName>
          <description>PDMA Channel x Current Transfer Byte Count Register</description>
          <alternateRegister>PDMA_CBCR0</alternateRegister>
          <addressOffset>0x1C</addressOffset>
       </register>
       <register derivedFrom="PDMA_CBCR0">
          <name>PDMA_CBCR4</name>
          <displayName>PDMA_CBCR4</displayName>
          <description>PDMA Channel x Current Transfer Byte Count Register</description>
          <alternateRegister>PDMA_CBCR0</alternateRegister>
          <addressOffset>0x1C</addressOffset>
       </register>
       <register derivedFrom="PDMA_CBCR0">
          <name>PDMA_CBCR5</name>
          <displayName>PDMA_CBCR5</displayName>
          <description>PDMA Channel x Current Transfer Byte Count Register</description>
          <alternateRegister>PDMA_CBCR0</alternateRegister>
          <addressOffset>0x1C</addressOffset>
       </register>
       <register derivedFrom="PDMA_CBCR0">
          <name>PDMA_CBCR6</name>
          <displayName>PDMA_CBCR6</displayName>
          <description>PDMA Channel x Current Transfer Byte Count Register</description>
          <alternateRegister>PDMA_CBCR0</alternateRegister>
          <addressOffset>0x1C</addressOffset>
       </register>
       <register derivedFrom="PDMA_CBCR0">
          <name>PDMA_CBCR7</name>
          <displayName>PDMA_CBCR7</displayName>
          <description>PDMA Channel x Current Transfer Byte Count Register</description>
          <alternateRegister>PDMA_CBCR0</alternateRegister>
          <addressOffset>0x1C</addressOffset>
       </register>
       <register derivedFrom="PDMA_CBCR0">
          <name>PDMA_CBCR8</name>
          <displayName>PDMA_CBCR8</displayName>
          <description>PDMA Channel x Current Transfer Byte Count Register</description>
          <alternateRegister>PDMA_CBCR0</alternateRegister>
          <addressOffset>0x1C</addressOffset>
       </register>
       <register>
          <name>PDMA_IER0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_IER0</displayName>
          <description>PDMA Channel x Interrupt Enable Register</description>
          <addressOffset>0x20</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000001</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TABORT_IE</name>
              <description>PDMA Read/Write Target Abort Interrupt Enable Bit\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Target abort interrupt generation Disabled during PDMA transfer</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Target abort interrupt generation Enabled during PDMA transfer</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BLKD_IE</name>
              <description>PDMA Block Transfer Done Interrupt Enable Bit\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Interrupt generator Disabled when PDMA transfer is done</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Interrupt generator Enabled when PDMA transfer is done</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PDMA_IER0">
          <name>PDMA_IER1</name>
          <displayName>PDMA_IER1</displayName>
          <description>PDMA Channel x Interrupt Enable Register</description>
          <alternateRegister>PDMA_IER0</alternateRegister>
          <addressOffset>0x20</addressOffset>
       </register>
       <register derivedFrom="PDMA_IER0">
          <name>PDMA_IER2</name>
          <displayName>PDMA_IER2</displayName>
          <description>PDMA Channel x Interrupt Enable Register</description>
          <alternateRegister>PDMA_IER0</alternateRegister>
          <addressOffset>0x20</addressOffset>
       </register>
       <register derivedFrom="PDMA_IER0">
          <name>PDMA_IER3</name>
          <displayName>PDMA_IER3</displayName>
          <description>PDMA Channel x Interrupt Enable Register</description>
          <alternateRegister>PDMA_IER0</alternateRegister>
          <addressOffset>0x20</addressOffset>
       </register>
       <register derivedFrom="PDMA_IER0">
          <name>PDMA_IER4</name>
          <displayName>PDMA_IER4</displayName>
          <description>PDMA Channel x Interrupt Enable Register</description>
          <alternateRegister>PDMA_IER0</alternateRegister>
          <addressOffset>0x20</addressOffset>
       </register>
       <register derivedFrom="PDMA_IER0">
          <name>PDMA_IER5</name>
          <displayName>PDMA_IER5</displayName>
          <description>PDMA Channel x Interrupt Enable Register</description>
          <alternateRegister>PDMA_IER0</alternateRegister>
          <addressOffset>0x20</addressOffset>
       </register>
       <register derivedFrom="PDMA_IER0">
          <name>PDMA_IER6</name>
          <displayName>PDMA_IER6</displayName>
          <description>PDMA Channel x Interrupt Enable Register</description>
          <alternateRegister>PDMA_IER0</alternateRegister>
          <addressOffset>0x20</addressOffset>
       </register>
       <register derivedFrom="PDMA_IER0">
          <name>PDMA_IER7</name>
          <displayName>PDMA_IER7</displayName>
          <description>PDMA Channel x Interrupt Enable Register</description>
          <alternateRegister>PDMA_IER0</alternateRegister>
          <addressOffset>0x20</addressOffset>
       </register>
       <register derivedFrom="PDMA_IER0">
          <name>PDMA_IER8</name>
          <displayName>PDMA_IER8</displayName>
          <description>PDMA Channel x Interrupt Enable Register</description>
          <alternateRegister>PDMA_IER0</alternateRegister>
          <addressOffset>0x20</addressOffset>
       </register>
       <register>
          <name>PDMA_ISR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_ISR0</displayName>
          <description>PDMA Channel x Interrupt Status Register</description>
          <addressOffset>0x24</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TABORT_IF</name>
              <description>PDMA Read/Write Target Abort Interrupt Flag\nWrite 1 to clear this bit to 0.\nNote: This bit filed indicates bus master received ERROR response or not. If bus master received ERROR response, it means that target abort is happened. PDMA controller will stop transfer and respond this event to software then goes to IDLE state. When target abort occurred, software must reset PDMA, and then transfer those data again.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No bus ERROR response received</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Bus ERROR response received</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BLKD_IF</name>
              <description>PDMA Block Transfer Done Interrupt Flag\nThis bit indicates that PDMA has finished all transfers.\nWrite 1 to clear this bit to 0.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Not finished</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Done</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PDMA_ISR0">
          <name>PDMA_ISR1</name>
          <displayName>PDMA_ISR1</displayName>
          <description>PDMA Channel x Interrupt Status Register</description>
          <alternateRegister>PDMA_ISR0</alternateRegister>
          <addressOffset>0x24</addressOffset>
       </register>
       <register derivedFrom="PDMA_ISR0">
          <name>PDMA_ISR2</name>
          <displayName>PDMA_ISR2</displayName>
          <description>PDMA Channel x Interrupt Status Register</description>
          <alternateRegister>PDMA_ISR0</alternateRegister>
          <addressOffset>0x24</addressOffset>
       </register>
       <register derivedFrom="PDMA_ISR0">
          <name>PDMA_ISR3</name>
          <displayName>PDMA_ISR3</displayName>
          <description>PDMA Channel x Interrupt Status Register</description>
          <alternateRegister>PDMA_ISR0</alternateRegister>
          <addressOffset>0x24</addressOffset>
       </register>
       <register derivedFrom="PDMA_ISR0">
          <name>PDMA_ISR4</name>
          <displayName>PDMA_ISR4</displayName>
          <description>PDMA Channel x Interrupt Status Register</description>
          <alternateRegister>PDMA_ISR0</alternateRegister>
          <addressOffset>0x24</addressOffset>
       </register>
       <register derivedFrom="PDMA_ISR0">
          <name>PDMA_ISR5</name>
          <displayName>PDMA_ISR5</displayName>
          <description>PDMA Channel x Interrupt Status Register</description>
          <alternateRegister>PDMA_ISR0</alternateRegister>
          <addressOffset>0x24</addressOffset>
       </register>
       <register derivedFrom="PDMA_ISR0">
          <name>PDMA_ISR6</name>
          <displayName>PDMA_ISR6</displayName>
          <description>PDMA Channel x Interrupt Status Register</description>
          <alternateRegister>PDMA_ISR0</alternateRegister>
          <addressOffset>0x24</addressOffset>
       </register>
       <register derivedFrom="PDMA_ISR0">
          <name>PDMA_ISR7</name>
          <displayName>PDMA_ISR7</displayName>
          <description>PDMA Channel x Interrupt Status Register</description>
          <alternateRegister>PDMA_ISR0</alternateRegister>
          <addressOffset>0x24</addressOffset>
       </register>
       <register derivedFrom="PDMA_ISR0">
          <name>PDMA_ISR8</name>
          <displayName>PDMA_ISR8</displayName>
          <description>PDMA Channel x Interrupt Status Register</description>
          <alternateRegister>PDMA_ISR0</alternateRegister>
          <addressOffset>0x24</addressOffset>
       </register>
       <register>
          <name>PDMA_SBUF0_C0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_SBUF0_C0</displayName>
          <description>PDMA Channel x Shared Buffer FIFO 0 Register</description>
          <addressOffset>0x80</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_SBUF0</name>
              <description>PDMA Shared Buffer FIFO 0 (Read Only)\nEach channel has its own 1 word internal buffer.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PDMA_SBUF0_C0">
          <name>PDMA_SBUF0_C1</name>
          <displayName>PDMA_SBUF0_C1</displayName>
          <description>PDMA Channel x Shared Buffer FIFO 0 Register</description>
          <alternateRegister>PDMA_SBUF0_C0</alternateRegister>
          <addressOffset>0x80</addressOffset>
       </register>
       <register derivedFrom="PDMA_SBUF0_C0">
          <name>PDMA_SBUF0_C2</name>
          <displayName>PDMA_SBUF0_C2</displayName>
          <description>PDMA Channel x Shared Buffer FIFO 0 Register</description>
          <alternateRegister>PDMA_SBUF0_C0</alternateRegister>
          <addressOffset>0x80</addressOffset>
       </register>
       <register derivedFrom="PDMA_SBUF0_C0">
          <name>PDMA_SBUF0_C3</name>
          <displayName>PDMA_SBUF0_C3</displayName>
          <description>PDMA Channel x Shared Buffer FIFO 0 Register</description>
          <alternateRegister>PDMA_SBUF0_C0</alternateRegister>
          <addressOffset>0x80</addressOffset>
       </register>
       <register derivedFrom="PDMA_SBUF0_C0">
          <name>PDMA_SBUF0_C4</name>
          <displayName>PDMA_SBUF0_C4</displayName>
          <description>PDMA Channel x Shared Buffer FIFO 0 Register</description>
          <alternateRegister>PDMA_SBUF0_C0</alternateRegister>
          <addressOffset>0x80</addressOffset>
       </register>
       <register derivedFrom="PDMA_SBUF0_C0">
          <name>PDMA_SBUF0_C5</name>
          <displayName>PDMA_SBUF0_C5</displayName>
          <description>PDMA Channel x Shared Buffer FIFO 0 Register</description>
          <alternateRegister>PDMA_SBUF0_C0</alternateRegister>
          <addressOffset>0x80</addressOffset>
       </register>
       <register derivedFrom="PDMA_SBUF0_C0">
          <name>PDMA_SBUF0_C6</name>
          <displayName>PDMA_SBUF0_C6</displayName>
          <description>PDMA Channel x Shared Buffer FIFO 0 Register</description>
          <alternateRegister>PDMA_SBUF0_C0</alternateRegister>
          <addressOffset>0x80</addressOffset>
       </register>
       <register derivedFrom="PDMA_SBUF0_C0">
          <name>PDMA_SBUF0_C7</name>
          <displayName>PDMA_SBUF0_C7</displayName>
          <description>PDMA Channel x Shared Buffer FIFO 0 Register</description>
          <alternateRegister>PDMA_SBUF0_C0</alternateRegister>
          <addressOffset>0x80</addressOffset>
       </register>
       <register derivedFrom="PDMA_SBUF0_C0">
          <name>PDMA_SBUF0_C8</name>
          <displayName>PDMA_SBUF0_C8</displayName>
          <description>PDMA Channel x Shared Buffer FIFO 0 Register</description>
          <alternateRegister>PDMA_SBUF0_C0</alternateRegister>
          <addressOffset>0x80</addressOffset>
       </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>PDMA_CH3</name>
      <description>PDMA Register Map</description>
      <groupName>PDMA</groupName>
      <baseAddress>0x50008300</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x0</offset>
        <size>0x28</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x80</offset>
        <size>0x4</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>PDMA_CSR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_CSR0</displayName>
          <description>PDMA Channel x Control Register</description>
          <addressOffset>0x0</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMACEN</name>
              <description>PDMA Channel Enable Bit\nSetting this bit to 1 enables PDMA operation. If this bit is cleared, PDMA will ignore all PDMA request and force Bus Master into IDLE state.\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_RST</name>
              <description>Software Engine Reset\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reset the internal state machine, pointers and internal buffer. The contents of control register will not be cleared. This bit will be automatically cleared after few clock cycles</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>MODE_SEL</name>
              <description>PDMA Mode Selection\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Memory to Memory mode (Memory-to-Memory)</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Peripheral to Memory mode (Peripheral-to-Memory)</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Memory to Peripheral mode (Memory-to-Peripheral)</description>
                    <value>#10</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SAD_SEL</name>
              <description>Transfer Source Address Direction Selection\n</description>
              <bitOffset>4</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Transfer source address is increasing successively</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reserved</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Transfer source address is fixed (This feature can be used when data where transferred from a single source to multiple destinations)</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Reserved</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DAD_SEL</name>
              <description>Transfer Destination Address Direction Selection\n</description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Transfer destination address is increasing successively</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reserved</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Transfer destination address is fixed. (This feature can be used when data where transferred from multiple sources to a single destination)</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Reserved</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>APB_TWS</name>
              <description>Peripheral Transfer Width Selection\nNote: This field is meaningful only when MODE_SEL (PDMA_CSRx[3:2]) is Peripheral to Memory mode (Peripheral-to-Memory) or Memory to Peripheral mode (Memory-to-Peripheral).</description>
              <bitOffset>19</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>One word (32-bit) is transferred for every PDMA operation</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>One byte (8-bit) is transferred for every PDMA operation</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>One half-word (16-bit) is transferred for every PDMA operation</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Reserved</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TRIG_EN</name>
              <description>Trigger Enable Bit\nNote: When PDMA transfer completed, this bit will be cleared automatically.\nIf the bus error occurs, all PDMA transfer will be stopped. Software must reset all PDMA channel, and then trigger again.</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PDMA data read or write transfer Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PDMA_CSR0">
          <name>PDMA_CSR1</name>
          <displayName>PDMA_CSR1</displayName>
          <description>PDMA Channel x Control Register</description>
          <alternateRegister>PDMA_CSR0</alternateRegister>
          <addressOffset>0x0</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSR0">
          <name>PDMA_CSR2</name>
          <displayName>PDMA_CSR2</displayName>
          <description>PDMA Channel x Control Register</description>
          <alternateRegister>PDMA_CSR0</alternateRegister>
          <addressOffset>0x0</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSR0">
          <name>PDMA_CSR3</name>
          <displayName>PDMA_CSR3</displayName>
          <description>PDMA Channel x Control Register</description>
          <alternateRegister>PDMA_CSR0</alternateRegister>
          <addressOffset>0x0</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSR0">
          <name>PDMA_CSR4</name>
          <displayName>PDMA_CSR4</displayName>
          <description>PDMA Channel x Control Register</description>
          <alternateRegister>PDMA_CSR0</alternateRegister>
          <addressOffset>0x0</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSR0">
          <name>PDMA_CSR5</name>
          <displayName>PDMA_CSR5</displayName>
          <description>PDMA Channel x Control Register</description>
          <alternateRegister>PDMA_CSR0</alternateRegister>
          <addressOffset>0x0</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSR0">
          <name>PDMA_CSR6</name>
          <displayName>PDMA_CSR6</displayName>
          <description>PDMA Channel x Control Register</description>
          <alternateRegister>PDMA_CSR0</alternateRegister>
          <addressOffset>0x0</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSR0">
          <name>PDMA_CSR7</name>
          <displayName>PDMA_CSR7</displayName>
          <description>PDMA Channel x Control Register</description>
          <alternateRegister>PDMA_CSR0</alternateRegister>
          <addressOffset>0x0</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSR0">
          <name>PDMA_CSR8</name>
          <displayName>PDMA_CSR8</displayName>
          <description>PDMA Channel x Control Register</description>
          <alternateRegister>PDMA_CSR0</alternateRegister>
          <addressOffset>0x0</addressOffset>
       </register>
       <register>
          <name>PDMA_SAR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_SAR0</displayName>
          <description>PDMA Channel x Source Address Register</description>
          <addressOffset>0x4</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_SAR</name>
              <description>PDMA Transfer Source Address Register\nThis field indicates a 32-bit source address of PDMA.\nNote: The source address must be word alignment.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PDMA_SAR0">
          <name>PDMA_SAR1</name>
          <displayName>PDMA_SAR1</displayName>
          <description>PDMA Channel x Source Address Register</description>
          <alternateRegister>PDMA_SAR0</alternateRegister>
          <addressOffset>0x4</addressOffset>
       </register>
       <register derivedFrom="PDMA_SAR0">
          <name>PDMA_SAR2</name>
          <displayName>PDMA_SAR2</displayName>
          <description>PDMA Channel x Source Address Register</description>
          <alternateRegister>PDMA_SAR0</alternateRegister>
          <addressOffset>0x4</addressOffset>
       </register>
       <register derivedFrom="PDMA_SAR0">
          <name>PDMA_SAR3</name>
          <displayName>PDMA_SAR3</displayName>
          <description>PDMA Channel x Source Address Register</description>
          <alternateRegister>PDMA_SAR0</alternateRegister>
          <addressOffset>0x4</addressOffset>
       </register>
       <register derivedFrom="PDMA_SAR0">
          <name>PDMA_SAR4</name>
          <displayName>PDMA_SAR4</displayName>
          <description>PDMA Channel x Source Address Register</description>
          <alternateRegister>PDMA_SAR0</alternateRegister>
          <addressOffset>0x4</addressOffset>
       </register>
       <register derivedFrom="PDMA_SAR0">
          <name>PDMA_SAR5</name>
          <displayName>PDMA_SAR5</displayName>
          <description>PDMA Channel x Source Address Register</description>
          <alternateRegister>PDMA_SAR0</alternateRegister>
          <addressOffset>0x4</addressOffset>
       </register>
       <register derivedFrom="PDMA_SAR0">
          <name>PDMA_SAR6</name>
          <displayName>PDMA_SAR6</displayName>
          <description>PDMA Channel x Source Address Register</description>
          <alternateRegister>PDMA_SAR0</alternateRegister>
          <addressOffset>0x4</addressOffset>
       </register>
       <register derivedFrom="PDMA_SAR0">
          <name>PDMA_SAR7</name>
          <displayName>PDMA_SAR7</displayName>
          <description>PDMA Channel x Source Address Register</description>
          <alternateRegister>PDMA_SAR0</alternateRegister>
          <addressOffset>0x4</addressOffset>
       </register>
       <register derivedFrom="PDMA_SAR0">
          <name>PDMA_SAR8</name>
          <displayName>PDMA_SAR8</displayName>
          <description>PDMA Channel x Source Address Register</description>
          <alternateRegister>PDMA_SAR0</alternateRegister>
          <addressOffset>0x4</addressOffset>
       </register>
       <register>
          <name>PDMA_DAR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_DAR0</displayName>
          <description>PDMA Channel x Destination Address Register</description>
          <addressOffset>0x8</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_DAR</name>
              <description>PDMA Transfer Destination Address Register\nThis field indicates a 32-bit destination address of PDMA.\nNote: The destination address must be word alignment</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PDMA_DAR0">
          <name>PDMA_DAR1</name>
          <displayName>PDMA_DAR1</displayName>
          <description>PDMA Channel x Destination Address Register</description>
          <alternateRegister>PDMA_DAR0</alternateRegister>
          <addressOffset>0x8</addressOffset>
       </register>
       <register derivedFrom="PDMA_DAR0">
          <name>PDMA_DAR2</name>
          <displayName>PDMA_DAR2</displayName>
          <description>PDMA Channel x Destination Address Register</description>
          <alternateRegister>PDMA_DAR0</alternateRegister>
          <addressOffset>0x8</addressOffset>
       </register>
       <register derivedFrom="PDMA_DAR0">
          <name>PDMA_DAR3</name>
          <displayName>PDMA_DAR3</displayName>
          <description>PDMA Channel x Destination Address Register</description>
          <alternateRegister>PDMA_DAR0</alternateRegister>
          <addressOffset>0x8</addressOffset>
       </register>
       <register derivedFrom="PDMA_DAR0">
          <name>PDMA_DAR4</name>
          <displayName>PDMA_DAR4</displayName>
          <description>PDMA Channel x Destination Address Register</description>
          <alternateRegister>PDMA_DAR0</alternateRegister>
          <addressOffset>0x8</addressOffset>
       </register>
       <register derivedFrom="PDMA_DAR0">
          <name>PDMA_DAR5</name>
          <displayName>PDMA_DAR5</displayName>
          <description>PDMA Channel x Destination Address Register</description>
          <alternateRegister>PDMA_DAR0</alternateRegister>
          <addressOffset>0x8</addressOffset>
       </register>
       <register derivedFrom="PDMA_DAR0">
          <name>PDMA_DAR6</name>
          <displayName>PDMA_DAR6</displayName>
          <description>PDMA Channel x Destination Address Register</description>
          <alternateRegister>PDMA_DAR0</alternateRegister>
          <addressOffset>0x8</addressOffset>
       </register>
       <register derivedFrom="PDMA_DAR0">
          <name>PDMA_DAR7</name>
          <displayName>PDMA_DAR7</displayName>
          <description>PDMA Channel x Destination Address Register</description>
          <alternateRegister>PDMA_DAR0</alternateRegister>
          <addressOffset>0x8</addressOffset>
       </register>
       <register derivedFrom="PDMA_DAR0">
          <name>PDMA_DAR8</name>
          <displayName>PDMA_DAR8</displayName>
          <description>PDMA Channel x Destination Address Register</description>
          <alternateRegister>PDMA_DAR0</alternateRegister>
          <addressOffset>0x8</addressOffset>
       </register>
       <register>
          <name>PDMA_BCR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_BCR0</displayName>
          <description>PDMA Channel x Transfer Byte Count Register</description>
          <addressOffset>0xC</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_BCR</name>
              <description>PDMA Transfer Byte Count Register\nThis field indicates a 16-bit transfer byte count number of PDMA; it must be word alignment.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PDMA_BCR0">
          <name>PDMA_BCR1</name>
          <displayName>PDMA_BCR1</displayName>
          <description>PDMA Channel x Transfer Byte Count Register</description>
          <alternateRegister>PDMA_BCR0</alternateRegister>
          <addressOffset>0xC</addressOffset>
       </register>
       <register derivedFrom="PDMA_BCR0">
          <name>PDMA_BCR2</name>
          <displayName>PDMA_BCR2</displayName>
          <description>PDMA Channel x Transfer Byte Count Register</description>
          <alternateRegister>PDMA_BCR0</alternateRegister>
          <addressOffset>0xC</addressOffset>
       </register>
       <register derivedFrom="PDMA_BCR0">
          <name>PDMA_BCR3</name>
          <displayName>PDMA_BCR3</displayName>
          <description>PDMA Channel x Transfer Byte Count Register</description>
          <alternateRegister>PDMA_BCR0</alternateRegister>
          <addressOffset>0xC</addressOffset>
       </register>
       <register derivedFrom="PDMA_BCR0">
          <name>PDMA_BCR4</name>
          <displayName>PDMA_BCR4</displayName>
          <description>PDMA Channel x Transfer Byte Count Register</description>
          <alternateRegister>PDMA_BCR0</alternateRegister>
          <addressOffset>0xC</addressOffset>
       </register>
       <register derivedFrom="PDMA_BCR0">
          <name>PDMA_BCR5</name>
          <displayName>PDMA_BCR5</displayName>
          <description>PDMA Channel x Transfer Byte Count Register</description>
          <alternateRegister>PDMA_BCR0</alternateRegister>
          <addressOffset>0xC</addressOffset>
       </register>
       <register derivedFrom="PDMA_BCR0">
          <name>PDMA_BCR6</name>
          <displayName>PDMA_BCR6</displayName>
          <description>PDMA Channel x Transfer Byte Count Register</description>
          <alternateRegister>PDMA_BCR0</alternateRegister>
          <addressOffset>0xC</addressOffset>
       </register>
       <register derivedFrom="PDMA_BCR0">
          <name>PDMA_BCR7</name>
          <displayName>PDMA_BCR7</displayName>
          <description>PDMA Channel x Transfer Byte Count Register</description>
          <alternateRegister>PDMA_BCR0</alternateRegister>
          <addressOffset>0xC</addressOffset>
       </register>
       <register derivedFrom="PDMA_BCR0">
          <name>PDMA_BCR8</name>
          <displayName>PDMA_BCR8</displayName>
          <description>PDMA Channel x Transfer Byte Count Register</description>
          <alternateRegister>PDMA_BCR0</alternateRegister>
          <addressOffset>0xC</addressOffset>
       </register>
       <register>
          <name>PDMA_POINT0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_POINT0</displayName>
          <description>PDMA Channel x Internal Buffer Pointer Register</description>
          <addressOffset>0x10</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_POINT</name>
              <description>PDMA Internal Buffer Pointer Register (Read Only)\nThis field indicates the internal buffer pointer.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PDMA_POINT0">
          <name>PDMA_POINT1</name>
          <displayName>PDMA_POINT1</displayName>
          <description>PDMA Channel x Internal Buffer Pointer Register</description>
          <alternateRegister>PDMA_POINT0</alternateRegister>
          <addressOffset>0x10</addressOffset>
       </register>
       <register derivedFrom="PDMA_POINT0">
          <name>PDMA_POINT2</name>
          <displayName>PDMA_POINT2</displayName>
          <description>PDMA Channel x Internal Buffer Pointer Register</description>
          <alternateRegister>PDMA_POINT0</alternateRegister>
          <addressOffset>0x10</addressOffset>
       </register>
       <register derivedFrom="PDMA_POINT0">
          <name>PDMA_POINT3</name>
          <displayName>PDMA_POINT3</displayName>
          <description>PDMA Channel x Internal Buffer Pointer Register</description>
          <alternateRegister>PDMA_POINT0</alternateRegister>
          <addressOffset>0x10</addressOffset>
       </register>
       <register derivedFrom="PDMA_POINT0">
          <name>PDMA_POINT4</name>
          <displayName>PDMA_POINT4</displayName>
          <description>PDMA Channel x Internal Buffer Pointer Register</description>
          <alternateRegister>PDMA_POINT0</alternateRegister>
          <addressOffset>0x10</addressOffset>
       </register>
       <register derivedFrom="PDMA_POINT0">
          <name>PDMA_POINT5</name>
          <displayName>PDMA_POINT5</displayName>
          <description>PDMA Channel x Internal Buffer Pointer Register</description>
          <alternateRegister>PDMA_POINT0</alternateRegister>
          <addressOffset>0x10</addressOffset>
       </register>
       <register derivedFrom="PDMA_POINT0">
          <name>PDMA_POINT6</name>
          <displayName>PDMA_POINT6</displayName>
          <description>PDMA Channel x Internal Buffer Pointer Register</description>
          <alternateRegister>PDMA_POINT0</alternateRegister>
          <addressOffset>0x10</addressOffset>
       </register>
       <register derivedFrom="PDMA_POINT0">
          <name>PDMA_POINT7</name>
          <displayName>PDMA_POINT7</displayName>
          <description>PDMA Channel x Internal Buffer Pointer Register</description>
          <alternateRegister>PDMA_POINT0</alternateRegister>
          <addressOffset>0x10</addressOffset>
       </register>
       <register derivedFrom="PDMA_POINT0">
          <name>PDMA_POINT8</name>
          <displayName>PDMA_POINT8</displayName>
          <description>PDMA Channel x Internal Buffer Pointer Register</description>
          <alternateRegister>PDMA_POINT0</alternateRegister>
          <addressOffset>0x10</addressOffset>
       </register>
       <register>
          <name>PDMA_CSAR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_CSAR0</displayName>
          <description>PDMA Channel x Current Source Address Register</description>
          <addressOffset>0x14</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_CSAR</name>
              <description>PDMA Current Source Address Register (Read Only)\nThis field indicates the source address where the PDMA transfer just occurred.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PDMA_CSAR0">
          <name>PDMA_CSAR1</name>
          <displayName>PDMA_CSAR1</displayName>
          <description>PDMA Channel x Current Source Address Register</description>
          <alternateRegister>PDMA_CSAR0</alternateRegister>
          <addressOffset>0x14</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSAR0">
          <name>PDMA_CSAR2</name>
          <displayName>PDMA_CSAR2</displayName>
          <description>PDMA Channel x Current Source Address Register</description>
          <alternateRegister>PDMA_CSAR0</alternateRegister>
          <addressOffset>0x14</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSAR0">
          <name>PDMA_CSAR3</name>
          <displayName>PDMA_CSAR3</displayName>
          <description>PDMA Channel x Current Source Address Register</description>
          <alternateRegister>PDMA_CSAR0</alternateRegister>
          <addressOffset>0x14</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSAR0">
          <name>PDMA_CSAR4</name>
          <displayName>PDMA_CSAR4</displayName>
          <description>PDMA Channel x Current Source Address Register</description>
          <alternateRegister>PDMA_CSAR0</alternateRegister>
          <addressOffset>0x14</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSAR0">
          <name>PDMA_CSAR5</name>
          <displayName>PDMA_CSAR5</displayName>
          <description>PDMA Channel x Current Source Address Register</description>
          <alternateRegister>PDMA_CSAR0</alternateRegister>
          <addressOffset>0x14</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSAR0">
          <name>PDMA_CSAR6</name>
          <displayName>PDMA_CSAR6</displayName>
          <description>PDMA Channel x Current Source Address Register</description>
          <alternateRegister>PDMA_CSAR0</alternateRegister>
          <addressOffset>0x14</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSAR0">
          <name>PDMA_CSAR7</name>
          <displayName>PDMA_CSAR7</displayName>
          <description>PDMA Channel x Current Source Address Register</description>
          <alternateRegister>PDMA_CSAR0</alternateRegister>
          <addressOffset>0x14</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSAR0">
          <name>PDMA_CSAR8</name>
          <displayName>PDMA_CSAR8</displayName>
          <description>PDMA Channel x Current Source Address Register</description>
          <alternateRegister>PDMA_CSAR0</alternateRegister>
          <addressOffset>0x14</addressOffset>
       </register>
       <register>
          <name>PDMA_CDAR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_CDAR0</displayName>
          <description>PDMA Channel x Current Destination Address Register</description>
          <addressOffset>0x18</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_CDAR</name>
              <description>PDMA Current Destination Address Register (Read Only)\nThis field indicates the destination address where the PDMA transfer just occurred.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PDMA_CDAR0">
          <name>PDMA_CDAR1</name>
          <displayName>PDMA_CDAR1</displayName>
          <description>PDMA Channel x Current Destination Address Register</description>
          <alternateRegister>PDMA_CDAR0</alternateRegister>
          <addressOffset>0x18</addressOffset>
       </register>
       <register derivedFrom="PDMA_CDAR0">
          <name>PDMA_CDAR2</name>
          <displayName>PDMA_CDAR2</displayName>
          <description>PDMA Channel x Current Destination Address Register</description>
          <alternateRegister>PDMA_CDAR0</alternateRegister>
          <addressOffset>0x18</addressOffset>
       </register>
       <register derivedFrom="PDMA_CDAR0">
          <name>PDMA_CDAR3</name>
          <displayName>PDMA_CDAR3</displayName>
          <description>PDMA Channel x Current Destination Address Register</description>
          <alternateRegister>PDMA_CDAR0</alternateRegister>
          <addressOffset>0x18</addressOffset>
       </register>
       <register derivedFrom="PDMA_CDAR0">
          <name>PDMA_CDAR4</name>
          <displayName>PDMA_CDAR4</displayName>
          <description>PDMA Channel x Current Destination Address Register</description>
          <alternateRegister>PDMA_CDAR0</alternateRegister>
          <addressOffset>0x18</addressOffset>
       </register>
       <register derivedFrom="PDMA_CDAR0">
          <name>PDMA_CDAR5</name>
          <displayName>PDMA_CDAR5</displayName>
          <description>PDMA Channel x Current Destination Address Register</description>
          <alternateRegister>PDMA_CDAR0</alternateRegister>
          <addressOffset>0x18</addressOffset>
       </register>
       <register derivedFrom="PDMA_CDAR0">
          <name>PDMA_CDAR6</name>
          <displayName>PDMA_CDAR6</displayName>
          <description>PDMA Channel x Current Destination Address Register</description>
          <alternateRegister>PDMA_CDAR0</alternateRegister>
          <addressOffset>0x18</addressOffset>
       </register>
       <register derivedFrom="PDMA_CDAR0">
          <name>PDMA_CDAR7</name>
          <displayName>PDMA_CDAR7</displayName>
          <description>PDMA Channel x Current Destination Address Register</description>
          <alternateRegister>PDMA_CDAR0</alternateRegister>
          <addressOffset>0x18</addressOffset>
       </register>
       <register derivedFrom="PDMA_CDAR0">
          <name>PDMA_CDAR8</name>
          <displayName>PDMA_CDAR8</displayName>
          <description>PDMA Channel x Current Destination Address Register</description>
          <alternateRegister>PDMA_CDAR0</alternateRegister>
          <addressOffset>0x18</addressOffset>
       </register>
       <register>
          <name>PDMA_CBCR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_CBCR0</displayName>
          <description>PDMA Channel x Current Transfer Byte Count Register</description>
          <addressOffset>0x1C</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_CBCR</name>
              <description>PDMA Current Byte Count Register (Read Only)\nThis field indicates the current remained byte count of PDMA.\nNote: This field value will be cleared to 0, when software set SW_RST (PDMA_CSRx[1]) to "1".</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PDMA_CBCR0">
          <name>PDMA_CBCR1</name>
          <displayName>PDMA_CBCR1</displayName>
          <description>PDMA Channel x Current Transfer Byte Count Register</description>
          <alternateRegister>PDMA_CBCR0</alternateRegister>
          <addressOffset>0x1C</addressOffset>
       </register>
       <register derivedFrom="PDMA_CBCR0">
          <name>PDMA_CBCR2</name>
          <displayName>PDMA_CBCR2</displayName>
          <description>PDMA Channel x Current Transfer Byte Count Register</description>
          <alternateRegister>PDMA_CBCR0</alternateRegister>
          <addressOffset>0x1C</addressOffset>
       </register>
       <register derivedFrom="PDMA_CBCR0">
          <name>PDMA_CBCR3</name>
          <displayName>PDMA_CBCR3</displayName>
          <description>PDMA Channel x Current Transfer Byte Count Register</description>
          <alternateRegister>PDMA_CBCR0</alternateRegister>
          <addressOffset>0x1C</addressOffset>
       </register>
       <register derivedFrom="PDMA_CBCR0">
          <name>PDMA_CBCR4</name>
          <displayName>PDMA_CBCR4</displayName>
          <description>PDMA Channel x Current Transfer Byte Count Register</description>
          <alternateRegister>PDMA_CBCR0</alternateRegister>
          <addressOffset>0x1C</addressOffset>
       </register>
       <register derivedFrom="PDMA_CBCR0">
          <name>PDMA_CBCR5</name>
          <displayName>PDMA_CBCR5</displayName>
          <description>PDMA Channel x Current Transfer Byte Count Register</description>
          <alternateRegister>PDMA_CBCR0</alternateRegister>
          <addressOffset>0x1C</addressOffset>
       </register>
       <register derivedFrom="PDMA_CBCR0">
          <name>PDMA_CBCR6</name>
          <displayName>PDMA_CBCR6</displayName>
          <description>PDMA Channel x Current Transfer Byte Count Register</description>
          <alternateRegister>PDMA_CBCR0</alternateRegister>
          <addressOffset>0x1C</addressOffset>
       </register>
       <register derivedFrom="PDMA_CBCR0">
          <name>PDMA_CBCR7</name>
          <displayName>PDMA_CBCR7</displayName>
          <description>PDMA Channel x Current Transfer Byte Count Register</description>
          <alternateRegister>PDMA_CBCR0</alternateRegister>
          <addressOffset>0x1C</addressOffset>
       </register>
       <register derivedFrom="PDMA_CBCR0">
          <name>PDMA_CBCR8</name>
          <displayName>PDMA_CBCR8</displayName>
          <description>PDMA Channel x Current Transfer Byte Count Register</description>
          <alternateRegister>PDMA_CBCR0</alternateRegister>
          <addressOffset>0x1C</addressOffset>
       </register>
       <register>
          <name>PDMA_IER0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_IER0</displayName>
          <description>PDMA Channel x Interrupt Enable Register</description>
          <addressOffset>0x20</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000001</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TABORT_IE</name>
              <description>PDMA Read/Write Target Abort Interrupt Enable Bit\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Target abort interrupt generation Disabled during PDMA transfer</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Target abort interrupt generation Enabled during PDMA transfer</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BLKD_IE</name>
              <description>PDMA Block Transfer Done Interrupt Enable Bit\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Interrupt generator Disabled when PDMA transfer is done</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Interrupt generator Enabled when PDMA transfer is done</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PDMA_IER0">
          <name>PDMA_IER1</name>
          <displayName>PDMA_IER1</displayName>
          <description>PDMA Channel x Interrupt Enable Register</description>
          <alternateRegister>PDMA_IER0</alternateRegister>
          <addressOffset>0x20</addressOffset>
       </register>
       <register derivedFrom="PDMA_IER0">
          <name>PDMA_IER2</name>
          <displayName>PDMA_IER2</displayName>
          <description>PDMA Channel x Interrupt Enable Register</description>
          <alternateRegister>PDMA_IER0</alternateRegister>
          <addressOffset>0x20</addressOffset>
       </register>
       <register derivedFrom="PDMA_IER0">
          <name>PDMA_IER3</name>
          <displayName>PDMA_IER3</displayName>
          <description>PDMA Channel x Interrupt Enable Register</description>
          <alternateRegister>PDMA_IER0</alternateRegister>
          <addressOffset>0x20</addressOffset>
       </register>
       <register derivedFrom="PDMA_IER0">
          <name>PDMA_IER4</name>
          <displayName>PDMA_IER4</displayName>
          <description>PDMA Channel x Interrupt Enable Register</description>
          <alternateRegister>PDMA_IER0</alternateRegister>
          <addressOffset>0x20</addressOffset>
       </register>
       <register derivedFrom="PDMA_IER0">
          <name>PDMA_IER5</name>
          <displayName>PDMA_IER5</displayName>
          <description>PDMA Channel x Interrupt Enable Register</description>
          <alternateRegister>PDMA_IER0</alternateRegister>
          <addressOffset>0x20</addressOffset>
       </register>
       <register derivedFrom="PDMA_IER0">
          <name>PDMA_IER6</name>
          <displayName>PDMA_IER6</displayName>
          <description>PDMA Channel x Interrupt Enable Register</description>
          <alternateRegister>PDMA_IER0</alternateRegister>
          <addressOffset>0x20</addressOffset>
       </register>
       <register derivedFrom="PDMA_IER0">
          <name>PDMA_IER7</name>
          <displayName>PDMA_IER7</displayName>
          <description>PDMA Channel x Interrupt Enable Register</description>
          <alternateRegister>PDMA_IER0</alternateRegister>
          <addressOffset>0x20</addressOffset>
       </register>
       <register derivedFrom="PDMA_IER0">
          <name>PDMA_IER8</name>
          <displayName>PDMA_IER8</displayName>
          <description>PDMA Channel x Interrupt Enable Register</description>
          <alternateRegister>PDMA_IER0</alternateRegister>
          <addressOffset>0x20</addressOffset>
       </register>
       <register>
          <name>PDMA_ISR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_ISR0</displayName>
          <description>PDMA Channel x Interrupt Status Register</description>
          <addressOffset>0x24</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TABORT_IF</name>
              <description>PDMA Read/Write Target Abort Interrupt Flag\nWrite 1 to clear this bit to 0.\nNote: This bit filed indicates bus master received ERROR response or not. If bus master received ERROR response, it means that target abort is happened. PDMA controller will stop transfer and respond this event to software then goes to IDLE state. When target abort occurred, software must reset PDMA, and then transfer those data again.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No bus ERROR response received</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Bus ERROR response received</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BLKD_IF</name>
              <description>PDMA Block Transfer Done Interrupt Flag\nThis bit indicates that PDMA has finished all transfers.\nWrite 1 to clear this bit to 0.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Not finished</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Done</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PDMA_ISR0">
          <name>PDMA_ISR1</name>
          <displayName>PDMA_ISR1</displayName>
          <description>PDMA Channel x Interrupt Status Register</description>
          <alternateRegister>PDMA_ISR0</alternateRegister>
          <addressOffset>0x24</addressOffset>
       </register>
       <register derivedFrom="PDMA_ISR0">
          <name>PDMA_ISR2</name>
          <displayName>PDMA_ISR2</displayName>
          <description>PDMA Channel x Interrupt Status Register</description>
          <alternateRegister>PDMA_ISR0</alternateRegister>
          <addressOffset>0x24</addressOffset>
       </register>
       <register derivedFrom="PDMA_ISR0">
          <name>PDMA_ISR3</name>
          <displayName>PDMA_ISR3</displayName>
          <description>PDMA Channel x Interrupt Status Register</description>
          <alternateRegister>PDMA_ISR0</alternateRegister>
          <addressOffset>0x24</addressOffset>
       </register>
       <register derivedFrom="PDMA_ISR0">
          <name>PDMA_ISR4</name>
          <displayName>PDMA_ISR4</displayName>
          <description>PDMA Channel x Interrupt Status Register</description>
          <alternateRegister>PDMA_ISR0</alternateRegister>
          <addressOffset>0x24</addressOffset>
       </register>
       <register derivedFrom="PDMA_ISR0">
          <name>PDMA_ISR5</name>
          <displayName>PDMA_ISR5</displayName>
          <description>PDMA Channel x Interrupt Status Register</description>
          <alternateRegister>PDMA_ISR0</alternateRegister>
          <addressOffset>0x24</addressOffset>
       </register>
       <register derivedFrom="PDMA_ISR0">
          <name>PDMA_ISR6</name>
          <displayName>PDMA_ISR6</displayName>
          <description>PDMA Channel x Interrupt Status Register</description>
          <alternateRegister>PDMA_ISR0</alternateRegister>
          <addressOffset>0x24</addressOffset>
       </register>
       <register derivedFrom="PDMA_ISR0">
          <name>PDMA_ISR7</name>
          <displayName>PDMA_ISR7</displayName>
          <description>PDMA Channel x Interrupt Status Register</description>
          <alternateRegister>PDMA_ISR0</alternateRegister>
          <addressOffset>0x24</addressOffset>
       </register>
       <register derivedFrom="PDMA_ISR0">
          <name>PDMA_ISR8</name>
          <displayName>PDMA_ISR8</displayName>
          <description>PDMA Channel x Interrupt Status Register</description>
          <alternateRegister>PDMA_ISR0</alternateRegister>
          <addressOffset>0x24</addressOffset>
       </register>
       <register>
          <name>PDMA_SBUF0_C0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_SBUF0_C0</displayName>
          <description>PDMA Channel x Shared Buffer FIFO 0 Register</description>
          <addressOffset>0x80</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_SBUF0</name>
              <description>PDMA Shared Buffer FIFO 0 (Read Only)\nEach channel has its own 1 word internal buffer.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PDMA_SBUF0_C0">
          <name>PDMA_SBUF0_C1</name>
          <displayName>PDMA_SBUF0_C1</displayName>
          <description>PDMA Channel x Shared Buffer FIFO 0 Register</description>
          <alternateRegister>PDMA_SBUF0_C0</alternateRegister>
          <addressOffset>0x80</addressOffset>
       </register>
       <register derivedFrom="PDMA_SBUF0_C0">
          <name>PDMA_SBUF0_C2</name>
          <displayName>PDMA_SBUF0_C2</displayName>
          <description>PDMA Channel x Shared Buffer FIFO 0 Register</description>
          <alternateRegister>PDMA_SBUF0_C0</alternateRegister>
          <addressOffset>0x80</addressOffset>
       </register>
       <register derivedFrom="PDMA_SBUF0_C0">
          <name>PDMA_SBUF0_C3</name>
          <displayName>PDMA_SBUF0_C3</displayName>
          <description>PDMA Channel x Shared Buffer FIFO 0 Register</description>
          <alternateRegister>PDMA_SBUF0_C0</alternateRegister>
          <addressOffset>0x80</addressOffset>
       </register>
       <register derivedFrom="PDMA_SBUF0_C0">
          <name>PDMA_SBUF0_C4</name>
          <displayName>PDMA_SBUF0_C4</displayName>
          <description>PDMA Channel x Shared Buffer FIFO 0 Register</description>
          <alternateRegister>PDMA_SBUF0_C0</alternateRegister>
          <addressOffset>0x80</addressOffset>
       </register>
       <register derivedFrom="PDMA_SBUF0_C0">
          <name>PDMA_SBUF0_C5</name>
          <displayName>PDMA_SBUF0_C5</displayName>
          <description>PDMA Channel x Shared Buffer FIFO 0 Register</description>
          <alternateRegister>PDMA_SBUF0_C0</alternateRegister>
          <addressOffset>0x80</addressOffset>
       </register>
       <register derivedFrom="PDMA_SBUF0_C0">
          <name>PDMA_SBUF0_C6</name>
          <displayName>PDMA_SBUF0_C6</displayName>
          <description>PDMA Channel x Shared Buffer FIFO 0 Register</description>
          <alternateRegister>PDMA_SBUF0_C0</alternateRegister>
          <addressOffset>0x80</addressOffset>
       </register>
       <register derivedFrom="PDMA_SBUF0_C0">
          <name>PDMA_SBUF0_C7</name>
          <displayName>PDMA_SBUF0_C7</displayName>
          <description>PDMA Channel x Shared Buffer FIFO 0 Register</description>
          <alternateRegister>PDMA_SBUF0_C0</alternateRegister>
          <addressOffset>0x80</addressOffset>
       </register>
       <register derivedFrom="PDMA_SBUF0_C0">
          <name>PDMA_SBUF0_C8</name>
          <displayName>PDMA_SBUF0_C8</displayName>
          <description>PDMA Channel x Shared Buffer FIFO 0 Register</description>
          <alternateRegister>PDMA_SBUF0_C0</alternateRegister>
          <addressOffset>0x80</addressOffset>
       </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>PDMA_CH4</name>
      <description>PDMA Register Map</description>
      <groupName>PDMA</groupName>
      <baseAddress>0x50008400</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x0</offset>
        <size>0x28</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x80</offset>
        <size>0x4</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>PDMA_CSR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_CSR0</displayName>
          <description>PDMA Channel x Control Register</description>
          <addressOffset>0x0</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMACEN</name>
              <description>PDMA Channel Enable Bit\nSetting this bit to 1 enables PDMA operation. If this bit is cleared, PDMA will ignore all PDMA request and force Bus Master into IDLE state.\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_RST</name>
              <description>Software Engine Reset\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reset the internal state machine, pointers and internal buffer. The contents of control register will not be cleared. This bit will be automatically cleared after few clock cycles</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>MODE_SEL</name>
              <description>PDMA Mode Selection\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Memory to Memory mode (Memory-to-Memory)</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Peripheral to Memory mode (Peripheral-to-Memory)</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Memory to Peripheral mode (Memory-to-Peripheral)</description>
                    <value>#10</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SAD_SEL</name>
              <description>Transfer Source Address Direction Selection\n</description>
              <bitOffset>4</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Transfer source address is increasing successively</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reserved</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Transfer source address is fixed (This feature can be used when data where transferred from a single source to multiple destinations)</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Reserved</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DAD_SEL</name>
              <description>Transfer Destination Address Direction Selection\n</description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Transfer destination address is increasing successively</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reserved</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Transfer destination address is fixed. (This feature can be used when data where transferred from multiple sources to a single destination)</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Reserved</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>APB_TWS</name>
              <description>Peripheral Transfer Width Selection\nNote: This field is meaningful only when MODE_SEL (PDMA_CSRx[3:2]) is Peripheral to Memory mode (Peripheral-to-Memory) or Memory to Peripheral mode (Memory-to-Peripheral).</description>
              <bitOffset>19</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>One word (32-bit) is transferred for every PDMA operation</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>One byte (8-bit) is transferred for every PDMA operation</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>One half-word (16-bit) is transferred for every PDMA operation</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Reserved</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TRIG_EN</name>
              <description>Trigger Enable Bit\nNote: When PDMA transfer completed, this bit will be cleared automatically.\nIf the bus error occurs, all PDMA transfer will be stopped. Software must reset all PDMA channel, and then trigger again.</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PDMA data read or write transfer Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PDMA_CSR0">
          <name>PDMA_CSR1</name>
          <displayName>PDMA_CSR1</displayName>
          <description>PDMA Channel x Control Register</description>
          <alternateRegister>PDMA_CSR0</alternateRegister>
          <addressOffset>0x0</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSR0">
          <name>PDMA_CSR2</name>
          <displayName>PDMA_CSR2</displayName>
          <description>PDMA Channel x Control Register</description>
          <alternateRegister>PDMA_CSR0</alternateRegister>
          <addressOffset>0x0</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSR0">
          <name>PDMA_CSR3</name>
          <displayName>PDMA_CSR3</displayName>
          <description>PDMA Channel x Control Register</description>
          <alternateRegister>PDMA_CSR0</alternateRegister>
          <addressOffset>0x0</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSR0">
          <name>PDMA_CSR4</name>
          <displayName>PDMA_CSR4</displayName>
          <description>PDMA Channel x Control Register</description>
          <alternateRegister>PDMA_CSR0</alternateRegister>
          <addressOffset>0x0</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSR0">
          <name>PDMA_CSR5</name>
          <displayName>PDMA_CSR5</displayName>
          <description>PDMA Channel x Control Register</description>
          <alternateRegister>PDMA_CSR0</alternateRegister>
          <addressOffset>0x0</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSR0">
          <name>PDMA_CSR6</name>
          <displayName>PDMA_CSR6</displayName>
          <description>PDMA Channel x Control Register</description>
          <alternateRegister>PDMA_CSR0</alternateRegister>
          <addressOffset>0x0</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSR0">
          <name>PDMA_CSR7</name>
          <displayName>PDMA_CSR7</displayName>
          <description>PDMA Channel x Control Register</description>
          <alternateRegister>PDMA_CSR0</alternateRegister>
          <addressOffset>0x0</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSR0">
          <name>PDMA_CSR8</name>
          <displayName>PDMA_CSR8</displayName>
          <description>PDMA Channel x Control Register</description>
          <alternateRegister>PDMA_CSR0</alternateRegister>
          <addressOffset>0x0</addressOffset>
       </register>
       <register>
          <name>PDMA_SAR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_SAR0</displayName>
          <description>PDMA Channel x Source Address Register</description>
          <addressOffset>0x4</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_SAR</name>
              <description>PDMA Transfer Source Address Register\nThis field indicates a 32-bit source address of PDMA.\nNote: The source address must be word alignment.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PDMA_SAR0">
          <name>PDMA_SAR1</name>
          <displayName>PDMA_SAR1</displayName>
          <description>PDMA Channel x Source Address Register</description>
          <alternateRegister>PDMA_SAR0</alternateRegister>
          <addressOffset>0x4</addressOffset>
       </register>
       <register derivedFrom="PDMA_SAR0">
          <name>PDMA_SAR2</name>
          <displayName>PDMA_SAR2</displayName>
          <description>PDMA Channel x Source Address Register</description>
          <alternateRegister>PDMA_SAR0</alternateRegister>
          <addressOffset>0x4</addressOffset>
       </register>
       <register derivedFrom="PDMA_SAR0">
          <name>PDMA_SAR3</name>
          <displayName>PDMA_SAR3</displayName>
          <description>PDMA Channel x Source Address Register</description>
          <alternateRegister>PDMA_SAR0</alternateRegister>
          <addressOffset>0x4</addressOffset>
       </register>
       <register derivedFrom="PDMA_SAR0">
          <name>PDMA_SAR4</name>
          <displayName>PDMA_SAR4</displayName>
          <description>PDMA Channel x Source Address Register</description>
          <alternateRegister>PDMA_SAR0</alternateRegister>
          <addressOffset>0x4</addressOffset>
       </register>
       <register derivedFrom="PDMA_SAR0">
          <name>PDMA_SAR5</name>
          <displayName>PDMA_SAR5</displayName>
          <description>PDMA Channel x Source Address Register</description>
          <alternateRegister>PDMA_SAR0</alternateRegister>
          <addressOffset>0x4</addressOffset>
       </register>
       <register derivedFrom="PDMA_SAR0">
          <name>PDMA_SAR6</name>
          <displayName>PDMA_SAR6</displayName>
          <description>PDMA Channel x Source Address Register</description>
          <alternateRegister>PDMA_SAR0</alternateRegister>
          <addressOffset>0x4</addressOffset>
       </register>
       <register derivedFrom="PDMA_SAR0">
          <name>PDMA_SAR7</name>
          <displayName>PDMA_SAR7</displayName>
          <description>PDMA Channel x Source Address Register</description>
          <alternateRegister>PDMA_SAR0</alternateRegister>
          <addressOffset>0x4</addressOffset>
       </register>
       <register derivedFrom="PDMA_SAR0">
          <name>PDMA_SAR8</name>
          <displayName>PDMA_SAR8</displayName>
          <description>PDMA Channel x Source Address Register</description>
          <alternateRegister>PDMA_SAR0</alternateRegister>
          <addressOffset>0x4</addressOffset>
       </register>
       <register>
          <name>PDMA_DAR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_DAR0</displayName>
          <description>PDMA Channel x Destination Address Register</description>
          <addressOffset>0x8</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_DAR</name>
              <description>PDMA Transfer Destination Address Register\nThis field indicates a 32-bit destination address of PDMA.\nNote: The destination address must be word alignment</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PDMA_DAR0">
          <name>PDMA_DAR1</name>
          <displayName>PDMA_DAR1</displayName>
          <description>PDMA Channel x Destination Address Register</description>
          <alternateRegister>PDMA_DAR0</alternateRegister>
          <addressOffset>0x8</addressOffset>
       </register>
       <register derivedFrom="PDMA_DAR0">
          <name>PDMA_DAR2</name>
          <displayName>PDMA_DAR2</displayName>
          <description>PDMA Channel x Destination Address Register</description>
          <alternateRegister>PDMA_DAR0</alternateRegister>
          <addressOffset>0x8</addressOffset>
       </register>
       <register derivedFrom="PDMA_DAR0">
          <name>PDMA_DAR3</name>
          <displayName>PDMA_DAR3</displayName>
          <description>PDMA Channel x Destination Address Register</description>
          <alternateRegister>PDMA_DAR0</alternateRegister>
          <addressOffset>0x8</addressOffset>
       </register>
       <register derivedFrom="PDMA_DAR0">
          <name>PDMA_DAR4</name>
          <displayName>PDMA_DAR4</displayName>
          <description>PDMA Channel x Destination Address Register</description>
          <alternateRegister>PDMA_DAR0</alternateRegister>
          <addressOffset>0x8</addressOffset>
       </register>
       <register derivedFrom="PDMA_DAR0">
          <name>PDMA_DAR5</name>
          <displayName>PDMA_DAR5</displayName>
          <description>PDMA Channel x Destination Address Register</description>
          <alternateRegister>PDMA_DAR0</alternateRegister>
          <addressOffset>0x8</addressOffset>
       </register>
       <register derivedFrom="PDMA_DAR0">
          <name>PDMA_DAR6</name>
          <displayName>PDMA_DAR6</displayName>
          <description>PDMA Channel x Destination Address Register</description>
          <alternateRegister>PDMA_DAR0</alternateRegister>
          <addressOffset>0x8</addressOffset>
       </register>
       <register derivedFrom="PDMA_DAR0">
          <name>PDMA_DAR7</name>
          <displayName>PDMA_DAR7</displayName>
          <description>PDMA Channel x Destination Address Register</description>
          <alternateRegister>PDMA_DAR0</alternateRegister>
          <addressOffset>0x8</addressOffset>
       </register>
       <register derivedFrom="PDMA_DAR0">
          <name>PDMA_DAR8</name>
          <displayName>PDMA_DAR8</displayName>
          <description>PDMA Channel x Destination Address Register</description>
          <alternateRegister>PDMA_DAR0</alternateRegister>
          <addressOffset>0x8</addressOffset>
       </register>
       <register>
          <name>PDMA_BCR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_BCR0</displayName>
          <description>PDMA Channel x Transfer Byte Count Register</description>
          <addressOffset>0xC</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_BCR</name>
              <description>PDMA Transfer Byte Count Register\nThis field indicates a 16-bit transfer byte count number of PDMA; it must be word alignment.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PDMA_BCR0">
          <name>PDMA_BCR1</name>
          <displayName>PDMA_BCR1</displayName>
          <description>PDMA Channel x Transfer Byte Count Register</description>
          <alternateRegister>PDMA_BCR0</alternateRegister>
          <addressOffset>0xC</addressOffset>
       </register>
       <register derivedFrom="PDMA_BCR0">
          <name>PDMA_BCR2</name>
          <displayName>PDMA_BCR2</displayName>
          <description>PDMA Channel x Transfer Byte Count Register</description>
          <alternateRegister>PDMA_BCR0</alternateRegister>
          <addressOffset>0xC</addressOffset>
       </register>
       <register derivedFrom="PDMA_BCR0">
          <name>PDMA_BCR3</name>
          <displayName>PDMA_BCR3</displayName>
          <description>PDMA Channel x Transfer Byte Count Register</description>
          <alternateRegister>PDMA_BCR0</alternateRegister>
          <addressOffset>0xC</addressOffset>
       </register>
       <register derivedFrom="PDMA_BCR0">
          <name>PDMA_BCR4</name>
          <displayName>PDMA_BCR4</displayName>
          <description>PDMA Channel x Transfer Byte Count Register</description>
          <alternateRegister>PDMA_BCR0</alternateRegister>
          <addressOffset>0xC</addressOffset>
       </register>
       <register derivedFrom="PDMA_BCR0">
          <name>PDMA_BCR5</name>
          <displayName>PDMA_BCR5</displayName>
          <description>PDMA Channel x Transfer Byte Count Register</description>
          <alternateRegister>PDMA_BCR0</alternateRegister>
          <addressOffset>0xC</addressOffset>
       </register>
       <register derivedFrom="PDMA_BCR0">
          <name>PDMA_BCR6</name>
          <displayName>PDMA_BCR6</displayName>
          <description>PDMA Channel x Transfer Byte Count Register</description>
          <alternateRegister>PDMA_BCR0</alternateRegister>
          <addressOffset>0xC</addressOffset>
       </register>
       <register derivedFrom="PDMA_BCR0">
          <name>PDMA_BCR7</name>
          <displayName>PDMA_BCR7</displayName>
          <description>PDMA Channel x Transfer Byte Count Register</description>
          <alternateRegister>PDMA_BCR0</alternateRegister>
          <addressOffset>0xC</addressOffset>
       </register>
       <register derivedFrom="PDMA_BCR0">
          <name>PDMA_BCR8</name>
          <displayName>PDMA_BCR8</displayName>
          <description>PDMA Channel x Transfer Byte Count Register</description>
          <alternateRegister>PDMA_BCR0</alternateRegister>
          <addressOffset>0xC</addressOffset>
       </register>
       <register>
          <name>PDMA_POINT0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_POINT0</displayName>
          <description>PDMA Channel x Internal Buffer Pointer Register</description>
          <addressOffset>0x10</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_POINT</name>
              <description>PDMA Internal Buffer Pointer Register (Read Only)\nThis field indicates the internal buffer pointer.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PDMA_POINT0">
          <name>PDMA_POINT1</name>
          <displayName>PDMA_POINT1</displayName>
          <description>PDMA Channel x Internal Buffer Pointer Register</description>
          <alternateRegister>PDMA_POINT0</alternateRegister>
          <addressOffset>0x10</addressOffset>
       </register>
       <register derivedFrom="PDMA_POINT0">
          <name>PDMA_POINT2</name>
          <displayName>PDMA_POINT2</displayName>
          <description>PDMA Channel x Internal Buffer Pointer Register</description>
          <alternateRegister>PDMA_POINT0</alternateRegister>
          <addressOffset>0x10</addressOffset>
       </register>
       <register derivedFrom="PDMA_POINT0">
          <name>PDMA_POINT3</name>
          <displayName>PDMA_POINT3</displayName>
          <description>PDMA Channel x Internal Buffer Pointer Register</description>
          <alternateRegister>PDMA_POINT0</alternateRegister>
          <addressOffset>0x10</addressOffset>
       </register>
       <register derivedFrom="PDMA_POINT0">
          <name>PDMA_POINT4</name>
          <displayName>PDMA_POINT4</displayName>
          <description>PDMA Channel x Internal Buffer Pointer Register</description>
          <alternateRegister>PDMA_POINT0</alternateRegister>
          <addressOffset>0x10</addressOffset>
       </register>
       <register derivedFrom="PDMA_POINT0">
          <name>PDMA_POINT5</name>
          <displayName>PDMA_POINT5</displayName>
          <description>PDMA Channel x Internal Buffer Pointer Register</description>
          <alternateRegister>PDMA_POINT0</alternateRegister>
          <addressOffset>0x10</addressOffset>
       </register>
       <register derivedFrom="PDMA_POINT0">
          <name>PDMA_POINT6</name>
          <displayName>PDMA_POINT6</displayName>
          <description>PDMA Channel x Internal Buffer Pointer Register</description>
          <alternateRegister>PDMA_POINT0</alternateRegister>
          <addressOffset>0x10</addressOffset>
       </register>
       <register derivedFrom="PDMA_POINT0">
          <name>PDMA_POINT7</name>
          <displayName>PDMA_POINT7</displayName>
          <description>PDMA Channel x Internal Buffer Pointer Register</description>
          <alternateRegister>PDMA_POINT0</alternateRegister>
          <addressOffset>0x10</addressOffset>
       </register>
       <register derivedFrom="PDMA_POINT0">
          <name>PDMA_POINT8</name>
          <displayName>PDMA_POINT8</displayName>
          <description>PDMA Channel x Internal Buffer Pointer Register</description>
          <alternateRegister>PDMA_POINT0</alternateRegister>
          <addressOffset>0x10</addressOffset>
       </register>
       <register>
          <name>PDMA_CSAR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_CSAR0</displayName>
          <description>PDMA Channel x Current Source Address Register</description>
          <addressOffset>0x14</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_CSAR</name>
              <description>PDMA Current Source Address Register (Read Only)\nThis field indicates the source address where the PDMA transfer just occurred.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PDMA_CSAR0">
          <name>PDMA_CSAR1</name>
          <displayName>PDMA_CSAR1</displayName>
          <description>PDMA Channel x Current Source Address Register</description>
          <alternateRegister>PDMA_CSAR0</alternateRegister>
          <addressOffset>0x14</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSAR0">
          <name>PDMA_CSAR2</name>
          <displayName>PDMA_CSAR2</displayName>
          <description>PDMA Channel x Current Source Address Register</description>
          <alternateRegister>PDMA_CSAR0</alternateRegister>
          <addressOffset>0x14</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSAR0">
          <name>PDMA_CSAR3</name>
          <displayName>PDMA_CSAR3</displayName>
          <description>PDMA Channel x Current Source Address Register</description>
          <alternateRegister>PDMA_CSAR0</alternateRegister>
          <addressOffset>0x14</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSAR0">
          <name>PDMA_CSAR4</name>
          <displayName>PDMA_CSAR4</displayName>
          <description>PDMA Channel x Current Source Address Register</description>
          <alternateRegister>PDMA_CSAR0</alternateRegister>
          <addressOffset>0x14</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSAR0">
          <name>PDMA_CSAR5</name>
          <displayName>PDMA_CSAR5</displayName>
          <description>PDMA Channel x Current Source Address Register</description>
          <alternateRegister>PDMA_CSAR0</alternateRegister>
          <addressOffset>0x14</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSAR0">
          <name>PDMA_CSAR6</name>
          <displayName>PDMA_CSAR6</displayName>
          <description>PDMA Channel x Current Source Address Register</description>
          <alternateRegister>PDMA_CSAR0</alternateRegister>
          <addressOffset>0x14</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSAR0">
          <name>PDMA_CSAR7</name>
          <displayName>PDMA_CSAR7</displayName>
          <description>PDMA Channel x Current Source Address Register</description>
          <alternateRegister>PDMA_CSAR0</alternateRegister>
          <addressOffset>0x14</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSAR0">
          <name>PDMA_CSAR8</name>
          <displayName>PDMA_CSAR8</displayName>
          <description>PDMA Channel x Current Source Address Register</description>
          <alternateRegister>PDMA_CSAR0</alternateRegister>
          <addressOffset>0x14</addressOffset>
       </register>
       <register>
          <name>PDMA_CDAR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_CDAR0</displayName>
          <description>PDMA Channel x Current Destination Address Register</description>
          <addressOffset>0x18</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_CDAR</name>
              <description>PDMA Current Destination Address Register (Read Only)\nThis field indicates the destination address where the PDMA transfer just occurred.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PDMA_CDAR0">
          <name>PDMA_CDAR1</name>
          <displayName>PDMA_CDAR1</displayName>
          <description>PDMA Channel x Current Destination Address Register</description>
          <alternateRegister>PDMA_CDAR0</alternateRegister>
          <addressOffset>0x18</addressOffset>
       </register>
       <register derivedFrom="PDMA_CDAR0">
          <name>PDMA_CDAR2</name>
          <displayName>PDMA_CDAR2</displayName>
          <description>PDMA Channel x Current Destination Address Register</description>
          <alternateRegister>PDMA_CDAR0</alternateRegister>
          <addressOffset>0x18</addressOffset>
       </register>
       <register derivedFrom="PDMA_CDAR0">
          <name>PDMA_CDAR3</name>
          <displayName>PDMA_CDAR3</displayName>
          <description>PDMA Channel x Current Destination Address Register</description>
          <alternateRegister>PDMA_CDAR0</alternateRegister>
          <addressOffset>0x18</addressOffset>
       </register>
       <register derivedFrom="PDMA_CDAR0">
          <name>PDMA_CDAR4</name>
          <displayName>PDMA_CDAR4</displayName>
          <description>PDMA Channel x Current Destination Address Register</description>
          <alternateRegister>PDMA_CDAR0</alternateRegister>
          <addressOffset>0x18</addressOffset>
       </register>
       <register derivedFrom="PDMA_CDAR0">
          <name>PDMA_CDAR5</name>
          <displayName>PDMA_CDAR5</displayName>
          <description>PDMA Channel x Current Destination Address Register</description>
          <alternateRegister>PDMA_CDAR0</alternateRegister>
          <addressOffset>0x18</addressOffset>
       </register>
       <register derivedFrom="PDMA_CDAR0">
          <name>PDMA_CDAR6</name>
          <displayName>PDMA_CDAR6</displayName>
          <description>PDMA Channel x Current Destination Address Register</description>
          <alternateRegister>PDMA_CDAR0</alternateRegister>
          <addressOffset>0x18</addressOffset>
       </register>
       <register derivedFrom="PDMA_CDAR0">
          <name>PDMA_CDAR7</name>
          <displayName>PDMA_CDAR7</displayName>
          <description>PDMA Channel x Current Destination Address Register</description>
          <alternateRegister>PDMA_CDAR0</alternateRegister>
          <addressOffset>0x18</addressOffset>
       </register>
       <register derivedFrom="PDMA_CDAR0">
          <name>PDMA_CDAR8</name>
          <displayName>PDMA_CDAR8</displayName>
          <description>PDMA Channel x Current Destination Address Register</description>
          <alternateRegister>PDMA_CDAR0</alternateRegister>
          <addressOffset>0x18</addressOffset>
       </register>
       <register>
          <name>PDMA_CBCR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_CBCR0</displayName>
          <description>PDMA Channel x Current Transfer Byte Count Register</description>
          <addressOffset>0x1C</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_CBCR</name>
              <description>PDMA Current Byte Count Register (Read Only)\nThis field indicates the current remained byte count of PDMA.\nNote: This field value will be cleared to 0, when software set SW_RST (PDMA_CSRx[1]) to "1".</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PDMA_CBCR0">
          <name>PDMA_CBCR1</name>
          <displayName>PDMA_CBCR1</displayName>
          <description>PDMA Channel x Current Transfer Byte Count Register</description>
          <alternateRegister>PDMA_CBCR0</alternateRegister>
          <addressOffset>0x1C</addressOffset>
       </register>
       <register derivedFrom="PDMA_CBCR0">
          <name>PDMA_CBCR2</name>
          <displayName>PDMA_CBCR2</displayName>
          <description>PDMA Channel x Current Transfer Byte Count Register</description>
          <alternateRegister>PDMA_CBCR0</alternateRegister>
          <addressOffset>0x1C</addressOffset>
       </register>
       <register derivedFrom="PDMA_CBCR0">
          <name>PDMA_CBCR3</name>
          <displayName>PDMA_CBCR3</displayName>
          <description>PDMA Channel x Current Transfer Byte Count Register</description>
          <alternateRegister>PDMA_CBCR0</alternateRegister>
          <addressOffset>0x1C</addressOffset>
       </register>
       <register derivedFrom="PDMA_CBCR0">
          <name>PDMA_CBCR4</name>
          <displayName>PDMA_CBCR4</displayName>
          <description>PDMA Channel x Current Transfer Byte Count Register</description>
          <alternateRegister>PDMA_CBCR0</alternateRegister>
          <addressOffset>0x1C</addressOffset>
       </register>
       <register derivedFrom="PDMA_CBCR0">
          <name>PDMA_CBCR5</name>
          <displayName>PDMA_CBCR5</displayName>
          <description>PDMA Channel x Current Transfer Byte Count Register</description>
          <alternateRegister>PDMA_CBCR0</alternateRegister>
          <addressOffset>0x1C</addressOffset>
       </register>
       <register derivedFrom="PDMA_CBCR0">
          <name>PDMA_CBCR6</name>
          <displayName>PDMA_CBCR6</displayName>
          <description>PDMA Channel x Current Transfer Byte Count Register</description>
          <alternateRegister>PDMA_CBCR0</alternateRegister>
          <addressOffset>0x1C</addressOffset>
       </register>
       <register derivedFrom="PDMA_CBCR0">
          <name>PDMA_CBCR7</name>
          <displayName>PDMA_CBCR7</displayName>
          <description>PDMA Channel x Current Transfer Byte Count Register</description>
          <alternateRegister>PDMA_CBCR0</alternateRegister>
          <addressOffset>0x1C</addressOffset>
       </register>
       <register derivedFrom="PDMA_CBCR0">
          <name>PDMA_CBCR8</name>
          <displayName>PDMA_CBCR8</displayName>
          <description>PDMA Channel x Current Transfer Byte Count Register</description>
          <alternateRegister>PDMA_CBCR0</alternateRegister>
          <addressOffset>0x1C</addressOffset>
       </register>
       <register>
          <name>PDMA_IER0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_IER0</displayName>
          <description>PDMA Channel x Interrupt Enable Register</description>
          <addressOffset>0x20</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000001</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TABORT_IE</name>
              <description>PDMA Read/Write Target Abort Interrupt Enable Bit\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Target abort interrupt generation Disabled during PDMA transfer</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Target abort interrupt generation Enabled during PDMA transfer</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BLKD_IE</name>
              <description>PDMA Block Transfer Done Interrupt Enable Bit\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Interrupt generator Disabled when PDMA transfer is done</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Interrupt generator Enabled when PDMA transfer is done</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PDMA_IER0">
          <name>PDMA_IER1</name>
          <displayName>PDMA_IER1</displayName>
          <description>PDMA Channel x Interrupt Enable Register</description>
          <alternateRegister>PDMA_IER0</alternateRegister>
          <addressOffset>0x20</addressOffset>
       </register>
       <register derivedFrom="PDMA_IER0">
          <name>PDMA_IER2</name>
          <displayName>PDMA_IER2</displayName>
          <description>PDMA Channel x Interrupt Enable Register</description>
          <alternateRegister>PDMA_IER0</alternateRegister>
          <addressOffset>0x20</addressOffset>
       </register>
       <register derivedFrom="PDMA_IER0">
          <name>PDMA_IER3</name>
          <displayName>PDMA_IER3</displayName>
          <description>PDMA Channel x Interrupt Enable Register</description>
          <alternateRegister>PDMA_IER0</alternateRegister>
          <addressOffset>0x20</addressOffset>
       </register>
       <register derivedFrom="PDMA_IER0">
          <name>PDMA_IER4</name>
          <displayName>PDMA_IER4</displayName>
          <description>PDMA Channel x Interrupt Enable Register</description>
          <alternateRegister>PDMA_IER0</alternateRegister>
          <addressOffset>0x20</addressOffset>
       </register>
       <register derivedFrom="PDMA_IER0">
          <name>PDMA_IER5</name>
          <displayName>PDMA_IER5</displayName>
          <description>PDMA Channel x Interrupt Enable Register</description>
          <alternateRegister>PDMA_IER0</alternateRegister>
          <addressOffset>0x20</addressOffset>
       </register>
       <register derivedFrom="PDMA_IER0">
          <name>PDMA_IER6</name>
          <displayName>PDMA_IER6</displayName>
          <description>PDMA Channel x Interrupt Enable Register</description>
          <alternateRegister>PDMA_IER0</alternateRegister>
          <addressOffset>0x20</addressOffset>
       </register>
       <register derivedFrom="PDMA_IER0">
          <name>PDMA_IER7</name>
          <displayName>PDMA_IER7</displayName>
          <description>PDMA Channel x Interrupt Enable Register</description>
          <alternateRegister>PDMA_IER0</alternateRegister>
          <addressOffset>0x20</addressOffset>
       </register>
       <register derivedFrom="PDMA_IER0">
          <name>PDMA_IER8</name>
          <displayName>PDMA_IER8</displayName>
          <description>PDMA Channel x Interrupt Enable Register</description>
          <alternateRegister>PDMA_IER0</alternateRegister>
          <addressOffset>0x20</addressOffset>
       </register>
       <register>
          <name>PDMA_ISR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_ISR0</displayName>
          <description>PDMA Channel x Interrupt Status Register</description>
          <addressOffset>0x24</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TABORT_IF</name>
              <description>PDMA Read/Write Target Abort Interrupt Flag\nWrite 1 to clear this bit to 0.\nNote: This bit filed indicates bus master received ERROR response or not. If bus master received ERROR response, it means that target abort is happened. PDMA controller will stop transfer and respond this event to software then goes to IDLE state. When target abort occurred, software must reset PDMA, and then transfer those data again.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No bus ERROR response received</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Bus ERROR response received</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BLKD_IF</name>
              <description>PDMA Block Transfer Done Interrupt Flag\nThis bit indicates that PDMA has finished all transfers.\nWrite 1 to clear this bit to 0.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Not finished</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Done</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PDMA_ISR0">
          <name>PDMA_ISR1</name>
          <displayName>PDMA_ISR1</displayName>
          <description>PDMA Channel x Interrupt Status Register</description>
          <alternateRegister>PDMA_ISR0</alternateRegister>
          <addressOffset>0x24</addressOffset>
       </register>
       <register derivedFrom="PDMA_ISR0">
          <name>PDMA_ISR2</name>
          <displayName>PDMA_ISR2</displayName>
          <description>PDMA Channel x Interrupt Status Register</description>
          <alternateRegister>PDMA_ISR0</alternateRegister>
          <addressOffset>0x24</addressOffset>
       </register>
       <register derivedFrom="PDMA_ISR0">
          <name>PDMA_ISR3</name>
          <displayName>PDMA_ISR3</displayName>
          <description>PDMA Channel x Interrupt Status Register</description>
          <alternateRegister>PDMA_ISR0</alternateRegister>
          <addressOffset>0x24</addressOffset>
       </register>
       <register derivedFrom="PDMA_ISR0">
          <name>PDMA_ISR4</name>
          <displayName>PDMA_ISR4</displayName>
          <description>PDMA Channel x Interrupt Status Register</description>
          <alternateRegister>PDMA_ISR0</alternateRegister>
          <addressOffset>0x24</addressOffset>
       </register>
       <register derivedFrom="PDMA_ISR0">
          <name>PDMA_ISR5</name>
          <displayName>PDMA_ISR5</displayName>
          <description>PDMA Channel x Interrupt Status Register</description>
          <alternateRegister>PDMA_ISR0</alternateRegister>
          <addressOffset>0x24</addressOffset>
       </register>
       <register derivedFrom="PDMA_ISR0">
          <name>PDMA_ISR6</name>
          <displayName>PDMA_ISR6</displayName>
          <description>PDMA Channel x Interrupt Status Register</description>
          <alternateRegister>PDMA_ISR0</alternateRegister>
          <addressOffset>0x24</addressOffset>
       </register>
       <register derivedFrom="PDMA_ISR0">
          <name>PDMA_ISR7</name>
          <displayName>PDMA_ISR7</displayName>
          <description>PDMA Channel x Interrupt Status Register</description>
          <alternateRegister>PDMA_ISR0</alternateRegister>
          <addressOffset>0x24</addressOffset>
       </register>
       <register derivedFrom="PDMA_ISR0">
          <name>PDMA_ISR8</name>
          <displayName>PDMA_ISR8</displayName>
          <description>PDMA Channel x Interrupt Status Register</description>
          <alternateRegister>PDMA_ISR0</alternateRegister>
          <addressOffset>0x24</addressOffset>
       </register>
       <register>
          <name>PDMA_SBUF0_C0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_SBUF0_C0</displayName>
          <description>PDMA Channel x Shared Buffer FIFO 0 Register</description>
          <addressOffset>0x80</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_SBUF0</name>
              <description>PDMA Shared Buffer FIFO 0 (Read Only)\nEach channel has its own 1 word internal buffer.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PDMA_SBUF0_C0">
          <name>PDMA_SBUF0_C1</name>
          <displayName>PDMA_SBUF0_C1</displayName>
          <description>PDMA Channel x Shared Buffer FIFO 0 Register</description>
          <alternateRegister>PDMA_SBUF0_C0</alternateRegister>
          <addressOffset>0x80</addressOffset>
       </register>
       <register derivedFrom="PDMA_SBUF0_C0">
          <name>PDMA_SBUF0_C2</name>
          <displayName>PDMA_SBUF0_C2</displayName>
          <description>PDMA Channel x Shared Buffer FIFO 0 Register</description>
          <alternateRegister>PDMA_SBUF0_C0</alternateRegister>
          <addressOffset>0x80</addressOffset>
       </register>
       <register derivedFrom="PDMA_SBUF0_C0">
          <name>PDMA_SBUF0_C3</name>
          <displayName>PDMA_SBUF0_C3</displayName>
          <description>PDMA Channel x Shared Buffer FIFO 0 Register</description>
          <alternateRegister>PDMA_SBUF0_C0</alternateRegister>
          <addressOffset>0x80</addressOffset>
       </register>
       <register derivedFrom="PDMA_SBUF0_C0">
          <name>PDMA_SBUF0_C4</name>
          <displayName>PDMA_SBUF0_C4</displayName>
          <description>PDMA Channel x Shared Buffer FIFO 0 Register</description>
          <alternateRegister>PDMA_SBUF0_C0</alternateRegister>
          <addressOffset>0x80</addressOffset>
       </register>
       <register derivedFrom="PDMA_SBUF0_C0">
          <name>PDMA_SBUF0_C5</name>
          <displayName>PDMA_SBUF0_C5</displayName>
          <description>PDMA Channel x Shared Buffer FIFO 0 Register</description>
          <alternateRegister>PDMA_SBUF0_C0</alternateRegister>
          <addressOffset>0x80</addressOffset>
       </register>
       <register derivedFrom="PDMA_SBUF0_C0">
          <name>PDMA_SBUF0_C6</name>
          <displayName>PDMA_SBUF0_C6</displayName>
          <description>PDMA Channel x Shared Buffer FIFO 0 Register</description>
          <alternateRegister>PDMA_SBUF0_C0</alternateRegister>
          <addressOffset>0x80</addressOffset>
       </register>
       <register derivedFrom="PDMA_SBUF0_C0">
          <name>PDMA_SBUF0_C7</name>
          <displayName>PDMA_SBUF0_C7</displayName>
          <description>PDMA Channel x Shared Buffer FIFO 0 Register</description>
          <alternateRegister>PDMA_SBUF0_C0</alternateRegister>
          <addressOffset>0x80</addressOffset>
       </register>
       <register derivedFrom="PDMA_SBUF0_C0">
          <name>PDMA_SBUF0_C8</name>
          <displayName>PDMA_SBUF0_C8</displayName>
          <description>PDMA Channel x Shared Buffer FIFO 0 Register</description>
          <alternateRegister>PDMA_SBUF0_C0</alternateRegister>
          <addressOffset>0x80</addressOffset>
       </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>PDMA_CH5</name>
      <description>PDMA Register Map</description>
      <groupName>PDMA</groupName>
      <baseAddress>0x50008500</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x0</offset>
        <size>0x28</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x80</offset>
        <size>0x4</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>PDMA_CSR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_CSR0</displayName>
          <description>PDMA Channel x Control Register</description>
          <addressOffset>0x0</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMACEN</name>
              <description>PDMA Channel Enable Bit\nSetting this bit to 1 enables PDMA operation. If this bit is cleared, PDMA will ignore all PDMA request and force Bus Master into IDLE state.\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_RST</name>
              <description>Software Engine Reset\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reset the internal state machine, pointers and internal buffer. The contents of control register will not be cleared. This bit will be automatically cleared after few clock cycles</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>MODE_SEL</name>
              <description>PDMA Mode Selection\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Memory to Memory mode (Memory-to-Memory)</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Peripheral to Memory mode (Peripheral-to-Memory)</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Memory to Peripheral mode (Memory-to-Peripheral)</description>
                    <value>#10</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SAD_SEL</name>
              <description>Transfer Source Address Direction Selection\n</description>
              <bitOffset>4</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Transfer source address is increasing successively</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reserved</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Transfer source address is fixed (This feature can be used when data where transferred from a single source to multiple destinations)</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Reserved</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DAD_SEL</name>
              <description>Transfer Destination Address Direction Selection\n</description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Transfer destination address is increasing successively</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reserved</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Transfer destination address is fixed. (This feature can be used when data where transferred from multiple sources to a single destination)</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Reserved</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>APB_TWS</name>
              <description>Peripheral Transfer Width Selection\nNote: This field is meaningful only when MODE_SEL (PDMA_CSRx[3:2]) is Peripheral to Memory mode (Peripheral-to-Memory) or Memory to Peripheral mode (Memory-to-Peripheral).</description>
              <bitOffset>19</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>One word (32-bit) is transferred for every PDMA operation</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>One byte (8-bit) is transferred for every PDMA operation</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>One half-word (16-bit) is transferred for every PDMA operation</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Reserved</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TRIG_EN</name>
              <description>Trigger Enable Bit\nNote: When PDMA transfer completed, this bit will be cleared automatically.\nIf the bus error occurs, all PDMA transfer will be stopped. Software must reset all PDMA channel, and then trigger again.</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PDMA data read or write transfer Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PDMA_CSR0">
          <name>PDMA_CSR1</name>
          <displayName>PDMA_CSR1</displayName>
          <description>PDMA Channel x Control Register</description>
          <alternateRegister>PDMA_CSR0</alternateRegister>
          <addressOffset>0x0</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSR0">
          <name>PDMA_CSR2</name>
          <displayName>PDMA_CSR2</displayName>
          <description>PDMA Channel x Control Register</description>
          <alternateRegister>PDMA_CSR0</alternateRegister>
          <addressOffset>0x0</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSR0">
          <name>PDMA_CSR3</name>
          <displayName>PDMA_CSR3</displayName>
          <description>PDMA Channel x Control Register</description>
          <alternateRegister>PDMA_CSR0</alternateRegister>
          <addressOffset>0x0</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSR0">
          <name>PDMA_CSR4</name>
          <displayName>PDMA_CSR4</displayName>
          <description>PDMA Channel x Control Register</description>
          <alternateRegister>PDMA_CSR0</alternateRegister>
          <addressOffset>0x0</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSR0">
          <name>PDMA_CSR5</name>
          <displayName>PDMA_CSR5</displayName>
          <description>PDMA Channel x Control Register</description>
          <alternateRegister>PDMA_CSR0</alternateRegister>
          <addressOffset>0x0</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSR0">
          <name>PDMA_CSR6</name>
          <displayName>PDMA_CSR6</displayName>
          <description>PDMA Channel x Control Register</description>
          <alternateRegister>PDMA_CSR0</alternateRegister>
          <addressOffset>0x0</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSR0">
          <name>PDMA_CSR7</name>
          <displayName>PDMA_CSR7</displayName>
          <description>PDMA Channel x Control Register</description>
          <alternateRegister>PDMA_CSR0</alternateRegister>
          <addressOffset>0x0</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSR0">
          <name>PDMA_CSR8</name>
          <displayName>PDMA_CSR8</displayName>
          <description>PDMA Channel x Control Register</description>
          <alternateRegister>PDMA_CSR0</alternateRegister>
          <addressOffset>0x0</addressOffset>
       </register>
       <register>
          <name>PDMA_SAR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_SAR0</displayName>
          <description>PDMA Channel x Source Address Register</description>
          <addressOffset>0x4</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_SAR</name>
              <description>PDMA Transfer Source Address Register\nThis field indicates a 32-bit source address of PDMA.\nNote: The source address must be word alignment.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PDMA_SAR0">
          <name>PDMA_SAR1</name>
          <displayName>PDMA_SAR1</displayName>
          <description>PDMA Channel x Source Address Register</description>
          <alternateRegister>PDMA_SAR0</alternateRegister>
          <addressOffset>0x4</addressOffset>
       </register>
       <register derivedFrom="PDMA_SAR0">
          <name>PDMA_SAR2</name>
          <displayName>PDMA_SAR2</displayName>
          <description>PDMA Channel x Source Address Register</description>
          <alternateRegister>PDMA_SAR0</alternateRegister>
          <addressOffset>0x4</addressOffset>
       </register>
       <register derivedFrom="PDMA_SAR0">
          <name>PDMA_SAR3</name>
          <displayName>PDMA_SAR3</displayName>
          <description>PDMA Channel x Source Address Register</description>
          <alternateRegister>PDMA_SAR0</alternateRegister>
          <addressOffset>0x4</addressOffset>
       </register>
       <register derivedFrom="PDMA_SAR0">
          <name>PDMA_SAR4</name>
          <displayName>PDMA_SAR4</displayName>
          <description>PDMA Channel x Source Address Register</description>
          <alternateRegister>PDMA_SAR0</alternateRegister>
          <addressOffset>0x4</addressOffset>
       </register>
       <register derivedFrom="PDMA_SAR0">
          <name>PDMA_SAR5</name>
          <displayName>PDMA_SAR5</displayName>
          <description>PDMA Channel x Source Address Register</description>
          <alternateRegister>PDMA_SAR0</alternateRegister>
          <addressOffset>0x4</addressOffset>
       </register>
       <register derivedFrom="PDMA_SAR0">
          <name>PDMA_SAR6</name>
          <displayName>PDMA_SAR6</displayName>
          <description>PDMA Channel x Source Address Register</description>
          <alternateRegister>PDMA_SAR0</alternateRegister>
          <addressOffset>0x4</addressOffset>
       </register>
       <register derivedFrom="PDMA_SAR0">
          <name>PDMA_SAR7</name>
          <displayName>PDMA_SAR7</displayName>
          <description>PDMA Channel x Source Address Register</description>
          <alternateRegister>PDMA_SAR0</alternateRegister>
          <addressOffset>0x4</addressOffset>
       </register>
       <register derivedFrom="PDMA_SAR0">
          <name>PDMA_SAR8</name>
          <displayName>PDMA_SAR8</displayName>
          <description>PDMA Channel x Source Address Register</description>
          <alternateRegister>PDMA_SAR0</alternateRegister>
          <addressOffset>0x4</addressOffset>
       </register>
       <register>
          <name>PDMA_DAR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_DAR0</displayName>
          <description>PDMA Channel x Destination Address Register</description>
          <addressOffset>0x8</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_DAR</name>
              <description>PDMA Transfer Destination Address Register\nThis field indicates a 32-bit destination address of PDMA.\nNote: The destination address must be word alignment</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PDMA_DAR0">
          <name>PDMA_DAR1</name>
          <displayName>PDMA_DAR1</displayName>
          <description>PDMA Channel x Destination Address Register</description>
          <alternateRegister>PDMA_DAR0</alternateRegister>
          <addressOffset>0x8</addressOffset>
       </register>
       <register derivedFrom="PDMA_DAR0">
          <name>PDMA_DAR2</name>
          <displayName>PDMA_DAR2</displayName>
          <description>PDMA Channel x Destination Address Register</description>
          <alternateRegister>PDMA_DAR0</alternateRegister>
          <addressOffset>0x8</addressOffset>
       </register>
       <register derivedFrom="PDMA_DAR0">
          <name>PDMA_DAR3</name>
          <displayName>PDMA_DAR3</displayName>
          <description>PDMA Channel x Destination Address Register</description>
          <alternateRegister>PDMA_DAR0</alternateRegister>
          <addressOffset>0x8</addressOffset>
       </register>
       <register derivedFrom="PDMA_DAR0">
          <name>PDMA_DAR4</name>
          <displayName>PDMA_DAR4</displayName>
          <description>PDMA Channel x Destination Address Register</description>
          <alternateRegister>PDMA_DAR0</alternateRegister>
          <addressOffset>0x8</addressOffset>
       </register>
       <register derivedFrom="PDMA_DAR0">
          <name>PDMA_DAR5</name>
          <displayName>PDMA_DAR5</displayName>
          <description>PDMA Channel x Destination Address Register</description>
          <alternateRegister>PDMA_DAR0</alternateRegister>
          <addressOffset>0x8</addressOffset>
       </register>
       <register derivedFrom="PDMA_DAR0">
          <name>PDMA_DAR6</name>
          <displayName>PDMA_DAR6</displayName>
          <description>PDMA Channel x Destination Address Register</description>
          <alternateRegister>PDMA_DAR0</alternateRegister>
          <addressOffset>0x8</addressOffset>
       </register>
       <register derivedFrom="PDMA_DAR0">
          <name>PDMA_DAR7</name>
          <displayName>PDMA_DAR7</displayName>
          <description>PDMA Channel x Destination Address Register</description>
          <alternateRegister>PDMA_DAR0</alternateRegister>
          <addressOffset>0x8</addressOffset>
       </register>
       <register derivedFrom="PDMA_DAR0">
          <name>PDMA_DAR8</name>
          <displayName>PDMA_DAR8</displayName>
          <description>PDMA Channel x Destination Address Register</description>
          <alternateRegister>PDMA_DAR0</alternateRegister>
          <addressOffset>0x8</addressOffset>
       </register>
       <register>
          <name>PDMA_BCR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_BCR0</displayName>
          <description>PDMA Channel x Transfer Byte Count Register</description>
          <addressOffset>0xC</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_BCR</name>
              <description>PDMA Transfer Byte Count Register\nThis field indicates a 16-bit transfer byte count number of PDMA; it must be word alignment.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PDMA_BCR0">
          <name>PDMA_BCR1</name>
          <displayName>PDMA_BCR1</displayName>
          <description>PDMA Channel x Transfer Byte Count Register</description>
          <alternateRegister>PDMA_BCR0</alternateRegister>
          <addressOffset>0xC</addressOffset>
       </register>
       <register derivedFrom="PDMA_BCR0">
          <name>PDMA_BCR2</name>
          <displayName>PDMA_BCR2</displayName>
          <description>PDMA Channel x Transfer Byte Count Register</description>
          <alternateRegister>PDMA_BCR0</alternateRegister>
          <addressOffset>0xC</addressOffset>
       </register>
       <register derivedFrom="PDMA_BCR0">
          <name>PDMA_BCR3</name>
          <displayName>PDMA_BCR3</displayName>
          <description>PDMA Channel x Transfer Byte Count Register</description>
          <alternateRegister>PDMA_BCR0</alternateRegister>
          <addressOffset>0xC</addressOffset>
       </register>
       <register derivedFrom="PDMA_BCR0">
          <name>PDMA_BCR4</name>
          <displayName>PDMA_BCR4</displayName>
          <description>PDMA Channel x Transfer Byte Count Register</description>
          <alternateRegister>PDMA_BCR0</alternateRegister>
          <addressOffset>0xC</addressOffset>
       </register>
       <register derivedFrom="PDMA_BCR0">
          <name>PDMA_BCR5</name>
          <displayName>PDMA_BCR5</displayName>
          <description>PDMA Channel x Transfer Byte Count Register</description>
          <alternateRegister>PDMA_BCR0</alternateRegister>
          <addressOffset>0xC</addressOffset>
       </register>
       <register derivedFrom="PDMA_BCR0">
          <name>PDMA_BCR6</name>
          <displayName>PDMA_BCR6</displayName>
          <description>PDMA Channel x Transfer Byte Count Register</description>
          <alternateRegister>PDMA_BCR0</alternateRegister>
          <addressOffset>0xC</addressOffset>
       </register>
       <register derivedFrom="PDMA_BCR0">
          <name>PDMA_BCR7</name>
          <displayName>PDMA_BCR7</displayName>
          <description>PDMA Channel x Transfer Byte Count Register</description>
          <alternateRegister>PDMA_BCR0</alternateRegister>
          <addressOffset>0xC</addressOffset>
       </register>
       <register derivedFrom="PDMA_BCR0">
          <name>PDMA_BCR8</name>
          <displayName>PDMA_BCR8</displayName>
          <description>PDMA Channel x Transfer Byte Count Register</description>
          <alternateRegister>PDMA_BCR0</alternateRegister>
          <addressOffset>0xC</addressOffset>
       </register>
       <register>
          <name>PDMA_POINT0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_POINT0</displayName>
          <description>PDMA Channel x Internal Buffer Pointer Register</description>
          <addressOffset>0x10</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_POINT</name>
              <description>PDMA Internal Buffer Pointer Register (Read Only)\nThis field indicates the internal buffer pointer.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PDMA_POINT0">
          <name>PDMA_POINT1</name>
          <displayName>PDMA_POINT1</displayName>
          <description>PDMA Channel x Internal Buffer Pointer Register</description>
          <alternateRegister>PDMA_POINT0</alternateRegister>
          <addressOffset>0x10</addressOffset>
       </register>
       <register derivedFrom="PDMA_POINT0">
          <name>PDMA_POINT2</name>
          <displayName>PDMA_POINT2</displayName>
          <description>PDMA Channel x Internal Buffer Pointer Register</description>
          <alternateRegister>PDMA_POINT0</alternateRegister>
          <addressOffset>0x10</addressOffset>
       </register>
       <register derivedFrom="PDMA_POINT0">
          <name>PDMA_POINT3</name>
          <displayName>PDMA_POINT3</displayName>
          <description>PDMA Channel x Internal Buffer Pointer Register</description>
          <alternateRegister>PDMA_POINT0</alternateRegister>
          <addressOffset>0x10</addressOffset>
       </register>
       <register derivedFrom="PDMA_POINT0">
          <name>PDMA_POINT4</name>
          <displayName>PDMA_POINT4</displayName>
          <description>PDMA Channel x Internal Buffer Pointer Register</description>
          <alternateRegister>PDMA_POINT0</alternateRegister>
          <addressOffset>0x10</addressOffset>
       </register>
       <register derivedFrom="PDMA_POINT0">
          <name>PDMA_POINT5</name>
          <displayName>PDMA_POINT5</displayName>
          <description>PDMA Channel x Internal Buffer Pointer Register</description>
          <alternateRegister>PDMA_POINT0</alternateRegister>
          <addressOffset>0x10</addressOffset>
       </register>
       <register derivedFrom="PDMA_POINT0">
          <name>PDMA_POINT6</name>
          <displayName>PDMA_POINT6</displayName>
          <description>PDMA Channel x Internal Buffer Pointer Register</description>
          <alternateRegister>PDMA_POINT0</alternateRegister>
          <addressOffset>0x10</addressOffset>
       </register>
       <register derivedFrom="PDMA_POINT0">
          <name>PDMA_POINT7</name>
          <displayName>PDMA_POINT7</displayName>
          <description>PDMA Channel x Internal Buffer Pointer Register</description>
          <alternateRegister>PDMA_POINT0</alternateRegister>
          <addressOffset>0x10</addressOffset>
       </register>
       <register derivedFrom="PDMA_POINT0">
          <name>PDMA_POINT8</name>
          <displayName>PDMA_POINT8</displayName>
          <description>PDMA Channel x Internal Buffer Pointer Register</description>
          <alternateRegister>PDMA_POINT0</alternateRegister>
          <addressOffset>0x10</addressOffset>
       </register>
       <register>
          <name>PDMA_CSAR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_CSAR0</displayName>
          <description>PDMA Channel x Current Source Address Register</description>
          <addressOffset>0x14</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_CSAR</name>
              <description>PDMA Current Source Address Register (Read Only)\nThis field indicates the source address where the PDMA transfer just occurred.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PDMA_CSAR0">
          <name>PDMA_CSAR1</name>
          <displayName>PDMA_CSAR1</displayName>
          <description>PDMA Channel x Current Source Address Register</description>
          <alternateRegister>PDMA_CSAR0</alternateRegister>
          <addressOffset>0x14</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSAR0">
          <name>PDMA_CSAR2</name>
          <displayName>PDMA_CSAR2</displayName>
          <description>PDMA Channel x Current Source Address Register</description>
          <alternateRegister>PDMA_CSAR0</alternateRegister>
          <addressOffset>0x14</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSAR0">
          <name>PDMA_CSAR3</name>
          <displayName>PDMA_CSAR3</displayName>
          <description>PDMA Channel x Current Source Address Register</description>
          <alternateRegister>PDMA_CSAR0</alternateRegister>
          <addressOffset>0x14</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSAR0">
          <name>PDMA_CSAR4</name>
          <displayName>PDMA_CSAR4</displayName>
          <description>PDMA Channel x Current Source Address Register</description>
          <alternateRegister>PDMA_CSAR0</alternateRegister>
          <addressOffset>0x14</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSAR0">
          <name>PDMA_CSAR5</name>
          <displayName>PDMA_CSAR5</displayName>
          <description>PDMA Channel x Current Source Address Register</description>
          <alternateRegister>PDMA_CSAR0</alternateRegister>
          <addressOffset>0x14</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSAR0">
          <name>PDMA_CSAR6</name>
          <displayName>PDMA_CSAR6</displayName>
          <description>PDMA Channel x Current Source Address Register</description>
          <alternateRegister>PDMA_CSAR0</alternateRegister>
          <addressOffset>0x14</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSAR0">
          <name>PDMA_CSAR7</name>
          <displayName>PDMA_CSAR7</displayName>
          <description>PDMA Channel x Current Source Address Register</description>
          <alternateRegister>PDMA_CSAR0</alternateRegister>
          <addressOffset>0x14</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSAR0">
          <name>PDMA_CSAR8</name>
          <displayName>PDMA_CSAR8</displayName>
          <description>PDMA Channel x Current Source Address Register</description>
          <alternateRegister>PDMA_CSAR0</alternateRegister>
          <addressOffset>0x14</addressOffset>
       </register>
       <register>
          <name>PDMA_CDAR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_CDAR0</displayName>
          <description>PDMA Channel x Current Destination Address Register</description>
          <addressOffset>0x18</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_CDAR</name>
              <description>PDMA Current Destination Address Register (Read Only)\nThis field indicates the destination address where the PDMA transfer just occurred.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PDMA_CDAR0">
          <name>PDMA_CDAR1</name>
          <displayName>PDMA_CDAR1</displayName>
          <description>PDMA Channel x Current Destination Address Register</description>
          <alternateRegister>PDMA_CDAR0</alternateRegister>
          <addressOffset>0x18</addressOffset>
       </register>
       <register derivedFrom="PDMA_CDAR0">
          <name>PDMA_CDAR2</name>
          <displayName>PDMA_CDAR2</displayName>
          <description>PDMA Channel x Current Destination Address Register</description>
          <alternateRegister>PDMA_CDAR0</alternateRegister>
          <addressOffset>0x18</addressOffset>
       </register>
       <register derivedFrom="PDMA_CDAR0">
          <name>PDMA_CDAR3</name>
          <displayName>PDMA_CDAR3</displayName>
          <description>PDMA Channel x Current Destination Address Register</description>
          <alternateRegister>PDMA_CDAR0</alternateRegister>
          <addressOffset>0x18</addressOffset>
       </register>
       <register derivedFrom="PDMA_CDAR0">
          <name>PDMA_CDAR4</name>
          <displayName>PDMA_CDAR4</displayName>
          <description>PDMA Channel x Current Destination Address Register</description>
          <alternateRegister>PDMA_CDAR0</alternateRegister>
          <addressOffset>0x18</addressOffset>
       </register>
       <register derivedFrom="PDMA_CDAR0">
          <name>PDMA_CDAR5</name>
          <displayName>PDMA_CDAR5</displayName>
          <description>PDMA Channel x Current Destination Address Register</description>
          <alternateRegister>PDMA_CDAR0</alternateRegister>
          <addressOffset>0x18</addressOffset>
       </register>
       <register derivedFrom="PDMA_CDAR0">
          <name>PDMA_CDAR6</name>
          <displayName>PDMA_CDAR6</displayName>
          <description>PDMA Channel x Current Destination Address Register</description>
          <alternateRegister>PDMA_CDAR0</alternateRegister>
          <addressOffset>0x18</addressOffset>
       </register>
       <register derivedFrom="PDMA_CDAR0">
          <name>PDMA_CDAR7</name>
          <displayName>PDMA_CDAR7</displayName>
          <description>PDMA Channel x Current Destination Address Register</description>
          <alternateRegister>PDMA_CDAR0</alternateRegister>
          <addressOffset>0x18</addressOffset>
       </register>
       <register derivedFrom="PDMA_CDAR0">
          <name>PDMA_CDAR8</name>
          <displayName>PDMA_CDAR8</displayName>
          <description>PDMA Channel x Current Destination Address Register</description>
          <alternateRegister>PDMA_CDAR0</alternateRegister>
          <addressOffset>0x18</addressOffset>
       </register>
       <register>
          <name>PDMA_CBCR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_CBCR0</displayName>
          <description>PDMA Channel x Current Transfer Byte Count Register</description>
          <addressOffset>0x1C</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_CBCR</name>
              <description>PDMA Current Byte Count Register (Read Only)\nThis field indicates the current remained byte count of PDMA.\nNote: This field value will be cleared to 0, when software set SW_RST (PDMA_CSRx[1]) to "1".</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PDMA_CBCR0">
          <name>PDMA_CBCR1</name>
          <displayName>PDMA_CBCR1</displayName>
          <description>PDMA Channel x Current Transfer Byte Count Register</description>
          <alternateRegister>PDMA_CBCR0</alternateRegister>
          <addressOffset>0x1C</addressOffset>
       </register>
       <register derivedFrom="PDMA_CBCR0">
          <name>PDMA_CBCR2</name>
          <displayName>PDMA_CBCR2</displayName>
          <description>PDMA Channel x Current Transfer Byte Count Register</description>
          <alternateRegister>PDMA_CBCR0</alternateRegister>
          <addressOffset>0x1C</addressOffset>
       </register>
       <register derivedFrom="PDMA_CBCR0">
          <name>PDMA_CBCR3</name>
          <displayName>PDMA_CBCR3</displayName>
          <description>PDMA Channel x Current Transfer Byte Count Register</description>
          <alternateRegister>PDMA_CBCR0</alternateRegister>
          <addressOffset>0x1C</addressOffset>
       </register>
       <register derivedFrom="PDMA_CBCR0">
          <name>PDMA_CBCR4</name>
          <displayName>PDMA_CBCR4</displayName>
          <description>PDMA Channel x Current Transfer Byte Count Register</description>
          <alternateRegister>PDMA_CBCR0</alternateRegister>
          <addressOffset>0x1C</addressOffset>
       </register>
       <register derivedFrom="PDMA_CBCR0">
          <name>PDMA_CBCR5</name>
          <displayName>PDMA_CBCR5</displayName>
          <description>PDMA Channel x Current Transfer Byte Count Register</description>
          <alternateRegister>PDMA_CBCR0</alternateRegister>
          <addressOffset>0x1C</addressOffset>
       </register>
       <register derivedFrom="PDMA_CBCR0">
          <name>PDMA_CBCR6</name>
          <displayName>PDMA_CBCR6</displayName>
          <description>PDMA Channel x Current Transfer Byte Count Register</description>
          <alternateRegister>PDMA_CBCR0</alternateRegister>
          <addressOffset>0x1C</addressOffset>
       </register>
       <register derivedFrom="PDMA_CBCR0">
          <name>PDMA_CBCR7</name>
          <displayName>PDMA_CBCR7</displayName>
          <description>PDMA Channel x Current Transfer Byte Count Register</description>
          <alternateRegister>PDMA_CBCR0</alternateRegister>
          <addressOffset>0x1C</addressOffset>
       </register>
       <register derivedFrom="PDMA_CBCR0">
          <name>PDMA_CBCR8</name>
          <displayName>PDMA_CBCR8</displayName>
          <description>PDMA Channel x Current Transfer Byte Count Register</description>
          <alternateRegister>PDMA_CBCR0</alternateRegister>
          <addressOffset>0x1C</addressOffset>
       </register>
       <register>
          <name>PDMA_IER0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_IER0</displayName>
          <description>PDMA Channel x Interrupt Enable Register</description>
          <addressOffset>0x20</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000001</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TABORT_IE</name>
              <description>PDMA Read/Write Target Abort Interrupt Enable Bit\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Target abort interrupt generation Disabled during PDMA transfer</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Target abort interrupt generation Enabled during PDMA transfer</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BLKD_IE</name>
              <description>PDMA Block Transfer Done Interrupt Enable Bit\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Interrupt generator Disabled when PDMA transfer is done</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Interrupt generator Enabled when PDMA transfer is done</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PDMA_IER0">
          <name>PDMA_IER1</name>
          <displayName>PDMA_IER1</displayName>
          <description>PDMA Channel x Interrupt Enable Register</description>
          <alternateRegister>PDMA_IER0</alternateRegister>
          <addressOffset>0x20</addressOffset>
       </register>
       <register derivedFrom="PDMA_IER0">
          <name>PDMA_IER2</name>
          <displayName>PDMA_IER2</displayName>
          <description>PDMA Channel x Interrupt Enable Register</description>
          <alternateRegister>PDMA_IER0</alternateRegister>
          <addressOffset>0x20</addressOffset>
       </register>
       <register derivedFrom="PDMA_IER0">
          <name>PDMA_IER3</name>
          <displayName>PDMA_IER3</displayName>
          <description>PDMA Channel x Interrupt Enable Register</description>
          <alternateRegister>PDMA_IER0</alternateRegister>
          <addressOffset>0x20</addressOffset>
       </register>
       <register derivedFrom="PDMA_IER0">
          <name>PDMA_IER4</name>
          <displayName>PDMA_IER4</displayName>
          <description>PDMA Channel x Interrupt Enable Register</description>
          <alternateRegister>PDMA_IER0</alternateRegister>
          <addressOffset>0x20</addressOffset>
       </register>
       <register derivedFrom="PDMA_IER0">
          <name>PDMA_IER5</name>
          <displayName>PDMA_IER5</displayName>
          <description>PDMA Channel x Interrupt Enable Register</description>
          <alternateRegister>PDMA_IER0</alternateRegister>
          <addressOffset>0x20</addressOffset>
       </register>
       <register derivedFrom="PDMA_IER0">
          <name>PDMA_IER6</name>
          <displayName>PDMA_IER6</displayName>
          <description>PDMA Channel x Interrupt Enable Register</description>
          <alternateRegister>PDMA_IER0</alternateRegister>
          <addressOffset>0x20</addressOffset>
       </register>
       <register derivedFrom="PDMA_IER0">
          <name>PDMA_IER7</name>
          <displayName>PDMA_IER7</displayName>
          <description>PDMA Channel x Interrupt Enable Register</description>
          <alternateRegister>PDMA_IER0</alternateRegister>
          <addressOffset>0x20</addressOffset>
       </register>
       <register derivedFrom="PDMA_IER0">
          <name>PDMA_IER8</name>
          <displayName>PDMA_IER8</displayName>
          <description>PDMA Channel x Interrupt Enable Register</description>
          <alternateRegister>PDMA_IER0</alternateRegister>
          <addressOffset>0x20</addressOffset>
       </register>
       <register>
          <name>PDMA_ISR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_ISR0</displayName>
          <description>PDMA Channel x Interrupt Status Register</description>
          <addressOffset>0x24</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TABORT_IF</name>
              <description>PDMA Read/Write Target Abort Interrupt Flag\nWrite 1 to clear this bit to 0.\nNote: This bit filed indicates bus master received ERROR response or not. If bus master received ERROR response, it means that target abort is happened. PDMA controller will stop transfer and respond this event to software then goes to IDLE state. When target abort occurred, software must reset PDMA, and then transfer those data again.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No bus ERROR response received</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Bus ERROR response received</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BLKD_IF</name>
              <description>PDMA Block Transfer Done Interrupt Flag\nThis bit indicates that PDMA has finished all transfers.\nWrite 1 to clear this bit to 0.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Not finished</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Done</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PDMA_ISR0">
          <name>PDMA_ISR1</name>
          <displayName>PDMA_ISR1</displayName>
          <description>PDMA Channel x Interrupt Status Register</description>
          <alternateRegister>PDMA_ISR0</alternateRegister>
          <addressOffset>0x24</addressOffset>
       </register>
       <register derivedFrom="PDMA_ISR0">
          <name>PDMA_ISR2</name>
          <displayName>PDMA_ISR2</displayName>
          <description>PDMA Channel x Interrupt Status Register</description>
          <alternateRegister>PDMA_ISR0</alternateRegister>
          <addressOffset>0x24</addressOffset>
       </register>
       <register derivedFrom="PDMA_ISR0">
          <name>PDMA_ISR3</name>
          <displayName>PDMA_ISR3</displayName>
          <description>PDMA Channel x Interrupt Status Register</description>
          <alternateRegister>PDMA_ISR0</alternateRegister>
          <addressOffset>0x24</addressOffset>
       </register>
       <register derivedFrom="PDMA_ISR0">
          <name>PDMA_ISR4</name>
          <displayName>PDMA_ISR4</displayName>
          <description>PDMA Channel x Interrupt Status Register</description>
          <alternateRegister>PDMA_ISR0</alternateRegister>
          <addressOffset>0x24</addressOffset>
       </register>
       <register derivedFrom="PDMA_ISR0">
          <name>PDMA_ISR5</name>
          <displayName>PDMA_ISR5</displayName>
          <description>PDMA Channel x Interrupt Status Register</description>
          <alternateRegister>PDMA_ISR0</alternateRegister>
          <addressOffset>0x24</addressOffset>
       </register>
       <register derivedFrom="PDMA_ISR0">
          <name>PDMA_ISR6</name>
          <displayName>PDMA_ISR6</displayName>
          <description>PDMA Channel x Interrupt Status Register</description>
          <alternateRegister>PDMA_ISR0</alternateRegister>
          <addressOffset>0x24</addressOffset>
       </register>
       <register derivedFrom="PDMA_ISR0">
          <name>PDMA_ISR7</name>
          <displayName>PDMA_ISR7</displayName>
          <description>PDMA Channel x Interrupt Status Register</description>
          <alternateRegister>PDMA_ISR0</alternateRegister>
          <addressOffset>0x24</addressOffset>
       </register>
       <register derivedFrom="PDMA_ISR0">
          <name>PDMA_ISR8</name>
          <displayName>PDMA_ISR8</displayName>
          <description>PDMA Channel x Interrupt Status Register</description>
          <alternateRegister>PDMA_ISR0</alternateRegister>
          <addressOffset>0x24</addressOffset>
       </register>
       <register>
          <name>PDMA_SBUF0_C0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_SBUF0_C0</displayName>
          <description>PDMA Channel x Shared Buffer FIFO 0 Register</description>
          <addressOffset>0x80</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_SBUF0</name>
              <description>PDMA Shared Buffer FIFO 0 (Read Only)\nEach channel has its own 1 word internal buffer.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PDMA_SBUF0_C0">
          <name>PDMA_SBUF0_C1</name>
          <displayName>PDMA_SBUF0_C1</displayName>
          <description>PDMA Channel x Shared Buffer FIFO 0 Register</description>
          <alternateRegister>PDMA_SBUF0_C0</alternateRegister>
          <addressOffset>0x80</addressOffset>
       </register>
       <register derivedFrom="PDMA_SBUF0_C0">
          <name>PDMA_SBUF0_C2</name>
          <displayName>PDMA_SBUF0_C2</displayName>
          <description>PDMA Channel x Shared Buffer FIFO 0 Register</description>
          <alternateRegister>PDMA_SBUF0_C0</alternateRegister>
          <addressOffset>0x80</addressOffset>
       </register>
       <register derivedFrom="PDMA_SBUF0_C0">
          <name>PDMA_SBUF0_C3</name>
          <displayName>PDMA_SBUF0_C3</displayName>
          <description>PDMA Channel x Shared Buffer FIFO 0 Register</description>
          <alternateRegister>PDMA_SBUF0_C0</alternateRegister>
          <addressOffset>0x80</addressOffset>
       </register>
       <register derivedFrom="PDMA_SBUF0_C0">
          <name>PDMA_SBUF0_C4</name>
          <displayName>PDMA_SBUF0_C4</displayName>
          <description>PDMA Channel x Shared Buffer FIFO 0 Register</description>
          <alternateRegister>PDMA_SBUF0_C0</alternateRegister>
          <addressOffset>0x80</addressOffset>
       </register>
       <register derivedFrom="PDMA_SBUF0_C0">
          <name>PDMA_SBUF0_C5</name>
          <displayName>PDMA_SBUF0_C5</displayName>
          <description>PDMA Channel x Shared Buffer FIFO 0 Register</description>
          <alternateRegister>PDMA_SBUF0_C0</alternateRegister>
          <addressOffset>0x80</addressOffset>
       </register>
       <register derivedFrom="PDMA_SBUF0_C0">
          <name>PDMA_SBUF0_C6</name>
          <displayName>PDMA_SBUF0_C6</displayName>
          <description>PDMA Channel x Shared Buffer FIFO 0 Register</description>
          <alternateRegister>PDMA_SBUF0_C0</alternateRegister>
          <addressOffset>0x80</addressOffset>
       </register>
       <register derivedFrom="PDMA_SBUF0_C0">
          <name>PDMA_SBUF0_C7</name>
          <displayName>PDMA_SBUF0_C7</displayName>
          <description>PDMA Channel x Shared Buffer FIFO 0 Register</description>
          <alternateRegister>PDMA_SBUF0_C0</alternateRegister>
          <addressOffset>0x80</addressOffset>
       </register>
       <register derivedFrom="PDMA_SBUF0_C0">
          <name>PDMA_SBUF0_C8</name>
          <displayName>PDMA_SBUF0_C8</displayName>
          <description>PDMA Channel x Shared Buffer FIFO 0 Register</description>
          <alternateRegister>PDMA_SBUF0_C0</alternateRegister>
          <addressOffset>0x80</addressOffset>
       </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>PDMA_CH6</name>
      <description>PDMA Register Map</description>
      <groupName>PDMA</groupName>
      <baseAddress>0x50008600</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x0</offset>
        <size>0x28</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x80</offset>
        <size>0x4</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>PDMA_CSR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_CSR0</displayName>
          <description>PDMA Channel x Control Register</description>
          <addressOffset>0x0</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMACEN</name>
              <description>PDMA Channel Enable Bit\nSetting this bit to 1 enables PDMA operation. If this bit is cleared, PDMA will ignore all PDMA request and force Bus Master into IDLE state.\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_RST</name>
              <description>Software Engine Reset\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reset the internal state machine, pointers and internal buffer. The contents of control register will not be cleared. This bit will be automatically cleared after few clock cycles</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>MODE_SEL</name>
              <description>PDMA Mode Selection\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Memory to Memory mode (Memory-to-Memory)</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Peripheral to Memory mode (Peripheral-to-Memory)</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Memory to Peripheral mode (Memory-to-Peripheral)</description>
                    <value>#10</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SAD_SEL</name>
              <description>Transfer Source Address Direction Selection\n</description>
              <bitOffset>4</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Transfer source address is increasing successively</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reserved</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Transfer source address is fixed (This feature can be used when data where transferred from a single source to multiple destinations)</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Reserved</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DAD_SEL</name>
              <description>Transfer Destination Address Direction Selection\n</description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Transfer destination address is increasing successively</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reserved</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Transfer destination address is fixed. (This feature can be used when data where transferred from multiple sources to a single destination)</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Reserved</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>APB_TWS</name>
              <description>Peripheral Transfer Width Selection\nNote: This field is meaningful only when MODE_SEL (PDMA_CSRx[3:2]) is Peripheral to Memory mode (Peripheral-to-Memory) or Memory to Peripheral mode (Memory-to-Peripheral).</description>
              <bitOffset>19</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>One word (32-bit) is transferred for every PDMA operation</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>One byte (8-bit) is transferred for every PDMA operation</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>One half-word (16-bit) is transferred for every PDMA operation</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Reserved</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TRIG_EN</name>
              <description>Trigger Enable Bit\nNote: When PDMA transfer completed, this bit will be cleared automatically.\nIf the bus error occurs, all PDMA transfer will be stopped. Software must reset all PDMA channel, and then trigger again.</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PDMA data read or write transfer Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PDMA_CSR0">
          <name>PDMA_CSR1</name>
          <displayName>PDMA_CSR1</displayName>
          <description>PDMA Channel x Control Register</description>
          <alternateRegister>PDMA_CSR0</alternateRegister>
          <addressOffset>0x0</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSR0">
          <name>PDMA_CSR2</name>
          <displayName>PDMA_CSR2</displayName>
          <description>PDMA Channel x Control Register</description>
          <alternateRegister>PDMA_CSR0</alternateRegister>
          <addressOffset>0x0</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSR0">
          <name>PDMA_CSR3</name>
          <displayName>PDMA_CSR3</displayName>
          <description>PDMA Channel x Control Register</description>
          <alternateRegister>PDMA_CSR0</alternateRegister>
          <addressOffset>0x0</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSR0">
          <name>PDMA_CSR4</name>
          <displayName>PDMA_CSR4</displayName>
          <description>PDMA Channel x Control Register</description>
          <alternateRegister>PDMA_CSR0</alternateRegister>
          <addressOffset>0x0</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSR0">
          <name>PDMA_CSR5</name>
          <displayName>PDMA_CSR5</displayName>
          <description>PDMA Channel x Control Register</description>
          <alternateRegister>PDMA_CSR0</alternateRegister>
          <addressOffset>0x0</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSR0">
          <name>PDMA_CSR6</name>
          <displayName>PDMA_CSR6</displayName>
          <description>PDMA Channel x Control Register</description>
          <alternateRegister>PDMA_CSR0</alternateRegister>
          <addressOffset>0x0</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSR0">
          <name>PDMA_CSR7</name>
          <displayName>PDMA_CSR7</displayName>
          <description>PDMA Channel x Control Register</description>
          <alternateRegister>PDMA_CSR0</alternateRegister>
          <addressOffset>0x0</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSR0">
          <name>PDMA_CSR8</name>
          <displayName>PDMA_CSR8</displayName>
          <description>PDMA Channel x Control Register</description>
          <alternateRegister>PDMA_CSR0</alternateRegister>
          <addressOffset>0x0</addressOffset>
       </register>
       <register>
          <name>PDMA_SAR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_SAR0</displayName>
          <description>PDMA Channel x Source Address Register</description>
          <addressOffset>0x4</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_SAR</name>
              <description>PDMA Transfer Source Address Register\nThis field indicates a 32-bit source address of PDMA.\nNote: The source address must be word alignment.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PDMA_SAR0">
          <name>PDMA_SAR1</name>
          <displayName>PDMA_SAR1</displayName>
          <description>PDMA Channel x Source Address Register</description>
          <alternateRegister>PDMA_SAR0</alternateRegister>
          <addressOffset>0x4</addressOffset>
       </register>
       <register derivedFrom="PDMA_SAR0">
          <name>PDMA_SAR2</name>
          <displayName>PDMA_SAR2</displayName>
          <description>PDMA Channel x Source Address Register</description>
          <alternateRegister>PDMA_SAR0</alternateRegister>
          <addressOffset>0x4</addressOffset>
       </register>
       <register derivedFrom="PDMA_SAR0">
          <name>PDMA_SAR3</name>
          <displayName>PDMA_SAR3</displayName>
          <description>PDMA Channel x Source Address Register</description>
          <alternateRegister>PDMA_SAR0</alternateRegister>
          <addressOffset>0x4</addressOffset>
       </register>
       <register derivedFrom="PDMA_SAR0">
          <name>PDMA_SAR4</name>
          <displayName>PDMA_SAR4</displayName>
          <description>PDMA Channel x Source Address Register</description>
          <alternateRegister>PDMA_SAR0</alternateRegister>
          <addressOffset>0x4</addressOffset>
       </register>
       <register derivedFrom="PDMA_SAR0">
          <name>PDMA_SAR5</name>
          <displayName>PDMA_SAR5</displayName>
          <description>PDMA Channel x Source Address Register</description>
          <alternateRegister>PDMA_SAR0</alternateRegister>
          <addressOffset>0x4</addressOffset>
       </register>
       <register derivedFrom="PDMA_SAR0">
          <name>PDMA_SAR6</name>
          <displayName>PDMA_SAR6</displayName>
          <description>PDMA Channel x Source Address Register</description>
          <alternateRegister>PDMA_SAR0</alternateRegister>
          <addressOffset>0x4</addressOffset>
       </register>
       <register derivedFrom="PDMA_SAR0">
          <name>PDMA_SAR7</name>
          <displayName>PDMA_SAR7</displayName>
          <description>PDMA Channel x Source Address Register</description>
          <alternateRegister>PDMA_SAR0</alternateRegister>
          <addressOffset>0x4</addressOffset>
       </register>
       <register derivedFrom="PDMA_SAR0">
          <name>PDMA_SAR8</name>
          <displayName>PDMA_SAR8</displayName>
          <description>PDMA Channel x Source Address Register</description>
          <alternateRegister>PDMA_SAR0</alternateRegister>
          <addressOffset>0x4</addressOffset>
       </register>
       <register>
          <name>PDMA_DAR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_DAR0</displayName>
          <description>PDMA Channel x Destination Address Register</description>
          <addressOffset>0x8</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_DAR</name>
              <description>PDMA Transfer Destination Address Register\nThis field indicates a 32-bit destination address of PDMA.\nNote: The destination address must be word alignment</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PDMA_DAR0">
          <name>PDMA_DAR1</name>
          <displayName>PDMA_DAR1</displayName>
          <description>PDMA Channel x Destination Address Register</description>
          <alternateRegister>PDMA_DAR0</alternateRegister>
          <addressOffset>0x8</addressOffset>
       </register>
       <register derivedFrom="PDMA_DAR0">
          <name>PDMA_DAR2</name>
          <displayName>PDMA_DAR2</displayName>
          <description>PDMA Channel x Destination Address Register</description>
          <alternateRegister>PDMA_DAR0</alternateRegister>
          <addressOffset>0x8</addressOffset>
       </register>
       <register derivedFrom="PDMA_DAR0">
          <name>PDMA_DAR3</name>
          <displayName>PDMA_DAR3</displayName>
          <description>PDMA Channel x Destination Address Register</description>
          <alternateRegister>PDMA_DAR0</alternateRegister>
          <addressOffset>0x8</addressOffset>
       </register>
       <register derivedFrom="PDMA_DAR0">
          <name>PDMA_DAR4</name>
          <displayName>PDMA_DAR4</displayName>
          <description>PDMA Channel x Destination Address Register</description>
          <alternateRegister>PDMA_DAR0</alternateRegister>
          <addressOffset>0x8</addressOffset>
       </register>
       <register derivedFrom="PDMA_DAR0">
          <name>PDMA_DAR5</name>
          <displayName>PDMA_DAR5</displayName>
          <description>PDMA Channel x Destination Address Register</description>
          <alternateRegister>PDMA_DAR0</alternateRegister>
          <addressOffset>0x8</addressOffset>
       </register>
       <register derivedFrom="PDMA_DAR0">
          <name>PDMA_DAR6</name>
          <displayName>PDMA_DAR6</displayName>
          <description>PDMA Channel x Destination Address Register</description>
          <alternateRegister>PDMA_DAR0</alternateRegister>
          <addressOffset>0x8</addressOffset>
       </register>
       <register derivedFrom="PDMA_DAR0">
          <name>PDMA_DAR7</name>
          <displayName>PDMA_DAR7</displayName>
          <description>PDMA Channel x Destination Address Register</description>
          <alternateRegister>PDMA_DAR0</alternateRegister>
          <addressOffset>0x8</addressOffset>
       </register>
       <register derivedFrom="PDMA_DAR0">
          <name>PDMA_DAR8</name>
          <displayName>PDMA_DAR8</displayName>
          <description>PDMA Channel x Destination Address Register</description>
          <alternateRegister>PDMA_DAR0</alternateRegister>
          <addressOffset>0x8</addressOffset>
       </register>
       <register>
          <name>PDMA_BCR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_BCR0</displayName>
          <description>PDMA Channel x Transfer Byte Count Register</description>
          <addressOffset>0xC</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_BCR</name>
              <description>PDMA Transfer Byte Count Register\nThis field indicates a 16-bit transfer byte count number of PDMA; it must be word alignment.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PDMA_BCR0">
          <name>PDMA_BCR1</name>
          <displayName>PDMA_BCR1</displayName>
          <description>PDMA Channel x Transfer Byte Count Register</description>
          <alternateRegister>PDMA_BCR0</alternateRegister>
          <addressOffset>0xC</addressOffset>
       </register>
       <register derivedFrom="PDMA_BCR0">
          <name>PDMA_BCR2</name>
          <displayName>PDMA_BCR2</displayName>
          <description>PDMA Channel x Transfer Byte Count Register</description>
          <alternateRegister>PDMA_BCR0</alternateRegister>
          <addressOffset>0xC</addressOffset>
       </register>
       <register derivedFrom="PDMA_BCR0">
          <name>PDMA_BCR3</name>
          <displayName>PDMA_BCR3</displayName>
          <description>PDMA Channel x Transfer Byte Count Register</description>
          <alternateRegister>PDMA_BCR0</alternateRegister>
          <addressOffset>0xC</addressOffset>
       </register>
       <register derivedFrom="PDMA_BCR0">
          <name>PDMA_BCR4</name>
          <displayName>PDMA_BCR4</displayName>
          <description>PDMA Channel x Transfer Byte Count Register</description>
          <alternateRegister>PDMA_BCR0</alternateRegister>
          <addressOffset>0xC</addressOffset>
       </register>
       <register derivedFrom="PDMA_BCR0">
          <name>PDMA_BCR5</name>
          <displayName>PDMA_BCR5</displayName>
          <description>PDMA Channel x Transfer Byte Count Register</description>
          <alternateRegister>PDMA_BCR0</alternateRegister>
          <addressOffset>0xC</addressOffset>
       </register>
       <register derivedFrom="PDMA_BCR0">
          <name>PDMA_BCR6</name>
          <displayName>PDMA_BCR6</displayName>
          <description>PDMA Channel x Transfer Byte Count Register</description>
          <alternateRegister>PDMA_BCR0</alternateRegister>
          <addressOffset>0xC</addressOffset>
       </register>
       <register derivedFrom="PDMA_BCR0">
          <name>PDMA_BCR7</name>
          <displayName>PDMA_BCR7</displayName>
          <description>PDMA Channel x Transfer Byte Count Register</description>
          <alternateRegister>PDMA_BCR0</alternateRegister>
          <addressOffset>0xC</addressOffset>
       </register>
       <register derivedFrom="PDMA_BCR0">
          <name>PDMA_BCR8</name>
          <displayName>PDMA_BCR8</displayName>
          <description>PDMA Channel x Transfer Byte Count Register</description>
          <alternateRegister>PDMA_BCR0</alternateRegister>
          <addressOffset>0xC</addressOffset>
       </register>
       <register>
          <name>PDMA_POINT0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_POINT0</displayName>
          <description>PDMA Channel x Internal Buffer Pointer Register</description>
          <addressOffset>0x10</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_POINT</name>
              <description>PDMA Internal Buffer Pointer Register (Read Only)\nThis field indicates the internal buffer pointer.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PDMA_POINT0">
          <name>PDMA_POINT1</name>
          <displayName>PDMA_POINT1</displayName>
          <description>PDMA Channel x Internal Buffer Pointer Register</description>
          <alternateRegister>PDMA_POINT0</alternateRegister>
          <addressOffset>0x10</addressOffset>
       </register>
       <register derivedFrom="PDMA_POINT0">
          <name>PDMA_POINT2</name>
          <displayName>PDMA_POINT2</displayName>
          <description>PDMA Channel x Internal Buffer Pointer Register</description>
          <alternateRegister>PDMA_POINT0</alternateRegister>
          <addressOffset>0x10</addressOffset>
       </register>
       <register derivedFrom="PDMA_POINT0">
          <name>PDMA_POINT3</name>
          <displayName>PDMA_POINT3</displayName>
          <description>PDMA Channel x Internal Buffer Pointer Register</description>
          <alternateRegister>PDMA_POINT0</alternateRegister>
          <addressOffset>0x10</addressOffset>
       </register>
       <register derivedFrom="PDMA_POINT0">
          <name>PDMA_POINT4</name>
          <displayName>PDMA_POINT4</displayName>
          <description>PDMA Channel x Internal Buffer Pointer Register</description>
          <alternateRegister>PDMA_POINT0</alternateRegister>
          <addressOffset>0x10</addressOffset>
       </register>
       <register derivedFrom="PDMA_POINT0">
          <name>PDMA_POINT5</name>
          <displayName>PDMA_POINT5</displayName>
          <description>PDMA Channel x Internal Buffer Pointer Register</description>
          <alternateRegister>PDMA_POINT0</alternateRegister>
          <addressOffset>0x10</addressOffset>
       </register>
       <register derivedFrom="PDMA_POINT0">
          <name>PDMA_POINT6</name>
          <displayName>PDMA_POINT6</displayName>
          <description>PDMA Channel x Internal Buffer Pointer Register</description>
          <alternateRegister>PDMA_POINT0</alternateRegister>
          <addressOffset>0x10</addressOffset>
       </register>
       <register derivedFrom="PDMA_POINT0">
          <name>PDMA_POINT7</name>
          <displayName>PDMA_POINT7</displayName>
          <description>PDMA Channel x Internal Buffer Pointer Register</description>
          <alternateRegister>PDMA_POINT0</alternateRegister>
          <addressOffset>0x10</addressOffset>
       </register>
       <register derivedFrom="PDMA_POINT0">
          <name>PDMA_POINT8</name>
          <displayName>PDMA_POINT8</displayName>
          <description>PDMA Channel x Internal Buffer Pointer Register</description>
          <alternateRegister>PDMA_POINT0</alternateRegister>
          <addressOffset>0x10</addressOffset>
       </register>
       <register>
          <name>PDMA_CSAR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_CSAR0</displayName>
          <description>PDMA Channel x Current Source Address Register</description>
          <addressOffset>0x14</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_CSAR</name>
              <description>PDMA Current Source Address Register (Read Only)\nThis field indicates the source address where the PDMA transfer just occurred.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PDMA_CSAR0">
          <name>PDMA_CSAR1</name>
          <displayName>PDMA_CSAR1</displayName>
          <description>PDMA Channel x Current Source Address Register</description>
          <alternateRegister>PDMA_CSAR0</alternateRegister>
          <addressOffset>0x14</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSAR0">
          <name>PDMA_CSAR2</name>
          <displayName>PDMA_CSAR2</displayName>
          <description>PDMA Channel x Current Source Address Register</description>
          <alternateRegister>PDMA_CSAR0</alternateRegister>
          <addressOffset>0x14</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSAR0">
          <name>PDMA_CSAR3</name>
          <displayName>PDMA_CSAR3</displayName>
          <description>PDMA Channel x Current Source Address Register</description>
          <alternateRegister>PDMA_CSAR0</alternateRegister>
          <addressOffset>0x14</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSAR0">
          <name>PDMA_CSAR4</name>
          <displayName>PDMA_CSAR4</displayName>
          <description>PDMA Channel x Current Source Address Register</description>
          <alternateRegister>PDMA_CSAR0</alternateRegister>
          <addressOffset>0x14</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSAR0">
          <name>PDMA_CSAR5</name>
          <displayName>PDMA_CSAR5</displayName>
          <description>PDMA Channel x Current Source Address Register</description>
          <alternateRegister>PDMA_CSAR0</alternateRegister>
          <addressOffset>0x14</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSAR0">
          <name>PDMA_CSAR6</name>
          <displayName>PDMA_CSAR6</displayName>
          <description>PDMA Channel x Current Source Address Register</description>
          <alternateRegister>PDMA_CSAR0</alternateRegister>
          <addressOffset>0x14</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSAR0">
          <name>PDMA_CSAR7</name>
          <displayName>PDMA_CSAR7</displayName>
          <description>PDMA Channel x Current Source Address Register</description>
          <alternateRegister>PDMA_CSAR0</alternateRegister>
          <addressOffset>0x14</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSAR0">
          <name>PDMA_CSAR8</name>
          <displayName>PDMA_CSAR8</displayName>
          <description>PDMA Channel x Current Source Address Register</description>
          <alternateRegister>PDMA_CSAR0</alternateRegister>
          <addressOffset>0x14</addressOffset>
       </register>
       <register>
          <name>PDMA_CDAR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_CDAR0</displayName>
          <description>PDMA Channel x Current Destination Address Register</description>
          <addressOffset>0x18</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_CDAR</name>
              <description>PDMA Current Destination Address Register (Read Only)\nThis field indicates the destination address where the PDMA transfer just occurred.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PDMA_CDAR0">
          <name>PDMA_CDAR1</name>
          <displayName>PDMA_CDAR1</displayName>
          <description>PDMA Channel x Current Destination Address Register</description>
          <alternateRegister>PDMA_CDAR0</alternateRegister>
          <addressOffset>0x18</addressOffset>
       </register>
       <register derivedFrom="PDMA_CDAR0">
          <name>PDMA_CDAR2</name>
          <displayName>PDMA_CDAR2</displayName>
          <description>PDMA Channel x Current Destination Address Register</description>
          <alternateRegister>PDMA_CDAR0</alternateRegister>
          <addressOffset>0x18</addressOffset>
       </register>
       <register derivedFrom="PDMA_CDAR0">
          <name>PDMA_CDAR3</name>
          <displayName>PDMA_CDAR3</displayName>
          <description>PDMA Channel x Current Destination Address Register</description>
          <alternateRegister>PDMA_CDAR0</alternateRegister>
          <addressOffset>0x18</addressOffset>
       </register>
       <register derivedFrom="PDMA_CDAR0">
          <name>PDMA_CDAR4</name>
          <displayName>PDMA_CDAR4</displayName>
          <description>PDMA Channel x Current Destination Address Register</description>
          <alternateRegister>PDMA_CDAR0</alternateRegister>
          <addressOffset>0x18</addressOffset>
       </register>
       <register derivedFrom="PDMA_CDAR0">
          <name>PDMA_CDAR5</name>
          <displayName>PDMA_CDAR5</displayName>
          <description>PDMA Channel x Current Destination Address Register</description>
          <alternateRegister>PDMA_CDAR0</alternateRegister>
          <addressOffset>0x18</addressOffset>
       </register>
       <register derivedFrom="PDMA_CDAR0">
          <name>PDMA_CDAR6</name>
          <displayName>PDMA_CDAR6</displayName>
          <description>PDMA Channel x Current Destination Address Register</description>
          <alternateRegister>PDMA_CDAR0</alternateRegister>
          <addressOffset>0x18</addressOffset>
       </register>
       <register derivedFrom="PDMA_CDAR0">
          <name>PDMA_CDAR7</name>
          <displayName>PDMA_CDAR7</displayName>
          <description>PDMA Channel x Current Destination Address Register</description>
          <alternateRegister>PDMA_CDAR0</alternateRegister>
          <addressOffset>0x18</addressOffset>
       </register>
       <register derivedFrom="PDMA_CDAR0">
          <name>PDMA_CDAR8</name>
          <displayName>PDMA_CDAR8</displayName>
          <description>PDMA Channel x Current Destination Address Register</description>
          <alternateRegister>PDMA_CDAR0</alternateRegister>
          <addressOffset>0x18</addressOffset>
       </register>
       <register>
          <name>PDMA_CBCR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_CBCR0</displayName>
          <description>PDMA Channel x Current Transfer Byte Count Register</description>
          <addressOffset>0x1C</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_CBCR</name>
              <description>PDMA Current Byte Count Register (Read Only)\nThis field indicates the current remained byte count of PDMA.\nNote: This field value will be cleared to 0, when software set SW_RST (PDMA_CSRx[1]) to "1".</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PDMA_CBCR0">
          <name>PDMA_CBCR1</name>
          <displayName>PDMA_CBCR1</displayName>
          <description>PDMA Channel x Current Transfer Byte Count Register</description>
          <alternateRegister>PDMA_CBCR0</alternateRegister>
          <addressOffset>0x1C</addressOffset>
       </register>
       <register derivedFrom="PDMA_CBCR0">
          <name>PDMA_CBCR2</name>
          <displayName>PDMA_CBCR2</displayName>
          <description>PDMA Channel x Current Transfer Byte Count Register</description>
          <alternateRegister>PDMA_CBCR0</alternateRegister>
          <addressOffset>0x1C</addressOffset>
       </register>
       <register derivedFrom="PDMA_CBCR0">
          <name>PDMA_CBCR3</name>
          <displayName>PDMA_CBCR3</displayName>
          <description>PDMA Channel x Current Transfer Byte Count Register</description>
          <alternateRegister>PDMA_CBCR0</alternateRegister>
          <addressOffset>0x1C</addressOffset>
       </register>
       <register derivedFrom="PDMA_CBCR0">
          <name>PDMA_CBCR4</name>
          <displayName>PDMA_CBCR4</displayName>
          <description>PDMA Channel x Current Transfer Byte Count Register</description>
          <alternateRegister>PDMA_CBCR0</alternateRegister>
          <addressOffset>0x1C</addressOffset>
       </register>
       <register derivedFrom="PDMA_CBCR0">
          <name>PDMA_CBCR5</name>
          <displayName>PDMA_CBCR5</displayName>
          <description>PDMA Channel x Current Transfer Byte Count Register</description>
          <alternateRegister>PDMA_CBCR0</alternateRegister>
          <addressOffset>0x1C</addressOffset>
       </register>
       <register derivedFrom="PDMA_CBCR0">
          <name>PDMA_CBCR6</name>
          <displayName>PDMA_CBCR6</displayName>
          <description>PDMA Channel x Current Transfer Byte Count Register</description>
          <alternateRegister>PDMA_CBCR0</alternateRegister>
          <addressOffset>0x1C</addressOffset>
       </register>
       <register derivedFrom="PDMA_CBCR0">
          <name>PDMA_CBCR7</name>
          <displayName>PDMA_CBCR7</displayName>
          <description>PDMA Channel x Current Transfer Byte Count Register</description>
          <alternateRegister>PDMA_CBCR0</alternateRegister>
          <addressOffset>0x1C</addressOffset>
       </register>
       <register derivedFrom="PDMA_CBCR0">
          <name>PDMA_CBCR8</name>
          <displayName>PDMA_CBCR8</displayName>
          <description>PDMA Channel x Current Transfer Byte Count Register</description>
          <alternateRegister>PDMA_CBCR0</alternateRegister>
          <addressOffset>0x1C</addressOffset>
       </register>
       <register>
          <name>PDMA_IER0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_IER0</displayName>
          <description>PDMA Channel x Interrupt Enable Register</description>
          <addressOffset>0x20</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000001</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TABORT_IE</name>
              <description>PDMA Read/Write Target Abort Interrupt Enable Bit\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Target abort interrupt generation Disabled during PDMA transfer</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Target abort interrupt generation Enabled during PDMA transfer</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BLKD_IE</name>
              <description>PDMA Block Transfer Done Interrupt Enable Bit\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Interrupt generator Disabled when PDMA transfer is done</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Interrupt generator Enabled when PDMA transfer is done</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PDMA_IER0">
          <name>PDMA_IER1</name>
          <displayName>PDMA_IER1</displayName>
          <description>PDMA Channel x Interrupt Enable Register</description>
          <alternateRegister>PDMA_IER0</alternateRegister>
          <addressOffset>0x20</addressOffset>
       </register>
       <register derivedFrom="PDMA_IER0">
          <name>PDMA_IER2</name>
          <displayName>PDMA_IER2</displayName>
          <description>PDMA Channel x Interrupt Enable Register</description>
          <alternateRegister>PDMA_IER0</alternateRegister>
          <addressOffset>0x20</addressOffset>
       </register>
       <register derivedFrom="PDMA_IER0">
          <name>PDMA_IER3</name>
          <displayName>PDMA_IER3</displayName>
          <description>PDMA Channel x Interrupt Enable Register</description>
          <alternateRegister>PDMA_IER0</alternateRegister>
          <addressOffset>0x20</addressOffset>
       </register>
       <register derivedFrom="PDMA_IER0">
          <name>PDMA_IER4</name>
          <displayName>PDMA_IER4</displayName>
          <description>PDMA Channel x Interrupt Enable Register</description>
          <alternateRegister>PDMA_IER0</alternateRegister>
          <addressOffset>0x20</addressOffset>
       </register>
       <register derivedFrom="PDMA_IER0">
          <name>PDMA_IER5</name>
          <displayName>PDMA_IER5</displayName>
          <description>PDMA Channel x Interrupt Enable Register</description>
          <alternateRegister>PDMA_IER0</alternateRegister>
          <addressOffset>0x20</addressOffset>
       </register>
       <register derivedFrom="PDMA_IER0">
          <name>PDMA_IER6</name>
          <displayName>PDMA_IER6</displayName>
          <description>PDMA Channel x Interrupt Enable Register</description>
          <alternateRegister>PDMA_IER0</alternateRegister>
          <addressOffset>0x20</addressOffset>
       </register>
       <register derivedFrom="PDMA_IER0">
          <name>PDMA_IER7</name>
          <displayName>PDMA_IER7</displayName>
          <description>PDMA Channel x Interrupt Enable Register</description>
          <alternateRegister>PDMA_IER0</alternateRegister>
          <addressOffset>0x20</addressOffset>
       </register>
       <register derivedFrom="PDMA_IER0">
          <name>PDMA_IER8</name>
          <displayName>PDMA_IER8</displayName>
          <description>PDMA Channel x Interrupt Enable Register</description>
          <alternateRegister>PDMA_IER0</alternateRegister>
          <addressOffset>0x20</addressOffset>
       </register>
       <register>
          <name>PDMA_ISR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_ISR0</displayName>
          <description>PDMA Channel x Interrupt Status Register</description>
          <addressOffset>0x24</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TABORT_IF</name>
              <description>PDMA Read/Write Target Abort Interrupt Flag\nWrite 1 to clear this bit to 0.\nNote: This bit filed indicates bus master received ERROR response or not. If bus master received ERROR response, it means that target abort is happened. PDMA controller will stop transfer and respond this event to software then goes to IDLE state. When target abort occurred, software must reset PDMA, and then transfer those data again.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No bus ERROR response received</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Bus ERROR response received</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BLKD_IF</name>
              <description>PDMA Block Transfer Done Interrupt Flag\nThis bit indicates that PDMA has finished all transfers.\nWrite 1 to clear this bit to 0.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Not finished</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Done</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PDMA_ISR0">
          <name>PDMA_ISR1</name>
          <displayName>PDMA_ISR1</displayName>
          <description>PDMA Channel x Interrupt Status Register</description>
          <alternateRegister>PDMA_ISR0</alternateRegister>
          <addressOffset>0x24</addressOffset>
       </register>
       <register derivedFrom="PDMA_ISR0">
          <name>PDMA_ISR2</name>
          <displayName>PDMA_ISR2</displayName>
          <description>PDMA Channel x Interrupt Status Register</description>
          <alternateRegister>PDMA_ISR0</alternateRegister>
          <addressOffset>0x24</addressOffset>
       </register>
       <register derivedFrom="PDMA_ISR0">
          <name>PDMA_ISR3</name>
          <displayName>PDMA_ISR3</displayName>
          <description>PDMA Channel x Interrupt Status Register</description>
          <alternateRegister>PDMA_ISR0</alternateRegister>
          <addressOffset>0x24</addressOffset>
       </register>
       <register derivedFrom="PDMA_ISR0">
          <name>PDMA_ISR4</name>
          <displayName>PDMA_ISR4</displayName>
          <description>PDMA Channel x Interrupt Status Register</description>
          <alternateRegister>PDMA_ISR0</alternateRegister>
          <addressOffset>0x24</addressOffset>
       </register>
       <register derivedFrom="PDMA_ISR0">
          <name>PDMA_ISR5</name>
          <displayName>PDMA_ISR5</displayName>
          <description>PDMA Channel x Interrupt Status Register</description>
          <alternateRegister>PDMA_ISR0</alternateRegister>
          <addressOffset>0x24</addressOffset>
       </register>
       <register derivedFrom="PDMA_ISR0">
          <name>PDMA_ISR6</name>
          <displayName>PDMA_ISR6</displayName>
          <description>PDMA Channel x Interrupt Status Register</description>
          <alternateRegister>PDMA_ISR0</alternateRegister>
          <addressOffset>0x24</addressOffset>
       </register>
       <register derivedFrom="PDMA_ISR0">
          <name>PDMA_ISR7</name>
          <displayName>PDMA_ISR7</displayName>
          <description>PDMA Channel x Interrupt Status Register</description>
          <alternateRegister>PDMA_ISR0</alternateRegister>
          <addressOffset>0x24</addressOffset>
       </register>
       <register derivedFrom="PDMA_ISR0">
          <name>PDMA_ISR8</name>
          <displayName>PDMA_ISR8</displayName>
          <description>PDMA Channel x Interrupt Status Register</description>
          <alternateRegister>PDMA_ISR0</alternateRegister>
          <addressOffset>0x24</addressOffset>
       </register>
       <register>
          <name>PDMA_SBUF0_C0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_SBUF0_C0</displayName>
          <description>PDMA Channel x Shared Buffer FIFO 0 Register</description>
          <addressOffset>0x80</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_SBUF0</name>
              <description>PDMA Shared Buffer FIFO 0 (Read Only)\nEach channel has its own 1 word internal buffer.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PDMA_SBUF0_C0">
          <name>PDMA_SBUF0_C1</name>
          <displayName>PDMA_SBUF0_C1</displayName>
          <description>PDMA Channel x Shared Buffer FIFO 0 Register</description>
          <alternateRegister>PDMA_SBUF0_C0</alternateRegister>
          <addressOffset>0x80</addressOffset>
       </register>
       <register derivedFrom="PDMA_SBUF0_C0">
          <name>PDMA_SBUF0_C2</name>
          <displayName>PDMA_SBUF0_C2</displayName>
          <description>PDMA Channel x Shared Buffer FIFO 0 Register</description>
          <alternateRegister>PDMA_SBUF0_C0</alternateRegister>
          <addressOffset>0x80</addressOffset>
       </register>
       <register derivedFrom="PDMA_SBUF0_C0">
          <name>PDMA_SBUF0_C3</name>
          <displayName>PDMA_SBUF0_C3</displayName>
          <description>PDMA Channel x Shared Buffer FIFO 0 Register</description>
          <alternateRegister>PDMA_SBUF0_C0</alternateRegister>
          <addressOffset>0x80</addressOffset>
       </register>
       <register derivedFrom="PDMA_SBUF0_C0">
          <name>PDMA_SBUF0_C4</name>
          <displayName>PDMA_SBUF0_C4</displayName>
          <description>PDMA Channel x Shared Buffer FIFO 0 Register</description>
          <alternateRegister>PDMA_SBUF0_C0</alternateRegister>
          <addressOffset>0x80</addressOffset>
       </register>
       <register derivedFrom="PDMA_SBUF0_C0">
          <name>PDMA_SBUF0_C5</name>
          <displayName>PDMA_SBUF0_C5</displayName>
          <description>PDMA Channel x Shared Buffer FIFO 0 Register</description>
          <alternateRegister>PDMA_SBUF0_C0</alternateRegister>
          <addressOffset>0x80</addressOffset>
       </register>
       <register derivedFrom="PDMA_SBUF0_C0">
          <name>PDMA_SBUF0_C6</name>
          <displayName>PDMA_SBUF0_C6</displayName>
          <description>PDMA Channel x Shared Buffer FIFO 0 Register</description>
          <alternateRegister>PDMA_SBUF0_C0</alternateRegister>
          <addressOffset>0x80</addressOffset>
       </register>
       <register derivedFrom="PDMA_SBUF0_C0">
          <name>PDMA_SBUF0_C7</name>
          <displayName>PDMA_SBUF0_C7</displayName>
          <description>PDMA Channel x Shared Buffer FIFO 0 Register</description>
          <alternateRegister>PDMA_SBUF0_C0</alternateRegister>
          <addressOffset>0x80</addressOffset>
       </register>
       <register derivedFrom="PDMA_SBUF0_C0">
          <name>PDMA_SBUF0_C8</name>
          <displayName>PDMA_SBUF0_C8</displayName>
          <description>PDMA Channel x Shared Buffer FIFO 0 Register</description>
          <alternateRegister>PDMA_SBUF0_C0</alternateRegister>
          <addressOffset>0x80</addressOffset>
       </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>PDMA_CH7</name>
      <description>PDMA Register Map</description>
      <groupName>PDMA</groupName>
      <baseAddress>0x50008700</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x0</offset>
        <size>0x28</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x80</offset>
        <size>0x4</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>PDMA_CSR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_CSR0</displayName>
          <description>PDMA Channel x Control Register</description>
          <addressOffset>0x0</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMACEN</name>
              <description>PDMA Channel Enable Bit\nSetting this bit to 1 enables PDMA operation. If this bit is cleared, PDMA will ignore all PDMA request and force Bus Master into IDLE state.\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_RST</name>
              <description>Software Engine Reset\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reset the internal state machine, pointers and internal buffer. The contents of control register will not be cleared. This bit will be automatically cleared after few clock cycles</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>MODE_SEL</name>
              <description>PDMA Mode Selection\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Memory to Memory mode (Memory-to-Memory)</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Peripheral to Memory mode (Peripheral-to-Memory)</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Memory to Peripheral mode (Memory-to-Peripheral)</description>
                    <value>#10</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SAD_SEL</name>
              <description>Transfer Source Address Direction Selection\n</description>
              <bitOffset>4</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Transfer source address is increasing successively</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reserved</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Transfer source address is fixed (This feature can be used when data where transferred from a single source to multiple destinations)</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Reserved</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DAD_SEL</name>
              <description>Transfer Destination Address Direction Selection\n</description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Transfer destination address is increasing successively</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reserved</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Transfer destination address is fixed. (This feature can be used when data where transferred from multiple sources to a single destination)</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Reserved</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>APB_TWS</name>
              <description>Peripheral Transfer Width Selection\nNote: This field is meaningful only when MODE_SEL (PDMA_CSRx[3:2]) is Peripheral to Memory mode (Peripheral-to-Memory) or Memory to Peripheral mode (Memory-to-Peripheral).</description>
              <bitOffset>19</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>One word (32-bit) is transferred for every PDMA operation</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>One byte (8-bit) is transferred for every PDMA operation</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>One half-word (16-bit) is transferred for every PDMA operation</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Reserved</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TRIG_EN</name>
              <description>Trigger Enable Bit\nNote: When PDMA transfer completed, this bit will be cleared automatically.\nIf the bus error occurs, all PDMA transfer will be stopped. Software must reset all PDMA channel, and then trigger again.</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PDMA data read or write transfer Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PDMA_CSR0">
          <name>PDMA_CSR1</name>
          <displayName>PDMA_CSR1</displayName>
          <description>PDMA Channel x Control Register</description>
          <alternateRegister>PDMA_CSR0</alternateRegister>
          <addressOffset>0x0</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSR0">
          <name>PDMA_CSR2</name>
          <displayName>PDMA_CSR2</displayName>
          <description>PDMA Channel x Control Register</description>
          <alternateRegister>PDMA_CSR0</alternateRegister>
          <addressOffset>0x0</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSR0">
          <name>PDMA_CSR3</name>
          <displayName>PDMA_CSR3</displayName>
          <description>PDMA Channel x Control Register</description>
          <alternateRegister>PDMA_CSR0</alternateRegister>
          <addressOffset>0x0</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSR0">
          <name>PDMA_CSR4</name>
          <displayName>PDMA_CSR4</displayName>
          <description>PDMA Channel x Control Register</description>
          <alternateRegister>PDMA_CSR0</alternateRegister>
          <addressOffset>0x0</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSR0">
          <name>PDMA_CSR5</name>
          <displayName>PDMA_CSR5</displayName>
          <description>PDMA Channel x Control Register</description>
          <alternateRegister>PDMA_CSR0</alternateRegister>
          <addressOffset>0x0</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSR0">
          <name>PDMA_CSR6</name>
          <displayName>PDMA_CSR6</displayName>
          <description>PDMA Channel x Control Register</description>
          <alternateRegister>PDMA_CSR0</alternateRegister>
          <addressOffset>0x0</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSR0">
          <name>PDMA_CSR7</name>
          <displayName>PDMA_CSR7</displayName>
          <description>PDMA Channel x Control Register</description>
          <alternateRegister>PDMA_CSR0</alternateRegister>
          <addressOffset>0x0</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSR0">
          <name>PDMA_CSR8</name>
          <displayName>PDMA_CSR8</displayName>
          <description>PDMA Channel x Control Register</description>
          <alternateRegister>PDMA_CSR0</alternateRegister>
          <addressOffset>0x0</addressOffset>
       </register>
       <register>
          <name>PDMA_SAR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_SAR0</displayName>
          <description>PDMA Channel x Source Address Register</description>
          <addressOffset>0x4</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_SAR</name>
              <description>PDMA Transfer Source Address Register\nThis field indicates a 32-bit source address of PDMA.\nNote: The source address must be word alignment.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PDMA_SAR0">
          <name>PDMA_SAR1</name>
          <displayName>PDMA_SAR1</displayName>
          <description>PDMA Channel x Source Address Register</description>
          <alternateRegister>PDMA_SAR0</alternateRegister>
          <addressOffset>0x4</addressOffset>
       </register>
       <register derivedFrom="PDMA_SAR0">
          <name>PDMA_SAR2</name>
          <displayName>PDMA_SAR2</displayName>
          <description>PDMA Channel x Source Address Register</description>
          <alternateRegister>PDMA_SAR0</alternateRegister>
          <addressOffset>0x4</addressOffset>
       </register>
       <register derivedFrom="PDMA_SAR0">
          <name>PDMA_SAR3</name>
          <displayName>PDMA_SAR3</displayName>
          <description>PDMA Channel x Source Address Register</description>
          <alternateRegister>PDMA_SAR0</alternateRegister>
          <addressOffset>0x4</addressOffset>
       </register>
       <register derivedFrom="PDMA_SAR0">
          <name>PDMA_SAR4</name>
          <displayName>PDMA_SAR4</displayName>
          <description>PDMA Channel x Source Address Register</description>
          <alternateRegister>PDMA_SAR0</alternateRegister>
          <addressOffset>0x4</addressOffset>
       </register>
       <register derivedFrom="PDMA_SAR0">
          <name>PDMA_SAR5</name>
          <displayName>PDMA_SAR5</displayName>
          <description>PDMA Channel x Source Address Register</description>
          <alternateRegister>PDMA_SAR0</alternateRegister>
          <addressOffset>0x4</addressOffset>
       </register>
       <register derivedFrom="PDMA_SAR0">
          <name>PDMA_SAR6</name>
          <displayName>PDMA_SAR6</displayName>
          <description>PDMA Channel x Source Address Register</description>
          <alternateRegister>PDMA_SAR0</alternateRegister>
          <addressOffset>0x4</addressOffset>
       </register>
       <register derivedFrom="PDMA_SAR0">
          <name>PDMA_SAR7</name>
          <displayName>PDMA_SAR7</displayName>
          <description>PDMA Channel x Source Address Register</description>
          <alternateRegister>PDMA_SAR0</alternateRegister>
          <addressOffset>0x4</addressOffset>
       </register>
       <register derivedFrom="PDMA_SAR0">
          <name>PDMA_SAR8</name>
          <displayName>PDMA_SAR8</displayName>
          <description>PDMA Channel x Source Address Register</description>
          <alternateRegister>PDMA_SAR0</alternateRegister>
          <addressOffset>0x4</addressOffset>
       </register>
       <register>
          <name>PDMA_DAR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_DAR0</displayName>
          <description>PDMA Channel x Destination Address Register</description>
          <addressOffset>0x8</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_DAR</name>
              <description>PDMA Transfer Destination Address Register\nThis field indicates a 32-bit destination address of PDMA.\nNote: The destination address must be word alignment</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PDMA_DAR0">
          <name>PDMA_DAR1</name>
          <displayName>PDMA_DAR1</displayName>
          <description>PDMA Channel x Destination Address Register</description>
          <alternateRegister>PDMA_DAR0</alternateRegister>
          <addressOffset>0x8</addressOffset>
       </register>
       <register derivedFrom="PDMA_DAR0">
          <name>PDMA_DAR2</name>
          <displayName>PDMA_DAR2</displayName>
          <description>PDMA Channel x Destination Address Register</description>
          <alternateRegister>PDMA_DAR0</alternateRegister>
          <addressOffset>0x8</addressOffset>
       </register>
       <register derivedFrom="PDMA_DAR0">
          <name>PDMA_DAR3</name>
          <displayName>PDMA_DAR3</displayName>
          <description>PDMA Channel x Destination Address Register</description>
          <alternateRegister>PDMA_DAR0</alternateRegister>
          <addressOffset>0x8</addressOffset>
       </register>
       <register derivedFrom="PDMA_DAR0">
          <name>PDMA_DAR4</name>
          <displayName>PDMA_DAR4</displayName>
          <description>PDMA Channel x Destination Address Register</description>
          <alternateRegister>PDMA_DAR0</alternateRegister>
          <addressOffset>0x8</addressOffset>
       </register>
       <register derivedFrom="PDMA_DAR0">
          <name>PDMA_DAR5</name>
          <displayName>PDMA_DAR5</displayName>
          <description>PDMA Channel x Destination Address Register</description>
          <alternateRegister>PDMA_DAR0</alternateRegister>
          <addressOffset>0x8</addressOffset>
       </register>
       <register derivedFrom="PDMA_DAR0">
          <name>PDMA_DAR6</name>
          <displayName>PDMA_DAR6</displayName>
          <description>PDMA Channel x Destination Address Register</description>
          <alternateRegister>PDMA_DAR0</alternateRegister>
          <addressOffset>0x8</addressOffset>
       </register>
       <register derivedFrom="PDMA_DAR0">
          <name>PDMA_DAR7</name>
          <displayName>PDMA_DAR7</displayName>
          <description>PDMA Channel x Destination Address Register</description>
          <alternateRegister>PDMA_DAR0</alternateRegister>
          <addressOffset>0x8</addressOffset>
       </register>
       <register derivedFrom="PDMA_DAR0">
          <name>PDMA_DAR8</name>
          <displayName>PDMA_DAR8</displayName>
          <description>PDMA Channel x Destination Address Register</description>
          <alternateRegister>PDMA_DAR0</alternateRegister>
          <addressOffset>0x8</addressOffset>
       </register>
       <register>
          <name>PDMA_BCR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_BCR0</displayName>
          <description>PDMA Channel x Transfer Byte Count Register</description>
          <addressOffset>0xC</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_BCR</name>
              <description>PDMA Transfer Byte Count Register\nThis field indicates a 16-bit transfer byte count number of PDMA; it must be word alignment.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PDMA_BCR0">
          <name>PDMA_BCR1</name>
          <displayName>PDMA_BCR1</displayName>
          <description>PDMA Channel x Transfer Byte Count Register</description>
          <alternateRegister>PDMA_BCR0</alternateRegister>
          <addressOffset>0xC</addressOffset>
       </register>
       <register derivedFrom="PDMA_BCR0">
          <name>PDMA_BCR2</name>
          <displayName>PDMA_BCR2</displayName>
          <description>PDMA Channel x Transfer Byte Count Register</description>
          <alternateRegister>PDMA_BCR0</alternateRegister>
          <addressOffset>0xC</addressOffset>
       </register>
       <register derivedFrom="PDMA_BCR0">
          <name>PDMA_BCR3</name>
          <displayName>PDMA_BCR3</displayName>
          <description>PDMA Channel x Transfer Byte Count Register</description>
          <alternateRegister>PDMA_BCR0</alternateRegister>
          <addressOffset>0xC</addressOffset>
       </register>
       <register derivedFrom="PDMA_BCR0">
          <name>PDMA_BCR4</name>
          <displayName>PDMA_BCR4</displayName>
          <description>PDMA Channel x Transfer Byte Count Register</description>
          <alternateRegister>PDMA_BCR0</alternateRegister>
          <addressOffset>0xC</addressOffset>
       </register>
       <register derivedFrom="PDMA_BCR0">
          <name>PDMA_BCR5</name>
          <displayName>PDMA_BCR5</displayName>
          <description>PDMA Channel x Transfer Byte Count Register</description>
          <alternateRegister>PDMA_BCR0</alternateRegister>
          <addressOffset>0xC</addressOffset>
       </register>
       <register derivedFrom="PDMA_BCR0">
          <name>PDMA_BCR6</name>
          <displayName>PDMA_BCR6</displayName>
          <description>PDMA Channel x Transfer Byte Count Register</description>
          <alternateRegister>PDMA_BCR0</alternateRegister>
          <addressOffset>0xC</addressOffset>
       </register>
       <register derivedFrom="PDMA_BCR0">
          <name>PDMA_BCR7</name>
          <displayName>PDMA_BCR7</displayName>
          <description>PDMA Channel x Transfer Byte Count Register</description>
          <alternateRegister>PDMA_BCR0</alternateRegister>
          <addressOffset>0xC</addressOffset>
       </register>
       <register derivedFrom="PDMA_BCR0">
          <name>PDMA_BCR8</name>
          <displayName>PDMA_BCR8</displayName>
          <description>PDMA Channel x Transfer Byte Count Register</description>
          <alternateRegister>PDMA_BCR0</alternateRegister>
          <addressOffset>0xC</addressOffset>
       </register>
       <register>
          <name>PDMA_POINT0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_POINT0</displayName>
          <description>PDMA Channel x Internal Buffer Pointer Register</description>
          <addressOffset>0x10</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_POINT</name>
              <description>PDMA Internal Buffer Pointer Register (Read Only)\nThis field indicates the internal buffer pointer.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PDMA_POINT0">
          <name>PDMA_POINT1</name>
          <displayName>PDMA_POINT1</displayName>
          <description>PDMA Channel x Internal Buffer Pointer Register</description>
          <alternateRegister>PDMA_POINT0</alternateRegister>
          <addressOffset>0x10</addressOffset>
       </register>
       <register derivedFrom="PDMA_POINT0">
          <name>PDMA_POINT2</name>
          <displayName>PDMA_POINT2</displayName>
          <description>PDMA Channel x Internal Buffer Pointer Register</description>
          <alternateRegister>PDMA_POINT0</alternateRegister>
          <addressOffset>0x10</addressOffset>
       </register>
       <register derivedFrom="PDMA_POINT0">
          <name>PDMA_POINT3</name>
          <displayName>PDMA_POINT3</displayName>
          <description>PDMA Channel x Internal Buffer Pointer Register</description>
          <alternateRegister>PDMA_POINT0</alternateRegister>
          <addressOffset>0x10</addressOffset>
       </register>
       <register derivedFrom="PDMA_POINT0">
          <name>PDMA_POINT4</name>
          <displayName>PDMA_POINT4</displayName>
          <description>PDMA Channel x Internal Buffer Pointer Register</description>
          <alternateRegister>PDMA_POINT0</alternateRegister>
          <addressOffset>0x10</addressOffset>
       </register>
       <register derivedFrom="PDMA_POINT0">
          <name>PDMA_POINT5</name>
          <displayName>PDMA_POINT5</displayName>
          <description>PDMA Channel x Internal Buffer Pointer Register</description>
          <alternateRegister>PDMA_POINT0</alternateRegister>
          <addressOffset>0x10</addressOffset>
       </register>
       <register derivedFrom="PDMA_POINT0">
          <name>PDMA_POINT6</name>
          <displayName>PDMA_POINT6</displayName>
          <description>PDMA Channel x Internal Buffer Pointer Register</description>
          <alternateRegister>PDMA_POINT0</alternateRegister>
          <addressOffset>0x10</addressOffset>
       </register>
       <register derivedFrom="PDMA_POINT0">
          <name>PDMA_POINT7</name>
          <displayName>PDMA_POINT7</displayName>
          <description>PDMA Channel x Internal Buffer Pointer Register</description>
          <alternateRegister>PDMA_POINT0</alternateRegister>
          <addressOffset>0x10</addressOffset>
       </register>
       <register derivedFrom="PDMA_POINT0">
          <name>PDMA_POINT8</name>
          <displayName>PDMA_POINT8</displayName>
          <description>PDMA Channel x Internal Buffer Pointer Register</description>
          <alternateRegister>PDMA_POINT0</alternateRegister>
          <addressOffset>0x10</addressOffset>
       </register>
       <register>
          <name>PDMA_CSAR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_CSAR0</displayName>
          <description>PDMA Channel x Current Source Address Register</description>
          <addressOffset>0x14</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_CSAR</name>
              <description>PDMA Current Source Address Register (Read Only)\nThis field indicates the source address where the PDMA transfer just occurred.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PDMA_CSAR0">
          <name>PDMA_CSAR1</name>
          <displayName>PDMA_CSAR1</displayName>
          <description>PDMA Channel x Current Source Address Register</description>
          <alternateRegister>PDMA_CSAR0</alternateRegister>
          <addressOffset>0x14</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSAR0">
          <name>PDMA_CSAR2</name>
          <displayName>PDMA_CSAR2</displayName>
          <description>PDMA Channel x Current Source Address Register</description>
          <alternateRegister>PDMA_CSAR0</alternateRegister>
          <addressOffset>0x14</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSAR0">
          <name>PDMA_CSAR3</name>
          <displayName>PDMA_CSAR3</displayName>
          <description>PDMA Channel x Current Source Address Register</description>
          <alternateRegister>PDMA_CSAR0</alternateRegister>
          <addressOffset>0x14</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSAR0">
          <name>PDMA_CSAR4</name>
          <displayName>PDMA_CSAR4</displayName>
          <description>PDMA Channel x Current Source Address Register</description>
          <alternateRegister>PDMA_CSAR0</alternateRegister>
          <addressOffset>0x14</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSAR0">
          <name>PDMA_CSAR5</name>
          <displayName>PDMA_CSAR5</displayName>
          <description>PDMA Channel x Current Source Address Register</description>
          <alternateRegister>PDMA_CSAR0</alternateRegister>
          <addressOffset>0x14</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSAR0">
          <name>PDMA_CSAR6</name>
          <displayName>PDMA_CSAR6</displayName>
          <description>PDMA Channel x Current Source Address Register</description>
          <alternateRegister>PDMA_CSAR0</alternateRegister>
          <addressOffset>0x14</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSAR0">
          <name>PDMA_CSAR7</name>
          <displayName>PDMA_CSAR7</displayName>
          <description>PDMA Channel x Current Source Address Register</description>
          <alternateRegister>PDMA_CSAR0</alternateRegister>
          <addressOffset>0x14</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSAR0">
          <name>PDMA_CSAR8</name>
          <displayName>PDMA_CSAR8</displayName>
          <description>PDMA Channel x Current Source Address Register</description>
          <alternateRegister>PDMA_CSAR0</alternateRegister>
          <addressOffset>0x14</addressOffset>
       </register>
       <register>
          <name>PDMA_CDAR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_CDAR0</displayName>
          <description>PDMA Channel x Current Destination Address Register</description>
          <addressOffset>0x18</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_CDAR</name>
              <description>PDMA Current Destination Address Register (Read Only)\nThis field indicates the destination address where the PDMA transfer just occurred.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PDMA_CDAR0">
          <name>PDMA_CDAR1</name>
          <displayName>PDMA_CDAR1</displayName>
          <description>PDMA Channel x Current Destination Address Register</description>
          <alternateRegister>PDMA_CDAR0</alternateRegister>
          <addressOffset>0x18</addressOffset>
       </register>
       <register derivedFrom="PDMA_CDAR0">
          <name>PDMA_CDAR2</name>
          <displayName>PDMA_CDAR2</displayName>
          <description>PDMA Channel x Current Destination Address Register</description>
          <alternateRegister>PDMA_CDAR0</alternateRegister>
          <addressOffset>0x18</addressOffset>
       </register>
       <register derivedFrom="PDMA_CDAR0">
          <name>PDMA_CDAR3</name>
          <displayName>PDMA_CDAR3</displayName>
          <description>PDMA Channel x Current Destination Address Register</description>
          <alternateRegister>PDMA_CDAR0</alternateRegister>
          <addressOffset>0x18</addressOffset>
       </register>
       <register derivedFrom="PDMA_CDAR0">
          <name>PDMA_CDAR4</name>
          <displayName>PDMA_CDAR4</displayName>
          <description>PDMA Channel x Current Destination Address Register</description>
          <alternateRegister>PDMA_CDAR0</alternateRegister>
          <addressOffset>0x18</addressOffset>
       </register>
       <register derivedFrom="PDMA_CDAR0">
          <name>PDMA_CDAR5</name>
          <displayName>PDMA_CDAR5</displayName>
          <description>PDMA Channel x Current Destination Address Register</description>
          <alternateRegister>PDMA_CDAR0</alternateRegister>
          <addressOffset>0x18</addressOffset>
       </register>
       <register derivedFrom="PDMA_CDAR0">
          <name>PDMA_CDAR6</name>
          <displayName>PDMA_CDAR6</displayName>
          <description>PDMA Channel x Current Destination Address Register</description>
          <alternateRegister>PDMA_CDAR0</alternateRegister>
          <addressOffset>0x18</addressOffset>
       </register>
       <register derivedFrom="PDMA_CDAR0">
          <name>PDMA_CDAR7</name>
          <displayName>PDMA_CDAR7</displayName>
          <description>PDMA Channel x Current Destination Address Register</description>
          <alternateRegister>PDMA_CDAR0</alternateRegister>
          <addressOffset>0x18</addressOffset>
       </register>
       <register derivedFrom="PDMA_CDAR0">
          <name>PDMA_CDAR8</name>
          <displayName>PDMA_CDAR8</displayName>
          <description>PDMA Channel x Current Destination Address Register</description>
          <alternateRegister>PDMA_CDAR0</alternateRegister>
          <addressOffset>0x18</addressOffset>
       </register>
       <register>
          <name>PDMA_CBCR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_CBCR0</displayName>
          <description>PDMA Channel x Current Transfer Byte Count Register</description>
          <addressOffset>0x1C</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_CBCR</name>
              <description>PDMA Current Byte Count Register (Read Only)\nThis field indicates the current remained byte count of PDMA.\nNote: This field value will be cleared to 0, when software set SW_RST (PDMA_CSRx[1]) to "1".</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PDMA_CBCR0">
          <name>PDMA_CBCR1</name>
          <displayName>PDMA_CBCR1</displayName>
          <description>PDMA Channel x Current Transfer Byte Count Register</description>
          <alternateRegister>PDMA_CBCR0</alternateRegister>
          <addressOffset>0x1C</addressOffset>
       </register>
       <register derivedFrom="PDMA_CBCR0">
          <name>PDMA_CBCR2</name>
          <displayName>PDMA_CBCR2</displayName>
          <description>PDMA Channel x Current Transfer Byte Count Register</description>
          <alternateRegister>PDMA_CBCR0</alternateRegister>
          <addressOffset>0x1C</addressOffset>
       </register>
       <register derivedFrom="PDMA_CBCR0">
          <name>PDMA_CBCR3</name>
          <displayName>PDMA_CBCR3</displayName>
          <description>PDMA Channel x Current Transfer Byte Count Register</description>
          <alternateRegister>PDMA_CBCR0</alternateRegister>
          <addressOffset>0x1C</addressOffset>
       </register>
       <register derivedFrom="PDMA_CBCR0">
          <name>PDMA_CBCR4</name>
          <displayName>PDMA_CBCR4</displayName>
          <description>PDMA Channel x Current Transfer Byte Count Register</description>
          <alternateRegister>PDMA_CBCR0</alternateRegister>
          <addressOffset>0x1C</addressOffset>
       </register>
       <register derivedFrom="PDMA_CBCR0">
          <name>PDMA_CBCR5</name>
          <displayName>PDMA_CBCR5</displayName>
          <description>PDMA Channel x Current Transfer Byte Count Register</description>
          <alternateRegister>PDMA_CBCR0</alternateRegister>
          <addressOffset>0x1C</addressOffset>
       </register>
       <register derivedFrom="PDMA_CBCR0">
          <name>PDMA_CBCR6</name>
          <displayName>PDMA_CBCR6</displayName>
          <description>PDMA Channel x Current Transfer Byte Count Register</description>
          <alternateRegister>PDMA_CBCR0</alternateRegister>
          <addressOffset>0x1C</addressOffset>
       </register>
       <register derivedFrom="PDMA_CBCR0">
          <name>PDMA_CBCR7</name>
          <displayName>PDMA_CBCR7</displayName>
          <description>PDMA Channel x Current Transfer Byte Count Register</description>
          <alternateRegister>PDMA_CBCR0</alternateRegister>
          <addressOffset>0x1C</addressOffset>
       </register>
       <register derivedFrom="PDMA_CBCR0">
          <name>PDMA_CBCR8</name>
          <displayName>PDMA_CBCR8</displayName>
          <description>PDMA Channel x Current Transfer Byte Count Register</description>
          <alternateRegister>PDMA_CBCR0</alternateRegister>
          <addressOffset>0x1C</addressOffset>
       </register>
       <register>
          <name>PDMA_IER0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_IER0</displayName>
          <description>PDMA Channel x Interrupt Enable Register</description>
          <addressOffset>0x20</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000001</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TABORT_IE</name>
              <description>PDMA Read/Write Target Abort Interrupt Enable Bit\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Target abort interrupt generation Disabled during PDMA transfer</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Target abort interrupt generation Enabled during PDMA transfer</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BLKD_IE</name>
              <description>PDMA Block Transfer Done Interrupt Enable Bit\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Interrupt generator Disabled when PDMA transfer is done</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Interrupt generator Enabled when PDMA transfer is done</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PDMA_IER0">
          <name>PDMA_IER1</name>
          <displayName>PDMA_IER1</displayName>
          <description>PDMA Channel x Interrupt Enable Register</description>
          <alternateRegister>PDMA_IER0</alternateRegister>
          <addressOffset>0x20</addressOffset>
       </register>
       <register derivedFrom="PDMA_IER0">
          <name>PDMA_IER2</name>
          <displayName>PDMA_IER2</displayName>
          <description>PDMA Channel x Interrupt Enable Register</description>
          <alternateRegister>PDMA_IER0</alternateRegister>
          <addressOffset>0x20</addressOffset>
       </register>
       <register derivedFrom="PDMA_IER0">
          <name>PDMA_IER3</name>
          <displayName>PDMA_IER3</displayName>
          <description>PDMA Channel x Interrupt Enable Register</description>
          <alternateRegister>PDMA_IER0</alternateRegister>
          <addressOffset>0x20</addressOffset>
       </register>
       <register derivedFrom="PDMA_IER0">
          <name>PDMA_IER4</name>
          <displayName>PDMA_IER4</displayName>
          <description>PDMA Channel x Interrupt Enable Register</description>
          <alternateRegister>PDMA_IER0</alternateRegister>
          <addressOffset>0x20</addressOffset>
       </register>
       <register derivedFrom="PDMA_IER0">
          <name>PDMA_IER5</name>
          <displayName>PDMA_IER5</displayName>
          <description>PDMA Channel x Interrupt Enable Register</description>
          <alternateRegister>PDMA_IER0</alternateRegister>
          <addressOffset>0x20</addressOffset>
       </register>
       <register derivedFrom="PDMA_IER0">
          <name>PDMA_IER6</name>
          <displayName>PDMA_IER6</displayName>
          <description>PDMA Channel x Interrupt Enable Register</description>
          <alternateRegister>PDMA_IER0</alternateRegister>
          <addressOffset>0x20</addressOffset>
       </register>
       <register derivedFrom="PDMA_IER0">
          <name>PDMA_IER7</name>
          <displayName>PDMA_IER7</displayName>
          <description>PDMA Channel x Interrupt Enable Register</description>
          <alternateRegister>PDMA_IER0</alternateRegister>
          <addressOffset>0x20</addressOffset>
       </register>
       <register derivedFrom="PDMA_IER0">
          <name>PDMA_IER8</name>
          <displayName>PDMA_IER8</displayName>
          <description>PDMA Channel x Interrupt Enable Register</description>
          <alternateRegister>PDMA_IER0</alternateRegister>
          <addressOffset>0x20</addressOffset>
       </register>
       <register>
          <name>PDMA_ISR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_ISR0</displayName>
          <description>PDMA Channel x Interrupt Status Register</description>
          <addressOffset>0x24</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TABORT_IF</name>
              <description>PDMA Read/Write Target Abort Interrupt Flag\nWrite 1 to clear this bit to 0.\nNote: This bit filed indicates bus master received ERROR response or not. If bus master received ERROR response, it means that target abort is happened. PDMA controller will stop transfer and respond this event to software then goes to IDLE state. When target abort occurred, software must reset PDMA, and then transfer those data again.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No bus ERROR response received</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Bus ERROR response received</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BLKD_IF</name>
              <description>PDMA Block Transfer Done Interrupt Flag\nThis bit indicates that PDMA has finished all transfers.\nWrite 1 to clear this bit to 0.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Not finished</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Done</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PDMA_ISR0">
          <name>PDMA_ISR1</name>
          <displayName>PDMA_ISR1</displayName>
          <description>PDMA Channel x Interrupt Status Register</description>
          <alternateRegister>PDMA_ISR0</alternateRegister>
          <addressOffset>0x24</addressOffset>
       </register>
       <register derivedFrom="PDMA_ISR0">
          <name>PDMA_ISR2</name>
          <displayName>PDMA_ISR2</displayName>
          <description>PDMA Channel x Interrupt Status Register</description>
          <alternateRegister>PDMA_ISR0</alternateRegister>
          <addressOffset>0x24</addressOffset>
       </register>
       <register derivedFrom="PDMA_ISR0">
          <name>PDMA_ISR3</name>
          <displayName>PDMA_ISR3</displayName>
          <description>PDMA Channel x Interrupt Status Register</description>
          <alternateRegister>PDMA_ISR0</alternateRegister>
          <addressOffset>0x24</addressOffset>
       </register>
       <register derivedFrom="PDMA_ISR0">
          <name>PDMA_ISR4</name>
          <displayName>PDMA_ISR4</displayName>
          <description>PDMA Channel x Interrupt Status Register</description>
          <alternateRegister>PDMA_ISR0</alternateRegister>
          <addressOffset>0x24</addressOffset>
       </register>
       <register derivedFrom="PDMA_ISR0">
          <name>PDMA_ISR5</name>
          <displayName>PDMA_ISR5</displayName>
          <description>PDMA Channel x Interrupt Status Register</description>
          <alternateRegister>PDMA_ISR0</alternateRegister>
          <addressOffset>0x24</addressOffset>
       </register>
       <register derivedFrom="PDMA_ISR0">
          <name>PDMA_ISR6</name>
          <displayName>PDMA_ISR6</displayName>
          <description>PDMA Channel x Interrupt Status Register</description>
          <alternateRegister>PDMA_ISR0</alternateRegister>
          <addressOffset>0x24</addressOffset>
       </register>
       <register derivedFrom="PDMA_ISR0">
          <name>PDMA_ISR7</name>
          <displayName>PDMA_ISR7</displayName>
          <description>PDMA Channel x Interrupt Status Register</description>
          <alternateRegister>PDMA_ISR0</alternateRegister>
          <addressOffset>0x24</addressOffset>
       </register>
       <register derivedFrom="PDMA_ISR0">
          <name>PDMA_ISR8</name>
          <displayName>PDMA_ISR8</displayName>
          <description>PDMA Channel x Interrupt Status Register</description>
          <alternateRegister>PDMA_ISR0</alternateRegister>
          <addressOffset>0x24</addressOffset>
       </register>
       <register>
          <name>PDMA_SBUF0_C0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_SBUF0_C0</displayName>
          <description>PDMA Channel x Shared Buffer FIFO 0 Register</description>
          <addressOffset>0x80</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_SBUF0</name>
              <description>PDMA Shared Buffer FIFO 0 (Read Only)\nEach channel has its own 1 word internal buffer.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PDMA_SBUF0_C0">
          <name>PDMA_SBUF0_C1</name>
          <displayName>PDMA_SBUF0_C1</displayName>
          <description>PDMA Channel x Shared Buffer FIFO 0 Register</description>
          <alternateRegister>PDMA_SBUF0_C0</alternateRegister>
          <addressOffset>0x80</addressOffset>
       </register>
       <register derivedFrom="PDMA_SBUF0_C0">
          <name>PDMA_SBUF0_C2</name>
          <displayName>PDMA_SBUF0_C2</displayName>
          <description>PDMA Channel x Shared Buffer FIFO 0 Register</description>
          <alternateRegister>PDMA_SBUF0_C0</alternateRegister>
          <addressOffset>0x80</addressOffset>
       </register>
       <register derivedFrom="PDMA_SBUF0_C0">
          <name>PDMA_SBUF0_C3</name>
          <displayName>PDMA_SBUF0_C3</displayName>
          <description>PDMA Channel x Shared Buffer FIFO 0 Register</description>
          <alternateRegister>PDMA_SBUF0_C0</alternateRegister>
          <addressOffset>0x80</addressOffset>
       </register>
       <register derivedFrom="PDMA_SBUF0_C0">
          <name>PDMA_SBUF0_C4</name>
          <displayName>PDMA_SBUF0_C4</displayName>
          <description>PDMA Channel x Shared Buffer FIFO 0 Register</description>
          <alternateRegister>PDMA_SBUF0_C0</alternateRegister>
          <addressOffset>0x80</addressOffset>
       </register>
       <register derivedFrom="PDMA_SBUF0_C0">
          <name>PDMA_SBUF0_C5</name>
          <displayName>PDMA_SBUF0_C5</displayName>
          <description>PDMA Channel x Shared Buffer FIFO 0 Register</description>
          <alternateRegister>PDMA_SBUF0_C0</alternateRegister>
          <addressOffset>0x80</addressOffset>
       </register>
       <register derivedFrom="PDMA_SBUF0_C0">
          <name>PDMA_SBUF0_C6</name>
          <displayName>PDMA_SBUF0_C6</displayName>
          <description>PDMA Channel x Shared Buffer FIFO 0 Register</description>
          <alternateRegister>PDMA_SBUF0_C0</alternateRegister>
          <addressOffset>0x80</addressOffset>
       </register>
       <register derivedFrom="PDMA_SBUF0_C0">
          <name>PDMA_SBUF0_C7</name>
          <displayName>PDMA_SBUF0_C7</displayName>
          <description>PDMA Channel x Shared Buffer FIFO 0 Register</description>
          <alternateRegister>PDMA_SBUF0_C0</alternateRegister>
          <addressOffset>0x80</addressOffset>
       </register>
       <register derivedFrom="PDMA_SBUF0_C0">
          <name>PDMA_SBUF0_C8</name>
          <displayName>PDMA_SBUF0_C8</displayName>
          <description>PDMA Channel x Shared Buffer FIFO 0 Register</description>
          <alternateRegister>PDMA_SBUF0_C0</alternateRegister>
          <addressOffset>0x80</addressOffset>
       </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>PDMA_CH8</name>
      <description>PDMA Register Map</description>
      <groupName>PDMA</groupName>
      <baseAddress>0x50008800</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x0</offset>
        <size>0x28</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x80</offset>
        <size>0x4</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>PDMA_CSR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_CSR0</displayName>
          <description>PDMA Channel x Control Register</description>
          <addressOffset>0x0</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMACEN</name>
              <description>PDMA Channel Enable Bit\nSetting this bit to 1 enables PDMA operation. If this bit is cleared, PDMA will ignore all PDMA request and force Bus Master into IDLE state.\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_RST</name>
              <description>Software Engine Reset\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reset the internal state machine, pointers and internal buffer. The contents of control register will not be cleared. This bit will be automatically cleared after few clock cycles</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>MODE_SEL</name>
              <description>PDMA Mode Selection\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Memory to Memory mode (Memory-to-Memory)</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Peripheral to Memory mode (Peripheral-to-Memory)</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Memory to Peripheral mode (Memory-to-Peripheral)</description>
                    <value>#10</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SAD_SEL</name>
              <description>Transfer Source Address Direction Selection\n</description>
              <bitOffset>4</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Transfer source address is increasing successively</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reserved</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Transfer source address is fixed (This feature can be used when data where transferred from a single source to multiple destinations)</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Reserved</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DAD_SEL</name>
              <description>Transfer Destination Address Direction Selection\n</description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Transfer destination address is increasing successively</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reserved</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Transfer destination address is fixed. (This feature can be used when data where transferred from multiple sources to a single destination)</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Reserved</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>APB_TWS</name>
              <description>Peripheral Transfer Width Selection\nNote: This field is meaningful only when MODE_SEL (PDMA_CSRx[3:2]) is Peripheral to Memory mode (Peripheral-to-Memory) or Memory to Peripheral mode (Memory-to-Peripheral).</description>
              <bitOffset>19</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>One word (32-bit) is transferred for every PDMA operation</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>One byte (8-bit) is transferred for every PDMA operation</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>One half-word (16-bit) is transferred for every PDMA operation</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Reserved</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TRIG_EN</name>
              <description>Trigger Enable Bit\nNote: When PDMA transfer completed, this bit will be cleared automatically.\nIf the bus error occurs, all PDMA transfer will be stopped. Software must reset all PDMA channel, and then trigger again.</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PDMA data read or write transfer Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PDMA_CSR0">
          <name>PDMA_CSR1</name>
          <displayName>PDMA_CSR1</displayName>
          <description>PDMA Channel x Control Register</description>
          <alternateRegister>PDMA_CSR0</alternateRegister>
          <addressOffset>0x0</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSR0">
          <name>PDMA_CSR2</name>
          <displayName>PDMA_CSR2</displayName>
          <description>PDMA Channel x Control Register</description>
          <alternateRegister>PDMA_CSR0</alternateRegister>
          <addressOffset>0x0</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSR0">
          <name>PDMA_CSR3</name>
          <displayName>PDMA_CSR3</displayName>
          <description>PDMA Channel x Control Register</description>
          <alternateRegister>PDMA_CSR0</alternateRegister>
          <addressOffset>0x0</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSR0">
          <name>PDMA_CSR4</name>
          <displayName>PDMA_CSR4</displayName>
          <description>PDMA Channel x Control Register</description>
          <alternateRegister>PDMA_CSR0</alternateRegister>
          <addressOffset>0x0</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSR0">
          <name>PDMA_CSR5</name>
          <displayName>PDMA_CSR5</displayName>
          <description>PDMA Channel x Control Register</description>
          <alternateRegister>PDMA_CSR0</alternateRegister>
          <addressOffset>0x0</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSR0">
          <name>PDMA_CSR6</name>
          <displayName>PDMA_CSR6</displayName>
          <description>PDMA Channel x Control Register</description>
          <alternateRegister>PDMA_CSR0</alternateRegister>
          <addressOffset>0x0</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSR0">
          <name>PDMA_CSR7</name>
          <displayName>PDMA_CSR7</displayName>
          <description>PDMA Channel x Control Register</description>
          <alternateRegister>PDMA_CSR0</alternateRegister>
          <addressOffset>0x0</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSR0">
          <name>PDMA_CSR8</name>
          <displayName>PDMA_CSR8</displayName>
          <description>PDMA Channel x Control Register</description>
          <alternateRegister>PDMA_CSR0</alternateRegister>
          <addressOffset>0x0</addressOffset>
       </register>
       <register>
          <name>PDMA_SAR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_SAR0</displayName>
          <description>PDMA Channel x Source Address Register</description>
          <addressOffset>0x4</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_SAR</name>
              <description>PDMA Transfer Source Address Register\nThis field indicates a 32-bit source address of PDMA.\nNote: The source address must be word alignment.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PDMA_SAR0">
          <name>PDMA_SAR1</name>
          <displayName>PDMA_SAR1</displayName>
          <description>PDMA Channel x Source Address Register</description>
          <alternateRegister>PDMA_SAR0</alternateRegister>
          <addressOffset>0x4</addressOffset>
       </register>
       <register derivedFrom="PDMA_SAR0">
          <name>PDMA_SAR2</name>
          <displayName>PDMA_SAR2</displayName>
          <description>PDMA Channel x Source Address Register</description>
          <alternateRegister>PDMA_SAR0</alternateRegister>
          <addressOffset>0x4</addressOffset>
       </register>
       <register derivedFrom="PDMA_SAR0">
          <name>PDMA_SAR3</name>
          <displayName>PDMA_SAR3</displayName>
          <description>PDMA Channel x Source Address Register</description>
          <alternateRegister>PDMA_SAR0</alternateRegister>
          <addressOffset>0x4</addressOffset>
       </register>
       <register derivedFrom="PDMA_SAR0">
          <name>PDMA_SAR4</name>
          <displayName>PDMA_SAR4</displayName>
          <description>PDMA Channel x Source Address Register</description>
          <alternateRegister>PDMA_SAR0</alternateRegister>
          <addressOffset>0x4</addressOffset>
       </register>
       <register derivedFrom="PDMA_SAR0">
          <name>PDMA_SAR5</name>
          <displayName>PDMA_SAR5</displayName>
          <description>PDMA Channel x Source Address Register</description>
          <alternateRegister>PDMA_SAR0</alternateRegister>
          <addressOffset>0x4</addressOffset>
       </register>
       <register derivedFrom="PDMA_SAR0">
          <name>PDMA_SAR6</name>
          <displayName>PDMA_SAR6</displayName>
          <description>PDMA Channel x Source Address Register</description>
          <alternateRegister>PDMA_SAR0</alternateRegister>
          <addressOffset>0x4</addressOffset>
       </register>
       <register derivedFrom="PDMA_SAR0">
          <name>PDMA_SAR7</name>
          <displayName>PDMA_SAR7</displayName>
          <description>PDMA Channel x Source Address Register</description>
          <alternateRegister>PDMA_SAR0</alternateRegister>
          <addressOffset>0x4</addressOffset>
       </register>
       <register derivedFrom="PDMA_SAR0">
          <name>PDMA_SAR8</name>
          <displayName>PDMA_SAR8</displayName>
          <description>PDMA Channel x Source Address Register</description>
          <alternateRegister>PDMA_SAR0</alternateRegister>
          <addressOffset>0x4</addressOffset>
       </register>
       <register>
          <name>PDMA_DAR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_DAR0</displayName>
          <description>PDMA Channel x Destination Address Register</description>
          <addressOffset>0x8</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_DAR</name>
              <description>PDMA Transfer Destination Address Register\nThis field indicates a 32-bit destination address of PDMA.\nNote: The destination address must be word alignment</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PDMA_DAR0">
          <name>PDMA_DAR1</name>
          <displayName>PDMA_DAR1</displayName>
          <description>PDMA Channel x Destination Address Register</description>
          <alternateRegister>PDMA_DAR0</alternateRegister>
          <addressOffset>0x8</addressOffset>
       </register>
       <register derivedFrom="PDMA_DAR0">
          <name>PDMA_DAR2</name>
          <displayName>PDMA_DAR2</displayName>
          <description>PDMA Channel x Destination Address Register</description>
          <alternateRegister>PDMA_DAR0</alternateRegister>
          <addressOffset>0x8</addressOffset>
       </register>
       <register derivedFrom="PDMA_DAR0">
          <name>PDMA_DAR3</name>
          <displayName>PDMA_DAR3</displayName>
          <description>PDMA Channel x Destination Address Register</description>
          <alternateRegister>PDMA_DAR0</alternateRegister>
          <addressOffset>0x8</addressOffset>
       </register>
       <register derivedFrom="PDMA_DAR0">
          <name>PDMA_DAR4</name>
          <displayName>PDMA_DAR4</displayName>
          <description>PDMA Channel x Destination Address Register</description>
          <alternateRegister>PDMA_DAR0</alternateRegister>
          <addressOffset>0x8</addressOffset>
       </register>
       <register derivedFrom="PDMA_DAR0">
          <name>PDMA_DAR5</name>
          <displayName>PDMA_DAR5</displayName>
          <description>PDMA Channel x Destination Address Register</description>
          <alternateRegister>PDMA_DAR0</alternateRegister>
          <addressOffset>0x8</addressOffset>
       </register>
       <register derivedFrom="PDMA_DAR0">
          <name>PDMA_DAR6</name>
          <displayName>PDMA_DAR6</displayName>
          <description>PDMA Channel x Destination Address Register</description>
          <alternateRegister>PDMA_DAR0</alternateRegister>
          <addressOffset>0x8</addressOffset>
       </register>
       <register derivedFrom="PDMA_DAR0">
          <name>PDMA_DAR7</name>
          <displayName>PDMA_DAR7</displayName>
          <description>PDMA Channel x Destination Address Register</description>
          <alternateRegister>PDMA_DAR0</alternateRegister>
          <addressOffset>0x8</addressOffset>
       </register>
       <register derivedFrom="PDMA_DAR0">
          <name>PDMA_DAR8</name>
          <displayName>PDMA_DAR8</displayName>
          <description>PDMA Channel x Destination Address Register</description>
          <alternateRegister>PDMA_DAR0</alternateRegister>
          <addressOffset>0x8</addressOffset>
       </register>
       <register>
          <name>PDMA_BCR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_BCR0</displayName>
          <description>PDMA Channel x Transfer Byte Count Register</description>
          <addressOffset>0xC</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_BCR</name>
              <description>PDMA Transfer Byte Count Register\nThis field indicates a 16-bit transfer byte count number of PDMA; it must be word alignment.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PDMA_BCR0">
          <name>PDMA_BCR1</name>
          <displayName>PDMA_BCR1</displayName>
          <description>PDMA Channel x Transfer Byte Count Register</description>
          <alternateRegister>PDMA_BCR0</alternateRegister>
          <addressOffset>0xC</addressOffset>
       </register>
       <register derivedFrom="PDMA_BCR0">
          <name>PDMA_BCR2</name>
          <displayName>PDMA_BCR2</displayName>
          <description>PDMA Channel x Transfer Byte Count Register</description>
          <alternateRegister>PDMA_BCR0</alternateRegister>
          <addressOffset>0xC</addressOffset>
       </register>
       <register derivedFrom="PDMA_BCR0">
          <name>PDMA_BCR3</name>
          <displayName>PDMA_BCR3</displayName>
          <description>PDMA Channel x Transfer Byte Count Register</description>
          <alternateRegister>PDMA_BCR0</alternateRegister>
          <addressOffset>0xC</addressOffset>
       </register>
       <register derivedFrom="PDMA_BCR0">
          <name>PDMA_BCR4</name>
          <displayName>PDMA_BCR4</displayName>
          <description>PDMA Channel x Transfer Byte Count Register</description>
          <alternateRegister>PDMA_BCR0</alternateRegister>
          <addressOffset>0xC</addressOffset>
       </register>
       <register derivedFrom="PDMA_BCR0">
          <name>PDMA_BCR5</name>
          <displayName>PDMA_BCR5</displayName>
          <description>PDMA Channel x Transfer Byte Count Register</description>
          <alternateRegister>PDMA_BCR0</alternateRegister>
          <addressOffset>0xC</addressOffset>
       </register>
       <register derivedFrom="PDMA_BCR0">
          <name>PDMA_BCR6</name>
          <displayName>PDMA_BCR6</displayName>
          <description>PDMA Channel x Transfer Byte Count Register</description>
          <alternateRegister>PDMA_BCR0</alternateRegister>
          <addressOffset>0xC</addressOffset>
       </register>
       <register derivedFrom="PDMA_BCR0">
          <name>PDMA_BCR7</name>
          <displayName>PDMA_BCR7</displayName>
          <description>PDMA Channel x Transfer Byte Count Register</description>
          <alternateRegister>PDMA_BCR0</alternateRegister>
          <addressOffset>0xC</addressOffset>
       </register>
       <register derivedFrom="PDMA_BCR0">
          <name>PDMA_BCR8</name>
          <displayName>PDMA_BCR8</displayName>
          <description>PDMA Channel x Transfer Byte Count Register</description>
          <alternateRegister>PDMA_BCR0</alternateRegister>
          <addressOffset>0xC</addressOffset>
       </register>
       <register>
          <name>PDMA_POINT0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_POINT0</displayName>
          <description>PDMA Channel x Internal Buffer Pointer Register</description>
          <addressOffset>0x10</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_POINT</name>
              <description>PDMA Internal Buffer Pointer Register (Read Only)\nThis field indicates the internal buffer pointer.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PDMA_POINT0">
          <name>PDMA_POINT1</name>
          <displayName>PDMA_POINT1</displayName>
          <description>PDMA Channel x Internal Buffer Pointer Register</description>
          <alternateRegister>PDMA_POINT0</alternateRegister>
          <addressOffset>0x10</addressOffset>
       </register>
       <register derivedFrom="PDMA_POINT0">
          <name>PDMA_POINT2</name>
          <displayName>PDMA_POINT2</displayName>
          <description>PDMA Channel x Internal Buffer Pointer Register</description>
          <alternateRegister>PDMA_POINT0</alternateRegister>
          <addressOffset>0x10</addressOffset>
       </register>
       <register derivedFrom="PDMA_POINT0">
          <name>PDMA_POINT3</name>
          <displayName>PDMA_POINT3</displayName>
          <description>PDMA Channel x Internal Buffer Pointer Register</description>
          <alternateRegister>PDMA_POINT0</alternateRegister>
          <addressOffset>0x10</addressOffset>
       </register>
       <register derivedFrom="PDMA_POINT0">
          <name>PDMA_POINT4</name>
          <displayName>PDMA_POINT4</displayName>
          <description>PDMA Channel x Internal Buffer Pointer Register</description>
          <alternateRegister>PDMA_POINT0</alternateRegister>
          <addressOffset>0x10</addressOffset>
       </register>
       <register derivedFrom="PDMA_POINT0">
          <name>PDMA_POINT5</name>
          <displayName>PDMA_POINT5</displayName>
          <description>PDMA Channel x Internal Buffer Pointer Register</description>
          <alternateRegister>PDMA_POINT0</alternateRegister>
          <addressOffset>0x10</addressOffset>
       </register>
       <register derivedFrom="PDMA_POINT0">
          <name>PDMA_POINT6</name>
          <displayName>PDMA_POINT6</displayName>
          <description>PDMA Channel x Internal Buffer Pointer Register</description>
          <alternateRegister>PDMA_POINT0</alternateRegister>
          <addressOffset>0x10</addressOffset>
       </register>
       <register derivedFrom="PDMA_POINT0">
          <name>PDMA_POINT7</name>
          <displayName>PDMA_POINT7</displayName>
          <description>PDMA Channel x Internal Buffer Pointer Register</description>
          <alternateRegister>PDMA_POINT0</alternateRegister>
          <addressOffset>0x10</addressOffset>
       </register>
       <register derivedFrom="PDMA_POINT0">
          <name>PDMA_POINT8</name>
          <displayName>PDMA_POINT8</displayName>
          <description>PDMA Channel x Internal Buffer Pointer Register</description>
          <alternateRegister>PDMA_POINT0</alternateRegister>
          <addressOffset>0x10</addressOffset>
       </register>
       <register>
          <name>PDMA_CSAR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_CSAR0</displayName>
          <description>PDMA Channel x Current Source Address Register</description>
          <addressOffset>0x14</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_CSAR</name>
              <description>PDMA Current Source Address Register (Read Only)\nThis field indicates the source address where the PDMA transfer just occurred.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PDMA_CSAR0">
          <name>PDMA_CSAR1</name>
          <displayName>PDMA_CSAR1</displayName>
          <description>PDMA Channel x Current Source Address Register</description>
          <alternateRegister>PDMA_CSAR0</alternateRegister>
          <addressOffset>0x14</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSAR0">
          <name>PDMA_CSAR2</name>
          <displayName>PDMA_CSAR2</displayName>
          <description>PDMA Channel x Current Source Address Register</description>
          <alternateRegister>PDMA_CSAR0</alternateRegister>
          <addressOffset>0x14</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSAR0">
          <name>PDMA_CSAR3</name>
          <displayName>PDMA_CSAR3</displayName>
          <description>PDMA Channel x Current Source Address Register</description>
          <alternateRegister>PDMA_CSAR0</alternateRegister>
          <addressOffset>0x14</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSAR0">
          <name>PDMA_CSAR4</name>
          <displayName>PDMA_CSAR4</displayName>
          <description>PDMA Channel x Current Source Address Register</description>
          <alternateRegister>PDMA_CSAR0</alternateRegister>
          <addressOffset>0x14</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSAR0">
          <name>PDMA_CSAR5</name>
          <displayName>PDMA_CSAR5</displayName>
          <description>PDMA Channel x Current Source Address Register</description>
          <alternateRegister>PDMA_CSAR0</alternateRegister>
          <addressOffset>0x14</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSAR0">
          <name>PDMA_CSAR6</name>
          <displayName>PDMA_CSAR6</displayName>
          <description>PDMA Channel x Current Source Address Register</description>
          <alternateRegister>PDMA_CSAR0</alternateRegister>
          <addressOffset>0x14</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSAR0">
          <name>PDMA_CSAR7</name>
          <displayName>PDMA_CSAR7</displayName>
          <description>PDMA Channel x Current Source Address Register</description>
          <alternateRegister>PDMA_CSAR0</alternateRegister>
          <addressOffset>0x14</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSAR0">
          <name>PDMA_CSAR8</name>
          <displayName>PDMA_CSAR8</displayName>
          <description>PDMA Channel x Current Source Address Register</description>
          <alternateRegister>PDMA_CSAR0</alternateRegister>
          <addressOffset>0x14</addressOffset>
       </register>
       <register>
          <name>PDMA_CDAR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_CDAR0</displayName>
          <description>PDMA Channel x Current Destination Address Register</description>
          <addressOffset>0x18</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_CDAR</name>
              <description>PDMA Current Destination Address Register (Read Only)\nThis field indicates the destination address where the PDMA transfer just occurred.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PDMA_CDAR0">
          <name>PDMA_CDAR1</name>
          <displayName>PDMA_CDAR1</displayName>
          <description>PDMA Channel x Current Destination Address Register</description>
          <alternateRegister>PDMA_CDAR0</alternateRegister>
          <addressOffset>0x18</addressOffset>
       </register>
       <register derivedFrom="PDMA_CDAR0">
          <name>PDMA_CDAR2</name>
          <displayName>PDMA_CDAR2</displayName>
          <description>PDMA Channel x Current Destination Address Register</description>
          <alternateRegister>PDMA_CDAR0</alternateRegister>
          <addressOffset>0x18</addressOffset>
       </register>
       <register derivedFrom="PDMA_CDAR0">
          <name>PDMA_CDAR3</name>
          <displayName>PDMA_CDAR3</displayName>
          <description>PDMA Channel x Current Destination Address Register</description>
          <alternateRegister>PDMA_CDAR0</alternateRegister>
          <addressOffset>0x18</addressOffset>
       </register>
       <register derivedFrom="PDMA_CDAR0">
          <name>PDMA_CDAR4</name>
          <displayName>PDMA_CDAR4</displayName>
          <description>PDMA Channel x Current Destination Address Register</description>
          <alternateRegister>PDMA_CDAR0</alternateRegister>
          <addressOffset>0x18</addressOffset>
       </register>
       <register derivedFrom="PDMA_CDAR0">
          <name>PDMA_CDAR5</name>
          <displayName>PDMA_CDAR5</displayName>
          <description>PDMA Channel x Current Destination Address Register</description>
          <alternateRegister>PDMA_CDAR0</alternateRegister>
          <addressOffset>0x18</addressOffset>
       </register>
       <register derivedFrom="PDMA_CDAR0">
          <name>PDMA_CDAR6</name>
          <displayName>PDMA_CDAR6</displayName>
          <description>PDMA Channel x Current Destination Address Register</description>
          <alternateRegister>PDMA_CDAR0</alternateRegister>
          <addressOffset>0x18</addressOffset>
       </register>
       <register derivedFrom="PDMA_CDAR0">
          <name>PDMA_CDAR7</name>
          <displayName>PDMA_CDAR7</displayName>
          <description>PDMA Channel x Current Destination Address Register</description>
          <alternateRegister>PDMA_CDAR0</alternateRegister>
          <addressOffset>0x18</addressOffset>
       </register>
       <register derivedFrom="PDMA_CDAR0">
          <name>PDMA_CDAR8</name>
          <displayName>PDMA_CDAR8</displayName>
          <description>PDMA Channel x Current Destination Address Register</description>
          <alternateRegister>PDMA_CDAR0</alternateRegister>
          <addressOffset>0x18</addressOffset>
       </register>
       <register>
          <name>PDMA_CBCR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_CBCR0</displayName>
          <description>PDMA Channel x Current Transfer Byte Count Register</description>
          <addressOffset>0x1C</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_CBCR</name>
              <description>PDMA Current Byte Count Register (Read Only)\nThis field indicates the current remained byte count of PDMA.\nNote: This field value will be cleared to 0, when software set SW_RST (PDMA_CSRx[1]) to "1".</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PDMA_CBCR0">
          <name>PDMA_CBCR1</name>
          <displayName>PDMA_CBCR1</displayName>
          <description>PDMA Channel x Current Transfer Byte Count Register</description>
          <alternateRegister>PDMA_CBCR0</alternateRegister>
          <addressOffset>0x1C</addressOffset>
       </register>
       <register derivedFrom="PDMA_CBCR0">
          <name>PDMA_CBCR2</name>
          <displayName>PDMA_CBCR2</displayName>
          <description>PDMA Channel x Current Transfer Byte Count Register</description>
          <alternateRegister>PDMA_CBCR0</alternateRegister>
          <addressOffset>0x1C</addressOffset>
       </register>
       <register derivedFrom="PDMA_CBCR0">
          <name>PDMA_CBCR3</name>
          <displayName>PDMA_CBCR3</displayName>
          <description>PDMA Channel x Current Transfer Byte Count Register</description>
          <alternateRegister>PDMA_CBCR0</alternateRegister>
          <addressOffset>0x1C</addressOffset>
       </register>
       <register derivedFrom="PDMA_CBCR0">
          <name>PDMA_CBCR4</name>
          <displayName>PDMA_CBCR4</displayName>
          <description>PDMA Channel x Current Transfer Byte Count Register</description>
          <alternateRegister>PDMA_CBCR0</alternateRegister>
          <addressOffset>0x1C</addressOffset>
       </register>
       <register derivedFrom="PDMA_CBCR0">
          <name>PDMA_CBCR5</name>
          <displayName>PDMA_CBCR5</displayName>
          <description>PDMA Channel x Current Transfer Byte Count Register</description>
          <alternateRegister>PDMA_CBCR0</alternateRegister>
          <addressOffset>0x1C</addressOffset>
       </register>
       <register derivedFrom="PDMA_CBCR0">
          <name>PDMA_CBCR6</name>
          <displayName>PDMA_CBCR6</displayName>
          <description>PDMA Channel x Current Transfer Byte Count Register</description>
          <alternateRegister>PDMA_CBCR0</alternateRegister>
          <addressOffset>0x1C</addressOffset>
       </register>
       <register derivedFrom="PDMA_CBCR0">
          <name>PDMA_CBCR7</name>
          <displayName>PDMA_CBCR7</displayName>
          <description>PDMA Channel x Current Transfer Byte Count Register</description>
          <alternateRegister>PDMA_CBCR0</alternateRegister>
          <addressOffset>0x1C</addressOffset>
       </register>
       <register derivedFrom="PDMA_CBCR0">
          <name>PDMA_CBCR8</name>
          <displayName>PDMA_CBCR8</displayName>
          <description>PDMA Channel x Current Transfer Byte Count Register</description>
          <alternateRegister>PDMA_CBCR0</alternateRegister>
          <addressOffset>0x1C</addressOffset>
       </register>
       <register>
          <name>PDMA_IER0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_IER0</displayName>
          <description>PDMA Channel x Interrupt Enable Register</description>
          <addressOffset>0x20</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000001</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TABORT_IE</name>
              <description>PDMA Read/Write Target Abort Interrupt Enable Bit\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Target abort interrupt generation Disabled during PDMA transfer</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Target abort interrupt generation Enabled during PDMA transfer</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BLKD_IE</name>
              <description>PDMA Block Transfer Done Interrupt Enable Bit\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Interrupt generator Disabled when PDMA transfer is done</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Interrupt generator Enabled when PDMA transfer is done</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PDMA_IER0">
          <name>PDMA_IER1</name>
          <displayName>PDMA_IER1</displayName>
          <description>PDMA Channel x Interrupt Enable Register</description>
          <alternateRegister>PDMA_IER0</alternateRegister>
          <addressOffset>0x20</addressOffset>
       </register>
       <register derivedFrom="PDMA_IER0">
          <name>PDMA_IER2</name>
          <displayName>PDMA_IER2</displayName>
          <description>PDMA Channel x Interrupt Enable Register</description>
          <alternateRegister>PDMA_IER0</alternateRegister>
          <addressOffset>0x20</addressOffset>
       </register>
       <register derivedFrom="PDMA_IER0">
          <name>PDMA_IER3</name>
          <displayName>PDMA_IER3</displayName>
          <description>PDMA Channel x Interrupt Enable Register</description>
          <alternateRegister>PDMA_IER0</alternateRegister>
          <addressOffset>0x20</addressOffset>
       </register>
       <register derivedFrom="PDMA_IER0">
          <name>PDMA_IER4</name>
          <displayName>PDMA_IER4</displayName>
          <description>PDMA Channel x Interrupt Enable Register</description>
          <alternateRegister>PDMA_IER0</alternateRegister>
          <addressOffset>0x20</addressOffset>
       </register>
       <register derivedFrom="PDMA_IER0">
          <name>PDMA_IER5</name>
          <displayName>PDMA_IER5</displayName>
          <description>PDMA Channel x Interrupt Enable Register</description>
          <alternateRegister>PDMA_IER0</alternateRegister>
          <addressOffset>0x20</addressOffset>
       </register>
       <register derivedFrom="PDMA_IER0">
          <name>PDMA_IER6</name>
          <displayName>PDMA_IER6</displayName>
          <description>PDMA Channel x Interrupt Enable Register</description>
          <alternateRegister>PDMA_IER0</alternateRegister>
          <addressOffset>0x20</addressOffset>
       </register>
       <register derivedFrom="PDMA_IER0">
          <name>PDMA_IER7</name>
          <displayName>PDMA_IER7</displayName>
          <description>PDMA Channel x Interrupt Enable Register</description>
          <alternateRegister>PDMA_IER0</alternateRegister>
          <addressOffset>0x20</addressOffset>
       </register>
       <register derivedFrom="PDMA_IER0">
          <name>PDMA_IER8</name>
          <displayName>PDMA_IER8</displayName>
          <description>PDMA Channel x Interrupt Enable Register</description>
          <alternateRegister>PDMA_IER0</alternateRegister>
          <addressOffset>0x20</addressOffset>
       </register>
       <register>
          <name>PDMA_ISR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_ISR0</displayName>
          <description>PDMA Channel x Interrupt Status Register</description>
          <addressOffset>0x24</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TABORT_IF</name>
              <description>PDMA Read/Write Target Abort Interrupt Flag\nWrite 1 to clear this bit to 0.\nNote: This bit filed indicates bus master received ERROR response or not. If bus master received ERROR response, it means that target abort is happened. PDMA controller will stop transfer and respond this event to software then goes to IDLE state. When target abort occurred, software must reset PDMA, and then transfer those data again.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No bus ERROR response received</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Bus ERROR response received</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BLKD_IF</name>
              <description>PDMA Block Transfer Done Interrupt Flag\nThis bit indicates that PDMA has finished all transfers.\nWrite 1 to clear this bit to 0.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Not finished</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Done</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PDMA_ISR0">
          <name>PDMA_ISR1</name>
          <displayName>PDMA_ISR1</displayName>
          <description>PDMA Channel x Interrupt Status Register</description>
          <alternateRegister>PDMA_ISR0</alternateRegister>
          <addressOffset>0x24</addressOffset>
       </register>
       <register derivedFrom="PDMA_ISR0">
          <name>PDMA_ISR2</name>
          <displayName>PDMA_ISR2</displayName>
          <description>PDMA Channel x Interrupt Status Register</description>
          <alternateRegister>PDMA_ISR0</alternateRegister>
          <addressOffset>0x24</addressOffset>
       </register>
       <register derivedFrom="PDMA_ISR0">
          <name>PDMA_ISR3</name>
          <displayName>PDMA_ISR3</displayName>
          <description>PDMA Channel x Interrupt Status Register</description>
          <alternateRegister>PDMA_ISR0</alternateRegister>
          <addressOffset>0x24</addressOffset>
       </register>
       <register derivedFrom="PDMA_ISR0">
          <name>PDMA_ISR4</name>
          <displayName>PDMA_ISR4</displayName>
          <description>PDMA Channel x Interrupt Status Register</description>
          <alternateRegister>PDMA_ISR0</alternateRegister>
          <addressOffset>0x24</addressOffset>
       </register>
       <register derivedFrom="PDMA_ISR0">
          <name>PDMA_ISR5</name>
          <displayName>PDMA_ISR5</displayName>
          <description>PDMA Channel x Interrupt Status Register</description>
          <alternateRegister>PDMA_ISR0</alternateRegister>
          <addressOffset>0x24</addressOffset>
       </register>
       <register derivedFrom="PDMA_ISR0">
          <name>PDMA_ISR6</name>
          <displayName>PDMA_ISR6</displayName>
          <description>PDMA Channel x Interrupt Status Register</description>
          <alternateRegister>PDMA_ISR0</alternateRegister>
          <addressOffset>0x24</addressOffset>
       </register>
       <register derivedFrom="PDMA_ISR0">
          <name>PDMA_ISR7</name>
          <displayName>PDMA_ISR7</displayName>
          <description>PDMA Channel x Interrupt Status Register</description>
          <alternateRegister>PDMA_ISR0</alternateRegister>
          <addressOffset>0x24</addressOffset>
       </register>
       <register derivedFrom="PDMA_ISR0">
          <name>PDMA_ISR8</name>
          <displayName>PDMA_ISR8</displayName>
          <description>PDMA Channel x Interrupt Status Register</description>
          <alternateRegister>PDMA_ISR0</alternateRegister>
          <addressOffset>0x24</addressOffset>
       </register>
       <register>
          <name>PDMA_SBUF0_C0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_SBUF0_C0</displayName>
          <description>PDMA Channel x Shared Buffer FIFO 0 Register</description>
          <addressOffset>0x80</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_SBUF0</name>
              <description>PDMA Shared Buffer FIFO 0 (Read Only)\nEach channel has its own 1 word internal buffer.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PDMA_SBUF0_C0">
          <name>PDMA_SBUF0_C1</name>
          <displayName>PDMA_SBUF0_C1</displayName>
          <description>PDMA Channel x Shared Buffer FIFO 0 Register</description>
          <alternateRegister>PDMA_SBUF0_C0</alternateRegister>
          <addressOffset>0x80</addressOffset>
       </register>
       <register derivedFrom="PDMA_SBUF0_C0">
          <name>PDMA_SBUF0_C2</name>
          <displayName>PDMA_SBUF0_C2</displayName>
          <description>PDMA Channel x Shared Buffer FIFO 0 Register</description>
          <alternateRegister>PDMA_SBUF0_C0</alternateRegister>
          <addressOffset>0x80</addressOffset>
       </register>
       <register derivedFrom="PDMA_SBUF0_C0">
          <name>PDMA_SBUF0_C3</name>
          <displayName>PDMA_SBUF0_C3</displayName>
          <description>PDMA Channel x Shared Buffer FIFO 0 Register</description>
          <alternateRegister>PDMA_SBUF0_C0</alternateRegister>
          <addressOffset>0x80</addressOffset>
       </register>
       <register derivedFrom="PDMA_SBUF0_C0">
          <name>PDMA_SBUF0_C4</name>
          <displayName>PDMA_SBUF0_C4</displayName>
          <description>PDMA Channel x Shared Buffer FIFO 0 Register</description>
          <alternateRegister>PDMA_SBUF0_C0</alternateRegister>
          <addressOffset>0x80</addressOffset>
       </register>
       <register derivedFrom="PDMA_SBUF0_C0">
          <name>PDMA_SBUF0_C5</name>
          <displayName>PDMA_SBUF0_C5</displayName>
          <description>PDMA Channel x Shared Buffer FIFO 0 Register</description>
          <alternateRegister>PDMA_SBUF0_C0</alternateRegister>
          <addressOffset>0x80</addressOffset>
       </register>
       <register derivedFrom="PDMA_SBUF0_C0">
          <name>PDMA_SBUF0_C6</name>
          <displayName>PDMA_SBUF0_C6</displayName>
          <description>PDMA Channel x Shared Buffer FIFO 0 Register</description>
          <alternateRegister>PDMA_SBUF0_C0</alternateRegister>
          <addressOffset>0x80</addressOffset>
       </register>
       <register derivedFrom="PDMA_SBUF0_C0">
          <name>PDMA_SBUF0_C7</name>
          <displayName>PDMA_SBUF0_C7</displayName>
          <description>PDMA Channel x Shared Buffer FIFO 0 Register</description>
          <alternateRegister>PDMA_SBUF0_C0</alternateRegister>
          <addressOffset>0x80</addressOffset>
       </register>
       <register derivedFrom="PDMA_SBUF0_C0">
          <name>PDMA_SBUF0_C8</name>
          <displayName>PDMA_SBUF0_C8</displayName>
          <description>PDMA Channel x Shared Buffer FIFO 0 Register</description>
          <alternateRegister>PDMA_SBUF0_C0</alternateRegister>
          <addressOffset>0x80</addressOffset>
       </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>PDMA_GCR</name>
      <description>PDMA Register Map</description>
      <groupName>PDMA</groupName>
      <baseAddress>0x50008F00</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x0</offset>
        <size>0x14</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>PDMA_GCRCSR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_GCRCSR</displayName>
          <description>PDMA Global Control Register</description>
          <addressOffset>0x0</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CLK0_EN</name>
              <description>PDMA Controller Channel 0 Clock Enable Bit\n</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK1_EN</name>
              <description>PDMA Controller Channel 1 Clock Enable Bit\n</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK2_EN</name>
              <description>PDMA Controller Channel 2 Clock Enable Bit \n</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK3_EN</name>
              <description>PDMA Controller Channel 3 Clock Enable Bit\n</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK4_EN</name>
              <description>PDMA Controller Channel 4 Clock Enable Bit\n</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK5_EN</name>
              <description>PDMA Controller Channel 5 Clock Enable Bit\n</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK6_EN</name>
              <description>PDMA Controller Channel 6 Clock Enable Bit\n</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK7_EN</name>
              <description>PDMA Controller Channel 7 Clock Enable Bit\n</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK8_EN</name>
              <description>PDMA Controller Channel 8 Clock Enable Bit \n</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CRC_CLK_EN</name>
              <description>CRC Controller Clock Enable Bit\n</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PDMA_PDSSR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_PDSSR0</displayName>
          <description>PDMA Service Selection Control Register 0</description>
          <addressOffset>0x4</addressOffset>
          <access>read-write</access>
          <resetValue>0xFFFFFFFF</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SPI0_RXSEL</name>
              <description>PDMA SPI0 RX Selection\n0000: CH0\n0001: CH1\n0010: CH2\n0011: CH3 \n0100: CH4 \n0101: CH5\n0110: CH6\n0111: CH7\n1000: CH8\nOthers : Reserved</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SPI0_TXSEL</name>
              <description>PDMA SPI0 TX Selection\nThis field defines which PDMA channel is connected to the on-chip peripheral SPI0 TX. Software can configure the TX channel setting by this field. The channel configuration is the same as SPI0_RXSEL (PDMA_PDSSR0[3:0]) field. Please refer to the explanation of SPI0_RXSEL (PDMA_PDSSR0[3:0]).</description>
              <bitOffset>4</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SPI1_RXSEL</name>
              <description>PDMA SPI1 RX Selection\nThis field defines which PDMA channel is connected to the on-chip peripheral SPI1 RX. Software can configure the RX channel setting by this field. The channel configuration is the same as SPI0_RXSEL (PDMA_PDSSR0[3:0]) field. Please refer to the explanation of SPI0_RXSEL (PDMA_PDSSR0[3:0]).</description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SPI1_TXSEL</name>
              <description>PDMA SPI1 TX Selection\nThis field defines which PDMA channel is connected to the on-chip peripheral SPI1 TX. Software can configure the TX channel setting by this field. The channel configuration is the same as SPI0_RXSEL (PDMA_PDSSR0[3:0]) field. Please refer to the explanation of SPI0_RXSEL (PDMA_PDSSR0[3:0]).</description>
              <bitOffset>12</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SPI2_RXSEL</name>
              <description>PDMA SPI2 RX Selection\nThis field defines which PDMA channel is connected to the on-chip peripheral SPI2 RX. Software can configure the RX channel setting by this field. The channel configuration is the same as SPI0_RXSEL (PDMA_PDSSR0[3:0]) field. Please refer to the explanation of SPI0_RXSEL (PDMA_PDSSR0[3:0]).</description>
              <bitOffset>16</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SPI2_TXSEL</name>
              <description>PDMA SPI2 TX Selection\nThis field defines which PDMA channel is connected to the on-chip peripheral SPI2 TX. Software can configure the TX channel setting by this field. The channel configuration is the same as SPI0_RXSEL (PDMA_PDSSR0[3:0]) field. Please refer to the explanation of SPI0_RXSEL (PDMA_PDSSR0[3:0]).</description>
              <bitOffset>20</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SPI3_RXSEL</name>
              <description>PDMA SPI3 RX Selection \nThis field defines which PDMA channel is connected to the on-chip peripheral SPI3 RX. Software can configure the RX channel setting by this field. The channel configuration is the same as SPI0_RXSEL (PDMA_PDSSR0[3:0]) field. Please refer to the explanation of SPI0_RXSEL (PDMA_PDSSR0[3:0]).</description>
              <bitOffset>24</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SPI3_TXSEL</name>
              <description>PDMA SPI3 TX Selection\nThis field defines which PDMA channel is connected to the on-chip peripheral SPI3 TX. Software can configure the TX channel setting by this field. The channel configuration is the same as SPI0_RXSEL (PDMA_PDSSR0[3:0]) field. Please refer to the explanation of SPI0_RXSEL (PDMA_PDSSR0[3:0]).</description>
              <bitOffset>28</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PDMA_PDSSR1</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_PDSSR1</displayName>
          <description>PDMA Service Selection Control Register 1</description>
          <addressOffset>0x8</addressOffset>
          <access>read-write</access>
          <resetValue>0xFFFFFFFF</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>UART0_RXSEL</name>
              <description>PDMA UART0 RX Selection\n0000: CH0\n0001: CH1\n0010: CH2\n0011: CH3 \n0100: CH4 \n0101: CH5\n0110: CH6\n0111: CH7\n1000: CH8\nOthers : Reserved</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>UART0_TXSEL</name>
              <description>PDMA UART0 TX Selection\nThis field defines which PDMA channel is connected to the on-chip peripheral UART0 TX. Software can configure the TX channel setting by this field. The channel configuration is the same as UART0_RXSEL (PDMA_PDSSR1[3:0]) field. Please refer to the explanation of UART0_RXSEL (PDMA_PDSSR1[3:0]).</description>
              <bitOffset>4</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>UART1_RXSEL</name>
              <description>PDMA UART1 RX Selection\nThis field defines which PDMA channel is connected to the on-chip peripheral UART1 RX. Software can configure the RX channel setting by this field. The channel configuration is the same as UART0_RXSEL (PDMA_PDSSR1[3:0]) field. Please refer to the explanation of UART0_RXSEL (PDMA_PDSSR1[3:0]).</description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>UART1_TXSEL</name>
              <description>PDMA UART1 TX Selection\nThis field defines which PDMA channel is connected to the on-chip peripheral UART1 TX. Software can configure the TX channel setting by this field. The channel configuration is the same as UART0_RXSEL (PDMA_PDSSR1[3:0]) field. Please refer to the explanation of UART0_RXSEL (PDMA_PDSSR1[3:0]).</description>
              <bitOffset>12</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ADC_RXSEL</name>
              <description>PDMA ADC RX Selection\nThis field defines which PDMA channel is connected to the on-chip peripheral ADC RX. Software can configure the RX channel setting by this field. The channel configuration is the same as UART0_RXSEL (PDMA_PDSSR1[3:0]) field. Please refer to the explanation of UART0_RXSEL (PDMA_PDSSR1[3:0]).</description>
              <bitOffset>24</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PDMA_GCRISR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_GCRISR</displayName>
          <description>PDMA Global Interrupt Status Register</description>
          <addressOffset>0xC</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>INTR0</name>
              <description>Interrupt Status Of Channel 0\nThis bit is the interrupt status of PDMA channel0.\nNote: This bit is read only.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>INTR1</name>
              <description>Interrupt Status Of Channel 1\nThis bit is the interrupt status of PDMA channel1.\nNote: This bit is read only.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>INTR2</name>
              <description>Interrupt Status Of Channel 2\nThis bit is the interrupt status of PDMA channel2.\nNote: This bit is read only.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>INTR3</name>
              <description>Interrupt Status Of Channel 3\nThis bit is the interrupt status of PDMA channel3.\nNote: This bit is read only.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>INTR4</name>
              <description>Interrupt Status Of Channel 4\nThis bit is the interrupt status of PDMA channel4.\nNote: This bit is read only.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>INTR5</name>
              <description>Interrupt Status Of Channel 5 \nThis bit is the interrupt status of PDMA channel5.\nNote: This bit is read only.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>INTR6</name>
              <description>Interrupt Status Of Channel 6 \nThis bit is the interrupt status of PDMA channel6.\nNote: This bit is read only.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>INTR7</name>
              <description>Interrupt Status Of Channel 7 \nThis bit is the interrupt status of PDMA channel7.\nNote: This bit is read only.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>INTR8</name>
              <description>Interrupt Status Of Channel 8 \nThis bit is the interrupt status of PDMA channel8.\nNote: This bit is read only.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>INTRCRC</name>
              <description>Interrupt Status Of CRC Controller\nThis bit is the interrupt status of CRC controller\nNote: This bit is read only</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>INTR</name>
              <description>Interrupt Status\nThis bit is the interrupt status of PDMA controller.\nNote: This bit is read only.</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PDMA_PDSSR2</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_PDSSR2</displayName>
          <description>PDMA Service Selection Control Register 2</description>
          <addressOffset>0x10</addressOffset>
          <access>read-write</access>
          <resetValue>0x000000FF</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>I2S_RXSEL</name>
              <description>PDMA I2S RX Selection\n0000: CH0\n0001: CH1\n0010: CH2\n0011: CH3\n0100: CH4\n0101: CH5\n0110: CH6\n0111: CH7\n1000: CH8\nOthers : Reserved</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>I2S_TXSEL</name>
              <description>PDMA I2S TX Selection\nThis field defines which PDMA channel is connected to the on-chip peripheral I2S TX. Software can configure the TX channel setting by this field. The channel configuration is the same as I2S_RXSEL (PDMA_PDSSR2[3:0]) field. Please refer to the explanation of I2S_RXSEL (PDMA_PDSSR2[3:0]).</description>
              <bitOffset>4</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>TMR01</name>
      <description>TIMER Register Map</description>
      <groupName>TIMER</groupName>
      <baseAddress>0x40010000</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x0</offset>
        <size>0x1C</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x20</offset>
        <size>0x1C</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>TCSR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>TCSR0</displayName>
          <description>Timer0 Control and Status Register</description>
          <addressOffset>0x0</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000005</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PRESCALE</name>
              <description>Prescale Counter\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TDR_EN</name>
              <description>Data Load Enable Bit\nWhen TDR_EN is set, TDR (Timer Data Register) will be updated continuously with the 24-bit up-timer value as the timer is counting.\n</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Timer Data Register update Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Timer Data Register update Enabled while Timer counter is active</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>WAKE_EN</name>
              <description>Wake Up Function Enable Bit\n</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Wake-up trigger event Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Wake-up trigger event Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CTB</name>
              <description>Counter Mode Enable Bit \nThis bit is for external counting pin function enabled. When timer is used as an event counter, this bit should be set to 1 and select HCLK as timer clock source. Please refer to 6.8.5.6 for detail description.\n</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>External counter mode Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>External counter mode Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CACT</name>
              <description>Timer Active Status (Read Only)\nThis bit indicates the 24-bit up counter status.\n</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>24-bit up counter is not active</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>24-bit up counter is active</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>CRST</name>
              <description>Timer Reset\n</description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reset 8-bit prescale counter, 24-bit up counter value and CEN bit if CACT is 1</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>MODE</name>
              <description>Timer Operating Mode\n</description>
              <bitOffset>27</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The Timer controller is operated in One-shot mode</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The Timer controller is operated in Periodic mode</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>The Timer controller is operated in Toggle-output mode</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>The Timer controller is operated in Continuous Counting mode</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IE</name>
              <description>Interrupt Enable Bit\nIf this bit is enabled, when the timer interrupt flag TIF (TISR[0]) is set to 1, the timer interrupt signal is generated and inform to CPU.</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Timer Interrupt function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Timer Interrupt function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CEN</name>
              <description>Timer Enable Bit\n</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Stops/Suspends counting</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Starts counting</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DBGACK_TMR</name>
              <description>ICE Debug Mode Acknowledge Disable Bit (Write Protect)\nTIMER counter will keep going no matter CPU is held by ICE or not.</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>ICE debug mode acknowledgement effects TIMER counting</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>ICE debug mode acknowledgement Disabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>TCMPR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>TCMPR0</displayName>
          <description>Timer0 Compare Register</description>
          <addressOffset>0x4</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TCMP</name>
              <description>Timer Compared Value\nTCMP is a 24-bit compared value register. When the internal 24-bit up counter value is equal to TCMP value, the TIF flag will set to 1.\nNote1: Never write 0x0 or 0x1 in TCMP field, or the core will run into unknown state.\nNote2: When timer is operating at continuous counting mode, the 24-bit up counter will keep counting continuously even if user writes a new value into TCMP field. But if timer is operating at other modes, the 24-bit up counter will restart counting and using newest TCMP value to be the timer compared value if user writes a new value into TCMP field.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>TISR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>TISR0</displayName>
          <description>Timer0 Interrupt Status Register</description>
          <addressOffset>0x8</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TIF</name>
              <description>Timer Interrupt Flag\nThis bit indicates the interrupt flag status of Timer while TDR value reaches to TCMP value.\nNote: This bit is cleared by writing 1 to it.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>TDR value matches the TCMP value</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TWF</name>
              <description>Timer Wake-Up Flag\nThis bit indicates the interrupt wake-up flag status of Timer.\nNote: This bit is cleared by writing 1 to it.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Timer does not cause CPU wake-up</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>CPU wake-up from Idle or Power-down mode if Timer time-out interrupt signal generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>TDR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>TDR0</displayName>
          <description>Timer0 Data Register</description>
          <addressOffset>0xC</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TDR</name>
              <description>Timer Data Register\nIf TDR_EN (TCSR[16]) is set to 1, TDR register will be updated continuously to monitor 24-bit up counter value.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>TCAP0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>TCAP0</displayName>
          <description>Timer0 Capture Data Register</description>
          <addressOffset>0x10</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TCAP</name>
              <description>Timer Capture Data Register\nWhen TEXIF (TEXISR[0]) flag and RSTCAPSEL (TEXCON[4]) is set to 1, the current TDR value will be auto-loaded into this TCAP filed immediately.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>TEXCON0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>TEXCON0</displayName>
          <description>Timer0 External Control Register</description>
          <addressOffset>0x14</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TX_PHASE</name>
              <description>Timer External Count Pin Phase Detect Selection\nThis bit indicates the detection phase of TMx_EXT pin.\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>A falling edge of TMx_EXT pin will be counted</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>A rising edge of TMx_EXT pin will be counted</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TEX_EDGE</name>
              <description>Timer External Capture Pin Edge Detect Selection\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>A 1 to 0 transition on TMx_EXT pin will be detected</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>A 0 to 1 transition on TMx_EXT pin will be detected</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Either 1 to 0 or 0 to 1 transition on TMx_EXT pin will be detected</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Reserved</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TEXEN</name>
              <description>Timer External Pin Function Enable Bit\nThis bit enables the RSTCAPSEL function on the TMx_EXT pin.\n</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RSTCAPSEL function of TMx_EXT pin will be ignored</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RSTCAPSEL function of TMx_EXT pin is active</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RSTCAPSEL</name>
              <description>Timer External Reset Counter / Timer External Capture Mode Selection\n</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Transition on TMx_EXT pin is using to save the TDR value into TCAP.(event capture function)</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Transition on TMx_EXT pin is using to reset the 24-bit up counter.(event reset counter function)</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TEXIEN</name>
              <description>Timer External Capture Interrupt Enable Bit\nIf TEXIEN enabled, Timer will raise an external capture interrupt signal and inform to CPU while TEXIF flag is set to 1.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>TMx_EXT pin detection Interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>TMx_EXT pin detection Interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TEXDB</name>
              <description>Timer External Capture Input Pin De-Bounce Enable Bit\nIf this bit is enabled, the edge detection of TMx_EXT pin is detected with de-bounce circuit.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>TMx_EXT pin de-bounce Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>TMx_EXT pin de-bounce Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TCDB</name>
              <description>Timer External Counter Input Pin De-Bounce Enable Bit\nIf this bit is enabled, the edge detection of TMx pin is detected with de-bounce circuit.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>TMx pin de-bounce Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>TMx pin de-bounce Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>TEXISR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>TEXISR0</displayName>
          <description>Timer0 External Interrupt Status Register</description>
          <addressOffset>0x18</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TEXIF</name>
              <description>Timer External Capture Interrupt Flag\nThis bit indicates the external capture interrupt flag status.\nWhen TEXEN (TEXCON[3]) enabled, TMx_EXT pin selected as external capture function, and a transition on TMx_EXT pin matched the TEX_EDGE (TEXCON[2:1]) setting, this flag will set to 1 by hardware.\nNote: This bit is cleared by writing 1 to it.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>TMx_EXT pin interrupt did not occur</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>TMx_EXT pin interrupt occurred</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="TCSR0">
          <name>TCSR1</name>
          <displayName>TCSR1</displayName>
          <description>Timer1 Control and Status Register</description>
          <addressOffset>0x20</addressOffset>
       </register>
       <register derivedFrom="TCMPR0">
          <name>TCMPR1</name>
          <displayName>TCMPR1</displayName>
          <description>Timer1 Compare Register</description>
          <addressOffset>0x24</addressOffset>
       </register>
       <register derivedFrom="TISR0">
          <name>TISR1</name>
          <displayName>TISR1</displayName>
          <description>Timer1 Interrupt Status Register</description>
          <addressOffset>0x28</addressOffset>
       </register>
       <register derivedFrom="TDR0">
          <name>TDR1</name>
          <displayName>TDR1</displayName>
          <description>Timer1 Data Register</description>
          <addressOffset>0x2C</addressOffset>
       </register>
       <register derivedFrom="TCAP0">
          <name>TCAP1</name>
          <displayName>TCAP1</displayName>
          <description>Timer1 Capture Data Register</description>
          <addressOffset>0x30</addressOffset>
       </register>
       <register derivedFrom="TEXCON0">
          <name>TEXCON1</name>
          <displayName>TEXCON1</displayName>
          <description>Timer1 External Control Register</description>
          <addressOffset>0x34</addressOffset>
       </register>
       <register derivedFrom="TEXISR0">
          <name>TEXISR1</name>
          <displayName>TEXISR1</displayName>
          <description>Timer1 External Interrupt Status Register</description>
          <addressOffset>0x38</addressOffset>
       </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>TMR23</name>
      <description>TIMER Register Map</description>
      <groupName>TIMER</groupName>
      <baseAddress>0x40110000</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x0</offset>
        <size>0x1C</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x20</offset>
        <size>0x1C</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>TCSR2</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>TCSR2</displayName>
          <description>Timer2 Control and Status Register</description>
          <addressOffset>0x0</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000005</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PRESCALE</name>
              <description>Prescale Counter\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TDR_EN</name>
              <description>Data Load Enable Bit\nWhen TDR_EN is set, TDR (Timer Data Register) will be updated continuously with the 24-bit up-timer value as the timer is counting.\n</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Timer Data Register update Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Timer Data Register update Enabled while Timer counter is active</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>WAKE_EN</name>
              <description>Wake Up Function Enable Bit\n</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Wake-up trigger event Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Wake-up trigger event Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CTB</name>
              <description>Counter Mode Enable Bit \nThis bit is for external counting pin function enabled. When timer is used as an event counter, this bit should be set to 1 and select HCLK as timer clock source. Please refer to 6.8.5.6 for detail description.\n</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>External counter mode Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>External counter mode Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CACT</name>
              <description>Timer Active Status (Read Only)\nThis bit indicates the 24-bit up counter status.\n</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>24-bit up counter is not active</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>24-bit up counter is active</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>CRST</name>
              <description>Timer Reset\n</description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reset 8-bit prescale counter, 24-bit up counter value and CEN bit if CACT is 1</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>MODE</name>
              <description>Timer Operating Mode\n</description>
              <bitOffset>27</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The Timer controller is operated in One-shot mode</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The Timer controller is operated in Periodic mode</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>The Timer controller is operated in Toggle-output mode</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>The Timer controller is operated in Continuous Counting mode</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IE</name>
              <description>Interrupt Enable Bit\nIf this bit is enabled, when the timer interrupt flag TIF (TISR[0]) is set to 1, the timer interrupt signal is generated and inform to CPU.</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Timer Interrupt function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Timer Interrupt function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CEN</name>
              <description>Timer Enable Bit\n</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Stops/Suspends counting</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Starts counting</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DBGACK_TMR</name>
              <description>ICE Debug Mode Acknowledge Disable Bit (Write Protect)\nTIMER counter will keep going no matter CPU is held by ICE or not.</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>ICE debug mode acknowledgement effects TIMER counting</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>ICE debug mode acknowledgement Disabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>TCMPR2</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>TCMPR2</displayName>
          <description>Timer2 Compare Register</description>
          <addressOffset>0x4</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TCMP</name>
              <description>Timer Compared Value\nTCMP is a 24-bit compared value register. When the internal 24-bit up counter value is equal to TCMP value, the TIF flag will set to 1.\nNote1: Never write 0x0 or 0x1 in TCMP field, or the core will run into unknown state.\nNote2: When timer is operating at continuous counting mode, the 24-bit up counter will keep counting continuously even if user writes a new value into TCMP field. But if timer is operating at other modes, the 24-bit up counter will restart counting and using newest TCMP value to be the timer compared value if user writes a new value into TCMP field.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>TISR2</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>TISR2</displayName>
          <description>Timer2 Interrupt Status Register</description>
          <addressOffset>0x8</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TIF</name>
              <description>Timer Interrupt Flag\nThis bit indicates the interrupt flag status of Timer while TDR value reaches to TCMP value.\nNote: This bit is cleared by writing 1 to it.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>TDR value matches the TCMP value</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TWF</name>
              <description>Timer Wake-Up Flag\nThis bit indicates the interrupt wake-up flag status of Timer.\nNote: This bit is cleared by writing 1 to it.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Timer does not cause CPU wake-up</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>CPU wake-up from Idle or Power-down mode if Timer time-out interrupt signal generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>TDR2</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>TDR2</displayName>
          <description>Timer2 Data Register</description>
          <addressOffset>0xC</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TDR</name>
              <description>Timer Data Register\nIf TDR_EN (TCSR[16]) is set to 1, TDR register will be updated continuously to monitor 24-bit up counter value.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>TCAP2</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>TCAP2</displayName>
          <description>Timer2 Capture Data Register</description>
          <addressOffset>0x10</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TCAP</name>
              <description>Timer Capture Data Register\nWhen TEXIF (TEXISR[0]) flag and RSTCAPSEL (TEXCON[4]) is set to 1, the current TDR value will be auto-loaded into this TCAP filed immediately.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>TEXCON2</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>TEXCON2</displayName>
          <description>Timer2 External Control Register</description>
          <addressOffset>0x14</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TX_PHASE</name>
              <description>Timer External Count Pin Phase Detect Selection\nThis bit indicates the detection phase of TMx_EXT pin.\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>A falling edge of TMx_EXT pin will be counted</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>A rising edge of TMx_EXT pin will be counted</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TEX_EDGE</name>
              <description>Timer External Capture Pin Edge Detect Selection\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>A 1 to 0 transition on TMx_EXT pin will be detected</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>A 0 to 1 transition on TMx_EXT pin will be detected</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Either 1 to 0 or 0 to 1 transition on TMx_EXT pin will be detected</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Reserved</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TEXEN</name>
              <description>Timer External Pin Function Enable Bit\nThis bit enables the RSTCAPSEL function on the TMx_EXT pin.\n</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RSTCAPSEL function of TMx_EXT pin will be ignored</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RSTCAPSEL function of TMx_EXT pin is active</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RSTCAPSEL</name>
              <description>Timer External Reset Counter / Timer External Capture Mode Selection\n</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Transition on TMx_EXT pin is using to save the TDR value into TCAP.(event capture function)</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Transition on TMx_EXT pin is using to reset the 24-bit up counter.(event reset counter function)</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TEXIEN</name>
              <description>Timer External Capture Interrupt Enable Bit\nIf TEXIEN enabled, Timer will raise an external capture interrupt signal and inform to CPU while TEXIF flag is set to 1.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>TMx_EXT pin detection Interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>TMx_EXT pin detection Interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TEXDB</name>
              <description>Timer External Capture Input Pin De-Bounce Enable Bit\nIf this bit is enabled, the edge detection of TMx_EXT pin is detected with de-bounce circuit.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>TMx_EXT pin de-bounce Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>TMx_EXT pin de-bounce Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TCDB</name>
              <description>Timer External Counter Input Pin De-Bounce Enable Bit\nIf this bit is enabled, the edge detection of TMx pin is detected with de-bounce circuit.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>TMx pin de-bounce Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>TMx pin de-bounce Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>TEXISR2</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>TEXISR2</displayName>
          <description>Timer2 External Interrupt Status Register</description>
          <addressOffset>0x18</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TEXIF</name>
              <description>Timer External Capture Interrupt Flag\nThis bit indicates the external capture interrupt flag status.\nWhen TEXEN (TEXCON[3]) enabled, TMx_EXT pin selected as external capture function, and a transition on TMx_EXT pin matched the TEX_EDGE (TEXCON[2:1]) setting, this flag will set to 1 by hardware.\nNote: This bit is cleared by writing 1 to it.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>TMx_EXT pin interrupt did not occur</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>TMx_EXT pin interrupt occurred</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="TCSR2">
          <name>TCSR3</name>
          <displayName>TCSR3</displayName>
          <description>Timer3 Control and Status Register</description>
          <addressOffset>0x20</addressOffset>
       </register>
       <register derivedFrom="TCMPR2">
          <name>TCMPR3</name>
          <displayName>TCMPR3</displayName>
          <description>Timer3 Compare Register</description>
          <addressOffset>0x24</addressOffset>
       </register>
       <register derivedFrom="TISR2">
          <name>TISR3</name>
          <displayName>TISR3</displayName>
          <description>Timer3 Interrupt Status Register</description>
          <addressOffset>0x28</addressOffset>
       </register>
       <register derivedFrom="TDR2">
          <name>TDR3</name>
          <displayName>TDR3</displayName>
          <description>Timer3 Data Register</description>
          <addressOffset>0x2C</addressOffset>
       </register>
       <register derivedFrom="TCAP2">
          <name>TCAP3</name>
          <displayName>TCAP3</displayName>
          <description>Timer3 Capture Data Register</description>
          <addressOffset>0x30</addressOffset>
       </register>
       <register derivedFrom="TEXCON2">
          <name>TEXCON3</name>
          <displayName>TEXCON3</displayName>
          <description>Timer3 External Control Register</description>
          <addressOffset>0x34</addressOffset>
       </register>
       <register derivedFrom="TEXISR2">
          <name>TEXISR3</name>
          <displayName>TEXISR3</displayName>
          <description>Timer3 External Interrupt Status Register</description>
          <addressOffset>0x38</addressOffset>
       </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>PWMA</name>
      <description>PWM Register Map</description>
      <groupName>PWM</groupName>
      <baseAddress>0x40040000</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x0</offset>
        <size>0x48</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x50</offset>
        <size>0x48</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>PPR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PPR</displayName>
          <description>PWM Prescaler Register</description>
          <addressOffset>0x0</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CP01</name>
              <description>Clock Prescaler 0 (PWM-Timer 0 / 1 For Group A And PWM-Timer 4 / 5 For Group B)\nClock input is divided by (CP01 + 1) before it is fed to the corresponding PWM-timer\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CP23</name>
              <description>Clock Prescaler 2 (PWM-Timer2 / 3 For Group A And PWM-Timer 6 / 7 For Group B)\nClock input is divided by (CP23 + 1) before it is fed to the corresponding PWM-timer\n</description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DZI01</name>
              <description>Dead-Zone Interval For Pair Of Channel 0 And Channel 1 (PWM0 And PWM1 Pair For PWM Group A, PWM4 And PWM5 Pair For PWM Group B)\nThese 8-bit determine the Dead-zone length.\n</description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DZI23</name>
              <description>Dead-Zone Interval For Pair Of Channel2 And Channel3 (PWM2 And PWM3 Pair For PWM Group A, PWM6 And PWM7 Pair For PWM Group B)\nThese 8-bit determine the Dead-zone length.\n</description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CSR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CSR</displayName>
          <description>PWM Clock Source Divider Select Register</description>
          <addressOffset>0x4</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CSR0</name>
              <description>PWM Timer 0 Clock Source Divider Selection (PWM Timer 0 For Group A And PWM Timer 4 For Group B)\nSelect clock source divider for PWM timer 0.\n(Table is the same as CSR3)</description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CSR1</name>
              <description>PWM Timer 1 Clock Source Divider Selection (PWM Timer 1 For Group A And PWM Timer 5 For Group B)\nSelect clock source divider for PWM timer 1.\n(Table is the same as CSR3)</description>
              <bitOffset>4</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CSR2</name>
              <description>PWM Timer 2 Clock Source Divider Selection (PWM Timer 2 For Group A And PWM Timer 6 For Group B)\nSelect clock source divider for PWM timer 2.\n(Table is the same as CSR3)</description>
              <bitOffset>8</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CSR3</name>
              <description>PWM Timer 3 Clock Source Divider Selection (PWM Timer 3 For Group A And PWM Timer 7 For Group B)\nSelect clock source divider for PWM timer 3.\n</description>
              <bitOffset>12</bitOffset>
              <bitWidth>3</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>2</description>
                    <value>#000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>4</description>
                    <value>#001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>8</description>
                    <value>#010</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>16</description>
                    <value>#011</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>4</name>
                    <description>1</description>
                    <value>#100</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PCR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PCR</displayName>
          <description>PWM Control Register</description>
          <addressOffset>0x8</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CH0EN</name>
              <description>PWM-Timer 0 Enable (PWM Timer 0 For Group A And PWM Timer 4 For Group B)\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The corresponding PWM-Timer stops running</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The corresponding PWM-Timer starts running</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CH0PINV</name>
              <description>PWM-Timer 0 Output Polar Inverse Enable (PWM Timer 0 For Group A And PWM Timer 4 For Group B)\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM0 output polar inverse Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PWM0 output polar inverse Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CH0INV</name>
              <description>PWM-Timer 0 Output Inverter Enable (PWM Timer 0 For Group A And PWM Timer 4 For Group B)\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Inverter Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Inverter Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CH0MOD</name>
              <description>PWM-Timer 0 Auto-Reload/One-Shot Mode (PWM Timer 0 For Group A And PWM Timer 4 For Group B)\nNote: If there is a transition at this bit, it will cause CNR0 and CMR0 be cleared.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>One-shot mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Auto-reload mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DZEN01</name>
              <description>Dead-Zone 0 Generator Enable (PWM0 And PWM1 Pair For PWM Group A, PWM4 And PWM5 Pair For PWM Group B)\nNote: When Dead-zone generator is enabled, the pair of PWM0 and PWM1 becomes a complementary pair for PWM group A and the pair of PWM4 and PWM5 becomes a complementary pair for PWM group B.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DZEN23</name>
              <description>Dead-Zone 2 Generator Enable (PWM2 And PWM3 Pair For PWM Group A, PWM6 And PWM7 Pair For PWM Group B)\nNote: When Dead-zone generator is enabled, the pair of PWM2 and PWM3 becomes a complementary pair for PWM group A and the pair of PWM6 and PWM7 becomes a complementary pair for PWM group B.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CH1EN</name>
              <description>PWM-Timer 1 Enable (PWM Timer 1 For Group A And PWM Timer 5 For Group B)\n</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Corresponding PWM-Timer Stopped</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Corresponding PWM-Timer Start Running</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CH1PINV</name>
              <description>PWM-Timer 1 Output Polar Inverse Enable (PWM Timer 1 For Group A And PWM Timer 5 For Group B)\n</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM1 output polar inverse Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PWM1 output polar inverse Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CH1INV</name>
              <description>PWM-Timer 1 Output Inverter Enable (PWM Timer 1 For Group A And PWM Timer 5 For Group B)\n</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Inverter Disable</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Inverter Enable</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CH1MOD</name>
              <description>PWM-Timer 1 Auto-Reload/One-Shot Mode (PWM Timer 1 For Group A And PWM Timer 5 For Group B)\nNote: If there is a transition at this bit, it will cause CNR1 and CMR1 be cleared.</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>One-shot mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Auto-reload mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CH2EN</name>
              <description>PWM-Timer 2 Enable (PWM Timer 2 For Group A And PWM Timer 6 For Group B)\n</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Corresponding PWM-Timer Stopped</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Corresponding PWM-Timer Start Running</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CH2PINV</name>
              <description>PWM-Timer 2 Output Polar Inverse Enable (PWM Timer 2 For Group A And PWM Timer 6 For Group B)\n</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM2 output polar inverse Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PWM2 output polar inverse Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CH2INV</name>
              <description>PWM-Timer 2 Output Inverter Enable (PWM Timer 2 For Group A And PWM Timer 6 For Group B)\n</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Inverter Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Inverter Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CH2MOD</name>
              <description>PWM-Timer 2 Auto-Reload/One-Shot Mode (PWM Timer 2 For Group A And PWM Timer 6 For Group B)\nNote: If there is a transition at this bit, it will cause CNR2 and CMR2 be cleared.</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>One-shot mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Auto-reload mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CH3EN</name>
              <description>PWM-Timer 3 Enable (PWM Timer 3 For Group A And PWM Timer 7 For Group B)\n</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Corresponding PWM-Timer Stopped</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Corresponding PWM-Timer Start Running</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CH3PINV</name>
              <description>PWM-Timer 3 Output Polar Inverse Enable (PWM Timer 3 For Group A And PWM Timer 7 For Group B)\n</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM3 output polar inverse Disable</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PWM3 output polar inverse Enable</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CH3INV</name>
              <description>PWM-Timer 3 Output Inverter Enable (PWM Timer 3 For Group A And PWM Timer 7 For Group B)\n</description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Inverter Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Inverter Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CH3MOD</name>
              <description>PWM-Timer 3 Auto-Reload/One-Shot Mode (PWM Timer 3 For Group A And PWM Timer 7 For Group B)\nNote: If there is a transition at this bit, it will cause CNR3 and CMR3 be cleared.</description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>One-shot mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Auto-reload mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PWM01TYPE</name>
              <description>PWM01 Aligned Type Selection (PWM0 And PWM1 Pair For PWM Group A, PWM4 And PWM5 Pair For PWM Group B)\n</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Edge-aligned type</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Center-aligned type</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PWM23TYPE</name>
              <description>PWM23 Aligned Type Selection (PWM2 And PWM3 Pair For PWM Group A, PWM6 And PWM7 Pair For PWM Group B)\n</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Edge-aligned type</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Center-aligned type</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CNR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CNR0</displayName>
          <description>PWM Counter Register 0</description>
          <addressOffset>0xC</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CNRx</name>
              <description>PWM Timer Loaded Value\nCNR determines the PWM period.\nNote: Any write to CNR will take effect in next PWM cycle.\nNote: When PWM operating at Center-aligned type, CNR value should be set between 0x0000 to 0xFFFE. If CNR equal to 0xFFFF, the PWM will work unpredictable.\nNote: When CNR value is set to 0, PWM output is always high.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CMR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CMR0</displayName>
          <description>PWM Comparator Register 0</description>
          <addressOffset>0x10</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CMRx</name>
              <description>PWM Comparator Register\nCMR determines the PWM duty.\nNote: Any write to CNR will take effect in next PWM cycle.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PDR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDR0</displayName>
          <description>PWM Data Register 0</description>
          <addressOffset>0x14</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDRx</name>
              <description>PWM Data Register\nUser can monitor PDR to know the current value in 16-bit counter.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="CNR0">
          <name>CNR1</name>
          <displayName>CNR1</displayName>
          <description>PWM Counter Register 1</description>
          <addressOffset>0x18</addressOffset>
       </register>
       <register derivedFrom="CMR0">
          <name>CMR1</name>
          <displayName>CMR1</displayName>
          <description>PWM Comparator Register 1</description>
          <addressOffset>0x1C</addressOffset>
       </register>
       <register derivedFrom="PDR0">
          <name>PDR1</name>
          <displayName>PDR1</displayName>
          <description>PWM Data Register 1</description>
          <addressOffset>0x20</addressOffset>
       </register>
       <register derivedFrom="CNR0">
          <name>CNR2</name>
          <displayName>CNR2</displayName>
          <description>PWM Counter Register 2</description>
          <addressOffset>0x24</addressOffset>
       </register>
       <register derivedFrom="CMR0">
          <name>CMR2</name>
          <displayName>CMR2</displayName>
          <description>PWM Comparator Register 2</description>
          <addressOffset>0x28</addressOffset>
       </register>
       <register derivedFrom="PDR0">
          <name>PDR2</name>
          <displayName>PDR2</displayName>
          <description>PWM Data Register 2</description>
          <addressOffset>0x2C</addressOffset>
       </register>
       <register derivedFrom="CNR0">
          <name>CNR3</name>
          <displayName>CNR3</displayName>
          <description>PWM Counter Register 3</description>
          <addressOffset>0x30</addressOffset>
       </register>
       <register derivedFrom="CMR0">
          <name>CMR3</name>
          <displayName>CMR3</displayName>
          <description>PWM Comparator Register 3</description>
          <addressOffset>0x34</addressOffset>
       </register>
       <register derivedFrom="PDR0">
          <name>PDR3</name>
          <displayName>PDR3</displayName>
          <description>PWM Data Register 3</description>
          <addressOffset>0x38</addressOffset>
       </register>
       <register>
          <name>PBCR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PBCR</displayName>
          <description>PWM Backward Compatible Register</description>
          <addressOffset>0x3C</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BCn</name>
              <description>PWM Backward Compatible Register\nRefer to the CCR0/CCR2 register bit 6, 7, 22, 23 description\nNote: It is recommended that this bit be set to 1 to prevent CFLRIx and CRLRIx from being cleared when writing CCR0/CCR2.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Configure write 0 to clear CFLRI0~3 and CRLRI0~3</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Configure write 1 to clear CFLRI0~3 and CRLRI0~3</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PIER</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PIER</displayName>
          <description>PWM Interrupt Enable Register</description>
          <addressOffset>0x40</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PWMIE0</name>
              <description>PWM Channel 0 Period Interrupt Enable Bit\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PWMIE1</name>
              <description>PWM Channel 1 Period Interrupt Enable Bit\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PWMIE2</name>
              <description>PWM Channel 2 Period Interrupt Enable Bit\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PWMIE3</name>
              <description>PWM Channel 3 Period Interrupt Enable Bit\n</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PWMDIE0</name>
              <description>PWM Channel 0 Duty Interrupt Enable Bit\n</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PWMDIE1</name>
              <description>PWM Channel 1 Duty Interrupt Enable Bit\n</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PWMDIE2</name>
              <description>PWM Channel 2 Duty Interrupt Enable Bit\n</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PWMDIE3</name>
              <description>PWM Channel 3 Duty Interrupt Enable Bit\n</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>INT01TYPE</name>
              <description>PWM01 Interrupt Period Type Selection Bit (PWM0 And PWM1 Pair For PWM Group A, PWM4 And PWM5 Pair For PWM Group B)\nNote: This bit is effective when PWM in Center-aligned type only.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWMIFn will be set if PWM counter underflow</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PWMIFn will be set if PWM counter matches CNRn register</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>INT23TYPE</name>
              <description>PWM23 Interrupt Period Type Selection Bit (PWM2 And PWM3 Pair For PWM Group A, PWM6 And PWM7 Pair For PWM Group B)\nNote: This bit is effective when PWM in Center-aligned type only.</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWMIFn will be set if PWM counter underflow</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PWMIFn will be set if PWM counter matches CNRn register</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PIIR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PIIR</displayName>
          <description>PWM Interrupt Indication Register</description>
          <addressOffset>0x44</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PWMIF0</name>
              <description>PWM Channel 0 Period Interrupt Status\nThis bit is set by hardware when PWM0 counter reaches the requirement of interrupt (depend on INT01TYPE bit of PIER register), software can write 1 to clear this bit to 0.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PWMIF1</name>
              <description>PWM Channel 1 Period Interrupt Status\nThis bit is set by hardware when PWM1 counter reaches the requirement of interrupt (depend on INT01TYPE bit of PIER register), software can write 1 to clear this bit to 0.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PWMIF2</name>
              <description>PWM Channel 2 Period Interrupt Status\nThis bit is set by hardware when PWM2 counter reaches the requirement of interrupt (depend on INT23TYPE bit of PIER register), software can write 1 to clear this bit to 0.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PWMIF3</name>
              <description>PWM Channel 3 Period Interrupt Status\nThis bit is set by hardware when PWM3 counter reaches the requirement of interrupt (depend on INT23TYPE bit of PIER register), software can write 1 to clear this bit to 0.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PWMDIF0</name>
              <description>PWM Channel 0 Duty Interrupt Flag\nFlag is set by hardware when channel 0 PWM counter down count and reaches CMR0, software can clear this bit by writing a one to it.\nNote: If CMR equal to CNR, this flag is not working in Edge-aligned type selection</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PWMDIF1</name>
              <description>PWM Channel 1 Duty Interrupt Flag\nFlag is set by hardware when channel 1 PWM counter down count and reaches CMR1, software can clear this bit by writing a one to it.\nNote: If CMR equal to CNR, this flag is not working in Edge-aligned type selection</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PWMDIF2</name>
              <description>PWM Channel 2 Duty Interrupt Flag\nFlag is set by hardware when channel 2 PWM counter down count and reaches CMR2, software can clear this bit by writing a one to it.\nNote: If CMR equal to CNR, this flag is not working in Edge-aligned type selection</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PWMDIF3</name>
              <description>PWM Channel 3 Duty Interrupt Flag\nFlag is set by hardware when channel 3 PWM counter down count and reaches CMR3, software can clear this bit by writing a one to it.\nNote: If CMR equal to CNR, this flag is not working in Edge-aligned type selection</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CCR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CCR0</displayName>
          <description>PWM Capture Control Register 0</description>
          <addressOffset>0x50</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>INV0</name>
              <description>Channel 0 Inverter Enable Bit\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Inverter Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Inverter Enabled. Reverse the input signal from GPIO before fed to Capture timer</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CRL_IE0</name>
              <description>Channel 0 Rising Latch Interrupt Enable Bit\nWhen Enabled, if Capture detects PWM group channel 0 has rising transition, Capture will issue an Interrupt.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Rising latch interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Rising latch interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CFL_IE0</name>
              <description>Channel 0 Falling Latch Interrupt Enable Bit\nWhen Enabled, if Capture detects PWM group channel 0 has falling transition, Capture will issue an Interrupt.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Falling latch interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Falling latch interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CAPCH0EN</name>
              <description>Channel 0 Capture Function Enable\nWhen Enabled, Capture latched the PWM-counter value and saved to CRLR (Rising latch) and CFLR (Falling latch).\nWhen Disabled, Capture does not update CRLR and CFLR, and disable PWM group channel 0 Interrupt.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Capture function on PWM group channel 0 Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Capture function on PWM group channel 0 Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CAPIF0</name>
              <description>Channel 0 Capture Interrupt Indication Flag\nWrite 1 to clear this bit to 0.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CRLRI0</name>
              <description>CRLR0 Latched Indicator\nWhen PWM group input channel 0 has a rising transition, CRLR0 was latched with the value of PWM down-counter and this bit is set by hardware.\nSoftware can write 0 to clear this bit to 0 if the BCn bit is 0, and can write 1 to clear this bit to 0 if the BCn bit is 1.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CFLRI0</name>
              <description>CFLR0 Latched Indicator\nWhen PWM group input channel 0 has a falling transition, CFLR0 was latched with the value of PWM down-counter and this bit is set by hardware.\nSoftware can write 0 to clear this bit to 0 if the BCn bit is 0, and can write 1 to clear this bit to0 if BCn bit is 1.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>INV1</name>
              <description>Channel 1 Inverter Enable Bit\n</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Inverter Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Inverter Enabled. Reverse the input signal from GPIO before fed to Capture timer</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CRL_IE1</name>
              <description>Channel 1 Rising Latch Interrupt Enable Bit\nWhen Enabled, if Capture detects PWM group channel 1 has rising transition, Capture will issue an Interrupt.</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Rising latch interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Rising latch interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CFL_IE1</name>
              <description>Channel 1 Falling Latch Interrupt Enable Bit\nWhen Enabled, if Capture detects PWM group channel 1 has falling transition, Capture will issue an Interrupt.</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Falling latch interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Falling latch interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CAPCH1EN</name>
              <description>Channel 1 Capture Function Enable Bit\nWhen Enabled, Capture latched the PWM-counter and saved to CRLR (Rising latch) and CFLR (Falling latch).\nWhen Disabled, Capture does not update CRLR and CFLR, and disable PWM group channel 1 Interrupt.</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Capture function on PWM group channel 1 Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Capture function on PWM group channel 1 Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CAPIF1</name>
              <description>Channel 1 Capture Interrupt Indication Flag\nWrite 1 to clear this bit to 0.</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CRLRI1</name>
              <description>CRLR1 Latched Indicator Bit\nWhen PWM group input channel 1 has a rising transition, CRLR1 was latched with the value of PWM down-counter and this bit is set by hardware.\nSoftware can write 0 to clear this bit to 0 if BCn bit is 0, and can write 1 to clear this bit to0 if BCn bit is 1.</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CFLRI1</name>
              <description>CFLR1 Latched Indicator Bit\nWhen PWM group input channel 1 has a falling transition, CFLR1 was latched with the value of PWM down-counter and this bit is set by hardware.\nSoftware can write 0 to clear this bit to 0 if BCn bit is 0, and can write 1 to clear this bit to 0 if BCn bit is 1.</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CCR2</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CCR2</displayName>
          <description>PWM Capture Control Register 2</description>
          <addressOffset>0x54</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>INV2</name>
              <description>Channel 2 Inverter Enable Bit\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Inverter Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Inverter Enabled. Reverse the input signal from GPIO before fed to Capture timer</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CRL_IE2</name>
              <description>Channel 2 Rising Latch Interrupt Enable Bit\nWhen Enabled, if Capture detects PWM group channel 2 has rising transition, Capture will issue an Interrupt.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Rising latch interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Rising latch interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CFL_IE2</name>
              <description>Channel 2 Falling Latch Interrupt Enable Bit\nWhen Enabled, if Capture detects PWM group channel 2 has falling transition, Capture will issue an Interrupt.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Falling latch interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Falling latch interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CAPCH2EN</name>
              <description>Channel 2 Capture Function Enable Bit\nWhen Enabled, Capture latched the PWM-counter value and saved to CRLR (Rising latch) and CFLR (Falling latch).\nWhen Disabled, Capture does not update CRLR and CFLR, and disable PWM group channel 2 Interrupt.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Capture function on PWM group channel 2 Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Capture function on PWM group channel 2 Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CAPIF2</name>
              <description>Channel 2 Capture Interrupt Indication Flag\nWrite 1 to clear this bit to 0</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CRLRI2</name>
              <description>CRLR2 Latched Indicator\nWhen PWM group input channel 2 has a rising transition, CRLR2 was latched with the value of PWM down-counter and this bit is set by hardware.\nSoftware can write 0 to clear this bit to 0 if the BCn bit is 0, and can write 1 to clear this bit to 0 if the BCn bit is 1.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CFLRI2</name>
              <description>CFLR2 Latched Indicator\nWhen PWM group input channel 2 has a falling transition, CFLR2 was latched with the value of PWM down-counter and this bit is set by hardware.\nSoftware can write 0 to clear this bit to 0 if BCn bit is 0, and can write 1 to clear this bit to 0 if the BCn bit is 1.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>INV3</name>
              <description>Channel 3 Inverter Enable Bit\n</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Inverter Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Inverter Enabled. Reverse the input signal from GPIO before fed to Capture timer</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CRL_IE3</name>
              <description>Channel 3 Rising Latch Interrupt Enable Bit\nWhen Enabled, if Capture detects PWM group channel 3 has rising transition, Capture will issue an Interrupt.</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Rising latch interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Rising latch interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CFL_IE3</name>
              <description>Channel 3 Falling Latch Interrupt Enable Bit\nWhen Enabled, if Capture detects PWM group channel 3 has falling transition, Capture will issue an Interrupt.</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Falling latch interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Falling latch interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CAPCH3EN</name>
              <description>Channel 3 Capture Function Enable Bit\nWhen Enabled, Capture latched the PWM-counter and saved to CRLR (Rising latch) and CFLR (Falling latch).\nWhen Disabled, Capture does not update CRLR and CFLR, and disable PWM group channel 3 Interrupt.</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Capture function on PWM group channel 3 Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Capture function on PWM group channel 3 Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CAPIF3</name>
              <description>Channel 3 Capture Interrupt Indication Flag\nWrite 1 to clear this bit to 0</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CRLRI3</name>
              <description>CRLR3 Latched Indicator\nWhen PWM group input channel 3 has a rising transition, CRLR3 was latched with the value of PWM down-counter and this bit is set by hardware.\nSoftware can write 0 to clear this bit to 0 if the BCn bit is 0, and can write 1 to clear this bit to 0 if the BCn bit is 1.</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CFLRI3</name>
              <description>CFLR3 Latched Indicator\nWhen PWM group input channel 3 has a falling transition, CFLR3 was latched with the value of PWM down-counter and this bit is set by hardware.\nSoftware can write 0 to clear this bit to 0 if the BCn bit is 0, and can write 1 to clear this bit to 0 if the BCn bit is 1.</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CRLR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CRLR0</displayName>
          <description>PWM Capture Rising Latch Register (Channel 0)</description>
          <addressOffset>0x58</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CRLRx</name>
              <description>Capture Rising Latch Register\nLatch the PWM counter when Channel 0/1/2/3 has rising transition.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CFLR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CFLR0</displayName>
          <description>PWM Capture Falling Latch Register (Channel 0)</description>
          <addressOffset>0x5C</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CFLRx</name>
              <description>Capture Falling Latch Register\nLatch the PWM counter when Channel 0/1/2/3 has Falling transition.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="CRLR0">
          <name>CRLR1</name>
          <displayName>CRLR1</displayName>
          <description>PWM Capture Rising Latch Register (Channel 1)</description>
          <addressOffset>0x60</addressOffset>
       </register>
       <register derivedFrom="CFLR0">
          <name>CFLR1</name>
          <displayName>CFLR1</displayName>
          <description>PWM Capture Falling Latch Register (Channel 1)</description>
          <addressOffset>0x64</addressOffset>
       </register>
       <register derivedFrom="CRLR0">
          <name>CRLR2</name>
          <displayName>CRLR2</displayName>
          <description>PWM Capture Rising Latch Register (Channel 2)</description>
          <addressOffset>0x68</addressOffset>
       </register>
       <register derivedFrom="CFLR0">
          <name>CFLR2</name>
          <displayName>CFLR2</displayName>
          <description>PWM Capture Falling Latch Register (Channel 2)</description>
          <addressOffset>0x6C</addressOffset>
       </register>
       <register derivedFrom="CRLR0">
          <name>CRLR3</name>
          <displayName>CRLR3</displayName>
          <description>PWM Capture Rising Latch Register (Channel 3)</description>
          <addressOffset>0x70</addressOffset>
       </register>
       <register derivedFrom="CFLR0">
          <name>CFLR3</name>
          <displayName>CFLR3</displayName>
          <description>PWM Capture Falling Latch Register (Channel 3)</description>
          <addressOffset>0x74</addressOffset>
       </register>
       <register>
          <name>CAPENR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CAPENR</displayName>
          <description>PWM Capture Input 0~3 Enable Register</description>
          <addressOffset>0x78</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CINEN0</name>
              <description>Channel 0 Capture Input Enable Bit\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM Channel 0 capture input path Disabled. The input of PWM channel 0 capture function is always regarded as 0</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PWM Channel 0 capture input path Enabled. The input of PWM channel 0 capture function comes from correlative multifunction pin if GPIO multi-function is set as PWM0</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CINEN1</name>
              <description>Channel 1 Capture Input Enable Bit\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM Channel 1 capture input path Disabled. The input of PWM channel 1 capture function is always regarded as 0</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PWM Channel 1 capture input path Enabled. The input of PWM channel 1 capture function comes from correlative multifunction pin if GPIO multi-function is set as PWM1</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CINEN2</name>
              <description>Channel 2 Capture Input Enable Bit\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM Channel 2 capture input path Disabled. The input of PWM channel 2 capture function is always regarded as 0</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PWM Channel 2 capture input path Enabled. The input of PWM channel 2 capture function comes from correlative multifunction pin if GPIO multi-function is set as PWM2</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CINEN3</name>
              <description>Channel 3 Capture Input Enable Bit\n</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM Channel 3 capture input path Disabled. The input of PWM channel 3 capture function is always regarded as 0</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PWM Channel 3 capture input path Enabled. The input of PWM channel 3 capture function comes from correlative multifunction pin if GPIO multi-function is set as PWM3</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>POE</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>POE</displayName>
          <description>PWM Output Enable for Channel 0~3</description>
          <addressOffset>0x7C</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>POE0</name>
              <description>Channel 0 Output Enable Bit\nNote: The corresponding GPIO pin must also be switched to PWM function</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM channel 0 output to pin Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PWM channel 0 output to pin Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>POE1</name>
              <description>Channel 1 Output Enable Bit\nNote: The corresponding GPIO pin must also be switched to PWM function</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM channel 1 output to pin Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PWM channel 1 output to pin Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>POE2</name>
              <description>Channel 2 Output Enable Bit\nNote: The corresponding GPIO pin must also be switched to PWM function</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM channel 2 output to pin Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PWM channel 2 output to pin Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>POE3</name>
              <description>Channel 3 Output Enable Bit\nNote: The corresponding GPIO pin must also be switched to PWM function</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM channel 3 output to pin Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PWM channel 3 output to pin Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>TCON</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>TCON</displayName>
          <description>PWM Trigger Control for Channel 0~3</description>
          <addressOffset>0x80</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PWM0TEN</name>
              <description>Channel 0 Center-Aligned Trigger Enable Bit\nPWM can trigger ADC to start conversion when PWM counter up count to CNR if this bit is set to 1.\nNote: This function is only supported when PWM operating at Center-aligned type.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM channel 0 trigger ADC function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PWM channel 0 trigger ADC function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PWM1TEN</name>
              <description>Channel 1 Center-Aligned Trigger Enable Bit\nPWM can trigger ADC to start conversion when PWM counter up count to CNR if this bit is set to 1.\nNote: This function is only supported when PWM operating at Center-aligned type.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM channel 1 trigger ADC function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PWM channel 1 trigger ADC function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PWM2TEN</name>
              <description>Channel 2 Center-Aligned Trigger Enable Bit\nPWM can trigger ADC to start conversion when PWM counter up count to CNR if this bit is set to 1.\nNote: This function is only supported when PWM operating at Center-aligned type.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM channel 2 trigger ADC function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PWM channel 2 trigger ADC function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PWM3TEN</name>
              <description>Channel 3 Center-Aligned Trigger Enable Bit\nPWM can trigger ADC to start conversion when PWM counter up count to CNR if this bit is set to 1.\nNote: This function is only supported when PWM operating at Center-aligned type.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM channel 3 trigger ADC function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PWM channel 3 trigger ADC function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>TSTATUS</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>TSTATUS</displayName>
          <description>PWM Trigger Status Register</description>
          <addressOffset>0x84</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PWM0TF</name>
              <description>Channel 0 Center-Aligned Trigger Flag\nFor Center-aligned Operating mode, this bit is set to 1 by hardware when PWM counter up counts to CNR if PWM0TEN bit is set to 1. After this bit is set to 1, ADC will start conversion if ADC triggered source is selected by PWM.\nSoftware can write 1 to clear this bit.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PWM1TF</name>
              <description>Channel 1 Center-Aligned Trigger Flag\nFor Center-aligned Operating mode, this bit is set to 1 by hardware when PWM counter up count to CNR if PWM1TEN bit is set to 1. After this bit is set to 1, ADC will start conversion if ADC triggered source is selected by PWM.\nSoftware can write 1 to clear this bit.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PWM2TF</name>
              <description>Channel 2 Center-Aligned Trigger Flag\nFor Center-aligned Operating mode, this bit is set to 1 by hardware when PWM counter up count to CNR if PWM2TEN bit is set to 1. After this bit is set to 1, ADC will start conversion if ADC triggered source is selected by PWM.\nSoftware can write 1 to clear this bit.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PWM3TF</name>
              <description>Channel 3 Center-Aligned Trigger Flag\nFor Center-aligned Operating mode, this bit is set to 1 by hardware when PWM counter up count to CNR if PWM3TEN bit is set to 1. After this bit is set to 1, ADC will start conversion if ADC triggered source is selected by PWM.\nSoftware can write 1 to clear this bit.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SYNCBUSY0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SYNCBUSY0</displayName>
          <description>PWM0 Synchronous Busy Status Register</description>
          <addressOffset>0x88</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>S_BUSY</name>
              <description>PWM Synchronous Busy\nWhen software writes CNR0/CMR0/PPR or switches PWM0 operation mode (PCR[3]), PWM will have a busy time to update these values completely because PWM clock may be different from system clock domain. Software needs to check this busy status before writing CNR0/CMR0/PPR or switching PWM0 operation mode (PCR[3]) to make sure previous setting has been updated completely.\nThis bit will be set when software writes CNR0/CMR0/PPR or switches PWM0 operation mode (PCR[3]) and will be cleared by hardware automatically when PWM update these value completely.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SYNCBUSY1</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SYNCBUSY1</displayName>
          <description>PWM1 Synchronous Busy Status Register</description>
          <addressOffset>0x8C</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>S_BUSY</name>
              <description>PWM Synchronous Busy\nWhen Software writes CNR1/CMR1/PPR or switches PWM1 operation mode (PCR[11]), PWM will have a busy time to update these values completely because PWM clock may be different from system clock domain. Software needs to check this busy status before writing CNR1/CMR1/PPR or switching PWM1 operation mode (PCR[11]) to make sure previous setting has been updated completely.\nThis bit will be set when software writes CNR1/CMR1/PPR or switches PWM1 operation mode (PCR[11]) and will be cleared by hardware automatically when PWM update these value completely.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SYNCBUSY2</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SYNCBUSY2</displayName>
          <description>PWM2 Synchronous Busy Status Register</description>
          <addressOffset>0x90</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>S_BUSY</name>
              <description>PWM Synchronous Busy\nWhen Software writes CNR2/CMR2/PPR or switch PWM2 operation mode (PCR[19]), PWM will have a busy time to update these values completely because PWM clock may be different from system clock domain. Software needs to check this busy status before writing CNR2/CMR2/PPR or switching PWM2 operation mode (PCR[19]) to make sure previous setting has been updated completely.\nThis bit will be set when software writes CNR2/CMR2/PPR or switch PWM2 operation mode (PCR[19]) and will be cleared by hardware automatically when PWM update these value completely.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SYNCBUSY3</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SYNCBUSY3</displayName>
          <description>PWM3 Synchronous Busy Status Register</description>
          <addressOffset>0x94</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>S_BUSY</name>
              <description>PWM Synchronous Busy\nWhen Software writes CNR3/CMR3/PPR or switch PWM3 operation mode (PCR[27]), PWM will have a busy time to update these values completely because PWM clock may be different from system clock domain. Software need to check this busy status before writing CNR3/CMR3/PPR or switching PWM3 operation mode (PCR[27]) to make sure previous setting has been updated completely.\nThis bit will be set when Software writes CNR3/CMR3/PPR or switch PWM3 operation mode (PCR[27]) and will be cleared by hardware automatically when PWM update these value completely.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>PWMB</name>
      <description>PWM Register Map</description>
      <groupName>PWM</groupName>
      <baseAddress>0x40140000</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x0</offset>
        <size>0x48</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x50</offset>
        <size>0x48</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>PPR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PPR</displayName>
          <description>PWM Prescaler Register</description>
          <addressOffset>0x0</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CP01</name>
              <description>Clock Prescaler 0 (PWM-Timer 0 / 1 For Group A And PWM-Timer 4 / 5 For Group B)\nClock input is divided by (CP01 + 1) before it is fed to the corresponding PWM-timer\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CP23</name>
              <description>Clock Prescaler 2 (PWM-Timer2 / 3 For Group A And PWM-Timer 6 / 7 For Group B)\nClock input is divided by (CP23 + 1) before it is fed to the corresponding PWM-timer\n</description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DZI01</name>
              <description>Dead-Zone Interval For Pair Of Channel 0 And Channel 1 (PWM0 And PWM1 Pair For PWM Group A, PWM4 And PWM5 Pair For PWM Group B)\nThese 8-bit determine the Dead-zone length.\n</description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DZI23</name>
              <description>Dead-Zone Interval For Pair Of Channel2 And Channel3 (PWM2 And PWM3 Pair For PWM Group A, PWM6 And PWM7 Pair For PWM Group B)\nThese 8-bit determine the Dead-zone length.\n</description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CSR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CSR</displayName>
          <description>PWM Clock Source Divider Select Register</description>
          <addressOffset>0x4</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CSR0</name>
              <description>PWM Timer 0 Clock Source Divider Selection (PWM Timer 0 For Group A And PWM Timer 4 For Group B)\nSelect clock source divider for PWM timer 0.\n(Table is the same as CSR3)</description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CSR1</name>
              <description>PWM Timer 1 Clock Source Divider Selection (PWM Timer 1 For Group A And PWM Timer 5 For Group B)\nSelect clock source divider for PWM timer 1.\n(Table is the same as CSR3)</description>
              <bitOffset>4</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CSR2</name>
              <description>PWM Timer 2 Clock Source Divider Selection (PWM Timer 2 For Group A And PWM Timer 6 For Group B)\nSelect clock source divider for PWM timer 2.\n(Table is the same as CSR3)</description>
              <bitOffset>8</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CSR3</name>
              <description>PWM Timer 3 Clock Source Divider Selection (PWM Timer 3 For Group A And PWM Timer 7 For Group B)\nSelect clock source divider for PWM timer 3.\n</description>
              <bitOffset>12</bitOffset>
              <bitWidth>3</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>2</description>
                    <value>#000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>4</description>
                    <value>#001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>8</description>
                    <value>#010</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>16</description>
                    <value>#011</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>4</name>
                    <description>1</description>
                    <value>#100</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PCR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PCR</displayName>
          <description>PWM Control Register</description>
          <addressOffset>0x8</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CH0EN</name>
              <description>PWM-Timer 0 Enable (PWM Timer 0 For Group A And PWM Timer 4 For Group B)\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The corresponding PWM-Timer stops running</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The corresponding PWM-Timer starts running</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CH0PINV</name>
              <description>PWM-Timer 0 Output Polar Inverse Enable (PWM Timer 0 For Group A And PWM Timer 4 For Group B)\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM0 output polar inverse Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PWM0 output polar inverse Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CH0INV</name>
              <description>PWM-Timer 0 Output Inverter Enable (PWM Timer 0 For Group A And PWM Timer 4 For Group B)\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Inverter Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Inverter Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CH0MOD</name>
              <description>PWM-Timer 0 Auto-Reload/One-Shot Mode (PWM Timer 0 For Group A And PWM Timer 4 For Group B)\nNote: If there is a transition at this bit, it will cause CNR0 and CMR0 be cleared.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>One-shot mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Auto-reload mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DZEN01</name>
              <description>Dead-Zone 0 Generator Enable (PWM0 And PWM1 Pair For PWM Group A, PWM4 And PWM5 Pair For PWM Group B)\nNote: When Dead-zone generator is enabled, the pair of PWM0 and PWM1 becomes a complementary pair for PWM group A and the pair of PWM4 and PWM5 becomes a complementary pair for PWM group B.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DZEN23</name>
              <description>Dead-Zone 2 Generator Enable (PWM2 And PWM3 Pair For PWM Group A, PWM6 And PWM7 Pair For PWM Group B)\nNote: When Dead-zone generator is enabled, the pair of PWM2 and PWM3 becomes a complementary pair for PWM group A and the pair of PWM6 and PWM7 becomes a complementary pair for PWM group B.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CH1EN</name>
              <description>PWM-Timer 1 Enable (PWM Timer 1 For Group A And PWM Timer 5 For Group B)\n</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Corresponding PWM-Timer Stopped</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Corresponding PWM-Timer Start Running</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CH1PINV</name>
              <description>PWM-Timer 1 Output Polar Inverse Enable (PWM Timer 1 For Group A And PWM Timer 5 For Group B)\n</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM1 output polar inverse Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PWM1 output polar inverse Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CH1INV</name>
              <description>PWM-Timer 1 Output Inverter Enable (PWM Timer 1 For Group A And PWM Timer 5 For Group B)\n</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Inverter Disable</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Inverter Enable</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CH1MOD</name>
              <description>PWM-Timer 1 Auto-Reload/One-Shot Mode (PWM Timer 1 For Group A And PWM Timer 5 For Group B)\nNote: If there is a transition at this bit, it will cause CNR1 and CMR1 be cleared.</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>One-shot mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Auto-reload mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CH2EN</name>
              <description>PWM-Timer 2 Enable (PWM Timer 2 For Group A And PWM Timer 6 For Group B)\n</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Corresponding PWM-Timer Stopped</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Corresponding PWM-Timer Start Running</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CH2PINV</name>
              <description>PWM-Timer 2 Output Polar Inverse Enable (PWM Timer 2 For Group A And PWM Timer 6 For Group B)\n</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM2 output polar inverse Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PWM2 output polar inverse Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CH2INV</name>
              <description>PWM-Timer 2 Output Inverter Enable (PWM Timer 2 For Group A And PWM Timer 6 For Group B)\n</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Inverter Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Inverter Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CH2MOD</name>
              <description>PWM-Timer 2 Auto-Reload/One-Shot Mode (PWM Timer 2 For Group A And PWM Timer 6 For Group B)\nNote: If there is a transition at this bit, it will cause CNR2 and CMR2 be cleared.</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>One-shot mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Auto-reload mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CH3EN</name>
              <description>PWM-Timer 3 Enable (PWM Timer 3 For Group A And PWM Timer 7 For Group B)\n</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Corresponding PWM-Timer Stopped</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Corresponding PWM-Timer Start Running</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CH3PINV</name>
              <description>PWM-Timer 3 Output Polar Inverse Enable (PWM Timer 3 For Group A And PWM Timer 7 For Group B)\n</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM3 output polar inverse Disable</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PWM3 output polar inverse Enable</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CH3INV</name>
              <description>PWM-Timer 3 Output Inverter Enable (PWM Timer 3 For Group A And PWM Timer 7 For Group B)\n</description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Inverter Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Inverter Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CH3MOD</name>
              <description>PWM-Timer 3 Auto-Reload/One-Shot Mode (PWM Timer 3 For Group A And PWM Timer 7 For Group B)\nNote: If there is a transition at this bit, it will cause CNR3 and CMR3 be cleared.</description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>One-shot mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Auto-reload mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PWM01TYPE</name>
              <description>PWM01 Aligned Type Selection (PWM0 And PWM1 Pair For PWM Group A, PWM4 And PWM5 Pair For PWM Group B)\n</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Edge-aligned type</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Center-aligned type</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PWM23TYPE</name>
              <description>PWM23 Aligned Type Selection (PWM2 And PWM3 Pair For PWM Group A, PWM6 And PWM7 Pair For PWM Group B)\n</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Edge-aligned type</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Center-aligned type</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CNR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CNR0</displayName>
          <description>PWM Counter Register 0</description>
          <addressOffset>0xC</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CNRx</name>
              <description>PWM Timer Loaded Value\nCNR determines the PWM period.\nNote: Any write to CNR will take effect in next PWM cycle.\nNote: When PWM operating at Center-aligned type, CNR value should be set between 0x0000 to 0xFFFE. If CNR equal to 0xFFFF, the PWM will work unpredictable.\nNote: When CNR value is set to 0, PWM output is always high.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CMR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CMR0</displayName>
          <description>PWM Comparator Register 0</description>
          <addressOffset>0x10</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CMRx</name>
              <description>PWM Comparator Register\nCMR determines the PWM duty.\nNote: Any write to CNR will take effect in next PWM cycle.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PDR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDR0</displayName>
          <description>PWM Data Register 0</description>
          <addressOffset>0x14</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDRx</name>
              <description>PWM Data Register\nUser can monitor PDR to know the current value in 16-bit counter.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="CNR0">
          <name>CNR1</name>
          <displayName>CNR1</displayName>
          <description>PWM Counter Register 1</description>
          <addressOffset>0x18</addressOffset>
       </register>
       <register derivedFrom="CMR0">
          <name>CMR1</name>
          <displayName>CMR1</displayName>
          <description>PWM Comparator Register 1</description>
          <addressOffset>0x1C</addressOffset>
       </register>
       <register derivedFrom="PDR0">
          <name>PDR1</name>
          <displayName>PDR1</displayName>
          <description>PWM Data Register 1</description>
          <addressOffset>0x20</addressOffset>
       </register>
       <register derivedFrom="CNR0">
          <name>CNR2</name>
          <displayName>CNR2</displayName>
          <description>PWM Counter Register 2</description>
          <addressOffset>0x24</addressOffset>
       </register>
       <register derivedFrom="CMR0">
          <name>CMR2</name>
          <displayName>CMR2</displayName>
          <description>PWM Comparator Register 2</description>
          <addressOffset>0x28</addressOffset>
       </register>
       <register derivedFrom="PDR0">
          <name>PDR2</name>
          <displayName>PDR2</displayName>
          <description>PWM Data Register 2</description>
          <addressOffset>0x2C</addressOffset>
       </register>
       <register derivedFrom="CNR0">
          <name>CNR3</name>
          <displayName>CNR3</displayName>
          <description>PWM Counter Register 3</description>
          <addressOffset>0x30</addressOffset>
       </register>
       <register derivedFrom="CMR0">
          <name>CMR3</name>
          <displayName>CMR3</displayName>
          <description>PWM Comparator Register 3</description>
          <addressOffset>0x34</addressOffset>
       </register>
       <register derivedFrom="PDR0">
          <name>PDR3</name>
          <displayName>PDR3</displayName>
          <description>PWM Data Register 3</description>
          <addressOffset>0x38</addressOffset>
       </register>
       <register>
          <name>PBCR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PBCR</displayName>
          <description>PWM Backward Compatible Register</description>
          <addressOffset>0x3C</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BCn</name>
              <description>PWM Backward Compatible Register\nRefer to the CCR0/CCR2 register bit 6, 7, 22, 23 description\nNote: It is recommended that this bit be set to 1 to prevent CFLRIx and CRLRIx from being cleared when writing CCR0/CCR2.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Configure write 0 to clear CFLRI0~3 and CRLRI0~3</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Configure write 1 to clear CFLRI0~3 and CRLRI0~3</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PIER</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PIER</displayName>
          <description>PWM Interrupt Enable Register</description>
          <addressOffset>0x40</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PWMIE0</name>
              <description>PWM Channel 0 Period Interrupt Enable Bit\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PWMIE1</name>
              <description>PWM Channel 1 Period Interrupt Enable Bit\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PWMIE2</name>
              <description>PWM Channel 2 Period Interrupt Enable Bit\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PWMIE3</name>
              <description>PWM Channel 3 Period Interrupt Enable Bit\n</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PWMDIE0</name>
              <description>PWM Channel 0 Duty Interrupt Enable Bit\n</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PWMDIE1</name>
              <description>PWM Channel 1 Duty Interrupt Enable Bit\n</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PWMDIE2</name>
              <description>PWM Channel 2 Duty Interrupt Enable Bit\n</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PWMDIE3</name>
              <description>PWM Channel 3 Duty Interrupt Enable Bit\n</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>INT01TYPE</name>
              <description>PWM01 Interrupt Period Type Selection Bit (PWM0 And PWM1 Pair For PWM Group A, PWM4 And PWM5 Pair For PWM Group B)\nNote: This bit is effective when PWM in Center-aligned type only.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWMIFn will be set if PWM counter underflow</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PWMIFn will be set if PWM counter matches CNRn register</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>INT23TYPE</name>
              <description>PWM23 Interrupt Period Type Selection Bit (PWM2 And PWM3 Pair For PWM Group A, PWM6 And PWM7 Pair For PWM Group B)\nNote: This bit is effective when PWM in Center-aligned type only.</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWMIFn will be set if PWM counter underflow</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PWMIFn will be set if PWM counter matches CNRn register</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PIIR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PIIR</displayName>
          <description>PWM Interrupt Indication Register</description>
          <addressOffset>0x44</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PWMIF0</name>
              <description>PWM Channel 0 Period Interrupt Status\nThis bit is set by hardware when PWM0 counter reaches the requirement of interrupt (depend on INT01TYPE bit of PIER register), software can write 1 to clear this bit to 0.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PWMIF1</name>
              <description>PWM Channel 1 Period Interrupt Status\nThis bit is set by hardware when PWM1 counter reaches the requirement of interrupt (depend on INT01TYPE bit of PIER register), software can write 1 to clear this bit to 0.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PWMIF2</name>
              <description>PWM Channel 2 Period Interrupt Status\nThis bit is set by hardware when PWM2 counter reaches the requirement of interrupt (depend on INT23TYPE bit of PIER register), software can write 1 to clear this bit to 0.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PWMIF3</name>
              <description>PWM Channel 3 Period Interrupt Status\nThis bit is set by hardware when PWM3 counter reaches the requirement of interrupt (depend on INT23TYPE bit of PIER register), software can write 1 to clear this bit to 0.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PWMDIF0</name>
              <description>PWM Channel 0 Duty Interrupt Flag\nFlag is set by hardware when channel 0 PWM counter down count and reaches CMR0, software can clear this bit by writing a one to it.\nNote: If CMR equal to CNR, this flag is not working in Edge-aligned type selection</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PWMDIF1</name>
              <description>PWM Channel 1 Duty Interrupt Flag\nFlag is set by hardware when channel 1 PWM counter down count and reaches CMR1, software can clear this bit by writing a one to it.\nNote: If CMR equal to CNR, this flag is not working in Edge-aligned type selection</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PWMDIF2</name>
              <description>PWM Channel 2 Duty Interrupt Flag\nFlag is set by hardware when channel 2 PWM counter down count and reaches CMR2, software can clear this bit by writing a one to it.\nNote: If CMR equal to CNR, this flag is not working in Edge-aligned type selection</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PWMDIF3</name>
              <description>PWM Channel 3 Duty Interrupt Flag\nFlag is set by hardware when channel 3 PWM counter down count and reaches CMR3, software can clear this bit by writing a one to it.\nNote: If CMR equal to CNR, this flag is not working in Edge-aligned type selection</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CCR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CCR0</displayName>
          <description>PWM Capture Control Register 0</description>
          <addressOffset>0x50</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>INV0</name>
              <description>Channel 0 Inverter Enable Bit\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Inverter Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Inverter Enabled. Reverse the input signal from GPIO before fed to Capture timer</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CRL_IE0</name>
              <description>Channel 0 Rising Latch Interrupt Enable Bit\nWhen Enabled, if Capture detects PWM group channel 0 has rising transition, Capture will issue an Interrupt.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Rising latch interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Rising latch interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CFL_IE0</name>
              <description>Channel 0 Falling Latch Interrupt Enable Bit\nWhen Enabled, if Capture detects PWM group channel 0 has falling transition, Capture will issue an Interrupt.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Falling latch interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Falling latch interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CAPCH0EN</name>
              <description>Channel 0 Capture Function Enable\nWhen Enabled, Capture latched the PWM-counter value and saved to CRLR (Rising latch) and CFLR (Falling latch).\nWhen Disabled, Capture does not update CRLR and CFLR, and disable PWM group channel 0 Interrupt.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Capture function on PWM group channel 0 Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Capture function on PWM group channel 0 Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CAPIF0</name>
              <description>Channel 0 Capture Interrupt Indication Flag\nWrite 1 to clear this bit to 0.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CRLRI0</name>
              <description>CRLR0 Latched Indicator\nWhen PWM group input channel 0 has a rising transition, CRLR0 was latched with the value of PWM down-counter and this bit is set by hardware.\nSoftware can write 0 to clear this bit to 0 if the BCn bit is 0, and can write 1 to clear this bit to 0 if the BCn bit is 1.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CFLRI0</name>
              <description>CFLR0 Latched Indicator\nWhen PWM group input channel 0 has a falling transition, CFLR0 was latched with the value of PWM down-counter and this bit is set by hardware.\nSoftware can write 0 to clear this bit to 0 if the BCn bit is 0, and can write 1 to clear this bit to0 if BCn bit is 1.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>INV1</name>
              <description>Channel 1 Inverter Enable Bit\n</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Inverter Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Inverter Enabled. Reverse the input signal from GPIO before fed to Capture timer</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CRL_IE1</name>
              <description>Channel 1 Rising Latch Interrupt Enable Bit\nWhen Enabled, if Capture detects PWM group channel 1 has rising transition, Capture will issue an Interrupt.</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Rising latch interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Rising latch interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CFL_IE1</name>
              <description>Channel 1 Falling Latch Interrupt Enable Bit\nWhen Enabled, if Capture detects PWM group channel 1 has falling transition, Capture will issue an Interrupt.</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Falling latch interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Falling latch interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CAPCH1EN</name>
              <description>Channel 1 Capture Function Enable Bit\nWhen Enabled, Capture latched the PWM-counter and saved to CRLR (Rising latch) and CFLR (Falling latch).\nWhen Disabled, Capture does not update CRLR and CFLR, and disable PWM group channel 1 Interrupt.</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Capture function on PWM group channel 1 Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Capture function on PWM group channel 1 Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CAPIF1</name>
              <description>Channel 1 Capture Interrupt Indication Flag\nWrite 1 to clear this bit to 0.</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CRLRI1</name>
              <description>CRLR1 Latched Indicator Bit\nWhen PWM group input channel 1 has a rising transition, CRLR1 was latched with the value of PWM down-counter and this bit is set by hardware.\nSoftware can write 0 to clear this bit to 0 if BCn bit is 0, and can write 1 to clear this bit to0 if BCn bit is 1.</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CFLRI1</name>
              <description>CFLR1 Latched Indicator Bit\nWhen PWM group input channel 1 has a falling transition, CFLR1 was latched with the value of PWM down-counter and this bit is set by hardware.\nSoftware can write 0 to clear this bit to 0 if BCn bit is 0, and can write 1 to clear this bit to 0 if BCn bit is 1.</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CCR2</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CCR2</displayName>
          <description>PWM Capture Control Register 2</description>
          <addressOffset>0x54</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>INV2</name>
              <description>Channel 2 Inverter Enable Bit\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Inverter Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Inverter Enabled. Reverse the input signal from GPIO before fed to Capture timer</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CRL_IE2</name>
              <description>Channel 2 Rising Latch Interrupt Enable Bit\nWhen Enabled, if Capture detects PWM group channel 2 has rising transition, Capture will issue an Interrupt.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Rising latch interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Rising latch interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CFL_IE2</name>
              <description>Channel 2 Falling Latch Interrupt Enable Bit\nWhen Enabled, if Capture detects PWM group channel 2 has falling transition, Capture will issue an Interrupt.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Falling latch interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Falling latch interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CAPCH2EN</name>
              <description>Channel 2 Capture Function Enable Bit\nWhen Enabled, Capture latched the PWM-counter value and saved to CRLR (Rising latch) and CFLR (Falling latch).\nWhen Disabled, Capture does not update CRLR and CFLR, and disable PWM group channel 2 Interrupt.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Capture function on PWM group channel 2 Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Capture function on PWM group channel 2 Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CAPIF2</name>
              <description>Channel 2 Capture Interrupt Indication Flag\nWrite 1 to clear this bit to 0</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CRLRI2</name>
              <description>CRLR2 Latched Indicator\nWhen PWM group input channel 2 has a rising transition, CRLR2 was latched with the value of PWM down-counter and this bit is set by hardware.\nSoftware can write 0 to clear this bit to 0 if the BCn bit is 0, and can write 1 to clear this bit to 0 if the BCn bit is 1.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CFLRI2</name>
              <description>CFLR2 Latched Indicator\nWhen PWM group input channel 2 has a falling transition, CFLR2 was latched with the value of PWM down-counter and this bit is set by hardware.\nSoftware can write 0 to clear this bit to 0 if BCn bit is 0, and can write 1 to clear this bit to 0 if the BCn bit is 1.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>INV3</name>
              <description>Channel 3 Inverter Enable Bit\n</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Inverter Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Inverter Enabled. Reverse the input signal from GPIO before fed to Capture timer</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CRL_IE3</name>
              <description>Channel 3 Rising Latch Interrupt Enable Bit\nWhen Enabled, if Capture detects PWM group channel 3 has rising transition, Capture will issue an Interrupt.</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Rising latch interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Rising latch interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CFL_IE3</name>
              <description>Channel 3 Falling Latch Interrupt Enable Bit\nWhen Enabled, if Capture detects PWM group channel 3 has falling transition, Capture will issue an Interrupt.</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Falling latch interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Falling latch interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CAPCH3EN</name>
              <description>Channel 3 Capture Function Enable Bit\nWhen Enabled, Capture latched the PWM-counter and saved to CRLR (Rising latch) and CFLR (Falling latch).\nWhen Disabled, Capture does not update CRLR and CFLR, and disable PWM group channel 3 Interrupt.</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Capture function on PWM group channel 3 Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Capture function on PWM group channel 3 Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CAPIF3</name>
              <description>Channel 3 Capture Interrupt Indication Flag\nWrite 1 to clear this bit to 0</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CRLRI3</name>
              <description>CRLR3 Latched Indicator\nWhen PWM group input channel 3 has a rising transition, CRLR3 was latched with the value of PWM down-counter and this bit is set by hardware.\nSoftware can write 0 to clear this bit to 0 if the BCn bit is 0, and can write 1 to clear this bit to 0 if the BCn bit is 1.</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CFLRI3</name>
              <description>CFLR3 Latched Indicator\nWhen PWM group input channel 3 has a falling transition, CFLR3 was latched with the value of PWM down-counter and this bit is set by hardware.\nSoftware can write 0 to clear this bit to 0 if the BCn bit is 0, and can write 1 to clear this bit to 0 if the BCn bit is 1.</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CRLR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CRLR0</displayName>
          <description>PWM Capture Rising Latch Register (Channel 0)</description>
          <addressOffset>0x58</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CRLRx</name>
              <description>Capture Rising Latch Register\nLatch the PWM counter when Channel 0/1/2/3 has rising transition.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CFLR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CFLR0</displayName>
          <description>PWM Capture Falling Latch Register (Channel 0)</description>
          <addressOffset>0x5C</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CFLRx</name>
              <description>Capture Falling Latch Register\nLatch the PWM counter when Channel 0/1/2/3 has Falling transition.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="CRLR0">
          <name>CRLR1</name>
          <displayName>CRLR1</displayName>
          <description>PWM Capture Rising Latch Register (Channel 1)</description>
          <addressOffset>0x60</addressOffset>
       </register>
       <register derivedFrom="CFLR0">
          <name>CFLR1</name>
          <displayName>CFLR1</displayName>
          <description>PWM Capture Falling Latch Register (Channel 1)</description>
          <addressOffset>0x64</addressOffset>
       </register>
       <register derivedFrom="CRLR0">
          <name>CRLR2</name>
          <displayName>CRLR2</displayName>
          <description>PWM Capture Rising Latch Register (Channel 2)</description>
          <addressOffset>0x68</addressOffset>
       </register>
       <register derivedFrom="CFLR0">
          <name>CFLR2</name>
          <displayName>CFLR2</displayName>
          <description>PWM Capture Falling Latch Register (Channel 2)</description>
          <addressOffset>0x6C</addressOffset>
       </register>
       <register derivedFrom="CRLR0">
          <name>CRLR3</name>
          <displayName>CRLR3</displayName>
          <description>PWM Capture Rising Latch Register (Channel 3)</description>
          <addressOffset>0x70</addressOffset>
       </register>
       <register derivedFrom="CFLR0">
          <name>CFLR3</name>
          <displayName>CFLR3</displayName>
          <description>PWM Capture Falling Latch Register (Channel 3)</description>
          <addressOffset>0x74</addressOffset>
       </register>
       <register>
          <name>CAPENR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CAPENR</displayName>
          <description>PWM Capture Input 0~3 Enable Register</description>
          <addressOffset>0x78</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CINEN0</name>
              <description>Channel 0 Capture Input Enable Bit\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM Channel 0 capture input path Disabled. The input of PWM channel 0 capture function is always regarded as 0</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PWM Channel 0 capture input path Enabled. The input of PWM channel 0 capture function comes from correlative multifunction pin if GPIO multi-function is set as PWM0</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CINEN1</name>
              <description>Channel 1 Capture Input Enable Bit\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM Channel 1 capture input path Disabled. The input of PWM channel 1 capture function is always regarded as 0</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PWM Channel 1 capture input path Enabled. The input of PWM channel 1 capture function comes from correlative multifunction pin if GPIO multi-function is set as PWM1</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CINEN2</name>
              <description>Channel 2 Capture Input Enable Bit\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM Channel 2 capture input path Disabled. The input of PWM channel 2 capture function is always regarded as 0</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PWM Channel 2 capture input path Enabled. The input of PWM channel 2 capture function comes from correlative multifunction pin if GPIO multi-function is set as PWM2</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CINEN3</name>
              <description>Channel 3 Capture Input Enable Bit\n</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM Channel 3 capture input path Disabled. The input of PWM channel 3 capture function is always regarded as 0</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PWM Channel 3 capture input path Enabled. The input of PWM channel 3 capture function comes from correlative multifunction pin if GPIO multi-function is set as PWM3</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>POE</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>POE</displayName>
          <description>PWM Output Enable for Channel 0~3</description>
          <addressOffset>0x7C</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>POE0</name>
              <description>Channel 0 Output Enable Bit\nNote: The corresponding GPIO pin must also be switched to PWM function</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM channel 0 output to pin Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PWM channel 0 output to pin Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>POE1</name>
              <description>Channel 1 Output Enable Bit\nNote: The corresponding GPIO pin must also be switched to PWM function</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM channel 1 output to pin Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PWM channel 1 output to pin Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>POE2</name>
              <description>Channel 2 Output Enable Bit\nNote: The corresponding GPIO pin must also be switched to PWM function</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM channel 2 output to pin Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PWM channel 2 output to pin Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>POE3</name>
              <description>Channel 3 Output Enable Bit\nNote: The corresponding GPIO pin must also be switched to PWM function</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM channel 3 output to pin Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PWM channel 3 output to pin Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>TCON</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>TCON</displayName>
          <description>PWM Trigger Control for Channel 0~3</description>
          <addressOffset>0x80</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PWM0TEN</name>
              <description>Channel 0 Center-Aligned Trigger Enable Bit\nPWM can trigger ADC to start conversion when PWM counter up count to CNR if this bit is set to 1.\nNote: This function is only supported when PWM operating at Center-aligned type.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM channel 0 trigger ADC function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PWM channel 0 trigger ADC function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PWM1TEN</name>
              <description>Channel 1 Center-Aligned Trigger Enable Bit\nPWM can trigger ADC to start conversion when PWM counter up count to CNR if this bit is set to 1.\nNote: This function is only supported when PWM operating at Center-aligned type.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM channel 1 trigger ADC function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PWM channel 1 trigger ADC function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PWM2TEN</name>
              <description>Channel 2 Center-Aligned Trigger Enable Bit\nPWM can trigger ADC to start conversion when PWM counter up count to CNR if this bit is set to 1.\nNote: This function is only supported when PWM operating at Center-aligned type.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM channel 2 trigger ADC function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PWM channel 2 trigger ADC function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PWM3TEN</name>
              <description>Channel 3 Center-Aligned Trigger Enable Bit\nPWM can trigger ADC to start conversion when PWM counter up count to CNR if this bit is set to 1.\nNote: This function is only supported when PWM operating at Center-aligned type.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM channel 3 trigger ADC function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PWM channel 3 trigger ADC function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>TSTATUS</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>TSTATUS</displayName>
          <description>PWM Trigger Status Register</description>
          <addressOffset>0x84</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PWM0TF</name>
              <description>Channel 0 Center-Aligned Trigger Flag\nFor Center-aligned Operating mode, this bit is set to 1 by hardware when PWM counter up counts to CNR if PWM0TEN bit is set to 1. After this bit is set to 1, ADC will start conversion if ADC triggered source is selected by PWM.\nSoftware can write 1 to clear this bit.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PWM1TF</name>
              <description>Channel 1 Center-Aligned Trigger Flag\nFor Center-aligned Operating mode, this bit is set to 1 by hardware when PWM counter up count to CNR if PWM1TEN bit is set to 1. After this bit is set to 1, ADC will start conversion if ADC triggered source is selected by PWM.\nSoftware can write 1 to clear this bit.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PWM2TF</name>
              <description>Channel 2 Center-Aligned Trigger Flag\nFor Center-aligned Operating mode, this bit is set to 1 by hardware when PWM counter up count to CNR if PWM2TEN bit is set to 1. After this bit is set to 1, ADC will start conversion if ADC triggered source is selected by PWM.\nSoftware can write 1 to clear this bit.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PWM3TF</name>
              <description>Channel 3 Center-Aligned Trigger Flag\nFor Center-aligned Operating mode, this bit is set to 1 by hardware when PWM counter up count to CNR if PWM3TEN bit is set to 1. After this bit is set to 1, ADC will start conversion if ADC triggered source is selected by PWM.\nSoftware can write 1 to clear this bit.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SYNCBUSY0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SYNCBUSY0</displayName>
          <description>PWM0 Synchronous Busy Status Register</description>
          <addressOffset>0x88</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>S_BUSY</name>
              <description>PWM Synchronous Busy\nWhen software writes CNR0/CMR0/PPR or switches PWM0 operation mode (PCR[3]), PWM will have a busy time to update these values completely because PWM clock may be different from system clock domain. Software needs to check this busy status before writing CNR0/CMR0/PPR or switching PWM0 operation mode (PCR[3]) to make sure previous setting has been updated completely.\nThis bit will be set when software writes CNR0/CMR0/PPR or switches PWM0 operation mode (PCR[3]) and will be cleared by hardware automatically when PWM update these value completely.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SYNCBUSY1</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SYNCBUSY1</displayName>
          <description>PWM1 Synchronous Busy Status Register</description>
          <addressOffset>0x8C</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>S_BUSY</name>
              <description>PWM Synchronous Busy\nWhen Software writes CNR1/CMR1/PPR or switches PWM1 operation mode (PCR[11]), PWM will have a busy time to update these values completely because PWM clock may be different from system clock domain. Software needs to check this busy status before writing CNR1/CMR1/PPR or switching PWM1 operation mode (PCR[11]) to make sure previous setting has been updated completely.\nThis bit will be set when software writes CNR1/CMR1/PPR or switches PWM1 operation mode (PCR[11]) and will be cleared by hardware automatically when PWM update these value completely.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SYNCBUSY2</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SYNCBUSY2</displayName>
          <description>PWM2 Synchronous Busy Status Register</description>
          <addressOffset>0x90</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>S_BUSY</name>
              <description>PWM Synchronous Busy\nWhen Software writes CNR2/CMR2/PPR or switch PWM2 operation mode (PCR[19]), PWM will have a busy time to update these values completely because PWM clock may be different from system clock domain. Software needs to check this busy status before writing CNR2/CMR2/PPR or switching PWM2 operation mode (PCR[19]) to make sure previous setting has been updated completely.\nThis bit will be set when software writes CNR2/CMR2/PPR or switch PWM2 operation mode (PCR[19]) and will be cleared by hardware automatically when PWM update these value completely.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SYNCBUSY3</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SYNCBUSY3</displayName>
          <description>PWM3 Synchronous Busy Status Register</description>
          <addressOffset>0x94</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>S_BUSY</name>
              <description>PWM Synchronous Busy\nWhen Software writes CNR3/CMR3/PPR or switch PWM3 operation mode (PCR[27]), PWM will have a busy time to update these values completely because PWM clock may be different from system clock domain. Software need to check this busy status before writing CNR3/CMR3/PPR or switching PWM3 operation mode (PCR[27]) to make sure previous setting has been updated completely.\nThis bit will be set when Software writes CNR3/CMR3/PPR or switch PWM3 operation mode (PCR[27]) and will be cleared by hardware automatically when PWM update these value completely.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>WDT</name>
      <description>WDT Register Map</description>
      <groupName>WDT</groupName>
      <baseAddress>0x40004000</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x0</offset>
        <size>0x8</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>WTCR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>WTCR</displayName>
          <description>Watchdog Timer Control Register</description>
          <addressOffset>0x0</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000700</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WTR</name>
              <description>Reset Watchdog Timer Up Counter (Write Protect)\nNote: This bit will be automatically cleared by hardware.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reset the internal 18-bit WDT up counter value</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>WTRE</name>
              <description>Watchdog Timer Reset Enable Bit (Write Protect)\nSetting this bit will enable the WDT time-out reset function if the WDT up counter value has not been cleared after the specific WDT reset delay period expires.\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>WDT time-out reset function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>WDT time-out reset function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>WTRF</name>
              <description>Watchdog Timer Time-Out Reset Flag\nThis bit indicates the system has been reset by WDT time-out reset or not.\nNote: This bit is cleared by writing 1 to it.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>WDT time-out reset did not occur</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>WDT time-out reset occurred</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>WTIF</name>
              <description>Watchdog Timer Time-Out Interrupt Flag\nThis bit will set to 1 while WDT up counter value reaches the selected WDT time-out interval.\nNote: This bit is cleared by writing 1 to it.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>WDT time-out interrupt did not occur</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>WDT time-out interrupt occurred</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>WTWKE</name>
              <description>Watchdog Timer Time-Out Wake-Up Function Control (Write Protect)\nIf this bit is set to 1, while WTIF is generated to 1 and WTIE enabled, the WDT time-out interrupt signal will generate a wake-up trigger event to chip.\nNote: Chip can be woken-up by WDT time-out interrupt signal generated only if WDT   clock source is selected to 10 kHz oscillator.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Wake-up trigger event Disabled if WDT time-out interrupt signal generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Wake-up trigger event Enabled if WDT time-out interrupt signal generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>WTWKF</name>
              <description>Watchdog Timer Time-Out Wake-Up Flag\nThis bit indicates the interrupt wake-up flag status of WDT.\nNote: This bit is cleared by writing 1 to it.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>WDT does not cause chip wake-up</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Chip wake-up from Idle or Power-down mode if WDT time-out interrupt signal generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>WTIE</name>
              <description>Watchdog Timer Time-Out Interrupt Enable Bit (Write Protect)\nIf this bit is enabled, the WDT time-out interrupt signal is generated and inform to CPU.\n</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>WDT time-out interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>WDT time-out interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>WTE</name>
              <description>Watchdog Timer Enable Bit (Write Protect)\nNote: If CWDTEN (CONFIG0[31] Watchdog Enable) bit is set to 0, this bit is forced as 1 and user cannot change this bit to 0.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>WDT Disabled. (This action will reset the internal up counter value.)</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>WDT Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>WTIS</name>
              <description>Watchdog Timer Time-Out Interval Selection (Write Protect)\nThese three bits select the time-out interval period for the WDT.\n</description>
              <bitOffset>8</bitOffset>
              <bitWidth>3</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>24 *TWDT</description>
                    <value>#000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>26 * TWDT</description>
                    <value>#001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>28 * TWDT</description>
                    <value>#010</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>210 * TWDT</description>
                    <value>#011</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>4</name>
                    <description>212 * TWDT</description>
                    <value>#100</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>5</name>
                    <description>214 * TWDT</description>
                    <value>#101</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>6</name>
                    <description>216 * TWDT</description>
                    <value>#110</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>7</name>
                    <description>218 * TWDT</description>
                    <value>#111</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DBGACK_WDT</name>
              <description>ICE Debug Mode Acknowledge Disable Bit (Write Protect)\nWDT up counter will keep going no matter CPU is held by ICE or not.</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>ICE debug mode acknowledgement effects WDT counting</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>ICE debug mode acknowledgement Disabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>WTCRALT</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>WTCRALT</displayName>
          <description>Watchdog Timer Alternative Control Register</description>
          <addressOffset>0x4</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WTRDSEL</name>
              <description>Watchdog Timer Reset Delay Selection (Write Protect)\nWhen WDT time-out happened, user has a time named WDT Reset Delay Period to clear WDT counter to prevent WDT time-out reset happened. User can select a suitable value of WDT Reset Delay Period for different WDT time-out period.\nThese bits are protected bit. It means programming this bit needs to write "59h", "16h", "88h" to address 0x5000_0100 to disable register protection. Reference the register REGWRPROT at address GCR_BA+0x100.\nNote: This register will be reset to 0 if WDT time-out reset happened.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Watchdog Timer Reset Delay Period is 1026 * WDT_CLK</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Watchdog Timer Reset Delay Period is 130 * WDT_CLK</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Watchdog Timer Reset Delay Period is 18 * WDT_CLK</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Watchdog Timer Reset Delay Period is 3 * WDT_CLK</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>WWDT</name>
      <description>WWDT Register Map</description>
      <groupName>WWDT</groupName>
      <baseAddress>0x40004100</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x0</offset>
        <size>0x10</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>WWDTRLD</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>WWDTRLD</displayName>
          <description>Window Watchdog Timer Reload Counter Register</description>
          <addressOffset>0x0</addressOffset>
          <access>write-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WWDTRLD</name>
              <description>WWDT Reload Counter Register\nWriting 0x00005AA5 to this register will reload the WWDT counter value to 0x3F. \nNote: User can only write WWDTRLD to reload WWDT counter value when current WWDT counter value between 0 and WINCMP. If user writes WWDTRLD when current WWDT counter value is larger than WINCMP, WWDT reset signal will generate immediately.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>WWDTCR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>WWDTCR</displayName>
          <description>Window Watchdog Timer Control Register</description>
          <addressOffset>0x4</addressOffset>
          <access>read-write</access>
          <resetValue>0x003F0800</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WWDTEN</name>
              <description>WWDT Enable Bit\nSet this bit to enable WWDT counter counting\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>WWDT counter is stopped</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>WWDT counter is starting counting</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>WWDTIE</name>
              <description>WWDT Interrupt Enable Bit\nIf this bit is enabled, the WWDT counter compare match interrupt signal is generated and inform to CPU.\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>WWDT counter compare match interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>WWDT counter compare match interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PERIODSEL</name>
              <description>WWDT Counter Prescale Period Selection\n</description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Pre-scale is 1; Max time-out period is 1 * 64 * TWWDT</description>
                    <value>#0000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Pre-scale is 2; Max time-out period is 2 * 64 * TWWDT</description>
                    <value>#0001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Pre-scale is 4; Max time-out period is 4 * 64 * TWWDT</description>
                    <value>#0010</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Pre-scale is 8; Max time-out period is 8 * 64 * TWWDT</description>
                    <value>#0011</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>4</name>
                    <description>Pre-scale is 16; Max time-out period is 16 * 64 * TWWDT</description>
                    <value>#0100</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>5</name>
                    <description>Pre-scale is 32; Max time-out period is 32 * 64 * TWWDT</description>
                    <value>#0101</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>6</name>
                    <description>Pre-scale is 64; Max time-out period is 64 * 64 * TWWDT</description>
                    <value>#0110</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>7</name>
                    <description>Pre-scale is 128; Max time-out period is 128 * 64 * TWWDT</description>
                    <value>#0111</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>8</name>
                    <description>Pre-scale is 192; Max time-out period is 192 * 64 * TWWDT</description>
                    <value>#1000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>9</name>
                    <description>Pre-scale is 256; Max time-out period is 256 * 64 * TWWDT</description>
                    <value>#1001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>10</name>
                    <description>Pre-scale is 384; Max time-out period is 384 * 64 * TWWDT</description>
                    <value>#1010</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>11</name>
                    <description>Pre-scale is 512; Max time-out period is 512 * 64 * TWWDT</description>
                    <value>#1011</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>12</name>
                    <description>Pre-scale is 768; Max time-out period is 768 * 64 * TWWDT</description>
                    <value>#1100</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>13</name>
                    <description>Pre-scale is 1024; Max time-out period is 1024 * 64 * TWWDT</description>
                    <value>#1101</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>14</name>
                    <description>Pre-scale is 1536; Max time-out period is 1536 * 64 * TWWDT</description>
                    <value>#1110</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>15</name>
                    <description>Pre-scale is 2048; Max time-out period is 2048 * 64 * TWWDT</description>
                    <value>#1111</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>WINCMP</name>
              <description>WWDT Window Compare Register\nSet this register to adjust the valid reload window. \nNote: User can only write WWDTRLD to reload WWDT counter value when current WWDT counter value between 0 and WINCMP. If user writes WWDTRLD when current WWDT counter value larger than WINCMP, WWDT reset signal will generate immediately.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DBGACK_WWDT</name>
              <description>ICE Debug Mode Acknowledge Disable Bit\nWWDT down counter will keep going no matter CPU is held by ICE or not.</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>ICE debug mode acknowledgement effects WWDT counting</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>ICE debug mode acknowledgement Disabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>WWDTSR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>WWDTSR</displayName>
          <description>Window Watchdog Timer Status Register</description>
          <addressOffset>0x8</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WWDTIF</name>
              <description>WWDT Compare Match Interrupt Flag\nThis bit indicates the interrupt flag status of WWDT while WWDT counter value matches WINCMP value.\nNote: This bit is cleared by writing 1 to it.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>WWDT counter value matches WINCMP value</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>WWDTRF</name>
              <description>WWDT Time-Out Reset Flag\nThis bit indicates the system has been reset by WWDT time-out reset or not.\nNote: This bit is cleared by writing 1 to it.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>WWDT time-out reset did not occur</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>WWDT time-out reset occurred</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>WWDTCVR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>WWDTCVR</displayName>
          <description>Window Watchdog Timer Counter Value Register</description>
          <addressOffset>0xC</addressOffset>
          <access>read-only</access>
          <resetValue>0x0000003F</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WWDTCVAL</name>
              <description>WWDT Counter Value\nWWDTCVAL will be updated continuously to monitor 6-bit down counter value.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>RTC</name>
      <description>RTC Register Map</description>
      <groupName>RTC</groupName>
      <baseAddress>0x40008000</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x0</offset>
        <size>0x34</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x3C</offset>
        <size>0x54</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>INIR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>INIR</displayName>
          <description>RTC Initiation Register</description>
          <addressOffset>0x0</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>INIR_Active</name>
              <description>RTC Active Status (Read Only)\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RTC is at reset state</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RTC is at normal active state</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>INIR</name>
              <description>RTC Initiation\nWhen RTC block is powered on, RTC is at reset state. User has to write a number (0xa5eb1357) to INIR to make RTC leaving reset state. Once the INIR is written as 0xa5eb1357, the RTC will be in un-reset state permanently.\nThe INIR is a write-only field and read value will be always 0.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>31</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>AER</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>AER</displayName>
          <description>RTC Access Enable Register</description>
          <addressOffset>0x4</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>AER</name>
              <description>RTC Register Access Enable Password (Write Only)\nWriting 0xA965 to this register will enable RTC access and keep 1024 RTC clocks.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>ENF</name>
              <description>RTC Register Access Enable Flag (Read Only)\nNote: This bit will be set after AER[15:0] is load a 0xA965, and will be cleared automatically after 1024 RTC clocks.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RTC register read/write access Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RTC register read/write access Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>FCR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>FCR</displayName>
          <description>RTC Frequency Compensation Register</description>
          <addressOffset>0x8</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000700</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>FRACTION</name>
              <description>Fraction Part\nNote: Digit in FCR must be expressed as hexadecimal number..</description>
              <bitOffset>0</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>INTEGER</name>
              <description>Integer Part\nPlease refer to 5.14.5.4 .</description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>TLR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>TLR</displayName>
          <description>Time Loading Register</description>
          <addressOffset>0xC</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>_1SEC</name>
              <description>1-Sec Time Digit (0~9)</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>_10SEC</name>
              <description>10-Sec Time Digit (0~5)</description>
              <bitOffset>4</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>_1MIN</name>
              <description>1-Min Time Digit (0~9)</description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>_10MIN</name>
              <description>10-Min Time Digit (0~5)</description>
              <bitOffset>12</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>_1HR</name>
              <description>1-Hour Time Digit (0~9)</description>
              <bitOffset>16</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>_10HR</name>
              <description>10-Hour Time Digit (0~2)</description>
              <bitOffset>20</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CLR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CLR</displayName>
          <description>Calendar Loading Register</description>
          <addressOffset>0x10</addressOffset>
          <access>read-write</access>
          <resetValue>0x00050101</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>_1DAY</name>
              <description>1-Day Calendar Digit (0~9)</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>_10DAY</name>
              <description>10-Day Calendar Digit (0~3)</description>
              <bitOffset>4</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>_1MON</name>
              <description>1-Month Calendar Digit (0~9)</description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>_10MON</name>
              <description>10-Month Calendar Digit (0~1)</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>_1YEAR</name>
              <description>1-Year Calendar Digit (0~9)</description>
              <bitOffset>16</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>_10YEAR</name>
              <description>10-Year Calendar Digit (0~9)</description>
              <bitOffset>20</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>TSSR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>TSSR</displayName>
          <description>Time Scale Selection Register</description>
          <addressOffset>0x14</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000001</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>_24H_12H</name>
              <description>24-Hour / 12-Hour Time Scale Selection\nIt indicates that RTC TLR and TAR counter are in 24-hour time scale or 12-hour time scale. Please refer to 5.14.5.6 .\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>24-hour time scale selected</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>24-hour time scale selected</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>DWR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>DWR</displayName>
          <description>Day of the Week Register</description>
          <addressOffset>0x18</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000006</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DWR</name>
              <description>Day Of The Week Register \n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Sunday</description>
                    <value>#000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Monday</description>
                    <value>#001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Tuesday</description>
                    <value>#010</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Wednesday</description>
                    <value>#011</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>4</name>
                    <description>Thursday</description>
                    <value>#100</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>5</name>
                    <description>Friday</description>
                    <value>#101</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>6</name>
                    <description>Saturday</description>
                    <value>#110</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>7</name>
                    <description>Reserved</description>
                    <value>#111</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>TAR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>TAR</displayName>
          <description>Time Alarm Register</description>
          <addressOffset>0x1C</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>_1SEC</name>
              <description>1-Sec Time Digit of Alarm Setting (0~9)</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>_10SEC</name>
              <description>10-Sec Time Digit of Alarm Setting (0~5)</description>
              <bitOffset>4</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>_1MIN</name>
              <description>1-Min Time Digit of Alarm Setting (0~9)</description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>_10MIN</name>
              <description>10-Min Time Digit of Alarm Setting (0~5)</description>
              <bitOffset>12</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>_1HR</name>
              <description>1-Hour Time Digit of Alarm Setting (0~9)</description>
              <bitOffset>16</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>_10HR</name>
              <description>10-Hour Time Digit of Alarm Setting (0~2)</description>
              <bitOffset>20</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CAR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CAR</displayName>
          <description>Calendar Alarm Register</description>
          <addressOffset>0x20</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>_1DAY</name>
              <description>1-Day Calendar Digit of Alarm Setting (0~9)</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>_10DAY</name>
              <description>10-Day Calendar Digit of Alarm Setting (0~3)</description>
              <bitOffset>4</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>_1MON</name>
              <description>1-Month Calendar Digit of Alarm Setting (0~9)</description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>_10MON</name>
              <description>10-Month Calendar Digit of Alarm Setting (0~1)</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>_1YEAR</name>
              <description>1-Year Calendar Digit of Alarm Setting (0~9)</description>
              <bitOffset>16</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>_10YEAR</name>
              <description>10-Year Calendar Digit of Alarm Setting (0~9)</description>
              <bitOffset>20</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>LIR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>LIR</displayName>
          <description>Leap Year Indicator Register</description>
          <addressOffset>0x24</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>LIR</name>
              <description>Leap Year Indication Register (Read Only)\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>This year is not a leap year</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>This year is a leap year</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>RIER</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>RIER</displayName>
          <description>RTC Interrupt Enable Register</description>
          <addressOffset>0x28</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>AIER</name>
              <description>Alarm Interrupt Enable Bit\nThis bit is used to enable/disable RTC Alarm Interrupt, and generate an interrupt signal if AIF (RIIR[0] RTC Alarm Interrupt Flag) is set to 1.\nNote: This bit will also trigger a wake-up event while system runs in Idle/Power-down mode and RTC Alarm Interrupt signal generated.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RTC Alarm Interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RTC Alarm Interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TIER</name>
              <description>Time Tick Interrupt Enable Bit\nThis bit is used to enable/disable RTC Time Tick Interrupt, and generate an interrupt signal if TIF (RIIR[1] RTC Time Tick Interrupt Flag) is set to 1.\nNote: This bit will also trigger a wake-up event while system runs in Idle/Power-down mode and RTC Time Tick Interrupt signal generated.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RTC Time Tick Interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RTC Time Tick Interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>RIIR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>RIIR</displayName>
          <description>RTC Interrupt Indicator Register</description>
          <addressOffset>0x2C</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>AIF</name>
              <description>RTC Alarm Interrupt Flag\nWhen RTC time counters TLR and CLR match the alarm setting time registers TAR and CAR, this bit will be set to 1 and an interrupt will be generated if RTC Alarm Interrupt enabled AIER (RIER[0]) is set to 1. Chip will be wake-up if RTC Alarm Interrupt is enabled when chip is at Power-down mode.\nNote: Write 1 to clear this bit.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Alarm condition is not matched</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Alarm condition is matched</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TIF</name>
              <description>RTC Time Tick Interrupt Flag\nWhen RTC time tick happened, this bit will be set to 1 and an interrupt will be generated if RTC Tick Interrupt enabled TIER (RIER[1]) is set to 1. Chip will also be wake-up if RTC Tick Interrupt is enabled and this bit is set to 1 when chip is running at Power-down mode.\nNote: Write 1 to clear this bit.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Tick condition does not occur</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Tick condition occur</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>TTR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>TTR</displayName>
          <description>RTC Time Tick Register</description>
          <addressOffset>0x30</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TTR</name>
              <description>Time Tick Register\nThese bits are used to select RTC time tick period for Periodic Time Tick Interrupt request. \nNote: This register can be read back after the RTC register access enable bit ENF (AER[16]) is active.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Time tick is 1 second</description>
                    <value>#000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Time tick is 1/2 second</description>
                    <value>#001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Time tick is 1/4 second</description>
                    <value>#010</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Time tick is 1/8 second</description>
                    <value>#011</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>4</name>
                    <description>Time tick is 1/16 second</description>
                    <value>#100</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>5</name>
                    <description>Time tick is 1/32 second</description>
                    <value>#101</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>6</name>
                    <description>Time tick is 1/64 second</description>
                    <value>#110</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>7</name>
                    <description>Time tick is 1/28 second</description>
                    <value>#111</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SPRCTL</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SPRCTL</displayName>
          <description>RTC Spare Functional Control Register</description>
          <addressOffset>0x3C</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000080</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SPREN</name>
              <description>SPR Register Enable Bit\nNote: When spare register is disabled, RTC SPR0 ~ SPR19 cannot be accessed.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Spare register is Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Spare register is Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SPRRDY</name>
              <description>SPR Register Ready\nThis bit indicates if the registers SPRCTL, SPR0 ~ SPR19 are ready to be accessed.\nAfter user writing registers SPRCTL, SPR0 ~ SPR19, read this bit to check if these registers are updated done is necessary.\nNote: This bit is read only and any write to it won't take any effect.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>SPRCTL, SPR0 ~ SPR19 updating is in progress</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>SPRCTL, SPR0 ~ SPR19 are updated done and ready to be accessed</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SPR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SPR0</displayName>
          <description>RTC Spare Register 0</description>
          <addressOffset>0x40</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
          </fields>
       </register>
       <register derivedFrom="SPR0">
          <name>SPR1</name>
          <displayName>SPR1</displayName>
          <description>RTC Spare Register 1</description>
          <addressOffset>0x44</addressOffset>
       </register>
       <register derivedFrom="SPR0">
          <name>SPR2</name>
          <displayName>SPR2</displayName>
          <description>RTC Spare Register 2</description>
          <addressOffset>0x48</addressOffset>
       </register>
       <register derivedFrom="SPR0">
          <name>SPR3</name>
          <displayName>SPR3</displayName>
          <description>RTC Spare Register 3</description>
          <addressOffset>0x4C</addressOffset>
       </register>
       <register derivedFrom="SPR0">
          <name>SPR4</name>
          <displayName>SPR4</displayName>
          <description>RTC Spare Register 4</description>
          <addressOffset>0x50</addressOffset>
       </register>
       <register derivedFrom="SPR0">
          <name>SPR5</name>
          <displayName>SPR5</displayName>
          <description>RTC Spare Register 5</description>
          <addressOffset>0x54</addressOffset>
       </register>
       <register derivedFrom="SPR0">
          <name>SPR6</name>
          <displayName>SPR6</displayName>
          <description>RTC Spare Register 6</description>
          <addressOffset>0x58</addressOffset>
       </register>
       <register derivedFrom="SPR0">
          <name>SPR7</name>
          <displayName>SPR7</displayName>
          <description>RTC Spare Register 7</description>
          <addressOffset>0x5C</addressOffset>
       </register>
       <register derivedFrom="SPR0">
          <name>SPR8</name>
          <displayName>SPR8</displayName>
          <description>RTC Spare Register 8</description>
          <addressOffset>0x60</addressOffset>
       </register>
       <register derivedFrom="SPR0">
          <name>SPR9</name>
          <displayName>SPR9</displayName>
          <description>RTC Spare Register 9</description>
          <addressOffset>0x64</addressOffset>
       </register>
       <register derivedFrom="SPR0">
          <name>SPR10</name>
          <displayName>SPR10</displayName>
          <description>RTC Spare Register 10</description>
          <addressOffset>0x68</addressOffset>
       </register>
       <register derivedFrom="SPR0">
          <name>SPR11</name>
          <displayName>SPR11</displayName>
          <description>RTC Spare Register 11</description>
          <addressOffset>0x6C</addressOffset>
       </register>
       <register derivedFrom="SPR0">
          <name>SPR12</name>
          <displayName>SPR12</displayName>
          <description>RTC Spare Register 12</description>
          <addressOffset>0x70</addressOffset>
       </register>
       <register derivedFrom="SPR0">
          <name>SPR13</name>
          <displayName>SPR13</displayName>
          <description>RTC Spare Register 13</description>
          <addressOffset>0x74</addressOffset>
       </register>
       <register derivedFrom="SPR0">
          <name>SPR14</name>
          <displayName>SPR14</displayName>
          <description>RTC Spare Register 14</description>
          <addressOffset>0x78</addressOffset>
       </register>
       <register derivedFrom="SPR0">
          <name>SPR15</name>
          <displayName>SPR15</displayName>
          <description>RTC Spare Register 15</description>
          <addressOffset>0x7C</addressOffset>
       </register>
       <register derivedFrom="SPR0">
          <name>SPR16</name>
          <displayName>SPR16</displayName>
          <description>RTC Spare Register 16</description>
          <addressOffset>0x80</addressOffset>
       </register>
       <register derivedFrom="SPR0">
          <name>SPR17</name>
          <displayName>SPR17</displayName>
          <description>RTC Spare Register 17</description>
          <addressOffset>0x84</addressOffset>
       </register>
       <register derivedFrom="SPR0">
          <name>SPR18</name>
          <displayName>SPR18</displayName>
          <description>RTC Spare Register 18</description>
          <addressOffset>0x88</addressOffset>
       </register>
       <register derivedFrom="SPR0">
          <name>SPR19</name>
          <displayName>SPR19</displayName>
          <description>RTC Spare Register 19</description>
          <addressOffset>0x8C</addressOffset>
       </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>UART0</name>
      <description>UART Register Map</description>
      <groupName>UART</groupName>
      <baseAddress>0x40050000</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x0</offset>
        <size>0x3C</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>UA_RBR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UA_RBR</displayName>
          <description>UART Receive Buffer Register</description>
          <addressOffset>0x0</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>RBR</name>
              <description>Receive Buffer Register (Read Only)\nBy reading this register, the UART will return the 8-bit data received from RX pin (LSB first).</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UA_THR</name>
          <alternateRegister>UA_RBR</alternateRegister>
          <!-- the display name is an unrestricted string. -->
          <displayName>UA_THR</displayName>
          <description>UART Transmit Holding Register</description>
          <addressOffset>0x0</addressOffset>
          <access>write-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>THR</name>
              <description>Transmit Holding Register\nBy writing one byte to this register, the data byte will be stored in transmitter FIFO. The UART Controller will send out the data stored in transmitter FIFO top location through the TX pin.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UA_IER</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UA_IER</displayName>
          <description>UART Interrupt Enable Register</description>
          <addressOffset>0x4</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RDA_IEN</name>
              <description>Receive Data Available Interrupt Enable Bit\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RDA_INT Masked off</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RDA_INT Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>THRE_IEN</name>
              <description>Transmit Holding Register Empty Interrupt Enable Bit\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>THRE_INT Masked off</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>THRE_INT Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RLS_IEN</name>
              <description>Receive Line Status Interrupt Enable Bit\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RLS_INT Masked off</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RLS_INT Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>MODEM_IEN</name>
              <description>Modem Status Interrupt Enable Bit (Not Available In UART2 Channel)\n</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>MODEM_INT Masked off</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>MODEM_INT Enabled.</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TOUT_IEN</name>
              <description>RX Time-Out Interrupt Enable Bit\n</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>TOUT_INT Masked off</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>TOUT_INT Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BUF_ERR_IEN</name>
              <description>Buffer Error Interrupt Enable Bit\n</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>BUF_ERR_INT Masked off</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>BUF_ERR_INT Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>WAKE_EN</name>
              <description>UART Wake-Up Function Enable Bit (Not Available In UART2 Channel)\n</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>UART wake-up function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>UART wake-up function Enabled, when the chip is in Power-down mode, an external CTS change will wake-up chip from Power-down mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>LIN_IEN</name>
              <description>LIN Bus Interrupt Enable Bit\nNote: This field is used for LIN function mode.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Lin bus interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Lin bus interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TIME_OUT_EN</name>
              <description>Time-Out Counter Enable Bit\n</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Time-out counter Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Time-out counter Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>AUTO_RTS_EN</name>
              <description>RTS Auto Flow Control Enable Bit (Not Available In UART2 Channel)\nWhen RTS auto-flow is enabled, if the number of bytes in the RX FIFO equals the RTS_TRI_LEV (UA_FCR [19:16]), the UART will de-assert RTS signal.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RTS auto flow control Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RTS auto flow control Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>AUTO_CTS_EN</name>
              <description>CTS Auto Flow Control Enable Bit (Not Available In UART2 Channel)\nWhen CTS auto-flow is enabled, the UART will send data to external device when CTS input assert (UART will not send data to device until CTS is asserted).</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>CTS auto flow control Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>CTS auto flow control Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DMA_TX_EN</name>
              <description>TX DMA Enable Bit (Not Available In UART2 Channel)\nThis bit can enable or disable TX DMA service.\n</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>TX DMA Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>TX DMA Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DMA_RX_EN</name>
              <description>RX DMA Enable Bit (Not Available In UART2 Channel)\nThis bit can enable or disable RX DMA service.\n</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RX DMA Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RX DMA Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UA_FCR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UA_FCR</displayName>
          <description>UART FIFO Control Register</description>
          <addressOffset>0x8</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000101</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RFR</name>
              <description>RX Field Software Reset\nWhen RFR is set, all the byte in the receiver FIFO and RX internal state machine are cleared.\nNote: This bit will automatically clear at least 3 UART peripherial clock cycles.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reset the RX internal state machine and pointers</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TFR</name>
              <description>TX Field Software Reset\nWhen TFR is set, all the byte in the transmit FIFO and TX internal state machine are cleared.\nNote: This bit will automatically clear at least 3 UART peripherial clock cycles.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reset the TX internal state machine and pointers</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RFITL</name>
              <description>RX FIFO Interrupt (INT_RDA) Trigger Level\nWhen the number of bytes in the receive FIFO equals the RFITL, the RDA_IF will be set (if UA_IER [RDA_IEN] enabled, and an interrupt will be generated).\n</description>
              <bitOffset>4</bitOffset>
              <bitWidth>4</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RX FIFO Interrupt Trigger Level is 1 byte</description>
                    <value>#0000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RX FIFO Interrupt Trigger Level is 4 bytes</description>
                    <value>#0001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>RX FIFO Interrupt Trigger Level is 8 bytes</description>
                    <value>#0010</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>RX FIFO Interrupt Trigger Level is 14 bytes</description>
                    <value>#0011</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>4</name>
                    <description>RX FIFO Interrupt Trigger Level is 30/14 bytes (High Speed/Normal Speed)</description>
                    <value>#0100</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>5</name>
                    <description>RX FIFO Interrupt Trigger Level is 46/14 bytes (High Speed/Normal Speed)</description>
                    <value>#0101</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>6</name>
                    <description>RX FIFO Interrupt Trigger Level is 62/14 bytes (High Speed/Normal Speed)</description>
                    <value>#0110</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_DIS</name>
              <description>Receiver Disable Bit\nThe receiver is disabled or not (set 1 to disable receiver)\nNote: This field is used for RS-485 Normal Multi-drop mode. It should be programmed before UA_ALT_CSR [RS-485_NMM] is programmed.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Receiver Enabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Receiver Disabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RTS_TRI_LEV</name>
              <description>RTS Trigger Level For Auto-Flow Control Use (Not Available In UART2 Channel)\nNote: This field is used for RTS auto-flow control.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>4</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RTS Trigger Level is 1 byte</description>
                    <value>#0000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RTS Trigger Level is 4 bytes</description>
                    <value>#0001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>RTS Trigger Level is 8 bytes</description>
                    <value>#0010</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>RTS Trigger Level is 14 bytes</description>
                    <value>#0011</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>4</name>
                    <description>RTS Trigger Level is 30/14 bytes (High Speed/Normal Speed)</description>
                    <value>#0100</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>5</name>
                    <description>RTS Trigger Level is 46/14 bytes (High Speed/Normal Speed)</description>
                    <value>#0101</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>6</name>
                    <description>RTS Trigger Level is 62/14 bytes (High Speed/Normal Speed)</description>
                    <value>#0110</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UA_LCR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UA_LCR</displayName>
          <description>UART Line Control Register</description>
          <addressOffset>0xC</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WLS</name>
              <description>Word Length Selection\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Word length is 5-bit</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Word length is 6-bit</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Word length is 7-bit</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Word length is 8-bit</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>NSB</name>
              <description>Number Of "STOP Bit"\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>One " STOP bit" is generated in the transmitted data</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>When select 5-bit word length, 1.5 "STOP bit" is generated in the transmitted data. When select 6-,7- and 8-bti word length, 2 "STOP bit" is generated in the transmitted data</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PBE</name>
              <description>Parity Bit Enable Bit\n</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No parity bit</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Parity bit is generated on each outgoing character and is checked on each incoming data</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>EPE</name>
              <description>Even Parity Enable Bit\nThis bit has effect only when PBE (UA_LCR[3]) is set.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Odd number of logic 1's is transmitted and checked in each word</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Even number of logic 1's is transmitted and checked in each word</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SPE</name>
              <description>Stick Parity Enable Bit\n</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Stick parity Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>If PBE (UA_LCR[3]) and EBE (UA_LCR[4]) are logic 1, the parity bit is transmitted and checked as logic 0. If PBE (UA_LCR[3]) is 1 and EBE (UA_LCR[4]) is 0 then the parity bit is transmitted and checked as 1</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BCB</name>
              <description>Break Control Bit\nWhen this bit is set to logic 1, the serial data output (TX) is forced to the Spacing State (logic 0). This bit acts only on TX and has no effect on the transmitter logic.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UA_MCR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UA_MCR</displayName>
          <description>UART Modem Control Register</description>
          <addressOffset>0x10</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000200</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RTS</name>
              <description>RTS (Request-To-Send) Signal Control (Not Available In UART2 Channel)\nThis bit is direct control internal RTS signal active or not, and then drive the RTS pin output with LEV_RTS bit configuration.\nNote1: This RTS signal control bit is not effective when RTS auto-flow control is enabled in UART function mode.\nNote2: This RTS signal control bit is not effective when RS-485 auto direction mode (AUD) is enabled in RS-485 function mode.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RTS signal is active</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RTS signal is inactive</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>LEV_RTS</name>
              <description>RTS Pin Active Level (Not Available In UART2 Channel)\nThis bit defines the active level state of RTS pin output.\nNote1: Refer to Figure 662 and Figure 663 for UART function mode.\nNote2: Refer to Figure 673 And Figure 674for RS-485 function mode.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RTS pin output is high level active</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RTS pin output is low level active</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RTS_ST</name>
              <description>RTS Pin State (Read Only) (Not Available In UART2 Channel)\nThis bit mirror from RTS pin output of voltage logic status.\n</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RTS pin output is low level voltage logic state</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RTS pin output is high level voltage logic state</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UA_MSR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UA_MSR</displayName>
          <description>UART Modem Status Register</description>
          <addressOffset>0x14</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000110</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DCTSF</name>
              <description>Detect CTS State Change Flag (Read Only) (Not Available In UART2 Channel)\nThis bit is set whenever CTS input has change state, and it will generate Modem interrupt to CPU when MODEM_IEN (UA_IER [3]) is set to 1.\nNote: This bit is read only, but can be cleared by writing "1" to it.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>CTS input has not change state</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>CTS input has change state</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>CTS_ST</name>
              <description>CTS Pin Status (Read Only) (Not Available In UART2 Channel)\nThis bit mirror from CTS pin input of voltage logic status.\nNote: This bit echoes when UART Controller peripheral clock is enabled, and CTS multi-function port is selected</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>CTS pin input is low level voltage logic state</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>CTS pin input is high level voltage logic state</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>LEV_CTS</name>
              <description>CTS Pin Active Level\nThis bit defines the active level state of CTS pin input.\nNote: Refer to Figure 661 for more information</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>CTS pin input is high level active</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>CTS pin input is low level active</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UA_FSR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UA_FSR</displayName>
          <description>UART FIFO Status Register</description>
          <addressOffset>0x18</addressOffset>
          <access>read-write</access>
          <resetValue>0x10404000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RX_OVER_IF</name>
              <description>RX Overflow Error IF (Read Only)\nThis bit is set when RX FIFO overflow.\nIf the number of bytes of received data is greater than RX_FIFO (UA_RBR) size, 64/16/16 bytes of UART0/UART1/UART2, this bit will be set.\nNote: This bit is read only, but can be cleared by writing "1" to it.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RX FIFO is not overflow</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RX FIFO is overflow</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>RS485_ADD_DETF</name>
              <description>RS-485 Address Byte Detection Flag (Read Only) \nNote1: This field is used for RS-485 function mode and RS485_ADD_EN (UA_ALT_CSR[15]) is set to 1 to enable Address detection mode.\nNote2: This bit is read only, but can be cleared by writing '1' to it.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Receiver detects a data that is not an address bit (bit 9 ='1')</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Receiver detects a data that is an address bit (bit 9 ='1')</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>PEF</name>
              <description>Parity Error Flag (Read Only)\nThis bit is set to logic 1 whenever the received character does not have a valid "parity bit", and is reset whenever the CPU writes 1 to this bit.\nNote: This bit is read only, but can be cleared by writing "1" to it.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No parity error is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Parity error is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>FEF</name>
              <description>Framing Error Flag (Read Only)\nThis bit is set to logic 1 whenever the received character does not have a valid "stop bit" (that is, the stop bit following the last data bit or parity bit is detected as logic 0), and is reset whenever the CPU writes 1 to this bit.\nNote: This bit is read only, but can be cleared by writing "1" to it.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No framing error is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Framing error is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>BIF</name>
              <description>Break Interrupt Flag (Read Only)\nThis bit is set to logic 1 whenever the received data input(RX) is held in the "spacing state" (logic 0) for longer than a full word transmission time (that is, the total time of "start bit" + data bits + parity + stop bits) and is reset whenever the CPU writes 1 to this bit.\nNote: This bit is read only, but can be cleared by writing "1" to it.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No Break interrupt is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Break interrupt is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>RX_POINTER</name>
              <description>RX FIFO Pointer (Read Only)\nThis field indicates the RX FIFO Buffer Pointer. When UART receives one byte from external device, then RX_POINTER increases one. When one byte of RX FIFO is read by CPU, then RX_POINTER decreases one.\nThe Maximum value shown in RX_POINTER is 63/15/15 (UART0/UART1/UART2). When the using level of RX FIFO Buffer equal to 64/16/16, the RX_FULL bit is set to 1 and RX_POINTER will show 0. As one byte of RX FIFO is read by CPU, the RX_FULL bit is cleared to 0 and RX_POINTER will show 63/15/15 (UART0/UART1/UART2).</description>
              <bitOffset>8</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RX_EMPTY</name>
              <description>Receiver FIFO Empty (Read Only)\nThis bit initiate RX FIFO empty or not.\nNote: When the last byte of RX FIFO has been read by CPU, hardware sets this bit high. It will be cleared when UART receives any new data.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RX FIFO is not empty</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RX FIFO is empty</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>RX_FULL</name>
              <description>Receiver FIFO Full (Read Only)\nThis bit initiates RX FIFO is full or not.\nNote: This bit is set when the number of usage in RX FIFO Buffer is equal to 64/16/16(UART0/UART1/UART2), otherwise is cleared by hardware.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RX FIFO is not full</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RX FIFO is full</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>TX_POINTER</name>
              <description>TX FIFO Pointer (Read Only)\nThis field indicates the TX FIFO Buffer Pointer. When CPU writes one byte into UA_THR, then TX_POINTER increases one. When one byte of TX FIFO is transferred to Transmitter Shift Register, then TX_POINTER decreases one.\nThe Maximum value shown in TX_POINTER is 63/15/15 (UART0/UART1/UART2). When the using level of TX FIFO Buffer equal to 64/16/16, the TX_FULL bit is set to 1 and TX_POINTER will show 0. As one byte of TX FIFO is transferred to Transmitter Shift Register, the TX_FULL bit is cleared to 0 and TX_POINTER will show 63/15/15 (UART0/UART1/UART2).</description>
              <bitOffset>16</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TX_EMPTY</name>
              <description>Transmitter FIFO Empty (Read Only)\nThis bit indicates TX FIFO empty or not.\nNote: When the last byte of TX FIFO has been transferred to Transmitter Shift Register, hardware sets this bit high. It will be cleared when writing data into THR (TX FIFO not empty).</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>TX FIFO is not empty</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>TX FIFO is empty</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>TX_FULL</name>
              <description>Transmitter FIFO Full (Read Only)\nThis bit indicates TX FIFO full or not.\nThis bit is set when the number of usage in TX FIFO Buffer is equal to 64/16/16(UART0/UART1/UART2), otherwise is cleared by hardware.</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>TX FIFO is not full</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>TX FIFO is full</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>TX_OVER_IF</name>
              <description>TX Overflow Error Interrupt Flag (Read Only)\nIf TX FIFO (UA_THR) is full, an additional write to UA_THR will cause this bit to logic 1.\nNote: This bit is read only, but can be cleared by writing "1" to it.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>TX FIFO is not overflow</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>TX FIFO is overflow</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>TE_FLAG</name>
              <description>Transmitter Empty Flag (Read Only)\nThis bit is set by hardware when TX FIFO (UA_THR) is empty and the STOP bit of the last byte has been transmitted.\nNote: This bit is cleared automatically when TX FIFO is not empty or the last byte transmission has not completed.</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>TX FIFO is not empty</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>TX FIFO is empty</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UA_ISR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UA_ISR</displayName>
          <description>UART Interrupt Status Register</description>
          <addressOffset>0x1C</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000002</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RDA_IF</name>
              <description>Receive Data Available Interrupt Flag (Read Only)\nWhen the number of bytes in the RX FIFO equals the RFITL then the RDA_IF(UA_ISR[0]) will be set. If RDA_IEN (UA_IER [0]) is enabled, the RDA interrupt will be generated.\nNote: This bit is read only and it will be cleared when the number of unread bytes of RX FIFO drops below the threshold level (RFITL(UA_FCR[7:4]).</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No RDA interrupt flag is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RDA interrupt flag is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>THRE_IF</name>
              <description>Transmit Holding Register Empty Interrupt Flag (Read Only) \nThis bit is set when the last data of TX FIFO is transferred to Transmitter Shift Register. If THRE_IEN (UA_IER[1]) is enabled, the THRE interrupt will be generated.\nNote: This bit is read only and it will be cleared when writing data into THR (TX FIFO not empty).</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No THRE interrupt flag is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>THRE interrupt flag is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>RLS_IF</name>
              <description>Receive Line Interrupt Flag (Read Only)  \nThis bit is set when the RX receive data have parity error, frame error or break error (at least one of 3 bits, BIF(UA_FSR[6]), FEF(UA_FSR[5]) and PEF(UA_FSR[4]), is set). If RLS_IEN (UA_IER [2]) is enabled, the RLS interrupt will be generated.\nNote2: This bit is read only and reset to 0 when all bits of BIF(UA_FSR[6]), FEF(UA_FSR[5]) and PEF(UA_FSR[4]) are cleared.\nNote3: In RS-485 function mode, this bit is read only and reset to 0 when all bits of BIF(UA_FSR[6]) , FEF(UA_FSR[5]) and PEF(UA_FSR[4]) and RS485_ADD_DETF (UA_FSR[3]) are cleared.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No RLS interrupt flag is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RLS interrupt flag is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>MODEM_IF</name>
              <description>MODEM Interrupt Flag (Read Only) (Not Available In UART2 Channel)\nNote: This bit is read only and reset to 0 when bit DCTSF is cleared by a write 1 on DCTSF(UA_MSR[0]).</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No Modem interrupt flag is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Modem interrupt flag is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>TOUT_IF</name>
              <description>Time-Out Interrupt Flag (Read Only)\nThis bit is set when the RX FIFO is not empty and no activities occurred in the RX FIFO and the time-out counter equal to TOIC. If TOUT_IEN (UA_IER [4]) is enabled, the Tout interrupt will be generated.\nNote: This bit is read only and user can read UA_RBR (RX is in active) to clear it</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No Time-out interrupt flag is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Time-out interrupt flag is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>BUF_ERR_IF</name>
              <description>Buffer Error Interrupt Flag (Read Only)\nThis bit is set when the TX FIFO or RX FIFO overflows (TX_OVER_IF (UA_FSR[24]) or RX_OVER_IF (UA_FSR[0]) is set). When BUF_ERR_IF (UA_ISR[5])is set, the transfer is not correct. If BUF_ERR_IEN (UA_IER [8]) is enabled, the buffer error interrupt will be generated.\nNote: This bit is read only and reset to 0 when all bits of TX_OVER_IF(UA_FSR[24]) and RX_OVER_IF(UA_FSR[0]) are cleared.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No buffer error interrupt flag is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Buffer error interrupt flag is generated.0 = No buffer error interrupt flag is generated.\nBuffer error interrupt flag is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>LIN_IF</name>
              <description>LIN Bus Flag (Read Only)\nNote: This bit is read only. This bit is cleared when LINS_HDET_F(UA_LIN_SR[0]), LIN_BKDET_F(UA_LIN_SR[9]), BIT_ERR_F(UA_LIN_SR[9]), LINS_IDPENR_F (UA_LIN_SR[2]) and LINS_HERR_F(UA_LIN_SR[1]) all are cleared.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>None of LINS_HDET_F, LIN_BKDET_F, BIT_ERR_F, LINS_IDPERR_F and LINS_HERR_F is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>At least one of LINS_HDET_F, LIN_BKDET_F, BIT_ERR_F, LINS_IDPERR_F and LINS_HERR_F is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>RDA_INT</name>
              <description>Receive Data Available Interrupt Indicator (Read Only)\nThis bit is set if RDA_IEN (UA_IER[0]) and RDA_IF (UA_ISR[0]) are both set to 1.\n</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No RDA interrupt is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RDA interrupt is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>THRE_INT</name>
              <description>Transmit Holding Register Empty Interrupt Indicator (Read Only)\nThis bit is set if THRE_IEN (UA_IER[1])and THRE_IF(UA_SR[1]) are both set to 1.\n</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No THRE interrupt is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>THRE interrupt is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>RLS_INT</name>
              <description>Receive Line Status Interrupt Indicator (Read Only) \nThis bit is set if RLS_IEN (UA_IER[2]) and RLS_IF(UA_ISR[2]) are both set to 1.\n</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No RLS interrupt is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RLS interrupt is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>MODEM_INT</name>
              <description>MODEM Status Interrupt Indicator (Read Only) (Not Available In UART2 Channel)\nThis bit is set if MODEM_IEN(UA_IER[3] and MODEM_IF(UA_ISR[4]) are both set to 1\n</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No Modem interrupt is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Modem interrupt is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>TOUT_INT</name>
              <description>Time-Out Interrupt Indicator (Read Only)\nThis bit is set if TOUT_IEN(UA_IER[4]) and TOUT_IF(UA_ISR[4]) are both set to 1.\n</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No Tout interrupt is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Tout interrupt is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>BUF_ERR_INT</name>
              <description>Buffer Error Interrupt Indicator (Read Only)\nThis bit is set if BUF_ERR_IEN(UA_IER[5] and BUF_ERR_IF(UA_ISR[5]) are both set to 1.\n</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No buffer error interrupt is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Buffer error interrupt is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>LIN_INT</name>
              <description>LIN Bus Interrupt Indicator (Read Only)\nThis bit is set if LIN_IEN (UA_IER[8]) and LIN _IF(UA_ISR[7]) are both set to 1.\n</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No LIN Bus interrupt is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The LIN Bus interrupt is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>HW_RLS_IF</name>
              <description>In DMA Mode, Receive Line Status Flag (Read Only)\nThis bit is set when the RX receive data have parity error, frame error or break error (at least one of 3 bits, BIF (UA_FSR[6]), FEF (UA_FSR[5]) and PEF (UA_FSR[4]) is set). If RLS_IEN (UA_IER [2]) is enabled, the RLS interrupt will be generated.\nNote2: In UART function mode, this bit is read only and reset to 0 when all bits of BIF(UA_FSR[6]) , FEF(UA_FSR[5]) and PEF(UA_FSR[4]) are cleared. \nNote3: In RS-485 function mode, this bit is read only and reset to 0 when all bits of BIF(UA_FSR[6]) , FEF(UA_FSR[5]) and PEF(UA_FSR[4]) and  RS485_ADD_DETF (UA_FSR[3]) are cleared.</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No RLS interrupt flag is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RLS interrupt flag is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>HW_MODEM_IF</name>
              <description>In DMA Mode, MODEM Interrupt Flag (Read Only) (Not Available In UART2 Channel)\nNote: This bit is read only and reset to 0 when the bit DCTSF(US_MSR[0]) is cleared by writing 1 on DCTSF (US_MSR[0]).</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No Modem interrupt flag is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Modem interrupt flag is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>HW_TOUT_IF</name>
              <description>In DMA Mode, Time-Out Interrupt Flag (Read Only)\nThis bit is set when the RX FIFO is not empty and no activities occurred in the RX FIFO and the time-out counter equal to TOIC (UA_TOR[7:0]). If TOUT_IEN (UA_IER [4]) is enabled, the Tout interrupt will be generated. \nNote: This bit is read only and user can read UA_RBR (RX is in active) to clear it.</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No Time-out interrupt flag is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Time-out interrupt flag is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>HW_BUF_ERR_IF</name>
              <description>In DMA Mode, Buffer Error Interrupt Flag (Read Only)\nThis bit is set when the TX or RX FIFO overflows (TX_OVER_IF (UA__FSR[24]) or RX_OVER_IF (UA_FSR[0])  is set). When BUF_ERR_IF (UA_ISR[5]) is set, the transfer maybe is not correct. If BUF_ERR_IEN (UA_IER [5]) is enabled, the buffer error interrupt will be generated.\nNote: This bit is cleared when both TX_OVER_IF (UA_FSR[24]]) and RX_OVER_IF (UA_FSR[0]) are cleared.</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No buffer error interrupt flag is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Buffer error interrupt flag is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>HW_RLS_INT</name>
              <description>In DMA Mode, Receive Line Status Interrupt Indicator (Read Only)\nThis bit is set if RLS_IEN (UA_IER[2])and HW_RLS_IF(UA_ISR[18]) are both set to 1.\n</description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No RLS interrupt is generated in DMA mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RLS interrupt is generated in DMA mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>HW_MODEM_INT</name>
              <description>In DMA Mode, MODEM Status Interrupt Indicator (Read Only) (Not Available In UART2 Channel)\nThis bit is set if MODEM_IEN(UA_IER[3]) and HW_MODEM_IF(UA_ ISR[3]) are both set to 1.\n</description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No Modem interrupt is generated in DMA mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Modem interrupt is generated in DMA mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>HW_TOUT_INT</name>
              <description>In DMA Mode, Time-Out Interrupt Indicator (Read Only)\nThis bit is set if TOUT_IEN (UA_IER[4])and HW_TOUT_IF(UA_ISR[20]) are both set to 1.\n</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No Tout interrupt is generated in DMA mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Tout interrupt is generated in DMA mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>HW_BUF_ERR_INT</name>
              <description>In DMA Mode, Buffer Error Interrupt Indicator (Read Only)\nThis bit is set if BUF_ERR_IEN (UA_IER[5]) and HW_BUF_ERR_IF (UA_ISR[5])are both set to 1.\n</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No buffer error interrupt is generated in DMA mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Buffer error interrupt is generated in DMA mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UA_TOR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UA_TOR</displayName>
          <description>UART Time-out Register</description>
          <addressOffset>0x20</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TOIC</name>
              <description>Time-Out Interrupt Comparator\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DLY</name>
              <description>TX Delay Time Value \nThis field is used to programming the transfer delay time between the last stop bit and next start bit.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UA_BAUD</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UA_BAUD</displayName>
          <description>UART Baud Rate Divisor Register</description>
          <addressOffset>0x24</addressOffset>
          <access>read-write</access>
          <resetValue>0x0F000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BRD</name>
              <description>Baud Rate Divider\nThe field indicates the baud rate divider</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DIVIDER_X</name>
              <description>Divider X\n</description>
              <bitOffset>24</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DIV_X_ONE</name>
              <description>Divider X Equal To 1\nRefer to Table 612 for more information.</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Divider M = X (the equation of M = X+1, but DIVIDER_X[27:24] must  = 8)</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Divider M = 1 (the equation of M = 1, but BRD [15:0] must  = 3)</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DIV_X_EN</name>
              <description>Divider X Enable Bit\nRefer to Table 612 for more information.\nNote: In IrDA mode, this bit must disable.</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Divider X Disabled (the equation of M = 16)</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Divider X Enabled (the equation of M = X+1, but DIVIDER_X [27:24] must  = 8)</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UA_IRCR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UA_IRCR</displayName>
          <description>UART IrDA Control Register</description>
          <addressOffset>0x28</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000040</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TX_SELECT</name>
              <description>TX_SELECT\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>IrDA Transmitter Disabled and Receiver Enabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>IrDA Transmitter Enabled and Receiver Disabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>INV_TX</name>
              <description>IrDA Inverse Transmitting Output Signal Control\n</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>None inverse transmitting signal.</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Inverse transmitting output signal</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>INV_RX</name>
              <description>IrDA Inverse Receive Input Signal Control\n</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>None inverse receiving input signal</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Inverse receiving input signal</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UA_ALT_CSR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UA_ALT_CSR</displayName>
          <description>UART Alternate Control/Status Register</description>
          <addressOffset>0x2C</addressOffset>
          <access>read-write</access>
          <resetValue>0x0000000C</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>LIN_BKFL</name>
              <description>UART LIN Break Field Length\nThis field indicates a 4-bit LIN TX break field count.\nNote1: This break field length is UA_LIN_BKFL + 1\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>LIN_RX_EN</name>
              <description>LIN RX Enable Bit\n</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>LIN RX mode Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>LIN RX mode Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>LIN_TX_EN</name>
              <description>LIN TX Break Mode Enable Bit\nNote: When TX break field transfer operation finished, this bit will be cleared automatically.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>LIN TX Break mode Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>LIN TX Break mode Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RS485_NMM</name>
              <description>RS-485 Normal Multi-Drop Operation Mode (NMM) \nNote: It cannot be active with RS-485_AAD operation mode.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RS-485 Normal Multi-drop Operation mode (NMM) Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RS-485 Normal Multi-drop Operation mode (NMM) Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RS485_AAD</name>
              <description>RS-485 Auto Address Detection Operation Mode (AAD)\nNote: It cannot be active with RS-485_NMM operation mode.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RS-485 Auto Address Detection Operation mode (AAD) Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RS-485 Auto Address Detection Operation mode (AAD) Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RS485_AUD</name>
              <description>RS-485 Auto Direction Mode (AUD) \nNote: It can be active with RS-485_AAD or RS-485_NMM operation mode.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RS-485 Auto Direction Operation mode (AUO) Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RS-485 Auto Direction Operation mode (AUO) Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RS485_ADD_EN</name>
              <description>RS-485 Address Detection Enable Bit\nThis bit is used to enable RS-485 Address Detection mode. \nNote: This bit is used for RS-485 any operation mode.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Address detection mode Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Address detection mode Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ADDR_MATCH</name>
              <description>Address Match Value Register \nThis field contains the RS-485 address match values.\nNote: This field is used for RS-485 auto address detection mode.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UA_FUN_SEL</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UA_FUN_SEL</displayName>
          <description>UART Function Select Register</description>
          <addressOffset>0x30</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>FUN_SEL</name>
              <description>Function Select Enable Bit\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>UART function Enabled</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>LIN function Enabled</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>IrDA function Enabled</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>RS-485 function Enabled</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UA_LIN_CTL</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UA_LIN_CTL</displayName>
          <description>UART LIN Control Register</description>
          <addressOffset>0x34</addressOffset>
          <access>read-write</access>
          <resetValue>0x000C0000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>LINS_EN</name>
              <description>LIN Slave Mode Enable Bit\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>LIN slave mode Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>LIN slave mode Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>LINS_HDET_EN</name>
              <description>LIN Slave Header Detection Enable Bit\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>LIN slave header detection Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>LIN slave header detection Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>LINS_ARS_EN</name>
              <description>LIN Slave Automatic Resynchronization Mode Enable Bit\nNote2: When operation in Automatic Resynchronization mode, the baud rate setting must be mode2 (BAUD_M1 (UA_BAUD [29]) and BAUD_M0 (UA_BAUD [28]) must be 1).\nNote3: The control and interactions of this field are explained in 6.13.5.8.4. (Slave mode with automatic resynchronization).</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>LIN automatic resynchronization Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>LIN automatic resynchronization Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>LINS_DUM_EN</name>
              <description>LIN Slave Divider Update Method Enable Bit\nNote2: This bit used for LIN Slave Automatic Resynchronization mode. (for Non-Automatic Resynchronization mode, this bit should be kept cleared) \nNote3: The control and interactions of this field are explained in 6.13.5.8.4. (Slave mode with automatic resynchronization).</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>UA_BAUD updated is written by software (if no automatic resynchronization update occurs at the same time)</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>UA_BAUD is updated at the next received character. User must set the bit before checksum reception</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>LIN_MUTE_EN</name>
              <description>LIN Mute Mode Enable Bit\nNote: The exit from mute mode condition and each control and interactions of this field are explained in (LIN slave mode).</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>LIN mute mode Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>LIN mute mode Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>LIN_SHD</name>
              <description>LIN TX Send Header Enable Bit\nThe LIN TX header can be "break field" or "break and sync field" or "break, sync and frame ID field", it is depend on setting LIN_HEAD_SEL (UA_LIN_CTL[23:22]).\nNote1: These registers are shadow registers of LIN_SHD (UA_ALT_CSR [7]); user can read/write it by setting LIN_SHD (UA_ALT_CSR [7]) or LIN_SHD (UA_LIN_CTL [8]).\nNote2: When transmitter header field (it may be "break" or "break + sync" or "break + sync + frame ID" selected by LIN_HEAD_SEL (UA_LIN_CTL[23:22]) field) transfer operation finished, this bit will be cleared automatically.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Send LIN TX header Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Send LIN TX header Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>LIN_IDPEN</name>
              <description>LIN ID Parity Enable Bit\n</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>LIN frame ID parity Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>LIN frame ID parity Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>LIN_BKDET_EN</name>
              <description>LIN Break Detection Enable Bit\n</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>LIN break detection Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>LIN break detection Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>LIN_RX_DIS</name>
              <description>LIN Receiver Disable Bit\n</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>LIN receiver Enabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>LIN receiver Disabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BIT_ERR_EN</name>
              <description>Bit Error Detect Enable Bit\n</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Bit error detection function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Bit error detection Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>LIN_BKFL</name>
              <description>LIN Break Field Length\nThis field indicates a 4-bit LIN TX break field count.\nNote1: These registers are shadow registers of LIN_BKFL, User can read/write it by setting LIN_BKFL (UA_ALT_CSR[3:0]) or LIN_BKFL (UA_LIN_CTL[19:16].\nNote2: This break field length is LIN_BKFL + 1.\n</description>
              <bitOffset>16</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>LIN_BS_LEN</name>
              <description>LIN Break/Sync Delimiter Length\n\nNote: This bit used for LIN master to sending header field.</description>
              <bitOffset>20</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The LIN break/sync delimiter length is 1 bit time</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>The LIN break/sync delimiter length is 2 bit time.\nThe LIN break/sync delimiter length is 3 bit time</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>The LIN break/sync delimiter length is 4 bit time</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>LIN_HEAD_SEL</name>
              <description>LIN Header Select\n</description>
              <bitOffset>22</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The LIN header includes "break field"</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The LIN header includes "break field" and "sync field"</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>The LIN header includes "break field", "sync field" and "frame ID field"</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Reserved</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>LIN_PID</name>
              <description>LIN PID Register\nIf the parity generated by hardware, user fill ID0~ID5, (LIN_PID [29:24] )hardware will calculate P0 (LIN_PID[30]) and P1 (LIN_PID[31]), otherwise user must filled frame ID and parity in this field.\n\nNote1: User can fill any 8-bit value to this field and the bit 24 indicates ID0 (LSB first).\nNote2: This field can be used for LIN master mode or slave mode.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UA_LIN_SR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UA_LIN_SR</displayName>
          <description>UART LIN Status Register</description>
          <addressOffset>0x38</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>LINS_HDET_F</name>
              <description>LIN Slave Header Detection Flag (Read Only)\nThis bit is set by hardware when a LIN header is detected in LIN slave mode and be cleared by writing 1 to it.\nNote3: When enable ID parity check LIN_IDPEN (UA_LIN_CTL [9]), if hardware detect complete header ("break + sync + frame ID"), the LINS_HEDT_F will be set whether the frame ID correct or not.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>LIN header not detected</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>LIN header detected (break + sync + frame ID)</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>LINS_HERR_F</name>
              <description>LIN Slave Header Error Flag (Read Only)\nThis bit is set by hardware when a LIN header error is detected in LIN slave mode and be cleared by writing 1 to it. The header errors include "break delimiter is too short (less than 0.5 bit time)", "frame error in sync field or Identifier field", "sync field data is not 0x55 in Non-Automatic Resynchronization mode", "sync field deviation error with Automatic Resynchronization mode", "sync field measure time-out with Automatic Resynchronization mode" and "LIN header reception time-out".\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>LIN header error not detected</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>LIN header error detected</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>LINS_IDPERR_F</name>
              <description>LIN Slave ID Parity Error Flag (Read Only)\nThis bit is set by hardware when receipted frame ID parity is not correct.\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No active</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Receipted frame ID parity is not correct</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>LINS_SYNC_F</name>
              <description>LIN Slave Sync Field\nThis bit indicates that the LIN sync field is being analyzed in Automatic Resynchronization mode. When the receiver header have some error been detect, user must reset the internal circuit to re-search new frame header by writing 1 to this bit.\nNote2: This bit is read only, but it can be cleared by writing 1 to it.\nNote3: When writing 1 to it, hardware will reload the initial baud rate and re-search a new frame header.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The current character is not at LIN sync state</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The current character is at LIN sync state</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>LIN_BKDET_F</name>
              <description>LIN Break Detection Flag (Read Only)\nThis bit is set by hardware when a break is detected and be cleared by writing 1 to it through software.\n</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>LIN break not detected</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>LIN break detected</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>BIT_ERR_F</name>
              <description>Bit Error Detect Status Flag (Read Only)\nAt TX transfer state, hardware will monitoring the bus state, if the input pin (SIN) state not equals to the output pin (SOUT) state, BIT_ERR_F (UA_LIN_SR[9]) will be set.\n</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>UART1</name>
      <description>UART Register Map</description>
      <groupName>UART</groupName>
      <baseAddress>0x40150000</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x0</offset>
        <size>0x3C</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>UA_RBR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UA_RBR</displayName>
          <description>UART Receive Buffer Register</description>
          <addressOffset>0x0</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>RBR</name>
              <description>Receive Buffer Register (Read Only)\nBy reading this register, the UART will return the 8-bit data received from RX pin (LSB first).</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UA_THR</name>
          <alternateRegister>UA_RBR</alternateRegister>
          <!-- the display name is an unrestricted string. -->
          <displayName>UA_THR</displayName>
          <description>UART Transmit Holding Register</description>
          <addressOffset>0x0</addressOffset>
          <access>write-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>THR</name>
              <description>Transmit Holding Register\nBy writing one byte to this register, the data byte will be stored in transmitter FIFO. The UART Controller will send out the data stored in transmitter FIFO top location through the TX pin.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UA_IER</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UA_IER</displayName>
          <description>UART Interrupt Enable Register</description>
          <addressOffset>0x4</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RDA_IEN</name>
              <description>Receive Data Available Interrupt Enable Bit\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RDA_INT Masked off</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RDA_INT Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>THRE_IEN</name>
              <description>Transmit Holding Register Empty Interrupt Enable Bit\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>THRE_INT Masked off</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>THRE_INT Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RLS_IEN</name>
              <description>Receive Line Status Interrupt Enable Bit\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RLS_INT Masked off</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RLS_INT Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>MODEM_IEN</name>
              <description>Modem Status Interrupt Enable Bit (Not Available In UART2 Channel)\n</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>MODEM_INT Masked off</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>MODEM_INT Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TOUT_IEN</name>
              <description>RX Time-Out Interrupt Enable Bit\n</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>TOUT_INT Masked off</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>TOUT_INT Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BUF_ERR_IEN</name>
              <description>Buffer Error Interrupt Enable Bit\n</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>BUF_ERR_INT Masked off</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>BUF_ERR_INT Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>WAKE_EN</name>
              <description>UART Wake-Up Function Enable Bit (Not Available In UART2 Channel)\n</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>UART wake-up function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>UART wake-up function Enabled, when the chip is in Power-down mode, an external CTS change will wake-up chip from Power-down mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>LIN_IEN</name>
              <description>LIN Bus Interrupt Enable Bit\nNote: This field is used for LIN function mode.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Lin bus interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Lin bus interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TIME_OUT_EN</name>
              <description>Time-Out Counter Enable Bit\n</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Time-out counter Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Time-out counter Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>AUTO_RTS_EN</name>
              <description>RTS Auto Flow Control Enable Bit (Not Available In UART2 Channel)\nWhen RTS auto-flow is enabled, if the number of bytes in the RX FIFO equals the RTS_TRI_LEV (UA_FCR [19:16]), the UART will de-assert RTS signal.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RTS auto flow control Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RTS auto flow control Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>AUTO_CTS_EN</name>
              <description>CTS Auto Flow Control Enable Bit (Not Available In UART2 Channel)\nWhen CTS auto-flow is enabled, the UART will send data to external device when CTS input assert (UART will not send data to device until CTS is asserted).</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>CTS auto flow control Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>CTS auto flow control Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DMA_TX_EN</name>
              <description>TX DMA Enable Bit (Not Available In UART2 Channel)\nThis bit can enable or disable TX DMA service.\n</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>TX DMA Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>TX DMA Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DMA_RX_EN</name>
              <description>RX DMA Enable Bit (Not Available In UART2 Channel)\nThis bit can enable or disable RX DMA service.\n</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RX DMA Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RX DMA Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UA_FCR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UA_FCR</displayName>
          <description>UART FIFO Control Register</description>
          <addressOffset>0x8</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000101</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RFR</name>
              <description>RX Field Software Reset\nWhen RFR is set, all the byte in the receiver FIFO and RX internal state machine are cleared.\nNote: This bit will automatically clear at least 3 UART peripherial clock cycles.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reset the RX internal state machine and pointers</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TFR</name>
              <description>TX Field Software Reset\nWhen TFR is set, all the byte in the transmit FIFO and TX internal state machine are cleared.\nNote: This bit will automatically clear at least 3 UART peripherial clock cycles.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reset the TX internal state machine and pointers</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RFITL</name>
              <description>RX FIFO Interrupt (INT_RDA) Trigger Level\nWhen the number of bytes in the receive FIFO equals the RFITL, the RDA_IF will be set (if UA_IER [RDA_IEN] enabled, and an interrupt will be generated).\n</description>
              <bitOffset>4</bitOffset>
              <bitWidth>4</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RX FIFO Interrupt Trigger Level is 1 byte</description>
                    <value>#0000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RX FIFO Interrupt Trigger Level is 4 bytes</description>
                    <value>#0001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>RX FIFO Interrupt Trigger Level is 8 bytes</description>
                    <value>#0010</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>RX FIFO Interrupt Trigger Level is 14 bytes</description>
                    <value>#0011</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>4</name>
                    <description>RX FIFO Interrupt Trigger Level is 30/14 bytes (High Speed/Normal Speed)</description>
                    <value>#0100</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>5</name>
                    <description>RX FIFO Interrupt Trigger Level is 46/14 bytes (High Speed/Normal Speed)</description>
                    <value>#0101</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>6</name>
                    <description>RX FIFO Interrupt Trigger Level is 62/14 bytes (High Speed/Normal Speed)</description>
                    <value>#0110</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_DIS</name>
              <description>Receiver Disable Bit\nThe receiver is disabled or not (set 1 to disable receiver)\nNote: This field is used for RS-485 Normal Multi-drop mode. It should be programmed before UA_ALT_CSR [RS-485_NMM] is programmed.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Receiver Enabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Receiver Disabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RTS_TRI_LEV</name>
              <description>RTS Trigger Level For Auto-Flow Control Use (Not Available In UART2 Channel)\nNote: This field is used for RTS auto-flow control.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>4</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RTS Trigger Level is 1 byte</description>
                    <value>#0000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RTS Trigger Level is 4 bytes</description>
                    <value>#0001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>RTS Trigger Level is 8 bytes</description>
                    <value>#0010</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>RTS Trigger Level is 14 bytes</description>
                    <value>#0011</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>4</name>
                    <description>RTS Trigger Level is 30/14 bytes (High Speed/Normal Speed)</description>
                    <value>#0100</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>5</name>
                    <description>RTS Trigger Level is 46/14 bytes (High Speed/Normal Speed)</description>
                    <value>#0101</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>6</name>
                    <description>RTS Trigger Level is 62/14 bytes (High Speed/Normal Speed)</description>
                    <value>#0110</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UA_LCR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UA_LCR</displayName>
          <description>UART Line Control Register</description>
          <addressOffset>0xC</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WLS</name>
              <description>Word Length Selection\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Word length is 5-bit</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Word length is 6-bit</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Word length is 7-bit</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Word length is 8-bit</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>NSB</name>
              <description>Number Of "STOP Bit"\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>One " STOP bit" is generated in the transmitted data</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>When select 5-bit word length, 1.5 "STOP bit" is generated in the transmitted data. When select 6-,7- and 8-bti word length, 2 "STOP bit" is generated in the transmitted data</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PBE</name>
              <description>Parity Bit Enable Bit\n</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No parity bit</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Parity bit is generated on each outgoing character and is checked on each incoming data</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>EPE</name>
              <description>Even Parity Enable Bit\nThis bit has effect only when PBE (UA_LCR[3]) is set.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Odd number of logic 1's is transmitted and checked in each word</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Even number of logic 1's is transmitted and checked in each word</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SPE</name>
              <description>Stick Parity Enable Bit\n</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Stick parity Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>If PBE (UA_LCR[3]) and EBE (UA_LCR[4]) are logic 1, the parity bit is transmitted and checked as logic 0. If PBE (UA_LCR[3]) is 1 and EBE (UA_LCR[4]) is 0 then the parity bit is transmitted and checked as 1</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BCB</name>
              <description>Break Control Bit\nWhen this bit is set to logic 1, the serial data output (TX) is forced to the Spacing State (logic 0). This bit acts only on TX and has no effect on the transmitter logic.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UA_MCR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UA_MCR</displayName>
          <description>UART Modem Control Register</description>
          <addressOffset>0x10</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000200</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RTS</name>
              <description>RTS (Request-To-Send) Signal Control (Not Available In UART2 Channel)\nThis bit is direct control internal RTS signal active or not, and then drive the RTS pin output with LEV_RTS bit configuration.\nNote1: This RTS signal control bit is not effective when RTS auto-flow control is enabled in UART function mode.\nNote2: This RTS signal control bit is not effective when RS-485 auto direction mode (AUD) is enabled in RS-485 function mode.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RTS signal is active</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RTS signal is inactive</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>LEV_RTS</name>
              <description>RTS Pin Active Level (Not Available In UART2 Channel)\nThis bit defines the active level state of RTS pin output.\nNote1: Refer to Figure 662 and Figure 663 for UART function mode.\nNote2: Refer to Figure 673 And Figure 674for RS-485 function mode.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RTS pin output is high level active</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RTS pin output is low level active</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RTS_ST</name>
              <description>RTS Pin State (Read Only) (Not Available In UART2 Channel)\nThis bit mirror from RTS pin output of voltage logic status.\n</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RTS pin output is low level voltage logic state</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RTS pin output is high level voltage logic state</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UA_MSR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UA_MSR</displayName>
          <description>UART Modem Status Register</description>
          <addressOffset>0x14</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000110</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DCTSF</name>
              <description>Detect CTS State Change Flag (Read Only) (Not Available In UART2 Channel)\nThis bit is set whenever CTS input has change state, and it will generate Modem interrupt to CPU when MODEM_IEN (UA_IER [3]) is set to 1.\nNote: This bit is read only, but can be cleared by writing "1" to it.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>CTS input has not change state</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>CTS input has change state</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>CTS_ST</name>
              <description>CTS Pin Status (Read Only) (Not Available In UART2 Channel)\nThis bit mirror from CTS pin input of voltage logic status.\nNote: This bit echoes when UART Controller peripheral clock is enabled, and CTS multi-function port is selected</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>CTS pin input is low level voltage logic state</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>CTS pin input is high level voltage logic state</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>LEV_CTS</name>
              <description>CTS Pin Active Level\nThis bit defines the active level state of CTS pin input.\nNote: Refer to Figure 661 for more information</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>CTS pin input is high level active</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>CTS pin input is low level active</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UA_FSR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UA_FSR</displayName>
          <description>UART FIFO Status Register</description>
          <addressOffset>0x18</addressOffset>
          <access>read-write</access>
          <resetValue>0x10404000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RX_OVER_IF</name>
              <description>RX Overflow Error IF (Read Only)\nThis bit is set when RX FIFO overflow.\nIf the number of bytes of received data is greater than RX_FIFO (UA_RBR) size, 64/16/16 bytes of UART0/UART1/UART2, this bit will be set.\nNote: This bit is read only, but can be cleared by writing "1" to it.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RX FIFO is not overflow</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RX FIFO is overflow</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>RS485_ADD_DETF</name>
              <description>RS-485 Address Byte Detection Flag (Read Only) \nNote1: This field is used for RS-485 function mode and RS485_ADD_EN (UA_ALT_CSR[15]) is set to 1 to enable Address detection mode.\nNote2: This bit is read only, but can be cleared by writing '1' to it.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Receiver detects a data that is not an address bit (bit 9 ='1')</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Receiver detects a data that is an address bit (bit 9 ='1')</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>PEF</name>
              <description>Parity Error Flag (Read Only)\nThis bit is set to logic 1 whenever the received character does not have a valid "parity bit", and is reset whenever the CPU writes 1 to this bit.\nNote: This bit is read only, but can be cleared by writing "1" to it.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No parity error is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Parity error is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>FEF</name>
              <description>Framing Error Flag (Read Only)\nThis bit is set to logic 1 whenever the received character does not have a valid "stop bit" (that is, the stop bit following the last data bit or parity bit is detected as logic 0), and is reset whenever the CPU writes 1 to this bit.\nNote: This bit is read only, but can be cleared by writing "1" to it.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No framing error is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Framing error is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>BIF</name>
              <description>Break Interrupt Flag (Read Only)\nThis bit is set to logic 1 whenever the received data input(RX) is held in the "spacing state" (logic 0) for longer than a full word transmission time (that is, the total time of "start bit" + data bits + parity + stop bits) and is reset whenever the CPU writes 1 to this bit.\nNote: This bit is read only, but can be cleared by writing "1" to it.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No Break interrupt is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Break interrupt is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>RX_POINTER</name>
              <description>RX FIFO Pointer (Read Only)\nThis field indicates the RX FIFO Buffer Pointer. When UART receives one byte from external device, then RX_POINTER increases one. When one byte of RX FIFO is read by CPU, then RX_POINTER decreases one.\nThe Maximum value shown in RX_POINTER is 63/15/15 (UART0/UART1/UART2). When the using level of RX FIFO Buffer equal to 64/16/16, the RX_FULL bit is set to 1 and RX_POINTER will show 0. As one byte of RX FIFO is read by CPU, the RX_FULL bit is cleared to 0 and RX_POINTER will show 63/15/15 (UART0/UART1/UART2).</description>
              <bitOffset>8</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RX_EMPTY</name>
              <description>Receiver FIFO Empty (Read Only)\nThis bit initiate RX FIFO empty or not.\nNote: When the last byte of RX FIFO has been read by CPU, hardware sets this bit high. It will be cleared when UART receives any new data.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RX FIFO is not empty</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RX FIFO is empty</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>RX_FULL</name>
              <description>Receiver FIFO Full (Read Only)\nThis bit initiates RX FIFO is full or not.\nNote: This bit is set when the number of usage in RX FIFO Buffer is equal to 64/16/16(UART0/UART1/UART2), otherwise is cleared by hardware.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RX FIFO is not full</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RX FIFO is full</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>TX_POINTER</name>
              <description>TX FIFO Pointer (Read Only)\nThis field indicates the TX FIFO Buffer Pointer. When CPU writes one byte into UA_THR, then TX_POINTER increases one. When one byte of TX FIFO is transferred to Transmitter Shift Register, then TX_POINTER decreases one.\nThe Maximum value shown in TX_POINTER is 63/15/15 (UART0/UART1/UART2). When the using level of TX FIFO Buffer equal to 64/16/16, the TX_FULL bit is set to 1 and TX_POINTER will show 0. As one byte of TX FIFO is transferred to Transmitter Shift Register, the TX_FULL bit is cleared to 0 and TX_POINTER will show 63/15/15 (UART0/UART1/UART2).</description>
              <bitOffset>16</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TX_EMPTY</name>
              <description>Transmitter FIFO Empty (Read Only)\nThis bit indicates TX FIFO empty or not.\nNote: When the last byte of TX FIFO has been transferred to Transmitter Shift Register, hardware sets this bit high. It will be cleared when writing data into THR (TX FIFO not empty).</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>TX FIFO is not empty</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>TX FIFO is empty</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>TX_FULL</name>
              <description>Transmitter FIFO Full (Read Only)\nThis bit indicates TX FIFO full or not.\nThis bit is set when the number of usage in TX FIFO Buffer is equal to 64/16/16(UART0/UART1/UART2), otherwise is cleared by hardware.</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>TX FIFO is not full</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>TX FIFO is full</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>TX_OVER_IF</name>
              <description>TX Overflow Error Interrupt Flag (Read Only)\nIf TX FIFO (UA_THR) is full, an additional write to UA_THR will cause this bit to logic 1.\nNote: This bit is read only, but can be cleared by writing "1" to it.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>TX FIFO is not overflow</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>TX FIFO is overflow</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>TE_FLAG</name>
              <description>Transmitter Empty Flag (Read Only)\nThis bit is set by hardware when TX FIFO (UA_THR) is empty and the STOP bit of the last byte has been transmitted.\nNote: This bit is cleared automatically when TX FIFO is not empty or the last byte transmission has not completed.</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>TX FIFO is not empty</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>TX FIFO is empty</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UA_ISR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UA_ISR</displayName>
          <description>UART Interrupt Status Register</description>
          <addressOffset>0x1C</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000002</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RDA_IF</name>
              <description>Receive Data Available Interrupt Flag (Read Only)\nWhen the number of bytes in the RX FIFO equals the RFITL then the RDA_IF(UA_ISR[0]) will be set. If RDA_IEN (UA_IER [0]) is enabled, the RDA interrupt will be generated.\nNote: This bit is read only and it will be cleared when the number of unread bytes of RX FIFO drops below the threshold level (RFITL(UA_FCR[7:4]).</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No RDA interrupt flag is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RDA interrupt flag is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>THRE_IF</name>
              <description>Transmit Holding Register Empty Interrupt Flag (Read Only) \nThis bit is set when the last data of TX FIFO is transferred to Transmitter Shift Register. If THRE_IEN (UA_IER[1]) is enabled, the THRE interrupt will be generated.\nNote: This bit is read only and it will be cleared when writing data into THR (TX FIFO not empty).</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No THRE interrupt flag is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>THRE interrupt flag is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>RLS_IF</name>
              <description>Receive Line Interrupt Flag (Read Only)  \nThis bit is set when the RX receive data have parity error, frame error or break error (at least one of 3 bits, BIF(UA_FSR[6]), FEF(UA_FSR[5]) and PEF(UA_FSR[4]), is set). If RLS_IEN (UA_IER [2]) is enabled, the RLS interrupt will be generated.\nNote2: This bit is read only and reset to 0 when all bits of BIF(UA_FSR[6]), FEF(UA_FSR[5]) and PEF(UA_FSR[4]) are cleared.\nNote3: In RS-485 function mode, this bit is read only and reset to 0 when all bits of BIF(UA_FSR[6]) , FEF(UA_FSR[5]) and PEF(UA_FSR[4]) and RS485_ADD_DETF (UA_FSR[3]) are cleared.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No RLS interrupt flag is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RLS interrupt flag is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>MODEM_IF</name>
              <description>MODEM Interrupt Flag (Read Only) (Not Available In UART2 Channel)\nNote: This bit is read only and reset to 0 when bit DCTSF is cleared by a write 1 on DCTSF(UA_MSR[0]).</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No Modem interrupt flag is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Modem interrupt flag is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>TOUT_IF</name>
              <description>Time-Out Interrupt Flag (Read Only)\nThis bit is set when the RX FIFO is not empty and no activities occurred in the RX FIFO and the time-out counter equal to TOIC. If TOUT_IEN (UA_IER [4]) is enabled, the Tout interrupt will be generated.\nNote: This bit is read only and user can read UA_RBR (RX is in active) to clear it</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No Time-out interrupt flag is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Time-out interrupt flag is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>BUF_ERR_IF</name>
              <description>Buffer Error Interrupt Flag (Read Only)\nThis bit is set when the TX FIFO or RX FIFO overflows (TX_OVER_IF (UA_FSR[24]) or RX_OVER_IF (UA_FSR[0]) is set). When BUF_ERR_IF (UA_ISR[5])is set, the transfer is not correct. If BUF_ERR_IEN (UA_IER [8]) is enabled, the buffer error interrupt will be generated.\nNote: This bit is read only and reset to 0 when all bits of TX_OVER_IF(UA_FSR[24]) and RX_OVER_IF(UA_FSR[0]) are cleared.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No buffer error interrupt flag is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Buffer error interrupt flag is generated.0 = No buffer error interrupt flag is generated.\nBuffer error interrupt flag is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>LIN_IF</name>
              <description>LIN Bus Flag (Read Only)\nNote: This bit is read only. This bit is cleared when LINS_HDET_F(UA_LIN_SR[0]), LIN_BKDET_F(UA_LIN_SR[9]), BIT_ERR_F(UA_LIN_SR[9]), LINS_IDPENR_F (UA_LIN_SR[2]) and LINS_HERR_F(UA_LIN_SR[1]) all are cleared.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>None of LINS_HDET_F, LIN_BKDET_F, BIT_ERR_F, LINS_IDPERR_F and LINS_HERR_F is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>At least one of LINS_HDET_F, LIN_BKDET_F, BIT_ERR_F, LINS_IDPERR_F and LINS_HERR_F is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>RDA_INT</name>
              <description>Receive Data Available Interrupt Indicator (Read Only)\nThis bit is set if RDA_IEN (UA_IER[0]) and RDA_IF (UA_ISR[0]) are both set to 1.\n</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No RDA interrupt is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RDA interrupt is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>THRE_INT</name>
              <description>Transmit Holding Register Empty Interrupt Indicator (Read Only)\nThis bit is set if THRE_IEN (UA_IER[1])and THRE_IF(UA_SR[1]) are both set to 1.\n</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No THRE interrupt is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>THRE interrupt is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>RLS_INT</name>
              <description>Receive Line Status Interrupt Indicator (Read Only) \nThis bit is set if RLS_IEN (UA_IER[2]) and RLS_IF(UA_ISR[2]) are both set to 1.\n</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No RLS interrupt is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RLS interrupt is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>MODEM_INT</name>
              <description>MODEM Status Interrupt Indicator (Read Only) (Not Available In UART2 Channel)\nThis bit is set if MODEM_IEN(UA_IER[3] and MODEM_IF(UA_ISR[4]) are both set to 1\n</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No Modem interrupt is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Modem interrupt is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>TOUT_INT</name>
              <description>Time-Out Interrupt Indicator (Read Only)\nThis bit is set if TOUT_IEN(UA_IER[4]) and TOUT_IF(UA_ISR[4]) are both set to 1.\n</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No Tout interrupt is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Tout interrupt is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>BUF_ERR_INT</name>
              <description>Buffer Error Interrupt Indicator (Read Only)\nThis bit is set if BUF_ERR_IEN(UA_IER[5] and BUF_ERR_IF(UA_ISR[5]) are both set to 1.\n</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No buffer error interrupt is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Buffer error interrupt is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>LIN_INT</name>
              <description>LIN Bus Interrupt Indicator (Read Only)\nThis bit is set if LIN_IEN (UA_IER[8]) and LIN _IF(UA_ISR[7]) are both set to 1.\n</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No LIN Bus interrupt is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The LIN Bus interrupt is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>HW_RLS_IF</name>
              <description>In DMA Mode, Receive Line Status Flag (Read Only)\nThis bit is set when the RX receive data have parity error, frame error or break error (at least one of 3 bits, BIF (UA_FSR[6]), FEF (UA_FSR[5]) and PEF (UA_FSR[4]) is set). If RLS_IEN (UA_IER [2]) is enabled, the RLS interrupt will be generated.\nNote2: In UART function mode, this bit is read only and reset to 0 when all bits of BIF(UA_FSR[6]) , FEF(UA_FSR[5]) and PEF(UA_FSR[4]) are cleared. \nNote3: In RS-485 function mode, this bit is read only and reset to 0 when all bits of BIF(UA_FSR[6]) , FEF(UA_FSR[5]) and PEF(UA_FSR[4]) and  RS485_ADD_DETF (UA_FSR[3]) are cleared.</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No RLS interrupt flag is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RLS interrupt flag is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>HW_MODEM_IF</name>
              <description>In DMA Mode, MODEM Interrupt Flag (Read Only) (Not Available In UART2 Channel)\nNote: This bit is read only and reset to 0 when the bit DCTSF(US_MSR[0]) is cleared by writing 1 on DCTSF (US_MSR[0]).</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No Modem interrupt flag is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Modem interrupt flag is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>HW_TOUT_IF</name>
              <description>In DMA Mode, Time-Out Interrupt Flag (Read Only)\nThis bit is set when the RX FIFO is not empty and no activities occurred in the RX FIFO and the time-out counter equal to TOIC (UA_TOR[7:0]). If TOUT_IEN (UA_IER [4]) is enabled, the Tout interrupt will be generated. \nNote: This bit is read only and user can read UA_RBR (RX is in active) to clear it.</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No Time-out interrupt flag is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Time-out interrupt flag is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>HW_BUF_ERR_IF</name>
              <description>In DMA Mode, Buffer Error Interrupt Flag (Read Only)\nThis bit is set when the TX or RX FIFO overflows (TX_OVER_IF (UA__FSR[24]) or RX_OVER_IF (UA_FSR[0])  is set). When BUF_ERR_IF (UA_ISR[5]) is set, the transfer maybe is not correct. If BUF_ERR_IEN (UA_IER [5]) is enabled, the buffer error interrupt will be generated.\nNote: This bit is cleared when both TX_OVER_IF (UA_FSR[24]]) and RX_OVER_IF (UA_FSR[0]) are cleared.</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No buffer error interrupt flag is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Buffer error interrupt flag is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>HW_RLS_INT</name>
              <description>In DMA Mode, Receive Line Status Interrupt Indicator (Read Only)\nThis bit is set if RLS_IEN (UA_IER[2])and HW_RLS_IF(UA_ISR[18]) are both set to 1.\n</description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No RLS interrupt is generated in DMA mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RLS interrupt is generated in DMA mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>HW_MODEM_INT</name>
              <description>In DMA Mode, MODEM Status Interrupt Indicator (Read Only) (Not Available In UART2 Channel)\nThis bit is set if MODEM_IEN(UA_IER[3]) and HW_MODEM_IF(UA_ ISR[3]) are both set to 1.\n</description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No Modem interrupt is generated in DMA mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Modem interrupt is generated in DMA mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>HW_TOUT_INT</name>
              <description>In DMA Mode, Time-Out Interrupt Indicator (Read Only)\nThis bit is set if TOUT_IEN (UA_IER[4])and HW_TOUT_IF(UA_ISR[20]) are both set to 1.\n</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No Tout interrupt is generated in DMA mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Tout interrupt is generated in DMA mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>HW_BUF_ERR_INT</name>
              <description>In DMA Mode, Buffer Error Interrupt Indicator (Read Only)\nThis bit is set if BUF_ERR_IEN (UA_IER[5]) and HW_BUF_ERR_IF (UA_ISR[5])are both set to 1.\n</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No buffer error interrupt is generated in DMA mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Buffer error interrupt is generated in DMA mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UA_TOR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UA_TOR</displayName>
          <description>UART Time-out Register</description>
          <addressOffset>0x20</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TOIC</name>
              <description>Time-Out Interrupt Comparator\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DLY</name>
              <description>TX Delay Time Value \nThis field is used to programming the transfer delay time between the last stop bit and next start bit.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UA_BAUD</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UA_BAUD</displayName>
          <description>UART Baud Rate Divisor Register</description>
          <addressOffset>0x24</addressOffset>
          <access>read-write</access>
          <resetValue>0x0F000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BRD</name>
              <description>Baud Rate Divider\nThe field indicates the baud rate divider</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DIVIDER_X</name>
              <description>Divider X\n</description>
              <bitOffset>24</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DIV_X_ONE</name>
              <description>Divider X Equal To 1\nRefer to Table 612 for more information.</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Divider M = X (the equation of M = X+1, but DIVIDER_X[27:24] must  = 8)</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Divider M = 1 (the equation of M = 1, but BRD [15:0] must  = 3)</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DIV_X_EN</name>
              <description>Divider X Enable Bit\nRefer to Table 612 for more information.\nNote: In IrDA mode, this bit must disable.</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Divider X Disabled (the equation of M = 16)</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Divider X Enabled (the equation of M = X+1, but DIVIDER_X [27:24] must  = 8)</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UA_IRCR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UA_IRCR</displayName>
          <description>UART IrDA Control Register</description>
          <addressOffset>0x28</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000040</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TX_SELECT</name>
              <description>TX_SELECT\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>IrDA Transmitter Disabled and Receiver Enabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>IrDA Transmitter Enabled and Receiver Disabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>INV_TX</name>
              <description>IrDA Inverse Transmitting Output Signal Control\n</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>None inverse transmitting signal</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Inverse transmitting output signal</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>INV_RX</name>
              <description>IrDA Inverse Receive Input Signal Control\n</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>None inverse receiving input signal</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Inverse receiving input signal</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UA_ALT_CSR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UA_ALT_CSR</displayName>
          <description>UART Alternate Control/Status Register</description>
          <addressOffset>0x2C</addressOffset>
          <access>read-write</access>
          <resetValue>0x0000000C</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>LIN_BKFL</name>
              <description>UART LIN Break Field Length\nThis field indicates a 4-bit LIN TX break field count.\nNote1: This break field length is UA_LIN_BKFL + 1\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>LIN_RX_EN</name>
              <description>LIN RX Enable Bit\n</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>LIN RX mode Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>LIN RX mode Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>LIN_TX_EN</name>
              <description>LIN TX Break Mode Enable Bit\nNote: When TX break field transfer operation finished, this bit will be cleared automatically.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>LIN TX Break mode Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>LIN TX Break mode Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RS485_NMM</name>
              <description>RS-485 Normal Multi-Drop Operation Mode (NMM) \nNote: It cannot be active with RS-485_AAD operation mode.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RS-485 Normal Multi-drop Operation mode (NMM) Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RS-485 Normal Multi-drop Operation mode (NMM) Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RS485_AAD</name>
              <description>RS-485 Auto Address Detection Operation Mode (AAD)\nNote: It cannot be active with RS-485_NMM operation mode.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RS-485 Auto Address Detection Operation mode (AAD) Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RS-485 Auto Address Detection Operation mode (AAD) Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RS485_AUD</name>
              <description>RS-485 Auto Direction Mode (AUD) \nNote: It can be active with RS-485_AAD or RS-485_NMM operation mode.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RS-485 Auto Direction Operation mode (AUO) Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RS-485 Auto Direction Operation mode (AUO) Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RS485_ADD_EN</name>
              <description>RS-485 Address Detection Enable Bit\nThis bit is used to enable RS-485 Address Detection mode. \nNote: This bit is used for RS-485 any operation mode.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Address detection mode Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Address detection mode Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ADDR_MATCH</name>
              <description>Address Match Value Register \nThis field contains the RS-485 address match values.\nNote: This field is used for RS-485 auto address detection mode.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UA_FUN_SEL</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UA_FUN_SEL</displayName>
          <description>UART Function Select Register</description>
          <addressOffset>0x30</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>FUN_SEL</name>
              <description>Function Select Enable Bit\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>UART function Enabled</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>LIN function Enabled</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>IrDA function Enabled</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>RS-485 function Enabled</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UA_LIN_CTL</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UA_LIN_CTL</displayName>
          <description>UART LIN Control Register</description>
          <addressOffset>0x34</addressOffset>
          <access>read-write</access>
          <resetValue>0x000C0000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>LINS_EN</name>
              <description>LIN Slave Mode Enable Bit\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>LIN slave mode Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>LIN slave mode Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>LINS_HDET_EN</name>
              <description>LIN Slave Header Detection Enable Bit\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>LIN slave header detection Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>LIN slave header detection Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>LINS_ARS_EN</name>
              <description>LIN Slave Automatic Resynchronization Mode Enable Bit\nNote2: When operation in Automatic Resynchronization mode, the baud rate setting must be mode2 (BAUD_M1 (UA_BAUD [29]) and BAUD_M0 (UA_BAUD [28]) must be 1).\nNote3: The control and interactions of this field are explained in 6.13.5.8.4. (Slave mode with automatic resynchronization).</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>LIN automatic resynchronization Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>LIN automatic resynchronization Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>LINS_DUM_EN</name>
              <description>LIN Slave Divider Update Method Enable Bit\nNote2: This bit used for LIN Slave Automatic Resynchronization mode. (for Non-Automatic Resynchronization mode, this bit should be kept cleared) \nNote3: The control and interactions of this field are explained in 6.13.5.8.4. (Slave mode with automatic resynchronization).</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>UA_BAUD updated is written by software (if no automatic resynchronization update occurs at the same time)</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>UA_BAUD is updated at the next received character. User must set the bit before checksum reception</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>LIN_MUTE_EN</name>
              <description>LIN Mute Mode Enable Bit\nNote: The exit from mute mode condition and each control and interactions of this field are explained in (LIN slave mode).</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>LIN mute mode Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>LIN mute mode Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>LIN_SHD</name>
              <description>LIN TX Send Header Enable Bit\nThe LIN TX header can be "break field" or "break and sync field" or "break, sync and frame ID field", it is depend on setting LIN_HEAD_SEL (UA_LIN_CTL[23:22]).\nNote1: These registers are shadow registers of LIN_SHD (UA_ALT_CSR [7]); user can read/write it by setting LIN_SHD (UA_ALT_CSR [7]) or LIN_SHD (UA_LIN_CTL [8]).\nNote2: When transmitter header field (it may be "break" or "break + sync" or "break + sync + frame ID" selected by LIN_HEAD_SEL (UA_LIN_CTL[23:22]) field) transfer operation finished, this bit will be cleared automatically.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Send LIN TX header Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Send LIN TX header Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>LIN_IDPEN</name>
              <description>LIN ID Parity Enable Bit\n</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>LIN frame ID parity Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>LIN frame ID parity Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>LIN_BKDET_EN</name>
              <description>LIN Break Detection Enable Bit\n</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>LIN break detection Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>LIN break detection Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>LIN_RX_DIS</name>
              <description>LIN Receiver Disable Bit\n</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>LIN receiver Enabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>LIN receiver Disabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BIT_ERR_EN</name>
              <description>Bit Error Detect Enable Bit\n</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Bit error detection function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Bit error detection Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>LIN_BKFL</name>
              <description>LIN Break Field Length\nThis field indicates a 4-bit LIN TX break field count.\nNote1: These registers are shadow registers of LIN_BKFL, User can read/write it by setting LIN_BKFL (UA_ALT_CSR[3:0]) or LIN_BKFL (UA_LIN_CTL[19:16].\nNote2: This break field length is LIN_BKFL + 1.\n</description>
              <bitOffset>16</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>LIN_BS_LEN</name>
              <description>LIN Break/Sync Delimiter Length\n\nNote: This bit used for LIN master to sending header field.</description>
              <bitOffset>20</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The LIN break/sync delimiter length is 1 bit time</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>The LIN break/sync delimiter length is 2 bit time.\nThe LIN break/sync delimiter length is 3 bit time</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>The LIN break/sync delimiter length is 4 bit time</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>LIN_HEAD_SEL</name>
              <description>LIN Header Select\n</description>
              <bitOffset>22</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The LIN header includes "break field"</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The LIN header includes "break field" and "sync field"</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>The LIN header includes "break field", "sync field" and "frame ID field"</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Reserved</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>LIN_PID</name>
              <description>LIN PID Register\nIf the parity generated by hardware, user fill ID0~ID5, (LIN_PID [29:24] )hardware will calculate P0 (LIN_PID[30]) and P1 (LIN_PID[31]), otherwise user must filled frame ID and parity in this field.\n\nNote1: User can fill any 8-bit value to this field and the bit 24 indicates ID0 (LSB first).\nNote2: This field can be used for LIN master mode or slave mode.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UA_LIN_SR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UA_LIN_SR</displayName>
          <description>UART LIN Status Register</description>
          <addressOffset>0x38</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>LINS_HDET_F</name>
              <description>LIN Slave Header Detection Flag (Read Only)\nThis bit is set by hardware when a LIN header is detected in LIN slave mode and be cleared by writing 1 to it.\nNote3: When enable ID parity check LIN_IDPEN (UA_LIN_CTL [9]), if hardware detect complete header ("break + sync + frame ID"), the LINS_HEDT_F will be set whether the frame ID correct or not.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>LIN header not detected</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>LIN header detected (break + sync + frame ID)</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>LINS_HERR_F</name>
              <description>LIN Slave Header Error Flag (Read Only)\nThis bit is set by hardware when a LIN header error is detected in LIN slave mode and be cleared by writing 1 to it. The header errors include "break delimiter is too short (less than 0.5 bit time)", "frame error in sync field or Identifier field", "sync field data is not 0x55 in Non-Automatic Resynchronization mode", "sync field deviation error with Automatic Resynchronization mode", "sync field measure time-out with Automatic Resynchronization mode" and "LIN header reception time-out".\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>LIN header error not detected</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>LIN header error detected</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>LINS_IDPERR_F</name>
              <description>LIN Slave ID Parity Error Flag (Read Only)\nThis bit is set by hardware when receipted frame ID parity is not correct.\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No active</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Receipted frame ID parity is not correct</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>LINS_SYNC_F</name>
              <description>LIN Slave Sync Field\nThis bit indicates that the LIN sync field is being analyzed in Automatic Resynchronization mode. When the receiver header have some error been detect, user must reset the internal circuit to re-search new frame header by writing 1 to this bit.\nNote2: This bit is read only, but it can be cleared by writing 1 to it.\nNote3: When writing 1 to it, hardware will reload the initial baud rate and re-search a new frame header.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The current character is not at LIN sync state</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The current character is at LIN sync state</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>LIN_BKDET_F</name>
              <description>LIN Break Detection Flag (Read Only)\nThis bit is set by hardware when a break is detected and be cleared by writing 1 to it through software.\n</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>LIN break not detected</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>LIN break detected</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>BIT_ERR_F</name>
              <description>Bit Error Detect Status Flag (Read Only)\nAt TX transfer state, hardware will monitoring the bus state, if the input pin (SIN) state not equals to the output pin (SOUT) state, BIT_ERR_F (UA_LIN_SR[9]) will be set.\n</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>UART2</name>
      <description>UART Register Map</description>
      <groupName>UART</groupName>
      <baseAddress>0x40154000</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x0</offset>
        <size>0x10</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x18</offset>
        <size>0x24</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>UA_RBR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UA_RBR</displayName>
          <description>UART Receive Buffer Register</description>
          <addressOffset>0x0</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>RBR</name>
              <description>Receive Buffer Register (Read Only)\nBy reading this register, the UART will return the 8-bit data received from RX pin (LSB first).</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UA_THR</name>
          <alternateRegister>UA_RBR</alternateRegister>
          <!-- the display name is an unrestricted string. -->
          <displayName>UA_THR</displayName>
          <description>UART Transmit Holding Register</description>
          <addressOffset>0x0</addressOffset>
          <access>write-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>THR</name>
              <description>Transmit Holding Register\nBy writing one byte to this register, the data byte will be stored in transmitter FIFO. The UART Controller will send out the data stored in transmitter FIFO top location through the TX pin.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UA_IER</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UA_IER</displayName>
          <description>UART Interrupt Enable Register</description>
          <addressOffset>0x4</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RDA_IEN</name>
              <description>Receive Data Available Interrupt Enable Bit\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RDA_INT Masked off</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RDA_INT Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>THRE_IEN</name>
              <description>Transmit Holding Register Empty Interrupt Enable Bit\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>THRE_INT Masked off</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>THRE_INT Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RLS_IEN</name>
              <description>Receive Line Status Interrupt Enable Bit\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RLS_INT Masked off</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RLS_INT Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>MODEM_IEN</name>
              <description>Modem Status Interrupt Enable Bit (Not Available In UART2 Channel)\n</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>MODEM_INT Masked off</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>MODEM_INT Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TOUT_IEN</name>
              <description>RX Time-Out Interrupt Enable Bit\n</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>TOUT_INT Masked off</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>TOUT_INT Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BUF_ERR_IEN</name>
              <description>Buffer Error Interrupt Enable Bit\n</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>BUF_ERR_INT Masked off</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>BUF_ERR_INT Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>WAKE_EN</name>
              <description>UART Wake-Up Function Enable Bit (Not Available In UART2 Channel)\n</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>UART wake-up function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>UART wake-up function Enabled, when the chip is in Power-down mode, an external CTS change will wake-up chip from Power-down mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>LIN_IEN</name>
              <description>LIN Bus Interrupt Enable Bit\nNote: This field is used for LIN function mode.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Lin bus interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Lin bus interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TIME_OUT_EN</name>
              <description>Time-Out Counter Enable Bit\n</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Time-out counter Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Time-out counter Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>AUTO_RTS_EN</name>
              <description>RTS Auto Flow Control Enable Bit (Not Available In UART2 Channel)\nWhen RTS auto-flow is enabled, if the number of bytes in the RX FIFO equals the RTS_TRI_LEV (UA_FCR [19:16]), the UART will de-assert RTS signal.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RTS auto flow control Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RTS auto flow control Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>AUTO_CTS_EN</name>
              <description>CTS Auto Flow Control Enable Bit (Not Available In UART2 Channel)\nWhen CTS auto-flow is enabled, the UART will send data to external device when CTS input assert (UART will not send data to device until CTS is asserted).</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>CTS auto flow control Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>CTS auto flow control Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DMA_TX_EN</name>
              <description>TX DMA Enable Bit (Not Available In UART2 Channel)\nThis bit can enable or disable TX DMA service.\n</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>TX DMA Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>TX DMA Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DMA_RX_EN</name>
              <description>RX DMA Enable Bit (Not Available In UART2 Channel)\nThis bit can enable or disable RX DMA service.\n</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RX DMA Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RX DMA Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UA_FCR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UA_FCR</displayName>
          <description>UART FIFO Control Register</description>
          <addressOffset>0x8</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000101</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RFR</name>
              <description>RX Field Software Reset\nWhen RFR is set, all the byte in the receiver FIFO and RX internal state machine are cleared.\nNote: This bit will automatically clear at least 3 UART peripherial clock cycles.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reset the RX internal state machine and pointers</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TFR</name>
              <description>TX Field Software Reset\nWhen TFR is set, all the byte in the transmit FIFO and TX internal state machine are cleared.\nNote: This bit will automatically clear at least 3 UART peripherial clock cycles.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reset the TX internal state machine and pointers</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RFITL</name>
              <description>RX FIFO Interrupt (INT_RDA) Trigger Level\nWhen the number of bytes in the receive FIFO equals the RFITL, the RDA_IF will be set (if UA_IER [RDA_IEN] enabled, and an interrupt will be generated).\n</description>
              <bitOffset>4</bitOffset>
              <bitWidth>4</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RX FIFO Interrupt Trigger Level is 1 byte</description>
                    <value>#0000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RX FIFO Interrupt Trigger Level is 4 bytes</description>
                    <value>#0001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>RX FIFO Interrupt Trigger Level is 8 bytes</description>
                    <value>#0010</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>RX FIFO Interrupt Trigger Level is 14 bytes</description>
                    <value>#0011</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>4</name>
                    <description>RX FIFO Interrupt Trigger Level is 30/14 bytes (High Speed/Normal Speed)</description>
                    <value>#0100</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>5</name>
                    <description>RX FIFO Interrupt Trigger Level is 46/14 bytes (High Speed/Normal Speed)</description>
                    <value>#0101</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>6</name>
                    <description>RX FIFO Interrupt Trigger Level is 62/14 bytes (High Speed/Normal Speed)</description>
                    <value>#0110</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_DIS</name>
              <description>Receiver Disable Bit\nThe receiver is disabled or not (set 1 to disable receiver)\nNote: This field is used for RS-485 Normal Multi-drop mode. It should be programmed before UA_ALT_CSR [RS-485_NMM] is programmed.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Receiver Enabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Receiver Disabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RTS_TRI_LEV</name>
              <description>RTS Trigger Level For Auto-Flow Control Use (Not Available In UART2 Channel)\nNote: This field is used for RTS auto-flow control.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>4</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RTS Trigger Level is 1 byte</description>
                    <value>#0000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RTS Trigger Level is 4 bytes</description>
                    <value>#0001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>RTS Trigger Level is 8 bytes</description>
                    <value>#0010</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>RTS Trigger Level is 14 bytes</description>
                    <value>#0011</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>4</name>
                    <description>RTS Trigger Level is 30/14 bytes (High Speed/Normal Speed)</description>
                    <value>#0100</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>5</name>
                    <description>RTS Trigger Level is 46/14 bytes (High Speed/Normal Speed)</description>
                    <value>#0101</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>6</name>
                    <description>RTS Trigger Level is 62/14 bytes (High Speed/Normal Speed)</description>
                    <value>#0110</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UA_LCR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UA_LCR</displayName>
          <description>UART Line Control Register</description>
          <addressOffset>0xC</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WLS</name>
              <description>Word Length Selection\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Word length is 5-bit</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Word length is 6-bit</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Word length is 7-bit</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Word length is 8-bit</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>NSB</name>
              <description>Number Of "STOP Bit"\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>One " STOP bit" is generated in the transmitted data</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>When select 5-bit word length, 1.5 "STOP bit" is generated in the transmitted data. When select 6-,7- and 8-bti word length, 2 "STOP bit" is generated in the transmitted data</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PBE</name>
              <description>Parity Bit Enable Bit\n</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No parity bit</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Parity bit is generated on each outgoing character and is checked on each incoming data</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>EPE</name>
              <description>Even Parity Enable Bit\nThis bit has effect only when PBE (UA_LCR[3]) is set.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Odd number of logic 1's is transmitted and checked in each word</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Even number of logic 1's is transmitted and checked in each word</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SPE</name>
              <description>Stick Parity Enable Bit\n</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Stick parity Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>If PBE (UA_LCR[3]) and EBE (UA_LCR[4]) are logic 1, the parity bit is transmitted and checked as logic 0. If PBE (UA_LCR[3]) is 1 and EBE (UA_LCR[4]) is 0 then the parity bit is transmitted and checked as 1</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BCB</name>
              <description>Break Control Bit\nWhen this bit is set to logic 1, the serial data output (TX) is forced to the Spacing State (logic 0). This bit acts only on TX and has no effect on the transmitter logic.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UA_FSR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UA_FSR</displayName>
          <description>UART FIFO Status Register</description>
          <addressOffset>0x18</addressOffset>
          <access>read-write</access>
          <resetValue>0x10404000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RX_OVER_IF</name>
              <description>RX Overflow Error IF (Read Only)\nThis bit is set when RX FIFO overflow.\nIf the number of bytes of received data is greater than RX_FIFO (UA_RBR) size, 64/16/16 bytes of UART0/UART1/UART2, this bit will be set.\nNote: This bit is read only, but can be cleared by writing "1" to it.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RX FIFO is not overflow</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RX FIFO is overflow</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>RS485_ADD_DETF</name>
              <description>RS-485 Address Byte Detection Flag (Read Only) \nNote1: This field is used for RS-485 function mode and RS485_ADD_EN (UA_ALT_CSR[15]) is set to 1 to enable Address detection mode.\nNote2: This bit is read only, but can be cleared by writing '1' to it.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Receiver detects a data that is not an address bit (bit 9 ='1')</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Receiver detects a data that is an address bit (bit 9 ='1')</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>PEF</name>
              <description>Parity Error Flag (Read Only)\nThis bit is set to logic 1 whenever the received character does not have a valid "parity bit", and is reset whenever the CPU writes 1 to this bit.\nNote: This bit is read only, but can be cleared by writing "1" to it.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No parity error is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Parity error is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>FEF</name>
              <description>Framing Error Flag (Read Only)\nThis bit is set to logic 1 whenever the received character does not have a valid "stop bit" (that is, the stop bit following the last data bit or parity bit is detected as logic 0), and is reset whenever the CPU writes 1 to this bit.\nNote: This bit is read only, but can be cleared by writing "1" to it.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No framing error is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Framing error is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>BIF</name>
              <description>Break Interrupt Flag (Read Only)\nThis bit is set to logic 1 whenever the received data input(RX) is held in the "spacing state" (logic 0) for longer than a full word transmission time (that is, the total time of "start bit" + data bits + parity + stop bits) and is reset whenever the CPU writes 1 to this bit.\nNote: This bit is read only, but can be cleared by writing "1" to it.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No Break interrupt is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Break interrupt is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>RX_POINTER</name>
              <description>RX FIFO Pointer (Read Only)\nThis field indicates the RX FIFO Buffer Pointer. When UART receives one byte from external device, then RX_POINTER increases one. When one byte of RX FIFO is read by CPU, then RX_POINTER decreases one.\nThe Maximum value shown in RX_POINTER is 63/15/15 (UART0/UART1/UART2). When the using level of RX FIFO Buffer equal to 64/16/16, the RX_FULL bit is set to 1 and RX_POINTER will show 0. As one byte of RX FIFO is read by CPU, the RX_FULL bit is cleared to 0 and RX_POINTER will show 63/15/15 (UART0/UART1/UART2).</description>
              <bitOffset>8</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RX_EMPTY</name>
              <description>Receiver FIFO Empty (Read Only)\nThis bit initiate RX FIFO empty or not.\nNote: When the last byte of RX FIFO has been read by CPU, hardware sets this bit high. It will be cleared when UART receives any new data.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RX FIFO is not empty</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RX FIFO is empty</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>RX_FULL</name>
              <description>Receiver FIFO Full (Read Only)\nThis bit initiates RX FIFO is full or not.\nNote: This bit is set when the number of usage in RX FIFO Buffer is equal to 64/16/16(UART0/UART1/UART2), otherwise is cleared by hardware.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RX FIFO is not full</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RX FIFO is full</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>TX_POINTER</name>
              <description>TX FIFO Pointer (Read Only)\nThis field indicates the TX FIFO Buffer Pointer. When CPU writes one byte into UA_THR, then TX_POINTER increases one. When one byte of TX FIFO is transferred to Transmitter Shift Register, then TX_POINTER decreases one.\nThe Maximum value shown in TX_POINTER is 63/15/15 (UART0/UART1/UART2). When the using level of TX FIFO Buffer equal to 64/16/16, the TX_FULL bit is set to 1 and TX_POINTER will show 0. As one byte of TX FIFO is transferred to Transmitter Shift Register, the TX_FULL bit is cleared to 0 and TX_POINTER will show 63/15/15 (UART0/UART1/UART2).</description>
              <bitOffset>16</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TX_EMPTY</name>
              <description>Transmitter FIFO Empty (Read Only)\nThis bit indicates TX FIFO empty or not.\nNote: When the last byte of TX FIFO has been transferred to Transmitter Shift Register, hardware sets this bit high. It will be cleared when writing data into THR (TX FIFO not empty).</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>TX FIFO is not empty</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>TX FIFO is empty</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>TX_FULL</name>
              <description>Transmitter FIFO Full (Read Only)\nThis bit indicates TX FIFO full or not.\nThis bit is set when the number of usage in TX FIFO Buffer is equal to 64/16/16(UART0/UART1/UART2), otherwise is cleared by hardware.</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>TX FIFO is not full</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>TX FIFO is full</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>TX_OVER_IF</name>
              <description>TX Overflow Error Interrupt Flag (Read Only)\nIf TX FIFO (UA_THR) is full, an additional write to UA_THR will cause this bit to logic 1.\nNote: This bit is read only, but can be cleared by writing "1" to it.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>TX FIFO is not overflow</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>TX FIFO is overflow</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>TE_FLAG</name>
              <description>Transmitter Empty Flag (Read Only)\nThis bit is set by hardware when TX FIFO (UA_THR) is empty and the STOP bit of the last byte has been transmitted.\nNote: This bit is cleared automatically when TX FIFO is not empty or the last byte transmission has not completed.</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>TX FIFO is not empty</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>TX FIFO is empty</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UA_ISR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UA_ISR</displayName>
          <description>UART Interrupt Status Register</description>
          <addressOffset>0x1C</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000002</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RDA_IF</name>
              <description>Receive Data Available Interrupt Flag (Read Only)\nWhen the number of bytes in the RX FIFO equals the RFITL then the RDA_IF(UA_ISR[0]) will be set. If RDA_IEN (UA_IER [0]) is enabled, the RDA interrupt will be generated.\nNote: This bit is read only and it will be cleared when the number of unread bytes of RX FIFO drops below the threshold level (RFITL(UA_FCR[7:4]).</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No RDA interrupt flag is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RDA interrupt flag is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>THRE_IF</name>
              <description>Transmit Holding Register Empty Interrupt Flag (Read Only) \nThis bit is set when the last data of TX FIFO is transferred to Transmitter Shift Register. If THRE_IEN (UA_IER[1]) is enabled, the THRE interrupt will be generated.\nNote: This bit is read only and it will be cleared when writing data into THR (TX FIFO not empty).</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No THRE interrupt flag is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>THRE interrupt flag is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>RLS_IF</name>
              <description>Receive Line Interrupt Flag (Read Only)  \nThis bit is set when the RX receive data have parity error, frame error or break error (at least one of 3 bits, BIF(UA_FSR[6]), FEF(UA_FSR[5]) and PEF(UA_FSR[4]), is set). If RLS_IEN (UA_IER [2]) is enabled, the RLS interrupt will be generated.\nNote2: This bit is read only and reset to 0 when all bits of BIF(UA_FSR[6]), FEF(UA_FSR[5]) and PEF(UA_FSR[4]) are cleared.\nNote3: In RS-485 function mode, this bit is read only and reset to 0 when all bits of BIF(UA_FSR[6]) , FEF(UA_FSR[5]) and PEF(UA_FSR[4]) and RS485_ADD_DETF (UA_FSR[3]) are cleared.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No RLS interrupt flag is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RLS interrupt flag is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>MODEM_IF</name>
              <description>MODEM Interrupt Flag (Read Only) (Not Available In UART2 Channel)\nNote: This bit is read only and reset to 0 when bit DCTSF is cleared by a write 1 on DCTSF(UA_MSR[0]).</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No Modem interrupt flag is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Modem interrupt flag is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>TOUT_IF</name>
              <description>Time-Out Interrupt Flag (Read Only)\nThis bit is set when the RX FIFO is not empty and no activities occurred in the RX FIFO and the time-out counter equal to TOIC. If TOUT_IEN (UA_IER [4]) is enabled, the Tout interrupt will be generated.\nNote: This bit is read only and user can read UA_RBR (RX is in active) to clear it</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No Time-out interrupt flag is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Time-out interrupt flag is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>BUF_ERR_IF</name>
              <description>Buffer Error Interrupt Flag (Read Only)\nThis bit is set when the TX FIFO or RX FIFO overflows (TX_OVER_IF (UA_FSR[24]) or RX_OVER_IF (UA_FSR[0]) is set). When BUF_ERR_IF (UA_ISR[5])is set, the transfer is not correct. If BUF_ERR_IEN (UA_IER [8]) is enabled, the buffer error interrupt will be generated.\nNote: This bit is read only and reset to 0 when all bits of TX_OVER_IF(UA_FSR[24]) and RX_OVER_IF(UA_FSR[0]) are cleared.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No buffer error interrupt flag is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Buffer error interrupt flag is generated.0 = No buffer error interrupt flag is generated.\nBuffer error interrupt flag is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>LIN_IF</name>
              <description>LIN Bus Flag (Read Only)\nNote: This bit is read only. This bit is cleared when LINS_HDET_F(UA_LIN_SR[0]), LIN_BKDET_F(UA_LIN_SR[9]), BIT_ERR_F(UA_LIN_SR[9]), LINS_IDPENR_F (UA_LIN_SR[2]) and LINS_HERR_F(UA_LIN_SR[1]) all are cleared.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>None of LINS_HDET_F, LIN_BKDET_F, BIT_ERR_F, LINS_IDPERR_F and LINS_HERR_F is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>At least one of LINS_HDET_F, LIN_BKDET_F, BIT_ERR_F, LINS_IDPERR_F and LINS_HERR_F is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>RDA_INT</name>
              <description>Receive Data Available Interrupt Indicator (Read Only)\nThis bit is set if RDA_IEN (UA_IER[0]) and RDA_IF (UA_ISR[0]) are both set to 1.\n</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No RDA interrupt is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RDA interrupt is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>THRE_INT</name>
              <description>Transmit Holding Register Empty Interrupt Indicator (Read Only)\nThis bit is set if THRE_IEN (UA_IER[1])and THRE_IF(UA_SR[1]) are both set to 1.\n</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No THRE interrupt is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>THRE interrupt is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>RLS_INT</name>
              <description>Receive Line Status Interrupt Indicator (Read Only) \nThis bit is set if RLS_IEN (UA_IER[2]) and RLS_IF(UA_ISR[2]) are both set to 1.\n</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No RLS interrupt is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RLS interrupt is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>MODEM_INT</name>
              <description>MODEM Status Interrupt Indicator (Read Only) (Not Available In UART2 Channel)\nThis bit is set if MODEM_IEN(UA_IER[3] and MODEM_IF(UA_ISR[4]) are both set to 1\n</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No Modem interrupt is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Modem interrupt is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>TOUT_INT</name>
              <description>Time-Out Interrupt Indicator (Read Only)\nThis bit is set if TOUT_IEN(UA_IER[4]) and TOUT_IF(UA_ISR[4]) are both set to 1.\n</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No Tout interrupt is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Tout interrupt is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>BUF_ERR_INT</name>
              <description>Buffer Error Interrupt Indicator (Read Only)\nThis bit is set if BUF_ERR_IEN(UA_IER[5] and BUF_ERR_IF(UA_ISR[5]) are both set to 1.\n</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No buffer error interrupt is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Buffer error interrupt is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>LIN_INT</name>
              <description>LIN Bus Interrupt Indicator (Read Only)\nThis bit is set if LIN_IEN (UA_IER[8]) and LIN _IF(UA_ISR[7]) are both set to 1.\n</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No LIN Bus interrupt is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The LIN Bus interrupt is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>HW_RLS_IF</name>
              <description>In DMA Mode, Receive Line Status Flag (Read Only)\nThis bit is set when the RX receive data have parity error, frame error or break error (at least one of 3 bits, BIF (UA_FSR[6]), FEF (UA_FSR[5]) and PEF (UA_FSR[4]) is set). If RLS_IEN (UA_IER [2]) is enabled, the RLS interrupt will be generated.\nNote2: In UART function mode, this bit is read only and reset to 0 when all bits of BIF(UA_FSR[6]) , FEF(UA_FSR[5]) and PEF(UA_FSR[4]) are cleared. \nNote3: In RS-485 function mode, this bit is read only and reset to 0 when all bits of BIF(UA_FSR[6]) , FEF(UA_FSR[5]) and PEF(UA_FSR[4]) and  RS485_ADD_DETF (UA_FSR[3]) are cleared.</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No RLS interrupt flag is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RLS interrupt flag is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>HW_MODEM_IF</name>
              <description>In DMA Mode, MODEM Interrupt Flag (Read Only) (Not Available In UART2 Channel)\nNote: This bit is read only and reset to 0 when the bit DCTSF(US_MSR[0]) is cleared by writing 1 on DCTSF (US_MSR[0]).</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No Modem interrupt flag is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Modem interrupt flag is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>HW_TOUT_IF</name>
              <description>In DMA Mode, Time-Out Interrupt Flag (Read Only)\nThis bit is set when the RX FIFO is not empty and no activities occurred in the RX FIFO and the time-out counter equal to TOIC (UA_TOR[7:0]). If TOUT_IEN (UA_IER [4]) is enabled, the Tout interrupt will be generated. \nNote: This bit is read only and user can read UA_RBR (RX is in active) to clear it.</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No Time-out interrupt flag is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Time-out interrupt flag is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>HW_BUF_ERR_IF</name>
              <description>In DMA Mode, Buffer Error Interrupt Flag (Read Only)\nThis bit is set when the TX or RX FIFO overflows (TX_OVER_IF (UA__FSR[24]) or RX_OVER_IF (UA_FSR[0])  is set). When BUF_ERR_IF (UA_ISR[5]) is set, the transfer maybe is not correct. If BUF_ERR_IEN (UA_IER [5]) is enabled, the buffer error interrupt will be generated.\nNote: This bit is cleared when both TX_OVER_IF (UA_FSR[24]]) and RX_OVER_IF (UA_FSR[0]) are cleared.</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No buffer error interrupt flag is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Buffer error interrupt flag is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>HW_RLS_INT</name>
              <description>In DMA Mode, Receive Line Status Interrupt Indicator (Read Only)\nThis bit is set if RLS_IEN (UA_IER[2])and HW_RLS_IF(UA_ISR[18]) are both set to 1.\n</description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No RLS interrupt is generated in DMA mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RLS interrupt is generated in DMA mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>HW_MODEM_INT</name>
              <description>In DMA Mode, MODEM Status Interrupt Indicator (Read Only) (Not Available In UART2 Channel)\nThis bit is set if MODEM_IEN(UA_IER[3]) and HW_MODEM_IF(UA_ ISR[3]) are both set to 1.\n</description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No Modem interrupt is generated in DMA mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Modem interrupt is generated in DMA mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>HW_TOUT_INT</name>
              <description>In DMA Mode, Time-Out Interrupt Indicator (Read Only)\nThis bit is set if TOUT_IEN (UA_IER[4])and HW_TOUT_IF(UA_ISR[20]) are both set to 1.\n</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No Tout interrupt is generated in DMA mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Tout interrupt is generated in DMA mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>HW_BUF_ERR_INT</name>
              <description>In DMA Mode, Buffer Error Interrupt Indicator (Read Only)\nThis bit is set if BUF_ERR_IEN (UA_IER[5]) and HW_BUF_ERR_IF (UA_ISR[5])are both set to 1.\n</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No buffer error interrupt is generated in DMA mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Buffer error interrupt is generated in DMA mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UA_TOR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UA_TOR</displayName>
          <description>UART Time-out Register</description>
          <addressOffset>0x20</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TOIC</name>
              <description>Time-Out Interrupt Comparator\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DLY</name>
              <description>TX Delay Time Value \nThis field is used to programming the transfer delay time between the last stop bit and next start bit.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UA_BAUD</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UA_BAUD</displayName>
          <description>UART Baud Rate Divisor Register</description>
          <addressOffset>0x24</addressOffset>
          <access>read-write</access>
          <resetValue>0x0F000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BRD</name>
              <description>Baud Rate Divider\nThe field indicates the baud rate divider</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DIVIDER_X</name>
              <description>Divider X\n</description>
              <bitOffset>24</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DIV_X_ONE</name>
              <description>Divider X Equal To 1\nRefer to Table 612 for more information.</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Divider M = X (the equation of M = X+1, but DIVIDER_X[27:24] must  = 8)</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Divider M = 1 (the equation of M = 1, but BRD [15:0] must  = 3)</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DIV_X_EN</name>
              <description>Divider X Enable Bit\nRefer to Table 612 for more information.\nNote: In IrDA mode, this bit must disable.</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Divider X Disabled (the equation of M = 16)</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Divider X Enabled (the equation of M = X+1, but DIVIDER_X [27:24] must  = 8)</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UA_IRCR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UA_IRCR</displayName>
          <description>UART IrDA Control Register</description>
          <addressOffset>0x28</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000040</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TX_SELECT</name>
              <description>TX_SELECT\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>IrDA Transmitter Disabled and Receiver Enabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>IrDA Transmitter Enabled and Receiver Disabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>INV_TX</name>
              <description>IrDA Inverse Transmitting Output Signal Control\n</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>None inverse transmitting signal</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Inverse transmitting output signal</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>INV_RX</name>
              <description>IrDA Inverse Receive Input Signal Control\n</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>None inverse receiving input signal</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Inverse receiving input signal</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UA_ALT_CSR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UA_ALT_CSR</displayName>
          <description>UART Alternate Control/Status Register</description>
          <addressOffset>0x2C</addressOffset>
          <access>read-write</access>
          <resetValue>0x0000000C</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>LIN_BKFL</name>
              <description>UART LIN Break Field Length\nThis field indicates a 4-bit LIN TX break field count.\nNote1: This break field length is UA_LIN_BKFL + 1\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>LIN_RX_EN</name>
              <description>LIN RX Enable Bit\n</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>LIN RX mode Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>LIN RX mode Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>LIN_TX_EN</name>
              <description>LIN TX Break Mode Enable Bit\nNote: When TX break field transfer operation finished, this bit will be cleared automatically.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>LIN TX Break mode Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>LIN TX Break mode Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RS485_NMM</name>
              <description>RS-485 Normal Multi-Drop Operation Mode (NMM) \nNote: It cannot be active with RS-485_AAD operation mode.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RS-485 Normal Multi-drop Operation mode (NMM) Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RS-485 Normal Multi-drop Operation mode (NMM) Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RS485_AAD</name>
              <description>RS-485 Auto Address Detection Operation Mode (AAD)\nNote: It cannot be active with RS-485_NMM operation mode.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RS-485 Auto Address Detection Operation mode (AAD) Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RS-485 Auto Address Detection Operation mode (AAD) Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RS485_AUD</name>
              <description>RS-485 Auto Direction Mode (AUD) \nNote: It can be active with RS-485_AAD or RS-485_NMM operation mode.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RS-485 Auto Direction Operation mode (AUO) Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RS-485 Auto Direction Operation mode (AUO) Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RS485_ADD_EN</name>
              <description>RS-485 Address Detection Enable Bit\nThis bit is used to enable RS-485 Address Detection mode. \nNote: This bit is used for RS-485 any operation mode.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Address detection mode Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Address detection mode Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ADDR_MATCH</name>
              <description>Address Match Value Register \nThis field contains the RS-485 address match values.\nNote: This field is used for RS-485 auto address detection mode.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UA_FUN_SEL</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UA_FUN_SEL</displayName>
          <description>UART Function Select Register</description>
          <addressOffset>0x30</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>FUN_SEL</name>
              <description>Function Select Enable Bit\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>UART function Enabled</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>LIN function Enabled</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>IrDA function Enabled</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>RS-485 function Enabled</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UA_LIN_CTL</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UA_LIN_CTL</displayName>
          <description>UART LIN Control Register</description>
          <addressOffset>0x34</addressOffset>
          <access>read-write</access>
          <resetValue>0x000C0000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>LINS_EN</name>
              <description>LIN Slave Mode Enable Bit\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>LIN slave mode Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>LIN slave mode Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>LINS_HDET_EN</name>
              <description>LIN Slave Header Detection Enable Bit\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>LIN slave header detection Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>LIN slave header detection Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>LINS_ARS_EN</name>
              <description>LIN Slave Automatic Resynchronization Mode Enable Bit\nNote2: When operation in Automatic Resynchronization mode, the baud rate setting must be mode2 (BAUD_M1 (UA_BAUD [29]) and BAUD_M0 (UA_BAUD [28]) must be 1).\nNote3: The control and interactions of this field are explained in 6.13.5.8.4. (Slave mode with automatic resynchronization).</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>LIN automatic resynchronization Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>LIN automatic resynchronization Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>LINS_DUM_EN</name>
              <description>LIN Slave Divider Update Method Enable Bit\nNote2: This bit used for LIN Slave Automatic Resynchronization mode. (for Non-Automatic Resynchronization mode, this bit should be kept cleared) \nNote3: The control and interactions of this field are explained in 6.13.5.8.4. (Slave mode with automatic resynchronization).</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>UA_BAUD updated is written by software (if no automatic resynchronization update occurs at the same time)</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>UA_BAUD is updated at the next received character. User must set the bit before checksum reception</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>LIN_MUTE_EN</name>
              <description>LIN Mute Mode Enable Bit\nNote: The exit from mute mode condition and each control and interactions of this field are explained in (LIN slave mode).</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>LIN mute mode Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>LIN mute mode Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>LIN_SHD</name>
              <description>LIN TX Send Header Enable Bit\nThe LIN TX header can be "break field" or "break and sync field" or "break, sync and frame ID field", it is depend on setting LIN_HEAD_SEL (UA_LIN_CTL[23:22]).\nNote1: These registers are shadow registers of LIN_SHD (UA_ALT_CSR [7]); user can read/write it by setting LIN_SHD (UA_ALT_CSR [7]) or LIN_SHD (UA_LIN_CTL [8]).\nNote2: When transmitter header field (it may be "break" or "break + sync" or "break + sync + frame ID" selected by LIN_HEAD_SEL (UA_LIN_CTL[23:22]) field) transfer operation finished, this bit will be cleared automatically.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Send LIN TX header Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Send LIN TX header Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>LIN_IDPEN</name>
              <description>LIN ID Parity Enable Bit\n</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>LIN frame ID parity Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>LIN frame ID parity Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>LIN_BKDET_EN</name>
              <description>LIN Break Detection Enable Bit\n</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>LIN break detection Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>LIN break detection Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>LIN_RX_DIS</name>
              <description>LIN Receiver Disable Bit\n</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>LIN receiver Enabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>LIN receiver Disabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BIT_ERR_EN</name>
              <description>Bit Error Detect Enable Bit\n</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Bit error detection function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Bit error detection Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>LIN_BKFL</name>
              <description>LIN Break Field Length\nThis field indicates a 4-bit LIN TX break field count.\nNote1: These registers are shadow registers of LIN_BKFL, User can read/write it by setting LIN_BKFL (UA_ALT_CSR[3:0]) or LIN_BKFL (UA_LIN_CTL[19:16].\nNote2: This break field length is LIN_BKFL + 1.\n</description>
              <bitOffset>16</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>LIN_BS_LEN</name>
              <description>LIN Break/Sync Delimiter Length\n\nNote: This bit used for LIN master to sending header field.</description>
              <bitOffset>20</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The LIN break/sync delimiter length is 1 bit time</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>The LIN break/sync delimiter length is 2 bit time.\nThe LIN break/sync delimiter length is 3 bit time</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>The LIN break/sync delimiter length is 4 bit time</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>LIN_HEAD_SEL</name>
              <description>LIN Header Select\n</description>
              <bitOffset>22</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The LIN header includes "break field"</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The LIN header includes "break field" and "sync field"</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>The LIN header includes "break field", "sync field" and "frame ID field"</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Reserved</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>LIN_PID</name>
              <description>LIN PID Register\nIf the parity generated by hardware, user fill ID0~ID5, (LIN_PID [29:24] )hardware will calculate P0 (LIN_PID[30]) and P1 (LIN_PID[31]), otherwise user must filled frame ID and parity in this field.\n\nNote1: User can fill any 8-bit value to this field and the bit 24 indicates ID0 (LSB first).\nNote2: This field can be used for LIN master mode or slave mode.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UA_LIN_SR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UA_LIN_SR</displayName>
          <description>UART LIN Status Register</description>
          <addressOffset>0x38</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>LINS_HDET_F</name>
              <description>LIN Slave Header Detection Flag (Read Only)\nThis bit is set by hardware when a LIN header is detected in LIN slave mode and be cleared by writing 1 to it.\nNote3: When enable ID parity check LIN_IDPEN (UA_LIN_CTL [9]), if hardware detect complete header ("break + sync + frame ID"), the LINS_HEDT_F will be set whether the frame ID correct or not.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>LIN header not detected</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>LIN header detected (break + sync + frame ID)</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>LINS_HERR_F</name>
              <description>LIN Slave Header Error Flag (Read Only)\nThis bit is set by hardware when a LIN header error is detected in LIN slave mode and be cleared by writing 1 to it. The header errors include "break delimiter is too short (less than 0.5 bit time)", "frame error in sync field or Identifier field", "sync field data is not 0x55 in Non-Automatic Resynchronization mode", "sync field deviation error with Automatic Resynchronization mode", "sync field measure time-out with Automatic Resynchronization mode" and "LIN header reception time-out".\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>LIN header error not detected</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>LIN header error detected</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>LINS_IDPERR_F</name>
              <description>LIN Slave ID Parity Error Flag (Read Only)\nThis bit is set by hardware when receipted frame ID parity is not correct.\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No active</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Receipted frame ID parity is not correct</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>LINS_SYNC_F</name>
              <description>LIN Slave Sync Field\nThis bit indicates that the LIN sync field is being analyzed in Automatic Resynchronization mode. When the receiver header have some error been detect, user must reset the internal circuit to re-search new frame header by writing 1 to this bit.\nNote2: This bit is read only, but it can be cleared by writing 1 to it.\nNote3: When writing 1 to it, hardware will reload the initial baud rate and re-search a new frame header.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The current character is not at LIN sync state</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The current character is at LIN sync state</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>LIN_BKDET_F</name>
              <description>LIN Break Detection Flag (Read Only)\nThis bit is set by hardware when a break is detected and be cleared by writing 1 to it through software.\n</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>LIN break not detected</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>LIN break detected</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>BIT_ERR_F</name>
              <description>Bit Error Detect Status Flag (Read Only)\nAt TX transfer state, hardware will monitoring the bus state, if the input pin (SIN) state not equals to the output pin (SOUT) state, BIT_ERR_F (UA_LIN_SR[9]) will be set.\n</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>SC0</name>
      <description>SC Register Map</description>
      <groupName>SC</groupName>
      <baseAddress>0x40190000</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x0</offset>
        <size>0x40</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>SC_RBR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SC_RBR</displayName>
          <description>SC Receiving Buffer Register.</description>
          <addressOffset>0x0</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>RBR</name>
              <description>Receiving Buffer \nBy reading RBR, the SC will return an 8-bit received data.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SC_THR</name>
          <alternateRegister>SC_RBR</alternateRegister>
          <!-- the display name is an unrestricted string. -->
          <displayName>SC_THR</displayName>
          <description>SC Transmit Holding Register</description>
          <addressOffset>0x0</addressOffset>
          <access>write-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>THR</name>
              <description>Transmit Holding Buffer\nBy writing data to THR, the SC will send out an 8-bit data.\nNote: If SC_CEN(SC_CTL[0]) is not enabled, THR cannot be programmed.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SC_CTL</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SC_CTL</displayName>
          <description>SC Control Register</description>
          <addressOffset>0x4</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SC_CEN</name>
              <description>SC Engine Enable Bit\nSet this bit to 1 to enable SC operation. If this bit is cleared, SC will force all transition to IDLE state.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DIS_RX</name>
              <description>RX Transition Disable Bit\nNote: If AUTO_CON_EN (SC_CTL[3])is enabled, these fields must be ignored.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The receiver Enabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The receiver Disabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DIS_TX</name>
              <description>TX Transition Disable Bit\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The transceiver Enabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The transceiver Disabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>AUTO_CON_EN</name>
              <description>Auto Convention Enable Bit\n</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Auto-convention Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Auto-convention Enabled. When hardware receives TS in answer to reset state and the TS is direct convention, CON_SEL(SC_CTL[5:4]) will be set to 00 automatically, otherwise if the TS is inverse convention, and CON_SEL (SC_CTL[5:4]) will be set to 11</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CON_SEL</name>
              <description>Convention Selection\nNote: If AUTO_CON_EN(SC_CTL[3]) enabled, this fields are ignored.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Direct convention</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reserved</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Reserved</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Inverse convention</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_FTRI_LEV</name>
              <description>Rx Buffer Trigger Level \nWhen the number of bytes in the receiving buffer equals the RX_FTRI_LEV, the RDA_IF will be set (if IER [RDA_IEN] is enabled, an interrupt will be generated).\n</description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>INTR_RDA Trigger Level with 01 Bytes</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>INTR_RDA Trigger Level with 02 Bytes</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>INTR_RDA Trigger Level with 03 Bytes</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Reserved</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BGT</name>
              <description>Block Guard Time (BGT)\nNote: The real block guard time is BGT + 1.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TMR_SEL</name>
              <description>Timer Selection \n</description>
              <bitOffset>13</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>All internal timer function Disabled</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Internal 24 bit timer Enabled. Software can configure it by setting SC_TMR0 [23:0]. SC_TMR1 and SC_TMR2 will be ignored in this mode</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>internal 24 bit timer and 8 bit internal timer Enabled. Software can configure the 24 bit timer by setting SC_TMR0 [23:0] and configure the 8 bit timer by setting SC_TMR1[7:0]. SC_TMR2 will be ignored in this mode</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Internal 24 bit timer and two 8 bit timers Enabled. Software can configure them by setting SC_TMR0 [23:0], SC_TMR1 [7:0] and SC_TMR2 [7:0]</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SLEN</name>
              <description>Stop Bit Length\nThis field indicates the length of stop bit.\nNote: The default stop bit length is 2. SMC and UART adopts SLEN to program the stop bit length</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The stop bit length is 2 ETU</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The stop bit length is 1 ETU</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_ERETRY</name>
              <description>RX Error Retry Count Number\nThis field indicates the maximum number of receiver retries that are allowed when parity error has occurred\nNote1: The real retry number is RX_ERETRY + 1, so 8 is the maximum retry number.\nNote2: This field cannot be changed when RX_ERETRY_EN enabled. The change flow is to disable RX_ETRTRY_EN first and then fill in new retry value.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_ERETRY_EN</name>
              <description>RX Error Retry Enable Bit\nThis bit enables receiver retry function when parity error has occurred.\nNote: Software must fill in the RX_ERETRY value before enabling this bit.</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RX error retry function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RX error retry function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_ERETRY</name>
              <description>TX Error Retry Count Number\nThis field indicates the maximum number of transmitter retries that are allowed when parity error has occurred.\nNote1: The real retry number is TX_ERETRY + 1, so 8 is the maximum retry number.\nNote2: This field cannot be changed when TX_ERETRY_EN enabled. The change flow is to disable TX_ETRTRY_EN first and then fill in new retry value.</description>
              <bitOffset>20</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_ERETRY_EN</name>
              <description>TX Error Retry Enable Bit\nThis bit enables transmitter retry function when parity error has occurred.\n</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>TX error retry function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>TX error retry function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CD_DEB_SEL</name>
              <description>Card Detect De-Bounce Selection\nThis field indicates the card detect de-bounce selection.\n</description>
              <bitOffset>24</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>De-bounce sample card insert once per 384 (128 * 3) SC peripheral clocks and de-bounce sample card removal once per 128 SC peripheral clocks</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>De-bounce sample card insert once per 192 (64 * 3) SC peripheral clocks and de-bounce sample card removal once per 64 SC peripheral clocks</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>De-bounce sample card insert once per 96 (32 * 3) SC peripheral clocks and de-bounce sample card removal once per 32 SC peripheral clocks</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>De-bounce sample card insert once per 48 (16 * 3) SC peripheral clocks and de-bounce sample card removal once per 16 SC peripheral clocks</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SYNC</name>
              <description>SYNC Flag Indicator\nDue to synchronization, software should check this bit before writing a new value to RX_ERETRY and TX_ERETRY.\nNote: This bit is read only.</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>synchronizing is completion, user can write new data to RX_ERETRY and TX_ERETRY</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Last value is synchronizing</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SC_ALTCTL</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SC_ALTCTL</displayName>
          <description>SC Alternate Control Register</description>
          <addressOffset>0x8</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TX_RST</name>
              <description>TX Software Reset\nWhen TX_RST is set, all the bytes in the transmit buffer and TX internal state machine will be cleared.\nNote: This bit will be auto cleared after reset is complete.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reset the TX internal state machine and pointers</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_RST</name>
              <description>Rx Software Reset\nWhen RX_RST is set, all the bytes in the receiver buffer and Rx internal state machine will be cleared.\nNote: This bit will be auto cleared after reset is complete.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reset the Rx internal state machine and pointers</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DACT_EN</name>
              <description>Deactivation Sequence Generator Enable Bit\nThis bit enables SC controller to initiate the card by deactivation sequence\nNote1: When the deactivation sequence completed, this bit will be cleared automatically and the INIT_IS(SC_ISR[8]) will be set to 1.\nNote2: This field will be cleared by TX_RST (SC_ALTCTL[0]) and RX_RST(SC_ALTCTL[1]). So don't fill this bit, TX_RST, and RX_RST at the same time.\nNote3: If SC_CEN (SC_CTL[0]) is not enabled, this filed cannot be programmed.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Deactivation sequence generator Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ACT_EN</name>
              <description>Activation Sequence Generator Enable Bit\nThis bit enables SC controller to initiate the card by activation sequence\nNote1: When the activation sequence completed, this bit will be cleared automatically and the INIT_IS(SC_ISR[8]) will be set to 1.\nNote2: This field will be cleared by TX_RST(SC_ALTCTL[0]) and RX_RST(SC_ALTCTL[1]), so don't fill this bit, TX_RST(SC_ALTCTL[0]), and RX_RST(SC_ALTCTL[1]) at the same time.\nNote3: If SC_CEN(SC_CTL[0]) is not enabled, this filed cannot be programmed.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Activation sequence generator Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>WARST_EN</name>
              <description>Warm Reset Sequence Generator Enable Bit\nThis bit enables SC controller to initiate the card by warm reset sequence\nNote1: When the warm reset sequence completed, this bit will be cleared automatically and the INIT_IS(SC_ISR[8]) will be set to 1.\nNote2: This field will be cleared by TX_RST(SC_ALTCTL[0]) and RX_RST(SC_ALTCTL[1]), so don't fill this bit, TX_RST, and RX_RST at the same time.\nNote3: If SC_CEN(SC_CTL[0]) is not enabled, this filed cannot be programmed.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Warm reset sequence generator Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TMR0_SEN</name>
              <description>Internal Timer0 Start Enable Bit\nThis bit enables Timer 0 to start counting. Software can fill 0 to stop it and set 1 to reload and count.\nNote3: This field will be cleared by TX_RST(SC_ALTCTL[0]) and RX_RST(SC_ALTCTL[1]). So don't fill this bit, TX_RST and RX_RST at the same time.\nNote4: If SC_CEN(SC_CTL[0]) is not enabled, this filed cannot be programmed.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Stops counting</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Start counting</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TMR1_SEN</name>
              <description>Internal Timer1 Start Enable Bit\nThis bit enables Timer 1 to start counting. Software can fill 0 to stop it and set 1 to reload and count.\nNote3: This field will be cleared by TX_RST(SC_ALTCTL[0]) and RX_RST(SC_ALTCTL[1]), so don't fill this bit, TX_RST(SC_ALTCTL[0]), and RX_RST(SC_ALTCTL[1]) at the same time.\nNote4: If SC_CEN(SC_CTL[0]) is not enabled, this filed cannot be programmed.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Stops counting</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Start counting</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TMR2_SEN</name>
              <description>Internal Timer2 Start Enable Bit\nThis bit enables Timer 2 to start counting. Software can fill 0 to stop it and set 1 to reload and count.\nNote3: This field will be cleared by TX_RST(SC_ALTCTL[0]) and RX_RST(SC_ALTCTL[1]). So don't fill this bit, TX_RST(SC_ALTCTL[0]), and RX_RST(SC_ALTCTL[1]) at the same time.\nNote4: If SC_CEN(SC_CTL[0]) is not enabled, this filed cannot be programmed.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Stops counting</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Start counting</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>INIT_SEL</name>
              <description>Initial Timing Selection\nThis fields indicates the timing of hardware initial state (activation or warm-reset or deactivation).\nUnit: SC clock\nActivation: refer to SC Activation Sequence in Figure 679.\nWarm-reset: refer to Warm-Reset Sequence in Figure 680.\nDeactivation: refer to Deactivation Sequence in Figure 681.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_BGT_EN</name>
              <description>Receiver Block Guard Time Function Enable Bit\n</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Receiver block guard time function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Receiver block guard time function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TMR0_ATV</name>
              <description>Internal Timer0 Active State (Read Only)\nThis bit indicates the timer counter status of timer0.\n</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Timer0 is not active</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Timer0 is active</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>TMR1_ATV</name>
              <description>Internal Timer1 Active State (Read Only)\nThis bit indicates the timer counter status of timer1.\n</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Timer1 is not active</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Timer1 is active</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>TMR2_ATV</name>
              <description>Internal Timer2 Active State (Read Only)\nThis bit indicates the timer counter status of timer2.\n</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Timer2 is not active</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Timer2 is active</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>OUTSEL</name>
              <description>Smartcard Data Pin Output Mode Selection\nUse this bit to select smartcard data pin (SC_DATA) output mode\n</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Quasi mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Open-drain mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SC_EGTR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SC_EGTR</displayName>
          <description>SC Extend Guard Time Register</description>
          <addressOffset>0xC</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>EGT</name>
              <description>Extended Guard Time\nThis field indicates the extended guard timer value.\nNote: The counter is ETU base and the real extended guard time is EGT.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SC_RFTMR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SC_RFTMR</displayName>
          <description>SC Receive Buffer Time-out Register</description>
          <addressOffset>0x10</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RFTM</name>
              <description>SC Receiver Buffer Time-Out  (ETU Base)\nNote1: The counter unit is ETU based and the interval of time-out is RFTM + 0.5\nNote2: Fill all 0 to this field indicates to disable this function.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>9</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SC_ETUCR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SC_ETUCR</displayName>
          <description>SC ETU Control Register</description>
          <addressOffset>0x14</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000173</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ETU_RDIV</name>
              <description>ETU Rate Divider\nThe field indicates the clock rate divider.\nThe real ETU is ETU_RDIV + 1.\nNote: Software can configure this field, but this field must be greater than 0x004.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>12</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>COMPEN_EN</name>
              <description>Compensation Mode Enable Bit\nThis bit enables clock compensation function. When this bit enabled, hardware will alternate between n clock cycles and n-1 clock cycles, where n is the value to be written into the ETU_RDIV .\n</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Compensation function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Compensation function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SC_IER</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SC_IER</displayName>
          <description>SC Interrupt Enable Control Register</description>
          <addressOffset>0x18</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RDA_IE</name>
              <description>Receive Data Reach Interrupt Enable Bit\nThis field is used for received data reaching trigger level RX_FTRI_LEV (SC_CTL[7:6]) interrupt enable.\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Receive data reach trigger level interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Receive data reach trigger level interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TXBE_IE</name>
              <description>Transmit Buffer Empty Interrupt Enable Bit\nThis field is used for transmit buffer empty interrupt enable.\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Transmit buffer empty interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Transmit buffer empty interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TERR_IE</name>
              <description>Transfer Error Interrupt Enable Bit\nThis field is used for transfer error interrupt enable. The transfer error states is at SC_SR register which includes receiver break error RX_EBR_F(SC_SR[6]), frame error RX_EFR_F(SC_SR[5]), parity error RX_EPA_F(SC_SR[4]), receiver buffer overflow error RX_OVER_F(SC_SR[0]), transmit buffer overflow error TX_OVER_F(SC_SR[8]), receiver retry over limit error RX_OVER_REERR(SC_SR[22]) and transmitter retry over limit error TX_OVER_REERR(SC_SR[30]).\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Transfer error interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Transfer error interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TMR0_IE</name>
              <description>Timer0 Interrupt Enable Bit\nThis field is used to enable TMR0 interrupt enable.\n</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Timer0 interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Timer0 interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TMR1_IE</name>
              <description>Timer1 Interrupt Enable Bit\nThis field is used to enable the TMR1 interrupt.\n</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Timer1 interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Timer1 interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TMR2_IE</name>
              <description>Timer2 Interrupt Enable Bit\nThis field is used for TMR2 interrupt enable.\n</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Timer2 interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Timer2 interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BGT_IE</name>
              <description>Block Guard Time Interrupt Enable Bit\nThis field is used for block guard time interrupt enable.\n</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Block guard time Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Block guard time Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CD_IE</name>
              <description>Card Detect Interrupt Enable Bit\nThis field is used for card detect interrupt enable. The card detect status is CD_INS_F(SC_SR[12]) \n</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Card detect interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Card detect interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>INIT_IE</name>
              <description>Initial End Interrupt Enable Bit\n</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Initial end interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Initial end interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RTMR_IE</name>
              <description>Receiver Buffer Time-Out Interrupt Enable Bit \nThis field is used for receiver buffer time-out interrupt enable.\n</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Receiver buffer time-out interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Receiver buffer time-out interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ACON_ERR_IE</name>
              <description>Auto Convention Error Interrupt Enable Bit \nThis field is used for auto-convention error interrupt enable.\n</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Auto-convention error interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Auto-convention error interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SC_ISR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SC_ISR</displayName>
          <description>SC Interrupt Status Register</description>
          <addressOffset>0x1C</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000002</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RDA_IS</name>
              <description>Receive Data Reach Interrupt Status Flag (Read Only)\nThis field is used for received data reaching trigger level RX_FTRI_LEV (SC_CTL[7:6]) interrupt status flag.\nNote: This field is the status flag of received data reaching RX_FTRI_LEV (SC_CTL[7:6]). If software reads data from SC_RBR and receiver buffer data byte number is less than RX_FTRI_LEV (SC_CTL[7:6]), this bit will be cleared automatically.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TBE_IS</name>
              <description>Transmit Buffer Empty Interrupt Status Flag (Read Only)\nThis field is used for transmit buffer empty interrupt status flag.\nNote: This field is the status flag of transmit buffer empty state. If software wants to clear this bit, software must write data to THR(SC_THR[7:0]) buffer and then this bit will be cleared automatically.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TERR_IS</name>
              <description>Transfer Error Interrupt Status Flag (Read Only)\nThis field is used for transfer error interrupt status flag. The transfer error states is at  SC_SR register which includes receiver break error RX_EBR_F(SC_SR[6]), frame error RX_EFR_F(SC_TRSR[5], parity error RX_EPA_F(SC_TRSR[4] and receiver buffer overflow error RX_OVER_F(SC_TRSR[0]), transmit buffer overflow error TX_OVER_F(SC_TRSR[8]), receiver retry over limit error RX_OVER_REERR(SC_TRSR[22] and transmitter retry over limit error TX_OVER_REERR(SC_TRSR[30]).\nNote: This field is the status flag of RX_EBR_F(SC_TRSR[6]), RX_EFR_F(SC_TRSR[5]), RX_EPA_F(SC_TRSR[4]), RX_OVER_F(SC_TRSR[0]), TX_OVER_F(SC_TRSR[8]), RX_OVER_REERR(SC_TRSR[22]) or TX_OVER_REERR(SC_TRSR[30]). So, if software wants to clear this bit, software must write 1 to each field.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TMR0_IS</name>
              <description>Timer0 Interrupt Status Flag (Read Only)\nThis field is used for TMR0 interrupt status flag.\nNote: This bit is read only, but it can be cleared by writing 1 to it.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TMR1_IS</name>
              <description>Timer1 Interrupt Status Flag (Read Only)\nThis field is used for TMR1 interrupt status flag.\nNote: This bit is read only, but it can be cleared by writing 1 to it.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TMR2_IS</name>
              <description>Timer2 Interrupt Status Flag (Read Only)\nThis field is used for TMR2 interrupt status flag.\nNote: This bit is read only, but it can be cleared by writing 1 to it.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>BGT_IS</name>
              <description>\n</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>CD_IS</name>
              <description>Card Detect Interrupt Status Flag (Read Only)\nThis field is used for card detect interrupt status flag. The card detect status  is CD_INS_F (SC_SR[12]) and CD_REM_F(SC_SR[11]).\nNote: This field is the status flag of CD_INS_F(SC_SR[12]) or CD_REM_F(SC_TRSR[11])]. So if software wants to clear this bit, software must write 1 to this field.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>INIT_IS</name>
              <description>Initial End Interrupt Status Flag (Read Only)\nThis field is used for activation (ACT_EN(SC_ALTCTL[3])), deactivation (DACT_EN (SC_ALTCTL[2])) and warm reset (WARST_EN (SC_ALTCTL[4])) sequence interrupt status flag.\nNote: This bit is read only, but it can be cleared by writing 1 to it.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RTMR_IS</name>
              <description>Receiver Buffer Time-Out Interrupt Status Flag (Read Only)\nThis field is used for receiver buffer time-out interrupt status flag.\nNote: This field is the status flag of receiver buffer time-out state. If software wants to clear this bit, software must read all receiver buffer remaining data by reading SC_RBR buffer,</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ACON_ERR_IS</name>
              <description>Auto Convention Error Interrupt Status Flag (Read Only)\nThis field indicates auto convention sequence error. If the received TS at ATR state is neither 0x3B nor 0x3F, this bit will be set.\nNote: This bit is read only, but it can be cleared by writing 1 to it.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SC_TRSR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SC_TRSR</displayName>
          <description>SC Status Register</description>
          <addressOffset>0x20</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000202</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RX_OVER_F</name>
              <description>RX Overflow Error Status Flag (Read Only) \nThis bit is set when RX buffer overflow.\nIf the number of received bytes is greater than Rx Buffer size (4 bytes), this bit will be set.\nNote: This bit is read only, but it can be cleared by writing 1 to it.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RX_EMPTY_F</name>
              <description>Receiver Buffer Empty Status Flag(Read Only)\nThis bit indicates RX buffer empty or not.\nWhen the last byte of Rx buffer has been read by CPU, hardware sets this bit high. It will be cleared when SC receives any new data.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RX_FULL_F</name>
              <description>Receiver Buffer Full Status Flag (Read Only)\nThis bit indicates RX buffer full or not.\nThis bit is set when RX pointer is equal to 4, otherwise it is cleared by hardware.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RX_EPA_F</name>
              <description>Receiver Parity Error Status Flag (Read Only)\nThis bit is set to logic 1 whenever the received character does not have a valid "parity bit".\nNote1: This bit is read only, but it can be cleared by writing 1 to it.\nNote2: If CPU sets receiver retries function by setting RX_ERETRY_EN(SC_CTL[19]) , hardware will not set this flag.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RX_EFR_F</name>
              <description>Receiver Frame Error Status Flag (Read Only)\nThis bit is set to logic 1 whenever the received character does not have a valid "stop bit" (that is, the stop bit following the last data bit or parity bit is detected as logic 0). \nNote1: This bit is read only, but it can be cleared by writing 1 to it.\nNote2: If CPU sets receiver retries function by setting RX_ERETRY_EN(SC_CTL[19]) , hardware will not set this flag.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RX_EBR_F</name>
              <description>Receiver Break Error Status Flag (Read Only)\nThis bit is set to logic 1 whenever the received data input (RX) held in the "spacing state" (logic 0) is longer than a full word transmission time (that is, the total time of "start bit" + data bits + parity + stop bits). .\nNote1: This bit is read only, but it can be cleared by writing 1 to it.\nNote2: If CPU sets receiver retries function by setting RX_ERETRY_EN(SC_CTL[19]) , hardware will not set this flag.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TX_OVER_F</name>
              <description>TX Overflow Error Interrupt Status Flag (Read Only)\nIf TX buffer is full, an additional write to THR(SC_THR[7:0]) will cause this bit be set to "1" by hardware. \nNote: This bit is read only, but it can be cleared by writing 1 to it.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TX_EMPTY_F</name>
              <description>Transmit Buffer Empty Status Flag (Read Only)\nThis bit indicates TX buffer empty or not.\nWhen the last byte of TX buffer has been transferred to Transmitter Shift Register, hardware sets this bit high. It will be cleared when writing data into THR(SC_THR[7:0]) (TX buffer not empty).</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TX_FULL_F</name>
              <description>Transmit Buffer Full Status Flag (Read Only)\nThis bit indicates TX buffer full or not.This bit is set when TX pointer is equal to 4, otherwise is cleared by hardware.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RX_POINT_F</name>
              <description>Receiver Buffer Pointer Status Flag (Read Only)\nThis field indicates the RX buffer pointer status flag. When SC receives one byte from external device, RX_POINT_F(SC_SR[17:16]) increases one. When one byte of RX buffer is read by CPU, RX_POINT_F(SC_SR[17:16]) decreases one.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RX_REERR</name>
              <description>Receiver Retry Error (Read Only)\nThis bit is set by hardware when RX has any error and retries transfer.\nNote1: This bit is read only, but it can be cleared by writing 1 to it.\nNote2 This bit is a flag and cannot generate any interrupt to CPU.\nNote3: If CPU enables receiver retry function by setting RX_ERETRY_EN (SC_CTL[19]) , the RX_EPA_F(SC_TRSR[4]) flag will be ignored (hardware will not set RX_EPA_F(SC_TRSR[4])).</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RX_OVER_REERR</name>
              <description>Receiver Over Retry Error (Read Only)\nThis bit is set by hardware when RX transfer error retry over retry number limit.\nNote1: This bit is read only, but it can be cleared by writing 1 to it.\nNote2: If CPU enables receiver retries function by setting RX_ERETRY_EN (SC_CTL[19]), the RX_EPA_F(SC_TRSR[4]) flag will be ignored (hardware will not set RX_EPA_F(SC_TRSR[4])).</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RX_ATV</name>
              <description>Receiver In Active Status Flag (Read Only)\nThis bit is set by hardware when RX transfer is in active.\nThis bit is cleared automatically when RX transfer is finished.</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TX_POINT_F</name>
              <description>Transmit Buffer Pointer Status Flag (Read Only)\nThis field indicates the TX buffer pointer status flag. When CPU writes data into SC_THR, TX_POINT_F increases one. When one byte of TX Buffer is transferred to transmitter shift register, TX_POINT_F decreases one.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TX_REERR</name>
              <description>Transmitter Retry Error (Read Only)\nThis bit is set by hardware when transmitter re-transmits.\nNote1: This bit is read only, but it can be cleared by writing 1 to it.\nNote2 This bit is a flag and cannot generate any interrupt to CPU.</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TX_OVER_REERR</name>
              <description>Transmitter Over Retry Error (Read Only)\nThis bit is set by hardware when transmitter re-transmits over retry number limitation.\nNote: This bit is read only, but it can be cleared by writing 1 to it.</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TX_ATV</name>
              <description>Transmit In Active Status Flag (Read Only)\n</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>This bit is cleared automatically when TX transfer is finished or the last byte transmission has completed</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>This bit is set by hardware when TX transfer is in active and the STOP bit of the last byte has been transmitted</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SC_PINCSR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SC_PINCSR</displayName>
          <description>SC Pin Control State Register</description>
          <addressOffset>0x24</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFF0F</resetMask>
          <fields>
            <field>
              <name>POW_EN</name>
              <description>SC_POW_EN Pin Signal\nSoftware can set POW_EN (SC_PINCSR[0]) and POW_INV (SC_PINCSR[11])to decide SC_PWR pin is in high or low level.\nWrite this field to drive SC_PWR pin\nRefer POW_INV (SC_PINCSR[11]) description for programming SC_PWR pin voltage level. \nRead this field to get SC_PWR pin status.\nNote: When operating at activation, warm reset or deactivation mode, this bit will be changed automatically. So don't fill this field when operating in these modes.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>SC_PWR pin status is low</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>SC_PWR pin status is high</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SC_RST</name>
              <description>SC_RST Pin Signal\nThis bit is the pin status of SC_RST but user can drive SC_RST pin to high or low by setting this bit.\nWrite this field to drive SC_RST pin.\nNote: When operating at activation, warm reset or deactivation mode, this bit will be changed automatically. So don't fill this field when operating in these modes.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Drive SC_RST pin to low.\nSC_RST pin status is low</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Drive SC_RST pin to high.\nSC_RST pin status is high</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CD_REM_F</name>
              <description>Card Detect Removal Status Of SC_CD Pin (Read Only)\nThis bit is set whenever a card has been removed.\nNote1: This bit is read only, but it can be cleared by writing "1" to it.\nNote2: Card detect engine will start after SC_CEN (SC_CTL[0] )set.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Card removed</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>CD_INS_F</name>
              <description>Card Detect Insert Status Of SC_CD Pin (Read Only)\nThis bit is set whenever card has been inserted.\nNote1: This bit is read only, but it can be cleared by writing "1" to it.\nNote2: The card detect engine will start after SC_CEN (SC_CTL[0] )set.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Card insert</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>CD_PIN_ST</name>
              <description>Card Detect Status Of SC_CD Pin Status (Read Only)\nThis bit is the pin status flag of SC_CD\n</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The SC_CD pin state at low</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The SC_CD pin state at high</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>CLK_KEEP</name>
              <description>SC Clock Enable Bit \nNote: When operating in activation, warm reset or deactivation mode, this bit will be changed automatically. So don't fill this field when operating in these modes.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>SC clock generation Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>SC clock always keeps free running</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ADAC_CD_EN</name>
              <description>Auto Deactivation When Card Removal\nNote: When the card is removed, hardware will stop any process and then do deactivation sequence (if this bit be setting). If this process completes. Hardware will generate an initial end interrupt to CPU.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Auto deactivation Disabled when hardware detected the card removal</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Auto deactivation Enabled when hardware detected the card removal</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SC_OEN_ST</name>
              <description>SC Data Output Enable Pin Status (Read Only)\nThis bit is the pin status of SC_DATA_OEN\n</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The SC_DATA_OEN pin state at low</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The SC_DATA_OEN pin state at high</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>SC_DATA_O</name>
              <description>SC Data Output Pin \nThis bit is the pin status of SC_DATA_O but user can drive SC_DATA_O pin to high or low by setting this bit.\nNote: When SC is at activation, warm reset or deactivation mode, this bit will be changed automatically. So don't fill this field when SC is in these modes.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Drive SC_DATA_O pin to low</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Drive SC_DATA_O pin to high</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CD_LEV</name>
              <description>Card Detect Level\n\nNote: Software must select card detect level before Smart Card engine is enabled</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>When hardware detects the card detect pin from high to low, it indicates a card is detected</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>When hardware detects the card detect pin from low to high, it indicates a card is detected</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>POW_INV</name>
              <description>SC_POW Pin Inverse\nThis bit is used for inverse the SC_POW pin.\nThere are four kinds of combination for SC_POW pin setting by POW_INV(SC_PINCSR[11]) and POW_EN(SC_PINCSR[0]). POW_INV (SC_PINCSR[11]) is bit 1 and POW_EN(SC_PINCSR[0]) is bit 0 for SC_POW_Pin as high or low voltage selection.\nNote: Software must select POW_INV (SC_PINCSR[11]) before Smart Card  is enabled by SC_CEN (SC_CTL[0]).</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SC_DATA_I_ST</name>
              <description>SC Data Pin Status (Read Only)\nThis bit is the pin status of SC_DATA\n</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The SC_DATA pin is low</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The SC_DATA pin is high</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>SYNC</name>
              <description>SYNC Flag Indicator\nDue to synchronization, software should check this bit when writing a new value to SC_PINCSR register.\nNote: This bit is read only.</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Synchronizing is completion, user can write new data to SC_PINCSR register</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Last value is synchronizing</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SC_TMR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SC_TMR0</displayName>
          <description>SC Internal Timer Control Register 0</description>
          <addressOffset>0x28</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CNT0</name>
              <description>Timer 0 Counter Value (ETU Base)\nThis field indicates the internal timer operation values.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MODE</name>
              <description>Timer 0 Operation Mode Selection\nThis field indicates the internal 24-bit timer operation selection.\nRefer to 6.14.5.4 for programming Timer0</description>
              <bitOffset>24</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SC_TMR1</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SC_TMR1</displayName>
          <description>SC Internal Timer Control Register 1</description>
          <addressOffset>0x2C</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CNT1</name>
              <description>Timer 1 Counter Value (ETU Base)\nThis field indicates the internal timer operation values.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MODE</name>
              <description>Timer 1 Operation Mode Selection\nThis field indicates the internal 8-bit timer operation selection.\nRefer to 6.14.5.4 for programming Timer1</description>
              <bitOffset>24</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SC_TMR2</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SC_TMR2</displayName>
          <description>SC Internal Timer Control Register 2</description>
          <addressOffset>0x30</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CNT2</name>
              <description>Timer 2 Counter Value (ETU Base)\nThis field indicates the internal timer operation values.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MODE</name>
              <description>Timer 2 Operation Mode Selection\nThis field indicates the internal 8-bit timer operation selection\nRefer to 6.14.5.4 for programming Timer2</description>
              <bitOffset>24</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SC_UACTL</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SC_UACTL</displayName>
          <description>SC UART Mode Control Register.</description>
          <addressOffset>0x34</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>UA_MODE_EN</name>
              <description>UART Mode Enable Bit\nNote3: When UART is enabled, hardware will generate a reset to reset FIFO and internal state machine.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Smart Card mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>UART mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA_LEN</name>
              <description>Data Length\nNote: In smart card mode, this DATA_LEN must be '00'</description>
              <bitOffset>4</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Character Data Length is 8 bits</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Character Data Length is 7 bits</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Character Data length is 6 bits</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Character Data Length is 5 bits</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PBDIS</name>
              <description>Parity Bit Disable Bit\nNote: In smart card mode, this field must be '0' (default setting is with parity bit)</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Parity bit is generated or checked between the "last data word bit" and "stop bit" of the serial data</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Parity bit is not generated (transmitting data) or checked (receiving data) during transfer</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>OPE</name>
              <description>Odd Parity Enable Bit\nNote: This bit has effect only when PBDIS bit is '0'.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Even number of logic 1's are transmitted or check the data word and parity bits in receiving mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Odd number of logic 1's are transmitted or check the data word and parity bits in receiving mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SC_TDRA</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SC_TDRA</displayName>
          <description>SC Timer Current Data Register A</description>
          <addressOffset>0x38</addressOffset>
          <access>read-only</access>
          <resetValue>0x000007FF</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TDR0</name>
              <description>Timer0 Current Data Value(Read Only)\nThis field indicates the current count values of timer0.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SC_TDRB</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SC_TDRB</displayName>
          <description>SC Timer Current Data Register B</description>
          <addressOffset>0x3C</addressOffset>
          <access>read-only</access>
          <resetValue>0x00007F7F</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TDR1</name>
              <description>Timer1 Current Data Value(Read Only)\nThis field indicates the current count values of timer1.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TDR2</name>
              <description>Timer2 Current Data Value (Read Only)\nThis field indicates the current count values of timer2.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>SC1</name>
      <description>SC Register Map</description>
      <groupName>SC</groupName>
      <baseAddress>0x40194000</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x0</offset>
        <size>0x40</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>SC_RBR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SC_RBR</displayName>
          <description>SC Receiving Buffer Register.</description>
          <addressOffset>0x0</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>RBR</name>
              <description>Receiving Buffer \nBy reading RBR, the SC will return an 8-bit received data.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SC_THR</name>
          <alternateRegister>SC_RBR</alternateRegister>
          <!-- the display name is an unrestricted string. -->
          <displayName>SC_THR</displayName>
          <description>SC Transmit Holding Register</description>
          <addressOffset>0x0</addressOffset>
          <access>write-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>THR</name>
              <description>Transmit Holding Buffer\nBy writing data to THR, the SC will send out an 8-bit data.\nNote: If SC_CEN(SC_CTL[0]) is not enabled, THR cannot be programmed.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SC_CTL</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SC_CTL</displayName>
          <description>SC Control Register</description>
          <addressOffset>0x4</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SC_CEN</name>
              <description>SC Engine Enable Bit\nSet this bit to 1 to enable SC operation. If this bit is cleared, SC will force all transition to IDLE state.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DIS_RX</name>
              <description>RX Transition Disable Bit\nNote: If AUTO_CON_EN (SC_CTL[3])is enabled, these fields must be ignored.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The receiver Enabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The receiver Disabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DIS_TX</name>
              <description>TX Transition Disable Bit\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The transceiver Enabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The transceiver Disabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>AUTO_CON_EN</name>
              <description>Auto Convention Enable Bit\n</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Auto-convention Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Auto-convention Enabled. When hardware receives TS in answer to reset state and the TS is direct convention, CON_SEL(SC_CTL[5:4]) will be set to 00 automatically, otherwise if the TS is inverse convention, and CON_SEL (SC_CTL[5:4]) will be set to 11</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CON_SEL</name>
              <description>Convention Selection\nNote: If AUTO_CON_EN(SC_CTL[3]) enabled, this fields are ignored.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Direct convention</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reserved</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Reserved</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Inverse convention</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_FTRI_LEV</name>
              <description>Rx Buffer Trigger Level \nWhen the number of bytes in the receiving buffer equals the RX_FTRI_LEV, the RDA_IF will be set (if IER [RDA_IEN] is enabled, an interrupt will be generated).\n</description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>INTR_RDA Trigger Level with 01 Bytes</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>INTR_RDA Trigger Level with 02 Bytes</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>INTR_RDA Trigger Level with 03 Bytes</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Reserved</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BGT</name>
              <description>Block Guard Time (BGT)\nNote: The real block guard time is BGT + 1.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TMR_SEL</name>
              <description>Timer Selection \n</description>
              <bitOffset>13</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>All internal timer function Disabled</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Internal 24 bit timer Enabled. Software can configure it by setting SC_TMR0 [23:0]. SC_TMR1 and SC_TMR2 will be ignored in this mode</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>internal 24 bit timer and 8 bit internal timer Enabled. Software can configure the 24 bit timer by setting SC_TMR0 [23:0] and configure the 8 bit timer by setting SC_TMR1[7:0]. SC_TMR2 will be ignored in this mode</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Internal 24 bit timer and two 8 bit timers Enabled. Software can configure them by setting SC_TMR0 [23:0], SC_TMR1 [7:0] and SC_TMR2 [7:0]</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SLEN</name>
              <description>Stop Bit Length\nThis field indicates the length of stop bit.\nNote: The default stop bit length is 2. SMC and UART adopts SLEN to program the stop bit length</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The stop bit length is 2 ETU</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The stop bit length is 1 ETU</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_ERETRY</name>
              <description>RX Error Retry Count Number\nThis field indicates the maximum number of receiver retries that are allowed when parity error has occurred\nNote1: The real retry number is RX_ERETRY + 1, so 8 is the maximum retry number.\nNote2: This field cannot be changed when RX_ERETRY_EN enabled. The change flow is to disable RX_ETRTRY_EN first and then fill in new retry value.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_ERETRY_EN</name>
              <description>RX Error Retry Enable Bit\nThis bit enables receiver retry function when parity error has occurred.\nNote: Software must fill in the RX_ERETRY value before enabling this bit.</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RX error retry function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RX error retry function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_ERETRY</name>
              <description>TX Error Retry Count Number\nThis field indicates the maximum number of transmitter retries that are allowed when parity error has occurred.\nNote1: The real retry number is TX_ERETRY + 1, so 8 is the maximum retry number.\nNote2: This field cannot be changed when TX_ERETRY_EN enabled. The change flow is to disable TX_ETRTRY_EN first and then fill in new retry value.</description>
              <bitOffset>20</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_ERETRY_EN</name>
              <description>TX Error Retry Enable Bit\nThis bit enables transmitter retry function when parity error has occurred.\n</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>TX error retry function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>TX error retry function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CD_DEB_SEL</name>
              <description>Card Detect De-Bounce Selection\nThis field indicates the card detect de-bounce selection.\n</description>
              <bitOffset>24</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>De-bounce sample card insert once per 384 (128 * 3) SC peripheral clocks and de-bounce sample card removal once per 128 SC peripheral clocks</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>De-bounce sample card insert once per 192 (64 * 3) SC peripheral clocks and de-bounce sample card removal once per 64 SC peripheral clocks</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>De-bounce sample card insert once per 96 (32 * 3) SC peripheral clocks and de-bounce sample card removal once per 32 SC peripheral clocks</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>De-bounce sample card insert once per 48 (16 * 3) SC peripheral clocks and de-bounce sample card removal once per 16 SC peripheral clocks</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SYNC</name>
              <description>SYNC Flag Indicator\nDue to synchronization, software should check this bit before writing a new value to RX_ERETRY and TX_ERETRY.\nNote: This bit is read only.</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>synchronizing is completion, user can write new data to RX_ERETRY and TX_ERETRY</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Last value is synchronizing</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SC_ALTCTL</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SC_ALTCTL</displayName>
          <description>SC Alternate Control Register</description>
          <addressOffset>0x8</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TX_RST</name>
              <description>TX Software Reset\nWhen TX_RST is set, all the bytes in the transmit buffer and TX internal state machine will be cleared.\nNote: This bit will be auto cleared after reset is complete.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reset the TX internal state machine and pointers</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_RST</name>
              <description>Rx Software Reset\nWhen RX_RST is set, all the bytes in the receiver buffer and Rx internal state machine will be cleared.\nNote: This bit will be auto cleared after reset is complete.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reset the Rx internal state machine and pointers</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DACT_EN</name>
              <description>Deactivation Sequence Generator Enable Bit\nThis bit enables SC controller to initiate the card by deactivation sequence\nNote1: When the deactivation sequence completed, this bit will be cleared automatically and the INIT_IS(SC_ISR[8]) will be set to 1.\nNote2: This field will be cleared by TX_RST (SC_ALTCTL[0]) and RX_RST(SC_ALTCTL[1]). So don't fill this bit, TX_RST, and RX_RST at the same time.\nNote3: If SC_CEN (SC_CTL[0]) is not enabled, this filed cannot be programmed.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Deactivation sequence generator Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ACT_EN</name>
              <description>Activation Sequence Generator Enable Bit\nThis bit enables SC controller to initiate the card by activation sequence\nNote1: When the activation sequence completed, this bit will be cleared automatically and the INIT_IS(SC_ISR[8]) will be set to 1.\nNote2: This field will be cleared by TX_RST(SC_ALTCTL[0]) and RX_RST(SC_ALTCTL[1]), so don't fill this bit, TX_RST(SC_ALTCTL[0]), and RX_RST(SC_ALTCTL[1]) at the same time.\nNote3: If SC_CEN(SC_CTL[0]) is not enabled, this filed cannot be programmed.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Activation sequence generator Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>WARST_EN</name>
              <description>Warm Reset Sequence Generator Enable Bit\nThis bit enables SC controller to initiate the card by warm reset sequence\nNote1: When the warm reset sequence completed, this bit will be cleared automatically and the INIT_IS(SC_ISR[8]) will be set to 1.\nNote2: This field will be cleared by TX_RST(SC_ALTCTL[0]) and RX_RST(SC_ALTCTL[1]), so don't fill this bit, TX_RST, and RX_RST at the same time.\nNote3: If SC_CEN(SC_CTL[0]) is not enabled, this filed cannot be programmed.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Warm reset sequence generator Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TMR0_SEN</name>
              <description>Internal Timer0 Start Enable Bit\nThis bit enables Timer 0 to start counting. Software can fill 0 to stop it and set 1 to reload and count.\nNote3: This field will be cleared by TX_RST(SC_ALTCTL[0]) and RX_RST(SC_ALTCTL[1]). So don't fill this bit, TX_RST and RX_RST at the same time.\nNote4: If SC_CEN(SC_CTL[0]) is not enabled, this filed cannot be programmed.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Stops counting</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Start counting</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TMR1_SEN</name>
              <description>Internal Timer1 Start Enable Bit\nThis bit enables Timer 1 to start counting. Software can fill 0 to stop it and set 1 to reload and count.\nNote3: This field will be cleared by TX_RST(SC_ALTCTL[0]) and RX_RST(SC_ALTCTL[1]), so don't fill this bit, TX_RST(SC_ALTCTL[0]), and RX_RST(SC_ALTCTL[1]) at the same time.\nNote4: If SC_CEN(SC_CTL[0]) is not enabled, this filed cannot be programmed.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Stops counting</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Start counting</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TMR2_SEN</name>
              <description>Internal Timer2 Start Enable Bit\nThis bit enables Timer 2 to start counting. Software can fill 0 to stop it and set 1 to reload and count.\nNote3: This field will be cleared by TX_RST(SC_ALTCTL[0]) and RX_RST(SC_ALTCTL[1]). So don't fill this bit, TX_RST(SC_ALTCTL[0]), and RX_RST(SC_ALTCTL[1]) at the same time.\nNote4: If SC_CEN(SC_CTL[0]) is not enabled, this filed cannot be programmed.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Stops counting</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Start counting</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>INIT_SEL</name>
              <description>Initial Timing Selection\nThis fields indicates the timing of hardware initial state (activation or warm-reset or deactivation).\nUnit: SC clock\nActivation: refer to SC Activation Sequence in Figure 679.\nWarm-reset: refer to Warm-Reset Sequence in Figure 680.\nDeactivation: refer to Deactivation Sequence in Figure 681.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_BGT_EN</name>
              <description>Receiver Block Guard Time Function Enable Bit\n</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Receiver block guard time function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Receiver block guard time function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TMR0_ATV</name>
              <description>Internal Timer0 Active State (Read Only)\nThis bit indicates the timer counter status of timer0.\n</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Timer0 is not active</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Timer0 is active</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>TMR1_ATV</name>
              <description>Internal Timer1 Active State (Read Only)\nThis bit indicates the timer counter status of timer1.\n</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Timer1 is not active</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Timer1 is active</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>TMR2_ATV</name>
              <description>Internal Timer2 Active State (Read Only)\nThis bit indicates the timer counter status of timer2.\n</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Timer2 is not active</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Timer2 is active</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>OUTSEL</name>
              <description>Smartcard Data Pin Output Mode Selection\nUse this bit to select smartcard data pin (SC_DATA) output mode\n</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Quasi mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Open-drain mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SC_EGTR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SC_EGTR</displayName>
          <description>SC Extend Guard Time Register</description>
          <addressOffset>0xC</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>EGT</name>
              <description>Extended Guard Time\nThis field indicates the extended guard timer value.\nNote: The counter is ETU base and the real extended guard time is EGT.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SC_RFTMR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SC_RFTMR</displayName>
          <description>SC Receive Buffer Time-out Register</description>
          <addressOffset>0x10</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RFTM</name>
              <description>SC Receiver Buffer Time-Out  (ETU Base)\nNote1: The counter unit is ETU based and the interval of time-out is RFTM + 0.5\nNote2: Fill all 0 to this field indicates to disable this function.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>9</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SC_ETUCR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SC_ETUCR</displayName>
          <description>SC ETU Control Register</description>
          <addressOffset>0x14</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000173</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ETU_RDIV</name>
              <description>ETU Rate Divider\nThe field indicates the clock rate divider.\nThe real ETU is ETU_RDIV + 1.\nNote: Software can configure this field, but this field must be greater than 0x004.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>12</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>COMPEN_EN</name>
              <description>Compensation Mode Enable Bit\nThis bit enables clock compensation function. When this bit enabled, hardware will alternate between n clock cycles and n-1 clock cycles, where n is the value to be written into the ETU_RDIV .\n</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Compensation function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Compensation function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SC_IER</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SC_IER</displayName>
          <description>SC Interrupt Enable Control Register</description>
          <addressOffset>0x18</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RDA_IE</name>
              <description>Receive Data Reach Interrupt Enable Bit\nThis field is used for received data reaching trigger level RX_FTRI_LEV (SC_CTL[7:6]) interrupt enable.\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Receive data reach trigger level interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Receive data reach trigger level interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TXBE_IE</name>
              <description>Transmit Buffer Empty Interrupt Enable Bit\nThis field is used for transmit buffer empty interrupt enable.\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Transmit buffer empty interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Transmit buffer empty interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TERR_IE</name>
              <description>Transfer Error Interrupt Enable Bit\nThis field is used for transfer error interrupt enable. The transfer error states is at SC_SR register which includes receiver break error RX_EBR_F(SC_SR[6]), frame error RX_EFR_F(SC_SR[5]), parity error RX_EPA_F(SC_SR[4]), receiver buffer overflow error RX_OVER_F(SC_SR[0]), transmit buffer overflow error TX_OVER_F(SC_SR[8]), receiver retry over limit error RX_OVER_REERR(SC_SR[22]) and transmitter retry over limit error TX_OVER_REERR(SC_SR[30]).\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Transfer error interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Transfer error interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TMR0_IE</name>
              <description>Timer0 Interrupt Enable Bit\nThis field is used to enable TMR0 interrupt enable.\n</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Timer0 interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Timer0 interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TMR1_IE</name>
              <description>Timer1 Interrupt Enable Bit\nThis field is used to enable the TMR1 interrupt.\n</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Timer1 interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Timer1 interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TMR2_IE</name>
              <description>Timer2 Interrupt Enable Bit\nThis field is used for TMR2 interrupt enable.\n</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Timer2 interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Timer2 interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BGT_IE</name>
              <description>Block Guard Time Interrupt Enable Bit\nThis field is used for block guard time interrupt enable.\n</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Block guard time Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Block guard time Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CD_IE</name>
              <description>Card Detect Interrupt Enable Bit\nThis field is used for card detect interrupt enable. The card detect status is CD_INS_F(SC_SR[12]) \n</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Card detect interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Card detect interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>INIT_IE</name>
              <description>Initial End Interrupt Enable Bit\n</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Initial end interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Initial end interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RTMR_IE</name>
              <description>Receiver Buffer Time-Out Interrupt Enable Bit \nThis field is used for receiver buffer time-out interrupt enable.\n</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Receiver buffer time-out interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Receiver buffer time-out interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ACON_ERR_IE</name>
              <description>Auto Convention Error Interrupt Enable Bit \nThis field is used for auto-convention error interrupt enable.\n</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Auto-convention error interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Auto-convention error interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SC_ISR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SC_ISR</displayName>
          <description>SC Interrupt Status Register</description>
          <addressOffset>0x1C</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000002</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RDA_IS</name>
              <description>Receive Data Reach Interrupt Status Flag (Read Only)\nThis field is used for received data reaching trigger level RX_FTRI_LEV (SC_CTL[7:6]) interrupt status flag.\nNote: This field is the status flag of received data reaching RX_FTRI_LEV (SC_CTL[7:6]). If software reads data from SC_RBR and receiver buffer data byte number is less than RX_FTRI_LEV (SC_CTL[7:6]), this bit will be cleared automatically.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TBE_IS</name>
              <description>Transmit Buffer Empty Interrupt Status Flag (Read Only)\nThis field is used for transmit buffer empty interrupt status flag.\nNote: This field is the status flag of transmit buffer empty state. If software wants to clear this bit, software must write data to THR(SC_THR[7:0]) buffer and then this bit will be cleared automatically.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TERR_IS</name>
              <description>Transfer Error Interrupt Status Flag (Read Only)\nThis field is used for transfer error interrupt status flag. The transfer error states is at  SC_SR register which includes receiver break error RX_EBR_F(SC_SR[6]), frame error RX_EFR_F(SC_TRSR[5], parity error RX_EPA_F(SC_TRSR[4] and receiver buffer overflow error RX_OVER_F(SC_TRSR[0]), transmit buffer overflow error TX_OVER_F(SC_TRSR[8]), receiver retry over limit error RX_OVER_REERR(SC_TRSR[22] and transmitter retry over limit error TX_OVER_REERR(SC_TRSR[30]).\nNote: This field is the status flag of RX_EBR_F(SC_TRSR[6]), RX_EFR_F(SC_TRSR[5]), RX_EPA_F(SC_TRSR[4]), RX_OVER_F(SC_TRSR[0]), TX_OVER_F(SC_TRSR[8]), RX_OVER_REERR(SC_TRSR[22]) or TX_OVER_REERR(SC_TRSR[30]). So, if software wants to clear this bit, software must write 1 to each field.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TMR0_IS</name>
              <description>Timer0 Interrupt Status Flag (Read Only)\nThis field is used for TMR0 interrupt status flag.\nNote: This bit is read only, but it can be cleared by writing 1 to it.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TMR1_IS</name>
              <description>Timer1 Interrupt Status Flag (Read Only)\nThis field is used for TMR1 interrupt status flag.\nNote: This bit is read only, but it can be cleared by writing 1 to it.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TMR2_IS</name>
              <description>Timer2 Interrupt Status Flag (Read Only)\nThis field is used for TMR2 interrupt status flag.\nNote: This bit is read only, but it can be cleared by writing 1 to it.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>BGT_IS</name>
              <description>\n</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>CD_IS</name>
              <description>Card Detect Interrupt Status Flag (Read Only)\nThis field is used for card detect interrupt status flag. The card detect status  is CD_INS_F (SC_SR[12]) and CD_REM_F(SC_SR[11]).\nNote: This field is the status flag of CD_INS_F(SC_SR[12]) or CD_REM_F(SC_TRSR[11])]. So if software wants to clear this bit, software must write 1 to this field.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>INIT_IS</name>
              <description>Initial End Interrupt Status Flag (Read Only)\nThis field is used for activation (ACT_EN(SC_ALTCTL[3])), deactivation (DACT_EN (SC_ALTCTL[2])) and warm reset (WARST_EN (SC_ALTCTL[4])) sequence interrupt status flag.\nNote: This bit is read only, but it can be cleared by writing 1 to it.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RTMR_IS</name>
              <description>Receiver Buffer Time-Out Interrupt Status Flag (Read Only)\nThis field is used for receiver buffer time-out interrupt status flag.\nNote: This field is the status flag of receiver buffer time-out state. If software wants to clear this bit, software must read all receiver buffer remaining data by reading SC_RBR buffer,</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ACON_ERR_IS</name>
              <description>Auto Convention Error Interrupt Status Flag (Read Only)\nThis field indicates auto convention sequence error. If the received TS at ATR state is neither 0x3B nor 0x3F, this bit will be set.\nNote: This bit is read only, but it can be cleared by writing 1 to it.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SC_TRSR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SC_TRSR</displayName>
          <description>SC Status Register</description>
          <addressOffset>0x20</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000202</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RX_OVER_F</name>
              <description>RX Overflow Error Status Flag (Read Only) \nThis bit is set when RX buffer overflow.\nIf the number of received bytes is greater than Rx Buffer size (4 bytes), this bit will be set.\nNote: This bit is read only, but it can be cleared by writing 1 to it.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RX_EMPTY_F</name>
              <description>Receiver Buffer Empty Status Flag(Read Only)\nThis bit indicates RX buffer empty or not.\nWhen the last byte of Rx buffer has been read by CPU, hardware sets this bit high. It will be cleared when SC receives any new data.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RX_FULL_F</name>
              <description>Receiver Buffer Full Status Flag (Read Only)\nThis bit indicates RX buffer full or not.\nThis bit is set when RX pointer is equal to 4, otherwise it is cleared by hardware.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RX_EPA_F</name>
              <description>Receiver Parity Error Status Flag (Read Only)\nThis bit is set to logic 1 whenever the received character does not have a valid "parity bit".\nNote1: This bit is read only, but it can be cleared by writing 1 to it.\nNote2: If CPU sets receiver retries function by setting RX_ERETRY_EN(SC_CTL[19]) , hardware will not set this flag.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RX_EFR_F</name>
              <description>Receiver Frame Error Status Flag (Read Only)\nThis bit is set to logic 1 whenever the received character does not have a valid "stop bit" (that is, the stop bit following the last data bit or parity bit is detected as logic 0). \nNote1: This bit is read only, but it can be cleared by writing 1 to it.\nNote2: If CPU sets receiver retries function by setting RX_ERETRY_EN(SC_CTL[19]) , hardware will not set this flag.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RX_EBR_F</name>
              <description>Receiver Break Error Status Flag (Read Only)\nThis bit is set to logic 1 whenever the received data input (RX) held in the "spacing state" (logic 0) is longer than a full word transmission time (that is, the total time of "start bit" + data bits + parity + stop bits). .\nNote1: This bit is read only, but it can be cleared by writing 1 to it.\nNote2: If CPU sets receiver retries function by setting RX_ERETRY_EN(SC_CTL[19]) , hardware will not set this flag.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TX_OVER_F</name>
              <description>TX Overflow Error Interrupt Status Flag (Read Only)\nIf TX buffer is full, an additional write to THR(SC_THR[7:0]) will cause this bit be set to "1" by hardware. \nNote: This bit is read only, but it can be cleared by writing 1 to it.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TX_EMPTY_F</name>
              <description>Transmit Buffer Empty Status Flag (Read Only)\nThis bit indicates TX buffer empty or not.\nWhen the last byte of TX buffer has been transferred to Transmitter Shift Register, hardware sets this bit high. It will be cleared when writing data into THR(SC_THR[7:0]) (TX buffer not empty).</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TX_FULL_F</name>
              <description>Transmit Buffer Full Status Flag (Read Only)\nThis bit indicates TX buffer full or not.This bit is set when TX pointer is equal to 4, otherwise is cleared by hardware.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RX_POINT_F</name>
              <description>Receiver Buffer Pointer Status Flag (Read Only)\nThis field indicates the RX buffer pointer status flag. When SC receives one byte from external device, RX_POINT_F(SC_SR[17:16]) increases one. When one byte of RX buffer is read by CPU, RX_POINT_F(SC_SR[17:16]) decreases one.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RX_REERR</name>
              <description>Receiver Retry Error (Read Only)\nThis bit is set by hardware when RX has any error and retries transfer.\nNote1: This bit is read only, but it can be cleared by writing 1 to it.\nNote2 This bit is a flag and cannot generate any interrupt to CPU.\nNote3: If CPU enables receiver retry function by setting RX_ERETRY_EN (SC_CTL[19]) , the RX_EPA_F(SC_TRSR[4]) flag will be ignored (hardware will not set RX_EPA_F(SC_TRSR[4])).</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RX_OVER_REERR</name>
              <description>Receiver Over Retry Error (Read Only)\nThis bit is set by hardware when RX transfer error retry over retry number limit.\nNote1: This bit is read only, but it can be cleared by writing 1 to it.\nNote2: If CPU enables receiver retries function by setting RX_ERETRY_EN (SC_CTL[19]), the RX_EPA_F(SC_TRSR[4]) flag will be ignored (hardware will not set RX_EPA_F(SC_TRSR[4])).</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RX_ATV</name>
              <description>Receiver In Active Status Flag (Read Only)\nThis bit is set by hardware when RX transfer is in active.\nThis bit is cleared automatically when RX transfer is finished.</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TX_POINT_F</name>
              <description>Transmit Buffer Pointer Status Flag (Read Only)\nThis field indicates the TX buffer pointer status flag. When CPU writes data into SC_THR, TX_POINT_F increases one. When one byte of TX Buffer is transferred to transmitter shift register, TX_POINT_F decreases one.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TX_REERR</name>
              <description>Transmitter Retry Error (Read Only)\nThis bit is set by hardware when transmitter re-transmits.\nNote1: This bit is read only, but it can be cleared by writing 1 to it.\nNote2 This bit is a flag and cannot generate any interrupt to CPU.</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TX_OVER_REERR</name>
              <description>Transmitter Over Retry Error (Read Only)\nThis bit is set by hardware when transmitter re-transmits over retry number limitation.\nNote: This bit is read only, but it can be cleared by writing 1 to it.</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TX_ATV</name>
              <description>Transmit In Active Status Flag (Read Only)\n</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>This bit is cleared automatically when TX transfer is finished or the last byte transmission has completed</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>This bit is set by hardware when TX transfer is in active and the STOP bit of the last byte has been transmitted</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SC_PINCSR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SC_PINCSR</displayName>
          <description>SC Pin Control State Register</description>
          <addressOffset>0x24</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFF0F</resetMask>
          <fields>
            <field>
              <name>POW_EN</name>
              <description>SC_POW_EN Pin Signal\nSoftware can set POW_EN (SC_PINCSR[0]) and POW_INV (SC_PINCSR[11])to decide SC_PWR pin is in high or low level.\nWrite this field to drive SC_PWR pin\nRefer POW_INV (SC_PINCSR[11]) description for programming SC_PWR pin voltage level. \nRead this field to get SC_PWR pin status.\nNote: When operating at activation, warm reset or deactivation mode, this bit will be changed automatically. So don't fill this field when operating in these modes.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>SC_PWR pin status is low</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>SC_PWR pin status is high</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SC_RST</name>
              <description>SC_RST Pin Signal\nThis bit is the pin status of SC_RST but user can drive SC_RST pin to high or low by setting this bit.\nWrite this field to drive SC_RST pin.\nNote: When operating at activation, warm reset or deactivation mode, this bit will be changed automatically. So don't fill this field when operating in these modes.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Drive SC_RST pin to low.\nSC_RST pin status is low</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Drive SC_RST pin to high.\nSC_RST pin status is high</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CD_REM_F</name>
              <description>Card Detect Removal Status Of SC_CD Pin (Read Only)\nThis bit is set whenever a card has been removed.\nNote1: This bit is read only, but it can be cleared by writing "1" to it.\nNote2: Card detect engine will start after SC_CEN (SC_CTL[0] )set.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Card removed</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>CD_INS_F</name>
              <description>Card Detect Insert Status Of SC_CD Pin (Read Only)\nThis bit is set whenever card has been inserted.\nNote1: This bit is read only, but it can be cleared by writing "1" to it.\nNote2: The card detect engine will start after SC_CEN (SC_CTL[0] )set.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Card insert</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>CD_PIN_ST</name>
              <description>Card Detect Status Of SC_CD Pin Status (Read Only)\nThis bit is the pin status flag of SC_CD\n</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The SC_CD pin state at low</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The SC_CD pin state at high</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>CLK_KEEP</name>
              <description>SC Clock Enable Bit \nNote: When operating in activation, warm reset or deactivation mode, this bit will be changed automatically. So don't fill this field when operating in these modes.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>SC clock generation Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>SC clock always keeps free running</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ADAC_CD_EN</name>
              <description>Auto Deactivation When Card Removal\nNote: When the card is removed, hardware will stop any process and then do deactivation sequence (if this bit be setting). If this process completes. Hardware will generate an initial end interrupt to CPU.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Auto deactivation Disabled when hardware detected the card removal</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Auto deactivation Enabled when hardware detected the card removal</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SC_OEN_ST</name>
              <description>SC Data Output Enable Pin Status (Read Only)\nThis bit is the pin status of SC_DATA_OEN\n</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The SC_DATA_OEN pin state at low</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The SC_DATA_OEN pin state at high</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>SC_DATA_O</name>
              <description>SC Data Output Pin \nThis bit is the pin status of SC_DATA_O but user can drive SC_DATA_O pin to high or low by setting this bit.\nNote: When SC is at activation, warm reset or deactivation mode, this bit will be changed automatically. So don't fill this field when SC is in these modes.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Drive SC_DATA_O pin to low</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Drive SC_DATA_O pin to high</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CD_LEV</name>
              <description>Card Detect Level\n\nNote: Software must select card detect level before Smart Card engine is enabled</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>When hardware detects the card detect pin from high to low, it indicates a card is detected</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>When hardware detects the card detect pin from low to high, it indicates a card is detected</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>POW_INV</name>
              <description>SC_POW Pin Inverse\nThis bit is used for inverse the SC_POW pin.\nThere are four kinds of combination for SC_POW pin setting by POW_INV(SC_PINCSR[11]) and POW_EN(SC_PINCSR[0]). POW_INV (SC_PINCSR[11]) is bit 1 and POW_EN(SC_PINCSR[0]) is bit 0 for SC_POW_Pin as high or low voltage selection.\nNote: Software must select POW_INV (SC_PINCSR[11]) before Smart Card  is enabled by SC_CEN (SC_CTL[0]).</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SC_DATA_I_ST</name>
              <description>SC Data Pin Status (Read Only)\nThis bit is the pin status of SC_DATA\n</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The SC_DATA pin is low</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The SC_DATA pin is high</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>SYNC</name>
              <description>SYNC Flag Indicator\nDue to synchronization, software should check this bit when writing a new value to SC_PINCSR register.\nNote: This bit is read only.</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Synchronizing is completion, user can write new data to SC_PINCSR register</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Last value is synchronizing</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SC_TMR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SC_TMR0</displayName>
          <description>SC Internal Timer Control Register 0</description>
          <addressOffset>0x28</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CNT0</name>
              <description>Timer 0 Counter Value (ETU Base)\nThis field indicates the internal timer operation values.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MODE</name>
              <description>Timer 0 Operation Mode Selection\nThis field indicates the internal 24-bit timer operation selection.\nRefer to 6.14.5.4 for programming Timer0</description>
              <bitOffset>24</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SC_TMR1</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SC_TMR1</displayName>
          <description>SC Internal Timer Control Register 1</description>
          <addressOffset>0x2C</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CNT1</name>
              <description>Timer 1 Counter Value (ETU Base)\nThis field indicates the internal timer operation values.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MODE</name>
              <description>Timer 1 Operation Mode Selection\nThis field indicates the internal 8-bit timer operation selection.\nRefer to 6.14.5.4 for programming Timer1</description>
              <bitOffset>24</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SC_TMR2</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SC_TMR2</displayName>
          <description>SC Internal Timer Control Register 2</description>
          <addressOffset>0x30</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CNT2</name>
              <description>Timer 2 Counter Value (ETU Base)\nThis field indicates the internal timer operation values.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MODE</name>
              <description>Timer 2 Operation Mode Selection\nThis field indicates the internal 8-bit timer operation selection\nRefer to 6.14.5.4 for programming Timer2</description>
              <bitOffset>24</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SC_UACTL</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SC_UACTL</displayName>
          <description>SC UART Mode Control Register.</description>
          <addressOffset>0x34</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>UA_MODE_EN</name>
              <description>UART Mode Enable Bit\nNote3: When UART is enabled, hardware will generate a reset to reset FIFO and internal state machine.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Smart Card mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>UART mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA_LEN</name>
              <description>Data Length\nNote: In smart card mode, this DATA_LEN must be '00'</description>
              <bitOffset>4</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Character Data Length is 8 bits</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Character Data Length is 7 bits</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Character Data length is 6 bits</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Character Data Length is 5 bits</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PBDIS</name>
              <description>Parity Bit Disable Bit\nNote: In smart card mode, this field must be '0' (default setting is with parity bit)</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Parity bit is generated or checked between the "last data word bit" and "stop bit" of the serial data</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Parity bit is not generated (transmitting data) or checked (receiving data) during transfer</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>OPE</name>
              <description>Odd Parity Enable Bit\nNote: This bit has effect only when PBDIS bit is '0'.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Even number of logic 1's are transmitted or check the data word and parity bits in receiving mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Odd number of logic 1's are transmitted or check the data word and parity bits in receiving mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SC_TDRA</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SC_TDRA</displayName>
          <description>SC Timer Current Data Register A</description>
          <addressOffset>0x38</addressOffset>
          <access>read-only</access>
          <resetValue>0x000007FF</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TDR0</name>
              <description>Timer0 Current Data Value(Read Only)\nThis field indicates the current count values of timer0.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SC_TDRB</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SC_TDRB</displayName>
          <description>SC Timer Current Data Register B</description>
          <addressOffset>0x3C</addressOffset>
          <access>read-only</access>
          <resetValue>0x00007F7F</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TDR1</name>
              <description>Timer1 Current Data Value(Read Only)\nThis field indicates the current count values of timer1.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TDR2</name>
              <description>Timer2 Current Data Value (Read Only)\nThis field indicates the current count values of timer2.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>SC2</name>
      <description>SC Register Map</description>
      <groupName>SC</groupName>
      <baseAddress>0x40198000</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x0</offset>
        <size>0x40</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>SC_RBR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SC_RBR</displayName>
          <description>SC Receiving Buffer Register.</description>
          <addressOffset>0x0</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>RBR</name>
              <description>Receiving Buffer \nBy reading RBR, the SC will return an 8-bit received data.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SC_THR</name>
          <alternateRegister>SC_RBR</alternateRegister>
          <!-- the display name is an unrestricted string. -->
          <displayName>SC_THR</displayName>
          <description>SC Transmit Holding Register</description>
          <addressOffset>0x0</addressOffset>
          <access>write-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>THR</name>
              <description>Transmit Holding Buffer\nBy writing data to THR, the SC will send out an 8-bit data.\nNote: If SC_CEN(SC_CTL[0]) is not enabled, THR cannot be programmed.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SC_CTL</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SC_CTL</displayName>
          <description>SC Control Register</description>
          <addressOffset>0x4</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SC_CEN</name>
              <description>SC Engine Enable Bit\nSet this bit to 1 to enable SC operation. If this bit is cleared, SC will force all transition to IDLE state.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DIS_RX</name>
              <description>RX Transition Disable Bit\nNote: If AUTO_CON_EN (SC_CTL[3])is enabled, these fields must be ignored.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The receiver Enabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The receiver Disabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DIS_TX</name>
              <description>TX Transition Disable Bit\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The transceiver Enabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The transceiver Disabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>AUTO_CON_EN</name>
              <description>Auto Convention Enable Bit\n</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Auto-convention Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Auto-convention Enabled. When hardware receives TS in answer to reset state and the TS is direct convention, CON_SEL(SC_CTL[5:4]) will be set to 00 automatically, otherwise if the TS is inverse convention, and CON_SEL (SC_CTL[5:4]) will be set to 11</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CON_SEL</name>
              <description>Convention Selection\nNote: If AUTO_CON_EN(SC_CTL[3]) enabled, this fields are ignored.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Direct convention</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reserved</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Reserved</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Inverse convention</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_FTRI_LEV</name>
              <description>Rx Buffer Trigger Level \nWhen the number of bytes in the receiving buffer equals the RX_FTRI_LEV, the RDA_IF will be set (if IER [RDA_IEN] is enabled, an interrupt will be generated).\n</description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>INTR_RDA Trigger Level with 01 Bytes</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>INTR_RDA Trigger Level with 02 Bytes</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>INTR_RDA Trigger Level with 03 Bytes</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Reserved</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BGT</name>
              <description>Block Guard Time (BGT)\nNote: The real block guard time is BGT + 1.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TMR_SEL</name>
              <description>Timer Selection \n</description>
              <bitOffset>13</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>All internal timer function Disabled</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Internal 24 bit timer Enabled. Software can configure it by setting SC_TMR0 [23:0]. SC_TMR1 and SC_TMR2 will be ignored in this mode</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>internal 24 bit timer and 8 bit internal timer Enabled. Software can configure the 24 bit timer by setting SC_TMR0 [23:0] and configure the 8 bit timer by setting SC_TMR1[7:0]. SC_TMR2 will be ignored in this mode</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Internal 24 bit timer and two 8 bit timers Enabled. Software can configure them by setting SC_TMR0 [23:0], SC_TMR1 [7:0] and SC_TMR2 [7:0]</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SLEN</name>
              <description>Stop Bit Length\nThis field indicates the length of stop bit.\nNote: The default stop bit length is 2. SMC and UART adopts SLEN to program the stop bit length</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The stop bit length is 2 ETU</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The stop bit length is 1 ETU</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_ERETRY</name>
              <description>RX Error Retry Count Number\nThis field indicates the maximum number of receiver retries that are allowed when parity error has occurred\nNote1: The real retry number is RX_ERETRY + 1, so 8 is the maximum retry number.\nNote2: This field cannot be changed when RX_ERETRY_EN enabled. The change flow is to disable RX_ETRTRY_EN first and then fill in new retry value.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_ERETRY_EN</name>
              <description>RX Error Retry Enable Bit\nThis bit enables receiver retry function when parity error has occurred.\nNote: Software must fill in the RX_ERETRY value before enabling this bit.</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RX error retry function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RX error retry function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_ERETRY</name>
              <description>TX Error Retry Count Number\nThis field indicates the maximum number of transmitter retries that are allowed when parity error has occurred.\nNote1: The real retry number is TX_ERETRY + 1, so 8 is the maximum retry number.\nNote2: This field cannot be changed when TX_ERETRY_EN enabled. The change flow is to disable TX_ETRTRY_EN first and then fill in new retry value.</description>
              <bitOffset>20</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_ERETRY_EN</name>
              <description>TX Error Retry Enable Bit\nThis bit enables transmitter retry function when parity error has occurred.\n</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>TX error retry function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>TX error retry function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CD_DEB_SEL</name>
              <description>Card Detect De-Bounce Selection\nThis field indicates the card detect de-bounce selection.\n</description>
              <bitOffset>24</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>De-bounce sample card insert once per 384 (128 * 3) SC peripheral clocks and de-bounce sample card removal once per 128 SC peripheral clocks</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>De-bounce sample card insert once per 192 (64 * 3) SC peripheral clocks and de-bounce sample card removal once per 64 SC peripheral clocks</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>De-bounce sample card insert once per 96 (32 * 3) SC peripheral clocks and de-bounce sample card removal once per 32 SC peripheral clocks</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>De-bounce sample card insert once per 48 (16 * 3) SC peripheral clocks and de-bounce sample card removal once per 16 SC peripheral clocks</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SYNC</name>
              <description>SYNC Flag Indicator\nDue to synchronization, software should check this bit before writing a new value to RX_ERETRY and TX_ERETRY.\nNote: This bit is read only.</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>synchronizing is completion, user can write new data to RX_ERETRY and TX_ERETRY</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Last value is synchronizing</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SC_ALTCTL</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SC_ALTCTL</displayName>
          <description>SC Alternate Control Register</description>
          <addressOffset>0x8</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TX_RST</name>
              <description>TX Software Reset\nWhen TX_RST is set, all the bytes in the transmit buffer and TX internal state machine will be cleared.\nNote: This bit will be auto cleared after reset is complete.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reset the TX internal state machine and pointers</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_RST</name>
              <description>Rx Software Reset\nWhen RX_RST is set, all the bytes in the receiver buffer and Rx internal state machine will be cleared.\nNote: This bit will be auto cleared after reset is complete.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reset the Rx internal state machine and pointers</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DACT_EN</name>
              <description>Deactivation Sequence Generator Enable Bit\nThis bit enables SC controller to initiate the card by deactivation sequence\nNote1: When the deactivation sequence completed, this bit will be cleared automatically and the INIT_IS(SC_ISR[8]) will be set to 1.\nNote2: This field will be cleared by TX_RST (SC_ALTCTL[0]) and RX_RST(SC_ALTCTL[1]). So don't fill this bit, TX_RST, and RX_RST at the same time.\nNote3: If SC_CEN (SC_CTL[0]) is not enabled, this filed cannot be programmed.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Deactivation sequence generator Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ACT_EN</name>
              <description>Activation Sequence Generator Enable Bit\nThis bit enables SC controller to initiate the card by activation sequence\nNote1: When the activation sequence completed, this bit will be cleared automatically and the INIT_IS(SC_ISR[8]) will be set to 1.\nNote2: This field will be cleared by TX_RST(SC_ALTCTL[0]) and RX_RST(SC_ALTCTL[1]), so don't fill this bit, TX_RST(SC_ALTCTL[0]), and RX_RST(SC_ALTCTL[1]) at the same time.\nNote3: If SC_CEN(SC_CTL[0]) is not enabled, this filed cannot be programmed.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Activation sequence generator Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>WARST_EN</name>
              <description>Warm Reset Sequence Generator Enable Bit\nThis bit enables SC controller to initiate the card by warm reset sequence\nNote1: When the warm reset sequence completed, this bit will be cleared automatically and the INIT_IS(SC_ISR[8]) will be set to 1.\nNote2: This field will be cleared by TX_RST(SC_ALTCTL[0]) and RX_RST(SC_ALTCTL[1]), so don't fill this bit, TX_RST, and RX_RST at the same time.\nNote3: If SC_CEN(SC_CTL[0]) is not enabled, this filed cannot be programmed.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Warm reset sequence generator Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TMR0_SEN</name>
              <description>Internal Timer0 Start Enable Bit\nThis bit enables Timer 0 to start counting. Software can fill 0 to stop it and set 1 to reload and count.\nNote3: This field will be cleared by TX_RST(SC_ALTCTL[0]) and RX_RST(SC_ALTCTL[1]). So don't fill this bit, TX_RST and RX_RST at the same time.\nNote4: If SC_CEN(SC_CTL[0]) is not enabled, this filed cannot be programmed.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Stops counting</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Start counting</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TMR1_SEN</name>
              <description>Internal Timer1 Start Enable Bit\nThis bit enables Timer 1 to start counting. Software can fill 0 to stop it and set 1 to reload and count.\nNote3: This field will be cleared by TX_RST(SC_ALTCTL[0]) and RX_RST(SC_ALTCTL[1]), so don't fill this bit, TX_RST(SC_ALTCTL[0]), and RX_RST(SC_ALTCTL[1]) at the same time.\nNote4: If SC_CEN(SC_CTL[0]) is not enabled, this filed cannot be programmed.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Stops counting</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Start counting</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TMR2_SEN</name>
              <description>Internal Timer2 Start Enable Bit\nThis bit enables Timer 2 to start counting. Software can fill 0 to stop it and set 1 to reload and count.\nNote3: This field will be cleared by TX_RST(SC_ALTCTL[0]) and RX_RST(SC_ALTCTL[1]). So don't fill this bit, TX_RST(SC_ALTCTL[0]), and RX_RST(SC_ALTCTL[1]) at the same time.\nNote4: If SC_CEN(SC_CTL[0]) is not enabled, this filed cannot be programmed.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Stops counting</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Start counting</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>INIT_SEL</name>
              <description>Initial Timing Selection\nThis fields indicates the timing of hardware initial state (activation or warm-reset or deactivation).\nUnit: SC clock\nActivation: refer to SC Activation Sequence in Figure 679.\nWarm-reset: refer to Warm-Reset Sequence in Figure 680.\nDeactivation: refer to Deactivation Sequence in Figure 681.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_BGT_EN</name>
              <description>Receiver Block Guard Time Function Enable Bit\n</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Receiver block guard time function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Receiver block guard time function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TMR0_ATV</name>
              <description>Internal Timer0 Active State (Read Only)\nThis bit indicates the timer counter status of timer0.\n</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Timer0 is not active</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Timer0 is active</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>TMR1_ATV</name>
              <description>Internal Timer1 Active State (Read Only)\nThis bit indicates the timer counter status of timer1.\n</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Timer1 is not active</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Timer1 is active</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>TMR2_ATV</name>
              <description>Internal Timer2 Active State (Read Only)\nThis bit indicates the timer counter status of timer2.\n</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Timer2 is not active</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Timer2 is active</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>OUTSEL</name>
              <description>Smartcard Data Pin Output Mode Selection\nUse this bit to select smartcard data pin (SC_DATA) output mode\n</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Quasi mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Open-drain mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SC_EGTR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SC_EGTR</displayName>
          <description>SC Extend Guard Time Register</description>
          <addressOffset>0xC</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>EGT</name>
              <description>Extended Guard Time\nThis field indicates the extended guard timer value.\nNote: The counter is ETU base and the real extended guard time is EGT.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SC_RFTMR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SC_RFTMR</displayName>
          <description>SC Receive Buffer Time-out Register</description>
          <addressOffset>0x10</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RFTM</name>
              <description>SC Receiver Buffer Time-Out  (ETU Base)\nNote1: The counter unit is ETU based and the interval of time-out is RFTM + 0.5\nNote2: Fill all 0 to this field indicates to disable this function.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>9</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SC_ETUCR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SC_ETUCR</displayName>
          <description>SC ETU Control Register</description>
          <addressOffset>0x14</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000173</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ETU_RDIV</name>
              <description>ETU Rate Divider\nThe field indicates the clock rate divider.\nThe real ETU is ETU_RDIV + 1.\nNote: Software can configure this field, but this field must be greater than 0x004.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>12</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>COMPEN_EN</name>
              <description>Compensation Mode Enable Bit\nThis bit enables clock compensation function. When this bit enabled, hardware will alternate between n clock cycles and n-1 clock cycles, where n is the value to be written into the ETU_RDIV .\n</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Compensation function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Compensation function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SC_IER</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SC_IER</displayName>
          <description>SC Interrupt Enable Control Register</description>
          <addressOffset>0x18</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RDA_IE</name>
              <description>Receive Data Reach Interrupt Enable Bit\nThis field is used for received data reaching trigger level RX_FTRI_LEV (SC_CTL[7:6]) interrupt enable.\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Receive data reach trigger level interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Receive data reach trigger level interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TXBE_IE</name>
              <description>Transmit Buffer Empty Interrupt Enable Bit\nThis field is used for transmit buffer empty interrupt enable.\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Transmit buffer empty interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Transmit buffer empty interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TERR_IE</name>
              <description>Transfer Error Interrupt Enable Bit\nThis field is used for transfer error interrupt enable. The transfer error states is at SC_SR register which includes receiver break error RX_EBR_F(SC_SR[6]), frame error RX_EFR_F(SC_SR[5]), parity error RX_EPA_F(SC_SR[4]), receiver buffer overflow error RX_OVER_F(SC_SR[0]), transmit buffer overflow error TX_OVER_F(SC_SR[8]), receiver retry over limit error RX_OVER_REERR(SC_SR[22]) and transmitter retry over limit error TX_OVER_REERR(SC_SR[30]).\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Transfer error interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Transfer error interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TMR0_IE</name>
              <description>Timer0 Interrupt Enable Bit\nThis field is used to enable TMR0 interrupt enable.\n</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Timer0 interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Timer0 interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TMR1_IE</name>
              <description>Timer1 Interrupt Enable Bit\nThis field is used to enable the TMR1 interrupt.\n</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Timer1 interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Timer1 interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TMR2_IE</name>
              <description>Timer2 Interrupt Enable Bit\nThis field is used for TMR2 interrupt enable.\n</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Timer2 interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Timer2 interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BGT_IE</name>
              <description>Block Guard Time Interrupt Enable Bit\nThis field is used for block guard time interrupt enable.\n</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Block guard time Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Block guard time Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CD_IE</name>
              <description>Card Detect Interrupt Enable Bit\nThis field is used for card detect interrupt enable. The card detect status is CD_INS_F(SC_SR[12]) \n</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Card detect interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Card detect interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>INIT_IE</name>
              <description>Initial End Interrupt Enable Bit\n</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Initial end interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Initial end interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RTMR_IE</name>
              <description>Receiver Buffer Time-Out Interrupt Enable Bit \nThis field is used for receiver buffer time-out interrupt enable.\n</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Receiver buffer time-out interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Receiver buffer time-out interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ACON_ERR_IE</name>
              <description>Auto Convention Error Interrupt Enable Bit \nThis field is used for auto-convention error interrupt enable.\n</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Auto-convention error interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Auto-convention error interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SC_ISR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SC_ISR</displayName>
          <description>SC Interrupt Status Register</description>
          <addressOffset>0x1C</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000002</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RDA_IS</name>
              <description>Receive Data Reach Interrupt Status Flag (Read Only)\nThis field is used for received data reaching trigger level RX_FTRI_LEV (SC_CTL[7:6]) interrupt status flag.\nNote: This field is the status flag of received data reaching RX_FTRI_LEV (SC_CTL[7:6]). If software reads data from SC_RBR and receiver buffer data byte number is less than RX_FTRI_LEV (SC_CTL[7:6]), this bit will be cleared automatically.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TBE_IS</name>
              <description>Transmit Buffer Empty Interrupt Status Flag (Read Only)\nThis field is used for transmit buffer empty interrupt status flag.\nNote: This field is the status flag of transmit buffer empty state. If software wants to clear this bit, software must write data to THR(SC_THR[7:0]) buffer and then this bit will be cleared automatically.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TERR_IS</name>
              <description>Transfer Error Interrupt Status Flag (Read Only)\nThis field is used for transfer error interrupt status flag. The transfer error states is at  SC_SR register which includes receiver break error RX_EBR_F(SC_SR[6]), frame error RX_EFR_F(SC_TRSR[5], parity error RX_EPA_F(SC_TRSR[4] and receiver buffer overflow error RX_OVER_F(SC_TRSR[0]), transmit buffer overflow error TX_OVER_F(SC_TRSR[8]), receiver retry over limit error RX_OVER_REERR(SC_TRSR[22] and transmitter retry over limit error TX_OVER_REERR(SC_TRSR[30]).\nNote: This field is the status flag of RX_EBR_F(SC_TRSR[6]), RX_EFR_F(SC_TRSR[5]), RX_EPA_F(SC_TRSR[4]), RX_OVER_F(SC_TRSR[0]), TX_OVER_F(SC_TRSR[8]), RX_OVER_REERR(SC_TRSR[22]) or TX_OVER_REERR(SC_TRSR[30]). So, if software wants to clear this bit, software must write 1 to each field.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TMR0_IS</name>
              <description>Timer0 Interrupt Status Flag (Read Only)\nThis field is used for TMR0 interrupt status flag.\nNote: This bit is read only, but it can be cleared by writing 1 to it.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TMR1_IS</name>
              <description>Timer1 Interrupt Status Flag (Read Only)\nThis field is used for TMR1 interrupt status flag.\nNote: This bit is read only, but it can be cleared by writing 1 to it.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TMR2_IS</name>
              <description>Timer2 Interrupt Status Flag (Read Only)\nThis field is used for TMR2 interrupt status flag.\nNote: This bit is read only, but it can be cleared by writing 1 to it.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>BGT_IS</name>
              <description>\n</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>CD_IS</name>
              <description>Card Detect Interrupt Status Flag (Read Only)\nThis field is used for card detect interrupt status flag. The card detect status  is CD_INS_F (SC_SR[12]) and CD_REM_F(SC_SR[11]).\nNote: This field is the status flag of CD_INS_F(SC_SR[12]) or CD_REM_F(SC_TRSR[11])]. So if software wants to clear this bit, software must write 1 to this field.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>INIT_IS</name>
              <description>Initial End Interrupt Status Flag (Read Only)\nThis field is used for activation (ACT_EN(SC_ALTCTL[3])), deactivation (DACT_EN (SC_ALTCTL[2])) and warm reset (WARST_EN (SC_ALTCTL[4])) sequence interrupt status flag.\nNote: This bit is read only, but it can be cleared by writing 1 to it.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RTMR_IS</name>
              <description>Receiver Buffer Time-Out Interrupt Status Flag (Read Only)\nThis field is used for receiver buffer time-out interrupt status flag.\nNote: This field is the status flag of receiver buffer time-out state. If software wants to clear this bit, software must read all receiver buffer remaining data by reading SC_RBR buffer,</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ACON_ERR_IS</name>
              <description>Auto Convention Error Interrupt Status Flag (Read Only)\nThis field indicates auto convention sequence error. If the received TS at ATR state is neither 0x3B nor 0x3F, this bit will be set.\nNote: This bit is read only, but it can be cleared by writing 1 to it.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SC_TRSR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SC_TRSR</displayName>
          <description>SC Status Register</description>
          <addressOffset>0x20</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000202</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RX_OVER_F</name>
              <description>RX Overflow Error Status Flag (Read Only) \nThis bit is set when RX buffer overflow.\nIf the number of received bytes is greater than Rx Buffer size (4 bytes), this bit will be set.\nNote: This bit is read only, but it can be cleared by writing 1 to it.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RX_EMPTY_F</name>
              <description>Receiver Buffer Empty Status Flag(Read Only)\nThis bit indicates RX buffer empty or not.\nWhen the last byte of Rx buffer has been read by CPU, hardware sets this bit high. It will be cleared when SC receives any new data.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RX_FULL_F</name>
              <description>Receiver Buffer Full Status Flag (Read Only)\nThis bit indicates RX buffer full or not.\nThis bit is set when RX pointer is equal to 4, otherwise it is cleared by hardware.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RX_EPA_F</name>
              <description>Receiver Parity Error Status Flag (Read Only)\nThis bit is set to logic 1 whenever the received character does not have a valid "parity bit".\nNote1: This bit is read only, but it can be cleared by writing 1 to it.\nNote2: If CPU sets receiver retries function by setting RX_ERETRY_EN(SC_CTL[19]) , hardware will not set this flag.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RX_EFR_F</name>
              <description>Receiver Frame Error Status Flag (Read Only)\nThis bit is set to logic 1 whenever the received character does not have a valid "stop bit" (that is, the stop bit following the last data bit or parity bit is detected as logic 0). \nNote1: This bit is read only, but it can be cleared by writing 1 to it.\nNote2: If CPU sets receiver retries function by setting RX_ERETRY_EN(SC_CTL[19]) , hardware will not set this flag.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RX_EBR_F</name>
              <description>Receiver Break Error Status Flag (Read Only)\nThis bit is set to logic 1 whenever the received data input (RX) held in the "spacing state" (logic 0) is longer than a full word transmission time (that is, the total time of "start bit" + data bits + parity + stop bits). .\nNote1: This bit is read only, but it can be cleared by writing 1 to it.\nNote2: If CPU sets receiver retries function by setting RX_ERETRY_EN(SC_CTL[19]) , hardware will not set this flag.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TX_OVER_F</name>
              <description>TX Overflow Error Interrupt Status Flag (Read Only)\nIf TX buffer is full, an additional write to THR(SC_THR[7:0]) will cause this bit be set to "1" by hardware. \nNote: This bit is read only, but it can be cleared by writing 1 to it.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TX_EMPTY_F</name>
              <description>Transmit Buffer Empty Status Flag (Read Only)\nThis bit indicates TX buffer empty or not.\nWhen the last byte of TX buffer has been transferred to Transmitter Shift Register, hardware sets this bit high. It will be cleared when writing data into THR(SC_THR[7:0]) (TX buffer not empty).</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TX_FULL_F</name>
              <description>Transmit Buffer Full Status Flag (Read Only)\nThis bit indicates TX buffer full or not.This bit is set when TX pointer is equal to 4, otherwise is cleared by hardware.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RX_POINT_F</name>
              <description>Receiver Buffer Pointer Status Flag (Read Only)\nThis field indicates the RX buffer pointer status flag. When SC receives one byte from external device, RX_POINT_F(SC_SR[17:16]) increases one. When one byte of RX buffer is read by CPU, RX_POINT_F(SC_SR[17:16]) decreases one.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RX_REERR</name>
              <description>Receiver Retry Error (Read Only)\nThis bit is set by hardware when RX has any error and retries transfer.\nNote1: This bit is read only, but it can be cleared by writing 1 to it.\nNote2 This bit is a flag and cannot generate any interrupt to CPU.\nNote3: If CPU enables receiver retry function by setting RX_ERETRY_EN (SC_CTL[19]) , the RX_EPA_F(SC_TRSR[4]) flag will be ignored (hardware will not set RX_EPA_F(SC_TRSR[4])).</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RX_OVER_REERR</name>
              <description>Receiver Over Retry Error (Read Only)\nThis bit is set by hardware when RX transfer error retry over retry number limit.\nNote1: This bit is read only, but it can be cleared by writing 1 to it.\nNote2: If CPU enables receiver retries function by setting RX_ERETRY_EN (SC_CTL[19]), the RX_EPA_F(SC_TRSR[4]) flag will be ignored (hardware will not set RX_EPA_F(SC_TRSR[4])).</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RX_ATV</name>
              <description>Receiver In Active Status Flag (Read Only)\nThis bit is set by hardware when RX transfer is in active.\nThis bit is cleared automatically when RX transfer is finished.</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TX_POINT_F</name>
              <description>Transmit Buffer Pointer Status Flag (Read Only)\nThis field indicates the TX buffer pointer status flag. When CPU writes data into SC_THR, TX_POINT_F increases one. When one byte of TX Buffer is transferred to transmitter shift register, TX_POINT_F decreases one.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TX_REERR</name>
              <description>Transmitter Retry Error (Read Only)\nThis bit is set by hardware when transmitter re-transmits.\nNote1: This bit is read only, but it can be cleared by writing 1 to it.\nNote2 This bit is a flag and cannot generate any interrupt to CPU.</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TX_OVER_REERR</name>
              <description>Transmitter Over Retry Error (Read Only)\nThis bit is set by hardware when transmitter re-transmits over retry number limitation.\nNote: This bit is read only, but it can be cleared by writing 1 to it.</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TX_ATV</name>
              <description>Transmit In Active Status Flag (Read Only)\n</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>This bit is cleared automatically when TX transfer is finished or the last byte transmission has completed</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>This bit is set by hardware when TX transfer is in active and the STOP bit of the last byte has been transmitted</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SC_PINCSR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SC_PINCSR</displayName>
          <description>SC Pin Control State Register</description>
          <addressOffset>0x24</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFF0F</resetMask>
          <fields>
            <field>
              <name>POW_EN</name>
              <description>SC_POW_EN Pin Signal\nSoftware can set POW_EN (SC_PINCSR[0]) and POW_INV (SC_PINCSR[11])to decide SC_PWR pin is in high or low level.\nWrite this field to drive SC_PWR pin\nRefer POW_INV (SC_PINCSR[11]) description for programming SC_PWR pin voltage level. \nRead this field to get SC_PWR pin status.\nNote: When operating at activation, warm reset or deactivation mode, this bit will be changed automatically. So don't fill this field when operating in these modes.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>SC_PWR pin status is low</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>SC_PWR pin status is high</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SC_RST</name>
              <description>SC_RST Pin Signal\nThis bit is the pin status of SC_RST but user can drive SC_RST pin to high or low by setting this bit.\nWrite this field to drive SC_RST pin.\nNote: When operating at activation, warm reset or deactivation mode, this bit will be changed automatically. So don't fill this field when operating in these modes.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Drive SC_RST pin to low.\nSC_RST pin status is low</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Drive SC_RST pin to high.\nSC_RST pin status is high</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CD_REM_F</name>
              <description>Card Detect Removal Status Of SC_CD Pin (Read Only)\nThis bit is set whenever a card has been removed.\nNote1: This bit is read only, but it can be cleared by writing "1" to it.\nNote2: Card detect engine will start after SC_CEN (SC_CTL[0] )set.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Card removed</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>CD_INS_F</name>
              <description>Card Detect Insert Status Of SC_CD Pin (Read Only)\nThis bit is set whenever card has been inserted.\nNote1: This bit is read only, but it can be cleared by writing "1" to it.\nNote2: The card detect engine will start after SC_CEN (SC_CTL[0] )set.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Card insert</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>CD_PIN_ST</name>
              <description>Card Detect Status Of SC_CD Pin Status (Read Only)\nThis bit is the pin status flag of SC_CD\n</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The SC_CD pin state at low</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The SC_CD pin state at high</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>CLK_KEEP</name>
              <description>SC Clock Enable Bit \nNote: When operating in activation, warm reset or deactivation mode, this bit will be changed automatically. So don't fill this field when operating in these modes.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>SC clock generation Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>SC clock always keeps free running</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ADAC_CD_EN</name>
              <description>Auto Deactivation When Card Removal\nNote: When the card is removed, hardware will stop any process and then do deactivation sequence (if this bit be setting). If this process completes. Hardware will generate an initial end interrupt to CPU.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Auto deactivation Disabled when hardware detected the card removal</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Auto deactivation Enabled when hardware detected the card removal</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SC_OEN_ST</name>
              <description>SC Data Output Enable Pin Status (Read Only)\nThis bit is the pin status of SC_DATA_OEN\n</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The SC_DATA_OEN pin state at low</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The SC_DATA_OEN pin state at high</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>SC_DATA_O</name>
              <description>SC Data Output Pin \nThis bit is the pin status of SC_DATA_O but user can drive SC_DATA_O pin to high or low by setting this bit.\nNote: When SC is at activation, warm reset or deactivation mode, this bit will be changed automatically. So don't fill this field when SC is in these modes.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Drive SC_DATA_O pin to low</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Drive SC_DATA_O pin to high</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CD_LEV</name>
              <description>Card Detect Level\n\nNote: Software must select card detect level before Smart Card engine is enabled</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>When hardware detects the card detect pin from high to low, it indicates a card is detected</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>When hardware detects the card detect pin from low to high, it indicates a card is detected</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>POW_INV</name>
              <description>SC_POW Pin Inverse\nThis bit is used for inverse the SC_POW pin.\nThere are four kinds of combination for SC_POW pin setting by POW_INV(SC_PINCSR[11]) and POW_EN(SC_PINCSR[0]). POW_INV (SC_PINCSR[11]) is bit 1 and POW_EN(SC_PINCSR[0]) is bit 0 for SC_POW_Pin as high or low voltage selection.\nNote: Software must select POW_INV (SC_PINCSR[11]) before Smart Card  is enabled by SC_CEN (SC_CTL[0]).</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SC_DATA_I_ST</name>
              <description>SC Data Pin Status (Read Only)\nThis bit is the pin status of SC_DATA\n</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The SC_DATA pin is low</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The SC_DATA pin is high</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>SYNC</name>
              <description>SYNC Flag Indicator\nDue to synchronization, software should check this bit when writing a new value to SC_PINCSR register.\nNote: This bit is read only.</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Synchronizing is completion, user can write new data to SC_PINCSR register</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Last value is synchronizing</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SC_TMR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SC_TMR0</displayName>
          <description>SC Internal Timer Control Register 0</description>
          <addressOffset>0x28</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CNT0</name>
              <description>Timer 0 Counter Value (ETU Base)\nThis field indicates the internal timer operation values.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MODE</name>
              <description>Timer 0 Operation Mode Selection\nThis field indicates the internal 24-bit timer operation selection.\nRefer to 6.14.5.4 for programming Timer0</description>
              <bitOffset>24</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SC_TMR1</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SC_TMR1</displayName>
          <description>SC Internal Timer Control Register 1</description>
          <addressOffset>0x2C</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CNT1</name>
              <description>Timer 1 Counter Value (ETU Base)\nThis field indicates the internal timer operation values.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MODE</name>
              <description>Timer 1 Operation Mode Selection\nThis field indicates the internal 8-bit timer operation selection.\nRefer to 6.14.5.4 for programming Timer1</description>
              <bitOffset>24</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SC_TMR2</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SC_TMR2</displayName>
          <description>SC Internal Timer Control Register 2</description>
          <addressOffset>0x30</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CNT2</name>
              <description>Timer 2 Counter Value (ETU Base)\nThis field indicates the internal timer operation values.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MODE</name>
              <description>Timer 2 Operation Mode Selection\nThis field indicates the internal 8-bit timer operation selection\nRefer to 6.14.5.4 for programming Timer2</description>
              <bitOffset>24</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SC_UACTL</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SC_UACTL</displayName>
          <description>SC UART Mode Control Register.</description>
          <addressOffset>0x34</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>UA_MODE_EN</name>
              <description>UART Mode Enable Bit\nNote3: When UART is enabled, hardware will generate a reset to reset FIFO and internal state machine.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Smart Card mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>UART mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA_LEN</name>
              <description>Data Length\nNote: In smart card mode, this DATA_LEN must be '00'</description>
              <bitOffset>4</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Character Data Length is 8 bits</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Character Data Length is 7 bits</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Character Data length is 6 bits</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Character Data Length is 5 bits</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PBDIS</name>
              <description>Parity Bit Disable Bit\nNote: In smart card mode, this field must be '0' (default setting is with parity bit)</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Parity bit is generated or checked between the "last data word bit" and "stop bit" of the serial data</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Parity bit is not generated (transmitting data) or checked (receiving data) during transfer</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>OPE</name>
              <description>Odd Parity Enable Bit\nNote: This bit has effect only when PBDIS bit is '0'.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Even number of logic 1's are transmitted or check the data word and parity bits in receiving mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Odd number of logic 1's are transmitted or check the data word and parity bits in receiving mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SC_TDRA</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SC_TDRA</displayName>
          <description>SC Timer Current Data Register A</description>
          <addressOffset>0x38</addressOffset>
          <access>read-only</access>
          <resetValue>0x000007FF</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TDR0</name>
              <description>Timer0 Current Data Value(Read Only)\nThis field indicates the current count values of timer0.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SC_TDRB</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SC_TDRB</displayName>
          <description>SC Timer Current Data Register B</description>
          <addressOffset>0x3C</addressOffset>
          <access>read-only</access>
          <resetValue>0x00007F7F</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TDR1</name>
              <description>Timer1 Current Data Value(Read Only)\nThis field indicates the current count values of timer1.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TDR2</name>
              <description>Timer2 Current Data Value (Read Only)\nThis field indicates the current count values of timer2.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>PS2</name>
      <description>PS2 Register Map</description>
      <groupName>PS2</groupName>
      <baseAddress>0x40100000</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x0</offset>
        <size>0x20</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>PS2CON</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PS2CON</displayName>
          <description>PS/2 Control Register</description>
          <addressOffset>0x0</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PS2EN</name>
              <description>PS/2 Device Enable Bit\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TXINTEN</name>
              <description>Transmit Interrupt Enable Bit\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Data transmit complete interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Data transmit complete interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RXINTEN</name>
              <description>Receive Interrupt Enable Bit\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Data receive complete interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Data receive complete interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TXFIFO_DEPTH</name>
              <description>Transmit Data FIFO Depth\nThere is a 16 bytes buffer for data transmit. Software can define the FIFO depth from 1 to 16 bytes depends on application.\n</description>
              <bitOffset>3</bitOffset>
              <bitWidth>4</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>1 byte</description>
                    <value>0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>2 bytes</description>
                    <value>1</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>14</name>
                    <description>15 bytes</description>
                    <value>14</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>15</name>
                    <description>16 bytes</description>
                    <value>15</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ACK</name>
              <description>Acknowledge Enable Bit\n</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Always send acknowledge to host at 12th clock for host to device communication</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>If parity bit error or stop bit is not received correctly, acknowledge bit will not be sent to host at 12th clock</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CLRFIFO</name>
              <description>Clear TX FIFO\nWrite 1 to this bit to terminate device to host transmission. The TXEMPTY(PS2STATUS[7]) bit will be set to 1 and pointer BYTEIDX (PS2STATUS[11:8]) is reset to 0 regardless there is residue data in buffer or not. The buffer content is not been cleared.\n</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Not active</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Clear FIFO</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>OVERRIDE</name>
              <description>Software Override PS/2 CLK/DATA Pin State\n</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PS2_CLK and PS2_DATA pins are controlled by internal state machine</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PS2_CLK and PS2_DATA pins are controlled by software</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>FPS2CLK</name>
              <description>Force PS2CLK Line\nIt forces PS2_CLK line high or low regardless of the internal state of the device controller if OVERRIDE(PS2CON[9]) is set to 1.\n</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Force PS2_CLK line low</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Force PS2_CLK line high</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>FPS2DAT</name>
              <description>Force PS2DATA Line\nIt forces PS2_DATA high or low regardless of the internal state of the device controller if OVERRIDE (PS2CON[9]) is set to 1.\n</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Force PS2_DATA low</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Force PS2_DATA high</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PS2TXDATA0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PS2TXDATA0</displayName>
          <description>PS/2 Transmit Data Register 0</description>
          <addressOffset>0x4</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PS2TXDATAx</name>
              <description>Transmit Data\nWriting data to this register starts in device to host communication if bus is in IDLE state. Software must enable PS2EN(PS2CON[0]) before writing data to TX buffer.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PS2TXDATA0">
          <name>PS2TXDATA1</name>
          <displayName>PS2TXDATA1</displayName>
          <description>PS/2 Transmit Data Register 1</description>
          <addressOffset>0x8</addressOffset>
       </register>
       <register derivedFrom="PS2TXDATA0">
          <name>PS2TXDATA2</name>
          <displayName>PS2TXDATA2</displayName>
          <description>PS/2 Transmit Data Register 2</description>
          <addressOffset>0xC</addressOffset>
       </register>
       <register derivedFrom="PS2TXDATA0">
          <name>PS2TXDATA3</name>
          <displayName>PS2TXDATA3</displayName>
          <description>PS/2 Transmit Data Register 3</description>
          <addressOffset>0x10</addressOffset>
       </register>
       <register>
          <name>PS2RXDATA</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PS2RXDATA</displayName>
          <description>PS/2 Receive Data Register</description>
          <addressOffset>0x14</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RXDATA</name>
              <description>Received Data\nFor host to device communication, after acknowledge bit is sent, the received data is copied from receive shift register to PS2RXDATA register. CPU must read this register before next byte reception complete, otherwise the data will be overwritten and RXOVF(PS2STATUS[6]) bit will be set to 1.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PS2STATUS</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PS2STATUS</displayName>
          <description>PS/2 Status Register</description>
          <addressOffset>0x18</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000083</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PS2CLK</name>
              <description>CLK Pin State\nThis bit reflects the status of the PS2_CLK line after synchronizing.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PS2DATA</name>
              <description>DATA Pin State\nThis bit reflects the status of the PS2_DATA line after synchronizing and sampling.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FRAMERR</name>
              <description>Frame Error\nFor host to device communication, this bit sets to 1 if STOP bit (logic 1) is not received. If frame error occurs, the PS/2_DATA line may keep at low state after 12th clock. At this moment, software overrides PS2_CLK to send clock till PS2_DATA release to high state. After that, device sends a "Resend" command to host.\nWrite 1 to clear this bit.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No frame error</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Frame error occur</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RXPARITY</name>
              <description>Received Parity\nThis bit reflects the parity bit for the last received data byte (odd parity).\nThis bit is read only.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXBUSY</name>
              <description>Receive Busy\nThis bit indicates that the PS/2 device is currently receiving data.\nThis bit is read only.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Idle</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Currently receiving data</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TXBUSY</name>
              <description>Transmit Busy\nThis bit indicates that the PS/2 device is currently sending data.\nThis bit is read only.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Idle</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Currently sending data</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RXOVF</name>
              <description>RX Buffer Overwrite\nWrite 1 to clear this bit.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No overwrite</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Data in PS2RXDATA register is overwritten by new received data</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TXEMPTY</name>
              <description>TX FIFO Empty\nWhen software writes data to PS2TXDATA0-3, the TXEMPTY bit is cleared to 0 immediately if PS2EN(PS2CON[0]) is enabled. When transmitted data byte number is equal to TXFIFO_DEPTH (PS2CON[6:3]) then TXEMPTY bit is set to 1.\nThis bit is read only.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>There is data to be transmitted</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>FIFO is empty</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BYTEIDX</name>
              <description>Byte Index\nIt indicates which data byte in transmit data shift register. When all data in FIFO is transmitted and it will be cleared to 0.\nThis bit is read only.\n</description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PS2TXDATA0[7:0]</description>
                    <value>#0000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PS2TXDATA0[15:8]</description>
                    <value>#0001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>PS2TXDATA0[23:16]</description>
                    <value>#0010</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>PS2TXDATA0[31:24]</description>
                    <value>#0011</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>4</name>
                    <description>PS2TXDATA1[7:0]</description>
                    <value>#0100</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>5</name>
                    <description>PS2TXDATA1[15:8]</description>
                    <value>#0101</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>6</name>
                    <description>PS2TXDATA1[23:16]</description>
                    <value>#0110</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>7</name>
                    <description>PS2TXDATA1[31:24]</description>
                    <value>#0111</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>8</name>
                    <description>PS2TXDATA2[7:0]</description>
                    <value>#1000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>9</name>
                    <description>PS2TXDATA2[15:8]</description>
                    <value>#1001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>10</name>
                    <description>PS2TXDATA2[23:16]</description>
                    <value>#1010</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>11</name>
                    <description>PS2TXDATA2[31:24]</description>
                    <value>#1011</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>12</name>
                    <description>PS2TXDATA3[7:0]</description>
                    <value>#1100</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>13</name>
                    <description>PS2TXDATA3[15:8]</description>
                    <value>#1101</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>14</name>
                    <description>PS2TXDATA3[23:16]</description>
                    <value>#1110</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>15</name>
                    <description>PS2TXDATA3[31:24]</description>
                    <value>#1111</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PS2INTID</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PS2INTID</displayName>
          <description>PS/2 Interrupt Identification Register</description>
          <addressOffset>0x1C</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RXINT</name>
              <description>Receive Interrupt\nThis bit is set to 1 when acknowledge bit is sent for Host to device communication. Interrupt occurs if RXINTEN(PS2CON[2]) bit is set to 1.\nWrite 1 to clear this bit to 0.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No interrupt</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Receive interrupt occurs</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TXINT</name>
              <description>Transmit Interrupt\nThis bit is set to 1 after STOP bit is transmitted. Interrupt occur if TXINTEN(PS2CON[1]) bit is set to 1.\nWrite 1 to clear this bit to 0.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No interrupt</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Transmit interrupt occurs</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>I2C0</name>
      <description>I2C Register Map</description>
      <groupName>I2C</groupName>
      <baseAddress>0x40020000</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x0</offset>
        <size>0x34</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x3C</offset>
        <size>0x8</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>I2CON</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>I2CON</displayName>
          <description>I2C Control Register</description>
          <addressOffset>0x0</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>AA</name>
              <description>Assert Acknowledge Control\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SI</name>
              <description>I2C Interrupt Flag\nWhen a new I2C state is present in the I2CSTATUS register, the SI flag is set by hardware, and if bit EI (I2CON [7]) is set, the I2C interrupt is requested. SI must be cleared by software. Clear SI by writing 1 to this bit.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>STO</name>
              <description>I2C STOP Control\nIn Master mode, setting STO to transmit a STOP condition to bus then I2C hardware will check the bus condition if a STOP condition is detected this bit will be cleared by hardware automatically. In a slave mode, setting STO resets I2C hardware to the defined "not addressed" slave mode. This means it is NO LONGER in the slave receiver mode to receive data from the master transmit device.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>STA</name>
              <description>I2C START Control\nSetting STA to logic 1 to enter Master mode, the I2C hardware sends a START or repeat START condition to bus when the bus is free.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ENS1</name>
              <description>I2C Controller Enable Bit\n</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>EI</name>
              <description>Interrupt Enable Bit\n</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>I2C interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>I2C interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>I2CADDR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>I2CADDR0</displayName>
          <description>I2C Slave Address Register0</description>
          <addressOffset>0x4</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>GC</name>
              <description>General Call Function\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>General Call Function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>General Call Function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>I2CADDR</name>
              <description>I2C Address Register\nThe content of this register is irrelevant when I2C is in Master mode. In the slave mode, the seven most significant bits must be loaded with the chip's own address. The I2C hardware will react if either of the address is matched.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>7</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>I2CDAT</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>I2CDAT</displayName>
          <description>I2C Data Register</description>
          <addressOffset>0x8</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>I2CDAT</name>
              <description>I2C Data Register\nThis field is located with the 8-bit transferred data of I2C serial port.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>I2CSTATUS</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>I2CSTATUS</displayName>
          <description>I2C Status Register</description>
          <addressOffset>0xC</addressOffset>
          <access>read-only</access>
          <resetValue>0x000000F8</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>I2CSTATUS</name>
              <description>I2C Status Register\nThere are 26 possible status codes. \nWhen I2CSTATUS contains 0xF8, no serial interrupt is requested. \n In addition, states 0x00 stands for a Bus Error. A Bus Error occurs when a START or STOP condition is present at an illegal position in the formation frame. Example of illegal position are during the serial transfer of an address byte, a data byte or an acknowledge bit.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>I2CLK</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>I2CLK</displayName>
          <description>I2C Clock Divided Register</description>
          <addressOffset>0x10</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>I2CLK</name>
              <description>I2C Clock Divided Register\nNote: The minimum value of I2CLK is 4.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>I2CTOC</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>I2CTOC</displayName>
          <description>I2C Time-out Counter Register</description>
          <addressOffset>0x14</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TIF</name>
              <description>Time-Out Flag\nThis bit is set by hardware when I2C time-out happened and it can interrupt CPU if I2C interrupt enable bit EI(I2CON[7]) is set to 1.\nNote: Write 1 to clear this bit.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DIV4</name>
              <description>Time-Out Counter Input Clock Divided By 4\nWhen Enabled, The time-out period is extend 4 times.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ENTI</name>
              <description>Time-Out Counter Enable Bit \nWhen Enabled, the 14-bit time-out counter will start counting when SI(I2CON[3]) is clear. Setting flag SI SI(I2CON[3]) to high will reset counter and re-start up counting after SI SI(I2CON[3]) is cleared.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="I2CADDR0">
          <name>I2CADDR1</name>
          <displayName>I2CADDR1</displayName>
          <description>I2C Slave Address Register1</description>
          <addressOffset>0x18</addressOffset>
       </register>
       <register derivedFrom="I2CADDR0">
          <name>I2CADDR2</name>
          <displayName>I2CADDR2</displayName>
          <description>I2C Slave Address Register2</description>
          <addressOffset>0x1C</addressOffset>
       </register>
       <register derivedFrom="I2CADDR0">
          <name>I2CADDR3</name>
          <displayName>I2CADDR3</displayName>
          <description>I2C Slave Address Register3</description>
          <addressOffset>0x20</addressOffset>
       </register>
       <register>
          <name>I2CADM0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>I2CADM0</displayName>
          <description>I2C Slave Address Mask Register0</description>
          <addressOffset>0x24</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>I2CADM</name>
              <description>I2C Address Mask Register\nI2C bus controllers support multiple address recognition with four address mask register. When the bit in the address mask register is set to one, it means the received corresponding address bit is don't-care. If the bit is set to zero, that means the received corresponding register bit should be exact the same as address register.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>7</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Mask Disabled (the received corresponding register bit should be exact the same as address register.)</description>
                    <value>0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Mask Enabled (the received corresponding address bit is don't care.)</description>
                    <value>1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="I2CADM0">
          <name>I2CADM1</name>
          <displayName>I2CADM1</displayName>
          <description>I2C Slave Address Mask Register1</description>
          <addressOffset>0x28</addressOffset>
       </register>
       <register derivedFrom="I2CADM0">
          <name>I2CADM2</name>
          <displayName>I2CADM2</displayName>
          <description>I2C Slave Address Mask Register2</description>
          <addressOffset>0x2C</addressOffset>
       </register>
       <register derivedFrom="I2CADM0">
          <name>I2CADM3</name>
          <displayName>I2CADM3</displayName>
          <description>I2C Slave Address Mask Register3</description>
          <addressOffset>0x30</addressOffset>
       </register>
       <register>
          <name>I2CWKUPCON</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>I2CWKUPCON</displayName>
          <description>I2C Wake-up Control Register</description>
          <addressOffset>0x3C</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WKUPEN</name>
              <description>I2C Wake-Up Enable Bit\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>I2C wake-up function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>I2C wake-up function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>I2CWKUPSTS</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>I2CWKUPSTS</displayName>
          <description>I2C Wake-up Status Register</description>
          <addressOffset>0x40</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WKUPIF</name>
              <description>I2C Wake-Up Flag\nNote: Software can write 1 to clear this bit.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Chip is not woken-up from Power-down mode by I2C</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Chip is woken-up from Power-down mode by I2C</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>I2C1</name>
      <description>I2C Register Map</description>
      <groupName>I2C</groupName>
      <baseAddress>0x40012000</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x0</offset>
        <size>0x34</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x3C</offset>
        <size>0x8</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>I2CON</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>I2CON</displayName>
          <description>I2C Control Register</description>
          <addressOffset>0x0</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>AA</name>
              <description>Assert Acknowledge Control\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SI</name>
              <description>I2C Interrupt Flag\nWhen a new I2C state is present in the I2CSTATUS register, the SI flag is set by hardware, and if bit EI (I2CON [7]) is set, the I2C interrupt is requested. SI must be cleared by software. Clear SI by writing 1 to this bit.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>STO</name>
              <description>I2C STOP Control\nIn Master mode, setting STO to transmit a STOP condition to bus then I2C hardware will check the bus condition if a STOP condition is detected this bit will be cleared by hardware automatically. In a slave mode, setting STO resets I2C hardware to the defined "not addressed" slave mode. This means it is NO LONGER in the slave receiver mode to receive data from the master transmit device.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>STA</name>
              <description>I2C START Control\nSetting STA to logic 1 to enter Master mode, the I2C hardware sends a START or repeat START condition to bus when the bus is free.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ENS1</name>
              <description>I2C Controller Enable Bit\n</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>EI</name>
              <description>Interrupt Enable Bit\n</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>I2C interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>I2C interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>I2CADDR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>I2CADDR0</displayName>
          <description>I2C Slave Address Register0</description>
          <addressOffset>0x4</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>GC</name>
              <description>General Call Function\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>General Call Function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>General Call Function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>I2CADDR</name>
              <description>I2C Address Register\nThe content of this register is irrelevant when I2C is in Master mode. In the slave mode, the seven most significant bits must be loaded with the chip's own address. The I2C hardware will react if either of the address is matched.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>7</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>I2CDAT</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>I2CDAT</displayName>
          <description>I2C Data Register</description>
          <addressOffset>0x8</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>I2CDAT</name>
              <description>I2C Data Register\nThis field is located with the 8-bit transferred data of I2C serial port.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>I2CSTATUS</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>I2CSTATUS</displayName>
          <description>I2C Status Register</description>
          <addressOffset>0xC</addressOffset>
          <access>read-only</access>
          <resetValue>0x000000F8</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>I2CSTATUS</name>
              <description>I2C Status Register\nThere are 26 possible status codes. \nWhen I2CSTATUS contains 0xF8, no serial interrupt is requested. \n In addition, states 0x00 stands for a Bus Error. A Bus Error occurs when a START or STOP condition is present at an illegal position in the formation frame. Example of illegal position are during the serial transfer of an address byte, a data byte or an acknowledge bit.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>I2CLK</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>I2CLK</displayName>
          <description>I2C Clock Divided Register</description>
          <addressOffset>0x10</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>I2CLK</name>
              <description>I2C Clock Divided Register\nNote: The minimum value of I2CLK is 4.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>I2CTOC</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>I2CTOC</displayName>
          <description>I2C Time-out Counter Register</description>
          <addressOffset>0x14</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TIF</name>
              <description>Time-Out Flag\nThis bit is set by hardware when I2C time-out happened and it can interrupt CPU if I2C interrupt enable bit EI(I2CON[7]) is set to 1.\nNote: Write 1 to clear this bit.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DIV4</name>
              <description>Time-Out Counter Input Clock Divided By 4\nWhen Enabled, The time-out period is extend 4 times.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ENTI</name>
              <description>Time-Out Counter Enable Bit \nWhen Enabled, the 14-bit time-out counter will start counting when SI(I2CON[3]) is clear. Setting flag SI SI(I2CON[3]) to high will reset counter and re-start up counting after SI SI(I2CON[3]) is cleared.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="I2CADDR0">
          <name>I2CADDR1</name>
          <displayName>I2CADDR1</displayName>
          <description>I2C Slave Address Register1</description>
          <addressOffset>0x18</addressOffset>
       </register>
       <register derivedFrom="I2CADDR0">
          <name>I2CADDR2</name>
          <displayName>I2CADDR2</displayName>
          <description>I2C Slave Address Register2</description>
          <addressOffset>0x1C</addressOffset>
       </register>
       <register derivedFrom="I2CADDR0">
          <name>I2CADDR3</name>
          <displayName>I2CADDR3</displayName>
          <description>I2C Slave Address Register3</description>
          <addressOffset>0x20</addressOffset>
       </register>
       <register>
          <name>I2CADM0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>I2CADM0</displayName>
          <description>I2C Slave Address Mask Register0</description>
          <addressOffset>0x24</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>I2CADM</name>
              <description>I2C Address Mask Register\nI2C bus controllers support multiple address recognition with four address mask register. When the bit in the address mask register is set to one, it means the received corresponding address bit is don't-care. If the bit is set to zero, that means the received corresponding register bit should be exact the same as address register.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>7</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Mask Disabled (the received corresponding register bit should be exact the same as address register.)</description>
                    <value>0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Mask Enabled (the received corresponding address bit is don't care.)</description>
                    <value>1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="I2CADM0">
          <name>I2CADM1</name>
          <displayName>I2CADM1</displayName>
          <description>I2C Slave Address Mask Register1</description>
          <addressOffset>0x28</addressOffset>
       </register>
       <register derivedFrom="I2CADM0">
          <name>I2CADM2</name>
          <displayName>I2CADM2</displayName>
          <description>I2C Slave Address Mask Register2</description>
          <addressOffset>0x2C</addressOffset>
       </register>
       <register derivedFrom="I2CADM0">
          <name>I2CADM3</name>
          <displayName>I2CADM3</displayName>
          <description>I2C Slave Address Mask Register3</description>
          <addressOffset>0x30</addressOffset>
       </register>
       <register>
          <name>I2CWKUPCON</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>I2CWKUPCON</displayName>
          <description>I2C Wake-up Control Register</description>
          <addressOffset>0x3C</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WKUPEN</name>
              <description>I2C Wake-Up Enable Bit\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>I2C wake-up function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>I2C wake-up function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>I2CWKUPSTS</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>I2CWKUPSTS</displayName>
          <description>I2C Wake-up Status Register</description>
          <addressOffset>0x40</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WKUPIF</name>
              <description>I2C Wake-Up Flag\nNote: Software can write 1 to clear this bit.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Chip is not woken-up from Power-down mode by I2C</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Chip is woken-up from Power-down mode by I2C</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>SPI0</name>
      <description>SPI Register Map</description>
      <groupName>SPI</groupName>
      <baseAddress>0x40030000</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x0</offset>
        <size>0xC</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x10</offset>
        <size>0x8</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x20</offset>
        <size>0x8</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x34</offset>
        <size>0x14</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>SPI_CNTRL</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SPI_CNTRL</displayName>
          <description>Control and Status Register</description>
          <addressOffset>0x0</addressOffset>
          <access>read-write</access>
          <resetValue>0x05003004</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>GO_BUSY</name>
              <description>SPI Transfer Control Bit And Busy Status\nIf FIFO mode is disabled, during the data transfer, this bit keeps the value of 1. As the transfer is finished, this bit will be cleared automatically. Software can read this bit to check if the SPI is in busy status.\nIn FIFO mode, this bit will be controlled by hardware. Software should not modify this bit. In Slave mode, this bit always returns 1 when this register is read by software. In Master mode, this bit reflects the busy or idle status of SPI.\nNote:\nWhen FIFO mode is disabled, all configurations should be set before writing 1 to this GO_BUSY bit.\nWhen FIFO mode is disabled and the software uses TX or RX PDMA function to transfer data, this bit will be cleared after the PDMA finishes the data transfer.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Data transfer stopped</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>In Master mode, writing 1 to this bit to start the SPI data transfer; in Slave mode, writing 1 to this bit indicates that the slave is ready to communicate with a master</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_NEG</name>
              <description>Receive On Negative Edge\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Received data input signal is latched on the rising edge of SPI bus clock</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Received data input signal is latched on the falling edge of SPI bus clock</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_NEG</name>
              <description>Transmit On Negative Edge\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Transmitted data output signal is changed on the rising edge of SPI bus clock</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Transmitted data output signal is changed on the falling edge of SPI bus clock</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_BIT_LEN</name>
              <description>Transmit Bit Length\nThis field specifies how many bits can be transmitted / received in one transaction. The minimum bit length is 8 bits and can up to 32 bits.\n</description>
              <bitOffset>3</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>LSB</name>
              <description>Send LSB First\n</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The MSB, which bit of transmit/receive register depends on the setting of TX_BIT_LEN, is transmitted/received first</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The LSB, bit 0 of the SPI TX0/1 register, is sent first to the SPI data output pin, and the first bit received from the SPI data input pin will be put in the LSB position of the RX register (bit 0 of SPI_RX0/1)</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CLKP</name>
              <description>Clock Polarity\n</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>SPI bus clock is idle low</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>SPI bus clock is idle high</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SP_CYCLE</name>
              <description>Suspend Interval (Master Only)\nThe four bits provide configurable suspend interval between two successive transmit/receive transaction in a transfer. The definition of the suspend interval is the interval between the last clock edge of the preceding transaction word and the first clock edge of the following transaction word. The default value is 0x3. The period of the suspend interval is obtained according to the following equation.\n (SP_CYCLE[3:0] + 0.5) * period of SPI bus clock cycle\nExample:\nIf the variable clock function is enabled and the transmit FIFO buffer is not empty, the minimum period of suspend interval between the successive transactions is (6.5 + SP_CYCLE) * SPI bus clock cycle.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>IF</name>
              <description>Unit Transfer Interrupt Flag\nNote: This bit will be cleared by writing 1 to itself.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No transaction has been finished since this bit was cleared to 0</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>SPI controller has finished one unit transfer</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IE</name>
              <description>Unit Transfer Interrupt EnableBit\n</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>SPI unit transfer interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>SPI unit transfer interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SLAVE</name>
              <description>Slave Mode EnableBit\n</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Master mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Slave mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>REORDER</name>
              <description>Byte Reorder Function EnableBit\nNote:\nByte Reorder function is only available if TX_BIT_LEN is defined as 16, 24, and 32 bits.\nIn Slave mode with level-trigger configuration, the slave select pin must be kept at active state during the byte suspend interval.\nThe Byte Reorder function is not supported when the variable bus clock function or Dual I/O mode is enabled.</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Byte Reorder function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Byte Reorder function Enabled. A byte suspend interval will be inserted among each byte. The period of the byte suspend interval depends on the setting of SP_CYCLE</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>FIFO</name>
              <description>FIFO Mode EnableBit\nNote:\nBefore enabling FIFO mode, the other related settings should be set in advance.\nIn Master mode, if the FIFO mode is enabled, the GO_BUSY bit will be set to 1 automatically after writing data to the transmit FIFO buffer; the GO_BUSY bit will be cleared to 0 automatically when the SPI controller is in idle. If all data stored at transmit FIFO buffer are sent out, the TX_EMPTY bit will be set to 1 and the GO_BUSY bit will be cleared to 0.\nAfter clearing this bit to 0, user must wait for at least 2 peripheral clock periods before setting this bit to 1 again.</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>FIFO mode Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>FIFO mode Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TWOB</name>
              <description>2-Bit Transfer Mode EnableBit\nNote: When 2-bit Transfer mode is enabled, the serial transmitted 2-bit data are from SPI_TX1/0, and the received 2-bit data input are put in SPI_RX1/0.</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>2-bit Transfer mode Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>2-bit Transfer mode Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>VARCLK_EN</name>
              <description>Variable Clock Enable Bit (Master Only)\nNote: When this VARCLK_EN bit is set to 1, the setting of TX_BIT_LEN must be programmed as 0x10 (16-bit mode).</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>SPI clock output frequency is fixed and decided only by the value of DIVIDER</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>SPI clock output frequency is variable. The output frequency is decided by the value of VARCLK, DIVIDER, and DIVIDER2</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_EMPTY</name>
              <description>Receive FIFO Buffer Empty Indicator (Read Only)\nIt is a mutual mirror bit of SPI_CNTRL[24].\n</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Receive FIFO buffer is not empty</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Receive FIFO buffer is empty</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>RX_FULL</name>
              <description>Receive FIFO Buffer Full Indicator (Read Only)\nIt is a mutual mirror bit of SPI_STATUS[25].\n</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Receive FIFO buffer is not full</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Receive FIFO buffer is full</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>TX_EMPTY</name>
              <description>Transmit FIFO Buffer Empty Indicator (Read Only)\nIt is a mutual mirror bit of SPI_STATUS[26].\n</description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Transmit FIFO buffer is not empty</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Transmit FIFO buffer is empty</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>TX_FULL</name>
              <description>Transmit FIFO Buffer Full Indicator (Read Only)\nIt is a mutual mirror bit of SPI_STATUS[27].\n</description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Transmit FIFO buffer is not full</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Transmit FIFO buffer is full</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SPI_DIVIDER</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SPI_DIVIDER</displayName>
          <description>Clock Divider Register</description>
          <addressOffset>0x4</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DIVIDER</name>
              <description>Clock Divider 1 Register \nThe value in this field is the frequency divider for generating the SPI peripheral clock, fspi_eclk, and the SPI bus clock of SPI master. The frequency is obtained according to the following equation. \nIf the bit of BCn, SPI_CNTRL2[31], is set to 0,\n\nelse if BCn is set to 1,\n\nwhere \n is the SPI peripheral clock source, which is defined in the CLKSEL1 register.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DIVIDER2</name>
              <description>Clock Divider 2 Register (Master Only)\nThe value in this field is the 2nd frequency divider for generating the second clock of the variable clock function. The frequency is obtained according to the following equation: \n\nIf the VARCLK_EN bit is cleared to 0, this setting is unmeaning.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SPI_SSR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SPI_SSR</displayName>
          <description>Slave Select Register</description>
          <addressOffset>0x8</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SSR</name>
              <description>Slave Select Control Bits (Master Only)\nIf AUTOSS bit is cleared, writing 1 to any bit of this field sets the proper SPIn_SPISS0/1 line to an active state and writing 0 sets the line back to inactive state.\nIf the AUTOSS bit is set, writing 0 to any bit location of this field will keep the corresponding SPIn_SPISS0/1 line at inactive state; writing 1 to any bit location of this field will select appropriate SPIn_SPISS0/1 line to be automatically driven to active state for the duration of the transmit/receive, and will be driven to inactive state for the rest of the time. The active state of SPIn_SPISS0/1 is specified in SS_LVL. \nNote: SPIn_SPISS0 is defined as the slave select input in Slave mode.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SS_LVL</name>
              <description>Slave Select Active Level\nThis bit defines the active status of slave select signal (SPIn_SPISS0/1).\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The slave select signal SPIn_SPISS0/1 is active on low-level/falling-edge</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The slave select signal SPIn_SPISS0/1 is active on high-level/rising-edge</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>AUTOSS</name>
              <description>Automatic Slave Select Function Enable Bit (Master Only)\n</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>If this bit is cleared, slave select signals will be asserted/de-asserted by setting /clearing the corresponding bits of SPI_SSR[1:0]</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>If this bit is set, SPIn_SPISS0/1 signals will be generated automatically. It means that device/slave select signal, which is set in SPI_SSR[1:0], will be asserted by the SPI controller when transmit/receive is started, and will be de-asserted after each transmit/receive is finished</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SS_LTRIG</name>
              <description>Slave Select Level Trigger Enable Bit (Slave Only)\n</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Slave select signal is edge-trigger. This is the default value. The SS_LVL bit decides the signal is active after a falling-edge or rising-edge</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Slave select signal is level-trigger. The SS_LVL bit decides the signal is active low or active high</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>LTRIG_FLAG</name>
              <description>Level Trigger Accomplish Flag\nIn Slave mode, this bit indicates whether the received bit number meets the requirement or not after the current transaction done. \nNote: This bit is READ only. As the GO_BUSY bit is set to 1 by software, the LTRIG_FLAG will be cleared to 0 after 4 SPI peripheral clock periods plus 1 system clock period. In FIFO mode, this bit has no meaning.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Transferred bit length of one transaction does not meet the specified requirement</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Transferred bit length meets the specified requirement which defined in TX_BIT_LEN</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SPI_RX0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SPI_RX0</displayName>
          <description>Data Receive Register 0</description>
          <addressOffset>0x10</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RX</name>
              <description>Data Receive Register\nThe data receive register holds the datum received from SPI data input pin. If FIFO mode is disabled, the last received data can be accessed through software by reading this register. If the FIFO bit is set as 1 and the RX_EMPTY bit, SPI_CNTRL[24] or SPI_STATUS[24], is not set to 1, the receive FIFO buffer can be accessed through software by reading this register. This is a read-only register.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="SPI_RX0">
          <name>SPI_RX1</name>
          <displayName>SPI_RX1</displayName>
          <description>Data Receive Register 1</description>
          <addressOffset>0x14</addressOffset>
       </register>
       <register>
          <name>SPI_TX0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SPI_TX0</displayName>
          <description>Data Transmit Register 0</description>
          <addressOffset>0x20</addressOffset>
          <access>write-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TX</name>
              <description>Data Transmit Register\nThe data transmit registers hold the data to be transmitted in the next transfer. The number of valid bits depends on the setting of transmit bit length field of the SPI_CNTRL register.\nFor example, if TX_BIT_LEN is set to 0x08, the bits TX[7:0] will be transmitted in next transfer. If TX_BIT_LEN is set to 0x00, the SPI controller will perform a 32-bit transfer.\nNote 1: When the SPI controller is configured as a slave device and FIFO mode is disabled, if the SPI controller attempts to transmit data to a master, the transmit data register should be updated by software before setting the GO_BUSY bit to 1.\nNote 2: In Master mode, SPI controller will start to transfer after 5 peripheral clock cycles since user wrote to this register.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="SPI_TX0">
          <name>SPI_TX1</name>
          <displayName>SPI_TX1</displayName>
          <description>Data Transmit Register 1</description>
          <addressOffset>0x24</addressOffset>
       </register>
       <register>
          <name>SPI_VARCLK</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SPI_VARCLK</displayName>
          <description>Variable Clock Pattern Register</description>
          <addressOffset>0x34</addressOffset>
          <access>read-write</access>
          <resetValue>0x007FFF87</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>VARCLK</name>
              <description>Variable Clock Pattern\nThis register defines the clock pattern of the SPI transfer. If the variable clock function is disabled, this setting is unmeaning. Refer to the "Variable Clock Function" paragraph for more detail description.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SPI_DMA</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SPI_DMA</displayName>
          <description>SPI DMA Control Register</description>
          <addressOffset>0x38</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TX_DMA_GO</name>
              <description>Transmit DMA Start\nSetting this bit to 1 will start the transmit PDMA process. SPI controller will issue request to PDMA controller automatically. Hardware will clear this bit to 0 automatically after PDMA transfer done.\nIf the SPI transmit PDMA function is used to transfer data, the GO_BUSY bit should not be set to 1 by software. The PDMA control logic of SPI controller will set it automatically whenever necessary.\nIn Slave mode and when FIFO mode is disabled, the minimal suspend interval between two successive transactions must be larger than (8 SPI clock periods + 14 APB clock periods) for edge-trigger mode or (9.5 SPI clock periods + 14 APB clock periods) for level-trigger mode. If the 2-bit Transfer mode is enabled, additional 18 APB clock periods for the above conditions is required.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_DMA_GO</name>
              <description>Receive DMA Start\nSetting this bit to 1 will start the receive PDMA process. The SPI controller will issue request to PDMA controller automatically when the SPI receive buffer is not empty. This bit will be cleared to 0 by hardware automatically after PDMA transfer is done.\nIf the software uses the receive PDMA function to access the received data of SPI and does not use the transmit PDMA function, the GO_BUSY bit should be set by software.\nEnabling FIFO mode is recommended if the software uses more than one PDMA channel to transfer data.\nIn Slave mode and when FIFO mode is disabled, if the software only uses one PDMA channel for SPI receive PDMA function and the other PDMA channels are not in use, the minimal suspend interval between two successive transactions must be larger than (9 SPI slave peripheral clock periods + 4 APB clock periods) for Edge-trigger mode or (9.5 SPI slave peripheral clock periods + 4 APB clock periods) for Level-trigger mode.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PDMA_RST</name>
              <description>PDMA Reset\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reset the PDMA control logic of the SPI controller. This bit will be cleared to 0 automatically</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SPI_CNTRL2</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SPI_CNTRL2</displayName>
          <description>Control and Status Register 2</description>
          <addressOffset>0x3C</addressOffset>
          <access>read-write</access>
          <resetValue>0x00001000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>NOSLVSEL</name>
              <description>Slave 3-Wire Mode Enable Bit\nThis is used to ignore the slave select signal in Slave mode. The SPI controller can work with 3-wire interface including SPIn_CLK, SPIn_MISO, and SPIn_MOSI.\nNote: In Slave 3-wire mode, the SS_LTRIG, SPI_SSR[4] will be set as 1 automatically.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>4-wire bi-direction interface</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>3-wire bi-direction interface</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SLV_ABORT</name>
              <description>Slave 3-Wire Mode Abort Control\nIn normal operation, there is an interrupt event when the received data meet the required bits which defined in TX_BIT_LEN.\nIf the received bits are less than the requirement and there is no more SPI clock input over the one transfer time in Slave 3-wire mode, the user can set this bit to force the current transfer done and then the user can get a transfer done interrupt event. \nNote: This bit will be cleared to 0 automatically by hardware after it is set to 1 by software.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SSTA_INTEN</name>
              <description>Slave 3-Wire Mode Start Interrupt EnableBit\nUsed to enable interrupt when the transfer has started in Slave 3-wire mode. If there is no transfer done interrupt over the time period which is defined by user after the transfer start, the user can set the SLV_ABORT bit to force the transfer done.\n</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Transaction start interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Transaction start interrupt Enabled. It will be cleared to 0 as the current transfer is done or the SLV_START_INTSTS bit is cleared</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SLV_START_INTSTS</name>
              <description>Slave 3-Wire Mode Start Interrupt Status\nThis bit indicates if a transaction has started in Slave 3-wire mode. It is a mutual mirror bit of SPI_STATUS[11].\n</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Slave has not detected any SPI clock transition since the SSTA_INTEN bit was set to 1</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>A transaction has started in Slave 3-wire mode. It will be cleared automatically when a transaction is done or by writing 1 to this bit</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DUAL_IO_DIR</name>
              <description>Dual I/O Mode Direction Control\n</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Dual Input mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Dual Output mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DUAL_IO_EN</name>
              <description>Dual I/O Mode EnableBit\n</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Dual I/O mode Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Dual I/O mode Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SS_INT_OPT</name>
              <description>Slave Select Inactive Interrupt Option \nThis setting is only available if the SPI controller is configured as level trigger slave device.\n</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>As the slave select signal goes to inactive level, the IF bit will NOT be set to 1</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>As the slave select signal goes to inactive level, the IF bit will be set to 1</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BCn</name>
              <description>SPI Peripheral Clock Backward Compatible Option\nRefer to the description of SPI_DIVIDER register for details.</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Backward compatible clock configuration</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Clock configuration is not backward compatible</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SPI_FIFO_CTL</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SPI_FIFO_CTL</displayName>
          <description>SPI FIFO Control Register</description>
          <addressOffset>0x40</addressOffset>
          <access>read-write</access>
          <resetValue>0x44000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RX_CLR</name>
              <description>Clear Receive FIFO Buffer\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Clear receive FIFO buffer. The RX_FULL flag will be cleared to 0 and the RX_EMPTY flag will be set to 1. This bit will be cleared to 0 by hardware after it is set to 1 by software</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_CLR</name>
              <description>Clear Transmit FIFO Buffer\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Clear transmit FIFO buffer. The TX_FULL flag will be cleared to 0 and the TX_EMPTY flag will be set to 1. This bit will be cleared to 0 by hardware after it is set to 1 by software</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_INTEN</name>
              <description>Receive Threshold Interrupt Enable Bit\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RX threshold interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RX threshold interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_INTEN</name>
              <description>Transmit Threshold Interrupt Enable Bit\n</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>TX threshold interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>TX threshold interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RXOV_INTEN</name>
              <description>Receive FIFO Overrun Interrupt Enable Bit\n</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Receive FIFO overrun interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Receive FIFO overrun interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TIMEOUT_INTEN</name>
              <description>Receive FIFO Time-Out Interrupt Enable Bit\n</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Time-out interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Time-out interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_THRESHOLD</name>
              <description>Receive FIFO Threshold\nIf the valid data count of the receive FIFO buffer is larger than the RX_THRESHOLD setting, the RX_INTSTS bit will be set to 1, else the RX_INTSTS bit will be cleared to 0.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_THRESHOLD</name>
              <description>Transmit FIFO Threshold\nIf the valid data count of the transmit FIFO buffer is less than or equal to the TX_THRESHOLD setting, the TX_INTSTS bit will be set to 1, else the TX_INTSTS bit will be cleared to 0.</description>
              <bitOffset>28</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SPI_STATUS</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SPI_STATUS</displayName>
          <description>SPI Status Register</description>
          <addressOffset>0x44</addressOffset>
          <access>read-write</access>
          <resetValue>0x05000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RX_INTSTS</name>
              <description>Receive FIFO Threshold Interrupt Status (Read Only)\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The valid data count within the Rx FIFO buffer is smaller than or equal to the setting value of RX_THRESHOLD</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The valid data count within the receive FIFO buffer is larger than the setting value of RX_THRESHOLD</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>RX_OVERRUN</name>
              <description>Receive FIFO Overrun Status\nWhen the receive FIFO buffer is full, the follow-up data will be dropped and this bit will be set to 1.\nNote: This bit will be cleared by writing 1 to itself.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_INTSTS</name>
              <description>Transmit FIFO Threshold Interrupt Status (Read Only)\n</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The valid data count within the transmit FIFO buffer is larger than the setting value of TX_THRESHOLD</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The valid data count within the transmit FIFO buffer is less than or equal to the setting value of TX_THRESHOLD</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>SLV_START_INTSTS</name>
              <description>Slave Start Interrupt Status\nIt is used to dedicate if a transaction has started in Slave 3-wire mode. It is a mutual mirror bit of SPI_CNTRL2[11].\n</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Slave has not detected any SPI clock transition since the SSTA_INTEN bit was set to 1</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>A transaction has started in Slave 3-wire mode. It will be cleared as a transaction is done or by writing 1 to this bit</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_FIFO_COUNT</name>
              <description>Receive FIFO Data Count (Read Only)\nThis bit field indicates the valid data count of receive FIFO buffer.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>IF</name>
              <description>SPI Unit Transfer Interrupt Flag\nIt is a mutual mirror bit of SPI_CNTRL[16].\nNote: This bit will be cleared by writing 1 to itself.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No transaction has been finished since this bit was cleared to 0</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>SPI controller has finished one unit transfer</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TIMEOUT</name>
              <description>Time-Out Interrupt Flag\nNote: This bit will be cleared by writing 1 to itself.</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No receive FIFO time-out event</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Receive FIFO buffer is not empty and no read operation on receive FIFO buffer over 64 SPI clock period in Master mode or over 576 SPI peripheral clock period in Slave mode. When the received FIFO buffer is read by software, the time-out status will be cleared automatically</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_EMPTY</name>
              <description>Receive FIFO Buffer Empty Indicator (Read Only)\nIt is a mutual mirror bit of SPI_CNTRL[24].\n</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Receive FIFO buffer is not empty</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Receive FIFO buffer is empty</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>RX_FULL</name>
              <description>Receive FIFO Buffer Empty Indicator (Read Only)\nIt is a mutual mirror bit of SPI_CNTRL[24].\n</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Receive FIFO buffer is not empty</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Receive FIFO buffer is empty</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>TX_EMPTY</name>
              <description>Transmit FIFO Buffer Empty Indicator (Read Only)\nIt is a mutual mirror bit of SPI_CNTRL[26].\n</description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Transmit FIFO buffer is not empty</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Transmit FIFO buffer is empty</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>TX_FULL</name>
              <description>Transmit FIFO Buffer Full Indicator (Read Only)\nIt is a mutual mirror bit of SPI_CNTRL[27].\n</description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Transmit FIFO buffer is not full</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Transmit FIFO buffer is full</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>TX_FIFO_COUNT</name>
              <description>Transmit FIFO Data Count (Read Only)\nThis bit field indicates the valid data count of transmit FIFO buffer.</description>
              <bitOffset>28</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>SPI1</name>
      <description>SPI Register Map</description>
      <groupName>SPI</groupName>
      <baseAddress>0x40034000</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x0</offset>
        <size>0xC</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x10</offset>
        <size>0x8</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x20</offset>
        <size>0x8</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x34</offset>
        <size>0x14</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>SPI_CNTRL</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SPI_CNTRL</displayName>
          <description>Control and Status Register</description>
          <addressOffset>0x0</addressOffset>
          <access>read-write</access>
          <resetValue>0x05003004</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>GO_BUSY</name>
              <description>SPI Transfer Control Bit And Busy Status\nIf FIFO mode is disabled, during the data transfer, this bit keeps the value of 1. As the transfer is finished, this bit will be cleared automatically. Software can read this bit to check if the SPI is in busy status.\nIn FIFO mode, this bit will be controlled by hardware. Software should not modify this bit. In Slave mode, this bit always returns 1 when this register is read by software. In Master mode, this bit reflects the busy or idle status of SPI.\nNote:\nWhen FIFO mode is disabled, all configurations should be set before writing 1 to this GO_BUSY bit.\nWhen FIFO mode is disabled and the software uses TX or RX PDMA function to transfer data, this bit will be cleared after the PDMA finishes the data transfer.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Data transfer stopped</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>In Master mode, writing 1 to this bit to start the SPI data transfer; in Slave mode, writing 1 to this bit indicates that the slave is ready to communicate with a master</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_NEG</name>
              <description>Receive On Negative Edge\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Received data input signal is latched on the rising edge of SPI bus clock</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Received data input signal is latched on the falling edge of SPI bus clock</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_NEG</name>
              <description>Transmit On Negative Edge\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Transmitted data output signal is changed on the rising edge of SPI bus clock</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Transmitted data output signal is changed on the falling edge of SPI bus clock</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_BIT_LEN</name>
              <description>Transmit Bit Length\nThis field specifies how many bits can be transmitted / received in one transaction. The minimum bit length is 8 bits and can up to 32 bits.\n</description>
              <bitOffset>3</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>LSB</name>
              <description>Send LSB First\n</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The MSB, which bit of transmit/receive register depends on the setting of TX_BIT_LEN, is transmitted/received first</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The LSB, bit 0 of the SPI TX0/1 register, is sent first to the SPI data output pin, and the first bit received from the SPI data input pin will be put in the LSB position of the RX register (bit 0 of SPI_RX0/1)</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CLKP</name>
              <description>Clock Polarity\n</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>SPI bus clock is idle low</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>SPI bus clock is idle high</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SP_CYCLE</name>
              <description>Suspend Interval (Master Only)\nThe four bits provide configurable suspend interval between two successive transmit/receive transaction in a transfer. The definition of the suspend interval is the interval between the last clock edge of the preceding transaction word and the first clock edge of the following transaction word. The default value is 0x3. The period of the suspend interval is obtained according to the following equation.\n (SP_CYCLE[3:0] + 0.5) * period of SPI bus clock cycle\nExample:\nIf the variable clock function is enabled and the transmit FIFO buffer is not empty, the minimum period of suspend interval between the successive transactions is (6.5 + SP_CYCLE) * SPI bus clock cycle.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>IF</name>
              <description>Unit Transfer Interrupt Flag\nNote: This bit will be cleared by writing 1 to itself.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No transaction has been finished since this bit was cleared to 0</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>SPI controller has finished one unit transfer</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IE</name>
              <description>Unit Transfer Interrupt EnableBit\n</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>SPI unit transfer interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>SPI unit transfer interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SLAVE</name>
              <description>Slave Mode EnableBit\n</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Master mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Slave mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>REORDER</name>
              <description>Byte Reorder Function EnableBit\nNote:\nByte Reorder function is only available if TX_BIT_LEN is defined as 16, 24, and 32 bits.\nIn Slave mode with level-trigger configuration, the slave select pin must be kept at active state during the byte suspend interval.\nThe Byte Reorder function is not supported when the variable bus clock function or Dual I/O mode is enabled.</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Byte Reorder function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Byte Reorder function Enabled. A byte suspend interval will be inserted among each byte. The period of the byte suspend interval depends on the setting of SP_CYCLE</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>FIFO</name>
              <description>FIFO Mode EnableBit\nNote:\nBefore enabling FIFO mode, the other related settings should be set in advance.\nIn Master mode, if the FIFO mode is enabled, the GO_BUSY bit will be set to 1 automatically after writing data to the transmit FIFO buffer; the GO_BUSY bit will be cleared to 0 automatically when the SPI controller is in idle. If all data stored at transmit FIFO buffer are sent out, the TX_EMPTY bit will be set to 1 and the GO_BUSY bit will be cleared to 0.\nAfter clearing this bit to 0, user must wait for at least 2 peripheral clock periods before setting this bit to 1 again.</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>FIFO mode Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>FIFO mode Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TWOB</name>
              <description>2-Bit Transfer Mode EnableBit\nNote: When 2-bit Transfer mode is enabled, the serial transmitted 2-bit data are from SPI_TX1/0, and the received 2-bit data input are put in SPI_RX1/0.</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>2-bit Transfer mode Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>2-bit Transfer mode Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>VARCLK_EN</name>
              <description>Variable Clock Enable Bit (Master Only)\nNote: When this VARCLK_EN bit is set to 1, the setting of TX_BIT_LEN must be programmed as 0x10 (16-bit mode).</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>SPI clock output frequency is fixed and decided only by the value of DIVIDER</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>SPI clock output frequency is variable. The output frequency is decided by the value of VARCLK, DIVIDER, and DIVIDER2</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_EMPTY</name>
              <description>Receive FIFO Buffer Empty Indicator (Read Only)\nIt is a mutual mirror bit of SPI_CNTRL[24].\n</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Receive FIFO buffer is not empty</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Receive FIFO buffer is empty</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>RX_FULL</name>
              <description>Receive FIFO Buffer Full Indicator (Read Only)\nIt is a mutual mirror bit of SPI_STATUS[25].\n</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Receive FIFO buffer is not full</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Receive FIFO buffer is full</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>TX_EMPTY</name>
              <description>Transmit FIFO Buffer Empty Indicator (Read Only)\nIt is a mutual mirror bit of SPI_STATUS[26].\n</description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Transmit FIFO buffer is not empty</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Transmit FIFO buffer is empty</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>TX_FULL</name>
              <description>Transmit FIFO Buffer Full Indicator (Read Only)\nIt is a mutual mirror bit of SPI_STATUS[27].\n</description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Transmit FIFO buffer is not full</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Transmit FIFO buffer is full</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SPI_DIVIDER</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SPI_DIVIDER</displayName>
          <description>Clock Divider Register</description>
          <addressOffset>0x4</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DIVIDER</name>
              <description>Clock Divider 1 Register \nThe value in this field is the frequency divider for generating the SPI peripheral clock, fspi_eclk, and the SPI bus clock of SPI master. The frequency is obtained according to the following equation. \nIf the bit of BCn, SPI_CNTRL2[31], is set to 0,\n\nelse if BCn is set to 1,\n\nwhere \n is the SPI peripheral clock source, which is defined in the CLKSEL1 register.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DIVIDER2</name>
              <description>Clock Divider 2 Register (Master Only)\nThe value in this field is the 2nd frequency divider for generating the second clock of the variable clock function. The frequency is obtained according to the following equation: \n\nIf the VARCLK_EN bit is cleared to 0, this setting is unmeaning.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SPI_SSR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SPI_SSR</displayName>
          <description>Slave Select Register</description>
          <addressOffset>0x8</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SSR</name>
              <description>Slave Select Control Bits (Master Only)\nIf AUTOSS bit is cleared, writing 1 to any bit of this field sets the proper SPIn_SPISS0/1 line to an active state and writing 0 sets the line back to inactive state.\nIf the AUTOSS bit is set, writing 0 to any bit location of this field will keep the corresponding SPIn_SPISS0/1 line at inactive state; writing 1 to any bit location of this field will select appropriate SPIn_SPISS0/1 line to be automatically driven to active state for the duration of the transmit/receive, and will be driven to inactive state for the rest of the time. The active state of SPIn_SPISS0/1 is specified in SS_LVL. \nNote: SPIn_SPISS0 is defined as the slave select input in Slave mode.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SS_LVL</name>
              <description>Slave Select Active Level\nThis bit defines the active status of slave select signal (SPIn_SPISS0/1).\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The slave select signal SPIn_SPISS0/1 is active on low-level/falling-edge</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The slave select signal SPIn_SPISS0/1 is active on high-level/rising-edge</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>AUTOSS</name>
              <description>Automatic Slave Select Function Enable Bit (Master Only)\n</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>If this bit is cleared, slave select signals will be asserted/de-asserted by setting /clearing the corresponding bits of SPI_SSR[1:0]</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>If this bit is set, SPIn_SPISS0/1 signals will be generated automatically. It means that device/slave select signal, which is set in SPI_SSR[1:0], will be asserted by the SPI controller when transmit/receive is started, and will be de-asserted after each transmit/receive is finished</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SS_LTRIG</name>
              <description>Slave Select Level Trigger Enable Bit (Slave Only)\n</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Slave select signal is edge-trigger. This is the default value. The SS_LVL bit decides the signal is active after a falling-edge or rising-edge</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Slave select signal is level-trigger. The SS_LVL bit decides the signal is active low or active high</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>LTRIG_FLAG</name>
              <description>Level Trigger Accomplish Flag\nIn Slave mode, this bit indicates whether the received bit number meets the requirement or not after the current transaction done. \nNote: This bit is READ only. As the GO_BUSY bit is set to 1 by software, the LTRIG_FLAG will be cleared to 0 after 4 SPI peripheral clock periods plus 1 system clock period. In FIFO mode, this bit has no meaning.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Transferred bit length of one transaction does not meet the specified requirement</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Transferred bit length meets the specified requirement which defined in TX_BIT_LEN</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SPI_RX0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SPI_RX0</displayName>
          <description>Data Receive Register 0</description>
          <addressOffset>0x10</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RX</name>
              <description>Data Receive Register\nThe data receive register holds the datum received from SPI data input pin. If FIFO mode is disabled, the last received data can be accessed through software by reading this register. If the FIFO bit is set as 1 and the RX_EMPTY bit, SPI_CNTRL[24] or SPI_STATUS[24], is not set to 1, the receive FIFO buffer can be accessed through software by reading this register. This is a read-only register.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="SPI_RX0">
          <name>SPI_RX1</name>
          <displayName>SPI_RX1</displayName>
          <description>Data Receive Register 1</description>
          <addressOffset>0x14</addressOffset>
       </register>
       <register>
          <name>SPI_TX0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SPI_TX0</displayName>
          <description>Data Transmit Register 0</description>
          <addressOffset>0x20</addressOffset>
          <access>write-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TX</name>
              <description>Data Transmit Register\nThe data transmit registers hold the data to be transmitted in the next transfer. The number of valid bits depends on the setting of transmit bit length field of the SPI_CNTRL register.\nFor example, if TX_BIT_LEN is set to 0x08, the bits TX[7:0] will be transmitted in next transfer. If TX_BIT_LEN is set to 0x00, the SPI controller will perform a 32-bit transfer.\nNote 1: When the SPI controller is configured as a slave device and FIFO mode is disabled, if the SPI controller attempts to transmit data to a master, the transmit data register should be updated by software before setting the GO_BUSY bit to 1.\nNote 2: In Master mode, SPI controller will start to transfer after 5 peripheral clock cycles since user wrote to this register.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="SPI_TX0">
          <name>SPI_TX1</name>
          <displayName>SPI_TX1</displayName>
          <description>Data Transmit Register 1</description>
          <addressOffset>0x24</addressOffset>
       </register>
       <register>
          <name>SPI_VARCLK</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SPI_VARCLK</displayName>
          <description>Variable Clock Pattern Register</description>
          <addressOffset>0x34</addressOffset>
          <access>read-write</access>
          <resetValue>0x007FFF87</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>VARCLK</name>
              <description>Variable Clock Pattern\nThis register defines the clock pattern of the SPI transfer. If the variable clock function is disabled, this setting is unmeaning. Refer to the "Variable Clock Function" paragraph for more detail description.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SPI_DMA</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SPI_DMA</displayName>
          <description>SPI DMA Control Register</description>
          <addressOffset>0x38</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TX_DMA_GO</name>
              <description>Transmit DMA Start\nSetting this bit to 1 will start the transmit PDMA process. SPI controller will issue request to PDMA controller automatically. Hardware will clear this bit to 0 automatically after PDMA transfer done.\nIf the SPI transmit PDMA function is used to transfer data, the GO_BUSY bit should not be set to 1 by software. The PDMA control logic of SPI controller will set it automatically whenever necessary.\nIn Slave mode and when FIFO mode is disabled, the minimal suspend interval between two successive transactions must be larger than (8 SPI clock periods + 14 APB clock periods) for edge-trigger mode or (9.5 SPI clock periods + 14 APB clock periods) for level-trigger mode. If the 2-bit Transfer mode is enabled, additional 18 APB clock periods for the above conditions is required.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_DMA_GO</name>
              <description>Receive DMA Start\nSetting this bit to 1 will start the receive PDMA process. The SPI controller will issue request to PDMA controller automatically when the SPI receive buffer is not empty. This bit will be cleared to 0 by hardware automatically after PDMA transfer is done.\nIf the software uses the receive PDMA function to access the received data of SPI and does not use the transmit PDMA function, the GO_BUSY bit should be set by software.\nEnabling FIFO mode is recommended if the software uses more than one PDMA channel to transfer data.\nIn Slave mode and when FIFO mode is disabled, if the software only uses one PDMA channel for SPI receive PDMA function and the other PDMA channels are not in use, the minimal suspend interval between two successive transactions must be larger than (9 SPI slave peripheral clock periods + 4 APB clock periods) for Edge-trigger mode or (9.5 SPI slave peripheral clock periods + 4 APB clock periods) for Level-trigger mode.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PDMA_RST</name>
              <description>PDMA Reset\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reset the PDMA control logic of the SPI controller. This bit will be cleared to 0 automatically</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SPI_CNTRL2</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SPI_CNTRL2</displayName>
          <description>Control and Status Register 2</description>
          <addressOffset>0x3C</addressOffset>
          <access>read-write</access>
          <resetValue>0x00001000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>NOSLVSEL</name>
              <description>Slave 3-Wire Mode Enable Bit\nThis is used to ignore the slave select signal in Slave mode. The SPI controller can work with 3-wire interface including SPIn_CLK, SPIn_MISO, and SPIn_MOSI.\nNote: In Slave 3-wire mode, the SS_LTRIG, SPI_SSR[4] will be set as 1 automatically.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>4-wire bi-direction interface</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>3-wire bi-direction interface</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SLV_ABORT</name>
              <description>Slave 3-Wire Mode Abort Control\nIn normal operation, there is an interrupt event when the received data meet the required bits which defined in TX_BIT_LEN.\nIf the received bits are less than the requirement and there is no more SPI clock input over the one transfer time in Slave 3-wire mode, the user can set this bit to force the current transfer done and then the user can get a transfer done interrupt event. \nNote: This bit will be cleared to 0 automatically by hardware after it is set to 1 by software.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SSTA_INTEN</name>
              <description>Slave 3-Wire Mode Start Interrupt EnableBit\nUsed to enable interrupt when the transfer has started in Slave 3-wire mode. If there is no transfer done interrupt over the time period which is defined by user after the transfer start, the user can set the SLV_ABORT bit to force the transfer done.\n</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Transaction start interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Transaction start interrupt Enabled. It will be cleared to 0 as the current transfer is done or the SLV_START_INTSTS bit is cleared</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SLV_START_INTSTS</name>
              <description>Slave 3-Wire Mode Start Interrupt Status\nThis bit indicates if a transaction has started in Slave 3-wire mode. It is a mutual mirror bit of SPI_STATUS[11].\n</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Slave has not detected any SPI clock transition since the SSTA_INTEN bit was set to 1</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>A transaction has started in Slave 3-wire mode. It will be cleared automatically when a transaction is done or by writing 1 to this bit</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DUAL_IO_DIR</name>
              <description>Dual I/O Mode Direction Control\n</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Dual Input mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Dual Output mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DUAL_IO_EN</name>
              <description>Dual I/O Mode EnableBit\n</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Dual I/O mode Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Dual I/O mode Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SS_INT_OPT</name>
              <description>Slave Select Inactive Interrupt Option \nThis setting is only available if the SPI controller is configured as level trigger slave device.\n</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>As the slave select signal goes to inactive level, the IF bit will NOT be set to 1</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>As the slave select signal goes to inactive level, the IF bit will be set to 1</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BCn</name>
              <description>SPI Peripheral Clock Backward Compatible Option\nRefer to the description of SPI_DIVIDER register for details.</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Backward compatible clock configuration</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Clock configuration is not backward compatible</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SPI_FIFO_CTL</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SPI_FIFO_CTL</displayName>
          <description>SPI FIFO Control Register</description>
          <addressOffset>0x40</addressOffset>
          <access>read-write</access>
          <resetValue>0x44000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RX_CLR</name>
              <description>Clear Receive FIFO Buffer\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Clear receive FIFO buffer. The RX_FULL flag will be cleared to 0 and the RX_EMPTY flag will be set to 1. This bit will be cleared to 0 by hardware after it is set to 1 by software</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_CLR</name>
              <description>Clear Transmit FIFO Buffer\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Clear transmit FIFO buffer. The TX_FULL flag will be cleared to 0 and the TX_EMPTY flag will be set to 1. This bit will be cleared to 0 by hardware after it is set to 1 by software</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_INTEN</name>
              <description>Receive Threshold Interrupt Enable Bit\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RX threshold interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RX threshold interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_INTEN</name>
              <description>Transmit Threshold Interrupt Enable Bit\n</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>TX threshold interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>TX threshold interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RXOV_INTEN</name>
              <description>Receive FIFO Overrun Interrupt Enable Bit\n</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Receive FIFO overrun interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Receive FIFO overrun interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TIMEOUT_INTEN</name>
              <description>Receive FIFO Time-Out Interrupt Enable Bit\n</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Time-out interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Time-out interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_THRESHOLD</name>
              <description>Receive FIFO Threshold\nIf the valid data count of the receive FIFO buffer is larger than the RX_THRESHOLD setting, the RX_INTSTS bit will be set to 1, else the RX_INTSTS bit will be cleared to 0.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_THRESHOLD</name>
              <description>Transmit FIFO Threshold\nIf the valid data count of the transmit FIFO buffer is less than or equal to the TX_THRESHOLD setting, the TX_INTSTS bit will be set to 1, else the TX_INTSTS bit will be cleared to 0.</description>
              <bitOffset>28</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SPI_STATUS</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SPI_STATUS</displayName>
          <description>SPI Status Register</description>
          <addressOffset>0x44</addressOffset>
          <access>read-write</access>
          <resetValue>0x05000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RX_INTSTS</name>
              <description>Receive FIFO Threshold Interrupt Status (Read Only)\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The valid data count within the Rx FIFO buffer is smaller than or equal to the setting value of RX_THRESHOLD</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The valid data count within the receive FIFO buffer is larger than the setting value of RX_THRESHOLD</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>RX_OVERRUN</name>
              <description>Receive FIFO Overrun Status\nWhen the receive FIFO buffer is full, the follow-up data will be dropped and this bit will be set to 1.\nNote: This bit will be cleared by writing 1 to itself.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_INTSTS</name>
              <description>Transmit FIFO Threshold Interrupt Status (Read Only)\n</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The valid data count within the transmit FIFO buffer is larger than the setting value of TX_THRESHOLD</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The valid data count within the transmit FIFO buffer is less than or equal to the setting value of TX_THRESHOLD</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>SLV_START_INTSTS</name>
              <description>Slave Start Interrupt Status\nIt is used to dedicate if a transaction has started in Slave 3-wire mode. It is a mutual mirror bit of SPI_CNTRL2[11].\n</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Slave has not detected any SPI clock transition since the SSTA_INTEN bit was set to 1</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>A transaction has started in Slave 3-wire mode. It will be cleared as a transaction is done or by writing 1 to this bit</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_FIFO_COUNT</name>
              <description>Receive FIFO Data Count (Read Only)\nThis bit field indicates the valid data count of receive FIFO buffer.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>IF</name>
              <description>SPI Unit Transfer Interrupt Flag\nIt is a mutual mirror bit of SPI_CNTRL[16].\nNote: This bit will be cleared by writing 1 to itself.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No transaction has been finished since this bit was cleared to 0</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>SPI controller has finished one unit transfer</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TIMEOUT</name>
              <description>Time-Out Interrupt Flag\nNote: This bit will be cleared by writing 1 to itself.</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No receive FIFO time-out event</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Receive FIFO buffer is not empty and no read operation on receive FIFO buffer over 64 SPI clock period in Master mode or over 576 SPI peripheral clock period in Slave mode. When the received FIFO buffer is read by software, the time-out status will be cleared automatically</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_EMPTY</name>
              <description>Receive FIFO Buffer Empty Indicator (Read Only)\nIt is a mutual mirror bit of SPI_CNTRL[24].\n</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Receive FIFO buffer is not empty</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Receive FIFO buffer is empty</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>RX_FULL</name>
              <description>Receive FIFO Buffer Empty Indicator (Read Only)\nIt is a mutual mirror bit of SPI_CNTRL[24].\n</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Receive FIFO buffer is not empty</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Receive FIFO buffer is empty</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>TX_EMPTY</name>
              <description>Transmit FIFO Buffer Empty Indicator (Read Only)\nIt is a mutual mirror bit of SPI_CNTRL[26].\n</description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Transmit FIFO buffer is not empty</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Transmit FIFO buffer is empty</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>TX_FULL</name>
              <description>Transmit FIFO Buffer Full Indicator (Read Only)\nIt is a mutual mirror bit of SPI_CNTRL[27].\n</description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Transmit FIFO buffer is not full</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Transmit FIFO buffer is full</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>TX_FIFO_COUNT</name>
              <description>Transmit FIFO Data Count (Read Only)\nThis bit field indicates the valid data count of transmit FIFO buffer.</description>
              <bitOffset>28</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>SPI2</name>
      <description>SPI Register Map</description>
      <groupName>SPI</groupName>
      <baseAddress>0x40130000</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x0</offset>
        <size>0xC</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x10</offset>
        <size>0x8</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x20</offset>
        <size>0x8</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x34</offset>
        <size>0x14</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>SPI_CNTRL</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SPI_CNTRL</displayName>
          <description>Control and Status Register</description>
          <addressOffset>0x0</addressOffset>
          <access>read-write</access>
          <resetValue>0x05003004</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>GO_BUSY</name>
              <description>SPI Transfer Control Bit And Busy Status\nIf FIFO mode is disabled, during the data transfer, this bit keeps the value of 1. As the transfer is finished, this bit will be cleared automatically. Software can read this bit to check if the SPI is in busy status.\nIn FIFO mode, this bit will be controlled by hardware. Software should not modify this bit. In Slave mode, this bit always returns 1 when this register is read by software. In Master mode, this bit reflects the busy or idle status of SPI.\nNote:\nWhen FIFO mode is disabled, all configurations should be set before writing 1 to this GO_BUSY bit.\nWhen FIFO mode is disabled and the software uses TX or RX PDMA function to transfer data, this bit will be cleared after the PDMA finishes the data transfer.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Data transfer stopped</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>In Master mode, writing 1 to this bit to start the SPI data transfer; in Slave mode, writing 1 to this bit indicates that the slave is ready to communicate with a master</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_NEG</name>
              <description>Receive On Negative Edge\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Received data input signal is latched on the rising edge of SPI bus clock</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Received data input signal is latched on the falling edge of SPI bus clock</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_NEG</name>
              <description>Transmit On Negative Edge\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Transmitted data output signal is changed on the rising edge of SPI bus clock</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Transmitted data output signal is changed on the falling edge of SPI bus clock</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_BIT_LEN</name>
              <description>Transmit Bit Length\nThis field specifies how many bits can be transmitted / received in one transaction. The minimum bit length is 8 bits and can up to 32 bits.\n</description>
              <bitOffset>3</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>LSB</name>
              <description>Send LSB First\n</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The MSB, which bit of transmit/receive register depends on the setting of TX_BIT_LEN, is transmitted/received first</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The LSB, bit 0 of the SPI TX0/1 register, is sent first to the SPI data output pin, and the first bit received from the SPI data input pin will be put in the LSB position of the RX register (bit 0 of SPI_RX0/1)</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CLKP</name>
              <description>Clock Polarity\n</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>SPI bus clock is idle low</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>SPI bus clock is idle high</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SP_CYCLE</name>
              <description>Suspend Interval (Master Only)\nThe four bits provide configurable suspend interval between two successive transmit/receive transaction in a transfer. The definition of the suspend interval is the interval between the last clock edge of the preceding transaction word and the first clock edge of the following transaction word. The default value is 0x3. The period of the suspend interval is obtained according to the following equation.\n (SP_CYCLE[3:0] + 0.5) * period of SPI bus clock cycle\nExample:\nIf the variable clock function is enabled and the transmit FIFO buffer is not empty, the minimum period of suspend interval between the successive transactions is (6.5 + SP_CYCLE) * SPI bus clock cycle.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>IF</name>
              <description>Unit Transfer Interrupt Flag\nNote: This bit will be cleared by writing 1 to itself.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No transaction has been finished since this bit was cleared to 0</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>SPI controller has finished one unit transfer</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IE</name>
              <description>Unit Transfer Interrupt EnableBit\n</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>SPI unit transfer interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>SPI unit transfer interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SLAVE</name>
              <description>Slave Mode EnableBit\n</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Master mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Slave mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>REORDER</name>
              <description>Byte Reorder Function EnableBit\nNote:\nByte Reorder function is only available if TX_BIT_LEN is defined as 16, 24, and 32 bits.\nIn Slave mode with level-trigger configuration, the slave select pin must be kept at active state during the byte suspend interval.\nThe Byte Reorder function is not supported when the variable bus clock function or Dual I/O mode is enabled.</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Byte Reorder function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Byte Reorder function Enabled. A byte suspend interval will be inserted among each byte. The period of the byte suspend interval depends on the setting of SP_CYCLE</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>FIFO</name>
              <description>FIFO Mode EnableBit\nNote:\nBefore enabling FIFO mode, the other related settings should be set in advance.\nIn Master mode, if the FIFO mode is enabled, the GO_BUSY bit will be set to 1 automatically after writing data to the transmit FIFO buffer; the GO_BUSY bit will be cleared to 0 automatically when the SPI controller is in idle. If all data stored at transmit FIFO buffer are sent out, the TX_EMPTY bit will be set to 1 and the GO_BUSY bit will be cleared to 0.\nAfter clearing this bit to 0, user must wait for at least 2 peripheral clock periods before setting this bit to 1 again.</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>FIFO mode Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>FIFO mode Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TWOB</name>
              <description>2-Bit Transfer Mode EnableBit\nNote: When 2-bit Transfer mode is enabled, the serial transmitted 2-bit data are from SPI_TX1/0, and the received 2-bit data input are put in SPI_RX1/0.</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>2-bit Transfer mode Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>2-bit Transfer mode Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>VARCLK_EN</name>
              <description>Variable Clock Enable Bit (Master Only)\nNote: When this VARCLK_EN bit is set to 1, the setting of TX_BIT_LEN must be programmed as 0x10 (16-bit mode).</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>SPI clock output frequency is fixed and decided only by the value of DIVIDER</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>SPI clock output frequency is variable. The output frequency is decided by the value of VARCLK, DIVIDER, and DIVIDER2</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_EMPTY</name>
              <description>Receive FIFO Buffer Empty Indicator (Read Only)\nIt is a mutual mirror bit of SPI_CNTRL[24].\n</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Receive FIFO buffer is not empty</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Receive FIFO buffer is empty</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>RX_FULL</name>
              <description>Receive FIFO Buffer Full Indicator (Read Only)\nIt is a mutual mirror bit of SPI_STATUS[25].\n</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Receive FIFO buffer is not full</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Receive FIFO buffer is full</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>TX_EMPTY</name>
              <description>Transmit FIFO Buffer Empty Indicator (Read Only)\nIt is a mutual mirror bit of SPI_STATUS[26].\n</description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Transmit FIFO buffer is not empty</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Transmit FIFO buffer is empty</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>TX_FULL</name>
              <description>Transmit FIFO Buffer Full Indicator (Read Only)\nIt is a mutual mirror bit of SPI_STATUS[27].\n</description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Transmit FIFO buffer is not full</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Transmit FIFO buffer is full</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SPI_DIVIDER</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SPI_DIVIDER</displayName>
          <description>Clock Divider Register</description>
          <addressOffset>0x4</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DIVIDER</name>
              <description>Clock Divider 1 Register \nThe value in this field is the frequency divider for generating the SPI peripheral clock, fspi_eclk, and the SPI bus clock of SPI master. The frequency is obtained according to the following equation. \nIf the bit of BCn, SPI_CNTRL2[31], is set to 0,\n\nelse if BCn is set to 1,\n\nwhere \n is the SPI peripheral clock source, which is defined in the CLKSEL1 register.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DIVIDER2</name>
              <description>Clock Divider 2 Register (Master Only)\nThe value in this field is the 2nd frequency divider for generating the second clock of the variable clock function. The frequency is obtained according to the following equation: \n\nIf the VARCLK_EN bit is cleared to 0, this setting is unmeaning.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SPI_SSR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SPI_SSR</displayName>
          <description>Slave Select Register</description>
          <addressOffset>0x8</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SSR</name>
              <description>Slave Select Control Bits (Master Only)\nIf AUTOSS bit is cleared, writing 1 to any bit of this field sets the proper SPIn_SPISS0/1 line to an active state and writing 0 sets the line back to inactive state.\nIf the AUTOSS bit is set, writing 0 to any bit location of this field will keep the corresponding SPIn_SPISS0/1 line at inactive state; writing 1 to any bit location of this field will select appropriate SPIn_SPISS0/1 line to be automatically driven to active state for the duration of the transmit/receive, and will be driven to inactive state for the rest of the time. The active state of SPIn_SPISS0/1 is specified in SS_LVL. \nNote: SPIn_SPISS0 is defined as the slave select input in Slave mode.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SS_LVL</name>
              <description>Slave Select Active Level\nThis bit defines the active status of slave select signal (SPIn_SPISS0/1).\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The slave select signal SPIn_SPISS0/1 is active on low-level/falling-edge</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The slave select signal SPIn_SPISS0/1 is active on high-level/rising-edge</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>AUTOSS</name>
              <description>Automatic Slave Select Function Enable Bit (Master Only)\n</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>If this bit is cleared, slave select signals will be asserted/de-asserted by setting /clearing the corresponding bits of SPI_SSR[1:0]</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>If this bit is set, SPIn_SPISS0/1 signals will be generated automatically. It means that device/slave select signal, which is set in SPI_SSR[1:0], will be asserted by the SPI controller when transmit/receive is started, and will be de-asserted after each transmit/receive is finished</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SS_LTRIG</name>
              <description>Slave Select Level Trigger Enable Bit (Slave Only)\n</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Slave select signal is edge-trigger. This is the default value. The SS_LVL bit decides the signal is active after a falling-edge or rising-edge</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Slave select signal is level-trigger. The SS_LVL bit decides the signal is active low or active high</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>LTRIG_FLAG</name>
              <description>Level Trigger Accomplish Flag\nIn Slave mode, this bit indicates whether the received bit number meets the requirement or not after the current transaction done. \nNote: This bit is READ only. As the GO_BUSY bit is set to 1 by software, the LTRIG_FLAG will be cleared to 0 after 4 SPI peripheral clock periods plus 1 system clock period. In FIFO mode, this bit has no meaning.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Transferred bit length of one transaction does not meet the specified requirement</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Transferred bit length meets the specified requirement which defined in TX_BIT_LEN</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SPI_RX0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SPI_RX0</displayName>
          <description>Data Receive Register 0</description>
          <addressOffset>0x10</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RX</name>
              <description>Data Receive Register\nThe data receive register holds the datum received from SPI data input pin. If FIFO mode is disabled, the last received data can be accessed through software by reading this register. If the FIFO bit is set as 1 and the RX_EMPTY bit, SPI_CNTRL[24] or SPI_STATUS[24], is not set to 1, the receive FIFO buffer can be accessed through software by reading this register. This is a read-only register.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="SPI_RX0">
          <name>SPI_RX1</name>
          <displayName>SPI_RX1</displayName>
          <description>Data Receive Register 1</description>
          <addressOffset>0x14</addressOffset>
       </register>
       <register>
          <name>SPI_TX0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SPI_TX0</displayName>
          <description>Data Transmit Register 0</description>
          <addressOffset>0x20</addressOffset>
          <access>write-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TX</name>
              <description>Data Transmit Register\nThe data transmit registers hold the data to be transmitted in the next transfer. The number of valid bits depends on the setting of transmit bit length field of the SPI_CNTRL register.\nFor example, if TX_BIT_LEN is set to 0x08, the bits TX[7:0] will be transmitted in next transfer. If TX_BIT_LEN is set to 0x00, the SPI controller will perform a 32-bit transfer.\nNote 1: When the SPI controller is configured as a slave device and FIFO mode is disabled, if the SPI controller attempts to transmit data to a master, the transmit data register should be updated by software before setting the GO_BUSY bit to 1.\nNote 2: In Master mode, SPI controller will start to transfer after 5 peripheral clock cycles since user wrote to this register.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="SPI_TX0">
          <name>SPI_TX1</name>
          <displayName>SPI_TX1</displayName>
          <description>Data Transmit Register 1</description>
          <addressOffset>0x24</addressOffset>
       </register>
       <register>
          <name>SPI_VARCLK</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SPI_VARCLK</displayName>
          <description>Variable Clock Pattern Register</description>
          <addressOffset>0x34</addressOffset>
          <access>read-write</access>
          <resetValue>0x007FFF87</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>VARCLK</name>
              <description>Variable Clock Pattern\nThis register defines the clock pattern of the SPI transfer. If the variable clock function is disabled, this setting is unmeaning. Refer to the "Variable Clock Function" paragraph for more detail description.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SPI_DMA</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SPI_DMA</displayName>
          <description>SPI DMA Control Register</description>
          <addressOffset>0x38</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TX_DMA_GO</name>
              <description>Transmit DMA Start\nSetting this bit to 1 will start the transmit PDMA process. SPI controller will issue request to PDMA controller automatically. Hardware will clear this bit to 0 automatically after PDMA transfer done.\nIf the SPI transmit PDMA function is used to transfer data, the GO_BUSY bit should not be set to 1 by software. The PDMA control logic of SPI controller will set it automatically whenever necessary.\nIn Slave mode and when FIFO mode is disabled, the minimal suspend interval between two successive transactions must be larger than (8 SPI clock periods + 14 APB clock periods) for edge-trigger mode or (9.5 SPI clock periods + 14 APB clock periods) for level-trigger mode. If the 2-bit Transfer mode is enabled, additional 18 APB clock periods for the above conditions is required.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_DMA_GO</name>
              <description>Receive DMA Start\nSetting this bit to 1 will start the receive PDMA process. The SPI controller will issue request to PDMA controller automatically when the SPI receive buffer is not empty. This bit will be cleared to 0 by hardware automatically after PDMA transfer is done.\nIf the software uses the receive PDMA function to access the received data of SPI and does not use the transmit PDMA function, the GO_BUSY bit should be set by software.\nEnabling FIFO mode is recommended if the software uses more than one PDMA channel to transfer data.\nIn Slave mode and when FIFO mode is disabled, if the software only uses one PDMA channel for SPI receive PDMA function and the other PDMA channels are not in use, the minimal suspend interval between two successive transactions must be larger than (9 SPI slave peripheral clock periods + 4 APB clock periods) for Edge-trigger mode or (9.5 SPI slave peripheral clock periods + 4 APB clock periods) for Level-trigger mode.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PDMA_RST</name>
              <description>PDMA Reset\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reset the PDMA control logic of the SPI controller. This bit will be cleared to 0 automatically</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SPI_CNTRL2</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SPI_CNTRL2</displayName>
          <description>Control and Status Register 2</description>
          <addressOffset>0x3C</addressOffset>
          <access>read-write</access>
          <resetValue>0x00001000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>NOSLVSEL</name>
              <description>Slave 3-Wire Mode Enable Bit\nThis is used to ignore the slave select signal in Slave mode. The SPI controller can work with 3-wire interface including SPIn_CLK, SPIn_MISO, and SPIn_MOSI.\nNote: In Slave 3-wire mode, the SS_LTRIG, SPI_SSR[4] will be set as 1 automatically.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>4-wire bi-direction interface</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>3-wire bi-direction interface</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SLV_ABORT</name>
              <description>Slave 3-Wire Mode Abort Control\nIn normal operation, there is an interrupt event when the received data meet the required bits which defined in TX_BIT_LEN.\nIf the received bits are less than the requirement and there is no more SPI clock input over the one transfer time in Slave 3-wire mode, the user can set this bit to force the current transfer done and then the user can get a transfer done interrupt event. \nNote: This bit will be cleared to 0 automatically by hardware after it is set to 1 by software.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SSTA_INTEN</name>
              <description>Slave 3-Wire Mode Start Interrupt EnableBit\nUsed to enable interrupt when the transfer has started in Slave 3-wire mode. If there is no transfer done interrupt over the time period which is defined by user after the transfer start, the user can set the SLV_ABORT bit to force the transfer done.\n</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Transaction start interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Transaction start interrupt Enabled. It will be cleared to 0 as the current transfer is done or the SLV_START_INTSTS bit is cleared</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SLV_START_INTSTS</name>
              <description>Slave 3-Wire Mode Start Interrupt Status\nThis bit indicates if a transaction has started in Slave 3-wire mode. It is a mutual mirror bit of SPI_STATUS[11].\n</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Slave has not detected any SPI clock transition since the SSTA_INTEN bit was set to 1</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>A transaction has started in Slave 3-wire mode. It will be cleared automatically when a transaction is done or by writing 1 to this bit</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DUAL_IO_DIR</name>
              <description>Dual I/O Mode Direction Control\n</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Dual Input mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Dual Output mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DUAL_IO_EN</name>
              <description>Dual I/O Mode EnableBit\n</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Dual I/O mode Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Dual I/O mode Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SS_INT_OPT</name>
              <description>Slave Select Inactive Interrupt Option \nThis setting is only available if the SPI controller is configured as level trigger slave device.\n</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>As the slave select signal goes to inactive level, the IF bit will NOT be set to 1</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>As the slave select signal goes to inactive level, the IF bit will be set to 1</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BCn</name>
              <description>SPI Peripheral Clock Backward Compatible Option\nRefer to the description of SPI_DIVIDER register for details.</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Backward compatible clock configuration</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Clock configuration is not backward compatible</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SPI_FIFO_CTL</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SPI_FIFO_CTL</displayName>
          <description>SPI FIFO Control Register</description>
          <addressOffset>0x40</addressOffset>
          <access>read-write</access>
          <resetValue>0x44000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RX_CLR</name>
              <description>Clear Receive FIFO Buffer\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Clear receive FIFO buffer. The RX_FULL flag will be cleared to 0 and the RX_EMPTY flag will be set to 1. This bit will be cleared to 0 by hardware after it is set to 1 by software</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_CLR</name>
              <description>Clear Transmit FIFO Buffer\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Clear transmit FIFO buffer. The TX_FULL flag will be cleared to 0 and the TX_EMPTY flag will be set to 1. This bit will be cleared to 0 by hardware after it is set to 1 by software</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_INTEN</name>
              <description>Receive Threshold Interrupt Enable Bit\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RX threshold interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RX threshold interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_INTEN</name>
              <description>Transmit Threshold Interrupt Enable Bit\n</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>TX threshold interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>TX threshold interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RXOV_INTEN</name>
              <description>Receive FIFO Overrun Interrupt Enable Bit\n</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Receive FIFO overrun interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Receive FIFO overrun interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TIMEOUT_INTEN</name>
              <description>Receive FIFO Time-Out Interrupt Enable Bit\n</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Time-out interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Time-out interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_THRESHOLD</name>
              <description>Receive FIFO Threshold\nIf the valid data count of the receive FIFO buffer is larger than the RX_THRESHOLD setting, the RX_INTSTS bit will be set to 1, else the RX_INTSTS bit will be cleared to 0.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_THRESHOLD</name>
              <description>Transmit FIFO Threshold\nIf the valid data count of the transmit FIFO buffer is less than or equal to the TX_THRESHOLD setting, the TX_INTSTS bit will be set to 1, else the TX_INTSTS bit will be cleared to 0.</description>
              <bitOffset>28</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SPI_STATUS</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SPI_STATUS</displayName>
          <description>SPI Status Register</description>
          <addressOffset>0x44</addressOffset>
          <access>read-write</access>
          <resetValue>0x05000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RX_INTSTS</name>
              <description>Receive FIFO Threshold Interrupt Status (Read Only)\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The valid data count within the Rx FIFO buffer is smaller than or equal to the setting value of RX_THRESHOLD</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The valid data count within the receive FIFO buffer is larger than the setting value of RX_THRESHOLD</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>RX_OVERRUN</name>
              <description>Receive FIFO Overrun Status\nWhen the receive FIFO buffer is full, the follow-up data will be dropped and this bit will be set to 1.\nNote: This bit will be cleared by writing 1 to itself.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_INTSTS</name>
              <description>Transmit FIFO Threshold Interrupt Status (Read Only)\n</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The valid data count within the transmit FIFO buffer is larger than the setting value of TX_THRESHOLD</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The valid data count within the transmit FIFO buffer is less than or equal to the setting value of TX_THRESHOLD</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>SLV_START_INTSTS</name>
              <description>Slave Start Interrupt Status\nIt is used to dedicate if a transaction has started in Slave 3-wire mode. It is a mutual mirror bit of SPI_CNTRL2[11].\n</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Slave has not detected any SPI clock transition since the SSTA_INTEN bit was set to 1</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>A transaction has started in Slave 3-wire mode. It will be cleared as a transaction is done or by writing 1 to this bit</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_FIFO_COUNT</name>
              <description>Receive FIFO Data Count (Read Only)\nThis bit field indicates the valid data count of receive FIFO buffer.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>IF</name>
              <description>SPI Unit Transfer Interrupt Flag\nIt is a mutual mirror bit of SPI_CNTRL[16].\nNote: This bit will be cleared by writing 1 to itself.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No transaction has been finished since this bit was cleared to 0</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>SPI controller has finished one unit transfer</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TIMEOUT</name>
              <description>Time-Out Interrupt Flag\nNote: This bit will be cleared by writing 1 to itself.</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No receive FIFO time-out event</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Receive FIFO buffer is not empty and no read operation on receive FIFO buffer over 64 SPI clock period in Master mode or over 576 SPI peripheral clock period in Slave mode. When the received FIFO buffer is read by software, the time-out status will be cleared automatically</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_EMPTY</name>
              <description>Receive FIFO Buffer Empty Indicator (Read Only)\nIt is a mutual mirror bit of SPI_CNTRL[24].\n</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Receive FIFO buffer is not empty</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Receive FIFO buffer is empty</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>RX_FULL</name>
              <description>Receive FIFO Buffer Empty Indicator (Read Only)\nIt is a mutual mirror bit of SPI_CNTRL[24].\n</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Receive FIFO buffer is not empty</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Receive FIFO buffer is empty</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>TX_EMPTY</name>
              <description>Transmit FIFO Buffer Empty Indicator (Read Only)\nIt is a mutual mirror bit of SPI_CNTRL[26].\n</description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Transmit FIFO buffer is not empty</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Transmit FIFO buffer is empty</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>TX_FULL</name>
              <description>Transmit FIFO Buffer Full Indicator (Read Only)\nIt is a mutual mirror bit of SPI_CNTRL[27].\n</description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Transmit FIFO buffer is not full</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Transmit FIFO buffer is full</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>TX_FIFO_COUNT</name>
              <description>Transmit FIFO Data Count (Read Only)\nThis bit field indicates the valid data count of transmit FIFO buffer.</description>
              <bitOffset>28</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>SPI3</name>
      <description>SPI Register Map</description>
      <groupName>SPI</groupName>
      <baseAddress>0x40134000</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x0</offset>
        <size>0xC</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x10</offset>
        <size>0x8</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x20</offset>
        <size>0x8</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x34</offset>
        <size>0x14</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>SPI_CNTRL</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SPI_CNTRL</displayName>
          <description>Control and Status Register</description>
          <addressOffset>0x0</addressOffset>
          <access>read-write</access>
          <resetValue>0x05003004</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>GO_BUSY</name>
              <description>SPI Transfer Control Bit And Busy Status\nIf FIFO mode is disabled, during the data transfer, this bit keeps the value of 1. As the transfer is finished, this bit will be cleared automatically. Software can read this bit to check if the SPI is in busy status.\nIn FIFO mode, this bit will be controlled by hardware. Software should not modify this bit. In Slave mode, this bit always returns 1 when this register is read by software. In Master mode, this bit reflects the busy or idle status of SPI.\nNote:\nWhen FIFO mode is disabled, all configurations should be set before writing 1 to this GO_BUSY bit.\nWhen FIFO mode is disabled and the software uses TX or RX PDMA function to transfer data, this bit will be cleared after the PDMA finishes the data transfer.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Data transfer stopped</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>In Master mode, writing 1 to this bit to start the SPI data transfer; in Slave mode, writing 1 to this bit indicates that the slave is ready to communicate with a master</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_NEG</name>
              <description>Receive On Negative Edge\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Received data input signal is latched on the rising edge of SPI bus clock</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Received data input signal is latched on the falling edge of SPI bus clock</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_NEG</name>
              <description>Transmit On Negative Edge\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Transmitted data output signal is changed on the rising edge of SPI bus clock</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Transmitted data output signal is changed on the falling edge of SPI bus clock</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_BIT_LEN</name>
              <description>Transmit Bit Length\nThis field specifies how many bits can be transmitted / received in one transaction. The minimum bit length is 8 bits and can up to 32 bits.\n</description>
              <bitOffset>3</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>LSB</name>
              <description>Send LSB First\n</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The MSB, which bit of transmit/receive register depends on the setting of TX_BIT_LEN, is transmitted/received first</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The LSB, bit 0 of the SPI TX0/1 register, is sent first to the SPI data output pin, and the first bit received from the SPI data input pin will be put in the LSB position of the RX register (bit 0 of SPI_RX0/1)</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CLKP</name>
              <description>Clock Polarity\n</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>SPI bus clock is idle low</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>SPI bus clock is idle high</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SP_CYCLE</name>
              <description>Suspend Interval (Master Only)\nThe four bits provide configurable suspend interval between two successive transmit/receive transaction in a transfer. The definition of the suspend interval is the interval between the last clock edge of the preceding transaction word and the first clock edge of the following transaction word. The default value is 0x3. The period of the suspend interval is obtained according to the following equation.\n (SP_CYCLE[3:0] + 0.5) * period of SPI bus clock cycle\nExample:\nIf the variable clock function is enabled and the transmit FIFO buffer is not empty, the minimum period of suspend interval between the successive transactions is (6.5 + SP_CYCLE) * SPI bus clock cycle.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>IF</name>
              <description>Unit Transfer Interrupt Flag\nNote: This bit will be cleared by writing 1 to itself.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No transaction has been finished since this bit was cleared to 0</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>SPI controller has finished one unit transfer</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IE</name>
              <description>Unit Transfer Interrupt EnableBit\n</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>SPI unit transfer interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>SPI unit transfer interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SLAVE</name>
              <description>Slave Mode EnableBit\n</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Master mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Slave mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>REORDER</name>
              <description>Byte Reorder Function EnableBit\nNote:\nByte Reorder function is only available if TX_BIT_LEN is defined as 16, 24, and 32 bits.\nIn Slave mode with level-trigger configuration, the slave select pin must be kept at active state during the byte suspend interval.\nThe Byte Reorder function is not supported when the variable bus clock function or Dual I/O mode is enabled.</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Byte Reorder function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Byte Reorder function Enabled. A byte suspend interval will be inserted among each byte. The period of the byte suspend interval depends on the setting of SP_CYCLE</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>FIFO</name>
              <description>FIFO Mode EnableBit\nNote:\nBefore enabling FIFO mode, the other related settings should be set in advance.\nIn Master mode, if the FIFO mode is enabled, the GO_BUSY bit will be set to 1 automatically after writing data to the transmit FIFO buffer; the GO_BUSY bit will be cleared to 0 automatically when the SPI controller is in idle. If all data stored at transmit FIFO buffer are sent out, the TX_EMPTY bit will be set to 1 and the GO_BUSY bit will be cleared to 0.\nAfter clearing this bit to 0, user must wait for at least 2 peripheral clock periods before setting this bit to 1 again.</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>FIFO mode Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>FIFO mode Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TWOB</name>
              <description>2-Bit Transfer Mode EnableBit\nNote: When 2-bit Transfer mode is enabled, the serial transmitted 2-bit data are from SPI_TX1/0, and the received 2-bit data input are put in SPI_RX1/0.</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>2-bit Transfer mode Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>2-bit Transfer mode Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>VARCLK_EN</name>
              <description>Variable Clock Enable Bit (Master Only)\nNote: When this VARCLK_EN bit is set to 1, the setting of TX_BIT_LEN must be programmed as 0x10 (16-bit mode).</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>SPI clock output frequency is fixed and decided only by the value of DIVIDER</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>SPI clock output frequency is variable. The output frequency is decided by the value of VARCLK, DIVIDER, and DIVIDER2</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_EMPTY</name>
              <description>Receive FIFO Buffer Empty Indicator (Read Only)\nIt is a mutual mirror bit of SPI_CNTRL[24].\n</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Receive FIFO buffer is not empty</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Receive FIFO buffer is empty</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>RX_FULL</name>
              <description>Receive FIFO Buffer Full Indicator (Read Only)\nIt is a mutual mirror bit of SPI_STATUS[25].\n</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Receive FIFO buffer is not full</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Receive FIFO buffer is full</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>TX_EMPTY</name>
              <description>Transmit FIFO Buffer Empty Indicator (Read Only)\nIt is a mutual mirror bit of SPI_STATUS[26].\n</description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Transmit FIFO buffer is not empty</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Transmit FIFO buffer is empty</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>TX_FULL</name>
              <description>Transmit FIFO Buffer Full Indicator (Read Only)\nIt is a mutual mirror bit of SPI_STATUS[27].\n</description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Transmit FIFO buffer is not full</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Transmit FIFO buffer is full</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SPI_DIVIDER</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SPI_DIVIDER</displayName>
          <description>Clock Divider Register</description>
          <addressOffset>0x4</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DIVIDER</name>
              <description>Clock Divider 1 Register \nThe value in this field is the frequency divider for generating the SPI peripheral clock, fspi_eclk, and the SPI bus clock of SPI master. The frequency is obtained according to the following equation. \nIf the bit of BCn, SPI_CNTRL2[31], is set to 0,\n\nelse if BCn is set to 1,\n\nwhere \n is the SPI peripheral clock source, which is defined in the CLKSEL1 register.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DIVIDER2</name>
              <description>Clock Divider 2 Register (Master Only)\nThe value in this field is the 2nd frequency divider for generating the second clock of the variable clock function. The frequency is obtained according to the following equation: \n\nIf the VARCLK_EN bit is cleared to 0, this setting is unmeaning.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SPI_SSR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SPI_SSR</displayName>
          <description>Slave Select Register</description>
          <addressOffset>0x8</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SSR</name>
              <description>Slave Select Control Bits (Master Only)\nIf AUTOSS bit is cleared, writing 1 to any bit of this field sets the proper SPIn_SPISS0/1 line to an active state and writing 0 sets the line back to inactive state.\nIf the AUTOSS bit is set, writing 0 to any bit location of this field will keep the corresponding SPIn_SPISS0/1 line at inactive state; writing 1 to any bit location of this field will select appropriate SPIn_SPISS0/1 line to be automatically driven to active state for the duration of the transmit/receive, and will be driven to inactive state for the rest of the time. The active state of SPIn_SPISS0/1 is specified in SS_LVL. \nNote: SPIn_SPISS0 is defined as the slave select input in Slave mode.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SS_LVL</name>
              <description>Slave Select Active Level\nThis bit defines the active status of slave select signal (SPIn_SPISS0/1).\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The slave select signal SPIn_SPISS0/1 is active on low-level/falling-edge</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The slave select signal SPIn_SPISS0/1 is active on high-level/rising-edge</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>AUTOSS</name>
              <description>Automatic Slave Select Function Enable Bit (Master Only)\n</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>If this bit is cleared, slave select signals will be asserted/de-asserted by setting /clearing the corresponding bits of SPI_SSR[1:0]</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>If this bit is set, SPIn_SPISS0/1 signals will be generated automatically. It means that device/slave select signal, which is set in SPI_SSR[1:0], will be asserted by the SPI controller when transmit/receive is started, and will be de-asserted after each transmit/receive is finished</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SS_LTRIG</name>
              <description>Slave Select Level Trigger Enable Bit (Slave Only)\n</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Slave select signal is edge-trigger. This is the default value. The SS_LVL bit decides the signal is active after a falling-edge or rising-edge</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Slave select signal is level-trigger. The SS_LVL bit decides the signal is active low or active high</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>LTRIG_FLAG</name>
              <description>Level Trigger Accomplish Flag\nIn Slave mode, this bit indicates whether the received bit number meets the requirement or not after the current transaction done. \nNote: This bit is READ only. As the GO_BUSY bit is set to 1 by software, the LTRIG_FLAG will be cleared to 0 after 4 SPI peripheral clock periods plus 1 system clock period. In FIFO mode, this bit has no meaning.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Transferred bit length of one transaction does not meet the specified requirement</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Transferred bit length meets the specified requirement which defined in TX_BIT_LEN</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SPI_RX0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SPI_RX0</displayName>
          <description>Data Receive Register 0</description>
          <addressOffset>0x10</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RX</name>
              <description>Data Receive Register\nThe data receive register holds the datum received from SPI data input pin. If FIFO mode is disabled, the last received data can be accessed through software by reading this register. If the FIFO bit is set as 1 and the RX_EMPTY bit, SPI_CNTRL[24] or SPI_STATUS[24], is not set to 1, the receive FIFO buffer can be accessed through software by reading this register. This is a read-only register.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="SPI_RX0">
          <name>SPI_RX1</name>
          <displayName>SPI_RX1</displayName>
          <description>Data Receive Register 1</description>
          <addressOffset>0x14</addressOffset>
       </register>
       <register>
          <name>SPI_TX0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SPI_TX0</displayName>
          <description>Data Transmit Register 0</description>
          <addressOffset>0x20</addressOffset>
          <access>write-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TX</name>
              <description>Data Transmit Register\nThe data transmit registers hold the data to be transmitted in the next transfer. The number of valid bits depends on the setting of transmit bit length field of the SPI_CNTRL register.\nFor example, if TX_BIT_LEN is set to 0x08, the bits TX[7:0] will be transmitted in next transfer. If TX_BIT_LEN is set to 0x00, the SPI controller will perform a 32-bit transfer.\nNote 1: When the SPI controller is configured as a slave device and FIFO mode is disabled, if the SPI controller attempts to transmit data to a master, the transmit data register should be updated by software before setting the GO_BUSY bit to 1.\nNote 2: In Master mode, SPI controller will start to transfer after 5 peripheral clock cycles since user wrote to this register.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="SPI_TX0">
          <name>SPI_TX1</name>
          <displayName>SPI_TX1</displayName>
          <description>Data Transmit Register 1</description>
          <addressOffset>0x24</addressOffset>
       </register>
       <register>
          <name>SPI_VARCLK</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SPI_VARCLK</displayName>
          <description>Variable Clock Pattern Register</description>
          <addressOffset>0x34</addressOffset>
          <access>read-write</access>
          <resetValue>0x007FFF87</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>VARCLK</name>
              <description>Variable Clock Pattern\nThis register defines the clock pattern of the SPI transfer. If the variable clock function is disabled, this setting is unmeaning. Refer to the "Variable Clock Function" paragraph for more detail description.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SPI_DMA</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SPI_DMA</displayName>
          <description>SPI DMA Control Register</description>
          <addressOffset>0x38</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TX_DMA_GO</name>
              <description>Transmit DMA Start\nSetting this bit to 1 will start the transmit PDMA process. SPI controller will issue request to PDMA controller automatically. Hardware will clear this bit to 0 automatically after PDMA transfer done.\nIf the SPI transmit PDMA function is used to transfer data, the GO_BUSY bit should not be set to 1 by software. The PDMA control logic of SPI controller will set it automatically whenever necessary.\nIn Slave mode and when FIFO mode is disabled, the minimal suspend interval between two successive transactions must be larger than (8 SPI clock periods + 14 APB clock periods) for edge-trigger mode or (9.5 SPI clock periods + 14 APB clock periods) for level-trigger mode. If the 2-bit Transfer mode is enabled, additional 18 APB clock periods for the above conditions is required.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_DMA_GO</name>
              <description>Receive DMA Start\nSetting this bit to 1 will start the receive PDMA process. The SPI controller will issue request to PDMA controller automatically when the SPI receive buffer is not empty. This bit will be cleared to 0 by hardware automatically after PDMA transfer is done.\nIf the software uses the receive PDMA function to access the received data of SPI and does not use the transmit PDMA function, the GO_BUSY bit should be set by software.\nEnabling FIFO mode is recommended if the software uses more than one PDMA channel to transfer data.\nIn Slave mode and when FIFO mode is disabled, if the software only uses one PDMA channel for SPI receive PDMA function and the other PDMA channels are not in use, the minimal suspend interval between two successive transactions must be larger than (9 SPI slave peripheral clock periods + 4 APB clock periods) for Edge-trigger mode or (9.5 SPI slave peripheral clock periods + 4 APB clock periods) for Level-trigger mode.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PDMA_RST</name>
              <description>PDMA Reset\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reset the PDMA control logic of the SPI controller. This bit will be cleared to 0 automatically</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SPI_CNTRL2</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SPI_CNTRL2</displayName>
          <description>Control and Status Register 2</description>
          <addressOffset>0x3C</addressOffset>
          <access>read-write</access>
          <resetValue>0x00001000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>NOSLVSEL</name>
              <description>Slave 3-Wire Mode Enable Bit\nThis is used to ignore the slave select signal in Slave mode. The SPI controller can work with 3-wire interface including SPIn_CLK, SPIn_MISO, and SPIn_MOSI.\nNote: In Slave 3-wire mode, the SS_LTRIG, SPI_SSR[4] will be set as 1 automatically.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>4-wire bi-direction interface</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>3-wire bi-direction interface</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SLV_ABORT</name>
              <description>Slave 3-Wire Mode Abort Control\nIn normal operation, there is an interrupt event when the received data meet the required bits which defined in TX_BIT_LEN.\nIf the received bits are less than the requirement and there is no more SPI clock input over the one transfer time in Slave 3-wire mode, the user can set this bit to force the current transfer done and then the user can get a transfer done interrupt event. \nNote: This bit will be cleared to 0 automatically by hardware after it is set to 1 by software.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SSTA_INTEN</name>
              <description>Slave 3-Wire Mode Start Interrupt EnableBit\nUsed to enable interrupt when the transfer has started in Slave 3-wire mode. If there is no transfer done interrupt over the time period which is defined by user after the transfer start, the user can set the SLV_ABORT bit to force the transfer done.\n</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Transaction start interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Transaction start interrupt Enabled. It will be cleared to 0 as the current transfer is done or the SLV_START_INTSTS bit is cleared</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SLV_START_INTSTS</name>
              <description>Slave 3-Wire Mode Start Interrupt Status\nThis bit indicates if a transaction has started in Slave 3-wire mode. It is a mutual mirror bit of SPI_STATUS[11].\n</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Slave has not detected any SPI clock transition since the SSTA_INTEN bit was set to 1</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>A transaction has started in Slave 3-wire mode. It will be cleared automatically when a transaction is done or by writing 1 to this bit</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DUAL_IO_DIR</name>
              <description>Dual I/O Mode Direction Control\n</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Dual Input mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Dual Output mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DUAL_IO_EN</name>
              <description>Dual I/O Mode EnableBit\n</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Dual I/O mode Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Dual I/O mode Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SS_INT_OPT</name>
              <description>Slave Select Inactive Interrupt Option \nThis setting is only available if the SPI controller is configured as level trigger slave device.\n</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>As the slave select signal goes to inactive level, the IF bit will NOT be set to 1</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>As the slave select signal goes to inactive level, the IF bit will be set to 1</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BCn</name>
              <description>SPI Peripheral Clock Backward Compatible Option\nRefer to the description of SPI_DIVIDER register for details.</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Backward compatible clock configuration</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Clock configuration is not backward compatible</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SPI_FIFO_CTL</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SPI_FIFO_CTL</displayName>
          <description>SPI FIFO Control Register</description>
          <addressOffset>0x40</addressOffset>
          <access>read-write</access>
          <resetValue>0x44000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RX_CLR</name>
              <description>Clear Receive FIFO Buffer\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Clear receive FIFO buffer. The RX_FULL flag will be cleared to 0 and the RX_EMPTY flag will be set to 1. This bit will be cleared to 0 by hardware after it is set to 1 by software</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_CLR</name>
              <description>Clear Transmit FIFO Buffer\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Clear transmit FIFO buffer. The TX_FULL flag will be cleared to 0 and the TX_EMPTY flag will be set to 1. This bit will be cleared to 0 by hardware after it is set to 1 by software</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_INTEN</name>
              <description>Receive Threshold Interrupt Enable Bit\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RX threshold interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RX threshold interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_INTEN</name>
              <description>Transmit Threshold Interrupt Enable Bit\n</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>TX threshold interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>TX threshold interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RXOV_INTEN</name>
              <description>Receive FIFO Overrun Interrupt Enable Bit\n</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Receive FIFO overrun interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Receive FIFO overrun interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TIMEOUT_INTEN</name>
              <description>Receive FIFO Time-Out Interrupt Enable Bit\n</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Time-out interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Time-out interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_THRESHOLD</name>
              <description>Receive FIFO Threshold\nIf the valid data count of the receive FIFO buffer is larger than the RX_THRESHOLD setting, the RX_INTSTS bit will be set to 1, else the RX_INTSTS bit will be cleared to 0.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_THRESHOLD</name>
              <description>Transmit FIFO Threshold\nIf the valid data count of the transmit FIFO buffer is less than or equal to the TX_THRESHOLD setting, the TX_INTSTS bit will be set to 1, else the TX_INTSTS bit will be cleared to 0.</description>
              <bitOffset>28</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SPI_STATUS</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SPI_STATUS</displayName>
          <description>SPI Status Register</description>
          <addressOffset>0x44</addressOffset>
          <access>read-write</access>
          <resetValue>0x05000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RX_INTSTS</name>
              <description>Receive FIFO Threshold Interrupt Status (Read Only)\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The valid data count within the Rx FIFO buffer is smaller than or equal to the setting value of RX_THRESHOLD</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The valid data count within the receive FIFO buffer is larger than the setting value of RX_THRESHOLD</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>RX_OVERRUN</name>
              <description>Receive FIFO Overrun Status\nWhen the receive FIFO buffer is full, the follow-up data will be dropped and this bit will be set to 1.\nNote: This bit will be cleared by writing 1 to itself.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_INTSTS</name>
              <description>Transmit FIFO Threshold Interrupt Status (Read Only)\n</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The valid data count within the transmit FIFO buffer is larger than the setting value of TX_THRESHOLD</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The valid data count within the transmit FIFO buffer is less than or equal to the setting value of TX_THRESHOLD</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>SLV_START_INTSTS</name>
              <description>Slave Start Interrupt Status\nIt is used to dedicate if a transaction has started in Slave 3-wire mode. It is a mutual mirror bit of SPI_CNTRL2[11].\n</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Slave has not detected any SPI clock transition since the SSTA_INTEN bit was set to 1</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>A transaction has started in Slave 3-wire mode. It will be cleared as a transaction is done or by writing 1 to this bit</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_FIFO_COUNT</name>
              <description>Receive FIFO Data Count (Read Only)\nThis bit field indicates the valid data count of receive FIFO buffer.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>IF</name>
              <description>SPI Unit Transfer Interrupt Flag\nIt is a mutual mirror bit of SPI_CNTRL[16].\nNote: This bit will be cleared by writing 1 to itself.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No transaction has been finished since this bit was cleared to 0</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>SPI controller has finished one unit transfer</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TIMEOUT</name>
              <description>Time-Out Interrupt Flag\nNote: This bit will be cleared by writing 1 to itself.</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No receive FIFO time-out event</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Receive FIFO buffer is not empty and no read operation on receive FIFO buffer over 64 SPI clock period in Master mode or over 576 SPI peripheral clock period in Slave mode. When the received FIFO buffer is read by software, the time-out status will be cleared automatically</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_EMPTY</name>
              <description>Receive FIFO Buffer Empty Indicator (Read Only)\nIt is a mutual mirror bit of SPI_CNTRL[24].\n</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Receive FIFO buffer is not empty</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Receive FIFO buffer is empty</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>RX_FULL</name>
              <description>Receive FIFO Buffer Empty Indicator (Read Only)\nIt is a mutual mirror bit of SPI_CNTRL[24].\n</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Receive FIFO buffer is not empty</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Receive FIFO buffer is empty</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>TX_EMPTY</name>
              <description>Transmit FIFO Buffer Empty Indicator (Read Only)\nIt is a mutual mirror bit of SPI_CNTRL[26].\n</description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Transmit FIFO buffer is not empty</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Transmit FIFO buffer is empty</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>TX_FULL</name>
              <description>Transmit FIFO Buffer Full Indicator (Read Only)\nIt is a mutual mirror bit of SPI_CNTRL[27].\n</description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Transmit FIFO buffer is not full</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Transmit FIFO buffer is full</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>TX_FIFO_COUNT</name>
              <description>Transmit FIFO Data Count (Read Only)\nThis bit field indicates the valid data count of transmit FIFO buffer.</description>
              <bitOffset>28</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>I2S</name>
      <description>I2S Register Map</description>
      <groupName>I2S</groupName>
      <baseAddress>0x401A0000</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x0</offset>
        <size>0x18</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>I2SCON</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>I2SCON</displayName>
          <description>I2S Control Register</description>
          <addressOffset>0x0</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>I2SEN</name>
              <description>I2S Controller Enable Bit\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TXEN</name>
              <description>Transmit Enable Bit\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Data transmit Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Data transmit Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RXEN</name>
              <description>Receive Enable Bit\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Data receiving Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Data receiving Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>MUTE</name>
              <description>Transmit Mute Enable Bit\n</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Transmit data is shifted from buffer</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Send zero on transmit channel</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>WORDWIDTH</name>
              <description>Word Width\n</description>
              <bitOffset>4</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>data is 8-bit word</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>data is 16-bit word</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>data is 24-bit word</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>data is 32-bit word</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>MONO</name>
              <description>Monaural Data\n</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Data is stereo format</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Data is monaural format</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>FORMAT</name>
              <description>Data Format\n</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>I2S data format</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>MSB justified data format</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SLAVE</name>
              <description>Slave Mode\nI2S can operate as master or slave. For Master mode, I2S_BCLK and I2S_LRCLK pins are output mode and send bit clock from NuMicro( NUC230/240 series to Audio CODEC chip. In Slave mode, I2S_BCLK and I2S_LRCLK pins are input mode and I2S_BCLK and I2S_LRCLK signals are received from outer Audio CODEC chip.\n</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Master mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Slave mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TXTH</name>
              <description>Transmit FIFO Threshold Level\nIf the count of remaining data word (32 bits) in transmit FIFO is equal to or less than threshold level then TXTHF (I2SSTATUS[18]) is set.\n</description>
              <bitOffset>9</bitOffset>
              <bitWidth>3</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>0 word data in transmit FIFO</description>
                    <value>#000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>1 word data in transmit FIFO</description>
                    <value>#001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>2 words data in transmit FIFO</description>
                    <value>#010</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>3 words data in transmit FIFO</description>
                    <value>#011</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>4</name>
                    <description>4 words data in transmit FIFO</description>
                    <value>#100</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>5</name>
                    <description>5 words data in transmit FIFO</description>
                    <value>#101</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>6</name>
                    <description>6 words data in transmit FIFO</description>
                    <value>#110</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>7</name>
                    <description>7 words data in transmit FIFO</description>
                    <value>#111</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RXTH</name>
              <description>Receive FIFO Threshold Level\nWhen the count of received data word(s) in buffer is equal to or higher than threshold level, RXTHF (I2SSTATUS[10]) will be set.\n</description>
              <bitOffset>12</bitOffset>
              <bitWidth>3</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>1 word data in receive FIFO</description>
                    <value>#000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>2 word data in receive FIFO</description>
                    <value>#001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>3 word data in receive FIFO</description>
                    <value>#010</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>4 word data in receive FIFO</description>
                    <value>#011</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>4</name>
                    <description>5 word data in receive FIFO</description>
                    <value>#100</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>5</name>
                    <description>6 word data in receive FIFO</description>
                    <value>#101</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>6</name>
                    <description>7 word data in receive FIFO</description>
                    <value>#110</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>7</name>
                    <description>8 word data in receive FIFO</description>
                    <value>#111</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>MCLKEN</name>
              <description>Master Clock Enable Bit\nIf MCLKEN is set to 1, I2S controller will generate master clock on I2S_MCLK pin for external audio devices.\n</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Master clock Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Master clock Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RCHZCEN</name>
              <description>Right Channel Zero Cross Detection Enable Bit\nIf this bit is set to 1, when right channel data sign bit change or next shift data bits are all 0 then RZCF flag in I2SSTATUS register is set to 1. This function is only available in transmit operation.\n</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Right channel zero cross detection Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Right channel zero cross detection Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>LCHZCEN</name>
              <description>Left Channel Zero Cross Detection Enable Bit\nIf this bit is set to 1, when left channel data sign bit changes or next shift data bits are all 0 then LZCF flag in I2SSTATUS register is set to 1. This function is only available in transmit operation.\n</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Left channel zero cross detection Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Left channel zero cross detection Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CLR_TXFIFO</name>
              <description>Clear Transmit FIFO\nWrite 1 to clear transmit FIFO, internal pointer is reset to FIFO start point, and TX_LEVEL[3:0] returns to 0 and transmit FIFO becomes empty but data in transmit FIFO is not changed. \nThis bit is cleared by hardware automatically. Returns 0 on read.</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CLR_RXFIFO</name>
              <description>Clear Receive FIFO\nWrite 1 to clear receive FIFO, internal pointer is reset to FIFO start point, and RX_LEVEL[3:0] returns 0 and receive FIFO becomes empty.\nThis bit is cleared by hardware automatically. Returns 0 on read.</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TXDMA</name>
              <description>Transmit DMA Enable Bit\nWhen TX DMA is enabled, I2S request DMA to transfer data from SRAM to transmit FIFO if FIFO is not full.\n</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>TX DMA Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>TX DMA Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RXDMA</name>
              <description>Receive DMA Enable Bit\nWhen RX DMA is enabled, I2S requests DMA to transfer data from receive FIFO to SRAM if FIFO is not empty.\n</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RX DMA Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RX DMA Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RXLCH</name>
              <description>Receive Left Channel Enable Bit\n</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Receive right channel data in Mono mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Receive left channel data in Mono mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>I2SCLKDIV</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>I2SCLKDIV</displayName>
          <description>I2S Clock Divider Control Register</description>
          <addressOffset>0x4</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MCLK_DIV</name>
              <description>Master Clock Divider\nIf MCLKEN is set to 1, I2S controller will generate master clock for external audio devices. The master clock rate, F_MCLK, is determined by the following expressions.\nF_I2SCLK is the frequency of I2S peripheral clock.\nIn general, the master clock rate is 256 times sampling clock rate.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>BCLK_DIV</name>
              <description>Bit Clock Divider\nThe I2S controller will generate bit clock in Master mode. The bit clock rate, F_BCLK, is determined by the following expression.\n</description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>I2SIE</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>I2SIE</displayName>
          <description>I2S Interrupt Enable Register</description>
          <addressOffset>0x8</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RXUDFIE</name>
              <description>Receive FIFO Underflow Interrupt Enable Bit\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RXOVFIE</name>
              <description>Receive FIFO Overflow Interrupt Enable Bit\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RXTHIE</name>
              <description>Receive FIFO Threshold Level Interrupt Enable Bit\nWhen the count of data words in receive FIFO is equal to or higher than RXTH (I2SCON[14:12]) and this bit is set to 1, receive FIFO threshold level interrupt will be asserted.\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TXUDFIE</name>
              <description>Transmit FIFO Underflow Interrupt Enable Bit\nInterrupt occurs if this bit is set to 1 and the transmit FIFO underflow flag is set to 1.\n</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TXOVFIE</name>
              <description>Transmit FIFO Overflow Interrupt Enable Bit\nInterrupt occurs if this bit is set to 1 and the transmit FIFO overflow flag is set to 1\n</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TXTHIE</name>
              <description>Transmit FIFO Threshold Level Interrupt Enable Bit\nInterrupt occurs if this bit is set to 1 and the count of data words in transmit FIFO is less than TXTH (I2SCON[11:9]).\n</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RZCIE</name>
              <description>Right Channel Zero-Cross Interrupt Enable Bit\nInterrupt occurs if this bit is set to 1 and right channel zero-cross event is detected.\n</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>LZCIE</name>
              <description>Left Channel Zero-Cross Interrupt Enable Bit\nInterrupt occurs if this bit is set to 1 and left channel zero-cross event is detected.\n</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>I2SSTATUS</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>I2SSTATUS</displayName>
          <description>I2S Status Register</description>
          <addressOffset>0xC</addressOffset>
          <access>read-write</access>
          <resetValue>0x00141000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>I2SINT</name>
              <description>I2S Interrupt Flag\nThis bit is wire-OR of I2STXINT and I2SRXINT bits.\nNote: This bit is read only.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No I2S interrupt</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>I2S interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>I2SRXINT</name>
              <description>I2S Receive Interrupt\nNote: This bit is read only.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No receive interrupt</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Receive interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>I2STXINT</name>
              <description>I2S Transmit Interrupt\nNote: This bit is read only.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No transmit interrupt</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Transmit interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RIGHT</name>
              <description>Right Channel\nThis bit indicates current transmit data is belong to which channel\nNote: This bit is read only.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Left channel</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Right channel</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RXUDF</name>
              <description>Receive FIFO Underflow Flag\nUnderflow event will occur if read the empty receive FIFO.\nNote: Write 1 to clear this bit to 0.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No underflow event occurred</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Underflow</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RXOVF</name>
              <description>Receive FIFO Overflow Flag\nWhen receive FIFO is full and hardware attempt to write data to receive FIFO, this bit will be set to 1, data in 1st buffer will be overwrote.\nNote: Write 1 to clear this bit to 0.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No overflow</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Overflow</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RXTHF</name>
              <description>Receive FIFO Threshold Flag\nWhen data word(s) in receive FIFO is equal to or larger than threshold value set in RXTH (I2SCON[14:12]). The RXTHF bit becomes to 1. It keeps at 1 till RX_LEVEL (I2SSTATUS[27:24]) is less than RXTH.\nNote: This bit is read only.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Data word(s) in FIFO is less than threshold level</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Data word(s) in FIFO is equal to or larger than threshold level</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RXFULL</name>
              <description>Receive FIFO Full\nThis bit reflects the count of data in receive FIFO is 8\nNote: This bit is read only.</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Not full</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Full</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RXEMPTY</name>
              <description>Receive FIFO Empty\nThis bit reflects the count of data in receive FIFO is 0\nNote: This bit is read only.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Not empty</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Empty</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TXUDF</name>
              <description>Transmit FIFO Underflow Flag\nIf transmit FIFO is empty and hardware reads data from transmit FIFO. This bit will be set to 1.\nNote: Software can write 1 to clear this bit to 0.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No underflow</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Underflow</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TXOVF</name>
              <description>Transmit FIFO Overflow Flag\nThis bit will be set to 1 if writes data to transmit FIFO when transmit FIFO is full.\nNote: Write 1 to clear this bit to 0.</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No overflow</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Overflow</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TXTHF</name>
              <description>Transmit FIFO Threshold Flag\nWhen the count of data stored in transmit-FIFO is equal to or less than threshold value set in TXTH (I2SCON[11:9]). The TXTHF bit becomes to 1. It keeps at 1 till TX_LEVEL (I2SSTATUS[31:28]) is larger than TXTH.\nNote: This bit is read only.</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Data word(s) in FIFO is larger than threshold level</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Data word(s) in FIFO is equal to or less than threshold level</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TXFULL</name>
              <description>Transmit FIFO Full\nThis bit reflects data word number in transmit FIFO is 8\nNote: This bit is read only.</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Not full</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Full</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TXEMPTY</name>
              <description>Transmit FIFO Empty\nThis bit reflects data word number in transmit FIFO is 0\nNote: This bit is read only.</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Not empty</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Empty</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TXBUSY</name>
              <description>Transmit Busy\nThis bit is cleared to 0 when all data in transmit FIFO and shift buffer is shifted out. And set to 1 when 1st data is load to shift buffer.\nNote: This bit is read only.</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Transmit shift buffer is empty</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Transmit shift buffer is not empty</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RZCF</name>
              <description>Right Channel Zero-Cross Flag\nIt indicates the sign bit of right channel sample data is changed or all data bits are 0.\nNote: Write 1 to clear this bit to 0.</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No zero-cross</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Right channel zero-cross event is detected</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>LZCF</name>
              <description>Left Channel Zero-Cross Flag\nIt indicates the sign bit of left channel sample data is changed or all data bits are 0.\nNote: Write 1 to clear this bit to 0.</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No zero-cross</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Left channel zero-cross event is detected</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_LEVEL</name>
              <description>Receive FIFO Level\nThese bits indicate word number in receive FIFO\n</description>
              <bitOffset>24</bitOffset>
              <bitWidth>4</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No data</description>
                    <value>#0000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>1 word in receive FIFO</description>
                    <value>#0001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>8</name>
                    <description>8 words in receive FIFO</description>
                    <value>#1000</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_LEVEL</name>
              <description>Transmit FIFO Level\nThese bits indicate word number in transmit FIFO\n</description>
              <bitOffset>28</bitOffset>
              <bitWidth>4</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No data</description>
                    <value>#0000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>1 word in transmit FIFO</description>
                    <value>#0001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>8</name>
                    <description>8 words in transmit FIFO</description>
                    <value>#1000</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>I2STXFIFO</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>I2STXFIFO</displayName>
          <description>I2S Transmit FIFO Register</description>
          <addressOffset>0x10</addressOffset>
          <access>write-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TXFIFO</name>
              <description>Transmit FIFO Register\nI2S contains 8 words (8x32 bits) data buffer for data transmit. Write data to this register to prepare data for transmission. The remaining word number is indicated by TX_LEVEL (I2SSTATUS[31:28])</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>I2SRXFIFO</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>I2SRXFIFO</displayName>
          <description>I2S Receive FIFO Register</description>
          <addressOffset>0x14</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RXFIFO</name>
              <description>Receive FIFO Register\nI2S contains 8 words (8x32 bits) data buffer for data receive. Read this register to get data of receive FIFO. The remaining data word number is indicated by RX_LEVEL (I2SSTATUS[27:24]).</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>USBD</name>
      <description>USB Register Map</description>
      <groupName>USB</groupName>
      <baseAddress>0x40060000</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x0</offset>
        <size>0x1C</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x90</offset>
        <size>0x4</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x500</offset>
        <size>0x80</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>USB_INTEN</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>USB_INTEN</displayName>
          <description>USB Interrupt Enable Register</description>
          <addressOffset>0x0</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BUS_IE</name>
              <description>Bus Event Interrupt Enable Bit\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>BUS event interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>BUS event interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>USB_IE</name>
              <description>USB Event Interrupt Enable Bit\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>USB event interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>USB event interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>FLDET_IE</name>
              <description>Floating Detection Interrupt Enable Bit\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Floating detection Interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Floating detection Interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>WAKEUP_IE</name>
              <description>USB Wake-Up Interrupt Enable Bit\n</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Wake-up Interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Wake-up Interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>WAKEUP_EN</name>
              <description>Wake-Up Function Enable Bit\n</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>USB wake-up function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>USB wake-up function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>INNAK_EN</name>
              <description>Active NAK Function And Its Status In IN Token\n</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>When device responds NAK after receiving IN token, IN NAK status will not be updated to USBD_EPSTS register, so that the USB interrupt event will not be asserted</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>IN NAK status will be updated to USBD_EPSTS register and the USB interrupt event will be asserted, when the device responds NAK after receiving IN token</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>USB_INTSTS</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>USB_INTSTS</displayName>
          <description>USB Interrupt Event Status Register</description>
          <addressOffset>0x4</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BUS_STS</name>
              <description>BUS Interrupt Status\nThe BUS event means that there is one of the suspense or the resume function in the bus.\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No BUS event occurred</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Bus event occurred; check USB_ATTR[3:0] to know which kind of bus event was occurred, cleared by write 1 to USB_INTSTS[0]</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>USB_STS</name>
              <description>USB Event Interrupt Status\nThe USB event includes the SETUP Token, IN Token, OUT ACK, ISO IN, or ISO OUT events in the bus.\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No USB event occurred</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>USB event occurred, check EPSTS0~7 to know which kind of USB event occurred. Cleared by write 1 to USB_INTSTS[1] or EPEVT0~7 and SETUP (USB_INTSTS[31])</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>FLDET_STS</name>
              <description>Floating Detection Interrupt Status\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>There is not attached/detached event in the USB</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>There is attached/detached event in the USB bus and it is cleared by write 1 to USB_INTSTS[2]</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>WAKEUP_STS</name>
              <description>Wake-Up Interrupt Status\n</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No Wake-up event occurred</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Wake-up event occurred, cleared by write 1 to USB_INTSTS[3]</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>EPEVT0</name>
              <description>Endpoint 0's USB Event Status\n</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No event occurred on endpoint 0</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>USB event occurred on Endpoint 0, check USB_EPSTS[10:8] to know which kind of USB event was occurred, cleared by write 1 to USB_INTSTS[16] or USB_INTSTS[1]</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>EPEVT1</name>
              <description>Endpoint 1's USB Event Status\n</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No event occurred on endpoint 1</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>USB event occurred on Endpoint 1, check USB_EPSTS[13:11] to know which kind of USB event was occurred, cleared by write 1 to USB_INTSTS[17] or USB_INTSTS[1]</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>EPEVT2</name>
              <description>Endpoint 2's USB Event Status\n</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No event occurred on endpoint 2</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>USB event occurred on Endpoint 2, check USB_EPSTS[16:14] to know which kind of USB event was occurred, cleared by write 1 to USB_INTSTS[18] or USB_INTSTS[1]</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>EPEVT3</name>
              <description>Endpoint 3's USB Event Status\n</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No event occurred on endpoint 3</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>USB event occurred on Endpoint 3, check USB_EPSTS[19:17] to know which kind of USB event was occurred, cleared by write 1 to USB_INTSTS[19] or USB_INTSTS[1]</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>EPEVT4</name>
              <description>Endpoint 4's USB Event Status\n</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No event occurred on endpoint 4</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>USB event occurred on Endpoint 4, check USB_EPSTS[22:20] to know which kind of USB event was occurred, cleared by write 1 to USB_INTSTS[20] or USB_INTSTS[1]</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>EPEVT5</name>
              <description>Endpoint 5's USB Event Status\n</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No event occurred on endpoint 5</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>USB event occurred on Endpoint 5, check USB_EPSTS[25:23] to know which kind of USB event was occurred, cleared by write 1 to USB_INTSTS[21] or USB_INTSTS[1]</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>EPEVT6</name>
              <description>Endpoint 6's USB Event Status\n</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No event occurred on endpoint 6</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>USB event occurred on Endpoint 6, check USB_EPSTS[28:26] to know which kind of USB event was occurred, cleared by write 1 to USB_INTSTS[22] or USB_INTSTS[1]</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>EPEVT7</name>
              <description>Endpoint 7's USB Event Status\n</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No event occurred on endpoint 7</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>USB event occurred on Endpoint 7, check USB_EPSTS[31:29] to know which kind of USB event was occurred, cleared by write 1 to USB_INTSTS[23] or USB_INTSTS[1]</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SETUP</name>
              <description>Setup Event Status\n</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No Setup event</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>SETUP event occurred, cleared by write 1 to USB_INTSTS[31]</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>USB_FADDR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>USB_FADDR</displayName>
          <description>USB Device Function Address Register</description>
          <addressOffset>0x8</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>FADDR</name>
              <description>USB Device Function Address</description>
              <bitOffset>0</bitOffset>
              <bitWidth>7</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>USB_EPSTS</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>USB_EPSTS</displayName>
          <description>USB Endpoint Status Register</description>
          <addressOffset>0xC</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>OVERRUN</name>
              <description>Overrun\nIt indicates that the received data is over the maximum payload number or not.\n</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No overrun</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Out Data is more than the Max Payload in MXPLD register or the Setup Data is more than 8 Bytes</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>EPSTS0</name>
              <description>Endpoint 0 Bus Status\nThese bits are used to indicate the current status of this endpoint\n</description>
              <bitOffset>8</bitOffset>
              <bitWidth>3</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>In ACK</description>
                    <value>#000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>In NAK</description>
                    <value>#001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Out Packet Data0 ACK</description>
                    <value>#010</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Setup ACK</description>
                    <value>#011</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>6</name>
                    <description>Out Packet Data1 ACK</description>
                    <value>#110</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>7</name>
                    <description>Isochronous transfer end</description>
                    <value>#111</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>EPSTS1</name>
              <description>Endpoint 1 Bus Status\nThese bits are used to indicate the current status of this endpoint\n</description>
              <bitOffset>11</bitOffset>
              <bitWidth>3</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>In ACK</description>
                    <value>#000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>In NAK</description>
                    <value>#001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Out Packet Data0 ACK</description>
                    <value>#010</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Setup ACK</description>
                    <value>#011</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>6</name>
                    <description>Out Packet Data1 ACK</description>
                    <value>#110</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>7</name>
                    <description>Isochronous transfer end</description>
                    <value>#111</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>EPSTS2</name>
              <description>Endpoint 2 Bus Status\nThese bits are used to indicate the current status of this endpoint\n</description>
              <bitOffset>14</bitOffset>
              <bitWidth>3</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>In ACK</description>
                    <value>#000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>In NAK</description>
                    <value>#001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Out Packet Data0 ACK</description>
                    <value>#010</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Setup ACK</description>
                    <value>#011</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>6</name>
                    <description>Out Packet Data1 ACK</description>
                    <value>#110</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>7</name>
                    <description>Isochronous transfer end</description>
                    <value>#111</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>EPSTS3</name>
              <description>Endpoint 3 Bus Status\nThese bits are used to indicate the current status of this endpoint\n</description>
              <bitOffset>17</bitOffset>
              <bitWidth>3</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>In ACK</description>
                    <value>#000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>In NAK</description>
                    <value>#001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Out Packet Data0 ACK</description>
                    <value>#010</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Setup ACK</description>
                    <value>#011</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>6</name>
                    <description>Out Packet Data1 ACK</description>
                    <value>#110</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>7</name>
                    <description>Isochronous transfer end</description>
                    <value>#111</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>EPSTS4</name>
              <description>Endpoint 4 Bus Status\nThese bits are used to indicate the current status of this endpoint\n</description>
              <bitOffset>20</bitOffset>
              <bitWidth>3</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>In ACK</description>
                    <value>#000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>In NAK</description>
                    <value>#001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Out Packet Data0 ACK</description>
                    <value>#010</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Setup ACK</description>
                    <value>#011</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>6</name>
                    <description>Out Packet Data1 ACK</description>
                    <value>#110</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>7</name>
                    <description>Isochronous transfer end</description>
                    <value>#111</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>EPSTS5</name>
              <description>Endpoint 5 Bus Status\nThese bits are used to indicate the current status of this endpoint\n</description>
              <bitOffset>23</bitOffset>
              <bitWidth>3</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>In ACK</description>
                    <value>#000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>In NAK</description>
                    <value>#001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Out Packet Data0 ACK</description>
                    <value>#010</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Setup ACK</description>
                    <value>#011</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>6</name>
                    <description>Out Packet Data1 ACK</description>
                    <value>#110</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>7</name>
                    <description>Isochronous transfer end</description>
                    <value>#111</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>EPSTS6</name>
              <description>Endpoint 6 Bus Status\nThese bits are used to indicate the current status of this endpoint\n</description>
              <bitOffset>26</bitOffset>
              <bitWidth>3</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>In ACK</description>
                    <value>#000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>In NAK</description>
                    <value>#001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Out Packet Data0 ACK</description>
                    <value>#010</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Setup ACK</description>
                    <value>#011</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>6</name>
                    <description>Out Packet Data1 ACK</description>
                    <value>#110</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>7</name>
                    <description>Isochronous transfer end</description>
                    <value>#111</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>EPSTS7</name>
              <description>Endpoint 7 Bus Status\nThese bits are used to indicate the current status of this endpoint\n</description>
              <bitOffset>29</bitOffset>
              <bitWidth>3</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>In ACK</description>
                    <value>#000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>In NAK</description>
                    <value>#001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Out Packet Data0 ACK</description>
                    <value>#010</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Setup ACK</description>
                    <value>#011</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>6</name>
                    <description>Out Packet Data1 ACK</description>
                    <value>#110</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>7</name>
                    <description>Isochronous transfer end</description>
                    <value>#111</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>USB_ATTR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>USB_ATTR</displayName>
          <description>USB Bus Status and Attribution Register</description>
          <addressOffset>0x10</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000040</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>USBRST</name>
              <description>USB Reset Status\nNote: This bit is read only.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Bus no reset</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Bus reset when SE0 (single-ended 0) is presented more than 2.5us</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SUSPEND</name>
              <description>Suspend Status\nNote: This bit is read only.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Bus no suspend</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Bus idle more than 3ms, either cable is plugged off or host is sleeping</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RESUME</name>
              <description>Resume Status\nNote: This bit is read only.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No bus resume</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Resume from suspend</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TIMEOUT</name>
              <description>Time-Out Status\nNote: This bit is read only.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No time-out</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>No Bus response more than 18 bits time</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PHY_EN</name>
              <description>PHY Transceiver Function Enable Bit\n</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PHY transceiver function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PHY transceiver function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RWAKEUP</name>
              <description>Remote Wake-Up\n</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Release the USB bus from K state</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Force USB bus to K (USB_D+ low, USB_D- high) state, used for remote wake-up</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>USB_EN</name>
              <description>USB Controller Enable Bit\n</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>USB Controller Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>USB Controller Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DPPU_EN</name>
              <description>Pull-Up Resistor On USB_D+ Enable Bit\n</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Pull-up resistor in USB_D+ pin Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Pull-up resistor in USB_D+ pin Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PWRDN</name>
              <description>Power-Down PHY Transceiver, Low Active\n</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Power-down related circuit of PHY transceiver</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Turn-on related circuit of PHY transceiver</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BYTEM</name>
              <description>CPU Access USB SRAM Size Mode Selection\n</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Word mode: The size of the transfer from CPU to USB SRAM can be Word only</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Byte mode: The size of the transfer from CPU to USB SRAM can be Byte only</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>USB_FLDET</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>USB_FLDET</displayName>
          <description>USB Floating Detection Register</description>
          <addressOffset>0x14</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>FLDET</name>
              <description>Device Floating Detected\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Controller is not attached into the USB host</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Controller is attached into the BUS</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>USB_STBUFSEG</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>USB_STBUFSEG</displayName>
          <description>Setup Token Buffer Segmentation Register</description>
          <addressOffset>0x18</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>STBUFSEG</name>
              <description>Setup Token Buffer Segmentation\nIt is used to indicate the offset address for the SETUP token with the USB Device SRAM starting address The effective starting address is\nUSB_SRAM address + {STBUFSEG[8:3], 3'b000} \nNote: It is used for SETUP token only.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>USB_DRVSE0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>USB_DRVSE0</displayName>
          <description>USB Drive SE0 Control Register</description>
          <addressOffset>0x90</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000001</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DRVSE0</name>
              <description>Drive Single Ended Zero In USB Bus\nThe Single Ended Zero (SE0) is when both lines (USB_D+ and USB_D-) are being pulled low.\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>None</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Force USB PHY transceiver to drive SE0</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>USB_BUFSEG0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>USB_BUFSEG0</displayName>
          <description>Endpoint 0 Buffer Segmentation Register</description>
          <addressOffset>0x500</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BUFSEG</name>
              <description>Endpoint Buffer Segmentation\nIt is used to indicate the offset address for each endpoint with the USB SRAM starting address The effective starting address of the endpoint is\nUSB_SRAM address + { BUFSEG[8:3], 3'b000}\nRefer to the section 5.4.4.7 for the endpoint SRAM structure and its description.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>USB_MXPLD0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>USB_MXPLD0</displayName>
          <description>Endpoint 0 Maximal Payload Register</description>
          <addressOffset>0x504</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MXPLD</name>
              <description>Maximal Payload\nDefine the data length which is transmitted to host (IN token) or the actual data length which is received from the host (OUT token). It also used to indicate that the endpoint is ready to be transmitted in IN token or received in OUT token.\n(1) When the register is written by CPU, \nFor IN token, the value of MXPLD is used to define the data length to be transmitted and indicate the data buffer is ready.\nFor OUT token, it means that the controller is ready to receive data from the host and the value of MXPLD is the maximal data length comes from host.\n(2) When the register is read by CPU,\nFor IN token, the value of MXPLD is indicated by the data length be transmitted to host\nFor OUT token, the value of MXPLD is indicated the actual data length receiving from host.\nNote: Once MXPLD is written, the data packets will be transmitted/received immediately after IN/OUT token arrived.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>9</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>USB_CFG0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>USB_CFG0</displayName>
          <description>Endpoint 0 Configuration Register</description>
          <addressOffset>0x508</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>EP_NUM</name>
              <description>Endpoint Number\nThese bits are used to define the endpoint number of the current endpoint.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ISOCH</name>
              <description>Isochronous Endpoint\nThis bit is used to set the endpoint as Isochronous endpoint, no handshake.\n</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No Isochronous endpoint</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Isochronous endpoint</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>STATE</name>
              <description>Endpoint STATE\n</description>
              <bitOffset>5</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Endpoint is Disabled</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Out endpoint</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>IN endpoint</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Undefined</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DSQ_SYNC</name>
              <description>Data Sequence Synchronization\nNote: It is used to specify the DATA0 or DATA1 PID in the following IN token transaction. Hardware will toggle automatically in IN token base on the bit.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>DATA0 PID</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>DATA1 PID</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CSTALL</name>
              <description>Clear STALL Response\n</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disable the device to clear the STALL handshake in setup stage</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Clear the device to response STALL handshake in setup stage</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>USB_CFGP0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>USB_CFGP0</displayName>
          <description>Endpoint 0 Set Stall and Clear In/Out Ready Control Register</description>
          <addressOffset>0x50C</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CLRRDY</name>
              <description>Clear Ready\nWhen the USB_MXPLD register is set by user, it means that the endpoint is ready to transmit or receive data. If the user wants to disable this transaction before the transaction start, users can set this bit to 1 to turn it off and it will be cleared to 0 automatically.\nFor IN token, write '1' to clear the IN token had ready to transmit the data to USB.\nFor OUT token, write '1' to clear the OUT token had ready to receive the data from USB.\nThis bit is write 1 only and is always 0 when it is read back.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SSTALL</name>
              <description>Set STALL\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disable the device to response STALL</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Set the device to respond STALL automatically</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="USB_BUFSEG0">
          <name>USB_BUFSEG1</name>
          <displayName>USB_BUFSEG1</displayName>
          <description>Endpoint 1 Buffer Segmentation Register</description>
          <addressOffset>0x510</addressOffset>
       </register>
       <register derivedFrom="USB_MXPLD0">
          <name>USB_MXPLD1</name>
          <displayName>USB_MXPLD1</displayName>
          <description>Endpoint 1 Maximal Payload Register</description>
          <addressOffset>0x514</addressOffset>
       </register>
       <register derivedFrom="USB_CFG0">
          <name>USB_CFG1</name>
          <displayName>USB_CFG1</displayName>
          <description>Endpoint 1 Configuration Register</description>
          <addressOffset>0x518</addressOffset>
       </register>
       <register derivedFrom="USB_CFGP0">
          <name>USB_CFGP1</name>
          <displayName>USB_CFGP1</displayName>
          <description>Endpoint 1 Set Stall and Clear In/Out Ready Control Register</description>
          <addressOffset>0x51C</addressOffset>
       </register>
       <register derivedFrom="USB_BUFSEG0">
          <name>USB_BUFSEG2</name>
          <displayName>USB_BUFSEG2</displayName>
          <description>Endpoint 2 Buffer Segmentation Register</description>
          <addressOffset>0x520</addressOffset>
       </register>
       <register derivedFrom="USB_MXPLD0">
          <name>USB_MXPLD2</name>
          <displayName>USB_MXPLD2</displayName>
          <description>Endpoint 2 Maximal Payload Register</description>
          <addressOffset>0x524</addressOffset>
       </register>
       <register derivedFrom="USB_CFG0">
          <name>USB_CFG2</name>
          <displayName>USB_CFG2</displayName>
          <description>Endpoint 2 Configuration Register</description>
          <addressOffset>0x528</addressOffset>
       </register>
       <register derivedFrom="USB_CFGP0">
          <name>USB_CFGP2</name>
          <displayName>USB_CFGP2</displayName>
          <description>Endpoint 2 Set Stall and Clear In/Out Ready Control Register</description>
          <addressOffset>0x52C</addressOffset>
       </register>
       <register derivedFrom="USB_BUFSEG0">
          <name>USB_BUFSEG3</name>
          <displayName>USB_BUFSEG3</displayName>
          <description>Endpoint 3 Buffer Segmentation Register</description>
          <addressOffset>0x530</addressOffset>
       </register>
       <register derivedFrom="USB_MXPLD0">
          <name>USB_MXPLD3</name>
          <displayName>USB_MXPLD3</displayName>
          <description>Endpoint 3 Maximal Payload Register</description>
          <addressOffset>0x534</addressOffset>
       </register>
       <register derivedFrom="USB_CFG0">
          <name>USB_CFG3</name>
          <displayName>USB_CFG3</displayName>
          <description>Endpoint 3 Configuration Register</description>
          <addressOffset>0x538</addressOffset>
       </register>
       <register derivedFrom="USB_CFGP0">
          <name>USB_CFGP3</name>
          <displayName>USB_CFGP3</displayName>
          <description>Endpoint 3 Set Stall and Clear In/Out Ready Control Register</description>
          <addressOffset>0x53C</addressOffset>
       </register>
       <register derivedFrom="USB_BUFSEG0">
          <name>USB_BUFSEG4</name>
          <displayName>USB_BUFSEG4</displayName>
          <description>Endpoint 4 Buffer Segmentation Register</description>
          <addressOffset>0x540</addressOffset>
       </register>
       <register derivedFrom="USB_MXPLD0">
          <name>USB_MXPLD4</name>
          <displayName>USB_MXPLD4</displayName>
          <description>Endpoint 4 Maximal Payload Register</description>
          <addressOffset>0x544</addressOffset>
       </register>
       <register derivedFrom="USB_CFG0">
          <name>USB_CFG4</name>
          <displayName>USB_CFG4</displayName>
          <description>Endpoint 4 Configuration Register</description>
          <addressOffset>0x548</addressOffset>
       </register>
       <register derivedFrom="USB_CFGP0">
          <name>USB_CFGP4</name>
          <displayName>USB_CFGP4</displayName>
          <description>Endpoint 4 Set Stall and Clear In/Out Ready Control Register</description>
          <addressOffset>0x54C</addressOffset>
       </register>
       <register derivedFrom="USB_BUFSEG0">
          <name>USB_BUFSEG5</name>
          <displayName>USB_BUFSEG5</displayName>
          <description>Endpoint 5 Buffer Segmentation Register</description>
          <addressOffset>0x550</addressOffset>
       </register>
       <register derivedFrom="USB_MXPLD0">
          <name>USB_MXPLD5</name>
          <displayName>USB_MXPLD5</displayName>
          <description>Endpoint 5 Maximal Payload Register</description>
          <addressOffset>0x554</addressOffset>
       </register>
       <register derivedFrom="USB_CFG0">
          <name>USB_CFG5</name>
          <displayName>USB_CFG5</displayName>
          <description>Endpoint 5 Configuration Register</description>
          <addressOffset>0x558</addressOffset>
       </register>
       <register derivedFrom="USB_CFGP0">
          <name>USB_CFGP5</name>
          <displayName>USB_CFGP5</displayName>
          <description>Endpoint 5 Set Stall and Clear In/Out Ready Control Register</description>
          <addressOffset>0x55C</addressOffset>
       </register>
       <register derivedFrom="USB_BUFSEG0">
          <name>USB_BUFSEG6</name>
          <displayName>USB_BUFSEG6</displayName>
          <description>Endpoint 6 Buffer Segmentation Register</description>
          <addressOffset>0x560</addressOffset>
       </register>
       <register derivedFrom="USB_MXPLD0">
          <name>USB_MXPLD6</name>
          <displayName>USB_MXPLD6</displayName>
          <description>Endpoint 6 Maximal Payload Register</description>
          <addressOffset>0x564</addressOffset>
       </register>
       <register derivedFrom="USB_CFG0">
          <name>USB_CFG6</name>
          <displayName>USB_CFG6</displayName>
          <description>Endpoint 6 Configuration Register</description>
          <addressOffset>0x568</addressOffset>
       </register>
       <register derivedFrom="USB_CFGP0">
          <name>USB_CFGP6</name>
          <displayName>USB_CFGP6</displayName>
          <description>Endpoint 6 Set Stall and Clear In/Out Ready Control Register</description>
          <addressOffset>0x56C</addressOffset>
       </register>
       <register derivedFrom="USB_BUFSEG0">
          <name>USB_BUFSEG7</name>
          <displayName>USB_BUFSEG7</displayName>
          <description>Endpoint 7 Buffer Segmentation Register</description>
          <addressOffset>0x570</addressOffset>
       </register>
       <register derivedFrom="USB_MXPLD0">
          <name>USB_MXPLD7</name>
          <displayName>USB_MXPLD7</displayName>
          <description>Endpoint 7 Maximal Payload Register</description>
          <addressOffset>0x574</addressOffset>
       </register>
       <register derivedFrom="USB_CFG0">
          <name>USB_CFG7</name>
          <displayName>USB_CFG7</displayName>
          <description>Endpoint 7 Configuration Register</description>
          <addressOffset>0x578</addressOffset>
       </register>
       <register derivedFrom="USB_CFGP0">
          <name>USB_CFGP7</name>
          <displayName>USB_CFGP7</displayName>
          <description>Endpoint 7 Set Stall and Clear In/Out Ready Control Register</description>
          <addressOffset>0x57C</addressOffset>
       </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>CAN0</name>
      <description>CAN Register Map</description>
      <groupName>CAN</groupName>
      <baseAddress>0x40180000</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x0</offset>
        <size>0x1C</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x20</offset>
        <size>0x2C</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x80</offset>
        <size>0x2C</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x100</offset>
        <size>0x8</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x120</offset>
        <size>0x8</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x140</offset>
        <size>0x8</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x160</offset>
        <size>0x10</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>CAN_CON</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CAN_CON</displayName>
          <description>Control Register</description>
          <addressOffset>0x0</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000001</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>Init</name>
              <description>Init Initialization\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Normal Operation</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Initialization is started</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IE</name>
              <description>Module Interrupt Enable Bit\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SIE</name>
              <description>Status Change Interrupt Enable Bit\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disabled - No Status Change Interrupt will be generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enabled - An interrupt will be generated when a message transfer is successfully completed or a CAN bus error is detected</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>EIE</name>
              <description>Error Interrupt Enable Bit\n</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disabled - No Error Status Interrupt will be generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enabled - A change in the bits BOff (CAN_STATUS[7]) or EWarn (CAN_STATUS[6]) in the Status Register will generate an interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DAR</name>
              <description>Automatic Re-Transmission Disable Bit\n</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Automatic Retransmission of disturbed messages enabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Automatic Retransmission disabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CCE</name>
              <description>Configuration Change Enable Bit\n</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No write access to the Bit Timing Register</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Write access to the Bit Timing Register (CAN_BTIME) allowed. (while Init bit (CAN_CON[0]) = 1)</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>Test</name>
              <description>Test Mode Enable Bit\n</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Normal Operation</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Test Mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CAN_STATUS</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CAN_STATUS</displayName>
          <description>Status Register</description>
          <addressOffset>0x4</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>LEC</name>
              <description>Last Error Code (Type Of The Last Error To Occur On The CAN Bus)\nThe LEC field holds a code, which indicates the type of the last error to occur on the CAN bus. This field will be cleared to '0' when a message has been transferred (reception or transmission) without error. The unused code '7' may be written by the CPU to check for updates. The following table describes the error code.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TxOK</name>
              <description>Transmitted A Message Successfully\n</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Since this bit was reset by the CPU, no message has been successfully transmitted. This bit is never reset by the CAN Core</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Since this bit was last reset by the CPU, a message has been successfully (error free and acknowledged by at least one other node) transmitted</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RxOK</name>
              <description>Received A Message Successfully\n</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No message has been successfully received since this bit was last reset by the CPU. This bit is never reset by the CAN Core</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>A message has been successfully received since this bit was last reset by the CPU (independent of the result of acceptance filtering)</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>EPass</name>
              <description>Error Passive (Read Only)\n</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The CAN Core is error active</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The CAN Core is in the error passive state as defined in the CAN Specification</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>EWarn</name>
              <description>Error Warning Status (Read Only)\n</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Both error counters are below the error warning limit of 96</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>At least one of the error counters in the EML has reached the error warning limit of 96</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>BOff</name>
              <description>Bus-Off Status (Read Only) \n</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The CAN module is not in bus-off state</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The CAN module is in bus-off state</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CAN_ERR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CAN_ERR</displayName>
          <description>Error Counter Register</description>
          <addressOffset>0x8</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TEC</name>
              <description>Transmit Error Counter\nActual state of the Transmit Error Counter. Values between 0 and 255.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>REC</name>
              <description>Receive Error Counter\nActual state of the Receive Error Counter. Values between 0 and 127.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>7</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RP</name>
              <description>Receive Error Passive\n</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The Receive Error Counter is below the error passive level</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The Receive Error Counter has reached the error passive level as defined in the CAN Specification</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CAN_BTIME</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CAN_BTIME</displayName>
          <description>Bit Timing Register</description>
          <addressOffset>0xC</addressOffset>
          <access>read-write</access>
          <resetValue>0x00002301</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BRP</name>
              <description>Baud Rate Prescaler \n0x01-0x3F: The value by which the oscillator frequency is divided for generating the bit time quanta. The bit time is built up from a multiple of this quanta. Valid values for the Baud Rate Prescaler are [ 0 ... 63 ]. The actual interpretation by the hardware of this value is such that one more than the value programmed here is used.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SJW</name>
              <description>(Re)Synchronization Jump Width\n0x0-0x3: Valid programmed values are [0 ... 3]. The actual interpretation by the hardware of this value is such that one more than the value programmed here is used.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TSeg1</name>
              <description>Time Segment Before The Sample Point Minus Sync_Seg\n0x01-0x0F: valid values for TSeg1 are [1 ... 15]. The actual interpretation by the hardware of this value is such that one more than the value programmed is used.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TSeg2</name>
              <description>Time Segment After Sample Point \n0x0-0x7: Valid values for TSeg2 are [0 ... 7]. The actual interpretation by the hardware of this value is such that one more than the value programmed here is used.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CAN_IIDR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CAN_IIDR</displayName>
          <description>Interrupt Identifier Register</description>
          <addressOffset>0x10</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>IntId</name>
              <description>Interrupt Identifier (Indicates The Source Of The Interrupt)\nIf several interrupts are pending, the CAN Interrupt Register will point to the pending interrupt with the highest priority, disregarding their chronological order. An interrupt remains pending until the application software has cleared it. If IntId is different from 0x0000 and IE (CAN_IFn_MCON[1]) is set, the IRQ interrupt signal to the EIC is active. The interrupt remains active until IntId is back to value 0x0000 (the cause of the interrupt is reset) or until IE is reset.\nThe Status Interrupt has the highest priority. Among the message interrupts, the Message Object' s interrupt priority decreases with increasing message number.\nA message interrupt is cleared by clearing the Message Object's IntPnd bit (CAN_IFn_MCON[13]). The Status Interrupt is cleared by reading the Status Register.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CAN_TEST</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CAN_TEST</displayName>
          <description>Test Register (Register Map Note 1)</description>
          <addressOffset>0x14</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000080</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>Res</name>
              <description>Reserved\nThere are reserved bits.\nThese bits are always read as '0' and must always be written with '0'.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>Basic</name>
              <description>Basic Mode\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Basic Mode disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>IF1 Registers used as Tx Buffer, IF2 Registers used as Rx Buffer</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>Silent</name>
              <description>Silent Mode\n</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Normal operation</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The module is in Silent Mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>LBack</name>
              <description>Loop Back Mode Enable Bit\n</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Loop Back Mode is disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Loop Back Mode is enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>Tx</name>
              <description>Tx[1:0]: Control Of CAN_TX Pin\n</description>
              <bitOffset>5</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Reset value, CAN_TX pin is controlled by the CAN Core</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Sample Point can be monitored at CAN_TX pin</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>CAN_TX pin drives a dominant ('0') value</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>CAN_TX pin drives a recessive ('1') value</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>Rx</name>
              <description>Monitors The Actual Value Of CAN_RX Pin (Read Only) \n</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The CAN bus is dominant (CAN_RX = '0')</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The CAN bus is recessive (CAN_RX = '1')</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CAN_BRPE</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CAN_BRPE</displayName>
          <description>Baud Rate Prescaler Extension Register</description>
          <addressOffset>0x18</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BRPE</name>
              <description>BRPE: Baud Rate Prescaler Extension\n0x00-0x0F: By programming BRPE, the Baud Rate Prescaler can be extended to values up to 1023. The actual interpretation by the hardware is that one more than the value programmed by BRPE (MSBs) and BTIME (LSBs) is used.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CAN_IF1_CREQ</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CAN_IF1_CREQ</displayName>
          <description>IFn (Register Map Note 2) Command Request Registers</description>
          <addressOffset>0x20</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000001</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MessageNumber</name>
              <description>Message Number\n0x01-0x20: Valid Message Number, the Message Object in the Message\nRAM is selected for data transfer.\n0x00: Not a valid Message Number, interpreted as 0x20.\n0x21-0x3F: Not a valid Message Number, interpreted as 0x01-0x1F.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>Busy</name>
              <description>Busy Flag\n</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Read/write action has finished</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Writing to the IFn Command Request Register is in progress. This bit can only be read by the software</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CAN_IF1_CMASK</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CAN_IF1_CMASK</displayName>
          <description>IFn Command Mask Register</description>
          <addressOffset>0x24</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DAT_B</name>
              <description>Access Data Bytes [7:4]\nWrite Operation: \n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Data Bytes [7:4] unchanged</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Transfer Data Bytes [7:4] to Message Object.\nTransfer Data Bytes [7:4] to IFn Message Buffer Register</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DAT_A</name>
              <description>Access Data Bytes [3:0]\nWrite Operation:\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Data Bytes [3:0] unchanged</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Transfer Data Bytes [3:0] to Message Object.\nTransfer Data Bytes [3:0] to IFn Message Buffer Register</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TxRqst_NewDat</name>
              <description>Access Transmission Request Bit When Write Operation\nNote: A read access to a Message Object can be combined with the reset of the control bits IntPnd and NewDat. The values of these bits transferred to the IFn Message Control Register always reflect the status before resetting these bits.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>TxRqst bit unchanged.\nNewDat bit remains unchanged</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Set TxRqst bit.\nClear NewDat bit in the Message Object</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ClrIntPnd</name>
              <description>Clear Interrupt Pending Bit\nWrite Operation:\nWhen writing to a Message Object, this bit is ignored.\nRead Operation:\n</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>IntPnd bit (CAN_IFn_MCON[13]) remains unchanged</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Clear IntPnd bit in the Message Object</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>Control</name>
              <description>Control Access Control Bits\nWrite Operation:\n</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Control Bits unchanged</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Transfer Control Bits to Message Object.\nTransfer Control Bits to IFn Message Buffer Register</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>Arb</name>
              <description>Access Arbitration Bits\nWrite Operation:\n</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Arbitration bits unchanged</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Transfer Identifier + Dir (CAN_IFn_ARB2[13]) + Xtd (CAN_IFn_ARB2[14]) + MsgVal (CAN_IFn_ARB2[15]) to Message Object.\nTransfer Identifier + Dir + Xtd + MsgVal to IFn Message Buffer Register</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>Mask</name>
              <description>Access Mask Bits\nWrite Operation:\n</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Mask bits unchanged</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Transfer Identifier Mask + MDir + MXtd to Message Object.\nTransfer Identifier Mask + MDir + MXtd to IFn Message Buffer Register</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>WR_RD</name>
              <description>Write / Read Mode\n</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Read: Transfer data from the Message Object addressed by the Command Request Register into the selected Message Buffer Registers</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Write: Transfer data from the selected Message Buffer Registers to the Message Object addressed by the Command Request Register</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CAN_IF1_MASK1</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CAN_IF1_MASK1</displayName>
          <description>IFn Mask 1 Register</description>
          <addressOffset>0x28</addressOffset>
          <access>read-write</access>
          <resetValue>0x0000FFFF</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>Msk</name>
              <description>Identifier Mask 15-0\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The corresponding bit in the identifier of the message object cannot inhibit the match in the acceptance filtering</description>
                    <value>0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The corresponding identifier bit is used for acceptance filtering</description>
                    <value>1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CAN_IF1_MASK2</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CAN_IF1_MASK2</displayName>
          <description>IFn Mask 2 Register</description>
          <addressOffset>0x2C</addressOffset>
          <access>read-write</access>
          <resetValue>0x0000FFFF</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>Msk</name>
              <description>Identifier Mask 28-16\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>13</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The corresponding bit in the identifier of the message object cannot inhibit the match in the acceptance filtering</description>
                    <value>0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The corresponding identifier bit is used for acceptance filtering</description>
                    <value>1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>MDir</name>
              <description>Mask Message Direction\n</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The message direction bit (Dir (CAN_IFn_ARB2[13])) has no effect on the acceptance filtering</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The message direction bit (Dir) is used for acceptance filtering</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>MXtd</name>
              <description>Mask Extended Identifier\nNote: When 11-bit  ("standard")  Identifiers  are  used  for  a  Message Object, the identifiers of received Data Frames are written into bits ID28 to ID18 (CAN_IFn_ARB2[12:2]). For acceptance filtering, only these bits together with mask bits Msk28 to Msk18 (CAN_IFn_MASK2[12:2]) are considered.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The extended identifier bit (IDE) has no effect on the acceptance filtering</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The extended identifier bit (IDE) is used for acceptance filtering</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CAN_IF1_ARB1</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CAN_IF1_ARB1</displayName>
          <description>IFn Arbitration 1 Register</description>
          <addressOffset>0x30</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ID</name>
              <description>Message Identifier 15-0\nID28 - ID0, 29-bit Identifier ("Extended Frame").\nID28 - ID18, 11-bit Identifier ("Standard Frame")</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CAN_IF1_ARB2</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CAN_IF1_ARB2</displayName>
          <description>IFn Arbitration 2 Register</description>
          <addressOffset>0x34</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ID</name>
              <description>Message Identifier 28-16\nID28 - ID0, 29-bit Identifier ("Extended Frame").\nID28 - ID18, 11-bit Identifier ("Standard Frame")</description>
              <bitOffset>0</bitOffset>
              <bitWidth>13</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>Dir</name>
              <description>Message Direction\n</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Direction is receive</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Direction is transmit</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>Xtd</name>
              <description>Extended Identifier\n</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The 11-bit ("standard") Identifier will be used for this Message Object</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The 29-bit ("extended") Identifier will be used for this Message Object</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>MsgVal</name>
              <description>Message Valid\nNote: The application software must reset the MsgVal bit of all unused Messages Objects during the initialization before it resets bit Init (CAN_CON[0]). This bit must also be reset before the identifier Id28-0 (CAN_IFn_ARB1/2), the control bits Xtd (CAN_IFn_ARB2[14]), Dir (CAN_IFn_ARB2[13]), or the Data Length Code DLC3-0 (CAN_IFn_MCON[3:0]) are modified,  or if the Messages  Object  is no longer required.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The Message Object is ignored by the Message Handler</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The Message Object is configured and should be considered by the Message Handler</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CAN_IF1_MCON</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CAN_IF1_MCON</displayName>
          <description>IFn Message Control Register</description>
          <addressOffset>0x38</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DLC</name>
              <description>Data Length Code\n0-8: Data Frame has 0-8 data bytes.\n9-15: Data Frame has 8 data bytes\nNote: The Data Length Code of a Message Object must be defined the same as in all the corresponding objects with the same identifier at other nodes. When the Message Handler stores a data frame, it will write the DLC to the value given by the received message.\nData 0: 1st data byte of a CAN Data Frame\nData 1: 2nd data byte of a CAN Data Frame\nData 2: 3rd data byte of a CAN Data Frame\nData 3: 4th data byte of a CAN Data Frame\nData 4: 5th data byte of a CAN Data Frame\nData 5: 6th data byte of a CAN Data Frame\nData 6: 7th data byte of a CAN Data Frame\nData 7 : 8th data byte of a CAN Data Frame\nNote: The Data 0 Byte is the first data byte shifted into the shift register of the CAN Core during a reception while the Data 7 byte is the last. When the Message Handler stores a Data Frame, it will write all the eight data bytes into a Message Object. I	f the Data Length Code is less than 8, the remaining bytes of the Message Object will be overwritten by unspecified values.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EoB</name>
              <description>End Of Buffer\nNote: This bit is used to concatenate two or more Message Objects (up to 32) to build a FIFO Buffer. For single Message Objects (not belonging to a FIFO Buffer), this bit must always be set to one.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Message Object belongs to a FIFO Buffer and is not the last Message Object of that FIFO Buffer</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Single Message Object or last Message Object of a FIFO Buffer</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TxRqst</name>
              <description>Transmit Request\n</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>This Message Object is not waiting for transmission</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The transmission of this Message Object is requested and is not yet done</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RmtEn</name>
              <description>Remote Enable Bit\n</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>At the reception of a Remote Frame, TxRqst (CAN_IFn_MCON[8]) is left unchanged</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>At the reception of a Remote Frame, TxRqst is set</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RxIE</name>
              <description>Receive Interrupt Enable Bit\n</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>IntPnd (CAN_IFn_MCON[13]) will be left unchanged after a successful reception of a frame</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>IntPnd will be set after a successful reception of a frame</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TxIE</name>
              <description>Transmit Interrupt Enable Bit\n</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>IntPnd (CAN_IFn_MCON[13]) will be left unchanged after the successful transmission of a frame</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>IntPnd will be set after a successful transmission of a frame</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>UMask</name>
              <description>Use Acceptance Mask\nNote: If the UMask bit is set to one, the Message Object's mask bits have  to  be  programmed  during  initialization  of  the  Message Object before MsgVal bit (CAN_IFn_ARB2[15]) is set to one.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Mask ignored</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Use Mask (Msk28-0, MXtd, and MDir) for acceptance filtering</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IntPnd</name>
              <description>Interrupt Pending\n</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>This message object is not the source of an interrupt</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>This message object is the source of an interrupt. The Interrupt Identifier in the Interrupt Register will point to this message object if there is no other interrupt source with higher priority</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>MsgLst</name>
              <description></description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No message lost since last time this bit was reset by the CPU</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The Message Handler stored a new message into this object when NewDat was still set, the CPU has lost a message</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>NewDat</name>
              <description>New Data\n</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No new data has been written into the data portion of this Message Object by the Message Handler since last time this flag was cleared by the application software</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The Message Handler or the application software has written new data into the data portion of this Message Object</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CAN_IF1_DAT_A1</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CAN_IF1_DAT_A1</displayName>
          <description>IFn Data A1 Register (Register Map Note 3)</description>
          <addressOffset>0x3C</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>Data0</name>
              <description>Data Byte 0\n1st data byte of a CAN Data Frame</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>Data1</name>
              <description>Data Byte 1\n2nd data byte of a CAN Data Frame</description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CAN_IF1_DAT_A2</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CAN_IF1_DAT_A2</displayName>
          <description>IFn Data A2 Register (Register Map Note 3)</description>
          <addressOffset>0x40</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>Data2</name>
              <description>Data Byte 2\n3rd data byte of CAN Data Frame</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>Data3</name>
              <description>Data Byte 3\n4th data byte of CAN Data Frame</description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CAN_IF1_DAT_B1</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CAN_IF1_DAT_B1</displayName>
          <description>IFn Data B1 Register (Register Map Note 3)</description>
          <addressOffset>0x44</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>Data4</name>
              <description>Data Byte 4\n5th data byte of CAN Data Frame</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>Data5</name>
              <description>Data Byte 5\n6th data byte of CAN Data Frame</description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CAN_IF1_DAT_B2</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CAN_IF1_DAT_B2</displayName>
          <description>IFn Data B2 Register (Register Map Note 3)</description>
          <addressOffset>0x48</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>Data6</name>
              <description>Data Byte 6\n7th data byte of CAN Data Frame.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>Data7</name>
              <description>Data Byte 7\n8th data byte of CAN Data Frame.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="CAN_IF1_CREQ">
          <name>CAN_IF2_CREQ</name>
          <displayName>CAN_IF2_CREQ</displayName>
          <description>IFn (Register Map Note 2) Command Request Registers</description>
          <addressOffset>0x80</addressOffset>
       </register>
       <register derivedFrom="CAN_IF1_CMASK">
          <name>CAN_IF2_CMASK</name>
          <displayName>CAN_IF2_CMASK</displayName>
          <description>IFn Command Mask Register</description>
          <addressOffset>0x84</addressOffset>
       </register>
       <register derivedFrom="CAN_IF1_MASK1">
          <name>CAN_IF2_MASK1</name>
          <displayName>CAN_IF2_MASK1</displayName>
          <description>IFn Mask 1 Register</description>
          <addressOffset>0x88</addressOffset>
       </register>
       <register derivedFrom="CAN_IF1_MASK2">
          <name>CAN_IF2_MASK2</name>
          <displayName>CAN_IF2_MASK2</displayName>
          <description>IFn Mask 2 Register</description>
          <addressOffset>0x8C</addressOffset>
       </register>
       <register derivedFrom="CAN_IF1_ARB1">
          <name>CAN_IF2_ARB1</name>
          <displayName>CAN_IF2_ARB1</displayName>
          <description>IFn Arbitration 1 Register</description>
          <addressOffset>0x90</addressOffset>
       </register>
       <register derivedFrom="CAN_IF1_ARB2">
          <name>CAN_IF2_ARB2</name>
          <displayName>CAN_IF2_ARB2</displayName>
          <description>IFn Arbitration 2 Register</description>
          <addressOffset>0x94</addressOffset>
       </register>
       <register derivedFrom="CAN_IF1_MCON">
          <name>CAN_IF2_MCON</name>
          <displayName>CAN_IF2_MCON</displayName>
          <description>IFn Message Control Register</description>
          <addressOffset>0x98</addressOffset>
       </register>
       <register derivedFrom="CAN_IF1_DAT_A1">
          <name>CAN_IF2_DAT_A1</name>
          <displayName>CAN_IF2_DAT_A1</displayName>
          <description>IFn Data A1 Register (Register Map Note 3)</description>
          <addressOffset>0x9C</addressOffset>
       </register>
       <register derivedFrom="CAN_IF1_DAT_A2">
          <name>CAN_IF2_DAT_A2</name>
          <displayName>CAN_IF2_DAT_A2</displayName>
          <description>IFn Data A2 Register (Register Map Note 3)</description>
          <addressOffset>0xA0</addressOffset>
       </register>
       <register derivedFrom="CAN_IF1_DAT_B1">
          <name>CAN_IF2_DAT_B1</name>
          <displayName>CAN_IF2_DAT_B1</displayName>
          <description>IFn Data B1 Register (Register Map Note 3)</description>
          <addressOffset>0xA4</addressOffset>
       </register>
       <register derivedFrom="CAN_IF1_DAT_B2">
          <name>CAN_IF2_DAT_B2</name>
          <displayName>CAN_IF2_DAT_B2</displayName>
          <description>IFn Data B2 Register (Register Map Note 3)</description>
          <addressOffset>0xA8</addressOffset>
       </register>
       <register>
          <name>CAN_TXREQ1</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CAN_TXREQ1</displayName>
          <description>Transmission Request Register 1</description>
          <addressOffset>0x100</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TxRqst16_1</name>
              <description>Transmission Request Bits 16-1 (Of All Message Objects)\nThese bits are read only.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>This Message Object is not waiting for transmission</description>
                    <value>0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The transmission of this Message Object is requested and is not yet done</description>
                    <value>1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CAN_TXREQ2</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CAN_TXREQ2</displayName>
          <description>Transmission Request Register 2</description>
          <addressOffset>0x104</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TxRqst32_17</name>
              <description>Transmission Request Bits 32-17 (Of All Message Objects)\nThese bits are read only.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>This Message Object is not waiting for transmission</description>
                    <value>0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The transmission of this Message Object is requested and is not yet done</description>
                    <value>1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CAN_NDAT1</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CAN_NDAT1</displayName>
          <description>New Data Register 1</description>
          <addressOffset>0x120</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>NewData16_1</name>
              <description>New Data Bits 16-1 (Of All Message Objects)\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No new data has been written into the data portion of this Message Object by the Message Handler since the last time this flag was cleared by the application software</description>
                    <value>0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The Message Handler or the application software has written new data into the data portion of this Message Object</description>
                    <value>1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CAN_NDAT2</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CAN_NDAT2</displayName>
          <description>New Data Register 2</description>
          <addressOffset>0x124</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>NewData32_17</name>
              <description>New Data Bits 32-17 (Of All Message Objects)\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No new data has been written into the data portion of this Message Object by the Message Handler since the last time this flag was cleared by the application software</description>
                    <value>0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The Message Handler or the application software has written new data into the data portion of this Message Object</description>
                    <value>1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CAN_IPND1</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CAN_IPND1</displayName>
          <description>Interrupt Pending Register 1</description>
          <addressOffset>0x140</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>IntPnd16_1</name>
              <description>Interrupt Pending Bits 16-1 (Of All Message Objects)\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>This message object is not the source of an interrupt</description>
                    <value>0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>This message object is the source of an interrupt</description>
                    <value>1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CAN_IPND2</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CAN_IPND2</displayName>
          <description>Interrupt Pending Register 2</description>
          <addressOffset>0x144</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>IntPnd32_17</name>
              <description>Interrupt Pending Bits 32-17(Of All Message Objects)\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>This message object is not the source of an interrupt</description>
                    <value>0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>This message object is the source of an interrupt</description>
                    <value>1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CAN_MVLD1</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CAN_MVLD1</displayName>
          <description>Message Valid Register 1</description>
          <addressOffset>0x160</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MsgVal16_1</name>
              <description>Message Valid Bits 16-1 (Of All Message Objects) (Read Only)\nEx. CAN_MVLD1[0] means Message object No.1 is valid or not. If CAN_MVLD1[0] is set, message object No.1 is configured.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>This Message Object is ignored by the Message Handler</description>
                    <value>0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>This Message Object is configured and should be considered by the Message Handler</description>
                    <value>1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CAN_MVLD2</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CAN_MVLD2</displayName>
          <description>Message Valid Register 2</description>
          <addressOffset>0x164</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MsgVal32_17</name>
              <description>Message Valid Bits 32-17 (Of All Message Objects) (Read Only)\nEx.CAN_MVLD2[15] means Message object No.32 is valid or not. If CAN_MVLD2[15] is set, message object No.32 is configured.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>This Message Object is ignored by the Message Handler</description>
                    <value>0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>This Message Object is configured and should be considered by the Message Handler</description>
                    <value>1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CAN_WU_EN</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CAN_WU_EN</displayName>
          <description>Wake-up Enable Register</description>
          <addressOffset>0x168</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WAKUP_EN</name>
              <description>Wake-Up Enable Bit\nNote: User can wake-up system when there is a falling edge in the CAN_Rx pin..</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The wake-up function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The wake-up function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CAN_WU_STATUS</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CAN_WU_STATUS</displayName>
          <description>Wake-up Status Register</description>
          <addressOffset>0x16C</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WAKUP_STS</name>
              <description>Wake-Up Status \nNote: This bit can be cleared by writing '0'.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No wake-up event occurred</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Wake-up event occurred</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>CAN1</name>
      <description>CAN Register Map</description>
      <groupName>CAN</groupName>
      <baseAddress>0x40184000</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x0</offset>
        <size>0x1C</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x20</offset>
        <size>0x2C</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x80</offset>
        <size>0x2C</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x100</offset>
        <size>0x8</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x120</offset>
        <size>0x8</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x140</offset>
        <size>0x8</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x160</offset>
        <size>0x10</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>CAN_CON</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CAN_CON</displayName>
          <description>Control Register</description>
          <addressOffset>0x0</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000001</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>Init</name>
              <description>Init Initialization\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Normal Operation</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Initialization is started</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IE</name>
              <description>Module Interrupt Enable Bit\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SIE</name>
              <description>Status Change Interrupt Enable Bit\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disabled - No Status Change Interrupt will be generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enabled - An interrupt will be generated when a message transfer is successfully completed or a CAN bus error is detected</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>EIE</name>
              <description>Error Interrupt Enable Bit\n</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disabled - No Error Status Interrupt will be generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enabled - A change in the bits BOff (CAN_STATUS[7]) or EWarn (CAN_STATUS[6]) in the Status Register will generate an interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DAR</name>
              <description>Automatic Re-Transmission Disable Bit\n</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Automatic Retransmission of disturbed messages enabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Automatic Retransmission disabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CCE</name>
              <description>Configuration Change Enable Bit\n</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No write access to the Bit Timing Register</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Write access to the Bit Timing Register (CAN_BTIME) allowed. (while Init bit (CAN_CON[0]) = 1)</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>Test</name>
              <description>Test Mode Enable Bit\n</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Normal Operation</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Test Mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CAN_STATUS</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CAN_STATUS</displayName>
          <description>Status Register</description>
          <addressOffset>0x4</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>LEC</name>
              <description>Last Error Code (Type Of The Last Error To Occur On The CAN Bus)\nThe LEC field holds a code, which indicates the type of the last error to occur on the CAN bus. This field will be cleared to '0' when a message has been transferred (reception or transmission) without error. The unused code '7' may be written by the CPU to check for updates. The following table describes the error code.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TxOK</name>
              <description>Transmitted A Message Successfully\n</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Since this bit was reset by the CPU, no message has been successfully transmitted. This bit is never reset by the CAN Core</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Since this bit was last reset by the CPU, a message has been successfully (error free and acknowledged by at least one other node) transmitted</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RxOK</name>
              <description>Received A Message Successfully\n</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No message has been successfully received since this bit was last reset by the CPU. This bit is never reset by the CAN Core</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>A message has been successfully received since this bit was last reset by the CPU (independent of the result of acceptance filtering)</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>EPass</name>
              <description>Error Passive (Read Only)\n</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The CAN Core is error active</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The CAN Core is in the error passive state as defined in the CAN Specification</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>EWarn</name>
              <description>Error Warning Status (Read Only)\n</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Both error counters are below the error warning limit of 96</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>At least one of the error counters in the EML has reached the error warning limit of 96</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>BOff</name>
              <description>Bus-Off Status (Read Only) \n</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The CAN module is not in bus-off state</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The CAN module is in bus-off state</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CAN_ERR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CAN_ERR</displayName>
          <description>Error Counter Register</description>
          <addressOffset>0x8</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TEC</name>
              <description>Transmit Error Counter\nActual state of the Transmit Error Counter. Values between 0 and 255.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>REC</name>
              <description>Receive Error Counter\nActual state of the Receive Error Counter. Values between 0 and 127.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>7</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RP</name>
              <description>Receive Error Passive\n</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The Receive Error Counter is below the error passive level</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The Receive Error Counter has reached the error passive level as defined in the CAN Specification</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CAN_BTIME</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CAN_BTIME</displayName>
          <description>Bit Timing Register</description>
          <addressOffset>0xC</addressOffset>
          <access>read-write</access>
          <resetValue>0x00002301</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BRP</name>
              <description>Baud Rate Prescaler \n0x01-0x3F: The value by which the oscillator frequency is divided for generating the bit time quanta. The bit time is built up from a multiple of this quanta. Valid values for the Baud Rate Prescaler are [ 0 ... 63 ]. The actual interpretation by the hardware of this value is such that one more than the value programmed here is used.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SJW</name>
              <description>(Re)Synchronization Jump Width\n0x0-0x3: Valid programmed values are [0 ... 3]. The actual interpretation by the hardware of this value is such that one more than the value programmed here is used.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TSeg1</name>
              <description>Time Segment Before The Sample Point Minus Sync_Seg\n0x01-0x0F: valid values for TSeg1 are [1 ... 15]. The actual interpretation by the hardware of this value is such that one more than the value programmed is used.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TSeg2</name>
              <description>Time Segment After Sample Point \n0x0-0x7: Valid values for TSeg2 are [0 ... 7]. The actual interpretation by the hardware of this value is such that one more than the value programmed here is used.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CAN_IIDR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CAN_IIDR</displayName>
          <description>Interrupt Identifier Register</description>
          <addressOffset>0x10</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>IntId</name>
              <description>Interrupt Identifier (Indicates The Source Of The Interrupt)\nIf several interrupts are pending, the CAN Interrupt Register will point to the pending interrupt with the highest priority, disregarding their chronological order. An interrupt remains pending until the application software has cleared it. If IntId is different from 0x0000 and IE (CAN_IFn_MCON[1]) is set, the IRQ interrupt signal to the EIC is active. The interrupt remains active until IntId is back to value 0x0000 (the cause of the interrupt is reset) or until IE is reset.\nThe Status Interrupt has the highest priority. Among the message interrupts, the Message Object' s interrupt priority decreases with increasing message number.\nA message interrupt is cleared by clearing the Message Object's IntPnd bit (CAN_IFn_MCON[13]). The Status Interrupt is cleared by reading the Status Register.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CAN_TEST</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CAN_TEST</displayName>
          <description>Test Register (Register Map Note 1)</description>
          <addressOffset>0x14</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000080</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>Res</name>
              <description>Reserved\nThere are reserved bits.\nThese bits are always read as '0' and must always be written with '0'.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>Basic</name>
              <description>Basic Mode\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Basic Mode disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>IF1 Registers used as Tx Buffer, IF2 Registers used as Rx Buffer</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>Silent</name>
              <description>Silent Mode\n</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Normal operation</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The module is in Silent Mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>LBack</name>
              <description>Loop Back Mode Enable Bit\n</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Loop Back Mode is disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Loop Back Mode is enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>Tx</name>
              <description>Tx[1:0]: Control Of CAN_TX Pin\n</description>
              <bitOffset>5</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Reset value, CAN_TX pin is controlled by the CAN Core</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Sample Point can be monitored at CAN_TX pin</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>CAN_TX pin drives a dominant ('0') value</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>CAN_TX pin drives a recessive ('1') value</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>Rx</name>
              <description>Monitors The Actual Value Of CAN_RX Pin (Read Only) \n</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The CAN bus is dominant (CAN_RX = '0')</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The CAN bus is recessive (CAN_RX = '1')</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CAN_BRPE</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CAN_BRPE</displayName>
          <description>Baud Rate Prescaler Extension Register</description>
          <addressOffset>0x18</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BRPE</name>
              <description>BRPE: Baud Rate Prescaler Extension\n0x00-0x0F: By programming BRPE, the Baud Rate Prescaler can be extended to values up to 1023. The actual interpretation by the hardware is that one more than the value programmed by BRPE (MSBs) and BTIME (LSBs) is used.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CAN_IF1_CREQ</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CAN_IF1_CREQ</displayName>
          <description>IFn (Register Map Note 2) Command Request Registers</description>
          <addressOffset>0x20</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000001</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MessageNumber</name>
              <description>Message Number\n0x01-0x20: Valid Message Number, the Message Object in the Message\nRAM is selected for data transfer.\n0x00: Not a valid Message Number, interpreted as 0x20.\n0x21-0x3F: Not a valid Message Number, interpreted as 0x01-0x1F.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>Busy</name>
              <description>Busy Flag\n</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Read/write action has finished</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Writing to the IFn Command Request Register is in progress. This bit can only be read by the software</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CAN_IF1_CMASK</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CAN_IF1_CMASK</displayName>
          <description>IFn Command Mask Register</description>
          <addressOffset>0x24</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DAT_B</name>
              <description>Access Data Bytes [7:4]\nWrite Operation: \n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Data Bytes [7:4] unchanged</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Transfer Data Bytes [7:4] to Message Object.\nTransfer Data Bytes [7:4] to IFn Message Buffer Register</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DAT_A</name>
              <description>Access Data Bytes [3:0]\nWrite Operation:\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Data Bytes [3:0] unchanged</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Transfer Data Bytes [3:0] to Message Object.\nTransfer Data Bytes [3:0] to IFn Message Buffer Register</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TxRqst_NewDat</name>
              <description>Access Transmission Request Bit When Write Operation\nNote: A read access to a Message Object can be combined with the reset of the control bits IntPnd and NewDat. The values of these bits transferred to the IFn Message Control Register always reflect the status before resetting these bits.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>TxRqst bit unchanged.\nNewDat bit remains unchanged</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Set TxRqst bit.\nClear NewDat bit in the Message Object</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ClrIntPnd</name>
              <description>Clear Interrupt Pending Bit\nWrite Operation:\nWhen writing to a Message Object, this bit is ignored.\nRead Operation:\n</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>IntPnd bit (CAN_IFn_MCON[13]) remains unchanged</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Clear IntPnd bit in the Message Object</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>Control</name>
              <description>Control Access Control Bits\nWrite Operation:\n</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Control Bits unchanged</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Transfer Control Bits to Message Object.\nTransfer Control Bits to IFn Message Buffer Register</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>Arb</name>
              <description>Access Arbitration Bits\nWrite Operation:\n</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Arbitration bits unchanged</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Transfer Identifier + Dir (CAN_IFn_ARB2[13]) + Xtd (CAN_IFn_ARB2[14]) + MsgVal (CAN_IFn_ARB2[15]) to Message Object.\nTransfer Identifier + Dir + Xtd + MsgVal to IFn Message Buffer Register</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>Mask</name>
              <description>Access Mask Bits\nWrite Operation:\n</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Mask bits unchanged</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Transfer Identifier Mask + MDir + MXtd to Message Object.\nTransfer Identifier Mask + MDir + MXtd to IFn Message Buffer Register</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>WR_RD</name>
              <description>Write / Read Mode\n</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Read: Transfer data from the Message Object addressed by the Command Request Register into the selected Message Buffer Registers</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Write: Transfer data from the selected Message Buffer Registers to the Message Object addressed by the Command Request Register</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CAN_IF1_MASK1</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CAN_IF1_MASK1</displayName>
          <description>IFn Mask 1 Register</description>
          <addressOffset>0x28</addressOffset>
          <access>read-write</access>
          <resetValue>0x0000FFFF</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>Msk</name>
              <description>Identifier Mask 15-0\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The corresponding bit in the identifier of the message object cannot inhibit the match in the acceptance filtering</description>
                    <value>0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The corresponding identifier bit is used for acceptance filtering</description>
                    <value>1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CAN_IF1_MASK2</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CAN_IF1_MASK2</displayName>
          <description>IFn Mask 2 Register</description>
          <addressOffset>0x2C</addressOffset>
          <access>read-write</access>
          <resetValue>0x0000FFFF</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>Msk</name>
              <description>Identifier Mask 28-16\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>13</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The corresponding bit in the identifier of the message object cannot inhibit the match in the acceptance filtering</description>
                    <value>0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The corresponding identifier bit is used for acceptance filtering</description>
                    <value>1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>MDir</name>
              <description>Mask Message Direction\n</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The message direction bit (Dir (CAN_IFn_ARB2[13])) has no effect on the acceptance filtering</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The message direction bit (Dir) is used for acceptance filtering</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>MXtd</name>
              <description>Mask Extended Identifier\nNote: When 11-bit  ("standard")  Identifiers  are  used  for  a  Message Object, the identifiers of received Data Frames are written into bits ID28 to ID18 (CAN_IFn_ARB2[12:2]). For acceptance filtering, only these bits together with mask bits Msk28 to Msk18 (CAN_IFn_MASK2[12:2]) are considered.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The extended identifier bit (IDE) has no effect on the acceptance filtering</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The extended identifier bit (IDE) is used for acceptance filtering</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CAN_IF1_ARB1</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CAN_IF1_ARB1</displayName>
          <description>IFn Arbitration 1 Register</description>
          <addressOffset>0x30</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ID</name>
              <description>Message Identifier 15-0\nID28 - ID0, 29-bit Identifier ("Extended Frame").\nID28 - ID18, 11-bit Identifier ("Standard Frame")</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CAN_IF1_ARB2</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CAN_IF1_ARB2</displayName>
          <description>IFn Arbitration 2 Register</description>
          <addressOffset>0x34</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ID</name>
              <description>Message Identifier 28-16\nID28 - ID0, 29-bit Identifier ("Extended Frame").\nID28 - ID18, 11-bit Identifier ("Standard Frame")</description>
              <bitOffset>0</bitOffset>
              <bitWidth>13</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>Dir</name>
              <description>Message Direction\n</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Direction is receive</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Direction is transmit</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>Xtd</name>
              <description>Extended Identifier\n</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The 11-bit ("standard") Identifier will be used for this Message Object</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The 29-bit ("extended") Identifier will be used for this Message Object</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>MsgVal</name>
              <description>Message Valid\nNote: The application software must reset the MsgVal bit of all unused Messages Objects during the initialization before it resets bit Init (CAN_CON[0]). This bit must also be reset before the identifier Id28-0 (CAN_IFn_ARB1/2), the control bits Xtd (CAN_IFn_ARB2[14]), Dir (CAN_IFn_ARB2[13]), or the Data Length Code DLC3-0 (CAN_IFn_MCON[3:0]) are modified,  or if the Messages  Object  is no longer required.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The Message Object is ignored by the Message Handler</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The Message Object is configured and should be considered by the Message Handler</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CAN_IF1_MCON</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CAN_IF1_MCON</displayName>
          <description>IFn Message Control Register</description>
          <addressOffset>0x38</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DLC</name>
              <description>Data Length Code\n0-8: Data Frame has 0-8 data bytes.\n9-15: Data Frame has 8 data bytes\nNote: The Data Length Code of a Message Object must be defined the same as in all the corresponding objects with the same identifier at other nodes. When the Message Handler stores a data frame, it will write the DLC to the value given by the received message.\nData 0: 1st data byte of a CAN Data Frame\nData 1: 2nd data byte of a CAN Data Frame\nData 2: 3rd data byte of a CAN Data Frame\nData 3: 4th data byte of a CAN Data Frame\nData 4: 5th data byte of a CAN Data Frame\nData 5: 6th data byte of a CAN Data Frame\nData 6: 7th data byte of a CAN Data Frame\nData 7 : 8th data byte of a CAN Data Frame\nNote: The Data 0 Byte is the first data byte shifted into the shift register of the CAN Core during a reception while the Data 7 byte is the last. When the Message Handler stores a Data Frame, it will write all the eight data bytes into a Message Object. I	f the Data Length Code is less than 8, the remaining bytes of the Message Object will be overwritten by unspecified values.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EoB</name>
              <description>End Of Buffer\nNote: This bit is used to concatenate two or more Message Objects (up to 32) to build a FIFO Buffer. For single Message Objects (not belonging to a FIFO Buffer), this bit must always be set to one.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Message Object belongs to a FIFO Buffer and is not the last Message Object of that FIFO Buffer</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Single Message Object or last Message Object of a FIFO Buffer</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TxRqst</name>
              <description>Transmit Request\n</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>This Message Object is not waiting for transmission</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The transmission of this Message Object is requested and is not yet done</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RmtEn</name>
              <description>Remote Enable Bit\n</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>At the reception of a Remote Frame, TxRqst (CAN_IFn_MCON[8]) is left unchanged</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>At the reception of a Remote Frame, TxRqst is set</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RxIE</name>
              <description>Receive Interrupt Enable Bit\n</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>IntPnd (CAN_IFn_MCON[13]) will be left unchanged after a successful reception of a frame</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>IntPnd will be set after a successful reception of a frame</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TxIE</name>
              <description>Transmit Interrupt Enable Bit\n</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>IntPnd (CAN_IFn_MCON[13]) will be left unchanged after the successful transmission of a frame</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>IntPnd will be set after a successful transmission of a frame</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>UMask</name>
              <description>Use Acceptance Mask\nNote: If the UMask bit is set to one, the Message Object's mask bits have  to  be  programmed  during  initialization  of  the  Message Object before MsgVal bit (CAN_IFn_ARB2[15]) is set to one.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Mask ignored</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Use Mask (Msk28-0, MXtd, and MDir) for acceptance filtering</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IntPnd</name>
              <description>Interrupt Pending\n</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>This message object is not the source of an interrupt</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>This message object is the source of an interrupt. The Interrupt Identifier in the Interrupt Register will point to this message object if there is no other interrupt source with higher priority</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>MsgLst</name>
              <description></description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No message lost since last time this bit was reset by the CPU</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The Message Handler stored a new message into this object when NewDat was still set, the CPU has lost a message</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>NewDat</name>
              <description>New Data\n</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No new data has been written into the data portion of this Message Object by the Message Handler since last time this flag was cleared by the application software</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The Message Handler or the application software has written new data into the data portion of this Message Object</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CAN_IF1_DAT_A1</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CAN_IF1_DAT_A1</displayName>
          <description>IFn Data A1 Register (Register Map Note 3)</description>
          <addressOffset>0x3C</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>Data0</name>
              <description>Data Byte 0\n1st data byte of a CAN Data Frame</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>Data1</name>
              <description>Data Byte 1\n2nd data byte of a CAN Data Frame</description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CAN_IF1_DAT_A2</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CAN_IF1_DAT_A2</displayName>
          <description>IFn Data A2 Register (Register Map Note 3)</description>
          <addressOffset>0x40</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>Data2</name>
              <description>Data Byte 2\n3rd data byte of CAN Data Frame</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>Data3</name>
              <description>Data Byte 3\n4th data byte of CAN Data Frame</description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CAN_IF1_DAT_B1</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CAN_IF1_DAT_B1</displayName>
          <description>IFn Data B1 Register (Register Map Note 3)</description>
          <addressOffset>0x44</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>Data4</name>
              <description>Data Byte 4\n5th data byte of CAN Data Frame</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>Data5</name>
              <description>Data Byte 5\n6th data byte of CAN Data Frame</description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CAN_IF1_DAT_B2</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CAN_IF1_DAT_B2</displayName>
          <description>IFn Data B2 Register (Register Map Note 3)</description>
          <addressOffset>0x48</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>Data6</name>
              <description>Data Byte 6\n7th data byte of CAN Data Frame.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>Data7</name>
              <description>Data Byte 7\n8th data byte of CAN Data Frame.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="CAN_IF1_CREQ">
          <name>CAN_IF2_CREQ</name>
          <displayName>CAN_IF2_CREQ</displayName>
          <description>IFn (Register Map Note 2) Command Request Registers</description>
          <addressOffset>0x80</addressOffset>
       </register>
       <register derivedFrom="CAN_IF1_CMASK">
          <name>CAN_IF2_CMASK</name>
          <displayName>CAN_IF2_CMASK</displayName>
          <description>IFn Command Mask Register</description>
          <addressOffset>0x84</addressOffset>
       </register>
       <register derivedFrom="CAN_IF1_MASK1">
          <name>CAN_IF2_MASK1</name>
          <displayName>CAN_IF2_MASK1</displayName>
          <description>IFn Mask 1 Register</description>
          <addressOffset>0x88</addressOffset>
       </register>
       <register derivedFrom="CAN_IF1_MASK2">
          <name>CAN_IF2_MASK2</name>
          <displayName>CAN_IF2_MASK2</displayName>
          <description>IFn Mask 2 Register</description>
          <addressOffset>0x8C</addressOffset>
       </register>
       <register derivedFrom="CAN_IF1_ARB1">
          <name>CAN_IF2_ARB1</name>
          <displayName>CAN_IF2_ARB1</displayName>
          <description>IFn Arbitration 1 Register</description>
          <addressOffset>0x90</addressOffset>
       </register>
       <register derivedFrom="CAN_IF1_ARB2">
          <name>CAN_IF2_ARB2</name>
          <displayName>CAN_IF2_ARB2</displayName>
          <description>IFn Arbitration 2 Register</description>
          <addressOffset>0x94</addressOffset>
       </register>
       <register derivedFrom="CAN_IF1_MCON">
          <name>CAN_IF2_MCON</name>
          <displayName>CAN_IF2_MCON</displayName>
          <description>IFn Message Control Register</description>
          <addressOffset>0x98</addressOffset>
       </register>
       <register derivedFrom="CAN_IF1_DAT_A1">
          <name>CAN_IF2_DAT_A1</name>
          <displayName>CAN_IF2_DAT_A1</displayName>
          <description>IFn Data A1 Register (Register Map Note 3)</description>
          <addressOffset>0x9C</addressOffset>
       </register>
       <register derivedFrom="CAN_IF1_DAT_A2">
          <name>CAN_IF2_DAT_A2</name>
          <displayName>CAN_IF2_DAT_A2</displayName>
          <description>IFn Data A2 Register (Register Map Note 3)</description>
          <addressOffset>0xA0</addressOffset>
       </register>
       <register derivedFrom="CAN_IF1_DAT_B1">
          <name>CAN_IF2_DAT_B1</name>
          <displayName>CAN_IF2_DAT_B1</displayName>
          <description>IFn Data B1 Register (Register Map Note 3)</description>
          <addressOffset>0xA4</addressOffset>
       </register>
       <register derivedFrom="CAN_IF1_DAT_B2">
          <name>CAN_IF2_DAT_B2</name>
          <displayName>CAN_IF2_DAT_B2</displayName>
          <description>IFn Data B2 Register (Register Map Note 3)</description>
          <addressOffset>0xA8</addressOffset>
       </register>
       <register>
          <name>CAN_TXREQ1</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CAN_TXREQ1</displayName>
          <description>Transmission Request Register 1</description>
          <addressOffset>0x100</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TxRqst16_1</name>
              <description>Transmission Request Bits 16-1 (Of All Message Objects)\nThese bits are read only.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>This Message Object is not waiting for transmission</description>
                    <value>0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The transmission of this Message Object is requested and is not yet done</description>
                    <value>1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CAN_TXREQ2</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CAN_TXREQ2</displayName>
          <description>Transmission Request Register 2</description>
          <addressOffset>0x104</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TxRqst32_17</name>
              <description>Transmission Request Bits 32-17 (Of All Message Objects)\nThese bits are read only.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>This Message Object is not waiting for transmission</description>
                    <value>0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The transmission of this Message Object is requested and is not yet done</description>
                    <value>1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CAN_NDAT1</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CAN_NDAT1</displayName>
          <description>New Data Register 1</description>
          <addressOffset>0x120</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>NewData16_1</name>
              <description>New Data Bits 16-1 (Of All Message Objects)\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No new data has been written into the data portion of this Message Object by the Message Handler since the last time this flag was cleared by the application software</description>
                    <value>0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The Message Handler or the application software has written new data into the data portion of this Message Object</description>
                    <value>1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CAN_NDAT2</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CAN_NDAT2</displayName>
          <description>New Data Register 2</description>
          <addressOffset>0x124</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>NewData32_17</name>
              <description>New Data Bits 32-17 (Of All Message Objects)\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No new data has been written into the data portion of this Message Object by the Message Handler since the last time this flag was cleared by the application software</description>
                    <value>0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The Message Handler or the application software has written new data into the data portion of this Message Object</description>
                    <value>1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CAN_IPND1</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CAN_IPND1</displayName>
          <description>Interrupt Pending Register 1</description>
          <addressOffset>0x140</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>IntPnd16_1</name>
              <description>Interrupt Pending Bits 16-1 (Of All Message Objects)\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>This message object is not the source of an interrupt</description>
                    <value>0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>This message object is the source of an interrupt</description>
                    <value>1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CAN_IPND2</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CAN_IPND2</displayName>
          <description>Interrupt Pending Register 2</description>
          <addressOffset>0x144</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>IntPnd32_17</name>
              <description>Interrupt Pending Bits 32-17(Of All Message Objects)\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>This message object is not the source of an interrupt</description>
                    <value>0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>This message object is the source of an interrupt</description>
                    <value>1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CAN_MVLD1</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CAN_MVLD1</displayName>
          <description>Message Valid Register 1</description>
          <addressOffset>0x160</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MsgVal16_1</name>
              <description>Message Valid Bits 16-1 (Of All Message Objects) (Read Only)\nEx. CAN_MVLD1[0] means Message object No.1 is valid or not. If CAN_MVLD1[0] is set, message object No.1 is configured.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>This Message Object is ignored by the Message Handler</description>
                    <value>0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>This Message Object is configured and should be considered by the Message Handler</description>
                    <value>1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CAN_MVLD2</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CAN_MVLD2</displayName>
          <description>Message Valid Register 2</description>
          <addressOffset>0x164</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MsgVal32_17</name>
              <description>Message Valid Bits 32-17 (Of All Message Objects) (Read Only)\nEx.CAN_MVLD2[15] means Message object No.32 is valid or not. If CAN_MVLD2[15] is set, message object No.32 is configured.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>This Message Object is ignored by the Message Handler</description>
                    <value>0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>This Message Object is configured and should be considered by the Message Handler</description>
                    <value>1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CAN_WU_EN</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CAN_WU_EN</displayName>
          <description>Wake-up Enable Register</description>
          <addressOffset>0x168</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WAKUP_EN</name>
              <description>Wake-Up Enable Bit\nNote: User can wake-up system when there is a falling edge in the CAN_Rx pin..</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The wake-up function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The wake-up function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CAN_WU_STATUS</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CAN_WU_STATUS</displayName>
          <description>Wake-up Status Register</description>
          <addressOffset>0x16C</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WAKUP_STS</name>
              <description>Wake-Up Status \nNote: This bit can be cleared by writing '0'.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No wake-up event occurred</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Wake-up event occurred</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>ADC</name>
      <description>ADC Register Map</description>
      <groupName>ADC</groupName>
      <baseAddress>0x400E0000</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x0</offset>
        <size>0x34</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x40</offset>
        <size>0x4</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>ADDR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>ADDR0</displayName>
          <description>ADC Data Register 0</description>
          <addressOffset>0x0</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RSLT</name>
              <description>A/D Conversion Result\nThis field contains conversion result of ADC.\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>OVERRUN</name>
              <description>Overrun Flag\nIf converted data in RSLT has not been read before new conversion result is loaded to this register, OVERRUN is set to 1 and previous conversion result is gone. It is cleared by hardware after ADDR register is read.\nThis is a read only bit.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Data in RSLT (ADDRx[15:0], x=0~7) is recent conversion result</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Data in RSLT (ADDRx[15:0], x=0~7) is overwritten</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>VALID</name>
              <description>Valid Flag\nThis bit is set to 1 when corresponding channel analog input conversion is completed and cleared by hardware after ADDR register is read.\nThis is a read only bit</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Data in RSLT bits (ADDRx[15:0], x=0~7) is not valid</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Data in RSLT bits (ADDRx[15:0], x=0~7) is valid</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="ADDR0">
          <name>ADDR1</name>
          <displayName>ADDR1</displayName>
          <description>ADC Data Register 1</description>
          <addressOffset>0x4</addressOffset>
       </register>
       <register derivedFrom="ADDR0">
          <name>ADDR2</name>
          <displayName>ADDR2</displayName>
          <description>ADC Data Register 2</description>
          <addressOffset>0x8</addressOffset>
       </register>
       <register derivedFrom="ADDR0">
          <name>ADDR3</name>
          <displayName>ADDR3</displayName>
          <description>ADC Data Register 3</description>
          <addressOffset>0xC</addressOffset>
       </register>
       <register derivedFrom="ADDR0">
          <name>ADDR4</name>
          <displayName>ADDR4</displayName>
          <description>ADC Data Register 4</description>
          <addressOffset>0x10</addressOffset>
       </register>
       <register derivedFrom="ADDR0">
          <name>ADDR5</name>
          <displayName>ADDR5</displayName>
          <description>ADC Data Register 5</description>
          <addressOffset>0x14</addressOffset>
       </register>
       <register derivedFrom="ADDR0">
          <name>ADDR6</name>
          <displayName>ADDR6</displayName>
          <description>ADC Data Register 6</description>
          <addressOffset>0x18</addressOffset>
       </register>
       <register derivedFrom="ADDR0">
          <name>ADDR7</name>
          <displayName>ADDR7</displayName>
          <description>ADC Data Register 7</description>
          <addressOffset>0x1C</addressOffset>
       </register>
       <register>
          <name>ADCR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>ADCR</displayName>
          <description>ADC Control Register</description>
          <addressOffset>0x20</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ADEN</name>
              <description>A/D Converter Enable Bit\nBefore starting A/D conversion function, this bit should be set to 1. Clear it to 0 to disable A/D converter analog circuit for saving power consumption.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ADIE</name>
              <description>A/D Interrupt Enable Bit\nA/D conversion end interrupt request is generated if ADIE bit (ADCR[1]) is set to 1.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>A/D interrupt function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>A/D interrupt function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ADMD</name>
              <description>A/D Converter Operation Mode\nWhen changing the operation mode, software should disable ADST bit (ADCR[11]) firstly.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Single conversion</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reserved</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Single-cycle scan</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Continuous scan</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TRGS</name>
              <description>Hardware Trigger Source\nSoftware should disable TRGEN (ADCR[8]) and ADST (ADCR[11]) before change TRGS.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>A/D conversion is started by external STADC pin</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>A/D conversion is started by PWM Center-aligned trigger</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TRGCOND</name>
              <description>External Trigger Condition\nThese two bits decide external pin STADC trigger event is level or edge. The signal must be kept at stable state at least 8 PCLKs for level trigger and 4 PCLKs at high and low state for edge trigger.\n</description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Low level</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>High level</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Falling edge</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Rising edge</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TRGEN</name>
              <description>Hardware Trigger Enable Bit\nEnable or disable triggering of A/D conversion by hardware (external STADC pin or PWM Center-aligned trigger).\nADC hardware trigger function is only supported in single-cycle scan mode.\nIf hardware trigger mode, the ADST bit (ADCR[11]) can be set to 1 by the selected hardware trigger source.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PTEN</name>
              <description>PDMA Transfer Enable Bit\n</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PDMA data transfer Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PDMA data transfer in ADDR 0~7 Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DIFFEN</name>
              <description>Differential Input Mode Control\n</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Single-end analog input mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Differential analog input mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ADST</name>
              <description>A/D Conversion Start\nADST bit can be set to 1 from three sources: software, PWM Center-aligned trigger and external pin STADC. ADST will be cleared to 0 by hardware automatically at the ends of single mode and single-cycle scan mode. In continuous scan mode, A/D conversion is continuously performed until software writes 0 to this bit or chip reset.</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Conversion stops and A/D converter enter idle state</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Conversion starts</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DMOF</name>
              <description>A/D Differential Input Mode Output Format\n</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>A/D Conversion result will be filled in RSLT at ADDRx registers with unsigned format</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>A/D Conversion result will be filled in RSLT at ADDRx registers with 2'complement format</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>ADCHER</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>ADCHER</displayName>
          <description>ADC Channel Enable Register</description>
          <addressOffset>0x24</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CHEN</name>
              <description>Analog Input Channel Enable Bit\nSet CHEN[7:0] to enable the corresponding analog input channel 7 ~ 0. If DIFFEN bit (ADCR[10]) is set to 1, only the even number channels need to be enabled.\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>ADC input channel Disabled</description>
                    <value>0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>ADC input channel Enabled</description>
                    <value>1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PRESEL</name>
              <description>Analog Input Channel 7 Selection\n</description>
              <bitOffset>8</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>External analog input</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Internal band-gap voltage</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Internal temperature sensor</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Reserved</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>ADCMPR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>ADCMPR0</displayName>
          <description>ADC Compare Register 0</description>
          <addressOffset>0x28</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CMPEN</name>
              <description>Compare Enable Bit\nSet this bit to 1 to enable ADC controller to compare CMPD (ADCMPR0/1[27:16]) with specified channel conversion result when converted data is loaded into ADDR register.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Compare function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Compare function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CMPIE</name>
              <description>Compare Interrupt Enable Bit\nIf the compare function is enabled and the compare condition matches the setting of CMPCOND (ADCMPR0/1[2]) and CMPMATCNT (ADCMPR0/1[11:8]), CMPF0/1 bit (ADSR[1]/[2]) will be asserted, in the meanwhile, if CMPIE (ADCMPR0/1[1]) is set to 1, a compare interrupt request is generated.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Compare function interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Compare function interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CMPCOND</name>
              <description>Compare Condition\nNote: When the internal counter reaches the value to (CMPMATCNT (ADCMPR0/1[11:8])+1), the CMPF0/1 bit (ADSR[1]/[2]) will be set.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Set the compare condition as that when a 12-bit A/D conversion result is less than the 12-bit CMPD (ADCMPR0/1[27:16]), the internal match counter will increase one</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Set the compare condition as that when a 12-bit A/D conversion result is greater or equal to the 12-bit CMPD (ADCMPR0/1[27:16]), the internal match counter will increase one</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CMPCH</name>
              <description>Compare Channel Selection\n</description>
              <bitOffset>3</bitOffset>
              <bitWidth>3</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Channel 0 conversion result is selected to be compared</description>
                    <value>#000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Channel 1 conversion result is selected to be compared</description>
                    <value>#001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Channel 2 conversion result is selected to be compared</description>
                    <value>#010</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Channel 3 conversion result is selected to be compared</description>
                    <value>#011</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>4</name>
                    <description>Channel 4 conversion result is selected to be compared</description>
                    <value>#100</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>5</name>
                    <description>Channel 5 conversion result is selected to be compared</description>
                    <value>#101</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>6</name>
                    <description>Channel 6 conversion result is selected to be compared</description>
                    <value>#110</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>7</name>
                    <description>Channel 7 conversion result is selected to be compared</description>
                    <value>#111</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CMPMATCNT</name>
              <description>Compare Match Count\nWhen the specified A/D channel analog conversion result matches the compare condition defined by CMPCOND (ADCMPR0/1[2]), the internal match counter will increase 1, The comparing data must successively matched with the compare condition. Once any comparing data does not match during the comparing, the internal counter will clear to 0. When the internal counter reaches the value to (CMPMATCNT (ADCMPR0/1[11:8]) +1), the CMPF0/1 bit (ADSR[1]/[2]) will be set.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CMPD</name>
              <description>Comparison Data\nThe 12-bit data is used to compare with conversion result of specified channel.\nWhen DMOF bit (ADCR[31]) is set to 0, ADC comparator compares CMPD with conversion result with unsigned format. CMPD should be filled in unsigned format.\nWhen DMOF bit (ADCR[31]) is set to 1, ADC comparator compares CMPD with conversion result with 2'complement format. CMPD should be filled in 2'complement format.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>12</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="ADCMPR0">
          <name>ADCMPR1</name>
          <displayName>ADCMPR1</displayName>
          <description>ADC Compare Register 1</description>
          <addressOffset>0x2C</addressOffset>
       </register>
       <register>
          <name>ADSR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>ADSR</displayName>
          <description>ADC Status Register</description>
          <addressOffset>0x30</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ADF</name>
              <description>A/D Conversion End Flag\nA status flag that indicates the end of A/D conversion.\nADF is set to 1 at these two conditions:\n1. When A/D conversion ends in Single mode.\n2. When A/D conversion ends on all specified channels in Scan mode.\nThis flag can be cleared by writing 1 to itself.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CMPF0</name>
              <description>Compare Flag\nWhen the selected channel A/D conversion result meets setting condition in ADCMPR0 then this bit is set to 1. And it is cleared by writing 1 to self.\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Conversion result in ADDR does not meet ADCMPR0 setting</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Conversion result in ADDR meets ADCMPR0 setting</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CMPF1</name>
              <description>Compare Flag\nWhen the selected channel A/D conversion result meets setting condition in ADCMPR1 then this bit is set to 1. And it is cleared by writing 1 to self.\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Conversion result in ADDR does not meet ADCMPR1 setting</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Conversion result in ADDR meets ADCMPR1 setting</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BUSY</name>
              <description>BUSY/IDLE\nThis bit is mirror of as ADST bit (ADCR[11]).\nIt is read only.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>A/D converter is in idle state</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>A/D converter is busy at conversion</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CHANNEL</name>
              <description>Current Conversion Channel\nIt is read only.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>VALID</name>
              <description>Data Valid Flag\nIt is a mirror of VALID bit (ADDR0~7[17]).\nIt is read only.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OVERRUN</name>
              <description>Overrun Flag\nIt is a mirror to OVERRUN bit (ADDR0~7[16]).\nIt is read only.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>ADPDMA</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>ADPDMA</displayName>
          <description>ADC PDMA Current Transfer Data Register</description>
          <addressOffset>0x40</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>AD_PDMA</name>
              <description>ADC PDMA Current Transfer Data Register\nWhen PDMA transferring, read this register can monitor current PDMA transfer data.\nCurrent PDMA transfer data is the content of ADDR0 ~ ADDR7.\nThis is a read only register.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>18</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>ACMP</name>
      <description>ACMP Register Map</description>
      <groupName>ACMP</groupName>
      <baseAddress>0x400D0000</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x0</offset>
        <size>0xC</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>CMPCR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CMPCR0</displayName>
          <description>Analog Comparator 0 Control Register</description>
          <addressOffset>0x0</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CMPEN</name>
              <description>Comparator Enable Bit\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Comparator Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Comparator Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CMPIE</name>
              <description>Comparator Interrupt Enable Bit\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Interrupt function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Interrupt function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CMP_HYSEN</name>
              <description>Comparator Hysteresis Enable Bit\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Hysteresis function Disabled (Default)</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Hysteresis function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CMPCN</name>
              <description>Comparator Negative Input Selection\n</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The source of the negative comparator input is from ACMPn_N pin (n = 0, 1)</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Internal band-gap reference voltage is selected as the source of negative comparator input</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CMPINV</name>
              <description>Comparator Output Inverse Enable Bit\n</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Comparator analog output inverse is Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Comparator analog output inverse is Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="CMPCR0">
          <name>CMPCR1</name>
          <displayName>CMPCR1</displayName>
          <description>Analog Comparator 1 Control Register</description>
          <addressOffset>0x4</addressOffset>
       </register>
       <register>
          <name>CMPSR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CMPSR</displayName>
          <description>Analog Comparator Status Register</description>
          <addressOffset>0x8</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CMPF0</name>
              <description>Comparator 0 Interrupt Flag\nThis bit is set by hardware whenever the comparator 0 output changes state. This will cause an interrupt if CMPCR0[1] is set to 1.\nWrite 1 to clear this bit to 0.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CMPF1</name>
              <description>Comparator 1 Interrupt Flag\nThis bit is set by hardware whenever the comparator 1 output changes state. This will cause an interrupt if CMPCR1[1] is set to 1.\nWrite 1 to clear this bit to 0.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CO0</name>
              <description>Comparator 0 Output\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CO1</name>
              <description>Comparator 1 Output\n</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
      </registers>
    </peripheral>
  </peripherals>
</device>
