<?xml version="1.0" encoding="utf-8"?>
<device schemaVersion="1.1" xmlns:xs="http://www.w3.org/2001/XMLSchema-instance" xs:noNamespaceSchemaLocation="CMSIS-SVD_Schema_1_1.xsd" >
  <name>NANO103AE_v1</name>
  <version>1.0</version>
  <description>NANO103AE_v1 SVD file</description>
  <!-- Bus Interface Properties -->
  <!-- Cortex-M0 is byte addressable -->
  <addressUnitBits>8</addressUnitBits>
  <!-- the maximum data bit width accessible within a single transfer is 32bits -->
  <width>32</width>

  <!-- Register Default Properties -->
  <!-- the size of the registers is set to a bit width of 32. This can be overruled for individual peripherals and/or registers -->
  <size>32</size>
  <!-- the access to all registers is set to be readable and writeable. This can be overruled for individual peripherals and/or registers -->
  <access>read-write</access>
  <!-- for demonstration purposes the resetValue for all registers of the device is set to be 0. This can be overruled within the description -->
  <resetValue>0</resetValue>
  <!-- the resetMask = 0 specifies that by default no register of this device has a defined reset value -->
  <resetMask>0</resetMask>

  <peripherals>
    <peripheral>
      <name>SCS</name>
      <description>SCS Register Map</description>
      <groupName>SCS</groupName>
      <baseAddress>0xE000E000</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x10</offset>
        <size>0xC</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x100</offset>
        <size>0x4</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x180</offset>
        <size>0x4</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x200</offset>
        <size>0x4</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x280</offset>
        <size>0x4</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x400</offset>
        <size>0x20</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0xD00</offset>
        <size>0x8</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0xD10</offset>
        <size>0x4</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0xD1C</offset>
        <size>0x8</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>SYST_CTL</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SYST_CTL</displayName>
          <description>SysTick Control and Status</description>
          <addressOffset>0x10</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000004</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ENABLE</name>
              <description>System Tick Counter Enable Control</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>System Tick  counter Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>System Tick counter will operate in a multi-shot manner</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TICKINT</name>
              <description>System Tick Interrupt Enable Control</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Counting down to 0 will  not cause the SysTick exception to be pended. User can use COUNTFLAG to determine if a count to zero has occurred</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Counting down to 0 will cause the SysTick exception to be pended. Clearing the SysTick Current Value register by a register write in software will not cause SysTick to be pended</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CLKSRC</name>
              <description>System Tick Clock Source Select Bit</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Clock source is optional, refer to STCLKSEL</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Core clock used for SysTick timer</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>COUNTFLAG</name>
              <description>System Tick Counter Flag\nReturns 1 If Timer Counted to 0 Since Last Time this Register Was Read</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>COUNTFLAG is cleared on read or by a write to the Current Value register</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>COUNTFLAG is set by a count transition from 1 to 0</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SYST_RVR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SYST_RVR</displayName>
          <description>SysTick Reload Value Register</description>
          <addressOffset>0x14</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>RELOAD</name>
              <description>System Tick Reload Value\nValue to load into the Current Value register when the counter reaches 0.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SYST_CVR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SYST_CVR</displayName>
          <description>SysTick Current Value Register</description>
          <addressOffset>0x18</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>CURRENT</name>
              <description>System Tick Current Value\nCurrent counter value. This is the value of the counter at the time it is sampled. The counter does not provide read-modify-write protection. The register is write-clear. A software write of any value will clear the register to 0.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>NVIC_ISER</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>NVIC_ISER</displayName>
          <description>IRQ0~IRQ31 Set-Enable Control Register</description>
          <addressOffset>0x100</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SETENA</name>
              <description>Interrupt Enable Bits\nEnable one or more interrupts. Each bit represents an interrupt number from IRQ0 ~ IRQ31 (Vector number from 16 ~ 47).\nWrite Operation:\nNote: Read value indicates the current enable status.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect.\nAssociated interrupt status is Disabled</description>
                    <value>0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Write 1 to enable associated interrupt.\nAssociated interrupt status is Enabled</description>
                    <value>1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>NVIC_ICER</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>NVIC_ICER</displayName>
          <description>IRQ0~IRQ31 Clear-Enable Control Register</description>
          <addressOffset>0x180</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CLRENA</name>
              <description>Interrupt Disable Bits\nDisable one or more interrupts. Each bit represents an interrupt number from IRQ0 ~ IRQ31 (Vector number from 16 ~ 47).\nWrite Operation:\nNote: Read value indicates the current enable status.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect.\nAssociated interrupt status is Disabled</description>
                    <value>0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Write 1 to disable associated interrupt.\nAssociated interrupt status is Enabled</description>
                    <value>1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>NVIC_ISPR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>NVIC_ISPR</displayName>
          <description>IRQ0~IRQ31 Set-Pending Control Register</description>
          <addressOffset>0x200</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SETPEND</name>
              <description>Set Interrupt Pending\nWrite Operation:\nNote: Read value indicates the current pending status.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect.\nAssociated interrupt in not in pending status</description>
                    <value>0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Write 1 to set pending state. Each bit represents an interrupt number from IRQ0 ~ IRQ31 (Vector number from 16 ~ 47).\nAssociated interrupt is in pending status</description>
                    <value>1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>NVIC_ICPR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>NVIC_ICPR</displayName>
          <description>IRQ0~IRQ31Clear-Pending Control Register</description>
          <addressOffset>0x280</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CLRPEND</name>
              <description>Clear Interrupt Pending\nWrite Operation:\nNote: Read value indicates the current pending status.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect.\nAssociated interrupt in not in pending status</description>
                    <value>0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Write 1 to clear pending state. Each bit represents an interrupt number from IRQ0 ~ IRQ31 (Vector number from 16 ~ 47).\nAssociated interrupt is in pending status</description>
                    <value>1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>NVIC_IPR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>NVIC_IPR0</displayName>
          <description>IRQ0~IRQ3 Priority Control Register</description>
          <addressOffset>0x400</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PRI_0</name>
              <description>Priority of IRQ0\n"0" denotes the highest priority and "3" denotes the lowest priority.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PRI_1</name>
              <description>Priority of IRQ1\n"0" denotes the highest priority and "3" denotes the lowest priority.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PRI_2</name>
              <description>Priority of IRQ2\n"0" denotes the highest priority and "3" denotes the lowest priority.</description>
              <bitOffset>22</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PRI_3</name>
              <description>Priority of IRQ3\n"0" denotes the highest priority and "3" denotes the lowest priority.</description>
              <bitOffset>30</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>NVIC_IPR1</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>NVIC_IPR1</displayName>
          <description>IRQ4~IRQ7 Priority Control Register</description>
          <addressOffset>0x404</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PRI_4</name>
              <description>Priority of IRQ4\n"0" denotes the highest priority and "3" denotes the lowest priority.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PRI_5</name>
              <description>Priority of IRQ5\n"0" denotes the highest priority and "3" denotes the lowest priority.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PRI_6</name>
              <description>Priority of IRQ6\n"0" denotes the highest priority and "3" denotes the lowest priority.</description>
              <bitOffset>22</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PRI_7</name>
              <description>Priority of IRQ7\n"0" denotes the highest priority and "3" denotes the lowest priority.</description>
              <bitOffset>30</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>NVIC_IPR2</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>NVIC_IPR2</displayName>
          <description>IRQ8~IRQ11 Priority Control Register</description>
          <addressOffset>0x408</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PRI_8</name>
              <description>Priority of IRQ8\n"0" denotes the highest priority and "3" denotes the lowest priority.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PRI_9</name>
              <description>Priority of IRQ9\n"0" denotes the highest priority and "3" denotes the lowest priority.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PRI_10</name>
              <description>Priority of IRQ10\n"0" denotes the highest priority and "3" denotes the lowest priority.</description>
              <bitOffset>22</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PRI_11</name>
              <description>Priority of IRQ11\n"0" denotes the highest priority and "3" denotes the lowest priority.</description>
              <bitOffset>30</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>NVIC_IPR3</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>NVIC_IPR3</displayName>
          <description>IRQ12~IRQ15 Priority Control Register</description>
          <addressOffset>0x40C</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PRI_12</name>
              <description>Priority of IRQ12\n"0" denotes the highest priority and "3" denotes the lowest priority.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PRI_13</name>
              <description>Priority of IRQ13\n"0" denotes the highest priority and "3" denotes the lowest priority.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PRI_14</name>
              <description>Priority of IRQ14\n"0" denotes the highest priority and "3" denotes the lowest priority.</description>
              <bitOffset>22</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PRI_15</name>
              <description>Priorityof IRQ15\n"0" denotes the highest priority and "3" denotes the lowest priority.</description>
              <bitOffset>30</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>NVIC_IPR4</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>NVIC_IPR4</displayName>
          <description>IRQ16~IRQ19 Priority Control Register</description>
          <addressOffset>0x410</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PRI_16</name>
              <description>Priority of IRQ16\n"0" denotes the highest priority and "3" denotes the lowest priority.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PRI_17</name>
              <description>Priority of IRQ17\n"0" denotes the highest priority and "3" denotes the lowest priority.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PRI_18</name>
              <description>Priority of IRQ18\n"0" denotes the highest priority and "3" denotes the lowest priority.</description>
              <bitOffset>22</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PRI_19</name>
              <description>Priority of IRQ19\n"0" denotes the highest priority and "3" denotes the lowest priority.</description>
              <bitOffset>30</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>NVIC_IPR5</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>NVIC_IPR5</displayName>
          <description>IRQ20~IRQ23 Priority Control Register</description>
          <addressOffset>0x414</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PRI_20</name>
              <description>Priority of IRQ20\n"0" denotes the highest priority and "3" denotes the lowest priority.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PRI_21</name>
              <description>Priority of IRQ21\n"0" denotes the highest priority and "3" denotes the lowest priority.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PRI_22</name>
              <description>Priority of IRQ22\n"0" denotes the highest priority and "3" denotes the lowest priority.</description>
              <bitOffset>22</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PRI_23</name>
              <description>Priority of IRQ23\n"0" denotes the highest priority and "3" denotes the lowest priority.</description>
              <bitOffset>30</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>NVIC_IPR6</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>NVIC_IPR6</displayName>
          <description>IRQ24~IRQ27 Priority Control Register</description>
          <addressOffset>0x418</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PRI_24</name>
              <description>Priority of IRQ24\n"0" denotes the highest priority and "3" denotes the lowest priority.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PRI_25</name>
              <description>Priority of IRQ25\n"0" denotes the highest priority and "3" denotes the lowest priority.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PRI_26</name>
              <description>Priority of IRQ26\n"0" denotes the highest priority and "3" denotes the lowest priority.</description>
              <bitOffset>22</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PRI_27</name>
              <description>Priority of IRQ27\n"0" denotes the highest priority and "3" denotes the lowest priority.</description>
              <bitOffset>30</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>NVIC_IPR7</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>NVIC_IPR7</displayName>
          <description>IRQ28~IRQ31 Priority Control Register</description>
          <addressOffset>0x41C</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PRI_28</name>
              <description>Priority of IRQ28\n"0" denotes the highest priority and "3" denotes the lowest priority.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PRI_29</name>
              <description>Priority of IRQ29\n"0" denotes the highest priority and "3" denotes the lowest priority.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PRI_30</name>
              <description>Priority of IRQ30\n"0" denotes the highest priority and "3" denotes the lowest priority.</description>
              <bitOffset>22</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PRI_31</name>
              <description>Priority of IRQ31\n"0" denotes the highest priority and "3" denotes the lowest priority.</description>
              <bitOffset>30</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CPUID</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CPUID</displayName>
          <description>CPUID Base Register</description>
          <addressOffset>0xD00</addressOffset>
          <access>read-only</access>
          <resetValue>0x410CC200</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>REVISION</name>
              <description>Revision Number \nReads as 0x0</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PARTNO</name>
              <description>Part Number of the Processor \nReads as 0xC20.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>12</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PART</name>
              <description>Architecture of the Processor \nReads as 0xC for ARMv6-M parts</description>
              <bitOffset>16</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>IMPLEMENTER</name>
              <description>Implementer Code </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>ICSR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>ICSR</displayName>
          <description>Interrupt Control State Register</description>
          <addressOffset>0xD04</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>VECTACTIVE</name>
              <description>Contains the Active Exception Number</description>
              <bitOffset>0</bitOffset>
              <bitWidth>9</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Thread mode</description>
                    <value>0</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>VECTPENDING</name>
              <description>Exception Number of the Highest Priority Pending Enabled Exception</description>
              <bitOffset>12</bitOffset>
              <bitWidth>9</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No pending exceptions</description>
                    <value>0</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ISRPENDING</name>
              <description>Interrupt Pending Flag,Excluding NMI and Faults (Read Only)</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Interrupt not pending</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Interrupt pending</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>ISRPREEMPT</name>
              <description>Interrupt Preempt Bit(Read Only)\nIf set, a pending exception will be serviced on exit from the debug halt state</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PENDSTCLR</name>
              <description>SysTick Exception Clear-pending Bit\nWrite Operation:\nNote: This bit is write-only. When you want to clear PENDST bit, you must "write 0 toPENDSTSET and write 1 to PENDSTCLR" at the same time.</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Removes the pending state from the SysTick exception</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PENDSTSET</name>
              <description>SysTick Exception Set-pending Bit\nWrite Operation:</description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect.\nSysTick exception is not pending</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Changes SysTick exception state to pending.\nSysTick exception is pending</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PENDSVCLR</name>
              <description>PendSV Clear-pending Bit\nWrite Operation:\nThis bit is write-only. To clear the PENDSV bit, you must "write 0 to PENDSVSET andwrite 1 to PENDSVCLR" at the same time.</description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Removes the pending state from the PendSV exception</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PENDSVSET</name>
              <description>PendSV Set-pending Bit\nWrite Operation:\nNote: Writing 1 to this bit is the only way to set the PendSV exception state to pending</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect.\nPendSV exception is not pending</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Changes PendSV exception state to pending.\nPendSV exception is pending</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>NMIPENDSET</name>
              <description>NMI Set-pending Bit\nWrite Operation:\nNote: Because NMI is the highest-priority exception, normally the processor entersthe NMI exception handler as soon as it detects a write of 1 to this bit. Entering thehandler then clears this bit to 0. This means a read of this bit by the NMI exceptionhandler returns 1 only if the NMI signal is reasserted while the processor is executingthat handler.</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect.\nNMI exception not pending</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Changes NMI exception state to pending.\nNMI exception pending</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SCR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SCR</displayName>
          <description>System Control Register</description>
          <addressOffset>0xD10</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SLEEPONEXIT</name>
              <description>Sleep-on-exit Enable Control\nThis bit indicates sleep-on-exit when returning from Handler mode to Thread mode.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Do not sleep when returning to Thread mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enter Sleep or Deep Sleep when returning from ISR to Thread mode.Setting this bit to 1 enables an interrupt driven application to avoid returning to an emptymain application</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SLEEPDEEP</name>
              <description>Processor Deep Sleep and Sleep Mode Selection\nControls whether the processor uses sleep or deep sleep as its low power mode:</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Sleep mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Deep Sleep mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SEVONPEND</name>
              <description>Send Event on Pending Bit\nWhen an event or interrupt enters pending state, the event signal wakes up the processorfrom WFE. If the processor is not waiting for an event, the event is registered and affectsthe next WFE.\nThe processor also wakes up on execution of an SEV instruction or an external event.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Only enabled interrupts or events can wake-up the processor, disabled interrupts areexcluded</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enabled events and all interrupts, including disabled interrupts, can wake-up theprocessor</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SHPR2</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SHPR2</displayName>
          <description>System Handler Priority Register 2</description>
          <addressOffset>0xD1C</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PRI_11</name>
              <description>Priority of System Handler 11 - SVCall\n"0" denotes the highest priority and "3" denotes the lowest priority.</description>
              <bitOffset>30</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SHPR3</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SHPR3</displayName>
          <description>System Handler Priority Register 3</description>
          <addressOffset>0xD20</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PRI_14</name>
              <description>Priority of System Handler 14 - PendSV\n"0" denotes the highest priority and "3" denotes the lowest priority.</description>
              <bitOffset>22</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PRI_15</name>
              <description>Priority of System Handler 15 - SysTick\n"0" denotes the highest priority and "3" denotes the lowest priority.</description>
              <bitOffset>30</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>INT</name>
      <description>SCS Register Map</description>
      <groupName>SCS</groupName>
      <baseAddress>0x50000300</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x0</offset>
        <size>0x88</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>IRQ0_SRC</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>IRQ0_SRC</displayName>
          <description>MCU IRQ0 (BOD_INT) interrupt source identify</description>
          <addressOffset>0x0</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>INT_SRC</name>
              <description>Interrupt Source\nDefine the interrupt sources for interrupt event.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="IRQ0_SRC">
          <name>IRQ1_SRC</name>
          <displayName>IRQ1_SRC</displayName>
          <description>MCU IRQ1 (BOD_INT) interrupt source identify</description>
          <addressOffset>0x4</addressOffset>
       </register>
       <register derivedFrom="IRQ0_SRC">
          <name>IRQ2_SRC</name>
          <displayName>IRQ2_SRC</displayName>
          <description>MCU IRQ2 (BOD_INT) interrupt source identify</description>
          <addressOffset>0x8</addressOffset>
       </register>
       <register derivedFrom="IRQ0_SRC">
          <name>IRQ3_SRC</name>
          <displayName>IRQ3_SRC</displayName>
          <description>MCU IRQ3 (BOD_INT) interrupt source identify</description>
          <addressOffset>0xC</addressOffset>
       </register>
       <register derivedFrom="IRQ0_SRC">
          <name>IRQ4_SRC</name>
          <displayName>IRQ4_SRC</displayName>
          <description>MCU IRQ4 (BOD_INT) interrupt source identify</description>
          <addressOffset>0x10</addressOffset>
       </register>
       <register derivedFrom="IRQ0_SRC">
          <name>IRQ5_SRC</name>
          <displayName>IRQ5_SRC</displayName>
          <description>MCU IRQ5 (BOD_INT) interrupt source identify</description>
          <addressOffset>0x14</addressOffset>
       </register>
       <register derivedFrom="IRQ0_SRC">
          <name>IRQ6_SRC</name>
          <displayName>IRQ6_SRC</displayName>
          <description>MCU IRQ6 (BOD_INT) interrupt source identify</description>
          <addressOffset>0x18</addressOffset>
       </register>
       <register derivedFrom="IRQ0_SRC">
          <name>IRQ7_SRC</name>
          <displayName>IRQ7_SRC</displayName>
          <description>MCU IRQ7 (BOD_INT) interrupt source identify</description>
          <addressOffset>0x1C</addressOffset>
       </register>
       <register derivedFrom="IRQ0_SRC">
          <name>IRQ8_SRC</name>
          <displayName>IRQ8_SRC</displayName>
          <description>MCU IRQ8 (BOD_INT) interrupt source identify</description>
          <addressOffset>0x20</addressOffset>
       </register>
       <register derivedFrom="IRQ0_SRC">
          <name>IRQ9_SRC</name>
          <displayName>IRQ9_SRC</displayName>
          <description>MCU IRQ9 (BOD_INT) interrupt source identify</description>
          <addressOffset>0x24</addressOffset>
       </register>
       <register derivedFrom="IRQ0_SRC">
          <name>IRQ10_SRC</name>
          <displayName>IRQ10_SRC</displayName>
          <description>MCU IRQ10 (BOD_INT) interrupt source identify</description>
          <addressOffset>0x28</addressOffset>
       </register>
       <register derivedFrom="IRQ0_SRC">
          <name>IRQ11_SRC</name>
          <displayName>IRQ11_SRC</displayName>
          <description>MCU IRQ11 (BOD_INT) interrupt source identify</description>
          <addressOffset>0x2C</addressOffset>
       </register>
       <register derivedFrom="IRQ0_SRC">
          <name>IRQ12_SRC</name>
          <displayName>IRQ12_SRC</displayName>
          <description>MCU IRQ12 (BOD_INT) interrupt source identify</description>
          <addressOffset>0x30</addressOffset>
       </register>
       <register derivedFrom="IRQ0_SRC">
          <name>IRQ13_SRC</name>
          <displayName>IRQ13_SRC</displayName>
          <description>MCU IRQ13 (BOD_INT) interrupt source identify</description>
          <addressOffset>0x34</addressOffset>
       </register>
       <register derivedFrom="IRQ0_SRC">
          <name>IRQ14_SRC</name>
          <displayName>IRQ14_SRC</displayName>
          <description>MCU IRQ14 (BOD_INT) interrupt source identify</description>
          <addressOffset>0x38</addressOffset>
       </register>
       <register derivedFrom="IRQ0_SRC">
          <name>IRQ15_SRC</name>
          <displayName>IRQ15_SRC</displayName>
          <description>MCU IRQ15 (BOD_INT) interrupt source identify</description>
          <addressOffset>0x3C</addressOffset>
       </register>
       <register derivedFrom="IRQ0_SRC">
          <name>IRQ16_SRC</name>
          <displayName>IRQ16_SRC</displayName>
          <description>MCU IRQ16 (BOD_INT) interrupt source identify</description>
          <addressOffset>0x40</addressOffset>
       </register>
       <register derivedFrom="IRQ0_SRC">
          <name>IRQ17_SRC</name>
          <displayName>IRQ17_SRC</displayName>
          <description>MCU IRQ17 (BOD_INT) interrupt source identify</description>
          <addressOffset>0x44</addressOffset>
       </register>
       <register derivedFrom="IRQ0_SRC">
          <name>IRQ18_SRC</name>
          <displayName>IRQ18_SRC</displayName>
          <description>MCU IRQ18 (BOD_INT) interrupt source identify</description>
          <addressOffset>0x48</addressOffset>
       </register>
       <register derivedFrom="IRQ0_SRC">
          <name>IRQ19_SRC</name>
          <displayName>IRQ19_SRC</displayName>
          <description>MCU IRQ19 (BOD_INT) interrupt source identify</description>
          <addressOffset>0x4C</addressOffset>
       </register>
       <register derivedFrom="IRQ0_SRC">
          <name>IRQ20_SRC</name>
          <displayName>IRQ20_SRC</displayName>
          <description>MCU IRQ20 (BOD_INT) interrupt source identify</description>
          <addressOffset>0x50</addressOffset>
       </register>
       <register derivedFrom="IRQ0_SRC">
          <name>IRQ21_SRC</name>
          <displayName>IRQ21_SRC</displayName>
          <description>MCU IRQ21 (BOD_INT) interrupt source identify</description>
          <addressOffset>0x54</addressOffset>
       </register>
       <register derivedFrom="IRQ0_SRC">
          <name>IRQ22_SRC</name>
          <displayName>IRQ22_SRC</displayName>
          <description>MCU IRQ22 (BOD_INT) interrupt source identify</description>
          <addressOffset>0x58</addressOffset>
       </register>
       <register derivedFrom="IRQ0_SRC">
          <name>IRQ23_SRC</name>
          <displayName>IRQ23_SRC</displayName>
          <description>MCU IRQ23 (BOD_INT) interrupt source identify</description>
          <addressOffset>0x5C</addressOffset>
       </register>
       <register derivedFrom="IRQ0_SRC">
          <name>IRQ24_SRC</name>
          <displayName>IRQ24_SRC</displayName>
          <description>MCU IRQ24 (BOD_INT) interrupt source identify</description>
          <addressOffset>0x60</addressOffset>
       </register>
       <register derivedFrom="IRQ0_SRC">
          <name>IRQ25_SRC</name>
          <displayName>IRQ25_SRC</displayName>
          <description>MCU IRQ25 (BOD_INT) interrupt source identify</description>
          <addressOffset>0x64</addressOffset>
       </register>
       <register derivedFrom="IRQ0_SRC">
          <name>IRQ26_SRC</name>
          <displayName>IRQ26_SRC</displayName>
          <description>MCU IRQ26 (BOD_INT) interrupt source identify</description>
          <addressOffset>0x68</addressOffset>
       </register>
       <register derivedFrom="IRQ0_SRC">
          <name>IRQ27_SRC</name>
          <displayName>IRQ27_SRC</displayName>
          <description>MCU IRQ27 (BOD_INT) interrupt source identify</description>
          <addressOffset>0x6C</addressOffset>
       </register>
       <register derivedFrom="IRQ0_SRC">
          <name>IRQ28_SRC</name>
          <displayName>IRQ28_SRC</displayName>
          <description>MCU IRQ28 (BOD_INT) interrupt source identify</description>
          <addressOffset>0x70</addressOffset>
       </register>
       <register derivedFrom="IRQ0_SRC">
          <name>IRQ29_SRC</name>
          <displayName>IRQ29_SRC</displayName>
          <description>MCU IRQ29 (BOD_INT) interrupt source identify</description>
          <addressOffset>0x74</addressOffset>
       </register>
       <register derivedFrom="IRQ0_SRC">
          <name>IRQ30_SRC</name>
          <displayName>IRQ30_SRC</displayName>
          <description>MCU IRQ30 (BOD_INT) interrupt source identify</description>
          <addressOffset>0x78</addressOffset>
       </register>
       <register derivedFrom="IRQ0_SRC">
          <name>IRQ31_SRC</name>
          <displayName>IRQ31_SRC</displayName>
          <description>MCU IRQ31 (BOD_INT) interrupt source identify</description>
          <addressOffset>0x7C</addressOffset>
       </register>
       <register>
          <name>NMI_SEL</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>NMI_SEL</displayName>
          <description>NMI Source Interrupt Select Control Register</description>
          <addressOffset>0x80</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>NMI_SEL</name>
              <description>NMI Interrupt to Cortex-M0 Can Be Selected From One of the Interrupt[31:0]\nThe NMI_SEL bit[4:0] is used to select the NMI interrupt source</description>
              <bitOffset>0</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>MCU_IRQ</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>MCU_IRQ</displayName>
          <description>MCU Interrupt Request Source Register</description>
          <addressOffset>0x84</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MCU_IRQ</name>
              <description>MCU IRQ Source Bits\nThe MCU_IRQ collects all the interrupts from the peripherals and generates the synchronous interrupt to MCU Cortex-M0. There are two modes to generate interrupt to Cortex-M0, the normal mode.\nThe MCU_IRQ collects all interrupts from each peripheral and synchronizes them and then interrupts the Cortex-M0.\nWhen the MCU_IRQ[n] is "0", setting MCU_IRQ[n] "1" will generate an interrupt to Cortex-M0 NVIC[n].\nWhen the MCU_IRQ[n] is "1" (means an interrupt is asserted), setting the MCU_bit[n] will clear the interrupt\nSet MCU_IRQ[n] "0": no any effect</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>SYS</name>
      <description>SYS Register Map</description>
      <groupName>SYS</groupName>
      <baseAddress>0x50000000</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x0</offset>
        <size>0x10</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x20</offset>
        <size>0x4</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x28</offset>
        <size>0x4</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x30</offset>
        <size>0x24</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x58</offset>
        <size>0x4</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x60</offset>
        <size>0x18</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x7C</offset>
        <size>0x10</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x90</offset>
        <size>0xC</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0xA0</offset>
        <size>0xC</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x100</offset>
        <size>0x4</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x120</offset>
        <size>0x4</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>SYS_PDID</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SYS_PDID</displayName>
          <description>Part Device Identification Number Register</description>
          <addressOffset>0x0</addressOffset>
          <access>read-only</access>
          <resetValue>0x00110000</resetValue>
          <resetMask>0xFFFF0000</resetMask>
          <fields>
            <field>
              <name>PDID</name>
              <description>Part Device Identification Number (Read Only)\nThis register reflects device part number code. Software can read this register to identify which device is used.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SYS_RSTSTS</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SYS_RSTSTS</displayName>
          <description>System Reset Status Register</description>
          <addressOffset>0x4</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFF00</resetMask>
          <fields>
            <field>
              <name>PORF</name>
              <description>POR Reset Flag\nThe POR reset flag is set by the "Reset Signal" from the Power-on Reset (POR) Controller or bit CHIPRST (SYS_IPRST0[0]) to indicate the previous reset source.\nNote: Write 1 to clear this bit to 0.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No reset from POR or CHIPRST</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Power-on Reset (POR) or CHIPRST had issued the reset signal to reset the system</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PINRF</name>
              <description>NRESET Pin Reset Flag\nThe nRESET pin reset flag is set by the "Reset Signal" from the nRESET Pin to indicate the previous reset source.\nNote: Write 1 to clear this bit to 0.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No reset from nRESET pin</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Pin nRESET had issued the reset signal to reset the system</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>WDTRF</name>
              <description>WDT Reset Flag\nThe WDT reset flag is set by the "Reset Signal" from the Watchdog Timer to indicate the previous reset source.\nNote: Write 1 to clear this bit to 0.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No reset from watchdog timer or window watchdog timer</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The watchdog timer had issued the reset signal to reset the system</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>LVRF</name>
              <description>LVR Reset Flag\nThe LVR reset flag is set by the "Reset Signal" from the Low-VoltageReset controller to indicate the previous reset source.\nNote: Write 1 to clear this bit to 0.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No reset from LVR</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The LVR had issued the reset signal to reset the system</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BODRF</name>
              <description>BOD Reset Flag\nThe BOD reset flag is set by the "Reset Signal" from the Brown-Out Detector to indicate the previous reset source.\nNote: Write 1 to clear this bit to 0.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No reset from BOD</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The BOD had issued the reset signal to reset the system</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SYSRF</name>
              <description>System Reset Flag\nThe system reset flag is set by the "Reset Signal" from the Cortex-M0 Core to indicate the previous reset source.\nNote: Write 1 to clear this bit to 0.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No reset from Cortex-M0</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The Cortex-M0 had issued the reset signal to reset the system by writing 1 to the bit SYSRESETREQ(AIRCR[2], Application Interrupt and Reset Control Register, address = 0xE000ED0C) in system control registers of Cortex-M0 core</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CPURF</name>
              <description>CPU Reset Flag\nThe CPU reset flag is set by hardware if software writes CPURST (SYS_IPRST0[1]) 1 to reset Cortex-M0 Core and Flash Memory Controller (FMC).\nNote: Write 1 to clear this bit to 0.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No reset from CPU</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The Cortex-M0 Core and FMC are reset by software setting CPURST to 1</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>LOCKRF</name>
              <description>Lockup Reset Flag</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No reset from Cortex-M0</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The Cortex-M0 had issued the reset signal to reset the system by Cortex-M0 lockup event</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SYS_IPRST1</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SYS_IPRST1</displayName>
          <description>Peripheral Reset Control Resister1</description>
          <addressOffset>0x8</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CHIPRST</name>
              <description>Chip One-shot Reset (Write Protect)\nSetting this bit will reset the whole chip, including Processor core and all peripherals, and this bit will automatically return to 0 after the 2 clock cycles.\nThe CHIPRST is same as the POR reset, all the chip controllers is reset and the chip setting from flash are also reload.\nAbout the difference between CHIPRST and SYSRESETREQ(AIRCR[2]), please refer to section 6.2.2\nNote:This bit is write protected. Refer to the SYS_REGLCTL register.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Chip normal operation</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Chip one-shot reset</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CPURST</name>
              <description>Processor Core One-shot Reset (Write Protect)\nSetting this bit will only reset the processor core and Flash Memory Controller(FMC), and this bit will automatically return to 0 after the 2 clock cycles.\nNote:This bit is write protected. Refer to the SYS_REGLCTL register.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Processor core normal operation</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Processor core one-shot reset</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PDMARST</name>
              <description>PDMA Controller Reset (Write Protect)\nSetting this bit to 1 will generate a reset signal to the PDMA. User needs to set this bit to 0 to release from reset state.\nNote:This bit is write protected. Refer to the SYS_REGLCTL register.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PDMA controller normal operation</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PDMA controllerreset</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SYS_IPRST2</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SYS_IPRST2</displayName>
          <description>Peripheral Reset Control Resister2</description>
          <addressOffset>0xC</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>GPIORST</name>
              <description>GPIO Controller Reset</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO module normal operation</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIO module reset</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TMR0RST</name>
              <description>Timer0 Controller Reset</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Timer0 module normal operation</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Timer0 module reset</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TMR1RST</name>
              <description>Timer1 Controller Reset</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Timer1 module normal operation</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Timer1 module reset</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TMR2RST</name>
              <description>Timer2 Controller Reset</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Timer2 module normal operation</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Timer2 module reset</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TMR3RST</name>
              <description>Timer3 Controller Reset</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Timer3 module normal operation</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Timer3 module reset</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DSRCRST</name>
              <description>DSRC Controller Reset</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>DSRCmodule normal operation</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>DSRCmodule reset</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C0RST</name>
              <description>I2C0 Controller Reset</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>I2C0 module normal operation</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>I2C0 module reset</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C1RST</name>
              <description>I2C1 Controller Reset</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>I2C1 module normal operation</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>I2C1 module reset</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SPI0RST</name>
              <description>SPI0 Controller Reset</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>SPI0 module normal operation</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>SPI0 module reset</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SPI1RST</name>
              <description>SPI1 Controller Reset</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>SPI1 module normal operation</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>SPI1 modulereset</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SPI2RST</name>
              <description>SPI2 Controller Reset</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>SPI2module normal operation</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>SPI2modulereset</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SPI3RST</name>
              <description>SPI3 Controller Reset</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>SPI3module normal operation</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>SPI3modulereset</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>UART0RST</name>
              <description>UART0 Controller Reset</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>UART0 module normal operation</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>UART0 module reset</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>UART1RST</name>
              <description>UART1 Controller Reset</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>UART1 module normal operation</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>UART1 module reset</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PWM0RST</name>
              <description>PWM0 Controller Reset</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM0 module normal operation</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PWM0 module reset</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ACMP01RST</name>
              <description>Comparator Controller Reset</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Comparatormodule normal operation</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Comparatormodule reset</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ADCRST</name>
              <description>ADC Controller Reset</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>ADC module normal operation</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>ADC module reset</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SC0RST</name>
              <description>SmartCard0 Controller Reset</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>SmartCardmodule normal operation</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>SmartCardmodule reset</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SC1RST</name>
              <description>SmartCard1 Controller Reset</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>SmartCardmodule normal operation</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>SmartCardmodule reset</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SYS_TEMPCTL</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SYS_TEMPCTL</displayName>
          <description>Temperature Sensor Control Register</description>
          <addressOffset>0x20</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>VTEMPEN</name>
              <description>Temperature Sensor Enable Bit\nThis bit is used to enable/disable temperature sensor function.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Temperature sensor function Disabled (default)</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Temperature sensor function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SYS_RCCFCTL</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SYS_RCCFCTL</displayName>
          <description>RC Clock Filter Control Register</description>
          <addressOffset>0x28</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000007</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>HIRC0FEN</name>
              <description>HIRC0 Clock Filter Enable Bit\nThis bit is used to enable/disable HIRC0clock filter function.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>HIRC0clock filter function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>HIRC0clock filter function Enabled (default)</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>HIRC1FEN</name>
              <description>HIRC1 Clock Filter Enable Bit\nThis bit is used to enable/disable HIRC1clock filter function.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>HIRC1clock filter function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>HIRC1clock filter function Enabled (default)</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>MRCFEN</name>
              <description>MRC Clock Filter Enable Bit\nThis bit is used to enable/disable MRC clock filter function.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>4MHz MRC clock filter function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>4MHz MRC clock filter function Enabled (default)</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SYS_GPA_MFPL</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SYS_GPA_MFPL</displayName>
          <description>GPIOA Low Byte Multiple Function Control Register</description>
          <addressOffset>0x30</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PA0MFP</name>
              <description>PA.0 Multi-function Pin Selection</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIOA[0]</description>
                    <value>#0000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>ADC analog input0</description>
                    <value>#0001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Comparator1 P-end input</description>
                    <value>#0010</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Timer0 capture input</description>
                    <value>#0011</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>5</name>
                    <description>PWM0 channel2 output/capture input</description>
                    <value>#0101</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PA1MFP</name>
              <description>PA.1 Multi-function Pin Selection</description>
              <bitOffset>4</bitOffset>
              <bitWidth>4</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIOA[1]</description>
                    <value>#0000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>ADC analog input1</description>
                    <value>#0001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Comparator1 N-end input</description>
                    <value>#0010</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>6</name>
                    <description>SPI0 2ndMISO (Master In, Slave Out) pin</description>
                    <value>#0110</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PA2MFP</name>
              <description>PA.2 Multi-function Pin Selection</description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIOA[2]</description>
                    <value>#0000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>ADC analog input2</description>
                    <value>#0001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>5</name>
                    <description>Data receiver input pin for UART1</description>
                    <value>#0101</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PA3MFP</name>
              <description>PA.3 Multi-function Pin Selection</description>
              <bitOffset>12</bitOffset>
              <bitWidth>4</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIOA[3]</description>
                    <value>#0000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>ADC analog input3</description>
                    <value>#0001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>5</name>
                    <description>Data transmitter output pin for UART1</description>
                    <value>#0101</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>6</name>
                    <description>SPI31stMOSI (Master Out, Slave In) pin</description>
                    <value>#0110</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PA4MFP</name>
              <description>PA.4 Multi-function Pin Selection</description>
              <bitOffset>16</bitOffset>
              <bitWidth>4</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIOA[4]</description>
                    <value>#0000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>ADC analog input4</description>
                    <value>#0001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>5</name>
                    <description>I2C0 data input/output pin</description>
                    <value>#0101</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>6</name>
                    <description>SPI31stMISO (Master In, Slave Out) pin</description>
                    <value>#0110</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PA5MFP</name>
              <description>PA.5 Multi-function Pin Selection</description>
              <bitOffset>20</bitOffset>
              <bitWidth>4</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIOA[5]</description>
                    <value>#0000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>ADC analog input5</description>
                    <value>#0001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>5</name>
                    <description>I2C0 clock pin</description>
                    <value>#0101</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>6</name>
                    <description>SPI3 serial clock pin</description>
                    <value>#0110</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PA6MFP</name>
              <description>PA.6 Multi-function Pin Selection</description>
              <bitOffset>24</bitOffset>
              <bitWidth>4</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIOA[6]</description>
                    <value>#0000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>ADC analog input6</description>
                    <value>#0001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Comparator1 output</description>
                    <value>#0010</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Timer3 capture input</description>
                    <value>#0011</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>4</name>
                    <description>Timer3 external counter input</description>
                    <value>#0100</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>5</name>
                    <description>PWM0 channel3 output/capture input</description>
                    <value>#0101</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>7</name>
                    <description>Timer3 toggle output</description>
                    <value>#0111</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SYS_GPA_MFPH</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SYS_GPA_MFPH</displayName>
          <description>GPIOA High Byte Multiple Function Control Register</description>
          <addressOffset>0x34</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PA8MFP</name>
              <description>PA.8 Multi-function Pin Selection</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIOA[8]</description>
                    <value>#0000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>I2C0 data input/output pin</description>
                    <value>#0001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Timer0 external counter input</description>
                    <value>#0010</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>SmartCard0 clock pin</description>
                    <value>#0011</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>4</name>
                    <description>SPI2 slave select pin</description>
                    <value>#0100</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>5</name>
                    <description>Timer0 toggle output</description>
                    <value>#0101</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>6</name>
                    <description>UART0 Clear to Send input pin</description>
                    <value>#0110</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PA9MFP</name>
              <description>PA.9 Multi-function Pin Selection</description>
              <bitOffset>4</bitOffset>
              <bitWidth>4</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIOA[9]</description>
                    <value>#0000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>I2C0 clock pin</description>
                    <value>#0001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Timer1 external counter input</description>
                    <value>#0010</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>SmartCard0 data pin</description>
                    <value>#0011</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>4</name>
                    <description>SPI0 serial clock pin</description>
                    <value>#0100</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>5</name>
                    <description>Timer1 toggle output</description>
                    <value>#0101</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>6</name>
                    <description>UART1 Request to Send output pin</description>
                    <value>#0110</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>7</name>
                    <description>Snooper pin</description>
                    <value>#0111</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PA10MFP</name>
              <description>PA.10 Multi-function Pin Selection</description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIOA[10]</description>
                    <value>#0000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>I2C1 data input/output pin</description>
                    <value>#0001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Timer2 external counter input</description>
                    <value>#0010</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>SmartCard0 power pin</description>
                    <value>#0011</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>4</name>
                    <description>SPI21stMISO (Master In, Slave Out) pin</description>
                    <value>#0100</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>5</name>
                    <description>Timer2 toggle output</description>
                    <value>#0101</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PA11MFP</name>
              <description>PA.11 Multi-function Pin Selection</description>
              <bitOffset>12</bitOffset>
              <bitWidth>4</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIOA[11]</description>
                    <value>#0000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>I2C1 clock pin</description>
                    <value>#0001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Timer3 external counter input</description>
                    <value>#0010</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>SmartCard0 reset pin</description>
                    <value>#0011</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>4</name>
                    <description>SPI21stMOSI (Master Out, Slave In) pin</description>
                    <value>#0100</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>5</name>
                    <description>Timer3 toggle output</description>
                    <value>#0101</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PA12MFP</name>
              <description>PA.12  Multi-function Pin Selection</description>
              <bitOffset>16</bitOffset>
              <bitWidth>4</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIOA[12]</description>
                    <value>#0000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PWM0 channel0 output/capture input</description>
                    <value>#0001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Timer0 capture input</description>
                    <value>#0011</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>5</name>
                    <description>I2C0 data input/output pin</description>
                    <value>#0101</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PA13MFP</name>
              <description>PA.13  Multi-function Pin Selection</description>
              <bitOffset>20</bitOffset>
              <bitWidth>4</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIOA[13]</description>
                    <value>#0000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PWM0 channel1 output/capture input</description>
                    <value>#0001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Timer1 capture input</description>
                    <value>#0011</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>5</name>
                    <description>I2C0 clock pin</description>
                    <value>#0101</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PA14MFP</name>
              <description>PA.14  Multi-function Pin Selection</description>
              <bitOffset>24</bitOffset>
              <bitWidth>4</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIOA[14]</description>
                    <value>#0000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PWM0 channel2 output/capture input</description>
                    <value>#0001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>I2C1 data input/output pin</description>
                    <value>#0010</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>I2C1 data input/output pin</description>
                    <value>#0011</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>5</name>
                    <description>Timer2 external counter input</description>
                    <value>#0101</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>6</name>
                    <description>Data receiver input pin for UART0</description>
                    <value>#0110</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>7</name>
                    <description>Timer2 toggle output</description>
                    <value>#0111</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PA15MFP</name>
              <description>PA.15  Multi-function Pin Selection</description>
              <bitOffset>28</bitOffset>
              <bitWidth>4</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIOA[15]</description>
                    <value>#0000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PWM0 channel3 output/capture input</description>
                    <value>#0001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>I2C1 clock pin</description>
                    <value>#0010</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Timer1 capture input</description>
                    <value>#0011</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>4</name>
                    <description>SmartCard0 power pin</description>
                    <value>#0100</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>6</name>
                    <description>Data transmitter output pin for UART0</description>
                    <value>#0110</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>7</name>
                    <description>Timer3 toggle output</description>
                    <value>#0111</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SYS_GPB_MFPL</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SYS_GPB_MFPL</displayName>
          <description>GPIOB Low Byte Multiple Function Control Register</description>
          <addressOffset>0x38</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PB0MFP</name>
              <description>PB.0 Multi-function Pin Selection</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIOB[0]</description>
                    <value>#0000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Data receiver input pin for UART0</description>
                    <value>#0001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>SPI11stMOSI (Master Out, Slave In) pin</description>
                    <value>#0011</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PB1MFP</name>
              <description>PB.1 Multi-function Pin Selection</description>
              <bitOffset>4</bitOffset>
              <bitWidth>4</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIOB[1]</description>
                    <value>#0000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Data transmitter output pin for UART0</description>
                    <value>#0001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>SPI11stMISO (Master In, Slave Out) pin</description>
                    <value>#0011</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PB2MFP</name>
              <description>PB.2 Multi-function Pin Selection</description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIOB[2]</description>
                    <value>#0000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>UART0 Request to Send output pin</description>
                    <value>#0001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>SPI1 serial clock pin</description>
                    <value>#0011</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>4</name>
                    <description>Frequency Divider output pin</description>
                    <value>#0100</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PB3MFP</name>
              <description>PB.3 Multi-function Pin Selection</description>
              <bitOffset>12</bitOffset>
              <bitWidth>4</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIOB[3]</description>
                    <value>#0000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>UART0 Clear to Send input pin</description>
                    <value>#0001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>SPI1 slave select pin</description>
                    <value>#0011</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>4</name>
                    <description>SmartCard1 card detect pin</description>
                    <value>#0100</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PB4MFP</name>
              <description>PB.4 Multi-function Pin Selection</description>
              <bitOffset>16</bitOffset>
              <bitWidth>4</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIOB[4]</description>
                    <value>#0000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Data receiver input pin for UART1</description>
                    <value>#0001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>SmartCard0 card detect pin</description>
                    <value>#0011</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>4</name>
                    <description>SPI2 slave select pin</description>
                    <value>#0100</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>6</name>
                    <description>RTC 1Hz output</description>
                    <value>#0110</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PB5MFP</name>
              <description>PB.5 Multi-function Pin Selection</description>
              <bitOffset>20</bitOffset>
              <bitWidth>4</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIOB[5]</description>
                    <value>#0000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Data transmitter output pin for UART1</description>
                    <value>#0001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>SmartCard0 reset pin</description>
                    <value>#0011</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>4</name>
                    <description>SPI2 serial clock pin</description>
                    <value>#0100</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PB6MFP</name>
              <description>PB.6 Multi-function Pin Selection</description>
              <bitOffset>24</bitOffset>
              <bitWidth>4</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIOB[6]</description>
                    <value>#0000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>UART1 Request to Send output pin</description>
                    <value>#0001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>4</name>
                    <description>SPI21stMISO (Master In, Slave Out) pin</description>
                    <value>#0100</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PB7MFP</name>
              <description>PB.7 Multi-function Pin Selection</description>
              <bitOffset>28</bitOffset>
              <bitWidth>4</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIOB[7]</description>
                    <value>#0000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>UART1 Clear to Send input pin</description>
                    <value>#0001</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SYS_GPB_MFPH</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SYS_GPB_MFPH</displayName>
          <description>GPIOB High Byte Multiple Function Control Register</description>
          <addressOffset>0x3C</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PB8MFP</name>
              <description>PB.8 Multi-function Pin Selection</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIOB[8]</description>
                    <value>#0000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>ADC external trigger input</description>
                    <value>#0001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Timer0 external counter input</description>
                    <value>#0010</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>External interrupt0 input pin</description>
                    <value>#0011</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>4</name>
                    <description>Timer0 toggle output</description>
                    <value>#0100</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>7</name>
                    <description>Snooper pin</description>
                    <value>#0111</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PB9MFP</name>
              <description>PB.9 Multi-function Pin Selection</description>
              <bitOffset>4</bitOffset>
              <bitWidth>4</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIOB[9]</description>
                    <value>#0000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>SPI1 slave select pin</description>
                    <value>#0001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Timer2 external counter input</description>
                    <value>#0010</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>4</name>
                    <description>Timer2 toggle output</description>
                    <value>#0100</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>5</name>
                    <description>External interrupt0 input pin</description>
                    <value>#0101</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PB10MFP</name>
              <description>PB.10 Multi-function Pin Selection</description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIOB[10]</description>
                    <value>#0000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>SPI0 1stMOSI (Master Out, Slave In) pin</description>
                    <value>#0001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>4</name>
                    <description>Timer2 toggle output</description>
                    <value>#0100</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>5</name>
                    <description>SPI0 slave select pin</description>
                    <value>#0101</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PB11MFP</name>
              <description>PB.11 Multi-function Pin Selection</description>
              <bitOffset>12</bitOffset>
              <bitWidth>4</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIOB[11]</description>
                    <value>#0000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PWM0 channel4 output/capture input</description>
                    <value>#0001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Timer3 external counter input</description>
                    <value>#0010</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>4</name>
                    <description>Timer3 toggle output</description>
                    <value>#0100</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>5</name>
                    <description>SPI0 1stMISO (Master In, Slave Out) pin</description>
                    <value>#0101</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PB13MFP</name>
              <description>PB.13 Multi-function Pin Selection</description>
              <bitOffset>20</bitOffset>
              <bitWidth>4</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIOB[13]</description>
                    <value>#0000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>SPI22ndMISO (Master In, Slave Out) pin</description>
                    <value>#0011</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>7</name>
                    <description>Snooper pin</description>
                    <value>#0111</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PB14MFP</name>
              <description>PB.14 Multi-function Pin Selection</description>
              <bitOffset>24</bitOffset>
              <bitWidth>4</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIOB[14]</description>
                    <value>#0000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>External interrupt0 input pin</description>
                    <value>#0001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>SPI22ndMOSI (Master Out, Slave In) pin</description>
                    <value>#0011</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>4</name>
                    <description>SPI2 slave select pin</description>
                    <value>#0100</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PB15MFP</name>
              <description>PB.15 Multi-function Pin Selection</description>
              <bitOffset>28</bitOffset>
              <bitWidth>4</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIOB[15]</description>
                    <value>#0000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>External interrupt1 input pin</description>
                    <value>#0001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Snooper pin</description>
                    <value>#0011</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>4</name>
                    <description>SmartCard1 card detect pin</description>
                    <value>#0100</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SYS_GPC_MFPL</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SYS_GPC_MFPL</displayName>
          <description>GPIOC Low Byte Multiple Function Control Register</description>
          <addressOffset>0x40</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PC0MFP</name>
              <description>PC.0 Multi-function Pin Selection</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIOC[0]</description>
                    <value>#0000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>SPI0 slave select pin</description>
                    <value>#0001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>4</name>
                    <description>SmartCard1 clock pin</description>
                    <value>#0100</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>5</name>
                    <description>PWM0 break1 input 1</description>
                    <value>#0101</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PC1MFP</name>
              <description>PC.1 Multi-function Pin Selection</description>
              <bitOffset>4</bitOffset>
              <bitWidth>4</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIOC[1]</description>
                    <value>#0000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>SPI0 serial clock pin</description>
                    <value>#0001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>4</name>
                    <description>SmartCard1 data pin</description>
                    <value>#0100</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>5</name>
                    <description>PWM0 break1 input 0</description>
                    <value>#0101</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PC2MFP</name>
              <description>PC.2 Multi-function Pin Selection</description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIOC[2]</description>
                    <value>#0000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>SPI0 1st MISO (Master In, Slave Out) pin</description>
                    <value>#0001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>4</name>
                    <description>SmartCard1 power pin</description>
                    <value>#0100</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>5</name>
                    <description>PWM0 break0 input 1</description>
                    <value>#0101</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PC3MFP</name>
              <description>PC.3 Multi-function Pin Selection</description>
              <bitOffset>12</bitOffset>
              <bitWidth>4</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIOC[3]</description>
                    <value>#0000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>SPI0 1stMOSI (Master Out, Slave In) pin</description>
                    <value>#0001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>4</name>
                    <description>SmartCard1 reset pin</description>
                    <value>#0100</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>5</name>
                    <description>PWM0 break0 input 0</description>
                    <value>#0101</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PC6MFP</name>
              <description>PC.6 Pin Fuction Selection</description>
              <bitOffset>24</bitOffset>
              <bitWidth>4</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIOC[6]</description>
                    <value>#0000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Data receiver input pin for UART1</description>
                    <value>#0001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Timer0 capture input</description>
                    <value>#0011</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>4</name>
                    <description>SmartCard1 card detect pin</description>
                    <value>#0100</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>5</name>
                    <description>PWM0 channel0 output/capture input</description>
                    <value>#0101</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PC7MFP</name>
              <description>PC.7 Multi-function Pin Selection</description>
              <bitOffset>28</bitOffset>
              <bitWidth>4</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIOC[7]</description>
                    <value>#0000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Data transmitter output pin for UART1</description>
                    <value>#0001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>ADC analog input7</description>
                    <value>#0010</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Timer1 capture input</description>
                    <value>#0011</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>5</name>
                    <description>PWM0 channel1 output/capture input</description>
                    <value>#0101</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SYS_GPC_MFPH</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SYS_GPC_MFPH</displayName>
          <description>GPIOC High Byte Multiple Function Control Register</description>
          <addressOffset>0x44</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PC8MFP</name>
              <description>PC.8 Multi-function Pin Selection</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIOC[8]</description>
                    <value>#0000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>SPI1 slave select pin</description>
                    <value>#0001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>5</name>
                    <description>I2C1 data input/output pin</description>
                    <value>#0101</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PC9MFP</name>
              <description>PC.9 Multi-function Pin Selection</description>
              <bitOffset>4</bitOffset>
              <bitWidth>4</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIOC[9]</description>
                    <value>#0000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>SPI1 serial clock pin</description>
                    <value>#0001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>5</name>
                    <description>I2C1 clock pin</description>
                    <value>#0101</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PC10MFP</name>
              <description>PC.10 Multi-function Pin Selection</description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIOC[10]</description>
                    <value>#0000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>SPI0 1stMISO (Master In, Slave Out) pin</description>
                    <value>#0001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>5</name>
                    <description>Data receiver input pin for UART1</description>
                    <value>#0101</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PC11MFP</name>
              <description>PC.11 Multi-function Pin Selection</description>
              <bitOffset>12</bitOffset>
              <bitWidth>4</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIOC[11]</description>
                    <value>#0000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>SPI1 1stMOSI (Master Out, Slave In) pin</description>
                    <value>#0001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>5</name>
                    <description>Data transmitter output pin for UART1</description>
                    <value>#0101</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PC14MFP</name>
              <description>PC.14 Multi-function Pin Selection</description>
              <bitOffset>24</bitOffset>
              <bitWidth>4</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIOC[14]</description>
                    <value>#0000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>UART0 Clear to Send input pin</description>
                    <value>#0001</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PC15MFP</name>
              <description>PC.15 Multi-function Pin Selection</description>
              <bitOffset>28</bitOffset>
              <bitWidth>4</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIOC[15]</description>
                    <value>#0000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>UART1 Request to Send output pin</description>
                    <value>#0001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Timer0 capture input</description>
                    <value>#0011</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SYS_GPD_MFPL</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SYS_GPD_MFPL</displayName>
          <description>GPIOD Low Byte Multiple Function Control Register</description>
          <addressOffset>0x48</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PD6MFP</name>
              <description>PD.6 Multi-function Pin Selection</description>
              <bitOffset>24</bitOffset>
              <bitWidth>4</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIOD[6]</description>
                    <value>#0000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>SPI12ndMOSI (Master Out, Slave In) pin</description>
                    <value>#0011</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>4</name>
                    <description>SmartCard1 reset pin</description>
                    <value>#0100</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PD7MFP</name>
              <description>PD.7 Multi-function Pin Selection</description>
              <bitOffset>28</bitOffset>
              <bitWidth>4</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIOD[7]</description>
                    <value>#0000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>SPI12ndMISO (Master In, Slave Out) pin</description>
                    <value>#0011</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>4</name>
                    <description>SmartCard1 power pin</description>
                    <value>#0100</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SYS_GPD_MFPH</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SYS_GPD_MFPH</displayName>
          <description>GPIOD High Byte Multiple Function Control Register</description>
          <addressOffset>0x4C</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PD14MFP</name>
              <description>PD.14 Multi-function Pin Selection</description>
              <bitOffset>24</bitOffset>
              <bitWidth>4</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIOD[14]</description>
                    <value>#0000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>SPI0 2ndMOSI (Master Out, Slave In) pin</description>
                    <value>#0001</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PD15MFP</name>
              <description>PD.15 Multi-function Pin Selection</description>
              <bitOffset>28</bitOffset>
              <bitWidth>4</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIOD[15]</description>
                    <value>#0000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>SPI0 2ndMISO (Master In, Slave Out) pin</description>
                    <value>#0001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>100</name>
                    <description>SmartCard1 clock pin</description>
                    <value>#0100</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SYS_GPE_MFPL</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SYS_GPE_MFPL</displayName>
          <description>GPIOE Low Byte Multiple Function Control Register</description>
          <addressOffset>0x50</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PE5MFP</name>
              <description>PE.5 Multi-function Pin Selection</description>
              <bitOffset>20</bitOffset>
              <bitWidth>4</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIOE[5]</description>
                    <value>#0000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PWM0 channel5 output/capture input</description>
                    <value>#0001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>6</name>
                    <description>RTC 1Hz output</description>
                    <value>#0110</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SYS_GPF_MFPL</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SYS_GPF_MFPL</displayName>
          <description>GPIOF Low Byte Multiple Function Control Register</description>
          <addressOffset>0x58</addressOffset>
          <access>read-write</access>
          <resetValue>0xFFFFFFFF</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PF0MFP</name>
              <description>PF.0 Multi-function Pin Selection</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIOF[1].\nSerial wired debugger data pin</description>
                    <value>#0000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>5</name>
                    <description>External interrupt0 input pin</description>
                    <value>#0101</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PF1MFP</name>
              <description>PF.1 Multi-function Pin Selection</description>
              <bitOffset>4</bitOffset>
              <bitWidth>4</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIOF[1].\nSerial wired debugger clock pin</description>
                    <value>#0000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>4</name>
                    <description>Frequency Divider output pin</description>
                    <value>#0100</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>5</name>
                    <description>External interrupt1 input pin</description>
                    <value>#0101</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PF2MFP</name>
              <description>PF.2 Multi-function Pin Selection</description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIOF[2].\nExternal 4~36 MHz (high speed) crystal output pin</description>
                    <value>#0000</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PF3MFP</name>
              <description>PF.3 Multi-function Pin Selection</description>
              <bitOffset>12</bitOffset>
              <bitWidth>4</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIOF[3].\nExternal 4~36 MHz (high speed) crystal input pin</description>
                    <value>#0000</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PF6MFP</name>
              <description>PF.6 Multi-function Pin Selection</description>
              <bitOffset>24</bitOffset>
              <bitWidth>4</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIOF[6].\nExternal 32.768 kHz crystal output pin(default)</description>
                    <value>#0000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>I2C1 data input/output pin</description>
                    <value>#0001</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PF7MFP</name>
              <description>PF.7 Multi-function Pin Selection</description>
              <bitOffset>28</bitOffset>
              <bitWidth>4</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIOF[7].\nExternal 32.768 kHz crystal input pin(default)</description>
                    <value>#0000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>I2C1 clock pin</description>
                    <value>#0001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>SmartCard0 card detect pin</description>
                    <value>#0011</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SYS_PORCTL</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SYS_PORCTL</displayName>
          <description>Power-on-Reset Controller Register</description>
          <addressOffset>0x60</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>POROFF</name>
              <description>Power-on Reset Enable Bit (Write Protect)\nWhen powered on, the POR circuit generates a reset signal to reset the whole chip function, but noise on the power may cause the POR active again. User can disable internal POR circuit to avoid unpredictable noise to cause chip reset by writing 0x5AA5 to this field.\nThe POR function will be active again when this field is set to another value or chip is reset by other reset source, including:\nnRESET, Watchdog, BOD reset, ICE reset command and the software-chip reset function.\nNote:This bit is write protected. Refer to the SYS_REGLCTL register.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SYS_BODCTL</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SYS_BODCTL</displayName>
          <description>Brown-out Detector Controller Register</description>
          <addressOffset>0x64</addressOffset>
          <access>read-write</access>
          <resetValue>0x03000000</resetValue>
          <resetMask>0xFF000F00</resetMask>
          <fields>
            <field>
              <name>BODEN</name>
              <description>Brown-out Detector Enable Bit (Write Protect)\nThe default value is set by flash controller user configuration register CBODEN (CONFIG0 []).This Brown-out Detecto only valid in Normal Mode.\nNote1: This bit is write protected. Refer to the SYS_REGLCTL register.\nNote2: LIRC must be enabled before enable BOD.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Brown-out Detector function Disabled in Normal mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Brown-out Detector function Enabled in Normal mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BODIE</name>
              <description>BOD Interrupt Enable Control(Write Protect)\nNote1: While the BOD function is enabled (BODEN high) and BOD interrupt function is enabled (BODRSTEN low), BOD will assert an interrupt if BODOUT is high.\nNote2: This bit is write protected. Refer to the SYS_REGLCTL register.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Interrupt does not issue when BOD occurs in Normal Mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Interrupt issues when BOD occursi in Normal Mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BODREN</name>
              <description>Brown-out Reset Enable Bit (Write Protect)\nThe default value is set by flash controller user configuration register CBOV(CONFIG0[]) bit.\nNote1: While the Brown-out Detector function is enabled (BODEN high) and BOD reset function is enabled (BODRSTEN high), BOD will assert a signal to reset chip when the detected voltage is lower than the threshold (BODOUT high).\nNote2: This bit is write protected. Refer to the SYS_REGLCTL register.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Brown-out "RESET" function Disabled in Normal Mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Brown-out "RESET" function Enabled in Normal Mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BODIF</name>
              <description>Brown-out DetectorInterrupt Flag\nNote: Write 1 to clear this bit to 0.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Brown-out Detector does not detect any voltage drift at VDD down through or up through the target detected voltage after interrupt is enabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>When Brown-out Detectordetects the VDD is dropped down through the target detected voltage or the VDD is raised up through the target detected voltage, this bit is set to 1 and the brown-out interrupt is requested if brown-out interrupt is enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BODOUT</name>
              <description>Brown-out DetectorOutuput Status\nIt means the detected voltage is lower than BODVL setting. If the BODEN is 0, BOD function disabled , this bit always responds 0.\nNote: This bit is ready-only.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Brown-out Detector output status is 0</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Brown-out Detector output status is 1</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>LVREN</name>
              <description>Low Voltage Reset Enable Bit (Write Protect)\nThe LVR function resets the chip when the input power voltage is lower than LVR circuit setting. LVR function is enabled by default.\nNote1: After enabling the bit, the LVR function will be active with 100us delay for LVR output stable (default).\nNote2: This bit is write protected. Refer to the SYS_REGLCTL register.\nNote3: LIRC must be enabled before enable LVR.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Low Voltage Reset function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Low Voltage Reset function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>LPBODEN</name>
              <description>Low Power Brown-out Detector Enable Bit (Write Protect)\nLow Power Brown-out Dector only valid in Power-down mode.\nNote1: This bit is write protected. Refer to the SYS_REGLCTL register.\nNote2: LIRC must be enabled before enable BOD.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Low Power Brown-out Detector function Disabled in Power-down mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Low Power Brown-out Detector function Enabled in Power-down mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>LPBODVL</name>
              <description>Low Power Brown-out Detector Threshold Voltage Selection(Write Protect)\nLow Power Brown-out Dector only valid in Power-down mode.\nNote1: This bit is write protected. Refer to the SYS_REGLCTL register.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Low Power Brown-Out Detector threshold voltageis 2.0V in Power-down mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Low Power Brown-Out Detector threshold voltageis 2.5V in Power-down mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>LPBODIE</name>
              <description>Low Power BOD Interrupt Enable Control(Write Protect)\nLow Power Brown-out Dector only valid in Power-down mode.\nNote1: While the LPBOD function is enabled (LPBODEN high) and LPBOD interrupt function is enabled (LPBODIEhigh), LPBOD will assert an interrupt if BODOUT is high. Note2: This bit is write protected. Refer to the SYS_REGLCTL register.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Interrupt does not issue when LPBOD occurs in Power-down mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Interrupt issues when LPBOD occurs in Power-down mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>LPBODREN</name>
              <description>Low Power Brown-out Reset Enable Bit (Write Protect)\nLow Power Brown-out Dector only valid in Power-down mode.\nNote1: While the Low power Brown-out Detector function is enabled (LPBODEN high) and LPBOD reset function is enabled (LPBODREN high), LPBOD will assert a signal to reset chip when the detected voltage is lower than the threshold (BODOUT high).\nNote2: This bit is write protected. Refer to the SYS_REGLCTL register.</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Low power Brown-out dector "RESET" function Disabled in Power-down mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Low Power Brown-out dector "RESET" function Enabled in Power-down mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BODVL</name>
              <description>Brown-out Detector Threshold Voltage Selection (Write Protect)\nThe default value is set by flash controller user configuration register CBOV (CONFIG0[]).\nNote: This bit is write protected. Refer to the SYS_REGLCTL register.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>4</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Brown-Out Detector threshold voltageis 1.7V</description>
                    <value>#0000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Brown-Out Detector threshold voltageis 1.8V</description>
                    <value>#0001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Brown-Out Detector threshold voltageis 1.9V</description>
                    <value>#0010</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Brown-Out Detector threshold voltageis 2.0V</description>
                    <value>#0011</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>4</name>
                    <description>Brown-Out Detector threshold voltageis 2.1V</description>
                    <value>#0100</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>5</name>
                    <description>Brown-Out Detector threshold voltageis 2.2V</description>
                    <value>#0101</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>6</name>
                    <description>Brown-Out Detector threshold voltageis 2.3V</description>
                    <value>#0110</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>7</name>
                    <description>Brown-Out Detector threshold voltageis 2.4V</description>
                    <value>#0111</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>8</name>
                    <description>Brown-Out Detector threshold voltageis 2.5V</description>
                    <value>#1000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>9</name>
                    <description>Brown-Out Detector threshold voltageis 2.6V</description>
                    <value>#1001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>10</name>
                    <description>Brown-Out Detector threshold voltageis 2.7V</description>
                    <value>#1010</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>11</name>
                    <description>Brown-Out Detector threshold voltageis 2.8V</description>
                    <value>#1011</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>12</name>
                    <description>Brown-Out Detector threshold voltageis 2.9V</description>
                    <value>#1100</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>13</name>
                    <description>Brown-Out Detector threshold voltageis 3.0V</description>
                    <value>#1101</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>14</name>
                    <description>Brown-Out Detector threshold voltageis 3.1V</description>
                    <value>#1110</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>15</name>
                    <description>Reserved</description>
                    <value>#1111</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>LPBOD20TRIM</name>
              <description>Low Power BOD 2.0 TRIM Value(Write Protect)\nThis value is used to control BOD20 detect voltage level in power-down mode, nominal 2.0 V.  Higher trim value, higher detection voltage.\nNote: These bits are write protected. Refer to the SYS_REGLCTL register.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>LPBOD25TRIM</name>
              <description>Low Power BOD 2.5 TRIM Value(Write Protect)\nThis value is used to control LPBOD25 detect voltage level in power-down mode, nominal 2.5 V.  Higher trim value, higher detection voltage.\nNote: These bits are write protected. Refer to the SYS_REGLCTL register.</description>
              <bitOffset>20</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>BODDGSEL</name>
              <description>Brown-out Detector Output De-glitch Time Select (Write Protect)\nNote: These bits are write protected. Refer to the SYS_REGLCTL register.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>3</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>BOD output is sampled by RC10K clock</description>
                    <value>#000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>4 system clock (HCLK)</description>
                    <value>#001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>8 system clock (HCLK)</description>
                    <value>#010</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>16 system clock (HCLK)</description>
                    <value>#011</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>4</name>
                    <description>32 system clock (HCLK)</description>
                    <value>#100</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>5</name>
                    <description>64 system clock (HCLK)</description>
                    <value>#101</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>6</name>
                    <description>128 system clock (HCLK)</description>
                    <value>#110</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>7</name>
                    <description>256 system clock (HCLK)</description>
                    <value>#111</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>LVRDGSEL</name>
              <description>LVR Output De-glitch Time Select (Write Protect)\nNote: These bits are write protected. Refer to the SYS_REGLCTL register.</description>
              <bitOffset>28</bitOffset>
              <bitWidth>3</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Without de-glitch function</description>
                    <value>#000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>4 system clock (HCLK)</description>
                    <value>#001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>8 system clock (HCLK)</description>
                    <value>#010</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>16 system clock (HCLK)</description>
                    <value>#011</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>4</name>
                    <description>32 system clock (HCLK)</description>
                    <value>#100</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>5</name>
                    <description>64 system clock (HCLK)</description>
                    <value>#101</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>6</name>
                    <description>128 system clock (HCLK)</description>
                    <value>#110</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>7</name>
                    <description>256 system clock (HCLK)</description>
                    <value>#111</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SYS_BODSTS</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SYS_BODSTS</displayName>
          <description>Brown-out Detector Status Register</description>
          <addressOffset>0x68</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
          </fields>
       </register>
       <register>
          <name>SYS_IVREFCTL</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SYS_IVREFCTL</displayName>
          <description>Internal Voltage Reference Control Register</description>
          <addressOffset>0x6C</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000700</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BGPEN</name>
              <description>Band-gap Enable Control(Write Protect)\nBand-gap is the reference voltage of internal reference voltage. User must enable band-gap if want to enable internal 1.5, 1.8V or 2.5V reference voltage.\nNote: This bit is write protected. Refer to the SYS_REGLCTL register.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Band-gap Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Band-gap Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>REGEN</name>
              <description>Regulator Enable Control(Write Protect)\nEnable internal 1.5, 1.8V or 2.5V reference voltage.\nNote: This bit is write protected. Refer to the SYS_REGLCTL register.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Regulator Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Regulator Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SEL25</name>
              <description>Regulator Output Voltage Selection(Write Protect)\nSelect internal reference voltage level.\nNote: This bit is write protected. Refer to the SYS_REGLCTL register.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>1.5V</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>1.8V</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>2.5V</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>2.5V</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>EXTMODE</name>
              <description>Regulator External Mode(Write Protect)\nUsers can output regulator output voltage in VREF pin if EXT_MODE is high.\nNote: This bit is write protected. Refer to the SYS_REGLCTL register.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No connection with external VREF pin</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Connet to external VREF pin. Connect a 1uF to 10uF capacitor to AVSS will let internal voltage reference be more stable</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>VREFTRIM</name>
              <description>Internal Voltage Reference Trim(Write Protect)\nNote: This bit is write protected. Refer to the SYS_REGLCTL register.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SYS_LDOCTL</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SYS_LDOCTL</displayName>
          <description>LDO Control Register</description>
          <addressOffset>0x70</addressOffset>
          <access>read-write</access>
          <resetValue>0x0000000C</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>FASTWK</name>
              <description>Fast Wake-up Control Bit  (Write Protect)\nNote: This bit is write protected. Refer to the SYS_REGLCTL register.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Fast Wake-up from Power-Down mode Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Fast Wake-up from Power-Down mode Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>LDOLVL</name>
              <description>LDO Output Voltage Select(Write Protect)\nNote: This bit is write protected. Refer to the SYS_REGLCTL register.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>1.2V</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>1.6V</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>1.8V</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>1.8V</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>LPRMEN</name>
              <description>Low-power Run Mode Enable Bit (Write Protect)\nNote: This bit is write protected. Refer to the SYS_REGLCTL register.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Low-Power runmode Enabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Low-Power runmode Disabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>FMCLVEN</name>
              <description>Flash Memory Low Voltage Mode Enable Bit (Write Protect)\nNote: This bit is write protected. Refer to the SYS_REGLCTL register.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Flash memory low voltage(1.2V) mode Enabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Flash memory low voltage(1.2V) mode Disabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SYS_BATDCTL</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SYS_BATDCTL</displayName>
          <description>Battery Voltage Divider Control Register</description>
          <addressOffset>0x74</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BATDIV2EN</name>
              <description>Battery Voltageg Divide 2 Enable Bit\nThis bit is used to enable/disable battery voltageg divider function.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Battery voltageg divide 2 function Disabled (default)</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Battery voltageg divide 2 function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SYS_WKSTS</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SYS_WKSTS</displayName>
          <description>System Wake-up Status Register</description>
          <addressOffset>0x7C</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ACMPWK</name>
              <description>ACMP Wake-up Flag (Read Only)\nThis flag indicates that wake-up of device from Power-down mode was requested with ACMP wake-up event. This flag is cleared when Power-down mode is entered.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>I2C1WK</name>
              <description>I2C1 Wake-up Flag (Read Only)\nThis flag indicates that wake-up of device from Power-down mode was requested with I2C1 wake-up event. This flag is cleared when Power-down mode is entered.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>I2C0WK</name>
              <description>I2C0 Wake-up Flag (Read Only)\nThis flag indicates that wake-up of device from Power-down mode was requested with I2C0 wake-up event. This flag is cleared when Power-down mode is entered.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TMR3WK</name>
              <description>TMR3 Wake-up Flag (Read Only)\nThis flag indicates that wake-up of device from Power-down mode was requested withTMR3 wake-up event. This flag is cleared when Power-down mode is entered.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TMR2WK</name>
              <description>TMR2 Wake-up Flag (Read Only)\nThis flag indicates that wake-up of device from Power-down mode was requested withTMR2 wake-up event. This flag is cleared when Power-down mode is entered.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TMR1WK</name>
              <description>TMR1 Wake-up Flag (Read Only)\nThis flag indicates that wake-up of device from Power-down mode was requested withTMR1 wake-up event. This flag is cleared when Power-down mode is entered.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TMR0WK</name>
              <description>TMR0 Wake-up Flag (Read Only)\nThis flag indicates that wake-up of device from Power-down mode was requested withTMR0 wake-up event. This flag is cleared when Power-down mode is entered.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>WDTWK</name>
              <description>WDT Wake-up Flag (Read Only)\nThis flag indicates that wake-up of device from Power-down mode was requested with WDT wake-up event. This flag is cleared when Power-down mode is entered.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>BODWK</name>
              <description>BOD Wake-up Flag (Read Only)\nThis flag indicates that wake-up of device from Power-down mode was requested with BOD wake-up event. This flag is cleared when Power-down mode is entered.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>SPI3WK</name>
              <description>SPI3 Wake-up Flag (Read Only)\nThis flag indicates that wake-up of device from Power-down mode was requested with SPI3 wake-up event. This flag is cleared when Power-down mode is entered.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>SPI2WK</name>
              <description>SPI2 Wake-up Flag (Read Only)\nThis flag indicates that wake-up of device from Power-down mode was requested with SPI2 wake-up event. This flag is cleared when Power-down mode is entered.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>SPI1WK</name>
              <description>SPI1 Wake-up Flag (Read Only)\nThis flag indicates that wake-up of device from Power-down mode was requested with SPI1 wake-up event. This flag is cleared when Power-down mode is entered.</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>SPI0WK</name>
              <description>SPI0 Wake-up Flag (Read Only)\nThis flag indicates that wake-up of device from Power-down mode was requested with SPI0 wake-up event. This flag is cleared when Power-down mode is entered.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>UART1WK</name>
              <description>UART1 Wake-up Flag (Read Only)\nThis flag indicates that wake-up of device from Power-down mode was requested with UART1 wake-up event. This flag is cleared when Power-down mode is entered.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>UART0WK</name>
              <description>UART0 Wake-up Flag (Read Only)\nThis flag indicates that wake-up of device from Power-down mode was requested with UART0 wake-up event. This flag is cleared when Power-down mode is entered.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RTCWK</name>
              <description>RTC Wake-up Flag (Read Only)\nThis flag indicates that wake-up of device from Power-down mode was requested with a RTCalarm or tick time happened. This flag is cleared when Power-down mode is entered.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>GPIOWK</name>
              <description>GPIO Wake-up Flag (Read Only)\nThis flag indicates that wake-up of device from Power-down mode was requested with GPIO wake-up event. This flag is cleared when Power-down mode is entered.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SYS_RC0TCTL</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SYS_RC0TCTL</displayName>
          <description>HIRC0 Trim Control Register</description>
          <addressOffset>0x80</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>FREQSEL</name>
              <description>Trim Frequency Selection\nThis field indicates the target frequency of 12 MHz internal high speed RC oscillator (HIRC0) auto trim.\nDuring auto trim operation, if clock error detected with CESTOPEN (SYS_IRC0TCTL[8]) is set to 1 or trim retry limitation count reached, this field will be cleared to 000 automatically.\nNote: HIRC0 auto trim cannot work normally inPower-down mode. These bits must be cleared before entering Power-down mode.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disable HIRC0 auto trim function</description>
                    <value>#000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable HIRC0 auto trim function and trim HIRC to 11.0592 MHz</description>
                    <value>#001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Enable HIRC0 auto trim function and trim HIRC to 12 MHz</description>
                    <value>#010</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Enable HIRC0 auto trim function and trim HIRC to 12.288 MHz</description>
                    <value>#011</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>4</name>
                    <description>Enable HIRC0 auto trim function and trim HIRC to 16 MHz</description>
                    <value>#100</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>LOOPSEL</name>
              <description>Trim Calculation Loop Selection\nThis field defines that trim value calculation is based on how many 32.768 kHz clock.\nNote: For example, if LOOPSEL is set as 00, auto trim circuit will calculate trim value based on the average frequency difference in 4 32.768 kHz clock.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Trim value calculation is based on average difference in 4 32.768 kHz clock</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Trim value calculation is based on average difference in 8 32.768 kHz clock</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Trim value calculation is based on average difference in 16 32.768 kHz clock</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Trim value calculation is based on average difference in 32 32.768 kHz clock</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RETRYCNT</name>
              <description>Trim Value Update Limitation Count\nThis field defines that how many times the auto trim circuit will try to update the HIRC0 trim value before the frequency of HIRC0 locked.\nOnce the HIRC0 locked, the internal trim value update counter will be reset.\nIf the trim value update counter reached this limitation value and frequency of HIRC0 still doesn't lock, the auto trim operation will be disabled and FREQSEL (SYS_IRC0TCTL[1:0]) will be cleared to 00.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Trim retry count limitation is 64 loops</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Trim retry count limitation is 128 loops</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Trim retry count limitation is 256 loops</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Trim retry count limitation is 512 loops</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CESTOPEN</name>
              <description>Clock Error Stop Enable Bit\nThis bit is used to control if stop the HIRC0 trim operation when 32.768 kHz clock error is detected.\nIf set this bit high and 32.768 kHz clock error detected, the status CLKERRIF (SYS_IRC0TISTS[2]) would be set high and HIRC0 trim operation was stopped. If this bit is low and 32.768 kHz clock error detected, the status CLKERRIF (SYS_IRC0TISTS[2]) would be set high and HIRC0 trim operation is continuously.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The trim operation is keep going if clock is inaccuracy</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The trim operation is stopped if clock is inaccuracy</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SYS_RC0TIEN</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SYS_RC0TIEN</displayName>
          <description>HIRC0 Trim Interrupt Enable Register</description>
          <addressOffset>0x84</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TFAILIEN</name>
              <description>Trim Failure Interrupt Enable Bit\nThis bit controls if an interrupt will be triggered while HIRC0 trim value update limitation count reached and HIRC0 frequency still not locked on target frequency set by FREQSEL(SYS_IRC0TCTL[1:0]).\nIf this bit is high and TFAILIF(SYS_IRC0TSTS[1]) is set during auto trim operation, an interrupt will be triggered to notify that HIRC0 trim value update limitation count was reached.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disable TFAILIF(SYS_IRC0TSTS[1]) status to trigger an interrupt to CPU</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable TFAILIF(SYS_IRC0TSTS[1]) status to trigger an interrupt to CPU</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CLKEIEN</name>
              <description>Clock Error Interrupt Enable Bit\nThis bit controls if CPU would get an interrupt while clock is inaccuracy during auto trim operation.\nIf this bit is set to1, and CLKERRIF(SYS_IRC0TSTS[2]) is set during auto trim operation, an interrupt will be triggered to notify the clock frequency is inaccuracy.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disable CLKERRIF(SYS_IRC0TSTS[2]) status to trigger an interrupt to CPU</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable CLKERRIF(SYS_IRC0TSTS[2]) status to trigger an interrupt to CPU</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SYS_RC0TISTS</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SYS_RC0TISTS</displayName>
          <description>HIRC0 Trim Interrupt Status Register</description>
          <addressOffset>0x88</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>FREQLOCK</name>
              <description>HIRC0 Frequency Lock Status\nThis bit indicates the HIRC0 frequency is locked.\nThis is a status bit and doesn't trigger any interrupt.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The internal high-speed oscillator frequency doesn't lock at frequency set by FREQSEL (SYS_IRC0TCTL[2:0])</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The internal high-speed oscillator frequency locked at frequency set by FREQSEL (SYS_IRC0TCTL[2:0])</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TFAILIF</name>
              <description>Trim Failure Interrupt Status\nThis bit indicates that HIRC0 trim value update limitation count reached and the HIRC0 clock frequency still doesn't be locked. Once this bit is set, the auto trim operation stopped and FREQSEL(SYS_IRC0TCTL[1:0]) will be cleared to 00 by hardware automatically.\nIf this bit is set and TFAILIEN(SYS_IRC0TIEN[1]) is high, an interrupt will be triggered to notify that HIRC0 trim value update limitation count was reached. Write 1 to clear this to 0.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Trim value update limitation count does not reach</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Trim value update limitation count reached and HIRC frequency still not locked</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CLKERRIF</name>
              <description>Clock Error Interrupt Status\nWhen the frequency of 32.768 kHz external low speed crystal oscillator (LXT) or internal high speed RC oscillator (HIRC0) is shift larger to unreasonable value, this bit will be set and to be an indicate that clock frequency is inaccuracy\nOnce this bit is set to 1, the auto trim operation stopped and FREQSEL(SYS_IRC0TCTL[1:0]) will be cleared to 00 by hardware automatically if CESTOPEN(SYS_IRC0TCTL[8]) is set to 1.\nIf this bit is set and CLKEIEN(SYS_IRC0TIEN[2]) is high, an interrupt will be triggered to notify the clock frequency is inaccuracy. Write 1 to clear this to 0.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Clock frequency is accuracy</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Clock frequency is inaccuracy</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SYS_RC1TCTL</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SYS_RC1TCTL</displayName>
          <description>HIRC1 Trim Control Register</description>
          <addressOffset>0x90</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>FREQSEL</name>
              <description>Trim Frequency Selection\nThis field indicates the target frequency of 36 MHz internal high speed RC oscillator (HIRC1) auto trim.\nDuring auto trim operation, if clock error detected with CESTOPEN (SYS_IRC1TCTL[8]) is set to 1 or trim retry limitation count reached, this field will be cleared to 00 automatically.\nNote: HIRC1 auto trim cannot work normally inPower-down mode. These bits must be cleared before entering Power-down mode.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disable HIRC1 auto trim function</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reserved</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Enable HIRC1 auto trim function and trim HIRC to 36 MHz</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Reserved</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>LOOPSEL</name>
              <description>Trim Calculation Loop Selection\nThis field defines that trim value calculation is based on how many 32.768 kHz clock.\nNote: For example, if LOOPSEL is set as 00, auto trim circuit will calculate trim value based on the average frequency difference in 4 32.768 kHz clock.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Trim value calculation is based on average difference in 4 32.768 kHz clock</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Trim value calculation is based on average difference in 8 32.768 kHz clock</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Trim value calculation is based on average difference in 16 32.768 kHz clock</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Trim value calculation is based on average difference in 32 32.768 kHz clock</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RETRYCNT</name>
              <description>Trim Value Update Limitation Count\nThis field defines that how many times the auto trim circuit will try to update the HIRC1 trim value before the frequency of HIRC1 locked.\nOnce the HIRC1 locked, the internal trim value update counter will be reset.\nIf the trim value update counter reached this limitation value and frequency of HIRC1 still doesn't lock, the auto trim operation will be disabled and FREQSEL (SYS_IRC1TCTL[1:0]) will be cleared to 00.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Trim retry count limitation is 64 loops</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Trim retry count limitation is 128 loops</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Trim retry count limitation is 256 loops</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Trim retry count limitation is 512 loops</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CESTOPEN</name>
              <description>Clock Error Stop Enable Bit\nThis bit is used to control if stop the HIRC1 trim operation when 32.768 kHz clock error is detected.\nIf set this bit high and 32.768 kHz clock error detected, the status CLKERRIF (SYS_IRC1TISTS[2]) would be set high and HIRC1 trim operation was stopped. If this bit is low and 32.768 kHz clock error detected, the status CLKERRIF (SYS_IRC1TISTS[2]) would be set high and HIRC1 trim operation is continuously.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The trim operation is keep going if clock is inaccuracy</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The trim operation is stopped if clock is inaccuracy</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SYS_RC1TIEN</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SYS_RC1TIEN</displayName>
          <description>HIRC1 Trim Interrupt Enable Register</description>
          <addressOffset>0x94</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TFAILIEN</name>
              <description>Trim Failure Interrupt Enable Bit\nThis bit controls if an interrupt will be triggered while HIRC1 trim value update limitation count reached and HIRC1 frequency still not locked on target frequency set by FREQSEL(SYS_IRC1TCTL[1:0]).\nIf this bit is high and TFAILIF(SYS_IRC1TSTS[1]) is set during auto trim operation, an interrupt will be triggered to notify that HIRC1 trim value update limitation count was reached.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disable TFAILIF(SYS_IRC1TSTS[1]) status to trigger an interrupt to CPU</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable TFAILIF(SYS_IRC1TSTS[1]) status to trigger an interrupt to CPU</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CLKEIEN</name>
              <description>Clock Error Interrupt Enable Bit\nThis bit controls if CPU would get an interrupt while clock is inaccuracy during auto trim operation.\nIf this bit is set to1, and CLKERRIF(SYS_IRC1TSTS[2]) is set during auto trim operation, an interrupt will be triggered to notify the clock frequency is inaccuracy.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disable CLKERRIF(SYS_IRC1TSTS[2]) status to trigger an interrupt to CPU</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable CLKERRIF(SYS_IRC1TSTS[2]) status to trigger an interrupt to CPU</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SYS_RC1TISTS</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SYS_RC1TISTS</displayName>
          <description>HIRC1 Trim Interrupt Status Register</description>
          <addressOffset>0x98</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>FREQLOCK</name>
              <description>HIRC1 Frequency Lock Status\nThis bit indicates the HIRC1 frequency is locked.\nThis is a status bit and doesn't trigger any interrupt.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The internal high-speed oscillator frequency doesn't lock at 36 MHz yet</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The internal high-speed oscillator frequency locked at 36 MHz</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TFAILIF</name>
              <description>Trim Failure Interrupt Status\nThis bit indicates that HIRC1 trim value update limitation count reached and the HIRC1 clock frequency still doesn't be locked. Once this bit is set, the auto trim operation stopped and FREQSEL(SYS_IRC1TCTL[1:0]) will be cleared to 00 by hardware automatically.\nIf this bit is set and TFAILIEN(SYS_IRC1TIEN[1]) is high, an interrupt will be triggered to notify that HIRC1 trim value update limitation count was reached. Write 1 to clear this to 0.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Trim value update limitation count does not reach</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Trim value update limitation count reached and HIRC1 frequency still not locked</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CLKERRIF</name>
              <description>Clock Error Interrupt Status\nWhen the frequency of 32.768 kHz external low speed crystal oscillator (LXT) or 36 MHz internal high speed RC oscillator (HIRC1) is shift larger to unreasonable value, this bit will be set and to be an indicate that clock frequency is inaccuracy\nOnce this bit is set to 1, the auto trim operation stopped and FREQSEL(SYS_IRC1TCTL[1:0]) will be cleared to 00 by hardware automatically if CESTOPEN(SYS_IRC1TCTL[8]) is set to 1.\nIf this bit is set and CLKEIEN(SYS_IRC1TIEN[2]) is high, an interrupt will be triggered to notify the clock frequency is inaccuracy. Write 1 to clear this to 0.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Clock frequency is accuracy</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Clock frequency is inaccuracy</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SYS_MRCTCTL</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SYS_MRCTCTL</displayName>
          <description>MIRC Trim Control Register</description>
          <addressOffset>0xA0</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>FREQSEL</name>
              <description>Trim Frequency Selection\nThis field indicates the target frequency of 4 MHz internal medium speed RC oscillator (MIRC) auto trim.\nDuring auto trim operation, if clock error detected with CESTOPEN (SYS_MIRCTCTL[8]) is set to 1 or trim retry limitation count reached, this field will be cleared to 00 automatically.\nNote:MIRC auto trim cannot work normally inPower downn mode. These bits must be cleared before entering Power-down mode.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disable MIRC auto trim function</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reserved</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Enable MIRC auto trim function and trim HIRC to 4 MHz</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Reserved</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>LOOPSEL</name>
              <description>Trim Calculation Loop Selection\nThis field defines that trim value calculation is based on how many 32.768 kHz clock.\nNote: For example, if LOOPSEL is set as 00, auto trim circuit will calculate trim value based on the average frequency difference in 4 32.768 kHz clock.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Trim value calculation is based on average difference in 4 32.768 kHz clock</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Trim value calculation is based on average difference in 8 32.768 kHz clock</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Trim value calculation is based on average difference in 16 32.768 kHz clock</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Trim value calculation is based on average difference in 32 32.768 kHz clock</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RETRYCNT</name>
              <description>Trim Value Update Limitation Count\nThis field defines that how many times the auto trim circuit will try to update the MIRC trim value before the frequency of MIRC locked.\nOnce the MIRC locked, the internal trim value update counter will be reset.\nIf the trim value update counter reached this limitation value and frequency of MIRC still doesn't lock, the auto trim operation will be disabled and FREQSEL (SYS_MIRCTCTL[1:0]) will be cleared to 00.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Trim retry count limitation is 64 loops</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Trim retry count limitation is 128 loops</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Trim retry count limitation is 256 loops</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Trim retry count limitation is 512 loops</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CESTOPEN</name>
              <description>Clock Error Stop Enable Bit\nThis bit is used to control if stop the MIRC trim operation when 32.768 kHz clock error is detected.\nIf set this bit high and 32.768 kHz clock error detected, the status CLKERRIF (SYS_MIRCTISTS[2]) would be set high and MIRC trim operation was stopped. If this bit is low and 32.768 kHz clock error detected, the status CLKERRIF (SYS_MIRCTISTS[2]) would be set high and MIRC trim operation is continuously.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The trim operation is keep going if clock is inaccuracy</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The trim operation is stopped if clock is inaccuracy</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SYS_MRCTIEN</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SYS_MRCTIEN</displayName>
          <description>MIRC Trim Interrupt Enable Register</description>
          <addressOffset>0xA4</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TFAILIEN</name>
              <description>Trim Failure Interrupt Enable Bit\nThis bit controls if an interrupt will be triggered while MIRC trim value update limitation count reached and MIRC frequency still not locked on target frequency set by FREQSEL(SYS_MIRCTCTL[1:0]).\nIf this bit is high and TFAILIF(SYS_MIRCTSTS[1]) is set during auto trim operation, an interrupt will be triggered to notify that MIRC trim value update limitation count was reached.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disable TFAILIF(SYS_MIRCTSTS[1]) status to trigger an interrupt to CPU</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable TFAILIF(SYS_MIRCTSTS[1]) status to trigger an interrupt to CPU</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CLKEIEN</name>
              <description>Clock Error Interrupt Enable Bit\nThis bit controls if CPU would get an interrupt while clock is inaccuracy during auto trim operation.\nIf this bit is set to1, and CLKERRIF(SYS_MIRCTSTS[2]) is set during auto trim operation, an interrupt will be triggered to notify the clock frequency is inaccuracy.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disable CLKERRIF(SYS_MIRCTSTS[2]) status to trigger an interrupt to CPU</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable CLKERRIF(SYS_MIRCTSTS[2]) status to trigger an interrupt to CPU</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SYS_MRCTISTS</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SYS_MRCTISTS</displayName>
          <description>MIRC Trim Interrupt Status Register</description>
          <addressOffset>0xA8</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>FREQLOCK</name>
              <description>MIRC Frequency Lock Status\nThis bit indicates the MIRC frequency is locked.\nThis is a status bit and doesn't trigger any interrupt.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The internal medium-speed oscillator frequency doesn't lock at 4 MHz yet</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The internal medium-speed oscillator frequency locked at 4 MHz</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TFAILIF</name>
              <description>Trim Failure Interrupt Status\nThis bit indicates that MIRC trim value update limitation count reached and the MIRC clock frequency still doesn't be locked. Once this bit is set, the auto trim operation stopped and FREQSEL(SYS_MIRCTCTL[1:0]) will be cleared to 00 by hardware automatically.\nIf this bit is set and TFAILIEN(SYS_MIRCTIEN[1]) is high, an interrupt will be triggered to notify that MIRC trim value update limitation count was reached. Write 1 to clear this to 0.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Trim value update limitation count does not reach</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Trim value update limitation count reached and MIRC frequency still not locked</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CLKERRIF</name>
              <description>Clock Error Interrupt Status\nWhen the frequency of 32.768 kHz external low speed crystal oscillator (LXT) or 4 MHz internal medium speed RC oscillator (MIRC) is shift larger to unreasonable value, this bit will be set and to be an indicate that clock frequency is inaccuracy\nOnce this bit is set to 1, the auto trim operation stopped and FREQSEL(SYS_MIRCTCTL[1:0]) will be cleared to 00 by hardware automatically if CESTOPEN(SYS_MIRCTCTL[8]) is set to 1.\nIf this bit is set and CLKEIEN(SYS_MIRCTIEN[2]) is high, an interrupt will be triggered to notify the clock frequency is inaccuracy. Write 1 to clear this to 0.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Clock frequency is accuracy</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Clock frequency is inaccuracy</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SYS_REGLCTL</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SYS_REGLCTL</displayName>
          <description>Register Lock Control Register</description>
          <addressOffset>0x100</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>REGLCTL</name>
              <description>Register Lock Control Code (Write Only)\nSome registers have write-protection function. Writing these registers have to disable the protected function by writing the sequence value "59h", "16h", "88h" to this field. After this sequence is completed, the REGLCTL bit will be set to 1 and write-protection registers can be normal write.\nRegister Lock Control Disable Index (Read Only)</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Write-protection Enabled for writing protected registers. Any write to the protected register is ignored</description>
                    <value>0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Write-protection Disabled for writing protected registers</description>
                    <value>1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SYS_RPDBCLK</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SYS_RPDBCLK</displayName>
          <description>Reset Pin Debounce Clock Selection Register</description>
          <addressOffset>0x120</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>RSTPDBCLK</name>
              <description>Reset Pin Debounce Clock Selection Bit\nBefore swtch clock, both clock sources must be enabled.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>HIRC2 is slected as reset pin debounce clock</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>HIRC0 is slected as reset pin debounce clock.(.default)</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>CLK</name>
      <description>CLK Register Map</description>
      <groupName>CLK</groupName>
      <baseAddress>0x50000200</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x0</offset>
        <size>0x2C</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x30</offset>
        <size>0x1C</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>CLK_PWRCTL</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CLK_PWRCTL</displayName>
          <description>System Power-down Control Register</description>
          <addressOffset>0x0</addressOffset>
          <access>read-write</access>
          <resetValue>0x001A001C</resetValue>
          <resetMask>0xFFFF00FF</resetMask>
          <fields>
            <field>
              <name>HXTEN</name>
              <description>HXT Enable Bit (Write Protect)\nNote: This bit is write protected. Refer to the SYS_REGLCTL register.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>4~32 MHz external high speed crystal (HXT) Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>4~32 MHz external high speed crystal (HXT) Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>LXTEN</name>
              <description>LXT Enable Bit (Write Protect)\nNote: This bit is write protected. Refer to the SYS_REGLCTL register.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>32.768 kHz external lowspeed crystal (LXT) Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>32.768 kHz external lowspeed crystal (LXT) Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>HIRC0EN</name>
              <description>HIRC0 Enable Bit (Write Protect)\nNote: This bit is write protected. Refer to the SYS_REGLCTL register.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>12~16 MHz internal high speed RC oscillator (HIRC0)Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>12~16 MHz internal high speed RC oscillator (HIRC0)Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>LIRCEN</name>
              <description>LIRC Enable Bit(Write Protect)\nNote: This bit is write protected. Refer to the SYS_REGLCTL register.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>10 kHz internal low speed RC oscillator (LIRC) Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>10 kHz internal low speed RC oscillator (LIRC)Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PDWKDLY</name>
              <description>Enable the Wake-up Delay Counter (Write Protect)\nWhen the chip wakes up from Power-down mode, the clock control will delay4096 clock cycles to wait system clock stable when chip works at 4~32 MHz external high speed crystal oscillator (HXT).\nNote: This bit is write protected. Refer to the SYS_REGLCTL register.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Clock cycles delayDisabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Clock cycles delayEnabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PDWKIEN</name>
              <description>Power-down Mode Wake-up Interrupt Enable Bit (Write Protect)\nNote1: The interrupt (EINT0~1, GPIO,, UART0~1, WDT, ACMP01, BOD, RTC, TMR0~3, I2C0~1 or SPI0 ~3)will occur when PDWKIEN are high.\nNote2: This bit is write protected. Refer to the SYS_REGLCTL register.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Power-down mode wake-up interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Power-down mode wake-up interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PDEN</name>
              <description>System Power-down Enable (Write Protect)\nWhen this bit is set to 1, Power-down mode is enabled and chip Power-down behavior will depend on the PDWTCPU bit.\n(a) If the PDWTCPU is 0, then the chip enters Power-down mode immediately after the PDEN bit set. (default)\n(b) if the PDWTCPU is 1, then the chip keeps active till the CPU sleep mode is also active and then the chip enters Power-down mode.\nWhen chip wakes up from Power-down mode, this bit is auto cleared. Users need to set this bit again for next Power-down.\nIn Power-down mode, HXT and the HIRC will be disabled in this mode, but LXT and LIRC  are not controlled by Power-down mode.\nIn Power-down mode, the PLL and system clock are disabled, and ignored the clock source selection. The clocks of peripheral are not controlled by Power-down mode, if the peripheral clock source is from LXT or LIRC.\nNote: This bit is write protected. Refer to the SYS_REGLCTL register.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Chip operating normally or chip in idle mode because of WFI command</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Chip enters Power-down mode instant or wait CPU sleep command WFI</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>HXTSLTYP</name>
              <description>HXT Mode Selection (Write Protect)\nNote: This bit is write protected. Refer to the SYS_REGLCTL register.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>High frequency crystal loop back path Disabled. It is used for external oscillator</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>High frequency crystal loop back path Enabled. It is used for external crystal</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>HXTGAIN</name>
              <description>HXT Gain Control Bit(Write Protect)\nGain control is used to enlarge the gain of crystal to make sure crystal wok normally. If gain control is enabled, crystal will consume more power than gain control off.\nNote: This bit is write protected. Refer to the SYS_REGLCTL register.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>3</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>HXT frequency is lower than from 4 MHz</description>
                    <value>#000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>HXT frequency is from 4 MHz to 8 MHz</description>
                    <value>#001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>HXT frequency is from 8 MHz to 12 MHz</description>
                    <value>#010</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>HXT frequency is from 12 MHz to 16 MHz</description>
                    <value>#011</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>4</name>
                    <description>HXT frequency is from 16 MHz to 24 MHz</description>
                    <value>#100</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>5</name>
                    <description>HXT frequency is from 24 MHz to 32 MHz</description>
                    <value>#101</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>6</name>
                    <description>HXT frequency is from 32 MHz to 36 MHz</description>
                    <value>#110</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>7</name>
                    <description>HXT frequency is higher than 36 MHz</description>
                    <value>#111</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>HIRC0FSEL</name>
              <description>HIRC0 Output Frequency Select Bit</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>HIRC0 will output 12MHz clock</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>HIRC0 will output 16MHz Clock</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>HIRC0FSTOP</name>
              <description>HIRC0 Stop Output When Frequency Changes (Write Protect)\nNote: This bit is write protected. Refer to the SYS_REGLCTL register.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>HIRC0 will continue to output when HIRC frequency changes</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>HIRC0will suppress to output during first 16 clocks when HIRC frequency change</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>HIRC1EN</name>
              <description>HIRC1 Enable Bit (Write Protect)\nNote: This bit is write protected. Refer to the SYS_REGLCTL register.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>36 MHz internal high speed RC oscillator (HIRC1)Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>36 MHz internal high speed RC oscillator (HIRC1)Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>MIRCEN</name>
              <description>MIRC Enable Bit (Write Protect)\nNote: This bit is write protected. Refer to the SYS_REGLCTL register.</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>4 MHz internal medium speed RC oscillator (MIRC)Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>4 MHz internal medium speed RC oscillator (MIRC)Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CLK_AHBCLK</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CLK_AHBCLK</displayName>
          <description>AHB Devices Clock Enable Control Register</description>
          <addressOffset>0x4</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000035</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>GPIOCKEN</name>
              <description>GPIO Controller Clock Enable Control</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO peripheral clock Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIO peripheral clock Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PDMACKEN</name>
              <description>PDMA Controller Clock Enable Bit</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PDMA peripheral clock Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PDMA peripheral clock Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ISPCKEN</name>
              <description>Flash ISP Controller Clock Enable Bit</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Flash ISP peripheral clock Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Flash ISP peripheral clock Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SRAMCKEN</name>
              <description>SRAM Controller Clock Enable Control Bit</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>SRAM peripheral clock Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>SRAM peripheral clock Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>STCKEN</name>
              <description>System Tick Clock Enable Control Bit</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>System Tick Clock Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>System Tick Clock Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CLK_APBCLK</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CLK_APBCLK</displayName>
          <description>APB Devices Clock Enable Control Register</description>
          <addressOffset>0x8</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000001</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WDTCKEN</name>
              <description>Watchdog Timer Clock Enable Control \nThis is a protected register. Please refer to open lock sequence to program it.\nThis bit is used to control the WDT APB clock only, The WDT engine Clock Source is from LIRC.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Watchdog Timer Clock Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Watchdog Timer Clock Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RTCCKEN</name>
              <description>Real-time-clock Clock Enable Control \nThis bit is used to control the RTC APB clock only, The RTC engine Clock Source is from LXT.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Real-time-clock Clock Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Real-time-clock Clock Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TMR0CKEN</name>
              <description>Timer0 Clock Enable Control</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Timer0 Clock Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Timer0 Clock Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TMR1CKEN</name>
              <description>Timer1 Clock Enable Control</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Timer1 Clock Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Timer1 Clock Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TMR2CKEN</name>
              <description>Timer2 Clock Enable Control</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Timer2 Clock Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Timer2 Clock Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TMR3CKEN</name>
              <description>Timer3 Clock Enable Control</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Timer3 Clock Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Timer3 Clock Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CLKOCKEN</name>
              <description>ClocK Output Clock Enable Control</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Clock Output Clock Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Clock Output Clock Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DSRCCKEN</name>
              <description>DSRC Clock Enable Control </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>DSRC Clock Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>DSRC Clock Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C0CKEN</name>
              <description>I2C0 Clock Enable Control </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>I2C0 Clock Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>I2C0 Clock Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C1CKEN</name>
              <description>I2C1 Clock Enable Control </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>I2C1 Clock Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>I2C1 Clock Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ACMP0CKEN</name>
              <description>ACMP0 Clock Enable Control </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>ACMP0 Clock Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>ACMP0 Clock Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SPI0CKEN</name>
              <description>SPI0 Clock Enable Control </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>SPI0 Clock Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>SPI0 Clock Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SPI1CKEN</name>
              <description>SPI1 Clock Enable Control </description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>SPI1 Clock Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>SPI1 Clock Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SPI2CKEN</name>
              <description>SPI2 Clock Enable Control </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>SPI2 Clock Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>SPI2 Clock Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SPI3CKEN</name>
              <description>SPI3 Clock Enable Control </description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>SPI3 Clock Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>SPI3 Clock Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>UART0CKEN</name>
              <description>UART0 Clock Enable Control</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>UART0 Clock Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>UART0 Clock Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>UART1CKEN</name>
              <description>UART1 Clock Enable Control</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>UART1 Clock Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>UART1 Clock Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PWM0CKEN</name>
              <description>PWM0 Clock Enable Control</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM0 Clock Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PWM0 Clock Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ADCCKEN</name>
              <description>Analog-digital-converter (ADC) Clock Enable Control</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>ADC Clock Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>ADC Clock Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SC0CKEN</name>
              <description>SmartCard 0 Clock Enable Control</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>SmartCard 0 Clock Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>SmartCard 0 Clock Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SC1CKEN</name>
              <description>SmartCard 1 Clock Enable Control</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>SmartCard 1 Clock Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>SmartCard 1 Clock Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CLK_STATUS</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CLK_STATUS</displayName>
          <description>Clock status monitor Register</description>
          <addressOffset>0xC</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000010</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>HXTSTB</name>
              <description>HXTClock Source Stable Flag(Read Only)</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>4~36 MHz external high speed crystal oscillator (HXT) clock is not stable or disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>4~36 MHz external high speed crystal oscillator (HXT)clock is stable and enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>LXTSTB</name>
              <description>LXTClock Source Stable Flag(Read Only)</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>32.768 kHz external low speed crystal oscillator (LXT) clock is not stable or disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>32.768 kHz external low speed crystal oscillator (LXT) clock is stabled and enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>PLLSTB</name>
              <description>Internal PLL Clock Source Stable Flag(Read Only)</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Internal PLL clock is not stable or disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Internal PLL clock is stable and enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>LIRCSTB</name>
              <description>LIRCClock Source Stable Flag(Read Only)</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>10 kHz internal low speed RC oscillator (LIRC) clock is not stable or disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>10 kHz internal low speed RC oscillator (LIRC) clock is stable and enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>HIRC0STB</name>
              <description>HIRC0 Clock Source Stable Flag (Read Only)</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>12~16 MHz internal high speed RC oscillator (HIRC0) clock is not stable or disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>12~16 MHz internal high speed RC oscillator (HIRC0) clock is stable and enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>HIRC1STB</name>
              <description>HIRCClock Source Stable Flag(Read Only)</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>36 MHz internal high speed RC oscillator (HIRC1) clock is not stable or disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>36 MHz internal high speed RC oscillator (HIRC1) clock is stable and enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>MIRCSTB</name>
              <description>MIRCClock Source Stable Flag(Read Only)</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>4 MHz internal medium speed RC oscillator (MIRC) clock is not stable or disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>4 MHz internal medium speed RC oscillator (MIRC) clock is stable and enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>CLKSFAIL</name>
              <description>Clock Switching Fail Flag(Read Only)\nThis bit is updated when software switches system clock source. If switch target clock is stable, this bit will be set to 0. If switch target clock is not stable, this bit will be set to 1.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Clock switching success</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Clock switching failure</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CLK_CLKSEL0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CLK_CLKSEL0</displayName>
          <description>Clock Source Select Control Register 0</description>
          <addressOffset>0x10</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000004</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>HCLKSEL</name>
              <description>HCLK Clock Source Selection(Write Protect)\nBefore clock switching, the related clock sources (both pre-select and new-select) must be turned on.\nNote:This bit is write protected. Refer to the SYS_REGLCTL register.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Clock source from HXT</description>
                    <value>#000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Clock source from LXT</description>
                    <value>#001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Clock source from PLL</description>
                    <value>#010</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Clock source from LIRC</description>
                    <value>#011</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>4</name>
                    <description>Clock source from HIRC1 or HIRC0 depend on HIRCSEL(CLK_CLKSEL0[3]) setting</description>
                    <value>#100</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>HIRCSEL</name>
              <description>HIRC Source Selection </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Clock source from HIRC0 (12~16MHz)</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Clock source from HIRC1 (36MHz)</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ISPSEL</name>
              <description>ISP Clock Source Selection </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Clock source from HIRC1 or HIRC0 depend on HIRCSEL(CLK_CLKSEL0[3]) setting</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Clock source from MIRC</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CLK_CLKSEL1</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CLK_CLKSEL1</displayName>
          <description>Clock Source Select Control Register 1</description>
          <addressOffset>0x14</addressOffset>
          <access>read-write</access>
          <resetValue>0xB51844F3</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>UART0SEL</name>
              <description>UART0 Clock Source Selection</description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Clock source from 4~32 MHz external high speed crystal oscillator (HXT)</description>
                    <value>#000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Clock source from 32.768 kHz external low speed crystal oscillator (LXT)</description>
                    <value>#001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Clock source from PLL</description>
                    <value>#010</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Clock source from 36 MHz internal high speed RC oscillator (HIRC1) or HIRC0 depend on HIRCSEL(CLK_CLKSEL0[3]) setting</description>
                    <value>#011</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PWM0SEL</name>
              <description>PWM0 Clock Source Selection</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Clock source from PLL</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Clock source from PCLK0</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TMR0SEL</name>
              <description>Timer0 Clock Source Selection</description>
              <bitOffset>8</bitOffset>
              <bitWidth>3</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Clock source from 4~32 MHz external high speed crystal oscillator (HXT)</description>
                    <value>#000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Clock source from 32.768 kHz external low speed crystal oscillator (LXT)</description>
                    <value>#001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Clock source from 10 kHz internal low speed RC oscillator (LIRC)</description>
                    <value>#010</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Clock source from external clock pin</description>
                    <value>#011</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>4</name>
                    <description>Clock source from36 MHz internal high speed RC oscillator (HIRC1) or HIRC0 depend on HIRCSEL(CLK_CLKSEL0[3]) setting</description>
                    <value>#100</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>5</name>
                    <description>Clock source from 4 MHz internal medium speed RC oscillator (MIRC)</description>
                    <value>#101</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TMR1SEL</name>
              <description>Timer1 Clock Source Selection</description>
              <bitOffset>12</bitOffset>
              <bitWidth>3</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Clock source from 4~32 MHz external high speed crystal oscillator (HXT)</description>
                    <value>#000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Clock source from 32.768 kHz external low speed crystal oscillator (LXT)</description>
                    <value>#001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Clock source from 10 kHz internal low speed RC oscillator (LIRC)</description>
                    <value>#010</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Clock source from external clock pin</description>
                    <value>#011</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>4</name>
                    <description>Clock source from36 MHz internal high speed RC oscillator (HIRC1) or HIRC0 depend on HIRCSEL(CLK_CLKSEL0[3]) setting</description>
                    <value>#100</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>5</name>
                    <description>Clock source from 4 MHz internal medium speed RC oscillator (MIRC)</description>
                    <value>#101</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ADCSEL</name>
              <description>ADC Clock Source Selection</description>
              <bitOffset>19</bitOffset>
              <bitWidth>3</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Clock source from 4~32 MHz external high speed crystal oscillator (HXT)</description>
                    <value>#000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Clock source from 32.768 kHz external low speed crystal oscillator (LXT)</description>
                    <value>#001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Clock source from PLL</description>
                    <value>#010</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Clock source from36 MHz internal high speed RC oscillator (HIRC1) or HIRC0 depend on HIRCSEL(CLK_CLKSEL0[3]) setting</description>
                    <value>#011</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>4</name>
                    <description>Clock source from 4 MHz internal medium speed RC oscillator (MIRC)</description>
                    <value>#100</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SPI0SEL</name>
              <description>SPI0 Clock Source Selection</description>
              <bitOffset>24</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Clock source from PLL</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Clock source from HCLK</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Clock source from 4~32 MHz external high speed crystal oscillator (HXT)</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Clock source from 36 MHz internal high speed RC oscillator (HIRC1) or HIRC0 depend on HIRCSEL(CLK_CLKSEL0[3]) setting</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SPI2SEL</name>
              <description>SPI2 Clock Source Selection</description>
              <bitOffset>26</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Clock source from PLL</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Clock source from HCLK</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Clock source from 4~32 MHz external high speed crystal oscillator (HXT)</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Clock source from 36 MHz internal high speed RC oscillator (HIRC1) or HIRC0 depend on HIRCSEL(CLK_CLKSEL0[3]) setting</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>WDTSEL</name>
              <description>WDT Clock Source Selection</description>
              <bitOffset>28</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>reserved</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Clock source from LXT</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Clock source from HCLK/2048</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Clock source from LIRC</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>WWDTSEL</name>
              <description>WDT Clock Source Selection</description>
              <bitOffset>30</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>reserved</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>reserved</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Clock source from HCLK/2048</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Clock source from LIRC</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CLK_CLKSEL2</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CLK_CLKSEL2</displayName>
          <description>Clock Source Select Control Register 2</description>
          <addressOffset>0x18</addressOffset>
          <access>read-write</access>
          <resetValue>0x052244B3</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>UART1SEL</name>
              <description>UART1 Clock Source Selection</description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Clock source from 4~32 MHz external high speed crystal oscillator (HXT)</description>
                    <value>#000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Clock source from 32.768 kHz external low speed crystal oscillator (LXT)</description>
                    <value>#001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Clock source from PLL</description>
                    <value>#010</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Clock source from 36 MHz internal high speed RC oscillator (HIRC1) or HIRC0 depend on HIRCSEL(CLK_CLKSEL0[3]) setting</description>
                    <value>#011</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CLKOSEL</name>
              <description>Clock Divider Clock Source Selection</description>
              <bitOffset>4</bitOffset>
              <bitWidth>3</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Clock source from 4~32 MHz external high speed crystal oscillator (HXT)</description>
                    <value>#000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Clock source from 32.768 kHz external low speed crystal oscillator (LXT)</description>
                    <value>#001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Clock source from HCLK</description>
                    <value>#010</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Clock source from36 MHz internal high speed RC oscillator (HIRC1) or HIRC0 depend on HIRCSEL(CLK_CLKSEL0[3]) setting</description>
                    <value>#011</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DSRCSEL</name>
              <description>DSRC Clock Source Selection</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Clock source from 4 MHz internal medium speed RC oscillator (MIRC)</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Clock source from 36 MHz internal high speed RC oscillator (HIRC1) or HIRC0 depend on HIRCSEL(CLK_CLKSEL0[3]) setting</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TMR2SEL</name>
              <description>Timer2 Clock Source Selection</description>
              <bitOffset>8</bitOffset>
              <bitWidth>3</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Clock source from 4~32 MHz external high speed crystal oscillator (HXT)</description>
                    <value>#000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Clock source from 32.768 kHz external low speed crystal oscillator (LXT)</description>
                    <value>#001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Clock source from 10 kHz internal low speed RC oscillator (LIRC)</description>
                    <value>#010</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Clock source from external clock pin</description>
                    <value>#011</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>4</name>
                    <description>Clock source from36 MHz internal high speed RC oscillator (HIRC1) or HIRC0 depend on HIRCSEL(CLK_CLKSEL0[3]) setting</description>
                    <value>#100</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>5</name>
                    <description>Clock source from 4 MHz internal medium speed RC oscillator (MIRC)</description>
                    <value>#101</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TMR3SEL</name>
              <description>Timer3 Clock Source Selection</description>
              <bitOffset>12</bitOffset>
              <bitWidth>3</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Clock source from 4~32 MHz external high speed crystal oscillator (HXT)</description>
                    <value>#000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Clock source from 32.768 kHz external low speed crystal oscillator (LXT)</description>
                    <value>#001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Clock source from 10 kHz internal low speed RC oscillator (LIRC)</description>
                    <value>#010</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Clock source from external clock pin</description>
                    <value>#011</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>4</name>
                    <description>Clock source from36 MHz internal high speed RC oscillator (HIRC1) or HIRC0 depend on HIRCSEL(CLK_CLKSEL0[3]) setting</description>
                    <value>#100</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>5</name>
                    <description>Clock source from 4 MHz internal medium speed RC oscillator (MIRC)</description>
                    <value>#101</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SC0SEL</name>
              <description>SC0 Clock Source Selection</description>
              <bitOffset>16</bitOffset>
              <bitWidth>3</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Clock source from 4~32 MHz external high speed crystal oscillator (HXT)</description>
                    <value>#000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Clock source from PLL</description>
                    <value>#001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Clock source from 36 MHz internal high speed RC oscillator (HIRC1) or HIRC0 depend on HIRCSEL(CLK_CLKSEL0[3]) setting</description>
                    <value>#010</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Clock source from 4 MHz internal medium speed RC oscillator (MIRC)</description>
                    <value>#011</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SC1SEL</name>
              <description>SC1 Clock Source Selection</description>
              <bitOffset>20</bitOffset>
              <bitWidth>3</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Clock source from 4~32 MHz external high speed crystal oscillator (HXT)</description>
                    <value>#000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Clock source from PLL</description>
                    <value>#001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Clock source from 36 MHz internal high speed RC oscillator (HIRC1) or HIRC0 depend on HIRCSEL(CLK_CLKSEL0[3]) setting</description>
                    <value>#010</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Clock source from 4 MHz internal medium speed RC oscillator (MIRC)</description>
                    <value>#011</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SPI1SEL</name>
              <description>SPI1 Clock Source Selection</description>
              <bitOffset>24</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Clock source from PLL</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Clock source from HCLK</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Clock source from 4~32 MHz external high speed crystal oscillator (HXT)</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Clock source from 36 MHz internal high speed RC oscillator (HIRC1) or HIRC0 depend on HIRCSEL(CLK_CLKSEL0[3]) setting</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SPI3SEL</name>
              <description>SPI3 Clock Source Selection</description>
              <bitOffset>26</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Clock source from PLL</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Clock source from HCLK</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Clock source from 4~32 MHz external high speed crystal oscillator (HXT)</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Clock source from 36 MHz internal high speed RC oscillator (HIRC1) or HIRC0 depend on HIRCSEL(CLK_CLKSEL0[3]) setting</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CLK_CLKDIV0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CLK_CLKDIV0</displayName>
          <description>Clock Divider Number Register 0</description>
          <addressOffset>0x1C</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>HCLKDIV</name>
              <description>HCLK Clock Divide Number From HCLK Clock Source</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>UART0DIV</name>
              <description>UART0Clock Divide Number From UART Clock Source</description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>UART1DIV</name>
              <description>UART1Clock Divide Number From UART Clock Source</description>
              <bitOffset>12</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ADCDIV</name>
              <description>ADC Clock Divide Number From ADC Clock Source</description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SC0DIV</name>
              <description>SC0Clock Divide Number From SC0Clock Source</description>
              <bitOffset>28</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CLK_CLKDIV1</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CLK_CLKDIV1</displayName>
          <description>Clock Divider Number Register 1</description>
          <addressOffset>0x20</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SC1DIV</name>
              <description>SC 1Clock Divide Number From SC 1Clock Source</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TMR0DIV</name>
              <description>Timer0Clock Divide Number From Timer0Clock Source</description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TMR1DIV</name>
              <description>Timer1Clock Divide Number From Timer1Clock Source</description>
              <bitOffset>12</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TMR2DIV</name>
              <description>Timer2Clock Divide Number From Timer2Clock Source</description>
              <bitOffset>16</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TMR3DIV</name>
              <description>Timer3Clock Divide Number From Timer3Clock Source</description>
              <bitOffset>20</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DSRCDIV</name>
              <description>DSRC Clock Divide Number From DSRCClock Source</description>
              <bitOffset>24</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CLK_PLLCTL</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CLK_PLLCTL</displayName>
          <description>PLL Control Register</description>
          <addressOffset>0x24</addressOffset>
          <access>read-write</access>
          <resetValue>0x00030000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PLLMLP</name>
              <description>PLL Multiple\n000000: Reserved\n000001: X1\n000010: X2\n000011: X3\n000100: X4\n...\n010000:X16\n...\n100000: X32\n100100: X36\n0thers: Reserved \nPLL output frequency: PLL input frequency * PLLMLP.\nPLL output frequency range: 16MHz ~ 36MHz</description>
              <bitOffset>0</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>INDIV</name>
              <description>PLL Input Source Divider \nPLL input clock frequency range: 0.8MHz ~ 2MHz</description>
              <bitOffset>8</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>STBCNT</name>
              <description>PLL Stable Time Selection</description>
              <bitOffset>14</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>100 cycle time of input clock source</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>120 cycle time of input clock source</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>180 cycle time of input clock source</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>240 cycle time of input clock source</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PD</name>
              <description>Power-down Mode\nIf set the PDEN bit "1" in CLK_PWRCTL register, the PLL will enter Power-down mode too</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PLL is in normal mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PLL is in power-down mode (default)</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PLLSRC</name>
              <description>PLL Source Clock Select</description>
              <bitOffset>17</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PLL source clock from HXT</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PLL source clock from HIRC0 or HIRC1</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>PLL source clock from MIRC</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>reserved</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CLK_CLKOCTL</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CLK_CLKOCTL</displayName>
          <description>Clock Output Control Register</description>
          <addressOffset>0x28</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>FREQSEL</name>
              <description>Clock Output Frequency Selection\nThe formula of output frequency is\nFin is the input clock frequency.\nFout is the frequency of divider output clock.\nN is the 4-bit value of FREQSEL[3:0].</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CLKOEN</name>
              <description>Clock Output Enable Bit</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Clock Output function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Clock Output function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DIV1EN</name>
              <description>Clock Output Divide One Enable Bit</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Clock Output will output clock with source frequency divided by FREQSEL</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Clock Output will output clock with source frequency</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CLK_WKINTSTS</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CLK_WKINTSTS</displayName>
          <description>Wake-up Interrupt Status</description>
          <addressOffset>0x30</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDWKIF</name>
              <description>Wake-up Interrupt Status in Chip Power-down Mode\nThis bit indicates that some event resumes chip from Power-down mode\nThe status is set if external interrupts, UART, GPIO, RTC, USB, SPI, Timer, WDT, and BOD wake-up occurred.\nWrite 1 to clear this bit.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CLK_APBDIV</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CLK_APBDIV</displayName>
          <description>APB Clock Divider</description>
          <addressOffset>0x34</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>APB0DIV</name>
              <description>APB0 Clock Divider\nAPB0 PCLK0 can be divided from HCLK.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>APB1DIV</name>
              <description>APB1 Clock Divider\nAPB1 PCLK1 can be divided from HCLK.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CLK_CLKDCTL</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CLK_CLKDCTL</displayName>
          <description>Clock Fail Detector Control Register</description>
          <addressOffset>0x38</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>HXTFDEN</name>
              <description>HXT Clock Fail Detector Enable Bit</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>4~32 MHz external high speed crystal oscillator (HXT) clock fail detector Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>4~32 MHz external high speed crystal oscillator (HXT) clock fail detector Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>LXTFDEN</name>
              <description>LXT Clock Fail Detector Enable Bit</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>32.768 kHz external low speed crystal oscillator (LXT) clock fail detector Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>32.768 kHz external low speed crystal oscillator (LXT) clock fail detector Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>HXTFQDEN</name>
              <description>HXT Clock Frequency Monitor Enable Bit</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>4~32 MHz external high speed crystal oscillator (HXT) clock frequency monitor Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>4~32 MHz external high speed crystal oscillator (HXT) clock frequency monitor Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CLK_CLKDIE</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CLK_CLKDIE</displayName>
          <description>Clock Fail Detector Interrupt Enable Register</description>
          <addressOffset>0x3C</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>HXTFIEN</name>
              <description>HXT Clock Fail Interrupt Enable Bit</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>4~32 MHz external high speed crystal oscillator (HXT) clock fail interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>4~32 MHz external high speed crystal oscillator (HXT) clock fail interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>LXTFIEN</name>
              <description>LXT Clock Fail Interrupt Enable Bit</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>32.768 kHz external low speed crystal oscillator (LXT) clock fail interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>32.768 kHz external low speed crystal oscillator (LXT) clock fail interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>HXTFQIEN</name>
              <description>HXT Clock Frequency Monitor Interrupt Enable Bit</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>4~32 MHz external high speed crystal oscillator (HXT) clock frequency monitor fail interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>4~32 MHz external high speed crystal oscillator (HXT) clock frequency monitor fail interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CLK_CLKDSTS</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CLK_CLKDSTS</displayName>
          <description>Clock Fail Detector Status Register</description>
          <addressOffset>0x40</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>HXTFIF</name>
              <description>HXT Clock Fail Interrupt Flag\nNote: Write 1 to clear the bit to 0.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>4~32 MHz external high speed crystal oscillator (HXT) clock is normal</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>4~32 MHz external high speed crystal oscillator (HXT) clock stops</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>LXTFIF</name>
              <description>LXT Clock Fail Interrupt Flag\nNote: Write 1 to clear the bit to 0.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>32.768 kHz external low speed crystal oscillator (LXT) clock is normal</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>32.768 kHz external low speed crystal oscillator (LXT) stops</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>HXTFQIF</name>
              <description>HXT Clock Frequency Monitor Interrupt Flag\nNote: Write 1 to clear the bit to 0.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>4~32 MHz external high speed crystal oscillator (HXT) clock is normal</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>4~32 MHz external high speed crystal oscillator (HXT) clock frequency is abnormal</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CLK_CDUPB</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CLK_CDUPB</displayName>
          <description>Clock Frequency Detector Upper Boundary Register</description>
          <addressOffset>0x44</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>UPERBD</name>
              <description>HXT Clock Frequency Detector Upper Boundary\nThe bits define the high value of frequency monitor window.\nWhen HXT frequency monitor value higher than this register, the HXT frequency detect fail interrupt flag will set to 1.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>11</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CLK_CDLOWB</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CLK_CDLOWB</displayName>
          <description>Clock Frequency Detector Lower Boundary Register</description>
          <addressOffset>0x48</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>LOWERBD</name>
              <description>HXT Clock Frequency Detector Lower Boundary\nThe bits define the low value of frequency monitor window.\nWhen HXT frequency monitor value lower than this register, the HXT frequency detect fail interrupt flag will set to 1.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>11</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>FMC</name>
      <description>FMC Register Map</description>
      <groupName>FMC</groupName>
      <baseAddress>0x5000C000</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x0</offset>
        <size>0x1C</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x40</offset>
        <size>0x4</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x50</offset>
        <size>0x1C</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>FMC_ISPCTL</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>FMC_ISPCTL</displayName>
          <description>ISP Control Register</description>
          <addressOffset>0x0</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ISPEN</name>
              <description>ISP Enable Bit (Write Protect)\nISP function enable bit. Set this bit to enable ISP function.\nNote: This bit is write protected. Refer to the SYS_REGLCTL register.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>ISP function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>ISP function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BS</name>
              <description>Boot Select (Write Protect)\nSet/clear this bit to select next booting from LDROM/APROM, respectively. This bit also functions as chip booting status flag, which can be used to check where chip booted from. This bit is initiated with the inversed value of CBS[1]  (CONFIG0[7]) after any reset is happened except CPU reset (CPU is 1) or system reset (SYS) is happened\nNote: This bit is write protected. Refer to the SYS_REGLCTL register.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Booting from APROM</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Booting from LDROM</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SPUEN</name>
              <description>SPROM Update Enable Bit (Write Protect)\nNote: This bit is write protected. Refer to the SYS_REGLCTL register.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>SPROM cannot be updated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>SPROM can be updated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>APUEN</name>
              <description>APROM Update Enable Bit (Write Protect)\nNote: This bit is write protected. Refer to the SYS_REGLCTL register.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>APROM cannot be updated when the chip runs in APROM</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>APROM can be updated when the chip runs in APROM</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CFGUEN</name>
              <description>CONFIG Update Enable Bit (Write Protect)\nNote: This bit is write protected. Refer to the SYS_REGLCTL register.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>CONFIG cannot be updated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>CONFIG can be updated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>LDUEN</name>
              <description>LDROM Update Enable Bit (Write Protect)\nLDROM update enable bit.\nNote: This bit is write protected. Refer to the SYS_REGLCTL register.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>LDROM cannot be updated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>LDROM can be updated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ISPFF</name>
              <description>ISP Fail Flag (Write Protect)\nThis bit is set by hardware when a triggered ISP meets any of the following conditions:\nThis bit needs to be cleared by writing 1 to it.\n(1) APROM writes to itself if APUEN is set to 0.\n(2) LDROM writes to itself if LDUEN is set to 0.\n(3) CONFIG is erased/programmed if CFGUEN is set to 0.\n(4) SPROM is erased/programmed if SPUEN is set to 0\n(5) SPROM is programmed at SPROM secured mode.\n(6) Page Erase command at LOCK mode with ICE connection\n(7) Erase or Program command at brown-out detected\n(8) Destination address is illegal, such as over an available range.\n(9) Invalid ISP commands\n(10) Vector address  is mapping to SPROM region\n(11) KPROM is erased/programmed if KEYLOCK is set to 1\n(12) APROM(not include Data Flash) is erased/programmed if KEYLOCK is set to 1\nNote: This bit is write protected. Refer to the SYS_REGLCTL register.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>FMC_ISPADDR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>FMC_ISPADDR</displayName>
          <description>ISP Address Register</description>
          <addressOffset>0x4</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ISPADDR</name>
              <description>ISP Address\nThe Nano103 series is equipped with embedded flash. ISPADDR [1:0] must be kept 00 for ISP 32-bit operation. \nFor both CRC-32 Checksum Calculation and Flash All-One Verification commands, this field is the flash starting address for checksum calculation and 512 bytes address alignment is necessary.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>FMC_ISPDAT</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>FMC_ISPDAT</displayName>
          <description>ISP Data Register</description>
          <addressOffset>0x8</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ISPDAT</name>
              <description>ISP Data\nWrite data to this register before ISP program operation.\nRead data from this register after ISP read operation.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>FMC_ISPCMD</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>FMC_ISPCMD</displayName>
          <description>ISP CMD Register</description>
          <addressOffset>0xC</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CMD</name>
              <description>ISP CMD\nISP command table is shown below:\nThe other commands are invalid.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>6</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>FLASH 32-bit Read</description>
                    <value>0x00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>4</name>
                    <description>Read Unique ID</description>
                    <value>0x04</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>8</name>
                    <description>Read All-One Verification Result</description>
                    <value>0x08</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>11</name>
                    <description>Read Company ID</description>
                    <value>0x0b</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>12</name>
                    <description>Read Device ID</description>
                    <value>0x0c</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>13</name>
                    <description>Read Checksum</description>
                    <value>0x0d</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>33</name>
                    <description>FLASH 32-bit Program</description>
                    <value>0x21</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>34</name>
                    <description>FLASH Page Erase</description>
                    <value>0x22</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>38</name>
                    <description>FLASH Mass Erase</description>
                    <value>0x26</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>40</name>
                    <description>Run All-One Verification</description>
                    <value>0x28</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>45</name>
                    <description>Run CRC-32 Checksum Calculation</description>
                    <value>0x2d</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>46</name>
                    <description>Vector Remap</description>
                    <value>0x2e</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>FMC_ISPTRG</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>FMC_ISPTRG</displayName>
          <description>ISP Trigger Control Register</description>
          <addressOffset>0x10</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ISPGO</name>
              <description>ISP Start Trigger (Write Protect)\nWrite 1 to start ISP operation and this bit will be cleared to 0 by hardware automatically when ISP operation is finished.\nNote:This bit is write protected. Refer to the SYS_REGLCTL register.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>ISP operation is finished</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>ISP is progressed</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>FMC_DFBA</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>FMC_DFBA</displayName>
          <description>Data Flash Base Address</description>
          <addressOffset>0x14</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>DFBA</name>
              <description>Data Flash Base Address\nThis register indicates Data Flash start address. It is a read only register.\nThe Data Flash is shared with APROM. the content of this register is loaded from CONFIG1</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>FMC_FTCTL</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>FMC_FTCTL</displayName>
          <description>Flash Access Time Control Register</description>
          <addressOffset>0x18</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000040</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>FOM</name>
              <description>Frequency Optimization Mode (Write Protect)\nThe Nano103 series supports adjustable flash access timing to optimize the flash access cycles in different working frequency.\nNote:This bit is write protected. Refer to the SYS_REGLCTL register.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>3</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Frequency   20MHz</description>
                    <value>#001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>4</name>
                    <description>Frequency   40MHz. (default power-on setting)</description>
                    <value>#100</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CACHEOFF</name>
              <description>Flash Cache Disable Control (Write Protect)\nNote:This bit is write protected. Refer to the SYS_REGLCTL register.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Flash Cache function Enabled (default)</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Flash Cache function Disabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>FMC_ISPSTS</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>FMC_ISPSTS</displayName>
          <description>ISP Status Register</description>
          <addressOffset>0x40</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ISPBUSY</name>
              <description>ISP Busy Flag (Read Only)\nWrite 1 to start ISP operation and this bit will be cleared to 0 by hardware automatically when ISP operation is finished.\nThis bit is the mirror of ISPGO(FMC_ISPTRG[0]).</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>ISP operation is finished</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>ISP is progressed</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>CBS</name>
              <description>Boot Selection of CONFIG (Read Only)\nThis bit is initiated with the CBS (CONFIG0 [7:6]) after any reset is happened except CPU reset (CPU is 1) or system reset (SYS) is happened.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>LDROM with IAP mode</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>LDROM without IAP mode</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>APROM with IAP mode</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>APROM without IAP mode</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>PGFF</name>
              <description>Flash Program with Fast Verification Flag(Read Only)\nThis bit is set if data is mismatched at ISP programming verification. This bit is clear by performing ISP flash erase or ISP read CID operation</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Flash Program is success</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Flash Program is fail. Program data is different with data in the flash memory</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>ISPFF</name>
              <description>ISP Fail Flag (Write Protect)\nThis bit is the mirror of ISPFF (FMC_ISPCTL[6]), it needs to be cleared by writing 1 to FMC_ISPCTL[6] or FMC_ISPSTS[6]. This bit is set by hardware when a triggered ISP meets any of the following conditions:\n(1) APROM writes to itself if APUEN is set to 0.\n(2) LDROM writes to itself if LDUEN is set to 0.\n(3) CONFIG is erased/programmed if CFGUEN is set to 0.\n(4) SPROM is erased/programmed if SPUEN is set to 0\n(5) SPROM is programmed at SPROM secured mode.\n(6) Page Erase command at LOCK mode with ICE connection\n(7) Erase or Program command at brown-out detected\n(8) Destination address is illegal, such as over an available range.\n(9) Invalid ISP commands\n(10) Vector address  is mapping to SPROM region\n(11) KPROM is erased/programmed if KEYLOCK is set to 1\n(12) APROM(not include Data Flash) is erased/programmed if KEYLOCK is set to 1\nNote: This bit is write-protected. Refer to the SYS_REGLCTL register.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ALLONE</name>
              <description>Flash All-one Verification Flag\nThis bit is set by hardware if all of flash bits are 1, and clear if flash bits are not all 1 after "Run Flash All-One Verification" complete; this bit also can be clear by writing 1</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>All of flash bits are 1 after "Run Flash All-One Verification" complete</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Flash bits are not all 1 after "Run Flash All-One Verification" complete</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>VECMAP</name>
              <description>Vector Page Mapping Address (Read Only)\nAll access to 0x0000_0000~0x0000_01FF is remapped to the flash memory or SRAM address {VECMAP[20:0], 9'h000} ~ {VECMAP[20:0], 9'h1FF}\nVECMAP [18:12] should be 0.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>21</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>SCODE</name>
              <description>Security Code Active Flag\nThis bit is set by hardware when detecting SPROM secured code is active at flash initiation, or software writes 1 to this bit to make secured code active; this bit is clear by SPROM page erase operation.</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Secured code is inactive</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Secured code is active</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>FMC_KEY0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>FMC_KEY0</displayName>
          <description>KEY0 Data Register</description>
          <addressOffset>0x50</addressOffset>
          <access>write-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>KEY0</name>
              <description>KEY0 Data (Write Only)\nWrite KEY0 data to this register before KEY Comparison operation.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>FMC_KEY1</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>FMC_KEY1</displayName>
          <description>KEY1 Data Register</description>
          <addressOffset>0x54</addressOffset>
          <access>write-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>KEY1</name>
              <description>KEY1 Data (Write Only)\nWrite KEY1 data to this register before KEY Comparison operation.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>FMC_KEY2</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>FMC_KEY2</displayName>
          <description>KEY2 Data Register</description>
          <addressOffset>0x58</addressOffset>
          <access>write-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>KEY2</name>
              <description>KEY2 Data (Write Only)\nWrite KEY2 data to this register before KEY Comparison operation.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>FMC_KEYTRG</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>FMC_KEYTRG</displayName>
          <description>KEY Comparison Trigger Control Register</description>
          <addressOffset>0x5C</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>KEYGO</name>
              <description>KEY Comparison Start Trigger (Write Protection)\nWrite 1 to start KEY comparison operation and this bit will be cleared to 0 by hardware automatically when KEY comparison operation is finished. This trigger operation is valid while FORBID (FMC_KEYSTS [3]) is 0.\nNote:This bit is write-protected. Refer to the SYS_REGLCTL register.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>KEY comparison operation is finished</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>KEY comparison is progressed</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TCEN</name>
              <description>Time-out Counting Enable Bit (Write Protection)\n10 minutes is at least for time-out, and average is about 20 minutes.\nNote:This bit is write-protected. Refer to the SYS_REGLCTL register.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Time-out counting Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Time-out counting Enabled if key is matched after key comparison finish</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>FMC_KEYSTS</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>FMC_KEYSTS</displayName>
          <description>KEY Comparison Status Register</description>
          <addressOffset>0x60</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>KEYBUSY</name>
              <description>KEY Comparison Busy (Read Only)</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>KEY comparison is finished</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>KEY comparison is busy</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>KEYLOCK</name>
              <description>KEY LOCK Flag\nThis bit is set to 1 if KEYMATCH (FMC_KEYSTS [2]) is 0 and cleared to 0 if KEYMATCH is 1 in Security Key protection. This bit also can be set to 1 while \nCPU write 1 to KEYLOCK(FMC_KEYSTS[1]) or\nKEYFLAG(FMC_KEYSTS[4]) is 1 at power-on or reset or\nKEYENROM is programmed a non-0xFF value or\nTime-out event or\nFORBID(FMC_KEYSTS[3]) is 1\nSPROM write protect is depended on SPFLAG.\nCONFIG write protect is depended on CFGFLAG</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>KPROM and APROM (not include Data Flash) is not in write protection</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>KPROM and APROM (not include Data Flash) is in write protection</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>KEYMATCH</name>
              <description>KEY Match Flag(Read Only)\nThis bit is set to 1 after KEY comparison complete if the KEY0, KEY1 and KEY2 are matched with the 96-bit security keys in KPROM; and cleared to 0 if KEYs are unmatched. This bit is also cleared to 0 while \nCPU writing 1 to KEYLOCK(FMC_KEYSTS[1]) or\nTime-out event or\nKPROM is erased or\nKEYENROM is programmed to a non-0xFF value.\nChip is in Power-down mode.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>KEY0, KEY1, and KEY2 are unmatched with the KPROM setting</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>KEY0, KEY1, and KEY2 are matched with the KPROM setting</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>FORBID</name>
              <description>KEY Comparison Forbidden Flag(Read Only)\nThis bit is set to 1 whenKECNT(FMC_KECNT[4:0])is more than KEMAX (FMC_KECNT[12:8]) orKPCNT (FMC_KPCNT [2:0])is more than KPMAX (FMC_KPCNT [10:8]). </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>KEY comparison is not forbidden</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>KEY comparison is forbidden, KEYGO (FMC_KEYTRG [0]) cannot trigger</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>KEYFLAG</name>
              <description>KEY Protection Enable Flag(Read Only)\nThis bit is set while the KEYENROM [7:0] is not 0xFF at power-on or reset. This bit is cleared to 0 by hardware while KPROM is erased. This bit is set to 1 by hardware while KEYENROM is programmed to a non-0xFF value.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Security Key protection Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Security KeyprotectionEnabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>CFGFLAG</name>
              <description>CONFIG Write-protection Enable Flag(Read Only)\nThis bit is set while the KEYENROM [0] is 0 at power-on or reset. This bit is cleared to 0 by hardware while KPROM is erased. This bit is set to 1 by hardware while KEYENROM[0] is programmed to 0.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>CONFIG write-protection Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>CONFIG write-protection Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>SPFLAG</name>
              <description>SPROM Write-protection Enable Flag(Read Only)\nThis bit is set while the KEYENROM [1] is 0 at power-on or reset. This bit is cleared to 0 by hardware while KPROM is erased. This bit is set to 1 by hardware while KEYENROM[1] is programmed to 0.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>SPROM write-protection Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>SPROM write-protection Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>FMC_KECNT</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>FMC_KECNT</displayName>
          <description>KEY-Unmatched Counting Register</description>
          <addressOffset>0x64</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFF00FF</resetMask>
          <fields>
            <field>
              <name>KECNT</name>
              <description>Error Key Entry Counter at Each Power-on (Read Only)\nKECNT is increased when entry keys is wrong in Security Key protection. KECNT is cleared to 0 if key comparison is matched or system power-on.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>KEMAX</name>
              <description>Maximum Number for Error Key Entry at Each Power-on (Read Only)\nKEMAX is the maximum error key entry number at each power-on. When KEMAXROM of KPROM is erased or programmed, KEMAX will also be updated. KEMAX is used to limit KECNT(FMC_KECNT[5:0]) maximum counting. The FORBID (FMC_KEYSTS [3]) will be set to 1 when KECNT is more than KEMAX.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>FMC_KPCNT</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>FMC_KPCNT</displayName>
          <description>KEY-Unmatched Power-on Counting Register</description>
          <addressOffset>0x68</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFF0FF</resetMask>
          <fields>
            <field>
              <name>KPCNT</name>
              <description>Power-on Counter for Error Key Entry(Read Only)\nKPCNT is the power-on counting for error key entry in Security Key protection. KPCNT is cleared to 0 if key comparison is matched.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>KPMAX</name>
              <description>Power-on Maximum Number for Error Key Entry (Read Only)\nKPMAX is the power-on maximum number for error key entry. When KPMAXROM of KPROM is erased or programmed, KPMAX will also be updated. KPMAX is used to limit KPCNT (FMC_KPCNT [3:0]) maximum counting. The FORBID(FMC_KEYSTS[3]) will be set to 1 when KPCNT is more than KPMAX</description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>GPIO</name>
      <description>GPIO Register Map</description>
      <groupName>GPIO</groupName>
      <baseAddress>0x50004000</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x0</offset>
        <size>0x2C</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x40</offset>
        <size>0x2C</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x80</offset>
        <size>0x2C</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0xC0</offset>
        <size>0x2C</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x100</offset>
        <size>0x2C</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x140</offset>
        <size>0x2C</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x180</offset>
        <size>0x4</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x200</offset>
        <size>0x13C</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x340</offset>
        <size>0x20</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>PA_MODE</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PA_MODE</displayName>
          <description>PA I/O Mode Control</description>
          <addressOffset>0x0</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>MODE0</name>
              <description>Port A-f I/O Pin[N] Mode Control\nDetermine each I/O mode of Px.n pins.\nNote2:\nThePA.7/PB.12/PC.4/PC.5/PC.12/PC.13/PD.0/PD.1/PD.2/PD.3/PD.4/PD.5/PD.8/PD.9/PD.10/PD.11/PD.12/PD.13/PE.0/PE.1/PE.2/PE.3/PE.4/PE.6/PE.7/PE.8/PE.9/PE.10/PE.11/PE.12/PE.13/PE.14/PE.15/PF.4/PF.5 pin is ignored.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Px.n is in Input mode</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Px.n is in Push-pull Output mode</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Px.n is in Open-drain Output mode</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Reserved</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>MODE1</name>
              <description>Port A-f I/O Pin[N] Mode Control\nDetermine each I/O mode of Px.n pins.\nNote2:\nThePA.7/PB.12/PC.4/PC.5/PC.12/PC.13/PD.0/PD.1/PD.2/PD.3/PD.4/PD.5/PD.8/PD.9/PD.10/PD.11/PD.12/PD.13/PE.0/PE.1/PE.2/PE.3/PE.4/PE.6/PE.7/PE.8/PE.9/PE.10/PE.11/PE.12/PE.13/PE.14/PE.15/PF.4/PF.5 pin is ignored.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Px.n is in Input mode</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Px.n is in Push-pull Output mode</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Px.n is in Open-drain Output mode</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Reserved</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>MODE2</name>
              <description>Port A-f I/O Pin[N] Mode Control\nDetermine each I/O mode of Px.n pins.\nNote2:\nThePA.7/PB.12/PC.4/PC.5/PC.12/PC.13/PD.0/PD.1/PD.2/PD.3/PD.4/PD.5/PD.8/PD.9/PD.10/PD.11/PD.12/PD.13/PE.0/PE.1/PE.2/PE.3/PE.4/PE.6/PE.7/PE.8/PE.9/PE.10/PE.11/PE.12/PE.13/PE.14/PE.15/PF.4/PF.5 pin is ignored.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Px.n is in Input mode</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Px.n is in Push-pull Output mode</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Px.n is in Open-drain Output mode</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Reserved</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>MODE3</name>
              <description>Port A-f I/O Pin[N] Mode Control\nDetermine each I/O mode of Px.n pins.\nNote2:\nThePA.7/PB.12/PC.4/PC.5/PC.12/PC.13/PD.0/PD.1/PD.2/PD.3/PD.4/PD.5/PD.8/PD.9/PD.10/PD.11/PD.12/PD.13/PE.0/PE.1/PE.2/PE.3/PE.4/PE.6/PE.7/PE.8/PE.9/PE.10/PE.11/PE.12/PE.13/PE.14/PE.15/PF.4/PF.5 pin is ignored.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Px.n is in Input mode</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Px.n is in Push-pull Output mode</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Px.n is in Open-drain Output mode</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Reserved</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>MODE4</name>
              <description>Port A-f I/O Pin[N] Mode Control\nDetermine each I/O mode of Px.n pins.\nNote2:\nThePA.7/PB.12/PC.4/PC.5/PC.12/PC.13/PD.0/PD.1/PD.2/PD.3/PD.4/PD.5/PD.8/PD.9/PD.10/PD.11/PD.12/PD.13/PE.0/PE.1/PE.2/PE.3/PE.4/PE.6/PE.7/PE.8/PE.9/PE.10/PE.11/PE.12/PE.13/PE.14/PE.15/PF.4/PF.5 pin is ignored.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Px.n is in Input mode</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Px.n is in Push-pull Output mode</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Px.n is in Open-drain Output mode</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Reserved</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>MODE5</name>
              <description>Port A-f I/O Pin[N] Mode Control\nDetermine each I/O mode of Px.n pins.\nNote2:\nThePA.7/PB.12/PC.4/PC.5/PC.12/PC.13/PD.0/PD.1/PD.2/PD.3/PD.4/PD.5/PD.8/PD.9/PD.10/PD.11/PD.12/PD.13/PE.0/PE.1/PE.2/PE.3/PE.4/PE.6/PE.7/PE.8/PE.9/PE.10/PE.11/PE.12/PE.13/PE.14/PE.15/PF.4/PF.5 pin is ignored.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Px.n is in Input mode</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Px.n is in Push-pull Output mode</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Px.n is in Open-drain Output mode</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Reserved</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>MODE6</name>
              <description>Port A-f I/O Pin[N] Mode Control\nDetermine each I/O mode of Px.n pins.\nNote2:\nThePA.7/PB.12/PC.4/PC.5/PC.12/PC.13/PD.0/PD.1/PD.2/PD.3/PD.4/PD.5/PD.8/PD.9/PD.10/PD.11/PD.12/PD.13/PE.0/PE.1/PE.2/PE.3/PE.4/PE.6/PE.7/PE.8/PE.9/PE.10/PE.11/PE.12/PE.13/PE.14/PE.15/PF.4/PF.5 pin is ignored.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Px.n is in Input mode</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Px.n is in Push-pull Output mode</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Px.n is in Open-drain Output mode</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Reserved</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>MODE7</name>
              <description>Port A-f I/O Pin[N] Mode Control\nDetermine each I/O mode of Px.n pins.\nNote2:\nThePA.7/PB.12/PC.4/PC.5/PC.12/PC.13/PD.0/PD.1/PD.2/PD.3/PD.4/PD.5/PD.8/PD.9/PD.10/PD.11/PD.12/PD.13/PE.0/PE.1/PE.2/PE.3/PE.4/PE.6/PE.7/PE.8/PE.9/PE.10/PE.11/PE.12/PE.13/PE.14/PE.15/PF.4/PF.5 pin is ignored.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Px.n is in Input mode</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Px.n is in Push-pull Output mode</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Px.n is in Open-drain Output mode</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Reserved</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>MODE8</name>
              <description>Port A-f I/O Pin[N] Mode Control\nDetermine each I/O mode of Px.n pins.\nNote2:\nThePA.7/PB.12/PC.4/PC.5/PC.12/PC.13/PD.0/PD.1/PD.2/PD.3/PD.4/PD.5/PD.8/PD.9/PD.10/PD.11/PD.12/PD.13/PE.0/PE.1/PE.2/PE.3/PE.4/PE.6/PE.7/PE.8/PE.9/PE.10/PE.11/PE.12/PE.13/PE.14/PE.15/PF.4/PF.5 pin is ignored.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Px.n is in Input mode</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Px.n is in Push-pull Output mode</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Px.n is in Open-drain Output mode</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Reserved</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>MODE9</name>
              <description>Port A-f I/O Pin[N] Mode Control\nDetermine each I/O mode of Px.n pins.\nNote2:\nThePA.7/PB.12/PC.4/PC.5/PC.12/PC.13/PD.0/PD.1/PD.2/PD.3/PD.4/PD.5/PD.8/PD.9/PD.10/PD.11/PD.12/PD.13/PE.0/PE.1/PE.2/PE.3/PE.4/PE.6/PE.7/PE.8/PE.9/PE.10/PE.11/PE.12/PE.13/PE.14/PE.15/PF.4/PF.5 pin is ignored.</description>
              <bitOffset>18</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Px.n is in Input mode</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Px.n is in Push-pull Output mode</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Px.n is in Open-drain Output mode</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Reserved</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>MODE10</name>
              <description>Port A-f I/O Pin[N] Mode Control\nDetermine each I/O mode of Px.n pins.\nNote2:\nThePA.7/PB.12/PC.4/PC.5/PC.12/PC.13/PD.0/PD.1/PD.2/PD.3/PD.4/PD.5/PD.8/PD.9/PD.10/PD.11/PD.12/PD.13/PE.0/PE.1/PE.2/PE.3/PE.4/PE.6/PE.7/PE.8/PE.9/PE.10/PE.11/PE.12/PE.13/PE.14/PE.15/PF.4/PF.5 pin is ignored.</description>
              <bitOffset>20</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Px.n is in Input mode</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Px.n is in Push-pull Output mode</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Px.n is in Open-drain Output mode</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Reserved</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>MODE11</name>
              <description>Port A-f I/O Pin[N] Mode Control\nDetermine each I/O mode of Px.n pins.\nNote2:\nThePA.7/PB.12/PC.4/PC.5/PC.12/PC.13/PD.0/PD.1/PD.2/PD.3/PD.4/PD.5/PD.8/PD.9/PD.10/PD.11/PD.12/PD.13/PE.0/PE.1/PE.2/PE.3/PE.4/PE.6/PE.7/PE.8/PE.9/PE.10/PE.11/PE.12/PE.13/PE.14/PE.15/PF.4/PF.5 pin is ignored.</description>
              <bitOffset>22</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Px.n is in Input mode</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Px.n is in Push-pull Output mode</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Px.n is in Open-drain Output mode</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Reserved</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>MODE12</name>
              <description>Port A-f I/O Pin[N] Mode Control\nDetermine each I/O mode of Px.n pins.\nNote2:\nThePA.7/PB.12/PC.4/PC.5/PC.12/PC.13/PD.0/PD.1/PD.2/PD.3/PD.4/PD.5/PD.8/PD.9/PD.10/PD.11/PD.12/PD.13/PE.0/PE.1/PE.2/PE.3/PE.4/PE.6/PE.7/PE.8/PE.9/PE.10/PE.11/PE.12/PE.13/PE.14/PE.15/PF.4/PF.5 pin is ignored.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Px.n is in Input mode</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Px.n is in Push-pull Output mode</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Px.n is in Open-drain Output mode</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Reserved</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>MODE13</name>
              <description>Port A-f I/O Pin[N] Mode Control\nDetermine each I/O mode of Px.n pins.\nNote2:\nThePA.7/PB.12/PC.4/PC.5/PC.12/PC.13/PD.0/PD.1/PD.2/PD.3/PD.4/PD.5/PD.8/PD.9/PD.10/PD.11/PD.12/PD.13/PE.0/PE.1/PE.2/PE.3/PE.4/PE.6/PE.7/PE.8/PE.9/PE.10/PE.11/PE.12/PE.13/PE.14/PE.15/PF.4/PF.5 pin is ignored.</description>
              <bitOffset>26</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Px.n is in Input mode</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Px.n is in Push-pull Output mode</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Px.n is in Open-drain Output mode</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Reserved</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>MODE14</name>
              <description>Port A-f I/O Pin[N] Mode Control\nDetermine each I/O mode of Px.n pins.\nNote2:\nThePA.7/PB.12/PC.4/PC.5/PC.12/PC.13/PD.0/PD.1/PD.2/PD.3/PD.4/PD.5/PD.8/PD.9/PD.10/PD.11/PD.12/PD.13/PE.0/PE.1/PE.2/PE.3/PE.4/PE.6/PE.7/PE.8/PE.9/PE.10/PE.11/PE.12/PE.13/PE.14/PE.15/PF.4/PF.5 pin is ignored.</description>
              <bitOffset>28</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Px.n is in Input mode</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Px.n is in Push-pull Output mode</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Px.n is in Open-drain Output mode</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Reserved</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>MODE15</name>
              <description>Port A-f I/O Pin[N] Mode Control\nDetermine each I/O mode of Px.n pins.\nNote2:\nThePA.7/PB.12/PC.4/PC.5/PC.12/PC.13/PD.0/PD.1/PD.2/PD.3/PD.4/PD.5/PD.8/PD.9/PD.10/PD.11/PD.12/PD.13/PE.0/PE.1/PE.2/PE.3/PE.4/PE.6/PE.7/PE.8/PE.9/PE.10/PE.11/PE.12/PE.13/PE.14/PE.15/PF.4/PF.5 pin is ignored.</description>
              <bitOffset>30</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Px.n is in Input mode</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Px.n is in Push-pull Output mode</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Px.n is in Open-drain Output mode</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Reserved</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PA_DINOFF</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PA_DINOFF</displayName>
          <description>PA Digital Input Path Disable Control</description>
          <addressOffset>0x4</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DINOFF0</name>
              <description>Port A-f Pin[N] Digital Input Path Disable Bit\nEach of these bits is used to control if the digital input path of corresponding Px.n pin is disabled. If input is analog signal, users can disable Px.n digital input path to avoid input current leakage.\nNote2:\nThePA.7/PB.12/PC.4/PC.5/PC.12/PC.13/PD.0/PD.1/PD.2/PD.3/PD.4/PD.5/PD.8/PD.9/PD.10/PD.11/PD.12/PD.13/PE.0/PE.1/PE.2/PE.3/PE.4/PE.6/PE.7/PE.8/PE.9/PE.10/PE.11/PE.12/PE.13/PE.14/PE.15/PF.4/PF.5 pin is ignored.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Px.n digital input path Enabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Px.n digital input path Disabled (digital input tied to low)</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DINOFF1</name>
              <description>Port A-f Pin[N] Digital Input Path Disable Bit\nEach of these bits is used to control if the digital input path of corresponding Px.n pin is disabled. If input is analog signal, users can disable Px.n digital input path to avoid input current leakage.\nNote2:\nThePA.7/PB.12/PC.4/PC.5/PC.12/PC.13/PD.0/PD.1/PD.2/PD.3/PD.4/PD.5/PD.8/PD.9/PD.10/PD.11/PD.12/PD.13/PE.0/PE.1/PE.2/PE.3/PE.4/PE.6/PE.7/PE.8/PE.9/PE.10/PE.11/PE.12/PE.13/PE.14/PE.15/PF.4/PF.5 pin is ignored.</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Px.n digital input path Enabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Px.n digital input path Disabled (digital input tied to low)</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DINOFF2</name>
              <description>Port A-f Pin[N] Digital Input Path Disable Bit\nEach of these bits is used to control if the digital input path of corresponding Px.n pin is disabled. If input is analog signal, users can disable Px.n digital input path to avoid input current leakage.\nNote2:\nThePA.7/PB.12/PC.4/PC.5/PC.12/PC.13/PD.0/PD.1/PD.2/PD.3/PD.4/PD.5/PD.8/PD.9/PD.10/PD.11/PD.12/PD.13/PE.0/PE.1/PE.2/PE.3/PE.4/PE.6/PE.7/PE.8/PE.9/PE.10/PE.11/PE.12/PE.13/PE.14/PE.15/PF.4/PF.5 pin is ignored.</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Px.n digital input path Enabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Px.n digital input path Disabled (digital input tied to low)</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DINOFF3</name>
              <description>Port A-f Pin[N] Digital Input Path Disable Bit\nEach of these bits is used to control if the digital input path of corresponding Px.n pin is disabled. If input is analog signal, users can disable Px.n digital input path to avoid input current leakage.\nNote2:\nThePA.7/PB.12/PC.4/PC.5/PC.12/PC.13/PD.0/PD.1/PD.2/PD.3/PD.4/PD.5/PD.8/PD.9/PD.10/PD.11/PD.12/PD.13/PE.0/PE.1/PE.2/PE.3/PE.4/PE.6/PE.7/PE.8/PE.9/PE.10/PE.11/PE.12/PE.13/PE.14/PE.15/PF.4/PF.5 pin is ignored.</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Px.n digital input path Enabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Px.n digital input path Disabled (digital input tied to low)</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DINOFF4</name>
              <description>Port A-f Pin[N] Digital Input Path Disable Bit\nEach of these bits is used to control if the digital input path of corresponding Px.n pin is disabled. If input is analog signal, users can disable Px.n digital input path to avoid input current leakage.\nNote2:\nThePA.7/PB.12/PC.4/PC.5/PC.12/PC.13/PD.0/PD.1/PD.2/PD.3/PD.4/PD.5/PD.8/PD.9/PD.10/PD.11/PD.12/PD.13/PE.0/PE.1/PE.2/PE.3/PE.4/PE.6/PE.7/PE.8/PE.9/PE.10/PE.11/PE.12/PE.13/PE.14/PE.15/PF.4/PF.5 pin is ignored.</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Px.n digital input path Enabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Px.n digital input path Disabled (digital input tied to low)</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DINOFF5</name>
              <description>Port A-f Pin[N] Digital Input Path Disable Bit\nEach of these bits is used to control if the digital input path of corresponding Px.n pin is disabled. If input is analog signal, users can disable Px.n digital input path to avoid input current leakage.\nNote2:\nThePA.7/PB.12/PC.4/PC.5/PC.12/PC.13/PD.0/PD.1/PD.2/PD.3/PD.4/PD.5/PD.8/PD.9/PD.10/PD.11/PD.12/PD.13/PE.0/PE.1/PE.2/PE.3/PE.4/PE.6/PE.7/PE.8/PE.9/PE.10/PE.11/PE.12/PE.13/PE.14/PE.15/PF.4/PF.5 pin is ignored.</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Px.n digital input path Enabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Px.n digital input path Disabled (digital input tied to low)</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DINOFF6</name>
              <description>Port A-f Pin[N] Digital Input Path Disable Bit\nEach of these bits is used to control if the digital input path of corresponding Px.n pin is disabled. If input is analog signal, users can disable Px.n digital input path to avoid input current leakage.\nNote2:\nThePA.7/PB.12/PC.4/PC.5/PC.12/PC.13/PD.0/PD.1/PD.2/PD.3/PD.4/PD.5/PD.8/PD.9/PD.10/PD.11/PD.12/PD.13/PE.0/PE.1/PE.2/PE.3/PE.4/PE.6/PE.7/PE.8/PE.9/PE.10/PE.11/PE.12/PE.13/PE.14/PE.15/PF.4/PF.5 pin is ignored.</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Px.n digital input path Enabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Px.n digital input path Disabled (digital input tied to low)</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DINOFF7</name>
              <description>Port A-f Pin[N] Digital Input Path Disable Bit\nEach of these bits is used to control if the digital input path of corresponding Px.n pin is disabled. If input is analog signal, users can disable Px.n digital input path to avoid input current leakage.\nNote2:\nThePA.7/PB.12/PC.4/PC.5/PC.12/PC.13/PD.0/PD.1/PD.2/PD.3/PD.4/PD.5/PD.8/PD.9/PD.10/PD.11/PD.12/PD.13/PE.0/PE.1/PE.2/PE.3/PE.4/PE.6/PE.7/PE.8/PE.9/PE.10/PE.11/PE.12/PE.13/PE.14/PE.15/PF.4/PF.5 pin is ignored.</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Px.n digital input path Enabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Px.n digital input path Disabled (digital input tied to low)</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DINOFF8</name>
              <description>Port A-f Pin[N] Digital Input Path Disable Bit\nEach of these bits is used to control if the digital input path of corresponding Px.n pin is disabled. If input is analog signal, users can disable Px.n digital input path to avoid input current leakage.\nNote2:\nThePA.7/PB.12/PC.4/PC.5/PC.12/PC.13/PD.0/PD.1/PD.2/PD.3/PD.4/PD.5/PD.8/PD.9/PD.10/PD.11/PD.12/PD.13/PE.0/PE.1/PE.2/PE.3/PE.4/PE.6/PE.7/PE.8/PE.9/PE.10/PE.11/PE.12/PE.13/PE.14/PE.15/PF.4/PF.5 pin is ignored.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Px.n digital input path Enabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Px.n digital input path Disabled (digital input tied to low)</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DINOFF9</name>
              <description>Port A-f Pin[N] Digital Input Path Disable Bit\nEach of these bits is used to control if the digital input path of corresponding Px.n pin is disabled. If input is analog signal, users can disable Px.n digital input path to avoid input current leakage.\nNote2:\nThePA.7/PB.12/PC.4/PC.5/PC.12/PC.13/PD.0/PD.1/PD.2/PD.3/PD.4/PD.5/PD.8/PD.9/PD.10/PD.11/PD.12/PD.13/PE.0/PE.1/PE.2/PE.3/PE.4/PE.6/PE.7/PE.8/PE.9/PE.10/PE.11/PE.12/PE.13/PE.14/PE.15/PF.4/PF.5 pin is ignored.</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Px.n digital input path Enabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Px.n digital input path Disabled (digital input tied to low)</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DINOFF10</name>
              <description>Port A-f Pin[N] Digital Input Path Disable Bit\nEach of these bits is used to control if the digital input path of corresponding Px.n pin is disabled. If input is analog signal, users can disable Px.n digital input path to avoid input current leakage.\nNote2:\nThePA.7/PB.12/PC.4/PC.5/PC.12/PC.13/PD.0/PD.1/PD.2/PD.3/PD.4/PD.5/PD.8/PD.9/PD.10/PD.11/PD.12/PD.13/PE.0/PE.1/PE.2/PE.3/PE.4/PE.6/PE.7/PE.8/PE.9/PE.10/PE.11/PE.12/PE.13/PE.14/PE.15/PF.4/PF.5 pin is ignored.</description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Px.n digital input path Enabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Px.n digital input path Disabled (digital input tied to low)</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DINOFF11</name>
              <description>Port A-f Pin[N] Digital Input Path Disable Bit\nEach of these bits is used to control if the digital input path of corresponding Px.n pin is disabled. If input is analog signal, users can disable Px.n digital input path to avoid input current leakage.\nNote2:\nThePA.7/PB.12/PC.4/PC.5/PC.12/PC.13/PD.0/PD.1/PD.2/PD.3/PD.4/PD.5/PD.8/PD.9/PD.10/PD.11/PD.12/PD.13/PE.0/PE.1/PE.2/PE.3/PE.4/PE.6/PE.7/PE.8/PE.9/PE.10/PE.11/PE.12/PE.13/PE.14/PE.15/PF.4/PF.5 pin is ignored.</description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Px.n digital input path Enabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Px.n digital input path Disabled (digital input tied to low)</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DINOFF12</name>
              <description>Port A-f Pin[N] Digital Input Path Disable Bit\nEach of these bits is used to control if the digital input path of corresponding Px.n pin is disabled. If input is analog signal, users can disable Px.n digital input path to avoid input current leakage.\nNote2:\nThePA.7/PB.12/PC.4/PC.5/PC.12/PC.13/PD.0/PD.1/PD.2/PD.3/PD.4/PD.5/PD.8/PD.9/PD.10/PD.11/PD.12/PD.13/PE.0/PE.1/PE.2/PE.3/PE.4/PE.6/PE.7/PE.8/PE.9/PE.10/PE.11/PE.12/PE.13/PE.14/PE.15/PF.4/PF.5 pin is ignored.</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Px.n digital input path Enabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Px.n digital input path Disabled (digital input tied to low)</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DINOFF13</name>
              <description>Port A-f Pin[N] Digital Input Path Disable Bit\nEach of these bits is used to control if the digital input path of corresponding Px.n pin is disabled. If input is analog signal, users can disable Px.n digital input path to avoid input current leakage.\nNote2:\nThePA.7/PB.12/PC.4/PC.5/PC.12/PC.13/PD.0/PD.1/PD.2/PD.3/PD.4/PD.5/PD.8/PD.9/PD.10/PD.11/PD.12/PD.13/PE.0/PE.1/PE.2/PE.3/PE.4/PE.6/PE.7/PE.8/PE.9/PE.10/PE.11/PE.12/PE.13/PE.14/PE.15/PF.4/PF.5 pin is ignored.</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Px.n digital input path Enabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Px.n digital input path Disabled (digital input tied to low)</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DINOFF14</name>
              <description>Port A-f Pin[N] Digital Input Path Disable Bit\nEach of these bits is used to control if the digital input path of corresponding Px.n pin is disabled. If input is analog signal, users can disable Px.n digital input path to avoid input current leakage.\nNote2:\nThePA.7/PB.12/PC.4/PC.5/PC.12/PC.13/PD.0/PD.1/PD.2/PD.3/PD.4/PD.5/PD.8/PD.9/PD.10/PD.11/PD.12/PD.13/PE.0/PE.1/PE.2/PE.3/PE.4/PE.6/PE.7/PE.8/PE.9/PE.10/PE.11/PE.12/PE.13/PE.14/PE.15/PF.4/PF.5 pin is ignored.</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Px.n digital input path Enabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Px.n digital input path Disabled (digital input tied to low)</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DINOFF15</name>
              <description>Port A-f Pin[N] Digital Input Path Disable Bit\nEach of these bits is used to control if the digital input path of corresponding Px.n pin is disabled. If input is analog signal, users can disable Px.n digital input path to avoid input current leakage.\nNote2:\nThePA.7/PB.12/PC.4/PC.5/PC.12/PC.13/PD.0/PD.1/PD.2/PD.3/PD.4/PD.5/PD.8/PD.9/PD.10/PD.11/PD.12/PD.13/PE.0/PE.1/PE.2/PE.3/PE.4/PE.6/PE.7/PE.8/PE.9/PE.10/PE.11/PE.12/PE.13/PE.14/PE.15/PF.4/PF.5 pin is ignored.</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Px.n digital input path Enabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Px.n digital input path Disabled (digital input tied to low)</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PA_DOUT</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PA_DOUT</displayName>
          <description>PA Data Output Value</description>
          <addressOffset>0x8</addressOffset>
          <access>read-write</access>
          <resetValue>0x0000FFFF</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DOUT0</name>
              <description>Port A-f Pin[N] Output Value\nEach of these bits controls the status of a Px.n pin when the Px.n is configured as Push-pull output, Open-drain output.\nNote2:\nThePA.7/PB.12/PC.4/PC.5/PC.12/PC.13/PD.0/PD.1/PD.2/PD.3/PD.4/PD.5/PD.8/PD.9/PD.10/PD.11/PD.12/PD.13/PE.0/PE.1/PE.2/PE.3/PE.4/PE.6/PE.7/PE.8/PE.9/PE.10/PE.11/PE.12/PE.13/PE.14/PE.15/PF.4/PF.5 pin is ignored.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Px.n will drive Low if the Px.n pin is configured as Push-pull output, Open-drain output</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Px.n will drive High if the Px.n pin is configured as Push-pull output</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DOUT1</name>
              <description>Port A-f Pin[N] Output Value\nEach of these bits controls the status of a Px.n pin when the Px.n is configured as Push-pull output, Open-drain output.\nNote2:\nThePA.7/PB.12/PC.4/PC.5/PC.12/PC.13/PD.0/PD.1/PD.2/PD.3/PD.4/PD.5/PD.8/PD.9/PD.10/PD.11/PD.12/PD.13/PE.0/PE.1/PE.2/PE.3/PE.4/PE.6/PE.7/PE.8/PE.9/PE.10/PE.11/PE.12/PE.13/PE.14/PE.15/PF.4/PF.5 pin is ignored.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Px.n will drive Low if the Px.n pin is configured as Push-pull output, Open-drain output</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Px.n will drive High if the Px.n pin is configured as Push-pull output</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DOUT2</name>
              <description>Port A-f Pin[N] Output Value\nEach of these bits controls the status of a Px.n pin when the Px.n is configured as Push-pull output, Open-drain output.\nNote2:\nThePA.7/PB.12/PC.4/PC.5/PC.12/PC.13/PD.0/PD.1/PD.2/PD.3/PD.4/PD.5/PD.8/PD.9/PD.10/PD.11/PD.12/PD.13/PE.0/PE.1/PE.2/PE.3/PE.4/PE.6/PE.7/PE.8/PE.9/PE.10/PE.11/PE.12/PE.13/PE.14/PE.15/PF.4/PF.5 pin is ignored.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Px.n will drive Low if the Px.n pin is configured as Push-pull output, Open-drain output</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Px.n will drive High if the Px.n pin is configured as Push-pull output</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DOUT3</name>
              <description>Port A-f Pin[N] Output Value\nEach of these bits controls the status of a Px.n pin when the Px.n is configured as Push-pull output, Open-drain output.\nNote2:\nThePA.7/PB.12/PC.4/PC.5/PC.12/PC.13/PD.0/PD.1/PD.2/PD.3/PD.4/PD.5/PD.8/PD.9/PD.10/PD.11/PD.12/PD.13/PE.0/PE.1/PE.2/PE.3/PE.4/PE.6/PE.7/PE.8/PE.9/PE.10/PE.11/PE.12/PE.13/PE.14/PE.15/PF.4/PF.5 pin is ignored.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Px.n will drive Low if the Px.n pin is configured as Push-pull output, Open-drain output</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Px.n will drive High if the Px.n pin is configured as Push-pull output</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DOUT4</name>
              <description>Port A-f Pin[N] Output Value\nEach of these bits controls the status of a Px.n pin when the Px.n is configured as Push-pull output, Open-drain output.\nNote2:\nThePA.7/PB.12/PC.4/PC.5/PC.12/PC.13/PD.0/PD.1/PD.2/PD.3/PD.4/PD.5/PD.8/PD.9/PD.10/PD.11/PD.12/PD.13/PE.0/PE.1/PE.2/PE.3/PE.4/PE.6/PE.7/PE.8/PE.9/PE.10/PE.11/PE.12/PE.13/PE.14/PE.15/PF.4/PF.5 pin is ignored.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Px.n will drive Low if the Px.n pin is configured as Push-pull output, Open-drain output</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Px.n will drive High if the Px.n pin is configured as Push-pull output</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DOUT5</name>
              <description>Port A-f Pin[N] Output Value\nEach of these bits controls the status of a Px.n pin when the Px.n is configured as Push-pull output, Open-drain output.\nNote2:\nThePA.7/PB.12/PC.4/PC.5/PC.12/PC.13/PD.0/PD.1/PD.2/PD.3/PD.4/PD.5/PD.8/PD.9/PD.10/PD.11/PD.12/PD.13/PE.0/PE.1/PE.2/PE.3/PE.4/PE.6/PE.7/PE.8/PE.9/PE.10/PE.11/PE.12/PE.13/PE.14/PE.15/PF.4/PF.5 pin is ignored.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Px.n will drive Low if the Px.n pin is configured as Push-pull output, Open-drain output</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Px.n will drive High if the Px.n pin is configured as Push-pull output</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DOUT6</name>
              <description>Port A-f Pin[N] Output Value\nEach of these bits controls the status of a Px.n pin when the Px.n is configured as Push-pull output, Open-drain output.\nNote2:\nThePA.7/PB.12/PC.4/PC.5/PC.12/PC.13/PD.0/PD.1/PD.2/PD.3/PD.4/PD.5/PD.8/PD.9/PD.10/PD.11/PD.12/PD.13/PE.0/PE.1/PE.2/PE.3/PE.4/PE.6/PE.7/PE.8/PE.9/PE.10/PE.11/PE.12/PE.13/PE.14/PE.15/PF.4/PF.5 pin is ignored.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Px.n will drive Low if the Px.n pin is configured as Push-pull output, Open-drain output</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Px.n will drive High if the Px.n pin is configured as Push-pull output</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DOUT7</name>
              <description>Port A-f Pin[N] Output Value\nEach of these bits controls the status of a Px.n pin when the Px.n is configured as Push-pull output, Open-drain output.\nNote2:\nThePA.7/PB.12/PC.4/PC.5/PC.12/PC.13/PD.0/PD.1/PD.2/PD.3/PD.4/PD.5/PD.8/PD.9/PD.10/PD.11/PD.12/PD.13/PE.0/PE.1/PE.2/PE.3/PE.4/PE.6/PE.7/PE.8/PE.9/PE.10/PE.11/PE.12/PE.13/PE.14/PE.15/PF.4/PF.5 pin is ignored.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Px.n will drive Low if the Px.n pin is configured as Push-pull output, Open-drain output</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Px.n will drive High if the Px.n pin is configured as Push-pull output</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DOUT8</name>
              <description>Port A-f Pin[N] Output Value\nEach of these bits controls the status of a Px.n pin when the Px.n is configured as Push-pull output, Open-drain output.\nNote2:\nThePA.7/PB.12/PC.4/PC.5/PC.12/PC.13/PD.0/PD.1/PD.2/PD.3/PD.4/PD.5/PD.8/PD.9/PD.10/PD.11/PD.12/PD.13/PE.0/PE.1/PE.2/PE.3/PE.4/PE.6/PE.7/PE.8/PE.9/PE.10/PE.11/PE.12/PE.13/PE.14/PE.15/PF.4/PF.5 pin is ignored.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Px.n will drive Low if the Px.n pin is configured as Push-pull output, Open-drain output</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Px.n will drive High if the Px.n pin is configured as Push-pull output</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DOUT9</name>
              <description>Port A-f Pin[N] Output Value\nEach of these bits controls the status of a Px.n pin when the Px.n is configured as Push-pull output, Open-drain output.\nNote2:\nThePA.7/PB.12/PC.4/PC.5/PC.12/PC.13/PD.0/PD.1/PD.2/PD.3/PD.4/PD.5/PD.8/PD.9/PD.10/PD.11/PD.12/PD.13/PE.0/PE.1/PE.2/PE.3/PE.4/PE.6/PE.7/PE.8/PE.9/PE.10/PE.11/PE.12/PE.13/PE.14/PE.15/PF.4/PF.5 pin is ignored.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Px.n will drive Low if the Px.n pin is configured as Push-pull output, Open-drain output</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Px.n will drive High if the Px.n pin is configured as Push-pull output</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DOUT10</name>
              <description>Port A-f Pin[N] Output Value\nEach of these bits controls the status of a Px.n pin when the Px.n is configured as Push-pull output, Open-drain output.\nNote2:\nThePA.7/PB.12/PC.4/PC.5/PC.12/PC.13/PD.0/PD.1/PD.2/PD.3/PD.4/PD.5/PD.8/PD.9/PD.10/PD.11/PD.12/PD.13/PE.0/PE.1/PE.2/PE.3/PE.4/PE.6/PE.7/PE.8/PE.9/PE.10/PE.11/PE.12/PE.13/PE.14/PE.15/PF.4/PF.5 pin is ignored.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Px.n will drive Low if the Px.n pin is configured as Push-pull output, Open-drain output</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Px.n will drive High if the Px.n pin is configured as Push-pull output</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DOUT11</name>
              <description>Port A-f Pin[N] Output Value\nEach of these bits controls the status of a Px.n pin when the Px.n is configured as Push-pull output, Open-drain output.\nNote2:\nThePA.7/PB.12/PC.4/PC.5/PC.12/PC.13/PD.0/PD.1/PD.2/PD.3/PD.4/PD.5/PD.8/PD.9/PD.10/PD.11/PD.12/PD.13/PE.0/PE.1/PE.2/PE.3/PE.4/PE.6/PE.7/PE.8/PE.9/PE.10/PE.11/PE.12/PE.13/PE.14/PE.15/PF.4/PF.5 pin is ignored.</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Px.n will drive Low if the Px.n pin is configured as Push-pull output, Open-drain output</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Px.n will drive High if the Px.n pin is configured as Push-pull output</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DOUT12</name>
              <description>Port A-f Pin[N] Output Value\nEach of these bits controls the status of a Px.n pin when the Px.n is configured as Push-pull output, Open-drain output.\nNote2:\nThePA.7/PB.12/PC.4/PC.5/PC.12/PC.13/PD.0/PD.1/PD.2/PD.3/PD.4/PD.5/PD.8/PD.9/PD.10/PD.11/PD.12/PD.13/PE.0/PE.1/PE.2/PE.3/PE.4/PE.6/PE.7/PE.8/PE.9/PE.10/PE.11/PE.12/PE.13/PE.14/PE.15/PF.4/PF.5 pin is ignored.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Px.n will drive Low if the Px.n pin is configured as Push-pull output, Open-drain output</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Px.n will drive High if the Px.n pin is configured as Push-pull output</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DOUT13</name>
              <description>Port A-f Pin[N] Output Value\nEach of these bits controls the status of a Px.n pin when the Px.n is configured as Push-pull output, Open-drain output.\nNote2:\nThePA.7/PB.12/PC.4/PC.5/PC.12/PC.13/PD.0/PD.1/PD.2/PD.3/PD.4/PD.5/PD.8/PD.9/PD.10/PD.11/PD.12/PD.13/PE.0/PE.1/PE.2/PE.3/PE.4/PE.6/PE.7/PE.8/PE.9/PE.10/PE.11/PE.12/PE.13/PE.14/PE.15/PF.4/PF.5 pin is ignored.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Px.n will drive Low if the Px.n pin is configured as Push-pull output, Open-drain output</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Px.n will drive High if the Px.n pin is configured as Push-pull output</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DOUT14</name>
              <description>Port A-f Pin[N] Output Value\nEach of these bits controls the status of a Px.n pin when the Px.n is configured as Push-pull output, Open-drain output.\nNote2:\nThePA.7/PB.12/PC.4/PC.5/PC.12/PC.13/PD.0/PD.1/PD.2/PD.3/PD.4/PD.5/PD.8/PD.9/PD.10/PD.11/PD.12/PD.13/PE.0/PE.1/PE.2/PE.3/PE.4/PE.6/PE.7/PE.8/PE.9/PE.10/PE.11/PE.12/PE.13/PE.14/PE.15/PF.4/PF.5 pin is ignored.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Px.n will drive Low if the Px.n pin is configured as Push-pull output, Open-drain output</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Px.n will drive High if the Px.n pin is configured as Push-pull output</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DOUT15</name>
              <description>Port A-f Pin[N] Output Value\nEach of these bits controls the status of a Px.n pin when the Px.n is configured as Push-pull output, Open-drain output.\nNote2:\nThePA.7/PB.12/PC.4/PC.5/PC.12/PC.13/PD.0/PD.1/PD.2/PD.3/PD.4/PD.5/PD.8/PD.9/PD.10/PD.11/PD.12/PD.13/PE.0/PE.1/PE.2/PE.3/PE.4/PE.6/PE.7/PE.8/PE.9/PE.10/PE.11/PE.12/PE.13/PE.14/PE.15/PF.4/PF.5 pin is ignored.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Px.n will drive Low if the Px.n pin is configured as Push-pull output, Open-drain output</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Px.n will drive High if the Px.n pin is configured as Push-pull output</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PA_DATMSK</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PA_DATMSK</displayName>
          <description>PA Data Output Write Mask</description>
          <addressOffset>0xC</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DMASK0</name>
              <description>Port A-f Pin[N] Data Output Write Mask\nThese bits are used to protect the corresponding DOUT (Px_DOUT[n]) bit. When the DATMSK (Px_DATMSK[n]) bit is set to 1, the corresponding DOUT (Px_DOUT[n]) bit is protected. If the write signal is masked, writing data to the protect bit is ignored.\nNote3:\nThePA.7/PB.12/PC.4/PC.5/PC.12/PC.13/PD.0/PD.1/PD.2/PD.3/PD.4/PD.5/PD.8/PD.9/PD.10/PD.11/PD.12/PD.13/PE.0/PE.1/PE.2/PE.3/PE.4/PE.6/PE.7/PE.8/PE.9/PE.10/PE.11/PE.12/PE.13/PE.14/PE.15/PF.4/PF.5 pin is ignored.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Corresponding DOUT (Px_DOUT[n]) bit can be updated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Corresponding DOUT (Px_DOUT[n]) bit protected</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DMASK1</name>
              <description>Port A-f Pin[N] Data Output Write Mask\nThese bits are used to protect the corresponding DOUT (Px_DOUT[n]) bit. When the DATMSK (Px_DATMSK[n]) bit is set to 1, the corresponding DOUT (Px_DOUT[n]) bit is protected. If the write signal is masked, writing data to the protect bit is ignored.\nNote3:\nThePA.7/PB.12/PC.4/PC.5/PC.12/PC.13/PD.0/PD.1/PD.2/PD.3/PD.4/PD.5/PD.8/PD.9/PD.10/PD.11/PD.12/PD.13/PE.0/PE.1/PE.2/PE.3/PE.4/PE.6/PE.7/PE.8/PE.9/PE.10/PE.11/PE.12/PE.13/PE.14/PE.15/PF.4/PF.5 pin is ignored.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Corresponding DOUT (Px_DOUT[n]) bit can be updated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Corresponding DOUT (Px_DOUT[n]) bit protected</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DMASK2</name>
              <description>Port A-f Pin[N] Data Output Write Mask\nThese bits are used to protect the corresponding DOUT (Px_DOUT[n]) bit. When the DATMSK (Px_DATMSK[n]) bit is set to 1, the corresponding DOUT (Px_DOUT[n]) bit is protected. If the write signal is masked, writing data to the protect bit is ignored.\nNote3:\nThePA.7/PB.12/PC.4/PC.5/PC.12/PC.13/PD.0/PD.1/PD.2/PD.3/PD.4/PD.5/PD.8/PD.9/PD.10/PD.11/PD.12/PD.13/PE.0/PE.1/PE.2/PE.3/PE.4/PE.6/PE.7/PE.8/PE.9/PE.10/PE.11/PE.12/PE.13/PE.14/PE.15/PF.4/PF.5 pin is ignored.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Corresponding DOUT (Px_DOUT[n]) bit can be updated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Corresponding DOUT (Px_DOUT[n]) bit protected</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DMASK3</name>
              <description>Port A-f Pin[N] Data Output Write Mask\nThese bits are used to protect the corresponding DOUT (Px_DOUT[n]) bit. When the DATMSK (Px_DATMSK[n]) bit is set to 1, the corresponding DOUT (Px_DOUT[n]) bit is protected. If the write signal is masked, writing data to the protect bit is ignored.\nNote3:\nThePA.7/PB.12/PC.4/PC.5/PC.12/PC.13/PD.0/PD.1/PD.2/PD.3/PD.4/PD.5/PD.8/PD.9/PD.10/PD.11/PD.12/PD.13/PE.0/PE.1/PE.2/PE.3/PE.4/PE.6/PE.7/PE.8/PE.9/PE.10/PE.11/PE.12/PE.13/PE.14/PE.15/PF.4/PF.5 pin is ignored.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Corresponding DOUT (Px_DOUT[n]) bit can be updated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Corresponding DOUT (Px_DOUT[n]) bit protected</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DMASK4</name>
              <description>Port A-f Pin[N] Data Output Write Mask\nThese bits are used to protect the corresponding DOUT (Px_DOUT[n]) bit. When the DATMSK (Px_DATMSK[n]) bit is set to 1, the corresponding DOUT (Px_DOUT[n]) bit is protected. If the write signal is masked, writing data to the protect bit is ignored.\nNote3:\nThePA.7/PB.12/PC.4/PC.5/PC.12/PC.13/PD.0/PD.1/PD.2/PD.3/PD.4/PD.5/PD.8/PD.9/PD.10/PD.11/PD.12/PD.13/PE.0/PE.1/PE.2/PE.3/PE.4/PE.6/PE.7/PE.8/PE.9/PE.10/PE.11/PE.12/PE.13/PE.14/PE.15/PF.4/PF.5 pin is ignored.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Corresponding DOUT (Px_DOUT[n]) bit can be updated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Corresponding DOUT (Px_DOUT[n]) bit protected</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DMASK5</name>
              <description>Port A-f Pin[N] Data Output Write Mask\nThese bits are used to protect the corresponding DOUT (Px_DOUT[n]) bit. When the DATMSK (Px_DATMSK[n]) bit is set to 1, the corresponding DOUT (Px_DOUT[n]) bit is protected. If the write signal is masked, writing data to the protect bit is ignored.\nNote3:\nThePA.7/PB.12/PC.4/PC.5/PC.12/PC.13/PD.0/PD.1/PD.2/PD.3/PD.4/PD.5/PD.8/PD.9/PD.10/PD.11/PD.12/PD.13/PE.0/PE.1/PE.2/PE.3/PE.4/PE.6/PE.7/PE.8/PE.9/PE.10/PE.11/PE.12/PE.13/PE.14/PE.15/PF.4/PF.5 pin is ignored.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Corresponding DOUT (Px_DOUT[n]) bit can be updated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Corresponding DOUT (Px_DOUT[n]) bit protected</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DMASK6</name>
              <description>Port A-f Pin[N] Data Output Write Mask\nThese bits are used to protect the corresponding DOUT (Px_DOUT[n]) bit. When the DATMSK (Px_DATMSK[n]) bit is set to 1, the corresponding DOUT (Px_DOUT[n]) bit is protected. If the write signal is masked, writing data to the protect bit is ignored.\nNote3:\nThePA.7/PB.12/PC.4/PC.5/PC.12/PC.13/PD.0/PD.1/PD.2/PD.3/PD.4/PD.5/PD.8/PD.9/PD.10/PD.11/PD.12/PD.13/PE.0/PE.1/PE.2/PE.3/PE.4/PE.6/PE.7/PE.8/PE.9/PE.10/PE.11/PE.12/PE.13/PE.14/PE.15/PF.4/PF.5 pin is ignored.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Corresponding DOUT (Px_DOUT[n]) bit can be updated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Corresponding DOUT (Px_DOUT[n]) bit protected</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DMASK7</name>
              <description>Port A-f Pin[N] Data Output Write Mask\nThese bits are used to protect the corresponding DOUT (Px_DOUT[n]) bit. When the DATMSK (Px_DATMSK[n]) bit is set to 1, the corresponding DOUT (Px_DOUT[n]) bit is protected. If the write signal is masked, writing data to the protect bit is ignored.\nNote3:\nThePA.7/PB.12/PC.4/PC.5/PC.12/PC.13/PD.0/PD.1/PD.2/PD.3/PD.4/PD.5/PD.8/PD.9/PD.10/PD.11/PD.12/PD.13/PE.0/PE.1/PE.2/PE.3/PE.4/PE.6/PE.7/PE.8/PE.9/PE.10/PE.11/PE.12/PE.13/PE.14/PE.15/PF.4/PF.5 pin is ignored.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Corresponding DOUT (Px_DOUT[n]) bit can be updated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Corresponding DOUT (Px_DOUT[n]) bit protected</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DMASK8</name>
              <description>Port A-f Pin[N] Data Output Write Mask\nThese bits are used to protect the corresponding DOUT (Px_DOUT[n]) bit. When the DATMSK (Px_DATMSK[n]) bit is set to 1, the corresponding DOUT (Px_DOUT[n]) bit is protected. If the write signal is masked, writing data to the protect bit is ignored.\nNote3:\nThePA.7/PB.12/PC.4/PC.5/PC.12/PC.13/PD.0/PD.1/PD.2/PD.3/PD.4/PD.5/PD.8/PD.9/PD.10/PD.11/PD.12/PD.13/PE.0/PE.1/PE.2/PE.3/PE.4/PE.6/PE.7/PE.8/PE.9/PE.10/PE.11/PE.12/PE.13/PE.14/PE.15/PF.4/PF.5 pin is ignored.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Corresponding DOUT (Px_DOUT[n]) bit can be updated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Corresponding DOUT (Px_DOUT[n]) bit protected</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DMASK9</name>
              <description>Port A-f Pin[N] Data Output Write Mask\nThese bits are used to protect the corresponding DOUT (Px_DOUT[n]) bit. When the DATMSK (Px_DATMSK[n]) bit is set to 1, the corresponding DOUT (Px_DOUT[n]) bit is protected. If the write signal is masked, writing data to the protect bit is ignored.\nNote3:\nThePA.7/PB.12/PC.4/PC.5/PC.12/PC.13/PD.0/PD.1/PD.2/PD.3/PD.4/PD.5/PD.8/PD.9/PD.10/PD.11/PD.12/PD.13/PE.0/PE.1/PE.2/PE.3/PE.4/PE.6/PE.7/PE.8/PE.9/PE.10/PE.11/PE.12/PE.13/PE.14/PE.15/PF.4/PF.5 pin is ignored.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Corresponding DOUT (Px_DOUT[n]) bit can be updated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Corresponding DOUT (Px_DOUT[n]) bit protected</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DMASK10</name>
              <description>Port A-f Pin[N] Data Output Write Mask\nThese bits are used to protect the corresponding DOUT (Px_DOUT[n]) bit. When the DATMSK (Px_DATMSK[n]) bit is set to 1, the corresponding DOUT (Px_DOUT[n]) bit is protected. If the write signal is masked, writing data to the protect bit is ignored.\nNote3:\nThePA.7/PB.12/PC.4/PC.5/PC.12/PC.13/PD.0/PD.1/PD.2/PD.3/PD.4/PD.5/PD.8/PD.9/PD.10/PD.11/PD.12/PD.13/PE.0/PE.1/PE.2/PE.3/PE.4/PE.6/PE.7/PE.8/PE.9/PE.10/PE.11/PE.12/PE.13/PE.14/PE.15/PF.4/PF.5 pin is ignored.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Corresponding DOUT (Px_DOUT[n]) bit can be updated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Corresponding DOUT (Px_DOUT[n]) bit protected</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DMASK11</name>
              <description>Port A-f Pin[N] Data Output Write Mask\nThese bits are used to protect the corresponding DOUT (Px_DOUT[n]) bit. When the DATMSK (Px_DATMSK[n]) bit is set to 1, the corresponding DOUT (Px_DOUT[n]) bit is protected. If the write signal is masked, writing data to the protect bit is ignored.\nNote3:\nThePA.7/PB.12/PC.4/PC.5/PC.12/PC.13/PD.0/PD.1/PD.2/PD.3/PD.4/PD.5/PD.8/PD.9/PD.10/PD.11/PD.12/PD.13/PE.0/PE.1/PE.2/PE.3/PE.4/PE.6/PE.7/PE.8/PE.9/PE.10/PE.11/PE.12/PE.13/PE.14/PE.15/PF.4/PF.5 pin is ignored.</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Corresponding DOUT (Px_DOUT[n]) bit can be updated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Corresponding DOUT (Px_DOUT[n]) bit protected</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DMASK12</name>
              <description>Port A-f Pin[N] Data Output Write Mask\nThese bits are used to protect the corresponding DOUT (Px_DOUT[n]) bit. When the DATMSK (Px_DATMSK[n]) bit is set to 1, the corresponding DOUT (Px_DOUT[n]) bit is protected. If the write signal is masked, writing data to the protect bit is ignored.\nNote3:\nThePA.7/PB.12/PC.4/PC.5/PC.12/PC.13/PD.0/PD.1/PD.2/PD.3/PD.4/PD.5/PD.8/PD.9/PD.10/PD.11/PD.12/PD.13/PE.0/PE.1/PE.2/PE.3/PE.4/PE.6/PE.7/PE.8/PE.9/PE.10/PE.11/PE.12/PE.13/PE.14/PE.15/PF.4/PF.5 pin is ignored.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Corresponding DOUT (Px_DOUT[n]) bit can be updated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Corresponding DOUT (Px_DOUT[n]) bit protected</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DMASK13</name>
              <description>Port A-f Pin[N] Data Output Write Mask\nThese bits are used to protect the corresponding DOUT (Px_DOUT[n]) bit. When the DATMSK (Px_DATMSK[n]) bit is set to 1, the corresponding DOUT (Px_DOUT[n]) bit is protected. If the write signal is masked, writing data to the protect bit is ignored.\nNote3:\nThePA.7/PB.12/PC.4/PC.5/PC.12/PC.13/PD.0/PD.1/PD.2/PD.3/PD.4/PD.5/PD.8/PD.9/PD.10/PD.11/PD.12/PD.13/PE.0/PE.1/PE.2/PE.3/PE.4/PE.6/PE.7/PE.8/PE.9/PE.10/PE.11/PE.12/PE.13/PE.14/PE.15/PF.4/PF.5 pin is ignored.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Corresponding DOUT (Px_DOUT[n]) bit can be updated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Corresponding DOUT (Px_DOUT[n]) bit protected</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DMASK14</name>
              <description>Port A-f Pin[N] Data Output Write Mask\nThese bits are used to protect the corresponding DOUT (Px_DOUT[n]) bit. When the DATMSK (Px_DATMSK[n]) bit is set to 1, the corresponding DOUT (Px_DOUT[n]) bit is protected. If the write signal is masked, writing data to the protect bit is ignored.\nNote3:\nThePA.7/PB.12/PC.4/PC.5/PC.12/PC.13/PD.0/PD.1/PD.2/PD.3/PD.4/PD.5/PD.8/PD.9/PD.10/PD.11/PD.12/PD.13/PE.0/PE.1/PE.2/PE.3/PE.4/PE.6/PE.7/PE.8/PE.9/PE.10/PE.11/PE.12/PE.13/PE.14/PE.15/PF.4/PF.5 pin is ignored.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Corresponding DOUT (Px_DOUT[n]) bit can be updated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Corresponding DOUT (Px_DOUT[n]) bit protected</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DMASK15</name>
              <description>Port A-f Pin[N] Data Output Write Mask\nThese bits are used to protect the corresponding DOUT (Px_DOUT[n]) bit. When the DATMSK (Px_DATMSK[n]) bit is set to 1, the corresponding DOUT (Px_DOUT[n]) bit is protected. If the write signal is masked, writing data to the protect bit is ignored.\nNote3:\nThePA.7/PB.12/PC.4/PC.5/PC.12/PC.13/PD.0/PD.1/PD.2/PD.3/PD.4/PD.5/PD.8/PD.9/PD.10/PD.11/PD.12/PD.13/PE.0/PE.1/PE.2/PE.3/PE.4/PE.6/PE.7/PE.8/PE.9/PE.10/PE.11/PE.12/PE.13/PE.14/PE.15/PF.4/PF.5 pin is ignored.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Corresponding DOUT (Px_DOUT[n]) bit can be updated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Corresponding DOUT (Px_DOUT[n]) bit protected</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PA_PIN</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PA_PIN</displayName>
          <description>PA Pin Value</description>
          <addressOffset>0x10</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFF0000</resetMask>
          <fields>
            <field>
              <name>PIN0</name>
              <description>Port A-f Pin[N] Pin Value\nEach bit of the register reflects the actual status of the respective Px.n pin. If the bit is 1, it indicates the corresponding pin status is high; else the pin status is low.\nNote1:\nNote2:\nThePA.7/PB.12/PC.4/PC.5/PC.12/PC.13/PD.0/PD.1/PD.2/PD.3/PD.4/PD.5/PD.8/PD.9/PD.10/PD.11/PD.12/PD.13/PE.0/PE.1/PE.2/PE.3/PE.4/PE.6/PE.7/PE.8/PE.9/PE.10/PE.11/PE.12/PE.13/PE.14/PE.15/PF.4/PF.5 pin is ignored.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PIN1</name>
              <description>Port A-f Pin[N] Pin Value\nEach bit of the register reflects the actual status of the respective Px.n pin. If the bit is 1, it indicates the corresponding pin status is high; else the pin status is low.\nNote1:\nNote2:\nThePA.7/PB.12/PC.4/PC.5/PC.12/PC.13/PD.0/PD.1/PD.2/PD.3/PD.4/PD.5/PD.8/PD.9/PD.10/PD.11/PD.12/PD.13/PE.0/PE.1/PE.2/PE.3/PE.4/PE.6/PE.7/PE.8/PE.9/PE.10/PE.11/PE.12/PE.13/PE.14/PE.15/PF.4/PF.5 pin is ignored.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PIN2</name>
              <description>Port A-f Pin[N] Pin Value\nEach bit of the register reflects the actual status of the respective Px.n pin. If the bit is 1, it indicates the corresponding pin status is high; else the pin status is low.\nNote1:\nNote2:\nThePA.7/PB.12/PC.4/PC.5/PC.12/PC.13/PD.0/PD.1/PD.2/PD.3/PD.4/PD.5/PD.8/PD.9/PD.10/PD.11/PD.12/PD.13/PE.0/PE.1/PE.2/PE.3/PE.4/PE.6/PE.7/PE.8/PE.9/PE.10/PE.11/PE.12/PE.13/PE.14/PE.15/PF.4/PF.5 pin is ignored.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PIN3</name>
              <description>Port A-f Pin[N] Pin Value\nEach bit of the register reflects the actual status of the respective Px.n pin. If the bit is 1, it indicates the corresponding pin status is high; else the pin status is low.\nNote1:\nNote2:\nThePA.7/PB.12/PC.4/PC.5/PC.12/PC.13/PD.0/PD.1/PD.2/PD.3/PD.4/PD.5/PD.8/PD.9/PD.10/PD.11/PD.12/PD.13/PE.0/PE.1/PE.2/PE.3/PE.4/PE.6/PE.7/PE.8/PE.9/PE.10/PE.11/PE.12/PE.13/PE.14/PE.15/PF.4/PF.5 pin is ignored.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PIN4</name>
              <description>Port A-f Pin[N] Pin Value\nEach bit of the register reflects the actual status of the respective Px.n pin. If the bit is 1, it indicates the corresponding pin status is high; else the pin status is low.\nNote1:\nNote2:\nThePA.7/PB.12/PC.4/PC.5/PC.12/PC.13/PD.0/PD.1/PD.2/PD.3/PD.4/PD.5/PD.8/PD.9/PD.10/PD.11/PD.12/PD.13/PE.0/PE.1/PE.2/PE.3/PE.4/PE.6/PE.7/PE.8/PE.9/PE.10/PE.11/PE.12/PE.13/PE.14/PE.15/PF.4/PF.5 pin is ignored.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PIN5</name>
              <description>Port A-f Pin[N] Pin Value\nEach bit of the register reflects the actual status of the respective Px.n pin. If the bit is 1, it indicates the corresponding pin status is high; else the pin status is low.\nNote1:\nNote2:\nThePA.7/PB.12/PC.4/PC.5/PC.12/PC.13/PD.0/PD.1/PD.2/PD.3/PD.4/PD.5/PD.8/PD.9/PD.10/PD.11/PD.12/PD.13/PE.0/PE.1/PE.2/PE.3/PE.4/PE.6/PE.7/PE.8/PE.9/PE.10/PE.11/PE.12/PE.13/PE.14/PE.15/PF.4/PF.5 pin is ignored.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PIN6</name>
              <description>Port A-f Pin[N] Pin Value\nEach bit of the register reflects the actual status of the respective Px.n pin. If the bit is 1, it indicates the corresponding pin status is high; else the pin status is low.\nNote1:\nNote2:\nThePA.7/PB.12/PC.4/PC.5/PC.12/PC.13/PD.0/PD.1/PD.2/PD.3/PD.4/PD.5/PD.8/PD.9/PD.10/PD.11/PD.12/PD.13/PE.0/PE.1/PE.2/PE.3/PE.4/PE.6/PE.7/PE.8/PE.9/PE.10/PE.11/PE.12/PE.13/PE.14/PE.15/PF.4/PF.5 pin is ignored.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PIN7</name>
              <description>Port A-f Pin[N] Pin Value\nEach bit of the register reflects the actual status of the respective Px.n pin. If the bit is 1, it indicates the corresponding pin status is high; else the pin status is low.\nNote1:\nNote2:\nThePA.7/PB.12/PC.4/PC.5/PC.12/PC.13/PD.0/PD.1/PD.2/PD.3/PD.4/PD.5/PD.8/PD.9/PD.10/PD.11/PD.12/PD.13/PE.0/PE.1/PE.2/PE.3/PE.4/PE.6/PE.7/PE.8/PE.9/PE.10/PE.11/PE.12/PE.13/PE.14/PE.15/PF.4/PF.5 pin is ignored.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PIN8</name>
              <description>Port A-f Pin[N] Pin Value\nEach bit of the register reflects the actual status of the respective Px.n pin. If the bit is 1, it indicates the corresponding pin status is high; else the pin status is low.\nNote1:\nNote2:\nThePA.7/PB.12/PC.4/PC.5/PC.12/PC.13/PD.0/PD.1/PD.2/PD.3/PD.4/PD.5/PD.8/PD.9/PD.10/PD.11/PD.12/PD.13/PE.0/PE.1/PE.2/PE.3/PE.4/PE.6/PE.7/PE.8/PE.9/PE.10/PE.11/PE.12/PE.13/PE.14/PE.15/PF.4/PF.5 pin is ignored.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PIN9</name>
              <description>Port A-f Pin[N] Pin Value\nEach bit of the register reflects the actual status of the respective Px.n pin. If the bit is 1, it indicates the corresponding pin status is high; else the pin status is low.\nNote1:\nNote2:\nThePA.7/PB.12/PC.4/PC.5/PC.12/PC.13/PD.0/PD.1/PD.2/PD.3/PD.4/PD.5/PD.8/PD.9/PD.10/PD.11/PD.12/PD.13/PE.0/PE.1/PE.2/PE.3/PE.4/PE.6/PE.7/PE.8/PE.9/PE.10/PE.11/PE.12/PE.13/PE.14/PE.15/PF.4/PF.5 pin is ignored.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PIN10</name>
              <description>Port A-f Pin[N] Pin Value\nEach bit of the register reflects the actual status of the respective Px.n pin. If the bit is 1, it indicates the corresponding pin status is high; else the pin status is low.\nNote1:\nNote2:\nThePA.7/PB.12/PC.4/PC.5/PC.12/PC.13/PD.0/PD.1/PD.2/PD.3/PD.4/PD.5/PD.8/PD.9/PD.10/PD.11/PD.12/PD.13/PE.0/PE.1/PE.2/PE.3/PE.4/PE.6/PE.7/PE.8/PE.9/PE.10/PE.11/PE.12/PE.13/PE.14/PE.15/PF.4/PF.5 pin is ignored.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PIN11</name>
              <description>Port A-f Pin[N] Pin Value\nEach bit of the register reflects the actual status of the respective Px.n pin. If the bit is 1, it indicates the corresponding pin status is high; else the pin status is low.\nNote1:\nNote2:\nThePA.7/PB.12/PC.4/PC.5/PC.12/PC.13/PD.0/PD.1/PD.2/PD.3/PD.4/PD.5/PD.8/PD.9/PD.10/PD.11/PD.12/PD.13/PE.0/PE.1/PE.2/PE.3/PE.4/PE.6/PE.7/PE.8/PE.9/PE.10/PE.11/PE.12/PE.13/PE.14/PE.15/PF.4/PF.5 pin is ignored.</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PIN12</name>
              <description>Port A-f Pin[N] Pin Value\nEach bit of the register reflects the actual status of the respective Px.n pin. If the bit is 1, it indicates the corresponding pin status is high; else the pin status is low.\nNote1:\nNote2:\nThePA.7/PB.12/PC.4/PC.5/PC.12/PC.13/PD.0/PD.1/PD.2/PD.3/PD.4/PD.5/PD.8/PD.9/PD.10/PD.11/PD.12/PD.13/PE.0/PE.1/PE.2/PE.3/PE.4/PE.6/PE.7/PE.8/PE.9/PE.10/PE.11/PE.12/PE.13/PE.14/PE.15/PF.4/PF.5 pin is ignored.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PIN13</name>
              <description>Port A-f Pin[N] Pin Value\nEach bit of the register reflects the actual status of the respective Px.n pin. If the bit is 1, it indicates the corresponding pin status is high; else the pin status is low.\nNote1:\nNote2:\nThePA.7/PB.12/PC.4/PC.5/PC.12/PC.13/PD.0/PD.1/PD.2/PD.3/PD.4/PD.5/PD.8/PD.9/PD.10/PD.11/PD.12/PD.13/PE.0/PE.1/PE.2/PE.3/PE.4/PE.6/PE.7/PE.8/PE.9/PE.10/PE.11/PE.12/PE.13/PE.14/PE.15/PF.4/PF.5 pin is ignored.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PIN14</name>
              <description>Port A-f Pin[N] Pin Value\nEach bit of the register reflects the actual status of the respective Px.n pin. If the bit is 1, it indicates the corresponding pin status is high; else the pin status is low.\nNote1:\nNote2:\nThePA.7/PB.12/PC.4/PC.5/PC.12/PC.13/PD.0/PD.1/PD.2/PD.3/PD.4/PD.5/PD.8/PD.9/PD.10/PD.11/PD.12/PD.13/PE.0/PE.1/PE.2/PE.3/PE.4/PE.6/PE.7/PE.8/PE.9/PE.10/PE.11/PE.12/PE.13/PE.14/PE.15/PF.4/PF.5 pin is ignored.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PIN15</name>
              <description>Port A-f Pin[N] Pin Value\nEach bit of the register reflects the actual status of the respective Px.n pin. If the bit is 1, it indicates the corresponding pin status is high; else the pin status is low.\nNote1:\nNote2:\nThePA.7/PB.12/PC.4/PC.5/PC.12/PC.13/PD.0/PD.1/PD.2/PD.3/PD.4/PD.5/PD.8/PD.9/PD.10/PD.11/PD.12/PD.13/PE.0/PE.1/PE.2/PE.3/PE.4/PE.6/PE.7/PE.8/PE.9/PE.10/PE.11/PE.12/PE.13/PE.14/PE.15/PF.4/PF.5 pin is ignored.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PA_DBEN</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PA_DBEN</displayName>
          <description>PA De-Bounce Enable Control Register</description>
          <addressOffset>0x14</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DBEN0</name>
              <description>Port A-f Pin[N] Input Signal De-bounce Enable Bit\nThe DBEN[n] bit is used to enable the de-bounce function for each corresponding bit. If the input signal pulse width cannot be sampled by continuous two de-bounce sample cycle, the input signal transition is seen as the signal bounce and will not trigger the interrupt. The de-bounce clock source is controlled by DBCLKSRC (GPIO_DBCTL [4]), one de-bounce sample cycle period is controlled by DBCLKSEL (GPIO_DBCTL [3:0]).\nNote2:\nThePA.7/PB.12/PC.4/PC.5/PC.12/PC.13/PD.0/PD.1/PD.2/PD.3/PD.4/PD.5/PD.8/PD.9/PD.10/PD.11/PD.12/PD.13/PE.0/PE.1/PE.2/PE.3/PE.4/PE.6/PE.7/PE.8/PE.9/PE.10/PE.11/PE.12/PE.13/PE.14/PE.15/PF.4/PF.5 pin is ignored.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Px.n de-bounce function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Px.n de-bounce function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DBEN1</name>
              <description>Port A-f Pin[N] Input Signal De-bounce Enable Bit\nThe DBEN[n] bit is used to enable the de-bounce function for each corresponding bit. If the input signal pulse width cannot be sampled by continuous two de-bounce sample cycle, the input signal transition is seen as the signal bounce and will not trigger the interrupt. The de-bounce clock source is controlled by DBCLKSRC (GPIO_DBCTL [4]), one de-bounce sample cycle period is controlled by DBCLKSEL (GPIO_DBCTL [3:0]).\nNote2:\nThePA.7/PB.12/PC.4/PC.5/PC.12/PC.13/PD.0/PD.1/PD.2/PD.3/PD.4/PD.5/PD.8/PD.9/PD.10/PD.11/PD.12/PD.13/PE.0/PE.1/PE.2/PE.3/PE.4/PE.6/PE.7/PE.8/PE.9/PE.10/PE.11/PE.12/PE.13/PE.14/PE.15/PF.4/PF.5 pin is ignored.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Px.n de-bounce function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Px.n de-bounce function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DBEN2</name>
              <description>Port A-f Pin[N] Input Signal De-bounce Enable Bit\nThe DBEN[n] bit is used to enable the de-bounce function for each corresponding bit. If the input signal pulse width cannot be sampled by continuous two de-bounce sample cycle, the input signal transition is seen as the signal bounce and will not trigger the interrupt. The de-bounce clock source is controlled by DBCLKSRC (GPIO_DBCTL [4]), one de-bounce sample cycle period is controlled by DBCLKSEL (GPIO_DBCTL [3:0]).\nNote2:\nThePA.7/PB.12/PC.4/PC.5/PC.12/PC.13/PD.0/PD.1/PD.2/PD.3/PD.4/PD.5/PD.8/PD.9/PD.10/PD.11/PD.12/PD.13/PE.0/PE.1/PE.2/PE.3/PE.4/PE.6/PE.7/PE.8/PE.9/PE.10/PE.11/PE.12/PE.13/PE.14/PE.15/PF.4/PF.5 pin is ignored.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Px.n de-bounce function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Px.n de-bounce function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DBEN3</name>
              <description>Port A-f Pin[N] Input Signal De-bounce Enable Bit\nThe DBEN[n] bit is used to enable the de-bounce function for each corresponding bit. If the input signal pulse width cannot be sampled by continuous two de-bounce sample cycle, the input signal transition is seen as the signal bounce and will not trigger the interrupt. The de-bounce clock source is controlled by DBCLKSRC (GPIO_DBCTL [4]), one de-bounce sample cycle period is controlled by DBCLKSEL (GPIO_DBCTL [3:0]).\nNote2:\nThePA.7/PB.12/PC.4/PC.5/PC.12/PC.13/PD.0/PD.1/PD.2/PD.3/PD.4/PD.5/PD.8/PD.9/PD.10/PD.11/PD.12/PD.13/PE.0/PE.1/PE.2/PE.3/PE.4/PE.6/PE.7/PE.8/PE.9/PE.10/PE.11/PE.12/PE.13/PE.14/PE.15/PF.4/PF.5 pin is ignored.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Px.n de-bounce function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Px.n de-bounce function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DBEN4</name>
              <description>Port A-f Pin[N] Input Signal De-bounce Enable Bit\nThe DBEN[n] bit is used to enable the de-bounce function for each corresponding bit. If the input signal pulse width cannot be sampled by continuous two de-bounce sample cycle, the input signal transition is seen as the signal bounce and will not trigger the interrupt. The de-bounce clock source is controlled by DBCLKSRC (GPIO_DBCTL [4]), one de-bounce sample cycle period is controlled by DBCLKSEL (GPIO_DBCTL [3:0]).\nNote2:\nThePA.7/PB.12/PC.4/PC.5/PC.12/PC.13/PD.0/PD.1/PD.2/PD.3/PD.4/PD.5/PD.8/PD.9/PD.10/PD.11/PD.12/PD.13/PE.0/PE.1/PE.2/PE.3/PE.4/PE.6/PE.7/PE.8/PE.9/PE.10/PE.11/PE.12/PE.13/PE.14/PE.15/PF.4/PF.5 pin is ignored.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Px.n de-bounce function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Px.n de-bounce function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DBEN5</name>
              <description>Port A-f Pin[N] Input Signal De-bounce Enable Bit\nThe DBEN[n] bit is used to enable the de-bounce function for each corresponding bit. If the input signal pulse width cannot be sampled by continuous two de-bounce sample cycle, the input signal transition is seen as the signal bounce and will not trigger the interrupt. The de-bounce clock source is controlled by DBCLKSRC (GPIO_DBCTL [4]), one de-bounce sample cycle period is controlled by DBCLKSEL (GPIO_DBCTL [3:0]).\nNote2:\nThePA.7/PB.12/PC.4/PC.5/PC.12/PC.13/PD.0/PD.1/PD.2/PD.3/PD.4/PD.5/PD.8/PD.9/PD.10/PD.11/PD.12/PD.13/PE.0/PE.1/PE.2/PE.3/PE.4/PE.6/PE.7/PE.8/PE.9/PE.10/PE.11/PE.12/PE.13/PE.14/PE.15/PF.4/PF.5 pin is ignored.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Px.n de-bounce function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Px.n de-bounce function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DBEN6</name>
              <description>Port A-f Pin[N] Input Signal De-bounce Enable Bit\nThe DBEN[n] bit is used to enable the de-bounce function for each corresponding bit. If the input signal pulse width cannot be sampled by continuous two de-bounce sample cycle, the input signal transition is seen as the signal bounce and will not trigger the interrupt. The de-bounce clock source is controlled by DBCLKSRC (GPIO_DBCTL [4]), one de-bounce sample cycle period is controlled by DBCLKSEL (GPIO_DBCTL [3:0]).\nNote2:\nThePA.7/PB.12/PC.4/PC.5/PC.12/PC.13/PD.0/PD.1/PD.2/PD.3/PD.4/PD.5/PD.8/PD.9/PD.10/PD.11/PD.12/PD.13/PE.0/PE.1/PE.2/PE.3/PE.4/PE.6/PE.7/PE.8/PE.9/PE.10/PE.11/PE.12/PE.13/PE.14/PE.15/PF.4/PF.5 pin is ignored.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Px.n de-bounce function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Px.n de-bounce function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DBEN7</name>
              <description>Port A-f Pin[N] Input Signal De-bounce Enable Bit\nThe DBEN[n] bit is used to enable the de-bounce function for each corresponding bit. If the input signal pulse width cannot be sampled by continuous two de-bounce sample cycle, the input signal transition is seen as the signal bounce and will not trigger the interrupt. The de-bounce clock source is controlled by DBCLKSRC (GPIO_DBCTL [4]), one de-bounce sample cycle period is controlled by DBCLKSEL (GPIO_DBCTL [3:0]).\nNote2:\nThePA.7/PB.12/PC.4/PC.5/PC.12/PC.13/PD.0/PD.1/PD.2/PD.3/PD.4/PD.5/PD.8/PD.9/PD.10/PD.11/PD.12/PD.13/PE.0/PE.1/PE.2/PE.3/PE.4/PE.6/PE.7/PE.8/PE.9/PE.10/PE.11/PE.12/PE.13/PE.14/PE.15/PF.4/PF.5 pin is ignored.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Px.n de-bounce function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Px.n de-bounce function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DBEN8</name>
              <description>Port A-f Pin[N] Input Signal De-bounce Enable Bit\nThe DBEN[n] bit is used to enable the de-bounce function for each corresponding bit. If the input signal pulse width cannot be sampled by continuous two de-bounce sample cycle, the input signal transition is seen as the signal bounce and will not trigger the interrupt. The de-bounce clock source is controlled by DBCLKSRC (GPIO_DBCTL [4]), one de-bounce sample cycle period is controlled by DBCLKSEL (GPIO_DBCTL [3:0]).\nNote2:\nThePA.7/PB.12/PC.4/PC.5/PC.12/PC.13/PD.0/PD.1/PD.2/PD.3/PD.4/PD.5/PD.8/PD.9/PD.10/PD.11/PD.12/PD.13/PE.0/PE.1/PE.2/PE.3/PE.4/PE.6/PE.7/PE.8/PE.9/PE.10/PE.11/PE.12/PE.13/PE.14/PE.15/PF.4/PF.5 pin is ignored.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Px.n de-bounce function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Px.n de-bounce function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DBEN9</name>
              <description>Port A-f Pin[N] Input Signal De-bounce Enable Bit\nThe DBEN[n] bit is used to enable the de-bounce function for each corresponding bit. If the input signal pulse width cannot be sampled by continuous two de-bounce sample cycle, the input signal transition is seen as the signal bounce and will not trigger the interrupt. The de-bounce clock source is controlled by DBCLKSRC (GPIO_DBCTL [4]), one de-bounce sample cycle period is controlled by DBCLKSEL (GPIO_DBCTL [3:0]).\nNote2:\nThePA.7/PB.12/PC.4/PC.5/PC.12/PC.13/PD.0/PD.1/PD.2/PD.3/PD.4/PD.5/PD.8/PD.9/PD.10/PD.11/PD.12/PD.13/PE.0/PE.1/PE.2/PE.3/PE.4/PE.6/PE.7/PE.8/PE.9/PE.10/PE.11/PE.12/PE.13/PE.14/PE.15/PF.4/PF.5 pin is ignored.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Px.n de-bounce function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Px.n de-bounce function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DBEN10</name>
              <description>Port A-f Pin[N] Input Signal De-bounce Enable Bit\nThe DBEN[n] bit is used to enable the de-bounce function for each corresponding bit. If the input signal pulse width cannot be sampled by continuous two de-bounce sample cycle, the input signal transition is seen as the signal bounce and will not trigger the interrupt. The de-bounce clock source is controlled by DBCLKSRC (GPIO_DBCTL [4]), one de-bounce sample cycle period is controlled by DBCLKSEL (GPIO_DBCTL [3:0]).\nNote2:\nThePA.7/PB.12/PC.4/PC.5/PC.12/PC.13/PD.0/PD.1/PD.2/PD.3/PD.4/PD.5/PD.8/PD.9/PD.10/PD.11/PD.12/PD.13/PE.0/PE.1/PE.2/PE.3/PE.4/PE.6/PE.7/PE.8/PE.9/PE.10/PE.11/PE.12/PE.13/PE.14/PE.15/PF.4/PF.5 pin is ignored.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Px.n de-bounce function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Px.n de-bounce function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DBEN11</name>
              <description>Port A-f Pin[N] Input Signal De-bounce Enable Bit\nThe DBEN[n] bit is used to enable the de-bounce function for each corresponding bit. If the input signal pulse width cannot be sampled by continuous two de-bounce sample cycle, the input signal transition is seen as the signal bounce and will not trigger the interrupt. The de-bounce clock source is controlled by DBCLKSRC (GPIO_DBCTL [4]), one de-bounce sample cycle period is controlled by DBCLKSEL (GPIO_DBCTL [3:0]).\nNote2:\nThePA.7/PB.12/PC.4/PC.5/PC.12/PC.13/PD.0/PD.1/PD.2/PD.3/PD.4/PD.5/PD.8/PD.9/PD.10/PD.11/PD.12/PD.13/PE.0/PE.1/PE.2/PE.3/PE.4/PE.6/PE.7/PE.8/PE.9/PE.10/PE.11/PE.12/PE.13/PE.14/PE.15/PF.4/PF.5 pin is ignored.</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Px.n de-bounce function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Px.n de-bounce function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DBEN12</name>
              <description>Port A-f Pin[N] Input Signal De-bounce Enable Bit\nThe DBEN[n] bit is used to enable the de-bounce function for each corresponding bit. If the input signal pulse width cannot be sampled by continuous two de-bounce sample cycle, the input signal transition is seen as the signal bounce and will not trigger the interrupt. The de-bounce clock source is controlled by DBCLKSRC (GPIO_DBCTL [4]), one de-bounce sample cycle period is controlled by DBCLKSEL (GPIO_DBCTL [3:0]).\nNote2:\nThePA.7/PB.12/PC.4/PC.5/PC.12/PC.13/PD.0/PD.1/PD.2/PD.3/PD.4/PD.5/PD.8/PD.9/PD.10/PD.11/PD.12/PD.13/PE.0/PE.1/PE.2/PE.3/PE.4/PE.6/PE.7/PE.8/PE.9/PE.10/PE.11/PE.12/PE.13/PE.14/PE.15/PF.4/PF.5 pin is ignored.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Px.n de-bounce function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Px.n de-bounce function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DBEN13</name>
              <description>Port A-f Pin[N] Input Signal De-bounce Enable Bit\nThe DBEN[n] bit is used to enable the de-bounce function for each corresponding bit. If the input signal pulse width cannot be sampled by continuous two de-bounce sample cycle, the input signal transition is seen as the signal bounce and will not trigger the interrupt. The de-bounce clock source is controlled by DBCLKSRC (GPIO_DBCTL [4]), one de-bounce sample cycle period is controlled by DBCLKSEL (GPIO_DBCTL [3:0]).\nNote2:\nThePA.7/PB.12/PC.4/PC.5/PC.12/PC.13/PD.0/PD.1/PD.2/PD.3/PD.4/PD.5/PD.8/PD.9/PD.10/PD.11/PD.12/PD.13/PE.0/PE.1/PE.2/PE.3/PE.4/PE.6/PE.7/PE.8/PE.9/PE.10/PE.11/PE.12/PE.13/PE.14/PE.15/PF.4/PF.5 pin is ignored.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Px.n de-bounce function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Px.n de-bounce function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DBEN14</name>
              <description>Port A-f Pin[N] Input Signal De-bounce Enable Bit\nThe DBEN[n] bit is used to enable the de-bounce function for each corresponding bit. If the input signal pulse width cannot be sampled by continuous two de-bounce sample cycle, the input signal transition is seen as the signal bounce and will not trigger the interrupt. The de-bounce clock source is controlled by DBCLKSRC (GPIO_DBCTL [4]), one de-bounce sample cycle period is controlled by DBCLKSEL (GPIO_DBCTL [3:0]).\nNote2:\nThePA.7/PB.12/PC.4/PC.5/PC.12/PC.13/PD.0/PD.1/PD.2/PD.3/PD.4/PD.5/PD.8/PD.9/PD.10/PD.11/PD.12/PD.13/PE.0/PE.1/PE.2/PE.3/PE.4/PE.6/PE.7/PE.8/PE.9/PE.10/PE.11/PE.12/PE.13/PE.14/PE.15/PF.4/PF.5 pin is ignored.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Px.n de-bounce function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Px.n de-bounce function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DBEN15</name>
              <description>Port A-f Pin[N] Input Signal De-bounce Enable Bit\nThe DBEN[n] bit is used to enable the de-bounce function for each corresponding bit. If the input signal pulse width cannot be sampled by continuous two de-bounce sample cycle, the input signal transition is seen as the signal bounce and will not trigger the interrupt. The de-bounce clock source is controlled by DBCLKSRC (GPIO_DBCTL [4]), one de-bounce sample cycle period is controlled by DBCLKSEL (GPIO_DBCTL [3:0]).\nNote2:\nThePA.7/PB.12/PC.4/PC.5/PC.12/PC.13/PD.0/PD.1/PD.2/PD.3/PD.4/PD.5/PD.8/PD.9/PD.10/PD.11/PD.12/PD.13/PE.0/PE.1/PE.2/PE.3/PE.4/PE.6/PE.7/PE.8/PE.9/PE.10/PE.11/PE.12/PE.13/PE.14/PE.15/PF.4/PF.5 pin is ignored.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Px.n de-bounce function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Px.n de-bounce function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PA_INTTYPE</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PA_INTTYPE</displayName>
          <description>PA Interrupt Trigger Type Control</description>
          <addressOffset>0x18</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TYPE0</name>
              <description>Port A-f Pin[N] Edge or Level Detection Interrupt Trigger Type Control\nTYPE (Px_INTTYPE[n]) bit is used to control the triggered interrupt is by level trigger or by edge trigger. If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce. If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrupt.\nNote2:\nThePA.7/PB.12/PC.4/PC.5/PC.12/PC.13/PD.0/PD.1/PD.2/PD.3/PD.4/PD.5/PD.8/PD.9/PD.10/PD.11/PD.12/PD.13/PE.0/PE.1/PE.2/PE.3/PE.4/PE.6/PE.7/PE.8/PE.9/PE.10/PE.11/PE.12/PE.13/PE.14/PE.15/PF.4/PF.5 pin is ignored.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Edge trigger interrupt</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Level trigger interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TYPE1</name>
              <description>Port A-f Pin[N] Edge or Level Detection Interrupt Trigger Type Control\nTYPE (Px_INTTYPE[n]) bit is used to control the triggered interrupt is by level trigger or by edge trigger. If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce. If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrupt.\nNote2:\nThePA.7/PB.12/PC.4/PC.5/PC.12/PC.13/PD.0/PD.1/PD.2/PD.3/PD.4/PD.5/PD.8/PD.9/PD.10/PD.11/PD.12/PD.13/PE.0/PE.1/PE.2/PE.3/PE.4/PE.6/PE.7/PE.8/PE.9/PE.10/PE.11/PE.12/PE.13/PE.14/PE.15/PF.4/PF.5 pin is ignored.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Edge trigger interrupt</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Level trigger interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TYPE2</name>
              <description>Port A-f Pin[N] Edge or Level Detection Interrupt Trigger Type Control\nTYPE (Px_INTTYPE[n]) bit is used to control the triggered interrupt is by level trigger or by edge trigger. If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce. If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrupt.\nNote2:\nThePA.7/PB.12/PC.4/PC.5/PC.12/PC.13/PD.0/PD.1/PD.2/PD.3/PD.4/PD.5/PD.8/PD.9/PD.10/PD.11/PD.12/PD.13/PE.0/PE.1/PE.2/PE.3/PE.4/PE.6/PE.7/PE.8/PE.9/PE.10/PE.11/PE.12/PE.13/PE.14/PE.15/PF.4/PF.5 pin is ignored.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Edge trigger interrupt</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Level trigger interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TYPE3</name>
              <description>Port A-f Pin[N] Edge or Level Detection Interrupt Trigger Type Control\nTYPE (Px_INTTYPE[n]) bit is used to control the triggered interrupt is by level trigger or by edge trigger. If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce. If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrupt.\nNote2:\nThePA.7/PB.12/PC.4/PC.5/PC.12/PC.13/PD.0/PD.1/PD.2/PD.3/PD.4/PD.5/PD.8/PD.9/PD.10/PD.11/PD.12/PD.13/PE.0/PE.1/PE.2/PE.3/PE.4/PE.6/PE.7/PE.8/PE.9/PE.10/PE.11/PE.12/PE.13/PE.14/PE.15/PF.4/PF.5 pin is ignored.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Edge trigger interrupt</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Level trigger interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TYPE4</name>
              <description>Port A-f Pin[N] Edge or Level Detection Interrupt Trigger Type Control\nTYPE (Px_INTTYPE[n]) bit is used to control the triggered interrupt is by level trigger or by edge trigger. If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce. If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrupt.\nNote2:\nThePA.7/PB.12/PC.4/PC.5/PC.12/PC.13/PD.0/PD.1/PD.2/PD.3/PD.4/PD.5/PD.8/PD.9/PD.10/PD.11/PD.12/PD.13/PE.0/PE.1/PE.2/PE.3/PE.4/PE.6/PE.7/PE.8/PE.9/PE.10/PE.11/PE.12/PE.13/PE.14/PE.15/PF.4/PF.5 pin is ignored.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Edge trigger interrupt</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Level trigger interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TYPE5</name>
              <description>Port A-f Pin[N] Edge or Level Detection Interrupt Trigger Type Control\nTYPE (Px_INTTYPE[n]) bit is used to control the triggered interrupt is by level trigger or by edge trigger. If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce. If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrupt.\nNote2:\nThePA.7/PB.12/PC.4/PC.5/PC.12/PC.13/PD.0/PD.1/PD.2/PD.3/PD.4/PD.5/PD.8/PD.9/PD.10/PD.11/PD.12/PD.13/PE.0/PE.1/PE.2/PE.3/PE.4/PE.6/PE.7/PE.8/PE.9/PE.10/PE.11/PE.12/PE.13/PE.14/PE.15/PF.4/PF.5 pin is ignored.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Edge trigger interrupt</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Level trigger interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TYPE6</name>
              <description>Port A-f Pin[N] Edge or Level Detection Interrupt Trigger Type Control\nTYPE (Px_INTTYPE[n]) bit is used to control the triggered interrupt is by level trigger or by edge trigger. If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce. If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrupt.\nNote2:\nThePA.7/PB.12/PC.4/PC.5/PC.12/PC.13/PD.0/PD.1/PD.2/PD.3/PD.4/PD.5/PD.8/PD.9/PD.10/PD.11/PD.12/PD.13/PE.0/PE.1/PE.2/PE.3/PE.4/PE.6/PE.7/PE.8/PE.9/PE.10/PE.11/PE.12/PE.13/PE.14/PE.15/PF.4/PF.5 pin is ignored.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Edge trigger interrupt</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Level trigger interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TYPE7</name>
              <description>Port A-f Pin[N] Edge or Level Detection Interrupt Trigger Type Control\nTYPE (Px_INTTYPE[n]) bit is used to control the triggered interrupt is by level trigger or by edge trigger. If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce. If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrupt.\nNote2:\nThePA.7/PB.12/PC.4/PC.5/PC.12/PC.13/PD.0/PD.1/PD.2/PD.3/PD.4/PD.5/PD.8/PD.9/PD.10/PD.11/PD.12/PD.13/PE.0/PE.1/PE.2/PE.3/PE.4/PE.6/PE.7/PE.8/PE.9/PE.10/PE.11/PE.12/PE.13/PE.14/PE.15/PF.4/PF.5 pin is ignored.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Edge trigger interrupt</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Level trigger interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TYPE8</name>
              <description>Port A-f Pin[N] Edge or Level Detection Interrupt Trigger Type Control\nTYPE (Px_INTTYPE[n]) bit is used to control the triggered interrupt is by level trigger or by edge trigger. If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce. If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrupt.\nNote2:\nThePA.7/PB.12/PC.4/PC.5/PC.12/PC.13/PD.0/PD.1/PD.2/PD.3/PD.4/PD.5/PD.8/PD.9/PD.10/PD.11/PD.12/PD.13/PE.0/PE.1/PE.2/PE.3/PE.4/PE.6/PE.7/PE.8/PE.9/PE.10/PE.11/PE.12/PE.13/PE.14/PE.15/PF.4/PF.5 pin is ignored.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Edge trigger interrupt</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Level trigger interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TYPE9</name>
              <description>Port A-f Pin[N] Edge or Level Detection Interrupt Trigger Type Control\nTYPE (Px_INTTYPE[n]) bit is used to control the triggered interrupt is by level trigger or by edge trigger. If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce. If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrupt.\nNote2:\nThePA.7/PB.12/PC.4/PC.5/PC.12/PC.13/PD.0/PD.1/PD.2/PD.3/PD.4/PD.5/PD.8/PD.9/PD.10/PD.11/PD.12/PD.13/PE.0/PE.1/PE.2/PE.3/PE.4/PE.6/PE.7/PE.8/PE.9/PE.10/PE.11/PE.12/PE.13/PE.14/PE.15/PF.4/PF.5 pin is ignored.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Edge trigger interrupt</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Level trigger interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TYPE10</name>
              <description>Port A-f Pin[N] Edge or Level Detection Interrupt Trigger Type Control\nTYPE (Px_INTTYPE[n]) bit is used to control the triggered interrupt is by level trigger or by edge trigger. If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce. If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrupt.\nNote2:\nThePA.7/PB.12/PC.4/PC.5/PC.12/PC.13/PD.0/PD.1/PD.2/PD.3/PD.4/PD.5/PD.8/PD.9/PD.10/PD.11/PD.12/PD.13/PE.0/PE.1/PE.2/PE.3/PE.4/PE.6/PE.7/PE.8/PE.9/PE.10/PE.11/PE.12/PE.13/PE.14/PE.15/PF.4/PF.5 pin is ignored.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Edge trigger interrupt</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Level trigger interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TYPE11</name>
              <description>Port A-f Pin[N] Edge or Level Detection Interrupt Trigger Type Control\nTYPE (Px_INTTYPE[n]) bit is used to control the triggered interrupt is by level trigger or by edge trigger. If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce. If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrupt.\nNote2:\nThePA.7/PB.12/PC.4/PC.5/PC.12/PC.13/PD.0/PD.1/PD.2/PD.3/PD.4/PD.5/PD.8/PD.9/PD.10/PD.11/PD.12/PD.13/PE.0/PE.1/PE.2/PE.3/PE.4/PE.6/PE.7/PE.8/PE.9/PE.10/PE.11/PE.12/PE.13/PE.14/PE.15/PF.4/PF.5 pin is ignored.</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Edge trigger interrupt</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Level trigger interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TYPE12</name>
              <description>Port A-f Pin[N] Edge or Level Detection Interrupt Trigger Type Control\nTYPE (Px_INTTYPE[n]) bit is used to control the triggered interrupt is by level trigger or by edge trigger. If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce. If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrupt.\nNote2:\nThePA.7/PB.12/PC.4/PC.5/PC.12/PC.13/PD.0/PD.1/PD.2/PD.3/PD.4/PD.5/PD.8/PD.9/PD.10/PD.11/PD.12/PD.13/PE.0/PE.1/PE.2/PE.3/PE.4/PE.6/PE.7/PE.8/PE.9/PE.10/PE.11/PE.12/PE.13/PE.14/PE.15/PF.4/PF.5 pin is ignored.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Edge trigger interrupt</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Level trigger interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TYPE13</name>
              <description>Port A-f Pin[N] Edge or Level Detection Interrupt Trigger Type Control\nTYPE (Px_INTTYPE[n]) bit is used to control the triggered interrupt is by level trigger or by edge trigger. If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce. If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrupt.\nNote2:\nThePA.7/PB.12/PC.4/PC.5/PC.12/PC.13/PD.0/PD.1/PD.2/PD.3/PD.4/PD.5/PD.8/PD.9/PD.10/PD.11/PD.12/PD.13/PE.0/PE.1/PE.2/PE.3/PE.4/PE.6/PE.7/PE.8/PE.9/PE.10/PE.11/PE.12/PE.13/PE.14/PE.15/PF.4/PF.5 pin is ignored.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Edge trigger interrupt</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Level trigger interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TYPE14</name>
              <description>Port A-f Pin[N] Edge or Level Detection Interrupt Trigger Type Control\nTYPE (Px_INTTYPE[n]) bit is used to control the triggered interrupt is by level trigger or by edge trigger. If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce. If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrupt.\nNote2:\nThePA.7/PB.12/PC.4/PC.5/PC.12/PC.13/PD.0/PD.1/PD.2/PD.3/PD.4/PD.5/PD.8/PD.9/PD.10/PD.11/PD.12/PD.13/PE.0/PE.1/PE.2/PE.3/PE.4/PE.6/PE.7/PE.8/PE.9/PE.10/PE.11/PE.12/PE.13/PE.14/PE.15/PF.4/PF.5 pin is ignored.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Edge trigger interrupt</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Level trigger interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TYPE15</name>
              <description>Port A-f Pin[N] Edge or Level Detection Interrupt Trigger Type Control\nTYPE (Px_INTTYPE[n]) bit is used to control the triggered interrupt is by level trigger or by edge trigger. If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce. If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrupt.\nNote2:\nThePA.7/PB.12/PC.4/PC.5/PC.12/PC.13/PD.0/PD.1/PD.2/PD.3/PD.4/PD.5/PD.8/PD.9/PD.10/PD.11/PD.12/PD.13/PE.0/PE.1/PE.2/PE.3/PE.4/PE.6/PE.7/PE.8/PE.9/PE.10/PE.11/PE.12/PE.13/PE.14/PE.15/PF.4/PF.5 pin is ignored.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Edge trigger interrupt</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Level trigger interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PA_INTEN</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PA_INTEN</displayName>
          <description>PA Interrupt Enable Control Register</description>
          <addressOffset>0x1C</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>FLIEN0</name>
              <description>Port A-f Pin[N] Falling Edge or Low Level Interrupt Trigger Type Enable Bit\nThe FLIEN (Px_INTEN[n]) bit is used to enable the interrupt for each of the corresponding input Px.n pin. Set bit to 1 also enable the pin wake-up function.\nWhen setting the FLIEN (Px_INTEN[n]) bit to 1 :\nIf the interrupt is level trigger (TYPE (Px_INTTYPE[n]) bit is set to 1), the input Px.n pin will generate the interrupt while this pin state is at low level.\nIf the interrupt is edge trigger(TYPE (Px_INTTYPE[n]) bit is set to 0), the input Px.n pin will generate the interrupt while this pin state changed from high to low.\nNote2:\nThePA.7/PB.12/PC.4/PC.5/PC.12/PC.13/PD.0/PD.1/PD.2/PD.3/PD.4/PD.5/PD.8/PD.9/PD.10/PD.11/PD.12/PD.13/PE.0/PE.1/PE.2/PE.3/PE.4/PE.6/PE.7/PE.8/PE.9/PE.10/PE.11/PE.12/PE.13/PE.14/PE.15/PF.4/PF.5 pin is ignored.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Px.n level low or high to low interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Px.n level low or high to low interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>FLIEN1</name>
              <description>Port A-f Pin[N] Falling Edge or Low Level Interrupt Trigger Type Enable Bit\nThe FLIEN (Px_INTEN[n]) bit is used to enable the interrupt for each of the corresponding input Px.n pin. Set bit to 1 also enable the pin wake-up function.\nWhen setting the FLIEN (Px_INTEN[n]) bit to 1 :\nIf the interrupt is level trigger (TYPE (Px_INTTYPE[n]) bit is set to 1), the input Px.n pin will generate the interrupt while this pin state is at low level.\nIf the interrupt is edge trigger(TYPE (Px_INTTYPE[n]) bit is set to 0), the input Px.n pin will generate the interrupt while this pin state changed from high to low.\nNote2:\nThePA.7/PB.12/PC.4/PC.5/PC.12/PC.13/PD.0/PD.1/PD.2/PD.3/PD.4/PD.5/PD.8/PD.9/PD.10/PD.11/PD.12/PD.13/PE.0/PE.1/PE.2/PE.3/PE.4/PE.6/PE.7/PE.8/PE.9/PE.10/PE.11/PE.12/PE.13/PE.14/PE.15/PF.4/PF.5 pin is ignored.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Px.n level low or high to low interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Px.n level low or high to low interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>FLIEN2</name>
              <description>Port A-f Pin[N] Falling Edge or Low Level Interrupt Trigger Type Enable Bit\nThe FLIEN (Px_INTEN[n]) bit is used to enable the interrupt for each of the corresponding input Px.n pin. Set bit to 1 also enable the pin wake-up function.\nWhen setting the FLIEN (Px_INTEN[n]) bit to 1 :\nIf the interrupt is level trigger (TYPE (Px_INTTYPE[n]) bit is set to 1), the input Px.n pin will generate the interrupt while this pin state is at low level.\nIf the interrupt is edge trigger(TYPE (Px_INTTYPE[n]) bit is set to 0), the input Px.n pin will generate the interrupt while this pin state changed from high to low.\nNote2:\nThePA.7/PB.12/PC.4/PC.5/PC.12/PC.13/PD.0/PD.1/PD.2/PD.3/PD.4/PD.5/PD.8/PD.9/PD.10/PD.11/PD.12/PD.13/PE.0/PE.1/PE.2/PE.3/PE.4/PE.6/PE.7/PE.8/PE.9/PE.10/PE.11/PE.12/PE.13/PE.14/PE.15/PF.4/PF.5 pin is ignored.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Px.n level low or high to low interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Px.n level low or high to low interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>FLIEN3</name>
              <description>Port A-f Pin[N] Falling Edge or Low Level Interrupt Trigger Type Enable Bit\nThe FLIEN (Px_INTEN[n]) bit is used to enable the interrupt for each of the corresponding input Px.n pin. Set bit to 1 also enable the pin wake-up function.\nWhen setting the FLIEN (Px_INTEN[n]) bit to 1 :\nIf the interrupt is level trigger (TYPE (Px_INTTYPE[n]) bit is set to 1), the input Px.n pin will generate the interrupt while this pin state is at low level.\nIf the interrupt is edge trigger(TYPE (Px_INTTYPE[n]) bit is set to 0), the input Px.n pin will generate the interrupt while this pin state changed from high to low.\nNote2:\nThePA.7/PB.12/PC.4/PC.5/PC.12/PC.13/PD.0/PD.1/PD.2/PD.3/PD.4/PD.5/PD.8/PD.9/PD.10/PD.11/PD.12/PD.13/PE.0/PE.1/PE.2/PE.3/PE.4/PE.6/PE.7/PE.8/PE.9/PE.10/PE.11/PE.12/PE.13/PE.14/PE.15/PF.4/PF.5 pin is ignored.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Px.n level low or high to low interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Px.n level low or high to low interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>FLIEN4</name>
              <description>Port A-f Pin[N] Falling Edge or Low Level Interrupt Trigger Type Enable Bit\nThe FLIEN (Px_INTEN[n]) bit is used to enable the interrupt for each of the corresponding input Px.n pin. Set bit to 1 also enable the pin wake-up function.\nWhen setting the FLIEN (Px_INTEN[n]) bit to 1 :\nIf the interrupt is level trigger (TYPE (Px_INTTYPE[n]) bit is set to 1), the input Px.n pin will generate the interrupt while this pin state is at low level.\nIf the interrupt is edge trigger(TYPE (Px_INTTYPE[n]) bit is set to 0), the input Px.n pin will generate the interrupt while this pin state changed from high to low.\nNote2:\nThePA.7/PB.12/PC.4/PC.5/PC.12/PC.13/PD.0/PD.1/PD.2/PD.3/PD.4/PD.5/PD.8/PD.9/PD.10/PD.11/PD.12/PD.13/PE.0/PE.1/PE.2/PE.3/PE.4/PE.6/PE.7/PE.8/PE.9/PE.10/PE.11/PE.12/PE.13/PE.14/PE.15/PF.4/PF.5 pin is ignored.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Px.n level low or high to low interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Px.n level low or high to low interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>FLIEN5</name>
              <description>Port A-f Pin[N] Falling Edge or Low Level Interrupt Trigger Type Enable Bit\nThe FLIEN (Px_INTEN[n]) bit is used to enable the interrupt for each of the corresponding input Px.n pin. Set bit to 1 also enable the pin wake-up function.\nWhen setting the FLIEN (Px_INTEN[n]) bit to 1 :\nIf the interrupt is level trigger (TYPE (Px_INTTYPE[n]) bit is set to 1), the input Px.n pin will generate the interrupt while this pin state is at low level.\nIf the interrupt is edge trigger(TYPE (Px_INTTYPE[n]) bit is set to 0), the input Px.n pin will generate the interrupt while this pin state changed from high to low.\nNote2:\nThePA.7/PB.12/PC.4/PC.5/PC.12/PC.13/PD.0/PD.1/PD.2/PD.3/PD.4/PD.5/PD.8/PD.9/PD.10/PD.11/PD.12/PD.13/PE.0/PE.1/PE.2/PE.3/PE.4/PE.6/PE.7/PE.8/PE.9/PE.10/PE.11/PE.12/PE.13/PE.14/PE.15/PF.4/PF.5 pin is ignored.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Px.n level low or high to low interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Px.n level low or high to low interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>FLIEN6</name>
              <description>Port A-f Pin[N] Falling Edge or Low Level Interrupt Trigger Type Enable Bit\nThe FLIEN (Px_INTEN[n]) bit is used to enable the interrupt for each of the corresponding input Px.n pin. Set bit to 1 also enable the pin wake-up function.\nWhen setting the FLIEN (Px_INTEN[n]) bit to 1 :\nIf the interrupt is level trigger (TYPE (Px_INTTYPE[n]) bit is set to 1), the input Px.n pin will generate the interrupt while this pin state is at low level.\nIf the interrupt is edge trigger(TYPE (Px_INTTYPE[n]) bit is set to 0), the input Px.n pin will generate the interrupt while this pin state changed from high to low.\nNote2:\nThePA.7/PB.12/PC.4/PC.5/PC.12/PC.13/PD.0/PD.1/PD.2/PD.3/PD.4/PD.5/PD.8/PD.9/PD.10/PD.11/PD.12/PD.13/PE.0/PE.1/PE.2/PE.3/PE.4/PE.6/PE.7/PE.8/PE.9/PE.10/PE.11/PE.12/PE.13/PE.14/PE.15/PF.4/PF.5 pin is ignored.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Px.n level low or high to low interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Px.n level low or high to low interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>FLIEN7</name>
              <description>Port A-f Pin[N] Falling Edge or Low Level Interrupt Trigger Type Enable Bit\nThe FLIEN (Px_INTEN[n]) bit is used to enable the interrupt for each of the corresponding input Px.n pin. Set bit to 1 also enable the pin wake-up function.\nWhen setting the FLIEN (Px_INTEN[n]) bit to 1 :\nIf the interrupt is level trigger (TYPE (Px_INTTYPE[n]) bit is set to 1), the input Px.n pin will generate the interrupt while this pin state is at low level.\nIf the interrupt is edge trigger(TYPE (Px_INTTYPE[n]) bit is set to 0), the input Px.n pin will generate the interrupt while this pin state changed from high to low.\nNote2:\nThePA.7/PB.12/PC.4/PC.5/PC.12/PC.13/PD.0/PD.1/PD.2/PD.3/PD.4/PD.5/PD.8/PD.9/PD.10/PD.11/PD.12/PD.13/PE.0/PE.1/PE.2/PE.3/PE.4/PE.6/PE.7/PE.8/PE.9/PE.10/PE.11/PE.12/PE.13/PE.14/PE.15/PF.4/PF.5 pin is ignored.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Px.n level low or high to low interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Px.n level low or high to low interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>FLIEN8</name>
              <description>Port A-f Pin[N] Falling Edge or Low Level Interrupt Trigger Type Enable Bit\nThe FLIEN (Px_INTEN[n]) bit is used to enable the interrupt for each of the corresponding input Px.n pin. Set bit to 1 also enable the pin wake-up function.\nWhen setting the FLIEN (Px_INTEN[n]) bit to 1 :\nIf the interrupt is level trigger (TYPE (Px_INTTYPE[n]) bit is set to 1), the input Px.n pin will generate the interrupt while this pin state is at low level.\nIf the interrupt is edge trigger(TYPE (Px_INTTYPE[n]) bit is set to 0), the input Px.n pin will generate the interrupt while this pin state changed from high to low.\nNote2:\nThePA.7/PB.12/PC.4/PC.5/PC.12/PC.13/PD.0/PD.1/PD.2/PD.3/PD.4/PD.5/PD.8/PD.9/PD.10/PD.11/PD.12/PD.13/PE.0/PE.1/PE.2/PE.3/PE.4/PE.6/PE.7/PE.8/PE.9/PE.10/PE.11/PE.12/PE.13/PE.14/PE.15/PF.4/PF.5 pin is ignored.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Px.n level low or high to low interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Px.n level low or high to low interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>FLIEN9</name>
              <description>Port A-f Pin[N] Falling Edge or Low Level Interrupt Trigger Type Enable Bit\nThe FLIEN (Px_INTEN[n]) bit is used to enable the interrupt for each of the corresponding input Px.n pin. Set bit to 1 also enable the pin wake-up function.\nWhen setting the FLIEN (Px_INTEN[n]) bit to 1 :\nIf the interrupt is level trigger (TYPE (Px_INTTYPE[n]) bit is set to 1), the input Px.n pin will generate the interrupt while this pin state is at low level.\nIf the interrupt is edge trigger(TYPE (Px_INTTYPE[n]) bit is set to 0), the input Px.n pin will generate the interrupt while this pin state changed from high to low.\nNote2:\nThePA.7/PB.12/PC.4/PC.5/PC.12/PC.13/PD.0/PD.1/PD.2/PD.3/PD.4/PD.5/PD.8/PD.9/PD.10/PD.11/PD.12/PD.13/PE.0/PE.1/PE.2/PE.3/PE.4/PE.6/PE.7/PE.8/PE.9/PE.10/PE.11/PE.12/PE.13/PE.14/PE.15/PF.4/PF.5 pin is ignored.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Px.n level low or high to low interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Px.n level low or high to low interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>FLIEN10</name>
              <description>Port A-f Pin[N] Falling Edge or Low Level Interrupt Trigger Type Enable Bit\nThe FLIEN (Px_INTEN[n]) bit is used to enable the interrupt for each of the corresponding input Px.n pin. Set bit to 1 also enable the pin wake-up function.\nWhen setting the FLIEN (Px_INTEN[n]) bit to 1 :\nIf the interrupt is level trigger (TYPE (Px_INTTYPE[n]) bit is set to 1), the input Px.n pin will generate the interrupt while this pin state is at low level.\nIf the interrupt is edge trigger(TYPE (Px_INTTYPE[n]) bit is set to 0), the input Px.n pin will generate the interrupt while this pin state changed from high to low.\nNote2:\nThePA.7/PB.12/PC.4/PC.5/PC.12/PC.13/PD.0/PD.1/PD.2/PD.3/PD.4/PD.5/PD.8/PD.9/PD.10/PD.11/PD.12/PD.13/PE.0/PE.1/PE.2/PE.3/PE.4/PE.6/PE.7/PE.8/PE.9/PE.10/PE.11/PE.12/PE.13/PE.14/PE.15/PF.4/PF.5 pin is ignored.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Px.n level low or high to low interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Px.n level low or high to low interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>FLIEN11</name>
              <description>Port A-f Pin[N] Falling Edge or Low Level Interrupt Trigger Type Enable Bit\nThe FLIEN (Px_INTEN[n]) bit is used to enable the interrupt for each of the corresponding input Px.n pin. Set bit to 1 also enable the pin wake-up function.\nWhen setting the FLIEN (Px_INTEN[n]) bit to 1 :\nIf the interrupt is level trigger (TYPE (Px_INTTYPE[n]) bit is set to 1), the input Px.n pin will generate the interrupt while this pin state is at low level.\nIf the interrupt is edge trigger(TYPE (Px_INTTYPE[n]) bit is set to 0), the input Px.n pin will generate the interrupt while this pin state changed from high to low.\nNote2:\nThePA.7/PB.12/PC.4/PC.5/PC.12/PC.13/PD.0/PD.1/PD.2/PD.3/PD.4/PD.5/PD.8/PD.9/PD.10/PD.11/PD.12/PD.13/PE.0/PE.1/PE.2/PE.3/PE.4/PE.6/PE.7/PE.8/PE.9/PE.10/PE.11/PE.12/PE.13/PE.14/PE.15/PF.4/PF.5 pin is ignored.</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Px.n level low or high to low interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Px.n level low or high to low interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>FLIEN12</name>
              <description>Port A-f Pin[N] Falling Edge or Low Level Interrupt Trigger Type Enable Bit\nThe FLIEN (Px_INTEN[n]) bit is used to enable the interrupt for each of the corresponding input Px.n pin. Set bit to 1 also enable the pin wake-up function.\nWhen setting the FLIEN (Px_INTEN[n]) bit to 1 :\nIf the interrupt is level trigger (TYPE (Px_INTTYPE[n]) bit is set to 1), the input Px.n pin will generate the interrupt while this pin state is at low level.\nIf the interrupt is edge trigger(TYPE (Px_INTTYPE[n]) bit is set to 0), the input Px.n pin will generate the interrupt while this pin state changed from high to low.\nNote2:\nThePA.7/PB.12/PC.4/PC.5/PC.12/PC.13/PD.0/PD.1/PD.2/PD.3/PD.4/PD.5/PD.8/PD.9/PD.10/PD.11/PD.12/PD.13/PE.0/PE.1/PE.2/PE.3/PE.4/PE.6/PE.7/PE.8/PE.9/PE.10/PE.11/PE.12/PE.13/PE.14/PE.15/PF.4/PF.5 pin is ignored.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Px.n level low or high to low interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Px.n level low or high to low interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>FLIEN13</name>
              <description>Port A-f Pin[N] Falling Edge or Low Level Interrupt Trigger Type Enable Bit\nThe FLIEN (Px_INTEN[n]) bit is used to enable the interrupt for each of the corresponding input Px.n pin. Set bit to 1 also enable the pin wake-up function.\nWhen setting the FLIEN (Px_INTEN[n]) bit to 1 :\nIf the interrupt is level trigger (TYPE (Px_INTTYPE[n]) bit is set to 1), the input Px.n pin will generate the interrupt while this pin state is at low level.\nIf the interrupt is edge trigger(TYPE (Px_INTTYPE[n]) bit is set to 0), the input Px.n pin will generate the interrupt while this pin state changed from high to low.\nNote2:\nThePA.7/PB.12/PC.4/PC.5/PC.12/PC.13/PD.0/PD.1/PD.2/PD.3/PD.4/PD.5/PD.8/PD.9/PD.10/PD.11/PD.12/PD.13/PE.0/PE.1/PE.2/PE.3/PE.4/PE.6/PE.7/PE.8/PE.9/PE.10/PE.11/PE.12/PE.13/PE.14/PE.15/PF.4/PF.5 pin is ignored.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Px.n level low or high to low interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Px.n level low or high to low interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>FLIEN14</name>
              <description>Port A-f Pin[N] Falling Edge or Low Level Interrupt Trigger Type Enable Bit\nThe FLIEN (Px_INTEN[n]) bit is used to enable the interrupt for each of the corresponding input Px.n pin. Set bit to 1 also enable the pin wake-up function.\nWhen setting the FLIEN (Px_INTEN[n]) bit to 1 :\nIf the interrupt is level trigger (TYPE (Px_INTTYPE[n]) bit is set to 1), the input Px.n pin will generate the interrupt while this pin state is at low level.\nIf the interrupt is edge trigger(TYPE (Px_INTTYPE[n]) bit is set to 0), the input Px.n pin will generate the interrupt while this pin state changed from high to low.\nNote2:\nThePA.7/PB.12/PC.4/PC.5/PC.12/PC.13/PD.0/PD.1/PD.2/PD.3/PD.4/PD.5/PD.8/PD.9/PD.10/PD.11/PD.12/PD.13/PE.0/PE.1/PE.2/PE.3/PE.4/PE.6/PE.7/PE.8/PE.9/PE.10/PE.11/PE.12/PE.13/PE.14/PE.15/PF.4/PF.5 pin is ignored.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Px.n level low or high to low interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Px.n level low or high to low interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>FLIEN15</name>
              <description>Port A-f Pin[N] Falling Edge or Low Level Interrupt Trigger Type Enable Bit\nThe FLIEN (Px_INTEN[n]) bit is used to enable the interrupt for each of the corresponding input Px.n pin. Set bit to 1 also enable the pin wake-up function.\nWhen setting the FLIEN (Px_INTEN[n]) bit to 1 :\nIf the interrupt is level trigger (TYPE (Px_INTTYPE[n]) bit is set to 1), the input Px.n pin will generate the interrupt while this pin state is at low level.\nIf the interrupt is edge trigger(TYPE (Px_INTTYPE[n]) bit is set to 0), the input Px.n pin will generate the interrupt while this pin state changed from high to low.\nNote2:\nThePA.7/PB.12/PC.4/PC.5/PC.12/PC.13/PD.0/PD.1/PD.2/PD.3/PD.4/PD.5/PD.8/PD.9/PD.10/PD.11/PD.12/PD.13/PE.0/PE.1/PE.2/PE.3/PE.4/PE.6/PE.7/PE.8/PE.9/PE.10/PE.11/PE.12/PE.13/PE.14/PE.15/PF.4/PF.5 pin is ignored.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Px.n level low or high to low interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Px.n level low or high to low interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RHIEN0</name>
              <description>Port A-f Pin[N] Rising Edge or High Level Interrupt Trigger Type Enable Bit\nThe RHIEN (Px_INTEN[n+16]) bit is used to enable the interrupt for each of the corresponding input Px.n pin. Set bit to 1 also enable the pin wake-up function. \nWhen setting the RHIEN (Px_INTEN[n+16]) bit to 1 :\nIf the interrupt is level trigger (TYPE (Px_INTTYPE[n]) bit is set to 1), the input Px.n pin will generate the interrupt while this pin state is at high level.\nIf the interrupt is edge trigger (TYPE (Px_INTTYPE[n]) bit is set to 0), the input Px.n pin will generate the interrupt while this pin state changed from low to high.\nNote2:\nThePA.7/PB.12/PC.4/PC.5/PC.12/PC.13/PD.0/PD.1/PD.2/PD.3/PD.4/PD.5/PD.8/PD.9/PD.10/PD.11/PD.12/PD.13/PE.0/PE.1/PE.2/PE.3/PE.4/PE.6/PE.7/PE.8/PE.9/PE.10/PE.11/PE.12/PE.13/PE.14/PE.15/PF.4/PF.5 pin is ignored.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Px.n level high or low to high interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Px.n level high or low to high interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RHIEN1</name>
              <description>Port A-f Pin[N] Rising Edge or High Level Interrupt Trigger Type Enable Bit\nThe RHIEN (Px_INTEN[n+16]) bit is used to enable the interrupt for each of the corresponding input Px.n pin. Set bit to 1 also enable the pin wake-up function. \nWhen setting the RHIEN (Px_INTEN[n+16]) bit to 1 :\nIf the interrupt is level trigger (TYPE (Px_INTTYPE[n]) bit is set to 1), the input Px.n pin will generate the interrupt while this pin state is at high level.\nIf the interrupt is edge trigger (TYPE (Px_INTTYPE[n]) bit is set to 0), the input Px.n pin will generate the interrupt while this pin state changed from low to high.\nNote2:\nThePA.7/PB.12/PC.4/PC.5/PC.12/PC.13/PD.0/PD.1/PD.2/PD.3/PD.4/PD.5/PD.8/PD.9/PD.10/PD.11/PD.12/PD.13/PE.0/PE.1/PE.2/PE.3/PE.4/PE.6/PE.7/PE.8/PE.9/PE.10/PE.11/PE.12/PE.13/PE.14/PE.15/PF.4/PF.5 pin is ignored.</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Px.n level high or low to high interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Px.n level high or low to high interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RHIEN2</name>
              <description>Port A-f Pin[N] Rising Edge or High Level Interrupt Trigger Type Enable Bit\nThe RHIEN (Px_INTEN[n+16]) bit is used to enable the interrupt for each of the corresponding input Px.n pin. Set bit to 1 also enable the pin wake-up function. \nWhen setting the RHIEN (Px_INTEN[n+16]) bit to 1 :\nIf the interrupt is level trigger (TYPE (Px_INTTYPE[n]) bit is set to 1), the input Px.n pin will generate the interrupt while this pin state is at high level.\nIf the interrupt is edge trigger (TYPE (Px_INTTYPE[n]) bit is set to 0), the input Px.n pin will generate the interrupt while this pin state changed from low to high.\nNote2:\nThePA.7/PB.12/PC.4/PC.5/PC.12/PC.13/PD.0/PD.1/PD.2/PD.3/PD.4/PD.5/PD.8/PD.9/PD.10/PD.11/PD.12/PD.13/PE.0/PE.1/PE.2/PE.3/PE.4/PE.6/PE.7/PE.8/PE.9/PE.10/PE.11/PE.12/PE.13/PE.14/PE.15/PF.4/PF.5 pin is ignored.</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Px.n level high or low to high interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Px.n level high or low to high interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RHIEN3</name>
              <description>Port A-f Pin[N] Rising Edge or High Level Interrupt Trigger Type Enable Bit\nThe RHIEN (Px_INTEN[n+16]) bit is used to enable the interrupt for each of the corresponding input Px.n pin. Set bit to 1 also enable the pin wake-up function. \nWhen setting the RHIEN (Px_INTEN[n+16]) bit to 1 :\nIf the interrupt is level trigger (TYPE (Px_INTTYPE[n]) bit is set to 1), the input Px.n pin will generate the interrupt while this pin state is at high level.\nIf the interrupt is edge trigger (TYPE (Px_INTTYPE[n]) bit is set to 0), the input Px.n pin will generate the interrupt while this pin state changed from low to high.\nNote2:\nThePA.7/PB.12/PC.4/PC.5/PC.12/PC.13/PD.0/PD.1/PD.2/PD.3/PD.4/PD.5/PD.8/PD.9/PD.10/PD.11/PD.12/PD.13/PE.0/PE.1/PE.2/PE.3/PE.4/PE.6/PE.7/PE.8/PE.9/PE.10/PE.11/PE.12/PE.13/PE.14/PE.15/PF.4/PF.5 pin is ignored.</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Px.n level high or low to high interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Px.n level high or low to high interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RHIEN4</name>
              <description>Port A-f Pin[N] Rising Edge or High Level Interrupt Trigger Type Enable Bit\nThe RHIEN (Px_INTEN[n+16]) bit is used to enable the interrupt for each of the corresponding input Px.n pin. Set bit to 1 also enable the pin wake-up function. \nWhen setting the RHIEN (Px_INTEN[n+16]) bit to 1 :\nIf the interrupt is level trigger (TYPE (Px_INTTYPE[n]) bit is set to 1), the input Px.n pin will generate the interrupt while this pin state is at high level.\nIf the interrupt is edge trigger (TYPE (Px_INTTYPE[n]) bit is set to 0), the input Px.n pin will generate the interrupt while this pin state changed from low to high.\nNote2:\nThePA.7/PB.12/PC.4/PC.5/PC.12/PC.13/PD.0/PD.1/PD.2/PD.3/PD.4/PD.5/PD.8/PD.9/PD.10/PD.11/PD.12/PD.13/PE.0/PE.1/PE.2/PE.3/PE.4/PE.6/PE.7/PE.8/PE.9/PE.10/PE.11/PE.12/PE.13/PE.14/PE.15/PF.4/PF.5 pin is ignored.</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Px.n level high or low to high interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Px.n level high or low to high interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RHIEN5</name>
              <description>Port A-f Pin[N] Rising Edge or High Level Interrupt Trigger Type Enable Bit\nThe RHIEN (Px_INTEN[n+16]) bit is used to enable the interrupt for each of the corresponding input Px.n pin. Set bit to 1 also enable the pin wake-up function. \nWhen setting the RHIEN (Px_INTEN[n+16]) bit to 1 :\nIf the interrupt is level trigger (TYPE (Px_INTTYPE[n]) bit is set to 1), the input Px.n pin will generate the interrupt while this pin state is at high level.\nIf the interrupt is edge trigger (TYPE (Px_INTTYPE[n]) bit is set to 0), the input Px.n pin will generate the interrupt while this pin state changed from low to high.\nNote2:\nThePA.7/PB.12/PC.4/PC.5/PC.12/PC.13/PD.0/PD.1/PD.2/PD.3/PD.4/PD.5/PD.8/PD.9/PD.10/PD.11/PD.12/PD.13/PE.0/PE.1/PE.2/PE.3/PE.4/PE.6/PE.7/PE.8/PE.9/PE.10/PE.11/PE.12/PE.13/PE.14/PE.15/PF.4/PF.5 pin is ignored.</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Px.n level high or low to high interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Px.n level high or low to high interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RHIEN6</name>
              <description>Port A-f Pin[N] Rising Edge or High Level Interrupt Trigger Type Enable Bit\nThe RHIEN (Px_INTEN[n+16]) bit is used to enable the interrupt for each of the corresponding input Px.n pin. Set bit to 1 also enable the pin wake-up function. \nWhen setting the RHIEN (Px_INTEN[n+16]) bit to 1 :\nIf the interrupt is level trigger (TYPE (Px_INTTYPE[n]) bit is set to 1), the input Px.n pin will generate the interrupt while this pin state is at high level.\nIf the interrupt is edge trigger (TYPE (Px_INTTYPE[n]) bit is set to 0), the input Px.n pin will generate the interrupt while this pin state changed from low to high.\nNote2:\nThePA.7/PB.12/PC.4/PC.5/PC.12/PC.13/PD.0/PD.1/PD.2/PD.3/PD.4/PD.5/PD.8/PD.9/PD.10/PD.11/PD.12/PD.13/PE.0/PE.1/PE.2/PE.3/PE.4/PE.6/PE.7/PE.8/PE.9/PE.10/PE.11/PE.12/PE.13/PE.14/PE.15/PF.4/PF.5 pin is ignored.</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Px.n level high or low to high interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Px.n level high or low to high interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RHIEN7</name>
              <description>Port A-f Pin[N] Rising Edge or High Level Interrupt Trigger Type Enable Bit\nThe RHIEN (Px_INTEN[n+16]) bit is used to enable the interrupt for each of the corresponding input Px.n pin. Set bit to 1 also enable the pin wake-up function. \nWhen setting the RHIEN (Px_INTEN[n+16]) bit to 1 :\nIf the interrupt is level trigger (TYPE (Px_INTTYPE[n]) bit is set to 1), the input Px.n pin will generate the interrupt while this pin state is at high level.\nIf the interrupt is edge trigger (TYPE (Px_INTTYPE[n]) bit is set to 0), the input Px.n pin will generate the interrupt while this pin state changed from low to high.\nNote2:\nThePA.7/PB.12/PC.4/PC.5/PC.12/PC.13/PD.0/PD.1/PD.2/PD.3/PD.4/PD.5/PD.8/PD.9/PD.10/PD.11/PD.12/PD.13/PE.0/PE.1/PE.2/PE.3/PE.4/PE.6/PE.7/PE.8/PE.9/PE.10/PE.11/PE.12/PE.13/PE.14/PE.15/PF.4/PF.5 pin is ignored.</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Px.n level high or low to high interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Px.n level high or low to high interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RHIEN8</name>
              <description>Port A-f Pin[N] Rising Edge or High Level Interrupt Trigger Type Enable Bit\nThe RHIEN (Px_INTEN[n+16]) bit is used to enable the interrupt for each of the corresponding input Px.n pin. Set bit to 1 also enable the pin wake-up function. \nWhen setting the RHIEN (Px_INTEN[n+16]) bit to 1 :\nIf the interrupt is level trigger (TYPE (Px_INTTYPE[n]) bit is set to 1), the input Px.n pin will generate the interrupt while this pin state is at high level.\nIf the interrupt is edge trigger (TYPE (Px_INTTYPE[n]) bit is set to 0), the input Px.n pin will generate the interrupt while this pin state changed from low to high.\nNote2:\nThePA.7/PB.12/PC.4/PC.5/PC.12/PC.13/PD.0/PD.1/PD.2/PD.3/PD.4/PD.5/PD.8/PD.9/PD.10/PD.11/PD.12/PD.13/PE.0/PE.1/PE.2/PE.3/PE.4/PE.6/PE.7/PE.8/PE.9/PE.10/PE.11/PE.12/PE.13/PE.14/PE.15/PF.4/PF.5 pin is ignored.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Px.n level high or low to high interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Px.n level high or low to high interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RHIEN9</name>
              <description>Port A-f Pin[N] Rising Edge or High Level Interrupt Trigger Type Enable Bit\nThe RHIEN (Px_INTEN[n+16]) bit is used to enable the interrupt for each of the corresponding input Px.n pin. Set bit to 1 also enable the pin wake-up function. \nWhen setting the RHIEN (Px_INTEN[n+16]) bit to 1 :\nIf the interrupt is level trigger (TYPE (Px_INTTYPE[n]) bit is set to 1), the input Px.n pin will generate the interrupt while this pin state is at high level.\nIf the interrupt is edge trigger (TYPE (Px_INTTYPE[n]) bit is set to 0), the input Px.n pin will generate the interrupt while this pin state changed from low to high.\nNote2:\nThePA.7/PB.12/PC.4/PC.5/PC.12/PC.13/PD.0/PD.1/PD.2/PD.3/PD.4/PD.5/PD.8/PD.9/PD.10/PD.11/PD.12/PD.13/PE.0/PE.1/PE.2/PE.3/PE.4/PE.6/PE.7/PE.8/PE.9/PE.10/PE.11/PE.12/PE.13/PE.14/PE.15/PF.4/PF.5 pin is ignored.</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Px.n level high or low to high interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Px.n level high or low to high interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RHIEN10</name>
              <description>Port A-f Pin[N] Rising Edge or High Level Interrupt Trigger Type Enable Bit\nThe RHIEN (Px_INTEN[n+16]) bit is used to enable the interrupt for each of the corresponding input Px.n pin. Set bit to 1 also enable the pin wake-up function. \nWhen setting the RHIEN (Px_INTEN[n+16]) bit to 1 :\nIf the interrupt is level trigger (TYPE (Px_INTTYPE[n]) bit is set to 1), the input Px.n pin will generate the interrupt while this pin state is at high level.\nIf the interrupt is edge trigger (TYPE (Px_INTTYPE[n]) bit is set to 0), the input Px.n pin will generate the interrupt while this pin state changed from low to high.\nNote2:\nThePA.7/PB.12/PC.4/PC.5/PC.12/PC.13/PD.0/PD.1/PD.2/PD.3/PD.4/PD.5/PD.8/PD.9/PD.10/PD.11/PD.12/PD.13/PE.0/PE.1/PE.2/PE.3/PE.4/PE.6/PE.7/PE.8/PE.9/PE.10/PE.11/PE.12/PE.13/PE.14/PE.15/PF.4/PF.5 pin is ignored.</description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Px.n level high or low to high interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Px.n level high or low to high interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RHIEN11</name>
              <description>Port A-f Pin[N] Rising Edge or High Level Interrupt Trigger Type Enable Bit\nThe RHIEN (Px_INTEN[n+16]) bit is used to enable the interrupt for each of the corresponding input Px.n pin. Set bit to 1 also enable the pin wake-up function. \nWhen setting the RHIEN (Px_INTEN[n+16]) bit to 1 :\nIf the interrupt is level trigger (TYPE (Px_INTTYPE[n]) bit is set to 1), the input Px.n pin will generate the interrupt while this pin state is at high level.\nIf the interrupt is edge trigger (TYPE (Px_INTTYPE[n]) bit is set to 0), the input Px.n pin will generate the interrupt while this pin state changed from low to high.\nNote2:\nThePA.7/PB.12/PC.4/PC.5/PC.12/PC.13/PD.0/PD.1/PD.2/PD.3/PD.4/PD.5/PD.8/PD.9/PD.10/PD.11/PD.12/PD.13/PE.0/PE.1/PE.2/PE.3/PE.4/PE.6/PE.7/PE.8/PE.9/PE.10/PE.11/PE.12/PE.13/PE.14/PE.15/PF.4/PF.5 pin is ignored.</description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Px.n level high or low to high interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Px.n level high or low to high interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RHIEN12</name>
              <description>Port A-f Pin[N] Rising Edge or High Level Interrupt Trigger Type Enable Bit\nThe RHIEN (Px_INTEN[n+16]) bit is used to enable the interrupt for each of the corresponding input Px.n pin. Set bit to 1 also enable the pin wake-up function. \nWhen setting the RHIEN (Px_INTEN[n+16]) bit to 1 :\nIf the interrupt is level trigger (TYPE (Px_INTTYPE[n]) bit is set to 1), the input Px.n pin will generate the interrupt while this pin state is at high level.\nIf the interrupt is edge trigger (TYPE (Px_INTTYPE[n]) bit is set to 0), the input Px.n pin will generate the interrupt while this pin state changed from low to high.\nNote2:\nThePA.7/PB.12/PC.4/PC.5/PC.12/PC.13/PD.0/PD.1/PD.2/PD.3/PD.4/PD.5/PD.8/PD.9/PD.10/PD.11/PD.12/PD.13/PE.0/PE.1/PE.2/PE.3/PE.4/PE.6/PE.7/PE.8/PE.9/PE.10/PE.11/PE.12/PE.13/PE.14/PE.15/PF.4/PF.5 pin is ignored.</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Px.n level high or low to high interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Px.n level high or low to high interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RHIEN13</name>
              <description>Port A-f Pin[N] Rising Edge or High Level Interrupt Trigger Type Enable Bit\nThe RHIEN (Px_INTEN[n+16]) bit is used to enable the interrupt for each of the corresponding input Px.n pin. Set bit to 1 also enable the pin wake-up function. \nWhen setting the RHIEN (Px_INTEN[n+16]) bit to 1 :\nIf the interrupt is level trigger (TYPE (Px_INTTYPE[n]) bit is set to 1), the input Px.n pin will generate the interrupt while this pin state is at high level.\nIf the interrupt is edge trigger (TYPE (Px_INTTYPE[n]) bit is set to 0), the input Px.n pin will generate the interrupt while this pin state changed from low to high.\nNote2:\nThePA.7/PB.12/PC.4/PC.5/PC.12/PC.13/PD.0/PD.1/PD.2/PD.3/PD.4/PD.5/PD.8/PD.9/PD.10/PD.11/PD.12/PD.13/PE.0/PE.1/PE.2/PE.3/PE.4/PE.6/PE.7/PE.8/PE.9/PE.10/PE.11/PE.12/PE.13/PE.14/PE.15/PF.4/PF.5 pin is ignored.</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Px.n level high or low to high interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Px.n level high or low to high interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RHIEN14</name>
              <description>Port A-f Pin[N] Rising Edge or High Level Interrupt Trigger Type Enable Bit\nThe RHIEN (Px_INTEN[n+16]) bit is used to enable the interrupt for each of the corresponding input Px.n pin. Set bit to 1 also enable the pin wake-up function. \nWhen setting the RHIEN (Px_INTEN[n+16]) bit to 1 :\nIf the interrupt is level trigger (TYPE (Px_INTTYPE[n]) bit is set to 1), the input Px.n pin will generate the interrupt while this pin state is at high level.\nIf the interrupt is edge trigger (TYPE (Px_INTTYPE[n]) bit is set to 0), the input Px.n pin will generate the interrupt while this pin state changed from low to high.\nNote2:\nThePA.7/PB.12/PC.4/PC.5/PC.12/PC.13/PD.0/PD.1/PD.2/PD.3/PD.4/PD.5/PD.8/PD.9/PD.10/PD.11/PD.12/PD.13/PE.0/PE.1/PE.2/PE.3/PE.4/PE.6/PE.7/PE.8/PE.9/PE.10/PE.11/PE.12/PE.13/PE.14/PE.15/PF.4/PF.5 pin is ignored.</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Px.n level high or low to high interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Px.n level high or low to high interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RHIEN15</name>
              <description>Port A-f Pin[N] Rising Edge or High Level Interrupt Trigger Type Enable Bit\nThe RHIEN (Px_INTEN[n+16]) bit is used to enable the interrupt for each of the corresponding input Px.n pin. Set bit to 1 also enable the pin wake-up function. \nWhen setting the RHIEN (Px_INTEN[n+16]) bit to 1 :\nIf the interrupt is level trigger (TYPE (Px_INTTYPE[n]) bit is set to 1), the input Px.n pin will generate the interrupt while this pin state is at high level.\nIf the interrupt is edge trigger (TYPE (Px_INTTYPE[n]) bit is set to 0), the input Px.n pin will generate the interrupt while this pin state changed from low to high.\nNote2:\nThePA.7/PB.12/PC.4/PC.5/PC.12/PC.13/PD.0/PD.1/PD.2/PD.3/PD.4/PD.5/PD.8/PD.9/PD.10/PD.11/PD.12/PD.13/PE.0/PE.1/PE.2/PE.3/PE.4/PE.6/PE.7/PE.8/PE.9/PE.10/PE.11/PE.12/PE.13/PE.14/PE.15/PF.4/PF.5 pin is ignored.</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Px.n level high or low to high interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Px.n level high or low to high interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PA_INTSRC</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PA_INTSRC</displayName>
          <description>PA Interrupt Source Flag</description>
          <addressOffset>0x20</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFF0000</resetMask>
          <fields>
            <field>
              <name>INTSRC0</name>
              <description>Port A-f Pin[N] Interrupt Source Flag\nWrite Operation :\nNote2:\nThePA.7/PB.12/PC.4/PC.5/PC.12/PC.13/PD.0/PD.1/PD.2/PD.3/PD.4/PD.5/PD.8/PD.9/PD.10/PD.11/PD.12/PD.13/PE.0/PE.1/PE.2/PE.3/PE.4/PE.6/PE.7/PE.8/PE.9/PE.10/PE.11/PE.12/PE.13/PE.14/PE.15/PF.4/PF.5 pin is ignored.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No action.\nNo interrupt at Px.n</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Clear the corresponding pending interrupt.\nPx.n generates an interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>INTSRC1</name>
              <description>Port A-f Pin[N] Interrupt Source Flag\nWrite Operation :\nNote2:\nThePA.7/PB.12/PC.4/PC.5/PC.12/PC.13/PD.0/PD.1/PD.2/PD.3/PD.4/PD.5/PD.8/PD.9/PD.10/PD.11/PD.12/PD.13/PE.0/PE.1/PE.2/PE.3/PE.4/PE.6/PE.7/PE.8/PE.9/PE.10/PE.11/PE.12/PE.13/PE.14/PE.15/PF.4/PF.5 pin is ignored.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No action.\nNo interrupt at Px.n</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Clear the corresponding pending interrupt.\nPx.n generates an interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>INTSRC2</name>
              <description>Port A-f Pin[N] Interrupt Source Flag\nWrite Operation :\nNote2:\nThePA.7/PB.12/PC.4/PC.5/PC.12/PC.13/PD.0/PD.1/PD.2/PD.3/PD.4/PD.5/PD.8/PD.9/PD.10/PD.11/PD.12/PD.13/PE.0/PE.1/PE.2/PE.3/PE.4/PE.6/PE.7/PE.8/PE.9/PE.10/PE.11/PE.12/PE.13/PE.14/PE.15/PF.4/PF.5 pin is ignored.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No action.\nNo interrupt at Px.n</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Clear the corresponding pending interrupt.\nPx.n generates an interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>INTSRC3</name>
              <description>Port A-f Pin[N] Interrupt Source Flag\nWrite Operation :\nNote2:\nThePA.7/PB.12/PC.4/PC.5/PC.12/PC.13/PD.0/PD.1/PD.2/PD.3/PD.4/PD.5/PD.8/PD.9/PD.10/PD.11/PD.12/PD.13/PE.0/PE.1/PE.2/PE.3/PE.4/PE.6/PE.7/PE.8/PE.9/PE.10/PE.11/PE.12/PE.13/PE.14/PE.15/PF.4/PF.5 pin is ignored.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No action.\nNo interrupt at Px.n</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Clear the corresponding pending interrupt.\nPx.n generates an interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>INTSRC4</name>
              <description>Port A-f Pin[N] Interrupt Source Flag\nWrite Operation :\nNote2:\nThePA.7/PB.12/PC.4/PC.5/PC.12/PC.13/PD.0/PD.1/PD.2/PD.3/PD.4/PD.5/PD.8/PD.9/PD.10/PD.11/PD.12/PD.13/PE.0/PE.1/PE.2/PE.3/PE.4/PE.6/PE.7/PE.8/PE.9/PE.10/PE.11/PE.12/PE.13/PE.14/PE.15/PF.4/PF.5 pin is ignored.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No action.\nNo interrupt at Px.n</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Clear the corresponding pending interrupt.\nPx.n generates an interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>INTSRC5</name>
              <description>Port A-f Pin[N] Interrupt Source Flag\nWrite Operation :\nNote2:\nThePA.7/PB.12/PC.4/PC.5/PC.12/PC.13/PD.0/PD.1/PD.2/PD.3/PD.4/PD.5/PD.8/PD.9/PD.10/PD.11/PD.12/PD.13/PE.0/PE.1/PE.2/PE.3/PE.4/PE.6/PE.7/PE.8/PE.9/PE.10/PE.11/PE.12/PE.13/PE.14/PE.15/PF.4/PF.5 pin is ignored.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No action.\nNo interrupt at Px.n</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Clear the corresponding pending interrupt.\nPx.n generates an interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>INTSRC6</name>
              <description>Port A-f Pin[N] Interrupt Source Flag\nWrite Operation :\nNote2:\nThePA.7/PB.12/PC.4/PC.5/PC.12/PC.13/PD.0/PD.1/PD.2/PD.3/PD.4/PD.5/PD.8/PD.9/PD.10/PD.11/PD.12/PD.13/PE.0/PE.1/PE.2/PE.3/PE.4/PE.6/PE.7/PE.8/PE.9/PE.10/PE.11/PE.12/PE.13/PE.14/PE.15/PF.4/PF.5 pin is ignored.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No action.\nNo interrupt at Px.n</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Clear the corresponding pending interrupt.\nPx.n generates an interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>INTSRC7</name>
              <description>Port A-f Pin[N] Interrupt Source Flag\nWrite Operation :\nNote2:\nThePA.7/PB.12/PC.4/PC.5/PC.12/PC.13/PD.0/PD.1/PD.2/PD.3/PD.4/PD.5/PD.8/PD.9/PD.10/PD.11/PD.12/PD.13/PE.0/PE.1/PE.2/PE.3/PE.4/PE.6/PE.7/PE.8/PE.9/PE.10/PE.11/PE.12/PE.13/PE.14/PE.15/PF.4/PF.5 pin is ignored.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No action.\nNo interrupt at Px.n</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Clear the corresponding pending interrupt.\nPx.n generates an interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>INTSRC8</name>
              <description>Port A-f Pin[N] Interrupt Source Flag\nWrite Operation :\nNote2:\nThePA.7/PB.12/PC.4/PC.5/PC.12/PC.13/PD.0/PD.1/PD.2/PD.3/PD.4/PD.5/PD.8/PD.9/PD.10/PD.11/PD.12/PD.13/PE.0/PE.1/PE.2/PE.3/PE.4/PE.6/PE.7/PE.8/PE.9/PE.10/PE.11/PE.12/PE.13/PE.14/PE.15/PF.4/PF.5 pin is ignored.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No action.\nNo interrupt at Px.n</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Clear the corresponding pending interrupt.\nPx.n generates an interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>INTSRC9</name>
              <description>Port A-f Pin[N] Interrupt Source Flag\nWrite Operation :\nNote2:\nThePA.7/PB.12/PC.4/PC.5/PC.12/PC.13/PD.0/PD.1/PD.2/PD.3/PD.4/PD.5/PD.8/PD.9/PD.10/PD.11/PD.12/PD.13/PE.0/PE.1/PE.2/PE.3/PE.4/PE.6/PE.7/PE.8/PE.9/PE.10/PE.11/PE.12/PE.13/PE.14/PE.15/PF.4/PF.5 pin is ignored.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No action.\nNo interrupt at Px.n</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Clear the corresponding pending interrupt.\nPx.n generates an interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>INTSRC10</name>
              <description>Port A-f Pin[N] Interrupt Source Flag\nWrite Operation :\nNote2:\nThePA.7/PB.12/PC.4/PC.5/PC.12/PC.13/PD.0/PD.1/PD.2/PD.3/PD.4/PD.5/PD.8/PD.9/PD.10/PD.11/PD.12/PD.13/PE.0/PE.1/PE.2/PE.3/PE.4/PE.6/PE.7/PE.8/PE.9/PE.10/PE.11/PE.12/PE.13/PE.14/PE.15/PF.4/PF.5 pin is ignored.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No action.\nNo interrupt at Px.n</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Clear the corresponding pending interrupt.\nPx.n generates an interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>INTSRC11</name>
              <description>Port A-f Pin[N] Interrupt Source Flag\nWrite Operation :\nNote2:\nThePA.7/PB.12/PC.4/PC.5/PC.12/PC.13/PD.0/PD.1/PD.2/PD.3/PD.4/PD.5/PD.8/PD.9/PD.10/PD.11/PD.12/PD.13/PE.0/PE.1/PE.2/PE.3/PE.4/PE.6/PE.7/PE.8/PE.9/PE.10/PE.11/PE.12/PE.13/PE.14/PE.15/PF.4/PF.5 pin is ignored.</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No action.\nNo interrupt at Px.n</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Clear the corresponding pending interrupt.\nPx.n generates an interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>INTSRC12</name>
              <description>Port A-f Pin[N] Interrupt Source Flag\nWrite Operation :\nNote2:\nThePA.7/PB.12/PC.4/PC.5/PC.12/PC.13/PD.0/PD.1/PD.2/PD.3/PD.4/PD.5/PD.8/PD.9/PD.10/PD.11/PD.12/PD.13/PE.0/PE.1/PE.2/PE.3/PE.4/PE.6/PE.7/PE.8/PE.9/PE.10/PE.11/PE.12/PE.13/PE.14/PE.15/PF.4/PF.5 pin is ignored.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No action.\nNo interrupt at Px.n</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Clear the corresponding pending interrupt.\nPx.n generates an interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>INTSRC13</name>
              <description>Port A-f Pin[N] Interrupt Source Flag\nWrite Operation :\nNote2:\nThePA.7/PB.12/PC.4/PC.5/PC.12/PC.13/PD.0/PD.1/PD.2/PD.3/PD.4/PD.5/PD.8/PD.9/PD.10/PD.11/PD.12/PD.13/PE.0/PE.1/PE.2/PE.3/PE.4/PE.6/PE.7/PE.8/PE.9/PE.10/PE.11/PE.12/PE.13/PE.14/PE.15/PF.4/PF.5 pin is ignored.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No action.\nNo interrupt at Px.n</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Clear the corresponding pending interrupt.\nPx.n generates an interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>INTSRC14</name>
              <description>Port A-f Pin[N] Interrupt Source Flag\nWrite Operation :\nNote2:\nThePA.7/PB.12/PC.4/PC.5/PC.12/PC.13/PD.0/PD.1/PD.2/PD.3/PD.4/PD.5/PD.8/PD.9/PD.10/PD.11/PD.12/PD.13/PE.0/PE.1/PE.2/PE.3/PE.4/PE.6/PE.7/PE.8/PE.9/PE.10/PE.11/PE.12/PE.13/PE.14/PE.15/PF.4/PF.5 pin is ignored.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No action.\nNo interrupt at Px.n</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Clear the corresponding pending interrupt.\nPx.n generates an interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>INTSRC15</name>
              <description>Port A-f Pin[N] Interrupt Source Flag\nWrite Operation :\nNote2:\nThePA.7/PB.12/PC.4/PC.5/PC.12/PC.13/PD.0/PD.1/PD.2/PD.3/PD.4/PD.5/PD.8/PD.9/PD.10/PD.11/PD.12/PD.13/PE.0/PE.1/PE.2/PE.3/PE.4/PE.6/PE.7/PE.8/PE.9/PE.10/PE.11/PE.12/PE.13/PE.14/PE.15/PF.4/PF.5 pin is ignored.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No action.\nNo interrupt at Px.n</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Clear the corresponding pending interrupt.\nPx.n generates an interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PA_PUEN</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PA_PUEN</displayName>
          <description>PA Pull-Up Enable Control Register</description>
          <addressOffset>0x24</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PUEN0</name>
              <description>Port A-f Pin[N]Pull-up Enable Bit\nRead :\nNote2:\nThePA.7/PB.12/PC.4/PC.5/PC.12/PC.13/PD.0/PD.1/PD.2/PD.3/PD.4/PD.5/PD.8/PD.9/PD.10/PD.11/PD.12/PD.13/PE.0/PE.1/PE.2/PE.3/PE.4/PE.6/PE.7/PE.8/PE.9/PE.10/PE.11/PE.12/PE.13/PE.14/PE.15/PF.4/PF.5 pin is ignored.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Px.n internal pull-up resistor Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Px.n internal pull-up resistor Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PUEN1</name>
              <description>Port A-f Pin[N]Pull-up Enable Bit\nRead :\nNote2:\nThePA.7/PB.12/PC.4/PC.5/PC.12/PC.13/PD.0/PD.1/PD.2/PD.3/PD.4/PD.5/PD.8/PD.9/PD.10/PD.11/PD.12/PD.13/PE.0/PE.1/PE.2/PE.3/PE.4/PE.6/PE.7/PE.8/PE.9/PE.10/PE.11/PE.12/PE.13/PE.14/PE.15/PF.4/PF.5 pin is ignored.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Px.n internal pull-up resistor Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Px.n internal pull-up resistor Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PUEN2</name>
              <description>Port A-f Pin[N]Pull-up Enable Bit\nRead :\nNote2:\nThePA.7/PB.12/PC.4/PC.5/PC.12/PC.13/PD.0/PD.1/PD.2/PD.3/PD.4/PD.5/PD.8/PD.9/PD.10/PD.11/PD.12/PD.13/PE.0/PE.1/PE.2/PE.3/PE.4/PE.6/PE.7/PE.8/PE.9/PE.10/PE.11/PE.12/PE.13/PE.14/PE.15/PF.4/PF.5 pin is ignored.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Px.n internal pull-up resistor Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Px.n internal pull-up resistor Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PUEN3</name>
              <description>Port A-f Pin[N]Pull-up Enable Bit\nRead :\nNote2:\nThePA.7/PB.12/PC.4/PC.5/PC.12/PC.13/PD.0/PD.1/PD.2/PD.3/PD.4/PD.5/PD.8/PD.9/PD.10/PD.11/PD.12/PD.13/PE.0/PE.1/PE.2/PE.3/PE.4/PE.6/PE.7/PE.8/PE.9/PE.10/PE.11/PE.12/PE.13/PE.14/PE.15/PF.4/PF.5 pin is ignored.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Px.n internal pull-up resistor Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Px.n internal pull-up resistor Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PUEN4</name>
              <description>Port A-f Pin[N]Pull-up Enable Bit\nRead :\nNote2:\nThePA.7/PB.12/PC.4/PC.5/PC.12/PC.13/PD.0/PD.1/PD.2/PD.3/PD.4/PD.5/PD.8/PD.9/PD.10/PD.11/PD.12/PD.13/PE.0/PE.1/PE.2/PE.3/PE.4/PE.6/PE.7/PE.8/PE.9/PE.10/PE.11/PE.12/PE.13/PE.14/PE.15/PF.4/PF.5 pin is ignored.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Px.n internal pull-up resistor Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Px.n internal pull-up resistor Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PUEN5</name>
              <description>Port A-f Pin[N]Pull-up Enable Bit\nRead :\nNote2:\nThePA.7/PB.12/PC.4/PC.5/PC.12/PC.13/PD.0/PD.1/PD.2/PD.3/PD.4/PD.5/PD.8/PD.9/PD.10/PD.11/PD.12/PD.13/PE.0/PE.1/PE.2/PE.3/PE.4/PE.6/PE.7/PE.8/PE.9/PE.10/PE.11/PE.12/PE.13/PE.14/PE.15/PF.4/PF.5 pin is ignored.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Px.n internal pull-up resistor Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Px.n internal pull-up resistor Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PUEN6</name>
              <description>Port A-f Pin[N]Pull-up Enable Bit\nRead :\nNote2:\nThePA.7/PB.12/PC.4/PC.5/PC.12/PC.13/PD.0/PD.1/PD.2/PD.3/PD.4/PD.5/PD.8/PD.9/PD.10/PD.11/PD.12/PD.13/PE.0/PE.1/PE.2/PE.3/PE.4/PE.6/PE.7/PE.8/PE.9/PE.10/PE.11/PE.12/PE.13/PE.14/PE.15/PF.4/PF.5 pin is ignored.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Px.n internal pull-up resistor Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Px.n internal pull-up resistor Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PUEN7</name>
              <description>Port A-f Pin[N]Pull-up Enable Bit\nRead :\nNote2:\nThePA.7/PB.12/PC.4/PC.5/PC.12/PC.13/PD.0/PD.1/PD.2/PD.3/PD.4/PD.5/PD.8/PD.9/PD.10/PD.11/PD.12/PD.13/PE.0/PE.1/PE.2/PE.3/PE.4/PE.6/PE.7/PE.8/PE.9/PE.10/PE.11/PE.12/PE.13/PE.14/PE.15/PF.4/PF.5 pin is ignored.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Px.n internal pull-up resistor Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Px.n internal pull-up resistor Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PUEN8</name>
              <description>Port A-f Pin[N]Pull-up Enable Bit\nRead :\nNote2:\nThePA.7/PB.12/PC.4/PC.5/PC.12/PC.13/PD.0/PD.1/PD.2/PD.3/PD.4/PD.5/PD.8/PD.9/PD.10/PD.11/PD.12/PD.13/PE.0/PE.1/PE.2/PE.3/PE.4/PE.6/PE.7/PE.8/PE.9/PE.10/PE.11/PE.12/PE.13/PE.14/PE.15/PF.4/PF.5 pin is ignored.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Px.n internal pull-up resistor Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Px.n internal pull-up resistor Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PUEN9</name>
              <description>Port A-f Pin[N]Pull-up Enable Bit\nRead :\nNote2:\nThePA.7/PB.12/PC.4/PC.5/PC.12/PC.13/PD.0/PD.1/PD.2/PD.3/PD.4/PD.5/PD.8/PD.9/PD.10/PD.11/PD.12/PD.13/PE.0/PE.1/PE.2/PE.3/PE.4/PE.6/PE.7/PE.8/PE.9/PE.10/PE.11/PE.12/PE.13/PE.14/PE.15/PF.4/PF.5 pin is ignored.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Px.n internal pull-up resistor Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Px.n internal pull-up resistor Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PUEN10</name>
              <description>Port A-f Pin[N]Pull-up Enable Bit\nRead :\nNote2:\nThePA.7/PB.12/PC.4/PC.5/PC.12/PC.13/PD.0/PD.1/PD.2/PD.3/PD.4/PD.5/PD.8/PD.9/PD.10/PD.11/PD.12/PD.13/PE.0/PE.1/PE.2/PE.3/PE.4/PE.6/PE.7/PE.8/PE.9/PE.10/PE.11/PE.12/PE.13/PE.14/PE.15/PF.4/PF.5 pin is ignored.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Px.n internal pull-up resistor Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Px.n internal pull-up resistor Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PUEN11</name>
              <description>Port A-f Pin[N]Pull-up Enable Bit\nRead :\nNote2:\nThePA.7/PB.12/PC.4/PC.5/PC.12/PC.13/PD.0/PD.1/PD.2/PD.3/PD.4/PD.5/PD.8/PD.9/PD.10/PD.11/PD.12/PD.13/PE.0/PE.1/PE.2/PE.3/PE.4/PE.6/PE.7/PE.8/PE.9/PE.10/PE.11/PE.12/PE.13/PE.14/PE.15/PF.4/PF.5 pin is ignored.</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Px.n internal pull-up resistor Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Px.n internal pull-up resistor Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PUEN12</name>
              <description>Port A-f Pin[N]Pull-up Enable Bit\nRead :\nNote2:\nThePA.7/PB.12/PC.4/PC.5/PC.12/PC.13/PD.0/PD.1/PD.2/PD.3/PD.4/PD.5/PD.8/PD.9/PD.10/PD.11/PD.12/PD.13/PE.0/PE.1/PE.2/PE.3/PE.4/PE.6/PE.7/PE.8/PE.9/PE.10/PE.11/PE.12/PE.13/PE.14/PE.15/PF.4/PF.5 pin is ignored.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Px.n internal pull-up resistor Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Px.n internal pull-up resistor Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PUEN13</name>
              <description>Port A-f Pin[N]Pull-up Enable Bit\nRead :\nNote2:\nThePA.7/PB.12/PC.4/PC.5/PC.12/PC.13/PD.0/PD.1/PD.2/PD.3/PD.4/PD.5/PD.8/PD.9/PD.10/PD.11/PD.12/PD.13/PE.0/PE.1/PE.2/PE.3/PE.4/PE.6/PE.7/PE.8/PE.9/PE.10/PE.11/PE.12/PE.13/PE.14/PE.15/PF.4/PF.5 pin is ignored.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Px.n internal pull-up resistor Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Px.n internal pull-up resistor Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PUEN14</name>
              <description>Port A-f Pin[N]Pull-up Enable Bit\nRead :\nNote2:\nThePA.7/PB.12/PC.4/PC.5/PC.12/PC.13/PD.0/PD.1/PD.2/PD.3/PD.4/PD.5/PD.8/PD.9/PD.10/PD.11/PD.12/PD.13/PE.0/PE.1/PE.2/PE.3/PE.4/PE.6/PE.7/PE.8/PE.9/PE.10/PE.11/PE.12/PE.13/PE.14/PE.15/PF.4/PF.5 pin is ignored.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Px.n internal pull-up resistor Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Px.n internal pull-up resistor Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PUEN15</name>
              <description>Port A-f Pin[N]Pull-up Enable Bit\nRead :\nNote2:\nThePA.7/PB.12/PC.4/PC.5/PC.12/PC.13/PD.0/PD.1/PD.2/PD.3/PD.4/PD.5/PD.8/PD.9/PD.10/PD.11/PD.12/PD.13/PE.0/PE.1/PE.2/PE.3/PE.4/PE.6/PE.7/PE.8/PE.9/PE.10/PE.11/PE.12/PE.13/PE.14/PE.15/PF.4/PF.5 pin is ignored.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Px.n internal pull-up resistor Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Px.n internal pull-up resistor Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PA_INTSTS</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PA_INTSTS</displayName>
          <description>PA Interrupt Status</description>
          <addressOffset>0x28</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>FLISTS0</name>
              <description>Port A-f Pin[N] Falling Edge Interrupt Status\nIf the interrupt is falling edge trigger for each of the corresponding input Px.n pin, this bit will be set after interrupt occurred and automatically cleared by interrupt source flag (INTSRC (Px_INTSRC[n])). \nNote2:\nThe PA.7/PB.12/PC.4/PC.5/PC.12/PC.13/PD.0/PD.1/PD.2/PD.3/PD.4/PD.5/PD.8/PD.9/PD.10/PD.11/PD.12/PD.13/PE.0/PE.1/PE.2/PE.3/PE.4/PE.6/PE.7/PE.8/PE.9/PE.10/PE.11/PE.12/PE.13/PE.14/PE.15/PF.4/PF.5 pin is ignored.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No falling edge interrupt at Px.n</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Px.n generates an falling edge interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>FLISTS1</name>
              <description>Port A-f Pin[N] Falling Edge Interrupt Status\nIf the interrupt is falling edge trigger for each of the corresponding input Px.n pin, this bit will be set after interrupt occurred and automatically cleared by interrupt source flag (INTSRC (Px_INTSRC[n])). \nNote2:\nThe PA.7/PB.12/PC.4/PC.5/PC.12/PC.13/PD.0/PD.1/PD.2/PD.3/PD.4/PD.5/PD.8/PD.9/PD.10/PD.11/PD.12/PD.13/PE.0/PE.1/PE.2/PE.3/PE.4/PE.6/PE.7/PE.8/PE.9/PE.10/PE.11/PE.12/PE.13/PE.14/PE.15/PF.4/PF.5 pin is ignored.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No falling edge interrupt at Px.n</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Px.n generates an falling edge interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>FLISTS2</name>
              <description>Port A-f Pin[N] Falling Edge Interrupt Status\nIf the interrupt is falling edge trigger for each of the corresponding input Px.n pin, this bit will be set after interrupt occurred and automatically cleared by interrupt source flag (INTSRC (Px_INTSRC[n])). \nNote2:\nThe PA.7/PB.12/PC.4/PC.5/PC.12/PC.13/PD.0/PD.1/PD.2/PD.3/PD.4/PD.5/PD.8/PD.9/PD.10/PD.11/PD.12/PD.13/PE.0/PE.1/PE.2/PE.3/PE.4/PE.6/PE.7/PE.8/PE.9/PE.10/PE.11/PE.12/PE.13/PE.14/PE.15/PF.4/PF.5 pin is ignored.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No falling edge interrupt at Px.n</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Px.n generates an falling edge interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>FLISTS3</name>
              <description>Port A-f Pin[N] Falling Edge Interrupt Status\nIf the interrupt is falling edge trigger for each of the corresponding input Px.n pin, this bit will be set after interrupt occurred and automatically cleared by interrupt source flag (INTSRC (Px_INTSRC[n])). \nNote2:\nThe PA.7/PB.12/PC.4/PC.5/PC.12/PC.13/PD.0/PD.1/PD.2/PD.3/PD.4/PD.5/PD.8/PD.9/PD.10/PD.11/PD.12/PD.13/PE.0/PE.1/PE.2/PE.3/PE.4/PE.6/PE.7/PE.8/PE.9/PE.10/PE.11/PE.12/PE.13/PE.14/PE.15/PF.4/PF.5 pin is ignored.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No falling edge interrupt at Px.n</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Px.n generates an falling edge interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>FLISTS4</name>
              <description>Port A-f Pin[N] Falling Edge Interrupt Status\nIf the interrupt is falling edge trigger for each of the corresponding input Px.n pin, this bit will be set after interrupt occurred and automatically cleared by interrupt source flag (INTSRC (Px_INTSRC[n])). \nNote2:\nThe PA.7/PB.12/PC.4/PC.5/PC.12/PC.13/PD.0/PD.1/PD.2/PD.3/PD.4/PD.5/PD.8/PD.9/PD.10/PD.11/PD.12/PD.13/PE.0/PE.1/PE.2/PE.3/PE.4/PE.6/PE.7/PE.8/PE.9/PE.10/PE.11/PE.12/PE.13/PE.14/PE.15/PF.4/PF.5 pin is ignored.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No falling edge interrupt at Px.n</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Px.n generates an falling edge interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>FLISTS5</name>
              <description>Port A-f Pin[N] Falling Edge Interrupt Status\nIf the interrupt is falling edge trigger for each of the corresponding input Px.n pin, this bit will be set after interrupt occurred and automatically cleared by interrupt source flag (INTSRC (Px_INTSRC[n])). \nNote2:\nThe PA.7/PB.12/PC.4/PC.5/PC.12/PC.13/PD.0/PD.1/PD.2/PD.3/PD.4/PD.5/PD.8/PD.9/PD.10/PD.11/PD.12/PD.13/PE.0/PE.1/PE.2/PE.3/PE.4/PE.6/PE.7/PE.8/PE.9/PE.10/PE.11/PE.12/PE.13/PE.14/PE.15/PF.4/PF.5 pin is ignored.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No falling edge interrupt at Px.n</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Px.n generates an falling edge interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>FLISTS6</name>
              <description>Port A-f Pin[N] Falling Edge Interrupt Status\nIf the interrupt is falling edge trigger for each of the corresponding input Px.n pin, this bit will be set after interrupt occurred and automatically cleared by interrupt source flag (INTSRC (Px_INTSRC[n])). \nNote2:\nThe PA.7/PB.12/PC.4/PC.5/PC.12/PC.13/PD.0/PD.1/PD.2/PD.3/PD.4/PD.5/PD.8/PD.9/PD.10/PD.11/PD.12/PD.13/PE.0/PE.1/PE.2/PE.3/PE.4/PE.6/PE.7/PE.8/PE.9/PE.10/PE.11/PE.12/PE.13/PE.14/PE.15/PF.4/PF.5 pin is ignored.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No falling edge interrupt at Px.n</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Px.n generates an falling edge interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>FLISTS7</name>
              <description>Port A-f Pin[N] Falling Edge Interrupt Status\nIf the interrupt is falling edge trigger for each of the corresponding input Px.n pin, this bit will be set after interrupt occurred and automatically cleared by interrupt source flag (INTSRC (Px_INTSRC[n])). \nNote2:\nThe PA.7/PB.12/PC.4/PC.5/PC.12/PC.13/PD.0/PD.1/PD.2/PD.3/PD.4/PD.5/PD.8/PD.9/PD.10/PD.11/PD.12/PD.13/PE.0/PE.1/PE.2/PE.3/PE.4/PE.6/PE.7/PE.8/PE.9/PE.10/PE.11/PE.12/PE.13/PE.14/PE.15/PF.4/PF.5 pin is ignored.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No falling edge interrupt at Px.n</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Px.n generates an falling edge interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>FLISTS8</name>
              <description>Port A-f Pin[N] Falling Edge Interrupt Status\nIf the interrupt is falling edge trigger for each of the corresponding input Px.n pin, this bit will be set after interrupt occurred and automatically cleared by interrupt source flag (INTSRC (Px_INTSRC[n])). \nNote2:\nThe PA.7/PB.12/PC.4/PC.5/PC.12/PC.13/PD.0/PD.1/PD.2/PD.3/PD.4/PD.5/PD.8/PD.9/PD.10/PD.11/PD.12/PD.13/PE.0/PE.1/PE.2/PE.3/PE.4/PE.6/PE.7/PE.8/PE.9/PE.10/PE.11/PE.12/PE.13/PE.14/PE.15/PF.4/PF.5 pin is ignored.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No falling edge interrupt at Px.n</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Px.n generates an falling edge interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>FLISTS9</name>
              <description>Port A-f Pin[N] Falling Edge Interrupt Status\nIf the interrupt is falling edge trigger for each of the corresponding input Px.n pin, this bit will be set after interrupt occurred and automatically cleared by interrupt source flag (INTSRC (Px_INTSRC[n])). \nNote2:\nThe PA.7/PB.12/PC.4/PC.5/PC.12/PC.13/PD.0/PD.1/PD.2/PD.3/PD.4/PD.5/PD.8/PD.9/PD.10/PD.11/PD.12/PD.13/PE.0/PE.1/PE.2/PE.3/PE.4/PE.6/PE.7/PE.8/PE.9/PE.10/PE.11/PE.12/PE.13/PE.14/PE.15/PF.4/PF.5 pin is ignored.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No falling edge interrupt at Px.n</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Px.n generates an falling edge interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>FLISTS10</name>
              <description>Port A-f Pin[N] Falling Edge Interrupt Status\nIf the interrupt is falling edge trigger for each of the corresponding input Px.n pin, this bit will be set after interrupt occurred and automatically cleared by interrupt source flag (INTSRC (Px_INTSRC[n])). \nNote2:\nThe PA.7/PB.12/PC.4/PC.5/PC.12/PC.13/PD.0/PD.1/PD.2/PD.3/PD.4/PD.5/PD.8/PD.9/PD.10/PD.11/PD.12/PD.13/PE.0/PE.1/PE.2/PE.3/PE.4/PE.6/PE.7/PE.8/PE.9/PE.10/PE.11/PE.12/PE.13/PE.14/PE.15/PF.4/PF.5 pin is ignored.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No falling edge interrupt at Px.n</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Px.n generates an falling edge interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>FLISTS11</name>
              <description>Port A-f Pin[N] Falling Edge Interrupt Status\nIf the interrupt is falling edge trigger for each of the corresponding input Px.n pin, this bit will be set after interrupt occurred and automatically cleared by interrupt source flag (INTSRC (Px_INTSRC[n])). \nNote2:\nThe PA.7/PB.12/PC.4/PC.5/PC.12/PC.13/PD.0/PD.1/PD.2/PD.3/PD.4/PD.5/PD.8/PD.9/PD.10/PD.11/PD.12/PD.13/PE.0/PE.1/PE.2/PE.3/PE.4/PE.6/PE.7/PE.8/PE.9/PE.10/PE.11/PE.12/PE.13/PE.14/PE.15/PF.4/PF.5 pin is ignored.</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No falling edge interrupt at Px.n</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Px.n generates an falling edge interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>FLISTS12</name>
              <description>Port A-f Pin[N] Falling Edge Interrupt Status\nIf the interrupt is falling edge trigger for each of the corresponding input Px.n pin, this bit will be set after interrupt occurred and automatically cleared by interrupt source flag (INTSRC (Px_INTSRC[n])). \nNote2:\nThe PA.7/PB.12/PC.4/PC.5/PC.12/PC.13/PD.0/PD.1/PD.2/PD.3/PD.4/PD.5/PD.8/PD.9/PD.10/PD.11/PD.12/PD.13/PE.0/PE.1/PE.2/PE.3/PE.4/PE.6/PE.7/PE.8/PE.9/PE.10/PE.11/PE.12/PE.13/PE.14/PE.15/PF.4/PF.5 pin is ignored.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No falling edge interrupt at Px.n</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Px.n generates an falling edge interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>FLISTS13</name>
              <description>Port A-f Pin[N] Falling Edge Interrupt Status\nIf the interrupt is falling edge trigger for each of the corresponding input Px.n pin, this bit will be set after interrupt occurred and automatically cleared by interrupt source flag (INTSRC (Px_INTSRC[n])). \nNote2:\nThe PA.7/PB.12/PC.4/PC.5/PC.12/PC.13/PD.0/PD.1/PD.2/PD.3/PD.4/PD.5/PD.8/PD.9/PD.10/PD.11/PD.12/PD.13/PE.0/PE.1/PE.2/PE.3/PE.4/PE.6/PE.7/PE.8/PE.9/PE.10/PE.11/PE.12/PE.13/PE.14/PE.15/PF.4/PF.5 pin is ignored.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No falling edge interrupt at Px.n</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Px.n generates an falling edge interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>FLISTS14</name>
              <description>Port A-f Pin[N] Falling Edge Interrupt Status\nIf the interrupt is falling edge trigger for each of the corresponding input Px.n pin, this bit will be set after interrupt occurred and automatically cleared by interrupt source flag (INTSRC (Px_INTSRC[n])). \nNote2:\nThe PA.7/PB.12/PC.4/PC.5/PC.12/PC.13/PD.0/PD.1/PD.2/PD.3/PD.4/PD.5/PD.8/PD.9/PD.10/PD.11/PD.12/PD.13/PE.0/PE.1/PE.2/PE.3/PE.4/PE.6/PE.7/PE.8/PE.9/PE.10/PE.11/PE.12/PE.13/PE.14/PE.15/PF.4/PF.5 pin is ignored.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No falling edge interrupt at Px.n</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Px.n generates an falling edge interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>FLISTS15</name>
              <description>Port A-f Pin[N] Falling Edge Interrupt Status\nIf the interrupt is falling edge trigger for each of the corresponding input Px.n pin, this bit will be set after interrupt occurred and automatically cleared by interrupt source flag (INTSRC (Px_INTSRC[n])). \nNote2:\nThe PA.7/PB.12/PC.4/PC.5/PC.12/PC.13/PD.0/PD.1/PD.2/PD.3/PD.4/PD.5/PD.8/PD.9/PD.10/PD.11/PD.12/PD.13/PE.0/PE.1/PE.2/PE.3/PE.4/PE.6/PE.7/PE.8/PE.9/PE.10/PE.11/PE.12/PE.13/PE.14/PE.15/PF.4/PF.5 pin is ignored.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No falling edge interrupt at Px.n</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Px.n generates an falling edge interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>RHISTS0</name>
              <description>Port A-f Pin[N] Rising Edge Interrupt Status \nIf the interrupt is rising edge trigger for each of the corresponding input Px.n pin, this bit will be set after interrupt occurred and automatically cleared by interrupt source flag (INTSRC (Px_INTSRC[n])). \nNote2:\nThe PA.7/PB.12/PC.4/PC.5/PC.12/PC.13/PD.0/PD.1/PD.2/PD.3/PD.4/PD.5/PD.8/PD.9/PD.10/PD.11/PD.12/PD.13/PE.0/PE.1/PE.2/PE.3/PE.4/PE.6/PE.7/PE.8/PE.9/PE.10/PE.11/PE.12/PE.13/PE.14/PE.15/PF.4/PF.5 pin is ignored.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No rising edge interrupt at Px.n</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Px.n generates an rising edge interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>RHISTS1</name>
              <description>Port A-f Pin[N] Rising Edge Interrupt Status \nIf the interrupt is rising edge trigger for each of the corresponding input Px.n pin, this bit will be set after interrupt occurred and automatically cleared by interrupt source flag (INTSRC (Px_INTSRC[n])). \nNote2:\nThe PA.7/PB.12/PC.4/PC.5/PC.12/PC.13/PD.0/PD.1/PD.2/PD.3/PD.4/PD.5/PD.8/PD.9/PD.10/PD.11/PD.12/PD.13/PE.0/PE.1/PE.2/PE.3/PE.4/PE.6/PE.7/PE.8/PE.9/PE.10/PE.11/PE.12/PE.13/PE.14/PE.15/PF.4/PF.5 pin is ignored.</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No rising edge interrupt at Px.n</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Px.n generates an rising edge interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>RHISTS2</name>
              <description>Port A-f Pin[N] Rising Edge Interrupt Status \nIf the interrupt is rising edge trigger for each of the corresponding input Px.n pin, this bit will be set after interrupt occurred and automatically cleared by interrupt source flag (INTSRC (Px_INTSRC[n])). \nNote2:\nThe PA.7/PB.12/PC.4/PC.5/PC.12/PC.13/PD.0/PD.1/PD.2/PD.3/PD.4/PD.5/PD.8/PD.9/PD.10/PD.11/PD.12/PD.13/PE.0/PE.1/PE.2/PE.3/PE.4/PE.6/PE.7/PE.8/PE.9/PE.10/PE.11/PE.12/PE.13/PE.14/PE.15/PF.4/PF.5 pin is ignored.</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No rising edge interrupt at Px.n</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Px.n generates an rising edge interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>RHISTS3</name>
              <description>Port A-f Pin[N] Rising Edge Interrupt Status \nIf the interrupt is rising edge trigger for each of the corresponding input Px.n pin, this bit will be set after interrupt occurred and automatically cleared by interrupt source flag (INTSRC (Px_INTSRC[n])). \nNote2:\nThe PA.7/PB.12/PC.4/PC.5/PC.12/PC.13/PD.0/PD.1/PD.2/PD.3/PD.4/PD.5/PD.8/PD.9/PD.10/PD.11/PD.12/PD.13/PE.0/PE.1/PE.2/PE.3/PE.4/PE.6/PE.7/PE.8/PE.9/PE.10/PE.11/PE.12/PE.13/PE.14/PE.15/PF.4/PF.5 pin is ignored.</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No rising edge interrupt at Px.n</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Px.n generates an rising edge interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>RHISTS4</name>
              <description>Port A-f Pin[N] Rising Edge Interrupt Status \nIf the interrupt is rising edge trigger for each of the corresponding input Px.n pin, this bit will be set after interrupt occurred and automatically cleared by interrupt source flag (INTSRC (Px_INTSRC[n])). \nNote2:\nThe PA.7/PB.12/PC.4/PC.5/PC.12/PC.13/PD.0/PD.1/PD.2/PD.3/PD.4/PD.5/PD.8/PD.9/PD.10/PD.11/PD.12/PD.13/PE.0/PE.1/PE.2/PE.3/PE.4/PE.6/PE.7/PE.8/PE.9/PE.10/PE.11/PE.12/PE.13/PE.14/PE.15/PF.4/PF.5 pin is ignored.</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No rising edge interrupt at Px.n</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Px.n generates an rising edge interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>RHISTS5</name>
              <description>Port A-f Pin[N] Rising Edge Interrupt Status \nIf the interrupt is rising edge trigger for each of the corresponding input Px.n pin, this bit will be set after interrupt occurred and automatically cleared by interrupt source flag (INTSRC (Px_INTSRC[n])). \nNote2:\nThe PA.7/PB.12/PC.4/PC.5/PC.12/PC.13/PD.0/PD.1/PD.2/PD.3/PD.4/PD.5/PD.8/PD.9/PD.10/PD.11/PD.12/PD.13/PE.0/PE.1/PE.2/PE.3/PE.4/PE.6/PE.7/PE.8/PE.9/PE.10/PE.11/PE.12/PE.13/PE.14/PE.15/PF.4/PF.5 pin is ignored.</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No rising edge interrupt at Px.n</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Px.n generates an rising edge interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>RHISTS6</name>
              <description>Port A-f Pin[N] Rising Edge Interrupt Status \nIf the interrupt is rising edge trigger for each of the corresponding input Px.n pin, this bit will be set after interrupt occurred and automatically cleared by interrupt source flag (INTSRC (Px_INTSRC[n])). \nNote2:\nThe PA.7/PB.12/PC.4/PC.5/PC.12/PC.13/PD.0/PD.1/PD.2/PD.3/PD.4/PD.5/PD.8/PD.9/PD.10/PD.11/PD.12/PD.13/PE.0/PE.1/PE.2/PE.3/PE.4/PE.6/PE.7/PE.8/PE.9/PE.10/PE.11/PE.12/PE.13/PE.14/PE.15/PF.4/PF.5 pin is ignored.</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No rising edge interrupt at Px.n</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Px.n generates an rising edge interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>RHISTS7</name>
              <description>Port A-f Pin[N] Rising Edge Interrupt Status \nIf the interrupt is rising edge trigger for each of the corresponding input Px.n pin, this bit will be set after interrupt occurred and automatically cleared by interrupt source flag (INTSRC (Px_INTSRC[n])). \nNote2:\nThe PA.7/PB.12/PC.4/PC.5/PC.12/PC.13/PD.0/PD.1/PD.2/PD.3/PD.4/PD.5/PD.8/PD.9/PD.10/PD.11/PD.12/PD.13/PE.0/PE.1/PE.2/PE.3/PE.4/PE.6/PE.7/PE.8/PE.9/PE.10/PE.11/PE.12/PE.13/PE.14/PE.15/PF.4/PF.5 pin is ignored.</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No rising edge interrupt at Px.n</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Px.n generates an rising edge interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>RHISTS8</name>
              <description>Port A-f Pin[N] Rising Edge Interrupt Status \nIf the interrupt is rising edge trigger for each of the corresponding input Px.n pin, this bit will be set after interrupt occurred and automatically cleared by interrupt source flag (INTSRC (Px_INTSRC[n])). \nNote2:\nThe PA.7/PB.12/PC.4/PC.5/PC.12/PC.13/PD.0/PD.1/PD.2/PD.3/PD.4/PD.5/PD.8/PD.9/PD.10/PD.11/PD.12/PD.13/PE.0/PE.1/PE.2/PE.3/PE.4/PE.6/PE.7/PE.8/PE.9/PE.10/PE.11/PE.12/PE.13/PE.14/PE.15/PF.4/PF.5 pin is ignored.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No rising edge interrupt at Px.n</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Px.n generates an rising edge interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>RHISTS9</name>
              <description>Port A-f Pin[N] Rising Edge Interrupt Status \nIf the interrupt is rising edge trigger for each of the corresponding input Px.n pin, this bit will be set after interrupt occurred and automatically cleared by interrupt source flag (INTSRC (Px_INTSRC[n])). \nNote2:\nThe PA.7/PB.12/PC.4/PC.5/PC.12/PC.13/PD.0/PD.1/PD.2/PD.3/PD.4/PD.5/PD.8/PD.9/PD.10/PD.11/PD.12/PD.13/PE.0/PE.1/PE.2/PE.3/PE.4/PE.6/PE.7/PE.8/PE.9/PE.10/PE.11/PE.12/PE.13/PE.14/PE.15/PF.4/PF.5 pin is ignored.</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No rising edge interrupt at Px.n</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Px.n generates an rising edge interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>RHISTS10</name>
              <description>Port A-f Pin[N] Rising Edge Interrupt Status \nIf the interrupt is rising edge trigger for each of the corresponding input Px.n pin, this bit will be set after interrupt occurred and automatically cleared by interrupt source flag (INTSRC (Px_INTSRC[n])). \nNote2:\nThe PA.7/PB.12/PC.4/PC.5/PC.12/PC.13/PD.0/PD.1/PD.2/PD.3/PD.4/PD.5/PD.8/PD.9/PD.10/PD.11/PD.12/PD.13/PE.0/PE.1/PE.2/PE.3/PE.4/PE.6/PE.7/PE.8/PE.9/PE.10/PE.11/PE.12/PE.13/PE.14/PE.15/PF.4/PF.5 pin is ignored.</description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No rising edge interrupt at Px.n</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Px.n generates an rising edge interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>RHISTS11</name>
              <description>Port A-f Pin[N] Rising Edge Interrupt Status \nIf the interrupt is rising edge trigger for each of the corresponding input Px.n pin, this bit will be set after interrupt occurred and automatically cleared by interrupt source flag (INTSRC (Px_INTSRC[n])). \nNote2:\nThe PA.7/PB.12/PC.4/PC.5/PC.12/PC.13/PD.0/PD.1/PD.2/PD.3/PD.4/PD.5/PD.8/PD.9/PD.10/PD.11/PD.12/PD.13/PE.0/PE.1/PE.2/PE.3/PE.4/PE.6/PE.7/PE.8/PE.9/PE.10/PE.11/PE.12/PE.13/PE.14/PE.15/PF.4/PF.5 pin is ignored.</description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No rising edge interrupt at Px.n</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Px.n generates an rising edge interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>RHISTS12</name>
              <description>Port A-f Pin[N] Rising Edge Interrupt Status \nIf the interrupt is rising edge trigger for each of the corresponding input Px.n pin, this bit will be set after interrupt occurred and automatically cleared by interrupt source flag (INTSRC (Px_INTSRC[n])). \nNote2:\nThe PA.7/PB.12/PC.4/PC.5/PC.12/PC.13/PD.0/PD.1/PD.2/PD.3/PD.4/PD.5/PD.8/PD.9/PD.10/PD.11/PD.12/PD.13/PE.0/PE.1/PE.2/PE.3/PE.4/PE.6/PE.7/PE.8/PE.9/PE.10/PE.11/PE.12/PE.13/PE.14/PE.15/PF.4/PF.5 pin is ignored.</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No rising edge interrupt at Px.n</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Px.n generates an rising edge interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>RHISTS13</name>
              <description>Port A-f Pin[N] Rising Edge Interrupt Status \nIf the interrupt is rising edge trigger for each of the corresponding input Px.n pin, this bit will be set after interrupt occurred and automatically cleared by interrupt source flag (INTSRC (Px_INTSRC[n])). \nNote2:\nThe PA.7/PB.12/PC.4/PC.5/PC.12/PC.13/PD.0/PD.1/PD.2/PD.3/PD.4/PD.5/PD.8/PD.9/PD.10/PD.11/PD.12/PD.13/PE.0/PE.1/PE.2/PE.3/PE.4/PE.6/PE.7/PE.8/PE.9/PE.10/PE.11/PE.12/PE.13/PE.14/PE.15/PF.4/PF.5 pin is ignored.</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No rising edge interrupt at Px.n</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Px.n generates an rising edge interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>RHISTS14</name>
              <description>Port A-f Pin[N] Rising Edge Interrupt Status \nIf the interrupt is rising edge trigger for each of the corresponding input Px.n pin, this bit will be set after interrupt occurred and automatically cleared by interrupt source flag (INTSRC (Px_INTSRC[n])). \nNote2:\nThe PA.7/PB.12/PC.4/PC.5/PC.12/PC.13/PD.0/PD.1/PD.2/PD.3/PD.4/PD.5/PD.8/PD.9/PD.10/PD.11/PD.12/PD.13/PE.0/PE.1/PE.2/PE.3/PE.4/PE.6/PE.7/PE.8/PE.9/PE.10/PE.11/PE.12/PE.13/PE.14/PE.15/PF.4/PF.5 pin is ignored.</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No rising edge interrupt at Px.n</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Px.n generates an rising edge interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>RHISTS15</name>
              <description>Port A-f Pin[N] Rising Edge Interrupt Status \nIf the interrupt is rising edge trigger for each of the corresponding input Px.n pin, this bit will be set after interrupt occurred and automatically cleared by interrupt source flag (INTSRC (Px_INTSRC[n])). \nNote2:\nThe PA.7/PB.12/PC.4/PC.5/PC.12/PC.13/PD.0/PD.1/PD.2/PD.3/PD.4/PD.5/PD.8/PD.9/PD.10/PD.11/PD.12/PD.13/PE.0/PE.1/PE.2/PE.3/PE.4/PE.6/PE.7/PE.8/PE.9/PE.10/PE.11/PE.12/PE.13/PE.14/PE.15/PF.4/PF.5 pin is ignored.</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No rising edge interrupt at Px.n</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Px.n generates an rising edge interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PA_MODE">
          <name>PB_MODE</name>
          <displayName>PB_MODE</displayName>
          <description>PB I/O Mode Control</description>
          <addressOffset>0x40</addressOffset>
       </register>
       <register derivedFrom="PA_DINOFF">
          <name>PB_DINOFF</name>
          <displayName>PB_DINOFF</displayName>
          <description>PB Digital Input Path Disable Control</description>
          <addressOffset>0x44</addressOffset>
       </register>
       <register derivedFrom="PA_DOUT">
          <name>PB_DOUT</name>
          <displayName>PB_DOUT</displayName>
          <description>PB Data Output Value</description>
          <addressOffset>0x48</addressOffset>
       </register>
       <register derivedFrom="PA_DATMSK">
          <name>PB_DATMSK</name>
          <displayName>PB_DATMSK</displayName>
          <description>PB Data Output Write Mask</description>
          <addressOffset>0x4C</addressOffset>
       </register>
       <register derivedFrom="PA_PIN">
          <name>PB_PIN</name>
          <displayName>PB_PIN</displayName>
          <description>PB Pin Value</description>
          <addressOffset>0x50</addressOffset>
       </register>
       <register derivedFrom="PA_DBEN">
          <name>PB_DBEN</name>
          <displayName>PB_DBEN</displayName>
          <description>PB De-Bounce Enable Control Register</description>
          <addressOffset>0x54</addressOffset>
       </register>
       <register derivedFrom="PA_INTTYPE">
          <name>PB_INTTYPE</name>
          <displayName>PB_INTTYPE</displayName>
          <description>PB Interrupt Trigger Type Control</description>
          <addressOffset>0x58</addressOffset>
       </register>
       <register derivedFrom="PA_INTEN">
          <name>PB_INTEN</name>
          <displayName>PB_INTEN</displayName>
          <description>PB Interrupt Enable Control Register</description>
          <addressOffset>0x5C</addressOffset>
       </register>
       <register derivedFrom="PA_INTSRC">
          <name>PB_INTSRC</name>
          <displayName>PB_INTSRC</displayName>
          <description>PB Interrupt Source Flag</description>
          <addressOffset>0x60</addressOffset>
       </register>
       <register derivedFrom="PA_PUEN">
          <name>PB_PUEN</name>
          <displayName>PB_PUEN</displayName>
          <description>PB Pull-Up Enable Control Register</description>
          <addressOffset>0x64</addressOffset>
       </register>
       <register derivedFrom="PA_INTSTS">
          <name>PB_INTSTS</name>
          <displayName>PB_INTSTS</displayName>
          <description>PB Interrupt Status</description>
          <addressOffset>0x68</addressOffset>
       </register>
       <register derivedFrom="PA_MODE">
          <name>PC_MODE</name>
          <displayName>PC_MODE</displayName>
          <description>PC I/O Mode Control</description>
          <addressOffset>0x80</addressOffset>
       </register>
       <register derivedFrom="PA_DINOFF">
          <name>PC_DINOFF</name>
          <displayName>PC_DINOFF</displayName>
          <description>PC Digital Input Path Disable Control</description>
          <addressOffset>0x84</addressOffset>
       </register>
       <register derivedFrom="PA_DOUT">
          <name>PC_DOUT</name>
          <displayName>PC_DOUT</displayName>
          <description>PC Data Output Value</description>
          <addressOffset>0x88</addressOffset>
       </register>
       <register derivedFrom="PA_DATMSK">
          <name>PC_DATMSK</name>
          <displayName>PC_DATMSK</displayName>
          <description>PC Data Output Write Mask</description>
          <addressOffset>0x8C</addressOffset>
       </register>
       <register derivedFrom="PA_PIN">
          <name>PC_PIN</name>
          <displayName>PC_PIN</displayName>
          <description>PC Pin Value</description>
          <addressOffset>0x90</addressOffset>
       </register>
       <register derivedFrom="PA_DBEN">
          <name>PC_DBEN</name>
          <displayName>PC_DBEN</displayName>
          <description>PC De-Bounce Enable Control Register</description>
          <addressOffset>0x94</addressOffset>
       </register>
       <register derivedFrom="PA_INTTYPE">
          <name>PC_INTTYPE</name>
          <displayName>PC_INTTYPE</displayName>
          <description>PC Interrupt Trigger Type Control</description>
          <addressOffset>0x98</addressOffset>
       </register>
       <register derivedFrom="PA_INTEN">
          <name>PC_INTEN</name>
          <displayName>PC_INTEN</displayName>
          <description>PC Interrupt Enable Control Register</description>
          <addressOffset>0x9C</addressOffset>
       </register>
       <register derivedFrom="PA_INTSRC">
          <name>PC_INTSRC</name>
          <displayName>PC_INTSRC</displayName>
          <description>PC Interrupt Source Flag</description>
          <addressOffset>0xA0</addressOffset>
       </register>
       <register derivedFrom="PA_PUEN">
          <name>PC_PUEN</name>
          <displayName>PC_PUEN</displayName>
          <description>PC Pull-Up Enable Control Register</description>
          <addressOffset>0xA4</addressOffset>
       </register>
       <register derivedFrom="PA_INTSTS">
          <name>PC_INTSTS</name>
          <displayName>PC_INTSTS</displayName>
          <description>PC Interrupt Status</description>
          <addressOffset>0xA8</addressOffset>
       </register>
       <register derivedFrom="PA_MODE">
          <name>PD_MODE</name>
          <displayName>PD_MODE</displayName>
          <description>PD I/O Mode Control</description>
          <addressOffset>0xC0</addressOffset>
       </register>
       <register derivedFrom="PA_DINOFF">
          <name>PD_DINOFF</name>
          <displayName>PD_DINOFF</displayName>
          <description>PD Digital Input Path Disable Control</description>
          <addressOffset>0xC4</addressOffset>
       </register>
       <register derivedFrom="PA_DOUT">
          <name>PD_DOUT</name>
          <displayName>PD_DOUT</displayName>
          <description>PD Data Output Value</description>
          <addressOffset>0xC8</addressOffset>
       </register>
       <register derivedFrom="PA_DATMSK">
          <name>PD_DATMSK</name>
          <displayName>PD_DATMSK</displayName>
          <description>PD Data Output Write Mask</description>
          <addressOffset>0xCC</addressOffset>
       </register>
       <register derivedFrom="PA_PIN">
          <name>PD_PIN</name>
          <displayName>PD_PIN</displayName>
          <description>PD Pin Value</description>
          <addressOffset>0xD0</addressOffset>
       </register>
       <register derivedFrom="PA_DBEN">
          <name>PD_DBEN</name>
          <displayName>PD_DBEN</displayName>
          <description>PD De-Bounce Enable Control Register</description>
          <addressOffset>0xD4</addressOffset>
       </register>
       <register derivedFrom="PA_INTTYPE">
          <name>PD_INTTYPE</name>
          <displayName>PD_INTTYPE</displayName>
          <description>PD Interrupt Trigger Type Control</description>
          <addressOffset>0xD8</addressOffset>
       </register>
       <register derivedFrom="PA_INTEN">
          <name>PD_INTEN</name>
          <displayName>PD_INTEN</displayName>
          <description>PD Interrupt Enable Control Register</description>
          <addressOffset>0xDC</addressOffset>
       </register>
       <register derivedFrom="PA_INTSRC">
          <name>PD_INTSRC</name>
          <displayName>PD_INTSRC</displayName>
          <description>PD Interrupt Source Flag</description>
          <addressOffset>0xE0</addressOffset>
       </register>
       <register derivedFrom="PA_PUEN">
          <name>PD_PUEN</name>
          <displayName>PD_PUEN</displayName>
          <description>PD Pull-Up Enable Control Register</description>
          <addressOffset>0xE4</addressOffset>
       </register>
       <register derivedFrom="PA_INTSTS">
          <name>PD_INTSTS</name>
          <displayName>PD_INTSTS</displayName>
          <description>PD Interrupt Status</description>
          <addressOffset>0xE8</addressOffset>
       </register>
       <register derivedFrom="PA_MODE">
          <name>PE_MODE</name>
          <displayName>PE_MODE</displayName>
          <description>PE I/O Mode Control</description>
          <addressOffset>0x100</addressOffset>
       </register>
       <register derivedFrom="PA_DINOFF">
          <name>PE_DINOFF</name>
          <displayName>PE_DINOFF</displayName>
          <description>PE Digital Input Path Disable Control</description>
          <addressOffset>0x104</addressOffset>
       </register>
       <register derivedFrom="PA_DOUT">
          <name>PE_DOUT</name>
          <displayName>PE_DOUT</displayName>
          <description>PE Data Output Value</description>
          <addressOffset>0x108</addressOffset>
       </register>
       <register derivedFrom="PA_DATMSK">
          <name>PE_DATMSK</name>
          <displayName>PE_DATMSK</displayName>
          <description>PE Data Output Write Mask</description>
          <addressOffset>0x10C</addressOffset>
       </register>
       <register derivedFrom="PA_PIN">
          <name>PE_PIN</name>
          <displayName>PE_PIN</displayName>
          <description>PE Pin Value</description>
          <addressOffset>0x110</addressOffset>
       </register>
       <register derivedFrom="PA_DBEN">
          <name>PE_DBEN</name>
          <displayName>PE_DBEN</displayName>
          <description>PE De-Bounce Enable Control Register</description>
          <addressOffset>0x114</addressOffset>
       </register>
       <register derivedFrom="PA_INTTYPE">
          <name>PE_INTTYPE</name>
          <displayName>PE_INTTYPE</displayName>
          <description>PE Interrupt Trigger Type Control</description>
          <addressOffset>0x118</addressOffset>
       </register>
       <register derivedFrom="PA_INTEN">
          <name>PE_INTEN</name>
          <displayName>PE_INTEN</displayName>
          <description>PE Interrupt Enable Control Register</description>
          <addressOffset>0x11C</addressOffset>
       </register>
       <register derivedFrom="PA_INTSRC">
          <name>PE_INTSRC</name>
          <displayName>PE_INTSRC</displayName>
          <description>PE Interrupt Source Flag</description>
          <addressOffset>0x120</addressOffset>
       </register>
       <register derivedFrom="PA_PUEN">
          <name>PE_PUEN</name>
          <displayName>PE_PUEN</displayName>
          <description>PE Pull-Up Enable Control Register</description>
          <addressOffset>0x124</addressOffset>
       </register>
       <register derivedFrom="PA_INTSTS">
          <name>PE_INTSTS</name>
          <displayName>PE_INTSTS</displayName>
          <description>PE Interrupt Status</description>
          <addressOffset>0x128</addressOffset>
       </register>
       <register derivedFrom="PA_MODE">
          <name>PF_MODE</name>
          <displayName>PF_MODE</displayName>
          <description>PF I/O Mode Control</description>
          <addressOffset>0x140</addressOffset>
       </register>
       <register derivedFrom="PA_DINOFF">
          <name>PF_DINOFF</name>
          <displayName>PF_DINOFF</displayName>
          <description>PF Digital Input Path Disable Control</description>
          <addressOffset>0x144</addressOffset>
       </register>
       <register derivedFrom="PA_DOUT">
          <name>PF_DOUT</name>
          <displayName>PF_DOUT</displayName>
          <description>PF Data Output Value</description>
          <addressOffset>0x148</addressOffset>
       </register>
       <register derivedFrom="PA_DATMSK">
          <name>PF_DATMSK</name>
          <displayName>PF_DATMSK</displayName>
          <description>PF Data Output Write Mask</description>
          <addressOffset>0x14C</addressOffset>
       </register>
       <register derivedFrom="PA_PIN">
          <name>PF_PIN</name>
          <displayName>PF_PIN</displayName>
          <description>PF Pin Value</description>
          <addressOffset>0x150</addressOffset>
       </register>
       <register derivedFrom="PA_DBEN">
          <name>PF_DBEN</name>
          <displayName>PF_DBEN</displayName>
          <description>PF De-Bounce Enable Control Register</description>
          <addressOffset>0x154</addressOffset>
       </register>
       <register derivedFrom="PA_INTTYPE">
          <name>PF_INTTYPE</name>
          <displayName>PF_INTTYPE</displayName>
          <description>PF Interrupt Trigger Type Control</description>
          <addressOffset>0x158</addressOffset>
       </register>
       <register derivedFrom="PA_INTEN">
          <name>PF_INTEN</name>
          <displayName>PF_INTEN</displayName>
          <description>PF Interrupt Enable Control Register</description>
          <addressOffset>0x15C</addressOffset>
       </register>
       <register derivedFrom="PA_INTSRC">
          <name>PF_INTSRC</name>
          <displayName>PF_INTSRC</displayName>
          <description>PF Interrupt Source Flag</description>
          <addressOffset>0x160</addressOffset>
       </register>
       <register derivedFrom="PA_PUEN">
          <name>PF_PUEN</name>
          <displayName>PF_PUEN</displayName>
          <description>PF Pull-Up Enable Control Register</description>
          <addressOffset>0x164</addressOffset>
       </register>
       <register derivedFrom="PA_INTSTS">
          <name>PF_INTSTS</name>
          <displayName>PF_INTSTS</displayName>
          <description>PF Interrupt Status</description>
          <addressOffset>0x168</addressOffset>
       </register>
       <register>
          <name>GPIO_DBCTL</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>GPIO_DBCTL</displayName>
          <description>Interrupt De-bounce Control Register</description>
          <addressOffset>0x180</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DBCLKSEL</name>
              <description>De-bounce Sampling Cycle Selection</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Sample interrupt input once per 1 clocks</description>
                    <value>#0000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Sample interrupt input once per 2 clocks</description>
                    <value>#0001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Sample interrupt input once per 4 clocks</description>
                    <value>#0010</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Sample interrupt input once per 8 clocks</description>
                    <value>#0011</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>4</name>
                    <description>Sample interrupt input once per 16 clocks</description>
                    <value>#0100</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>5</name>
                    <description>Sample interrupt input once per 32 clocks</description>
                    <value>#0101</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>6</name>
                    <description>Sample interrupt input once per 64 clocks</description>
                    <value>#0110</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>7</name>
                    <description>Sample interrupt input once per 128 clocks</description>
                    <value>#0111</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>8</name>
                    <description>Sample interrupt input once per 256 clocks</description>
                    <value>#1000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>9</name>
                    <description>Sample interrupt input once per 2*256 clocks</description>
                    <value>#1001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>10</name>
                    <description>Sample interrupt input once per 4*256 clocks</description>
                    <value>#1010</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>11</name>
                    <description>Sample interrupt input once per 8*256 clocks</description>
                    <value>#1011</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>12</name>
                    <description>Sample interrupt input once per 16*256 clocks</description>
                    <value>#1100</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>13</name>
                    <description>Sample interrupt input once per 32*256 clocks</description>
                    <value>#1101</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>14</name>
                    <description>Sample interrupt input once per 64*256 clocks</description>
                    <value>#1110</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>15</name>
                    <description>Sample interrupt input once per 128*256 clocks</description>
                    <value>#1111</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DBCLKSRC</name>
              <description>De-bounce Counter Clock Source Selection</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>De-bounce counter clock source is the HCLK</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>De-bounce counter clock source is the 10 kHz internal low speed RC oscillator (LIRC)</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ICLKON</name>
              <description>Interrupt Clock on Mode\nNote:It is recommended to disable this bit to save system power if no special application concern.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Edge detection circuit is active only if I/O pin corresponding RHIEN (Px_INTEN[n+16])/FLIEN (Px_INTEN[n]) bit is set to 1</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>All I/O pins edge detection circuit is always active after reset</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PA0_PDIO</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PA0_PDIO</displayName>
          <description>GPIO PA.0 Pin Data Input/Output Register</description>
          <addressOffset>0x200</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFF0</resetMask>
          <fields>
            <field>
              <name>PDIO</name>
              <description>GPIO Px.N Pin Data Input/Output\nWriting this bit can control one GPIO pin output value.\nNote3:\nThePA.7/PB.12/PC.4/PC.5/PC.12/PC.13/PD.0/PD.1/PD.2/PD.3/PD.4/PD.5/PD.8/PD.9/PD.10/PD.11/PD.12/PD.13/PE.0/PE.1/PE.2/PE.3/PE.4/PE.6/PE.7/PE.8/PE.9/PE.10/PE.11/PE.12/PE.13/PE.14/PE.15/PF.4/PF.5 pin is ignored.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Corresponding GPIO pin set to low</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Corresponding GPIO pin set to high</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PA0_PDIO">
          <name>PA1_PDIO</name>
          <displayName>PA1_PDIO</displayName>
          <description>GPIO PA.1 Pin Data Input/Output Register</description>
          <addressOffset>0x204</addressOffset>
       </register>
       <register derivedFrom="PA0_PDIO">
          <name>PA2_PDIO</name>
          <displayName>PA2_PDIO</displayName>
          <description>GPIO PA.2 Pin Data Input/Output Register</description>
          <addressOffset>0x208</addressOffset>
       </register>
       <register derivedFrom="PA0_PDIO">
          <name>PA3_PDIO</name>
          <displayName>PA3_PDIO</displayName>
          <description>GPIO PA.3 Pin Data Input/Output Register</description>
          <addressOffset>0x20C</addressOffset>
       </register>
       <register derivedFrom="PA0_PDIO">
          <name>PA4_PDIO</name>
          <displayName>PA4_PDIO</displayName>
          <description>GPIO PA.4 Pin Data Input/Output Register</description>
          <addressOffset>0x210</addressOffset>
       </register>
       <register derivedFrom="PA0_PDIO">
          <name>PA5_PDIO</name>
          <displayName>PA5_PDIO</displayName>
          <description>GPIO PA.5 Pin Data Input/Output Register</description>
          <addressOffset>0x214</addressOffset>
       </register>
       <register derivedFrom="PA0_PDIO">
          <name>PA6_PDIO</name>
          <displayName>PA6_PDIO</displayName>
          <description>GPIO PA.6 Pin Data Input/Output Register</description>
          <addressOffset>0x218</addressOffset>
       </register>
       <register derivedFrom="PA0_PDIO">
          <name>PA7_PDIO</name>
          <displayName>PA7_PDIO</displayName>
          <description>GPIO PA.7 Pin Data Input/Output Register</description>
          <addressOffset>0x21C</addressOffset>
       </register>
       <register derivedFrom="PA0_PDIO">
          <name>PA8_PDIO</name>
          <displayName>PA8_PDIO</displayName>
          <description>GPIO PA.8 Pin Data Input/Output Register</description>
          <addressOffset>0x220</addressOffset>
       </register>
       <register derivedFrom="PA0_PDIO">
          <name>PA9_PDIO</name>
          <displayName>PA9_PDIO</displayName>
          <description>GPIO PA.9 Pin Data Input/Output Register</description>
          <addressOffset>0x224</addressOffset>
       </register>
       <register derivedFrom="PA0_PDIO">
          <name>PA10_PDIO</name>
          <displayName>PA10_PDIO</displayName>
          <description>GPIO PA.10 Pin Data Input/Output Register</description>
          <addressOffset>0x228</addressOffset>
       </register>
       <register derivedFrom="PA0_PDIO">
          <name>PA11_PDIO</name>
          <displayName>PA11_PDIO</displayName>
          <description>GPIO PA.11 Pin Data Input/Output Register</description>
          <addressOffset>0x22C</addressOffset>
       </register>
       <register derivedFrom="PA0_PDIO">
          <name>PA12_PDIO</name>
          <displayName>PA12_PDIO</displayName>
          <description>GPIO PA.12 Pin Data Input/Output Register</description>
          <addressOffset>0x230</addressOffset>
       </register>
       <register derivedFrom="PA0_PDIO">
          <name>PA13_PDIO</name>
          <displayName>PA13_PDIO</displayName>
          <description>GPIO PA.13 Pin Data Input/Output Register</description>
          <addressOffset>0x234</addressOffset>
       </register>
       <register derivedFrom="PA0_PDIO">
          <name>PA14_PDIO</name>
          <displayName>PA14_PDIO</displayName>
          <description>GPIO PA.14 Pin Data Input/Output Register</description>
          <addressOffset>0x238</addressOffset>
       </register>
       <register derivedFrom="PA0_PDIO">
          <name>PA15_PDIO</name>
          <displayName>PA15_PDIO</displayName>
          <description>GPIO PA.15 Pin Data Input/Output Register</description>
          <addressOffset>0x23C</addressOffset>
       </register>
       <register derivedFrom="PA0_PDIO">
          <name>PB0_PDIO</name>
          <displayName>PB0_PDIO</displayName>
          <description>GPIO PB.0 Pin Data Input/Output Register</description>
          <addressOffset>0x240</addressOffset>
       </register>
       <register derivedFrom="PB0_PDIO">
          <name>PB1_PDIO</name>
          <displayName>PB1_PDIO</displayName>
          <description>GPIO PB.1 Pin Data Input/Output Register</description>
          <addressOffset>0x244</addressOffset>
       </register>
       <register derivedFrom="PB0_PDIO">
          <name>PB2_PDIO</name>
          <displayName>PB2_PDIO</displayName>
          <description>GPIO PB.2 Pin Data Input/Output Register</description>
          <addressOffset>0x248</addressOffset>
       </register>
       <register derivedFrom="PB0_PDIO">
          <name>PB3_PDIO</name>
          <displayName>PB3_PDIO</displayName>
          <description>GPIO PB.3 Pin Data Input/Output Register</description>
          <addressOffset>0x24C</addressOffset>
       </register>
       <register derivedFrom="PB0_PDIO">
          <name>PB4_PDIO</name>
          <displayName>PB4_PDIO</displayName>
          <description>GPIO PB.4 Pin Data Input/Output Register</description>
          <addressOffset>0x250</addressOffset>
       </register>
       <register derivedFrom="PB0_PDIO">
          <name>PB5_PDIO</name>
          <displayName>PB5_PDIO</displayName>
          <description>GPIO PB.5 Pin Data Input/Output Register</description>
          <addressOffset>0x254</addressOffset>
       </register>
       <register derivedFrom="PB0_PDIO">
          <name>PB6_PDIO</name>
          <displayName>PB6_PDIO</displayName>
          <description>GPIO PB.6 Pin Data Input/Output Register</description>
          <addressOffset>0x258</addressOffset>
       </register>
       <register derivedFrom="PB0_PDIO">
          <name>PB7_PDIO</name>
          <displayName>PB7_PDIO</displayName>
          <description>GPIO PB.7 Pin Data Input/Output Register</description>
          <addressOffset>0x25C</addressOffset>
       </register>
       <register derivedFrom="PB0_PDIO">
          <name>PB8_PDIO</name>
          <displayName>PB8_PDIO</displayName>
          <description>GPIO PB.8 Pin Data Input/Output Register</description>
          <addressOffset>0x260</addressOffset>
       </register>
       <register derivedFrom="PB0_PDIO">
          <name>PB9_PDIO</name>
          <displayName>PB9_PDIO</displayName>
          <description>GPIO PB.9 Pin Data Input/Output Register</description>
          <addressOffset>0x264</addressOffset>
       </register>
       <register derivedFrom="PB0_PDIO">
          <name>PB10_PDIO</name>
          <displayName>PB10_PDIO</displayName>
          <description>GPIO PB.10 Pin Data Input/Output Register</description>
          <addressOffset>0x268</addressOffset>
       </register>
       <register derivedFrom="PB0_PDIO">
          <name>PB11_PDIO</name>
          <displayName>PB11_PDIO</displayName>
          <description>GPIO PB.11 Pin Data Input/Output Register</description>
          <addressOffset>0x26C</addressOffset>
       </register>
       <register derivedFrom="PB0_PDIO">
          <name>PB12_PDIO</name>
          <displayName>PB12_PDIO</displayName>
          <description>GPIO PB.12 Pin Data Input/Output Register</description>
          <addressOffset>0x270</addressOffset>
       </register>
       <register derivedFrom="PB0_PDIO">
          <name>PB13_PDIO</name>
          <displayName>PB13_PDIO</displayName>
          <description>GPIO PB.13 Pin Data Input/Output Register</description>
          <addressOffset>0x274</addressOffset>
       </register>
       <register derivedFrom="PB0_PDIO">
          <name>PB14_PDIO</name>
          <displayName>PB14_PDIO</displayName>
          <description>GPIO PB.14 Pin Data Input/Output Register</description>
          <addressOffset>0x278</addressOffset>
       </register>
       <register derivedFrom="PB0_PDIO">
          <name>PB15_PDIO</name>
          <displayName>PB15_PDIO</displayName>
          <description>GPIO PB.15 Pin Data Input/Output Register</description>
          <addressOffset>0x27C</addressOffset>
       </register>
       <register derivedFrom="PA0_PDIO">
          <name>PC0_PDIO</name>
          <displayName>PC0_PDIO</displayName>
          <description>GPIO PC.0 Pin Data Input/Output Register</description>
          <addressOffset>0x280</addressOffset>
       </register>
       <register derivedFrom="PC0_PDIO">
          <name>PC1_PDIO</name>
          <displayName>PC1_PDIO</displayName>
          <description>GPIO PC.1 Pin Data Input/Output Register</description>
          <addressOffset>0x284</addressOffset>
       </register>
       <register derivedFrom="PC0_PDIO">
          <name>PC2_PDIO</name>
          <displayName>PC2_PDIO</displayName>
          <description>GPIO PC.2 Pin Data Input/Output Register</description>
          <addressOffset>0x288</addressOffset>
       </register>
       <register derivedFrom="PC0_PDIO">
          <name>PC3_PDIO</name>
          <displayName>PC3_PDIO</displayName>
          <description>GPIO PC.3 Pin Data Input/Output Register</description>
          <addressOffset>0x28C</addressOffset>
       </register>
       <register derivedFrom="PC0_PDIO">
          <name>PC4_PDIO</name>
          <displayName>PC4_PDIO</displayName>
          <description>GPIO PC.4 Pin Data Input/Output Register</description>
          <addressOffset>0x290</addressOffset>
       </register>
       <register derivedFrom="PC0_PDIO">
          <name>PC5_PDIO</name>
          <displayName>PC5_PDIO</displayName>
          <description>GPIO PC.5 Pin Data Input/Output Register</description>
          <addressOffset>0x294</addressOffset>
       </register>
       <register derivedFrom="PC0_PDIO">
          <name>PC6_PDIO</name>
          <displayName>PC6_PDIO</displayName>
          <description>GPIO PC.6 Pin Data Input/Output Register</description>
          <addressOffset>0x298</addressOffset>
       </register>
       <register derivedFrom="PC0_PDIO">
          <name>PC7_PDIO</name>
          <displayName>PC7_PDIO</displayName>
          <description>GPIO PC.7 Pin Data Input/Output Register</description>
          <addressOffset>0x29C</addressOffset>
       </register>
       <register derivedFrom="PC0_PDIO">
          <name>PC8_PDIO</name>
          <displayName>PC8_PDIO</displayName>
          <description>GPIO PC.8 Pin Data Input/Output Register</description>
          <addressOffset>0x2A0</addressOffset>
       </register>
       <register derivedFrom="PC0_PDIO">
          <name>PC9_PDIO</name>
          <displayName>PC9_PDIO</displayName>
          <description>GPIO PC.9 Pin Data Input/Output Register</description>
          <addressOffset>0x2A4</addressOffset>
       </register>
       <register derivedFrom="PC0_PDIO">
          <name>PC10_PDIO</name>
          <displayName>PC10_PDIO</displayName>
          <description>GPIO PC.10 Pin Data Input/Output Register</description>
          <addressOffset>0x2A8</addressOffset>
       </register>
       <register derivedFrom="PC0_PDIO">
          <name>PC11_PDIO</name>
          <displayName>PC11_PDIO</displayName>
          <description>GPIO PC.11 Pin Data Input/Output Register</description>
          <addressOffset>0x2AC</addressOffset>
       </register>
       <register derivedFrom="PC0_PDIO">
          <name>PC12_PDIO</name>
          <displayName>PC12_PDIO</displayName>
          <description>GPIO PC.12 Pin Data Input/Output Register</description>
          <addressOffset>0x2B0</addressOffset>
       </register>
       <register derivedFrom="PC0_PDIO">
          <name>PC13_PDIO</name>
          <displayName>PC13_PDIO</displayName>
          <description>GPIO PC.13 Pin Data Input/Output Register</description>
          <addressOffset>0x2B4</addressOffset>
       </register>
       <register derivedFrom="PC0_PDIO">
          <name>PC14_PDIO</name>
          <displayName>PC14_PDIO</displayName>
          <description>GPIO PC.14 Pin Data Input/Output Register</description>
          <addressOffset>0x2B8</addressOffset>
       </register>
       <register derivedFrom="PC0_PDIO">
          <name>PC15_PDIO</name>
          <displayName>PC15_PDIO</displayName>
          <description>GPIO PC.15 Pin Data Input/Output Register</description>
          <addressOffset>0x2BC</addressOffset>
       </register>
       <register derivedFrom="PA0_PDIO">
          <name>PD0_PDIO</name>
          <displayName>PD0_PDIO</displayName>
          <description>GPIO PD.0 Pin Data Input/Output Register</description>
          <addressOffset>0x2C0</addressOffset>
       </register>
       <register derivedFrom="PD0_PDIO">
          <name>PD1_PDIO</name>
          <displayName>PD1_PDIO</displayName>
          <description>GPIO PD.1 Pin Data Input/Output Register</description>
          <addressOffset>0x2C4</addressOffset>
       </register>
       <register derivedFrom="PD0_PDIO">
          <name>PD2_PDIO</name>
          <displayName>PD2_PDIO</displayName>
          <description>GPIO PD.2 Pin Data Input/Output Register</description>
          <addressOffset>0x2C8</addressOffset>
       </register>
       <register derivedFrom="PD0_PDIO">
          <name>PD3_PDIO</name>
          <displayName>PD3_PDIO</displayName>
          <description>GPIO PD.3 Pin Data Input/Output Register</description>
          <addressOffset>0x2CC</addressOffset>
       </register>
       <register derivedFrom="PD0_PDIO">
          <name>PD4_PDIO</name>
          <displayName>PD4_PDIO</displayName>
          <description>GPIO PD.4 Pin Data Input/Output Register</description>
          <addressOffset>0x2D0</addressOffset>
       </register>
       <register derivedFrom="PD0_PDIO">
          <name>PD5_PDIO</name>
          <displayName>PD5_PDIO</displayName>
          <description>GPIO PD.5 Pin Data Input/Output Register</description>
          <addressOffset>0x2D4</addressOffset>
       </register>
       <register derivedFrom="PD0_PDIO">
          <name>PD6_PDIO</name>
          <displayName>PD6_PDIO</displayName>
          <description>GPIO PD.6 Pin Data Input/Output Register</description>
          <addressOffset>0x2D8</addressOffset>
       </register>
       <register derivedFrom="PD0_PDIO">
          <name>PD7_PDIO</name>
          <displayName>PD7_PDIO</displayName>
          <description>GPIO PD.7 Pin Data Input/Output Register</description>
          <addressOffset>0x2DC</addressOffset>
       </register>
       <register derivedFrom="PD0_PDIO">
          <name>PD8_PDIO</name>
          <displayName>PD8_PDIO</displayName>
          <description>GPIO PD.8 Pin Data Input/Output Register</description>
          <addressOffset>0x2E0</addressOffset>
       </register>
       <register derivedFrom="PD0_PDIO">
          <name>PD9_PDIO</name>
          <displayName>PD9_PDIO</displayName>
          <description>GPIO PD.9 Pin Data Input/Output Register</description>
          <addressOffset>0x2E4</addressOffset>
       </register>
       <register derivedFrom="PD0_PDIO">
          <name>PD10_PDIO</name>
          <displayName>PD10_PDIO</displayName>
          <description>GPIO PD.10 Pin Data Input/Output Register</description>
          <addressOffset>0x2E8</addressOffset>
       </register>
       <register derivedFrom="PD0_PDIO">
          <name>PD11_PDIO</name>
          <displayName>PD11_PDIO</displayName>
          <description>GPIO PD.11 Pin Data Input/Output Register</description>
          <addressOffset>0x2EC</addressOffset>
       </register>
       <register derivedFrom="PD0_PDIO">
          <name>PD12_PDIO</name>
          <displayName>PD12_PDIO</displayName>
          <description>GPIO PD.12 Pin Data Input/Output Register</description>
          <addressOffset>0x2F0</addressOffset>
       </register>
       <register derivedFrom="PD0_PDIO">
          <name>PD13_PDIO</name>
          <displayName>PD13_PDIO</displayName>
          <description>GPIO PD.13 Pin Data Input/Output Register</description>
          <addressOffset>0x2F4</addressOffset>
       </register>
       <register derivedFrom="PD0_PDIO">
          <name>PD14_PDIO</name>
          <displayName>PD14_PDIO</displayName>
          <description>GPIO PD.14 Pin Data Input/Output Register</description>
          <addressOffset>0x2F8</addressOffset>
       </register>
       <register derivedFrom="PD0_PDIO">
          <name>PD15_PDIO</name>
          <displayName>PD15_PDIO</displayName>
          <description>GPIO PD.15 Pin Data Input/Output Register</description>
          <addressOffset>0x2FC</addressOffset>
       </register>
       <register derivedFrom="PA0_PDIO">
          <name>PE0_PDIO</name>
          <displayName>PE0_PDIO</displayName>
          <description>GPIO PE.0 Pin Data Input/Output Register</description>
          <addressOffset>0x300</addressOffset>
       </register>
       <register derivedFrom="PE0_PDIO">
          <name>PE1_PDIO</name>
          <displayName>PE1_PDIO</displayName>
          <description>GPIO PE.1 Pin Data Input/Output Register</description>
          <addressOffset>0x304</addressOffset>
       </register>
       <register derivedFrom="PE0_PDIO">
          <name>PE2_PDIO</name>
          <displayName>PE2_PDIO</displayName>
          <description>GPIO PE.2 Pin Data Input/Output Register</description>
          <addressOffset>0x308</addressOffset>
       </register>
       <register derivedFrom="PE0_PDIO">
          <name>PE3_PDIO</name>
          <displayName>PE3_PDIO</displayName>
          <description>GPIO PE.3 Pin Data Input/Output Register</description>
          <addressOffset>0x30C</addressOffset>
       </register>
       <register derivedFrom="PE0_PDIO">
          <name>PE4_PDIO</name>
          <displayName>PE4_PDIO</displayName>
          <description>GPIO PE.4 Pin Data Input/Output Register</description>
          <addressOffset>0x310</addressOffset>
       </register>
       <register derivedFrom="PE0_PDIO">
          <name>PE5_PDIO</name>
          <displayName>PE5_PDIO</displayName>
          <description>GPIO PE.5 Pin Data Input/Output Register</description>
          <addressOffset>0x314</addressOffset>
       </register>
       <register derivedFrom="PE0_PDIO">
          <name>PE6_PDIO</name>
          <displayName>PE6_PDIO</displayName>
          <description>GPIO PE.6 Pin Data Input/Output Register</description>
          <addressOffset>0x318</addressOffset>
       </register>
       <register derivedFrom="PE0_PDIO">
          <name>PE7_PDIO</name>
          <displayName>PE7_PDIO</displayName>
          <description>GPIO PE.7 Pin Data Input/Output Register</description>
          <addressOffset>0x31C</addressOffset>
       </register>
       <register derivedFrom="PE0_PDIO">
          <name>PE8_PDIO</name>
          <displayName>PE8_PDIO</displayName>
          <description>GPIO PE.8 Pin Data Input/Output Register</description>
          <addressOffset>0x320</addressOffset>
       </register>
       <register derivedFrom="PE0_PDIO">
          <name>PE9_PDIO</name>
          <displayName>PE9_PDIO</displayName>
          <description>GPIO PE.9 Pin Data Input/Output Register</description>
          <addressOffset>0x324</addressOffset>
       </register>
       <register derivedFrom="PE0_PDIO">
          <name>PE10_PDIO</name>
          <displayName>PE10_PDIO</displayName>
          <description>GPIO PE.10 Pin Data Input/Output Register</description>
          <addressOffset>0x328</addressOffset>
       </register>
       <register derivedFrom="PE0_PDIO">
          <name>PE11_PDIO</name>
          <displayName>PE11_PDIO</displayName>
          <description>GPIO PE.11 Pin Data Input/Output Register</description>
          <addressOffset>0x32C</addressOffset>
       </register>
       <register derivedFrom="PE0_PDIO">
          <name>PE12_PDIO</name>
          <displayName>PE12_PDIO</displayName>
          <description>GPIO PE.12 Pin Data Input/Output Register</description>
          <addressOffset>0x330</addressOffset>
       </register>
       <register derivedFrom="PE0_PDIO">
          <name>PE13_PDIO</name>
          <displayName>PE13_PDIO</displayName>
          <description>GPIO PE.13 Pin Data Input/Output Register</description>
          <addressOffset>0x334</addressOffset>
       </register>
       <register derivedFrom="PE0_PDIO">
          <name>PE14_PDIO</name>
          <displayName>PE14_PDIO</displayName>
          <description>GPIO PE.14 Pin Data Input/Output Register</description>
          <addressOffset>0x338</addressOffset>
       </register>
       <register derivedFrom="PA0_PDIO">
          <name>PF0_PDIO</name>
          <displayName>PF0_PDIO</displayName>
          <description>GPIO PF.0 Pin Data Input/Output Register</description>
          <addressOffset>0x340</addressOffset>
       </register>
       <register derivedFrom="PF0_PDIO">
          <name>PF1_PDIO</name>
          <displayName>PF1_PDIO</displayName>
          <description>GPIO PF.1 Pin Data Input/Output Register</description>
          <addressOffset>0x344</addressOffset>
       </register>
       <register derivedFrom="PF0_PDIO">
          <name>PF2_PDIO</name>
          <displayName>PF2_PDIO</displayName>
          <description>GPIO PF.2 Pin Data Input/Output Register</description>
          <addressOffset>0x348</addressOffset>
       </register>
       <register derivedFrom="PF0_PDIO">
          <name>PF3_PDIO</name>
          <displayName>PF3_PDIO</displayName>
          <description>GPIO PF.3 Pin Data Input/Output Register</description>
          <addressOffset>0x34C</addressOffset>
       </register>
       <register derivedFrom="PF0_PDIO">
          <name>PF4_PDIO</name>
          <displayName>PF4_PDIO</displayName>
          <description>GPIO PF.4 Pin Data Input/Output Register</description>
          <addressOffset>0x350</addressOffset>
       </register>
       <register derivedFrom="PF0_PDIO">
          <name>PF5_PDIO</name>
          <displayName>PF5_PDIO</displayName>
          <description>GPIO PF.5 Pin Data Input/Output Register</description>
          <addressOffset>0x354</addressOffset>
       </register>
       <register derivedFrom="PF0_PDIO">
          <name>PF6_PDIO</name>
          <displayName>PF6_PDIO</displayName>
          <description>GPIO PF.6 Pin Data Input/Output Register</description>
          <addressOffset>0x358</addressOffset>
       </register>
       <register derivedFrom="PF0_PDIO">
          <name>PF7_PDIO</name>
          <displayName>PF7_PDIO</displayName>
          <description>GPIO PF.7 Pin Data Input/Output Register</description>
          <addressOffset>0x35C</addressOffset>
       </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>CRC</name>
      <description>PDMA Register Map</description>
      <groupName>PDMA</groupName>
      <baseAddress>0x50008E00</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x0</offset>
        <size>0x8</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0xC</offset>
        <size>0x4</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x14</offset>
        <size>0x4</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x1C</offset>
        <size>0xC</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x80</offset>
        <size>0xC</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>CRC_CTL</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CRC_CTL</displayName>
          <description>CRC Control Register</description>
          <addressOffset>0x0</addressOffset>
          <access>read-write</access>
          <resetValue>0x20000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CRCEN</name>
              <description>CRC Channel Enable Bit</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>CRC operation Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CRCRST</name>
              <description>CRC Engine Reset Bit\nNote1: This bit will be cleared automatically.\nNote2: When operating in CPU mode, setting this bit will reload the seed value from CRC_SEED register as checksum initial value.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reset the internal CRC state machine and internal buffer. The others contents of CRC_CTL register will not be cleared</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TRIGEN</name>
              <description>Trigger Enable Bit\nThis bit is used to trigger the CRC DMA transfer.\nNote1: If this bit asserts which indicates the CRC engine operation in CRC DMA mode, do not fill in any data in CRC_DAT register.\nNote2: When CRC DMA transfer completed, this bit will be cleared automatically.\nNote3: If the bus error occurs when CRC DMA transfer data, all CRC DMA transfer will be stopped. User must reset all DMA channel before trigger DMA again.</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>CRC DMA data read or write transfer Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DATREV</name>
              <description>Write Data Bit Order Reverse\nThis bit is used to enable the bit order reverse function for writing data value in CRC_DTA register.\nNote: If the write data is 0xAABBCCDD, the bit order reverse for CRC data write in is 0x55DD33BB.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Bit order reverse for CRC data write in Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Bit order reverse for CRC data write in Enabled (per byte)</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CHKSREV</name>
              <description>Checksum Bit Order Reverse\nThis bit is used to enable the bit order reverse function for checksum result in CRC_CHECKSUM register.\nNote: If the checksum result is 0XDD7B0F2E, the bit order reverse for CRC checksum is 0x74F0DEBB.</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Bit order reverse for CRC checksum Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Bit order reverse for CRC checksum Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DATFMT</name>
              <description>Write Data 1's Complement\nThis bit is used to enable the 1's complement function for write data value in CRC_DTA register.</description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>1's complement for CRC writes data in Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>1's complement for CRC writes data in Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CHKSFMT</name>
              <description>Checksum 1's Complement\nThis bit is used to enable the 1's complement function for checksum result in CRC_CHECKSUM register.</description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>1's complementfor CRC checksum Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>1's complement for CRC checksum Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DATLEN</name>
              <description>CPU Write Data Length\nThis field indicates the CPU write data length only when operating in CPU mode.\nNote1: This field is only valid when operating in CPU mode.\nNote2: When the write data length is 8-bit mode, the valid data in CRC_DAT register is only DATA [7:0] bits; if the write data length is 16-bit mode, the valid data in CRC_DAT register is only DATA [15:0].</description>
              <bitOffset>28</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The write data length is 8-bit mode</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The write data length is 16-bit mode</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>The write data length is 32-bit mode</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Reserved</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CRCMODE</name>
              <description>CRC Polynomial Mode\nThis field indicates the CRC operation polynomial mode.</description>
              <bitOffset>30</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>CRC-CCITT Polynomial Mode</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>CRC-8 Polynomial Mode</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>CRC-16 Polynomial Mode</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>CRC-32 Polynomial Mode</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CRC_DMASA</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CRC_DMASA</displayName>
          <description>CRC DMA Source Address Register</description>
          <addressOffset>0x4</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SA</name>
              <description>CRC DMA Transfer Source Address Bits\nThis field indicates a 32-bit source address of CRC DMA.\nNote: The source address must be word alignment.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CRC_DMABCNT</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CRC_DMABCNT</displayName>
          <description>CRC DMA Transfer Byte Count Register</description>
          <addressOffset>0xC</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BCNT</name>
              <description>CRC DMA Transfer Byte Count \nThis field indicates a 16-bit total transfer byte count number of CRC DMA.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CRC_DMACSA</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CRC_DMACSA</displayName>
          <description>CRC DMA Current Source Address Register</description>
          <addressOffset>0x14</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CSA</name>
              <description>CRC DMA Current Source Address Bits (Read Only)\nThis field indicates the current source address where the CRC DMA transfer just occurs.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CRC_DMACBCNT</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CRC_DMACBCNT</displayName>
          <description>CRC DMA Current Transfer Byte Count Register</description>
          <addressOffset>0x1C</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CBCNT</name>
              <description>CRC DMA Current Remained Byte Count (Read Only)\nThis field indicates the current remained byte count of CRC DMA.\nNote: Setting the CRCRST (CRC_CTL[1]) bit to 1 will clear this register value.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CRC_DMAINTEN</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CRC_DMAINTEN</displayName>
          <description>CRC DMA Interrupt Enable Register</description>
          <addressOffset>0x20</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000001</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TABTIEN</name>
              <description>CRC DMA Read/Write Target Abort Interrupt Enable Bit\nEnable this bit will generate the CRC DMA Target Abort interrupt signal while TABTIF (CRC_DMAINTSTS[0]) bit is set to 1.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Target abort interrupt Disabled during CRC DMA transfer</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Target abort interrupt Enabled during CRC DMA transfer</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TDIEN</name>
              <description>CRC DMA Block Transfer Done Interrupt Enable Bit\nEnable this bit will generate the CRC DMA Transfer Done interrupt signal while TDIF (CRC_DMAINTSTS[1]) bit is set to 1.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Interrupt Disabled when CRC DMA transfer done</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Interrupt Enabled when CRC DMA transfer done</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CRC_DMAISTS</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CRC_DMAISTS</displayName>
          <description>CRC DMA Interrupt Status Register</description>
          <addressOffset>0x24</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TABTIF</name>
              <description>CRC DMA Read/Write Target Abort Interrupt Flag\nThis bit indicates that CRC bus has error or not during CRC DMA transfer.\nNote1: This bit is cleared by writing "1" to it.\nNote2: This bit indicates bus master received error response or not. If bus master received error response, it means that CRC transfer data from an invalid address or to an invalid adress .At this time target abort is happened.DMA will stop transfer and respond this event to user then CRC state machine goes to IDLE state. When target abort occurred, user must reset DMA before transfer those data again.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No bus error response received during CRC DMA transfer</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Bus error response received during CRC DMA transfer</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TDIF</name>
              <description>CRC DMA Transfer Done Interrupt Flag\nThis bit indicates that CRC DMA transfer has finished or not.\nNote1: This bit is cleared by writing "1" to it.\nNote2: When CRC DMA transfer is done, TRIGEN (CRC_CTL[23]) will be cleared automatically.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Not finished if TRIGEN (CRC_CTL[23]) has enabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>CRC transfer done if TRIGEN (CRC_CTL[23]) has enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CRC_DAT</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CRC_DAT</displayName>
          <description>CRC Write Data Register</description>
          <addressOffset>0x80</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DATA</name>
              <description>CRC Write Data Bits\nWhen operating in CPU mode, user can write data to this field to perform CRC operation.\nWhen operating in DMA mode, this field indicates the DMA read data from memory and cannot be written by user.\nNote: When the write data length is 8-bit mode, the valid data in CRC_DAT register are only DATA[7:0] bits; if the write data length is 16-bit mode, the valid data in CRC_DAT register are only DATA[15:0] bits.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CRC_SEED</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CRC_SEED</displayName>
          <description>CRC Seed Register</description>
          <addressOffset>0x84</addressOffset>
          <access>read-write</access>
          <resetValue>0xFFFFFFFF</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SEED</name>
              <description>CRC Seed Value\nThis field indicates the CRC seed value.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CRC_CHECKSUM</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CRC_CHECKSUM</displayName>
          <description>CRC Checksum Register</description>
          <addressOffset>0x88</addressOffset>
          <access>read-only</access>
          <resetValue>0xFFFFFFFF</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CHECKSUM</name>
              <description>CRC Checksum Results\nThis field indicates the CRC checksum result</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>PDMA_CH1</name>
      <description>PDMA Register Map</description>
      <groupName>PDMA</groupName>
      <baseAddress>0x50008100</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x0</offset>
        <size>0x10</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x14</offset>
        <size>0x18</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>PDMA_CTLn</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_CTLn</displayName>
          <description>PDMA Channel n Control Register</description>
          <addressOffset>0x0</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CHEN</name>
              <description>PDMA Channel Enable Bit\nSetting this bit to 1 enables PDMA operation. If this bit is cleared, PDMA will ignore all PDMA request and force Bus Master into IDLE state.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SWRST</name>
              <description>Software Engine Reset</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reset the internal state machine, pointers and internal buffer. The contents of all control registers will not be cleared. This bit will be automatically cleared after few clock cycles</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SASEL</name>
              <description>Transfer Source Address Direction Selection</description>
              <bitOffset>4</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Transfer Source address is incremented successively</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reserved</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Transfer Source address is fixed (This feature can be used when data where transferred from a single source to multiple destinations)</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Transfer Source address is wrap around (When the PDMA_CCNT is equal to 0, the PDMA_CSA and PDMA_CCNT registers will be updated by PDMA_SA and PDMA_CNT automatically. PDMA will start another transfer without user trigger until CHEN disabled. When the CHEN is disabled, the PDMA will complete the active transfer but the remained data which in the PDMA buffer will not transfer to destination address)</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DASEL</name>
              <description>Transfer Destination Address Direction Selection</description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Transfer Destination address is incremented successively</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reserved</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Transfer Destination address is fixed. (This feature can be used when data transferred from multiple sources to a single destination)</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Transfer Destination address is wrapped around (When the PDMA_CCNT is equal to 0, the PDMA_CDA and PDMA_CCNT registers will be updated by PDMA_DA and PDMA_CNT automatically. PDMA will start another transfer without user trigger until CHEN disabled. When the CHEN is disabled, the PDMA will complete the active transfer but the remained data which in the PDMA buffer will not transfer to destination address)</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TOUTEN</name>
              <description>Time-out Enable Bit</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PDMA internal counter Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PDMA internal counter Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TXWIDTH</name>
              <description>Transfer Width Selection\nThis field is used for transfer width.</description>
              <bitOffset>19</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>One word (32-bit) is transferred for every PDMA operation</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>One byte (8-bit) is transferred for every PDMA operation</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>One half-word (16-bit) is transferred for every PDMA operation</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Reserved</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TRIGEN</name>
              <description>Trigger Enable Bit \nNote1: When PDMA transfer completed, this bit will be cleared automatically.\nNote2: If the bus error occurs, all PDMA transfer will be stopped. User must reset all PDMA channels, and then trigger again.</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PDMA data transfer Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PDMA_SAn</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_SAn</displayName>
          <description>PDMA Channel n Source Address Register</description>
          <addressOffset>0x4</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SA</name>
              <description>PDMA Transfer Source Address Bits\nThis field indicates a 32-bit source address of PDMA.\nNote: The source address must be word alignment.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PDMA_DAn</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_DAn</displayName>
          <description>PDMA Channel n Destination Address Register</description>
          <addressOffset>0x8</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DA</name>
              <description>PDMA Transfer Destination Address Bits\nThis field indicates a 32-bit destination address of PDMA.\nNote: The Destination address must be word alignment.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PDMA_CNTn</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_CNTn</displayName>
          <description>PDMA Channel n Transfer Count Register</description>
          <addressOffset>0xC</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TCNT</name>
              <description>PDMA Transfer Count Bits\nThis field indicates a 16-bit transfer count number of PDMA.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PCNTITH</name>
              <description>PDMA Periodic Count Interrupt Threshold\nThis field indicates how many data transferred to generate periodic interrupt\nNote: write 0 to this field to disable this function.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PDMA_CSAn</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_CSAn</displayName>
          <description>PDMA Channel n Current Source Address Register</description>
          <addressOffset>0x14</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CSA</name>
              <description>PDMA Current Source Address Bits (Read Only)\nThis field indicates the source address where the PDMA transfer just occurred.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PDMA_CDAn</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_CDAn</displayName>
          <description>PDMA Channel n Current Destination Address Register</description>
          <addressOffset>0x18</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CDA</name>
              <description>PDMA Current Destination Address Bits (Read Only)\nThis field indicates the destination address where the PDMA transfer just occurred.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PDMA_CCNTn</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_CCNTn</displayName>
          <description>PDMA Channel n Current Transfer Count Register</description>
          <addressOffset>0x1C</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CCNT</name>
              <description>PDMA Current Count Bits (Read Only)\nThis field indicates the current remained transfer count of PDMA.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PDMA_INTENn</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_INTENn</displayName>
          <description>PDMA Channel n Interrupt Enable Register</description>
          <addressOffset>0x20</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000001</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TABTIEN</name>
              <description>PDMA Read/Write Target Abort Interrupt Enable Bit</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Target abort interrupt Disabled during PDMA transfer</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Target abort interrupt Enabled during PDMA transfer</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TDIEN</name>
              <description>PDMA Transfer Done Interrupt Enable Bit</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Interrupt Disabled when PDMA transfer is done</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Interrupt Enabled when PDMA transfer is done</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TOUTIEN</name>
              <description>Time-out Interrupt Enable Bit</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Time-out interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Time-out interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PCNTIEN</name>
              <description>Periodic Count Interrupt Enable Bit\nThis field indicates how many data transferred to generate interrupt periodically. </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Periodic transfer count interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Periodic transfer count interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PDMA_INTSTSn</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_INTSTSn</displayName>
          <description>PDMA Channel n Interrupt Status Register</description>
          <addressOffset>0x24</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TABTIF</name>
              <description>PDMA Read/Write Target Abort Interrupt Status Flag\nNote1: This bit is cleared by writing "1" to it.\nNote2: This bit indicates bus master received error response or not, if bus master received error response, it means that PDMA transfer data from an invalid address or to an invalid adress .At this time target abort is happened..PDMA controller will stop transfer and respond this event to user then go to IDLE state. When target abort occurred, user must reset PDMA controller, and then transfer those data again.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No bus ERROR response received</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Bus ERROR response received</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TDIF</name>
              <description>Transfer Done Interrupt Status Flag\nThis bit indicates that PDMA has finished all transfer.\nNote: This bit is cleared by writing "1" to it.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Not finished yet</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Done</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TOUTIF</name>
              <description>Time-out Interrupt Status Flag\nThis flag indicated that PDMA has waited peripheral request for a period defined by PDMA_TOC.\nNote: This bit is cleared by writing "1" to it.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No time-out flag</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Time-out flag</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PCNTIF</name>
              <description>Periodic Count Interrupt Status Flag\nNote: This bit is cleared by writing "1" to it.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PDMA_TOCn</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_TOCn</displayName>
          <description>PDMA Channel n Time-out Counter Register</description>
          <addressOffset>0x28</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TOC</name>
              <description>PDMA Time-out Period Counter</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TPSC</name>
              <description>PDMA Time-out Counter Clock Source Prescaler</description>
              <bitOffset>16</bitOffset>
              <bitWidth>3</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PDMA time-out clock source is HCLK/28</description>
                    <value>#000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PDMA time-out clock source is HCLK/29</description>
                    <value>#001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>PDMA time-out clock source is HCLK/210</description>
                    <value>#010</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>PDMA time-out clock source is HCLK/211</description>
                    <value>#011</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>4</name>
                    <description>PDMA time-out clock source is HCLK/212</description>
                    <value>#100</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>5</name>
                    <description>PDMA time-out clock source is HCLK/213</description>
                    <value>#101</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>6</name>
                    <description>PDMA time-out clock source is HCLK/214</description>
                    <value>#110</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>7</name>
                    <description>PDMA time-out clock source is HCLK/215</description>
                    <value>#111</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>PDMA_CH2</name>
      <description>PDMA Register Map</description>
      <groupName>PDMA</groupName>
      <baseAddress>0x50008200</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x0</offset>
        <size>0x10</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x14</offset>
        <size>0x18</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>PDMA_CTLn</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_CTLn</displayName>
          <description>PDMA Channel n Control Register</description>
          <addressOffset>0x0</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CHEN</name>
              <description>PDMA Channel Enable Bit\nSetting this bit to 1 enables PDMA operation. If this bit is cleared, PDMA will ignore all PDMA request and force Bus Master into IDLE state.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SWRST</name>
              <description>Software Engine Reset</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reset the internal state machine, pointers and internal buffer. The contents of all control registers will not be cleared. This bit will be automatically cleared after few clock cycles</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SASEL</name>
              <description>Transfer Source Address Direction Selection</description>
              <bitOffset>4</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Transfer Source address is incremented successively</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reserved</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Transfer Source address is fixed (This feature can be used when data where transferred from a single source to multiple destinations)</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Transfer Source address is wrap around (When the PDMA_CCNT is equal to 0, the PDMA_CSA and PDMA_CCNT registers will be updated by PDMA_SA and PDMA_CNT automatically. PDMA will start another transfer without user trigger until CHEN disabled. When the CHEN is disabled, the PDMA will complete the active transfer but the remained data which in the PDMA buffer will not transfer to destination address)</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DASEL</name>
              <description>Transfer Destination Address Direction Selection</description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Transfer Destination address is incremented successively</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reserved</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Transfer Destination address is fixed. (This feature can be used when data transferred from multiple sources to a single destination)</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Transfer Destination address is wrapped around (When the PDMA_CCNT is equal to 0, the PDMA_CDA and PDMA_CCNT registers will be updated by PDMA_DA and PDMA_CNT automatically. PDMA will start another transfer without user trigger until CHEN disabled. When the CHEN is disabled, the PDMA will complete the active transfer but the remained data which in the PDMA buffer will not transfer to destination address)</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TOUTEN</name>
              <description>Time-out Enable Bit</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PDMA internal counter Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PDMA internal counter Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TXWIDTH</name>
              <description>Transfer Width Selection\nThis field is used for transfer width.</description>
              <bitOffset>19</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>One word (32-bit) is transferred for every PDMA operation</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>One byte (8-bit) is transferred for every PDMA operation</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>One half-word (16-bit) is transferred for every PDMA operation</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Reserved</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TRIGEN</name>
              <description>Trigger Enable Bit \nNote1: When PDMA transfer completed, this bit will be cleared automatically.\nNote2: If the bus error occurs, all PDMA transfer will be stopped. User must reset all PDMA channels, and then trigger again.</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PDMA data transfer Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PDMA_SAn</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_SAn</displayName>
          <description>PDMA Channel n Source Address Register</description>
          <addressOffset>0x4</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SA</name>
              <description>PDMA Transfer Source Address Bits\nThis field indicates a 32-bit source address of PDMA.\nNote: The source address must be word alignment.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PDMA_DAn</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_DAn</displayName>
          <description>PDMA Channel n Destination Address Register</description>
          <addressOffset>0x8</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DA</name>
              <description>PDMA Transfer Destination Address Bits\nThis field indicates a 32-bit destination address of PDMA.\nNote: The Destination address must be word alignment.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PDMA_CNTn</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_CNTn</displayName>
          <description>PDMA Channel n Transfer Count Register</description>
          <addressOffset>0xC</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TCNT</name>
              <description>PDMA Transfer Count Bits\nThis field indicates a 16-bit transfer count number of PDMA.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PCNTITH</name>
              <description>PDMA Periodic Count Interrupt Threshold\nThis field indicates how many data transferred to generate periodic interrupt\nNote: write 0 to this field to disable this function.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PDMA_CSAn</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_CSAn</displayName>
          <description>PDMA Channel n Current Source Address Register</description>
          <addressOffset>0x14</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CSA</name>
              <description>PDMA Current Source Address Bits (Read Only)\nThis field indicates the source address where the PDMA transfer just occurred.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PDMA_CDAn</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_CDAn</displayName>
          <description>PDMA Channel n Current Destination Address Register</description>
          <addressOffset>0x18</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CDA</name>
              <description>PDMA Current Destination Address Bits (Read Only)\nThis field indicates the destination address where the PDMA transfer just occurred.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PDMA_CCNTn</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_CCNTn</displayName>
          <description>PDMA Channel n Current Transfer Count Register</description>
          <addressOffset>0x1C</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CCNT</name>
              <description>PDMA Current Count Bits (Read Only)\nThis field indicates the current remained transfer count of PDMA.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PDMA_INTENn</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_INTENn</displayName>
          <description>PDMA Channel n Interrupt Enable Register</description>
          <addressOffset>0x20</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000001</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TABTIEN</name>
              <description>PDMA Read/Write Target Abort Interrupt Enable Bit</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Target abort interrupt Disabled during PDMA transfer</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Target abort interrupt Enabled during PDMA transfer</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TDIEN</name>
              <description>PDMA Transfer Done Interrupt Enable Bit</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Interrupt Disabled when PDMA transfer is done</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Interrupt Enabled when PDMA transfer is done</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TOUTIEN</name>
              <description>Time-out Interrupt Enable Bit</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Time-out interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Time-out interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PCNTIEN</name>
              <description>Periodic Count Interrupt Enable Bit\nThis field indicates how many data transferred to generate interrupt periodically. </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Periodic transfer count interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Periodic transfer count interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PDMA_INTSTSn</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_INTSTSn</displayName>
          <description>PDMA Channel n Interrupt Status Register</description>
          <addressOffset>0x24</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TABTIF</name>
              <description>PDMA Read/Write Target Abort Interrupt Status Flag\nNote1: This bit is cleared by writing "1" to it.\nNote2: This bit indicates bus master received error response or not, if bus master received error response, it means that PDMA transfer data from an invalid address or to an invalid adress .At this time target abort is happened..PDMA controller will stop transfer and respond this event to user then go to IDLE state. When target abort occurred, user must reset PDMA controller, and then transfer those data again.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No bus ERROR response received</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Bus ERROR response received</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TDIF</name>
              <description>Transfer Done Interrupt Status Flag\nThis bit indicates that PDMA has finished all transfer.\nNote: This bit is cleared by writing "1" to it.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Not finished yet</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Done</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TOUTIF</name>
              <description>Time-out Interrupt Status Flag\nThis flag indicated that PDMA has waited peripheral request for a period defined by PDMA_TOC.\nNote: This bit is cleared by writing "1" to it.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No time-out flag</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Time-out flag</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PCNTIF</name>
              <description>Periodic Count Interrupt Status Flag\nNote: This bit is cleared by writing "1" to it.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PDMA_TOCn</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_TOCn</displayName>
          <description>PDMA Channel n Time-out Counter Register</description>
          <addressOffset>0x28</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TOC</name>
              <description>PDMA Time-out Period Counter</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TPSC</name>
              <description>PDMA Time-out Counter Clock Source Prescaler</description>
              <bitOffset>16</bitOffset>
              <bitWidth>3</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PDMA time-out clock source is HCLK/28</description>
                    <value>#000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PDMA time-out clock source is HCLK/29</description>
                    <value>#001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>PDMA time-out clock source is HCLK/210</description>
                    <value>#010</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>PDMA time-out clock source is HCLK/211</description>
                    <value>#011</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>4</name>
                    <description>PDMA time-out clock source is HCLK/212</description>
                    <value>#100</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>5</name>
                    <description>PDMA time-out clock source is HCLK/213</description>
                    <value>#101</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>6</name>
                    <description>PDMA time-out clock source is HCLK/214</description>
                    <value>#110</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>7</name>
                    <description>PDMA time-out clock source is HCLK/215</description>
                    <value>#111</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>PDMA_CH3</name>
      <description>PDMA Register Map</description>
      <groupName>PDMA</groupName>
      <baseAddress>0x50008300</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x0</offset>
        <size>0x10</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x14</offset>
        <size>0x18</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>PDMA_CTLn</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_CTLn</displayName>
          <description>PDMA Channel n Control Register</description>
          <addressOffset>0x0</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CHEN</name>
              <description>PDMA Channel Enable Bit\nSetting this bit to 1 enables PDMA operation. If this bit is cleared, PDMA will ignore all PDMA request and force Bus Master into IDLE state.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SWRST</name>
              <description>Software Engine Reset</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reset the internal state machine, pointers and internal buffer. The contents of all control registers will not be cleared. This bit will be automatically cleared after few clock cycles</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SASEL</name>
              <description>Transfer Source Address Direction Selection</description>
              <bitOffset>4</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Transfer Source address is incremented successively</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reserved</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Transfer Source address is fixed (This feature can be used when data where transferred from a single source to multiple destinations)</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Transfer Source address is wrap around (When the PDMA_CCNT is equal to 0, the PDMA_CSA and PDMA_CCNT registers will be updated by PDMA_SA and PDMA_CNT automatically. PDMA will start another transfer without user trigger until CHEN disabled. When the CHEN is disabled, the PDMA will complete the active transfer but the remained data which in the PDMA buffer will not transfer to destination address)</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DASEL</name>
              <description>Transfer Destination Address Direction Selection</description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Transfer Destination address is incremented successively</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reserved</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Transfer Destination address is fixed. (This feature can be used when data transferred from multiple sources to a single destination)</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Transfer Destination address is wrapped around (When the PDMA_CCNT is equal to 0, the PDMA_CDA and PDMA_CCNT registers will be updated by PDMA_DA and PDMA_CNT automatically. PDMA will start another transfer without user trigger until CHEN disabled. When the CHEN is disabled, the PDMA will complete the active transfer but the remained data which in the PDMA buffer will not transfer to destination address)</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TOUTEN</name>
              <description>Time-out Enable Bit</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PDMA internal counter Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PDMA internal counter Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TXWIDTH</name>
              <description>Transfer Width Selection\nThis field is used for transfer width.</description>
              <bitOffset>19</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>One word (32-bit) is transferred for every PDMA operation</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>One byte (8-bit) is transferred for every PDMA operation</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>One half-word (16-bit) is transferred for every PDMA operation</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Reserved</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TRIGEN</name>
              <description>Trigger Enable Bit \nNote1: When PDMA transfer completed, this bit will be cleared automatically.\nNote2: If the bus error occurs, all PDMA transfer will be stopped. User must reset all PDMA channels, and then trigger again.</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PDMA data transfer Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PDMA_SAn</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_SAn</displayName>
          <description>PDMA Channel n Source Address Register</description>
          <addressOffset>0x4</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SA</name>
              <description>PDMA Transfer Source Address Bits\nThis field indicates a 32-bit source address of PDMA.\nNote: The source address must be word alignment.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PDMA_DAn</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_DAn</displayName>
          <description>PDMA Channel n Destination Address Register</description>
          <addressOffset>0x8</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DA</name>
              <description>PDMA Transfer Destination Address Bits\nThis field indicates a 32-bit destination address of PDMA.\nNote: The Destination address must be word alignment.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PDMA_CNTn</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_CNTn</displayName>
          <description>PDMA Channel n Transfer Count Register</description>
          <addressOffset>0xC</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TCNT</name>
              <description>PDMA Transfer Count Bits\nThis field indicates a 16-bit transfer count number of PDMA.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PCNTITH</name>
              <description>PDMA Periodic Count Interrupt Threshold\nThis field indicates how many data transferred to generate periodic interrupt\nNote: write 0 to this field to disable this function.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PDMA_CSAn</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_CSAn</displayName>
          <description>PDMA Channel n Current Source Address Register</description>
          <addressOffset>0x14</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CSA</name>
              <description>PDMA Current Source Address Bits (Read Only)\nThis field indicates the source address where the PDMA transfer just occurred.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PDMA_CDAn</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_CDAn</displayName>
          <description>PDMA Channel n Current Destination Address Register</description>
          <addressOffset>0x18</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CDA</name>
              <description>PDMA Current Destination Address Bits (Read Only)\nThis field indicates the destination address where the PDMA transfer just occurred.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PDMA_CCNTn</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_CCNTn</displayName>
          <description>PDMA Channel n Current Transfer Count Register</description>
          <addressOffset>0x1C</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CCNT</name>
              <description>PDMA Current Count Bits (Read Only)\nThis field indicates the current remained transfer count of PDMA.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PDMA_INTENn</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_INTENn</displayName>
          <description>PDMA Channel n Interrupt Enable Register</description>
          <addressOffset>0x20</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000001</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TABTIEN</name>
              <description>PDMA Read/Write Target Abort Interrupt Enable Bit</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Target abort interrupt Disabled during PDMA transfer</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Target abort interrupt Enabled during PDMA transfer</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TDIEN</name>
              <description>PDMA Transfer Done Interrupt Enable Bit</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Interrupt Disabled when PDMA transfer is done</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Interrupt Enabled when PDMA transfer is done</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TOUTIEN</name>
              <description>Time-out Interrupt Enable Bit</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Time-out interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Time-out interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PCNTIEN</name>
              <description>Periodic Count Interrupt Enable Bit\nThis field indicates how many data transferred to generate interrupt periodically. </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Periodic transfer count interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Periodic transfer count interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PDMA_INTSTSn</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_INTSTSn</displayName>
          <description>PDMA Channel n Interrupt Status Register</description>
          <addressOffset>0x24</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TABTIF</name>
              <description>PDMA Read/Write Target Abort Interrupt Status Flag\nNote1: This bit is cleared by writing "1" to it.\nNote2: This bit indicates bus master received error response or not, if bus master received error response, it means that PDMA transfer data from an invalid address or to an invalid adress .At this time target abort is happened..PDMA controller will stop transfer and respond this event to user then go to IDLE state. When target abort occurred, user must reset PDMA controller, and then transfer those data again.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No bus ERROR response received</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Bus ERROR response received</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TDIF</name>
              <description>Transfer Done Interrupt Status Flag\nThis bit indicates that PDMA has finished all transfer.\nNote: This bit is cleared by writing "1" to it.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Not finished yet</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Done</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TOUTIF</name>
              <description>Time-out Interrupt Status Flag\nThis flag indicated that PDMA has waited peripheral request for a period defined by PDMA_TOC.\nNote: This bit is cleared by writing "1" to it.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No time-out flag</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Time-out flag</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PCNTIF</name>
              <description>Periodic Count Interrupt Status Flag\nNote: This bit is cleared by writing "1" to it.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PDMA_TOCn</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_TOCn</displayName>
          <description>PDMA Channel n Time-out Counter Register</description>
          <addressOffset>0x28</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TOC</name>
              <description>PDMA Time-out Period Counter</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TPSC</name>
              <description>PDMA Time-out Counter Clock Source Prescaler</description>
              <bitOffset>16</bitOffset>
              <bitWidth>3</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PDMA time-out clock source is HCLK/28</description>
                    <value>#000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PDMA time-out clock source is HCLK/29</description>
                    <value>#001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>PDMA time-out clock source is HCLK/210</description>
                    <value>#010</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>PDMA time-out clock source is HCLK/211</description>
                    <value>#011</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>4</name>
                    <description>PDMA time-out clock source is HCLK/212</description>
                    <value>#100</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>5</name>
                    <description>PDMA time-out clock source is HCLK/213</description>
                    <value>#101</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>6</name>
                    <description>PDMA time-out clock source is HCLK/214</description>
                    <value>#110</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>7</name>
                    <description>PDMA time-out clock source is HCLK/215</description>
                    <value>#111</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>PDMA_CH4</name>
      <description>PDMA Register Map</description>
      <groupName>PDMA</groupName>
      <baseAddress>0x50008400</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x0</offset>
        <size>0x10</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x14</offset>
        <size>0x18</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>PDMA_CTLn</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_CTLn</displayName>
          <description>PDMA Channel n Control Register</description>
          <addressOffset>0x0</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CHEN</name>
              <description>PDMA Channel Enable Bit\nSetting this bit to 1 enables PDMA operation. If this bit is cleared, PDMA will ignore all PDMA request and force Bus Master into IDLE state.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SWRST</name>
              <description>Software Engine Reset</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reset the internal state machine, pointers and internal buffer. The contents of all control registers will not be cleared. This bit will be automatically cleared after few clock cycles</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SASEL</name>
              <description>Transfer Source Address Direction Selection</description>
              <bitOffset>4</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Transfer Source address is incremented successively</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reserved</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Transfer Source address is fixed (This feature can be used when data where transferred from a single source to multiple destinations)</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Transfer Source address is wrap around (When the PDMA_CCNT is equal to 0, the PDMA_CSA and PDMA_CCNT registers will be updated by PDMA_SA and PDMA_CNT automatically. PDMA will start another transfer without user trigger until CHEN disabled. When the CHEN is disabled, the PDMA will complete the active transfer but the remained data which in the PDMA buffer will not transfer to destination address)</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DASEL</name>
              <description>Transfer Destination Address Direction Selection</description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Transfer Destination address is incremented successively</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reserved</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Transfer Destination address is fixed. (This feature can be used when data transferred from multiple sources to a single destination)</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Transfer Destination address is wrapped around (When the PDMA_CCNT is equal to 0, the PDMA_CDA and PDMA_CCNT registers will be updated by PDMA_DA and PDMA_CNT automatically. PDMA will start another transfer without user trigger until CHEN disabled. When the CHEN is disabled, the PDMA will complete the active transfer but the remained data which in the PDMA buffer will not transfer to destination address)</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TOUTEN</name>
              <description>Time-out Enable Bit</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PDMA internal counter Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PDMA internal counter Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TXWIDTH</name>
              <description>Transfer Width Selection\nThis field is used for transfer width.</description>
              <bitOffset>19</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>One word (32-bit) is transferred for every PDMA operation</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>One byte (8-bit) is transferred for every PDMA operation</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>One half-word (16-bit) is transferred for every PDMA operation</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Reserved</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TRIGEN</name>
              <description>Trigger Enable Bit \nNote1: When PDMA transfer completed, this bit will be cleared automatically.\nNote2: If the bus error occurs, all PDMA transfer will be stopped. User must reset all PDMA channels, and then trigger again.</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PDMA data transfer Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PDMA_SAn</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_SAn</displayName>
          <description>PDMA Channel n Source Address Register</description>
          <addressOffset>0x4</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SA</name>
              <description>PDMA Transfer Source Address Bits\nThis field indicates a 32-bit source address of PDMA.\nNote: The source address must be word alignment.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PDMA_DAn</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_DAn</displayName>
          <description>PDMA Channel n Destination Address Register</description>
          <addressOffset>0x8</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DA</name>
              <description>PDMA Transfer Destination Address Bits\nThis field indicates a 32-bit destination address of PDMA.\nNote: The Destination address must be word alignment.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PDMA_CNTn</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_CNTn</displayName>
          <description>PDMA Channel n Transfer Count Register</description>
          <addressOffset>0xC</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TCNT</name>
              <description>PDMA Transfer Count Bits\nThis field indicates a 16-bit transfer count number of PDMA.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PCNTITH</name>
              <description>PDMA Periodic Count Interrupt Threshold\nThis field indicates how many data transferred to generate periodic interrupt\nNote: write 0 to this field to disable this function.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PDMA_CSAn</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_CSAn</displayName>
          <description>PDMA Channel n Current Source Address Register</description>
          <addressOffset>0x14</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CSA</name>
              <description>PDMA Current Source Address Bits (Read Only)\nThis field indicates the source address where the PDMA transfer just occurred.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PDMA_CDAn</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_CDAn</displayName>
          <description>PDMA Channel n Current Destination Address Register</description>
          <addressOffset>0x18</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CDA</name>
              <description>PDMA Current Destination Address Bits (Read Only)\nThis field indicates the destination address where the PDMA transfer just occurred.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PDMA_CCNTn</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_CCNTn</displayName>
          <description>PDMA Channel n Current Transfer Count Register</description>
          <addressOffset>0x1C</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CCNT</name>
              <description>PDMA Current Count Bits (Read Only)\nThis field indicates the current remained transfer count of PDMA.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PDMA_INTENn</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_INTENn</displayName>
          <description>PDMA Channel n Interrupt Enable Register</description>
          <addressOffset>0x20</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000001</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TABTIEN</name>
              <description>PDMA Read/Write Target Abort Interrupt Enable Bit</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Target abort interrupt Disabled during PDMA transfer</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Target abort interrupt Enabled during PDMA transfer</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TDIEN</name>
              <description>PDMA Transfer Done Interrupt Enable Bit</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Interrupt Disabled when PDMA transfer is done</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Interrupt Enabled when PDMA transfer is done</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TOUTIEN</name>
              <description>Time-out Interrupt Enable Bit</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Time-out interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Time-out interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PCNTIEN</name>
              <description>Periodic Count Interrupt Enable Bit\nThis field indicates how many data transferred to generate interrupt periodically. </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Periodic transfer count interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Periodic transfer count interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PDMA_INTSTSn</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_INTSTSn</displayName>
          <description>PDMA Channel n Interrupt Status Register</description>
          <addressOffset>0x24</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TABTIF</name>
              <description>PDMA Read/Write Target Abort Interrupt Status Flag\nNote1: This bit is cleared by writing "1" to it.\nNote2: This bit indicates bus master received error response or not, if bus master received error response, it means that PDMA transfer data from an invalid address or to an invalid adress .At this time target abort is happened..PDMA controller will stop transfer and respond this event to user then go to IDLE state. When target abort occurred, user must reset PDMA controller, and then transfer those data again.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No bus ERROR response received</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Bus ERROR response received</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TDIF</name>
              <description>Transfer Done Interrupt Status Flag\nThis bit indicates that PDMA has finished all transfer.\nNote: This bit is cleared by writing "1" to it.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Not finished yet</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Done</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TOUTIF</name>
              <description>Time-out Interrupt Status Flag\nThis flag indicated that PDMA has waited peripheral request for a period defined by PDMA_TOC.\nNote: This bit is cleared by writing "1" to it.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No time-out flag</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Time-out flag</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PCNTIF</name>
              <description>Periodic Count Interrupt Status Flag\nNote: This bit is cleared by writing "1" to it.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PDMA_TOCn</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_TOCn</displayName>
          <description>PDMA Channel n Time-out Counter Register</description>
          <addressOffset>0x28</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TOC</name>
              <description>PDMA Time-out Period Counter</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TPSC</name>
              <description>PDMA Time-out Counter Clock Source Prescaler</description>
              <bitOffset>16</bitOffset>
              <bitWidth>3</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PDMA time-out clock source is HCLK/28</description>
                    <value>#000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PDMA time-out clock source is HCLK/29</description>
                    <value>#001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>PDMA time-out clock source is HCLK/210</description>
                    <value>#010</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>PDMA time-out clock source is HCLK/211</description>
                    <value>#011</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>4</name>
                    <description>PDMA time-out clock source is HCLK/212</description>
                    <value>#100</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>5</name>
                    <description>PDMA time-out clock source is HCLK/213</description>
                    <value>#101</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>6</name>
                    <description>PDMA time-out clock source is HCLK/214</description>
                    <value>#110</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>7</name>
                    <description>PDMA time-out clock source is HCLK/215</description>
                    <value>#111</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>PDMA_GCR</name>
      <description>PDMA Register Map</description>
      <groupName>PDMA</groupName>
      <baseAddress>0x50008F00</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x0</offset>
        <size>0x10</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>PDMA_GCTL</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_GCTL</displayName>
          <description>PDMA Global Control Register</description>
          <addressOffset>0x0</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CKEN1</name>
              <description>PDMA Controller Channel 1 Clock Enable Bit</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PDMA channel 1 clock Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PDMA channel 1 clock Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CKEN2</name>
              <description>PDMA Controller Channel 2 Clock Enable Bit</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PDMA channel 2 clock Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PDMA channel 2 clock Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CKEN3</name>
              <description>PDMA Controller Channel 3 Clock Enable Bit</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PDMA channel 3 clock Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PDMA channel 3 clock Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CKEN4</name>
              <description>PDMA Controller Channel 4 Clock Enable Bit</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PDMA channel 4 clock Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PDMA channel 4 clock Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CKENCRC</name>
              <description>CRC Controller Clock Enable Bit</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>CRC channel clock Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>CRC channel clock Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PDMA_REQSEL0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_REQSEL0</displayName>
          <description>PDMA Request Source Select Register 0</description>
          <addressOffset>0x4</addressOffset>
          <access>read-write</access>
          <resetValue>0x1F1F1F00</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>REQSRC1</name>
              <description>Channel 1 Request Source Selection\nThis filed defines which peripheral is connected to PDMA channel 1. User can configure the peripheral by setting REQSRC1</description>
              <bitOffset>8</bitOffset>
              <bitWidth>5</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Connect to SPI0_TX</description>
                    <value>#00000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Connect to SPI1_TX</description>
                    <value>#00001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Connect to UART0_TX</description>
                    <value>#00010</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Connect to UART1_TX</description>
                    <value>#00011</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>4</name>
                    <description>Reserved</description>
                    <value>#00100</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>5</name>
                    <description>Connect to SPI3_TX</description>
                    <value>#00101</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>6</name>
                    <description>Reserved</description>
                    <value>#00110</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>7</name>
                    <description>Reserved</description>
                    <value>#00111</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>8</name>
                    <description>Connect to SPI2_TX</description>
                    <value>#01000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>9</name>
                    <description>Connect to TMR0</description>
                    <value>#01001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>10</name>
                    <description>Connect to TMR1</description>
                    <value>#01010</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>11</name>
                    <description>Connect to TMR2</description>
                    <value>#01011</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>12</name>
                    <description>Connect to TMR3</description>
                    <value>#01100</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>16</name>
                    <description>Connect to SPI0_RX</description>
                    <value>#10000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>17</name>
                    <description>Connect to SPI1_RX</description>
                    <value>#10001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>18</name>
                    <description>Connect to UART0_RX</description>
                    <value>#10010</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>19</name>
                    <description>Connect to UART1_RX</description>
                    <value>#10011</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>20</name>
                    <description>Reserved</description>
                    <value>#10100</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>21</name>
                    <description>Connect to SPI3_RX</description>
                    <value>#10101</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>22</name>
                    <description>Connect to ADC</description>
                    <value>#10110</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>23</name>
                    <description>Reserved</description>
                    <value>#10111</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>24</name>
                    <description>Connect to SPI2_RX</description>
                    <value>#11000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>25</name>
                    <description>Reserved</description>
                    <value>#11001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>26</name>
                    <description>Reserved</description>
                    <value>#11010</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>27</name>
                    <description>Reserved</description>
                    <value>#11011</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>28</name>
                    <description>Reserved</description>
                    <value>#11100</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>REQSRC2</name>
              <description>Channel 2 Request Source Selection\nThis filed defines which peripheral is connected to PDMA channel 2. User can configure the peripheral setting by REQSRC2. \nNote: The channel configuration is the same as REQSRC1 field. Please refer to the explanation of REQSRC1.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>REQSRC3</name>
              <description>Channel 3 Request Source Selection\nThis filed defines which peripheral is connected to PDMA channel 3. User can configure the peripheral setting by REQSRC3. \nNote: The channel configuration is the same as REQSRC1 field. Please refer to the explanation of REQSRC1.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PDMA_REQSEL1</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_REQSEL1</displayName>
          <description>PDMA Request Source Select Register 1</description>
          <addressOffset>0x8</addressOffset>
          <access>read-write</access>
          <resetValue>0x0000001F</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>REQSRC4</name>
              <description>Channel 4 Request Source Selection\nThis filed defines which peripheral is connected to PDMA channel 4. User can configure the peripheral setting by REQSRC4. \nNote: The channel configuration is the same as REQSRC1 field. Please refer to the explanation of REQSRC1.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PDMA_GINTSTS</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_GINTSTS</displayName>
          <description>PDMA Global Interrupt Status Register</description>
          <addressOffset>0xC</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>IF1</name>
              <description>PDMA Channel 1 Interrupt Status (Read Only)\nThis bit indicates the interrupt status of PDMA channel 1.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>IF2</name>
              <description>PDMA Channel 2 Interrupt Status Flag of (Read Only)\nThis bit indicates the interrupt status of PDMA channel 2.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>IF3</name>
              <description>PDMA Channel 3 Interrupt Status (Read Only)\nThis bit indicates the interrupt status of PDMA channel 3.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>IF4</name>
              <description>PDMA Channel 4 Interrupt Status Flag (Read Only)\nThis bit indicates the interrupt status of PDMA channel 4.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>IFCRC</name>
              <description>CRC Controller Interrupt Status Flag (Read Only)\nThis bit indicates the interrupt status of CRC controller</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>TMR01</name>
      <description>TMR Register Map</description>
      <groupName>TMR</groupName>
      <baseAddress>0x40010000</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x0</offset>
        <size>0x1C</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x20</offset>
        <size>0x4</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x100</offset>
        <size>0x1C</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x120</offset>
        <size>0x4</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x200</offset>
        <size>0x18</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>TIMER0_CTL</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>TIMER0_CTL</displayName>
          <description>Timer 0 Control and Status Register</description>
          <addressOffset>0x0</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CNTEN</name>
              <description>Timer Counting Enable Bit\nNote3: Writing this bit 1 will not take any effect if RSTCNT (TIMERx_CTL[1]) is also set to 1 at the same time.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Stops/Suspends counting</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Starts counting</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RSTCNT</name>
              <description>Timer Counter Reset Bit\nSetting this bit will reset the internal 8-bit prescale counter, 24-bit up counter value CNT (TIMERx_CNT[23:0]) and also force CNTEN (TIMERx_CTL[0]) to 0.\nNote: This bit will be auto cleared and takes at least 3 TIMERx_CLK clock cycles.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reset internal 8-bit prescale counter, 24-bit up counter value and CNTEN bit</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>WKEN</name>
              <description>Wake-up Function Enable Bit\nIf this bit is set to 1, while CNTIF (TIMERx_INTSTS[0]) or CAPIF (TIMERx_INTSTS[1]) is 1, the timer interrupt signal will generate a wake-up trigger event to CPU.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Wake-up function Disabled if timer interrupt signal generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Wake-up function Enabled if timer interrupt signal generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ICEDEBUG</name>
              <description>ICE Debug Mode Acknowledge Disable Bit\nTimer counter will keep going no matter CPU is held by ICE or not.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>ICE debug mode acknowledgement affects TIMER counting</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>ICE debug mode acknowledgement Disabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>OPMODE</name>
              <description>Timer Counting Mode Selection</description>
              <bitOffset>4</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The Timer controller is operated in One-shot mode</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The Timer controller is operated in Periodic mode</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>The Timer controller is operated in Toggle-output mode</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>The Timer controller is operated in Continuous Counting mode</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ACTSTS</name>
              <description>Timer Active Status Bit (Read Only)\nThis bit indicates the 24-bit up counter status.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>24-bit up counter is not active</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>24-bit up counter is active</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>TRGADC</name>
              <description>Trigger ADC Enable Bit\nIf this bit is set to 1, timer time-out interrupt or capture interrupt can trigger ADC.\nNote: If TRGSSEL (TIMERx_CTL[11]) is set to 0, the time-out interrupt signal will trigger ADC.\nIf TRGSSEL (TIMERx_CTL[11]) is set to 1, the capture interrupt signal will trigger ADC.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Timer interrupt trigger ADC Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Timer interrupt trigger ADC Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TRGPDMA</name>
              <description>Timer Trigger PDMA EnableBit\nIf this bit is set to 1, timer time-out interrupt or capture interrupt can trigger PDMA.\nNote: If TRGSSEL (TIMERx_CTL[11]) is set to 0, the time-out interrupt signal will trigger PDMA.\nIf TRGSSEL (TIMERx_CTL[11]) is set to 1, the capture interrupt signal will trigger PDMA.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Timer interrupt trigger PDMADisabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Timer interrupt trigger PDMAEnabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TRGSSEL</name>
              <description>Trigger Source Selection\nIf this bit is set to 1, capture interrupt can trigger ADC, PDMA and PWM. Otherwise, time-out interrupt can trigger ADC, PDMA and PWM.</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Time-out interrupt is used to trigger ADC, PDMA and PWM</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Capture interrupt is used to trigger ADC, PDMA and PWM</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>EXTCNTEN</name>
              <description>Event Counter Mode Enable Bit\nThis bit is for external counting pin function enabled. \nNote: When timer is used as an event counter, this bit should be set to 1 and HCLK as timer clock source.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Event counter mode Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Event counter mode Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CNTPHASE</name>
              <description>Timer External Count Phase</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>A Falling edge of external counting pin will be counted</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>A Rising edge of external counting pin will be counted</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CNTDBEN</name>
              <description>Timer Counter Pin De-bounce Enable Bit\nNote: If this bit is set to 1, the edge detection of Tx pin is detected with de-bounce circuit.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Tx (x= 0~3) pin de-bounce Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Tx (x= 0~3) pin de-bounce Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CAPEN</name>
              <description>Timer External Capture Pin Enable Bit\nThis bit enables the Tx_EXT pin. </description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Tx_EXT (x= 0~3) pin Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Tx_EXT (x= 0~3) pin Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CAPFUNCS</name>
              <description>Capture Function Selection</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>External Capture Mode Enabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>External Reset Mode Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CAPEDGE</name>
              <description>Timer External Capture Pin Edge Detection\nFor timer counter reset function and free-counting mode of timer capture function, the configurations are:</description>
              <bitOffset>18</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>A Falling edge on Tx_EXT (x= 0~3) pin will be detected.\n1stfalling edge on TC pin triggers 24-bit timer to start counting, while 2nd falling edge triggers 24-bit timer to stop counting</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>A Rising edge on Tx_EXT (x= 0~3) pin will be detected.\n1st rising edge on TC pin triggers 24-bit timer to start counting, while 2nd rising edge triggers 24-bit timer to stop counting</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Either Rising or Falling edge on Tx_EXT (x= 0~3) pin will be detected.\nFalling edge on TC pin triggers 24-bit timer to start counting, while rising edge triggers 24-bit timer to stop counting</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Either Rising or Falling edge on Tx_EXT (x= 0~3) pin will be detected.\nRising edge on TC pin triggers 24-bit timer to start counting, while falling edge triggers 24-bit timer to stop counting</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CAPCNTMD</name>
              <description>Timer Capture Counting Mode Selection\nThis bit indicates the behavior of 24-bit up-counting timer while CAPEN (TIMERx_CTL[16]) is set to high.\nIf this bit is 0, the free-counting mode, the behavior of 24-bit up-counting timer is defined by OPMODE (TIMERx_CTL[5:4]) field. When CAPEN (TIMERx_CTL[16]) is set, CAPFUNCS (TIMERx_CTL[17]) is 0, and the transition of TC pin matches the CAPEDGE (TIMERx_CTL[19:18]) setting, the value of 24-bit up-counting timer will be saved into register TIMERx_CAP.\nIf this bit is 1, Trigger-counting mode, 24-bit up-counting timer will be not counting and keep its value at 0. When CAPEN (TIMERx_CTL[16]) is set, CAPFUNCS (TIMERx_CTL[17]) is 0, and once the transition of external pin matches the 1st transition of CAPEDGE (TIMERx_CTL[19:18]) setting, the 24-bit up-counting timer will start counting. And then if the transition of external pin matches the 2nd transition of CAPEDGE (TIMERx_CTL[19:18]) setting, the 24-bit up-counting timer will stop counting. And its value will be saved into register TIMERx_CAP.</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Capture with free-counting timer mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Capture with trigger-counting timer mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CAPDBEN</name>
              <description>Timer External Capture Pin De-bounce Enable Bit\nNote1: If this bit is enabled, the edge detection of Tx_EXT pin is detected with de-bounce circuit.\nNote2: For Timer 1 and 3, when INTRTGEN (TIMERx_CTL[24]) is high, the capture signal is from internal of chip and the de-bounce circuit would not take effect no matter this bit is high or low.</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Tx_EXT (x= 0~3) pin de-bounce Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Tx_EXT (x= 0~3) pin de-bounce Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CMPCTL</name>
              <description>Timer Compared Mode Selection\nIf updated CMPDAT (TIMERx_CMP) value   CNT (TIMERx_CNT), CNT (TIMERx_CNT) will be reset to default value. At the same time, prescale counter reloaded.</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The behavior selection in one-shot, periodic or Toggle-output mode Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The behavior selection in one-shot, periodic or Toggle-output mode Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>INTRTGEN</name>
              <description>Inter-timer Trigger Function EnableBit\nNote:In TIMERx+1_CTL, this bit is always 0.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Inter-timer trigger function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Inter-timer trigger function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>INTRTGMD</name>
              <description>Inter-timer Trigger Mode Selection\nNote:In TIMERx+1_CTL, this bit is always 0.</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>TIMERx count the all input events from Tx pin</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>TIMERx ignored the number of first incoming events based on EVNTDPCNT (TIMERx_ECTL[31:24])</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TRGPWM</name>
              <description>Trigger PWM EnableBit\nIf this bit is set to 1, timer time-out interrupt or capture interrupt can trigger PWM.</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Timer interrupt trigger PWM Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Timer interrupt trigger PWM Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DSRCCTLF</name>
              <description>DSRC Control Timer Flag (Read Only)\nThis flag high indicates this timer is being controlled by DSRC. When DSRCCTLF is 1, write operation to register of this timer wouldn't take any effect.\nNote1:This bit is read only. Write operation wouldn't take any effect.\nNote2: This bit is only valid in Timer2. In Timer0, Timer1 and Timer3, read this bit always get 0.</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>DSRC control Timer Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>DSRC control Timer Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>TIMER0_PRECNT</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>TIMER0_PRECNT</displayName>
          <description>Timer 0 Pre-Scale Counter Register</description>
          <addressOffset>0x4</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PSC</name>
              <description>Prescale Counter\nNote: If the PSC value is changed, CNT (TIMERx_CNT) is reset to 0 and prescale counter is reloaded.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>TIMER0_CMP</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>TIMER0_CMP</displayName>
          <description>Timer 0 Compare Register</description>
          <addressOffset>0x8</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CMPDAT</name>
              <description>Timer Compared Value\nCMPDAT is a 24-bit compared value register. When the internal 24-bit up counter value is equal to CMPDAT value, the CNTIF (TIMERx_INTSTS[0] Timer Interrupt Flag) will be set to 1.\nNote1: Never write 0x0 or 0x1 in CMPDAT, or the core will run into unknown state.\nNote2:When the timer is operating in Continuous Counting mode (OPMODE (TIMERx_CTL[5:4] is 11), the 24-bit up counter will keep counting continuously even if user writes a new value into CMPDAT field. \nNote3: Whenthe timer is not operating inContinuous Counting mode (OPMODE (TIMERx_CTL[5:4] is not 11), the 24-bit up counter will restart counting from 0 and usethe newest CMPDAT value as the timer compared value when user writes a new value into the CMPDAT field.In addition, the prescale counter will be reloaded.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>TIMER0_INTEN</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>TIMER0_INTEN</displayName>
          <description>Timer 0 Interrupt Enable Register</description>
          <addressOffset>0xC</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CNTIEN</name>
              <description>Timer Interrupt EnableBit\nNote:If this bit is enabled, when the timer interrupt flag CNTIF(TIMERx_INTSTS[0]) is set to 1, the timer interrupt signal is generated and informed to CPU.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Timer Interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Timer Interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CAPIEN</name>
              <description>Timer External Capture Interrupt Enable Bit\nNote:CAPIEN is used to enable timer external interrupt. If CAPIEN is enabled, the timer will rise an interrupt when CAPIF (TIMERx_INTSTS[1]) is 1.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Tx_EXT (x= 0~3) pin detection Interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Tx_EXT (x= 0~3) pin detection Interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>TIMER0_INTSTS</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>TIMER0_INTSTS</displayName>
          <description>Timer 0 Interrupt Status Register</description>
          <addressOffset>0x10</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CNTIF</name>
              <description>Timer Interrupt Status\nThis bit indicates the interrupt flag status of Timer while 24-bit timer up counter CNT (TIMERx_CNT[23:0]) value reaches to CMPDAT (TIMERx_CMP[23:0]) value.\nNote: This bit is cleared by writing 1 to it.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>CNT (TIMERx_CNT[23:0])value matches the CMPDAT (TIMERx_CMP[23:0]) value</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CAPIF</name>
              <description>Timer External Capture Interrupt Flag\nThis bit indicates the timer external capture interrupt flag status.\nNote3: If a new incoming capture event detected before CPU clearing the CAPIF status, the Timer will keep register TIMERx_CAP unchanged and drop the new capture value.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Tx_EXT (x= 0~3) pin interrupt did not occur</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Tx_EXT (x= 0~3) pin interrupt occurred</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TWKF</name>
              <description>Timer Wake-up Flag\nThis bit indicates the interrupt wake-up flag status of timer.\nNote: This bit is cleared by writing 1 to it.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Timer does not cause CPU wake-up</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>CPU wake-up from Idle or Power-down mode if timer time-out interrupt signal generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CAPDATOF</name>
              <description>Capture Data Overflow Flag\nThis status is to indicate there is a new incoming capture event detected before CPU clearing the CAPIF (TIMERx_INTSTS[1]) status.\nIf the above condition occurred, the Timer will keep register TIMERx_CAP unchanged and drop the new capture value.\nNote: This bit is cleared by writing 1 to it.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>New incoming capture event didn't detect before CPU clearing CAPIF (TIMERx_INTSTS[1]) status</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>New incoming capture event detected before CPU clearing CAPIF (TIMERx_INTSTS[1]) status</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CAPFEDF</name>
              <description>Capture Falling Edge Detected Flag\nThis flag indicates theedge detected on Tx_EXT pin is rising edge or falling edge.\nNote1: The timer updates this flag when it updates the Timer Capture Data (TMR_CAP[23:0]) value.\nNote2:When a new incoming capture event detected before CPU clearing the CAPIF (TIMERx_INTSTS[1]) status, Timer will keep this bit unchanged.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Rising edge detected on Tx_EXT pin</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Falling edge detected on Tx_EXT pin</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>TIMER0_CNT</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>TIMER0_CNT</displayName>
          <description>Timer 0Counter Data Register</description>
          <addressOffset>0x14</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CNT</name>
              <description>Timer Counter Data (Read)\nCounter Reset (Write)\nUser can write any value to TIEMRx_CNT to reset internal 24-bit timer up-counter and 8-bit pre-scale counter. This reset operation wouldn't affect any other timer control registers and circuit. After reset completed, the 24-bit timer up-counter and 8-bit pre-scale counter restart the counting based on the TIMERx_CTL register setting.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RSTACT</name>
              <description>Reset Active\nThis bit indicates if the counter reset operation active.\nWhen user write this register, timer starts to reset its internal 24-bit timer up-counter and 8-bit pre-scale counter to 0. At the same time, timer set this flag to 1 to indicate the counter reset operation is in progress. Once the counter reset operation done, timer clear this bit to 0 automatically.\nNote: This bit is read only. Write operation wouldn't take any effect.</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Reset operation is done</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reset operation triggered by writing TIMERx_CNT is in progress</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>TIMER0_CAP</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>TIMER0_CAP</displayName>
          <description>Timer 0 Capture Data Register</description>
          <addressOffset>0x18</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CAPDAT</name>
              <description>Timer Capture Data Register\nWhen CAPEN (TIMERx_CTL[16]) bit is set, CAPFUNCS (TIMERx_CTL[17]) bit is 0, CAPCNTMD (TIMERx_CTL[20]) bit is 0, and the transition on Tx_EXT pin matched the CAPEDGE (TIMERx_CTL[19:18]) setting, CAPIF (TIMERx_INTSTS[1]) will set to 1 and the current timer counter value CNT (TIMERx_CNT[23:0]) will be auto-loaded into this CAPDAT field.\nWhen CAPEN (TIMERx_CTL[16]) bit is set, CAPFUNCS (TIMERx_CTL[17]) bit is 0, CAPCNTMD (TIMERx_CTL[20]) bit is 1, and the transition on Tx_EXT pin matched the 2nd transition of CAPEDGE (TIMERx_CTL[19:18]) setting, CAPIF (TIMERx_INTSTS[1]) will set to 1 and the current timer counter value CNT (TIMERx_CNT[23:0]) will be auto-loaded into this CAPDAT field.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>TIMER0_ECTL</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>TIMER0_ECTL</displayName>
          <description>Timer 0Extended Control Register</description>
          <addressOffset>0x20</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>EVNTDPCNT</name>
              <description>Event Drop Count\nThis field indicates timer how many events dropped after inter-timer trigger function enable.\nFor example, if user configured EVNTDPCNT to 7, timer would drop 7 first incoming events and starts the inter-timer trigger operation when it get 8th event.\nNote: ECNTDPCNT only takes effect when INTRTGEN (TIMERx_CTL[24]) INTRTGMD (TIMERx_CTL[25]) are both set to 1.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="TIMER0_CTL">
          <name>TIMER1_CTL</name>
          <displayName>TIMER1_CTL</displayName>
          <description>Timer 1 Control and Status Register</description>
          <addressOffset>0x100</addressOffset>
       </register>
       <register derivedFrom="TIMER0_PRECNT">
          <name>TIMER1_PRECNT</name>
          <displayName>TIMER1_PRECNT</displayName>
          <description>Timer 1 Pre-Scale Counter Register</description>
          <addressOffset>0x104</addressOffset>
       </register>
       <register derivedFrom="TIMER0_CMP">
          <name>TIMER1_CMP</name>
          <displayName>TIMER1_CMP</displayName>
          <description>Timer 1 Compare Register</description>
          <addressOffset>0x108</addressOffset>
       </register>
       <register derivedFrom="TIMER0_INTEN">
          <name>TIMER1_INTEN</name>
          <displayName>TIMER1_INTEN</displayName>
          <description>Timer 1 Interrupt Enable Register</description>
          <addressOffset>0x10C</addressOffset>
       </register>
       <register derivedFrom="TIMER0_INTSTS">
          <name>TIMER1_INTSTS</name>
          <displayName>TIMER1_INTSTS</displayName>
          <description>Timer 1 Interrupt Status Register</description>
          <addressOffset>0x110</addressOffset>
       </register>
       <register derivedFrom="TIMER0_CNT">
          <name>TIMER1_CNT</name>
          <displayName>TIMER1_CNT</displayName>
          <description>Timer 1 Counter Data Register</description>
          <addressOffset>0x114</addressOffset>
       </register>
       <register derivedFrom="TIMER0_CAP">
          <name>TIMER1_CAP</name>
          <displayName>TIMER1_CAP</displayName>
          <description>Timer 1 Capture Data Register</description>
          <addressOffset>0x118</addressOffset>
       </register>
       <register derivedFrom="TIMER0_ECTL">
          <name>TIMER1_ECTL</name>
          <displayName>TIMER1_ECTL</displayName>
          <description>Timer 1 Extended Control Register</description>
          <addressOffset>0x120</addressOffset>
       </register>
       <register>
          <name>GPA_SHADOW</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>GPA_SHADOW</displayName>
          <description>GPIO Port A Pin Value Shadow Register</description>
          <addressOffset>0x200</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFF0000</resetMask>
          <fields>
            <field>
              <name>PIN0</name>
              <description>GPIO Port [A/B/C/D/E/F] Pin Values\nThe value read from each of these bit reflects the actual status of the respective GPIO pin.\nThese registers are shadow registers of GPIOx_PIN register.\nNote 1: For GPE_SHADOW, bits [15:10] are reserved.\nNote2: For GPF_SHADOW, bits [15:6] are reserved.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PIN1</name>
              <description>GPIO Port [A/B/C/D/E/F] Pin Values\nThe value read from each of these bit reflects the actual status of the respective GPIO pin.\nThese registers are shadow registers of GPIOx_PIN register.\nNote 1: For GPE_SHADOW, bits [15:10] are reserved.\nNote2: For GPF_SHADOW, bits [15:6] are reserved.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PIN2</name>
              <description>GPIO Port [A/B/C/D/E/F] Pin Values\nThe value read from each of these bit reflects the actual status of the respective GPIO pin.\nThese registers are shadow registers of GPIOx_PIN register.\nNote 1: For GPE_SHADOW, bits [15:10] are reserved.\nNote2: For GPF_SHADOW, bits [15:6] are reserved.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PIN3</name>
              <description>GPIO Port [A/B/C/D/E/F] Pin Values\nThe value read from each of these bit reflects the actual status of the respective GPIO pin.\nThese registers are shadow registers of GPIOx_PIN register.\nNote 1: For GPE_SHADOW, bits [15:10] are reserved.\nNote2: For GPF_SHADOW, bits [15:6] are reserved.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PIN4</name>
              <description>GPIO Port [A/B/C/D/E/F] Pin Values\nThe value read from each of these bit reflects the actual status of the respective GPIO pin.\nThese registers are shadow registers of GPIOx_PIN register.\nNote 1: For GPE_SHADOW, bits [15:10] are reserved.\nNote2: For GPF_SHADOW, bits [15:6] are reserved.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PIN5</name>
              <description>GPIO Port [A/B/C/D/E/F] Pin Values\nThe value read from each of these bit reflects the actual status of the respective GPIO pin.\nThese registers are shadow registers of GPIOx_PIN register.\nNote 1: For GPE_SHADOW, bits [15:10] are reserved.\nNote2: For GPF_SHADOW, bits [15:6] are reserved.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PIN6</name>
              <description>GPIO Port [A/B/C/D/E/F] Pin Values\nThe value read from each of these bit reflects the actual status of the respective GPIO pin.\nThese registers are shadow registers of GPIOx_PIN register.\nNote 1: For GPE_SHADOW, bits [15:10] are reserved.\nNote2: For GPF_SHADOW, bits [15:6] are reserved.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PIN7</name>
              <description>GPIO Port [A/B/C/D/E/F] Pin Values\nThe value read from each of these bit reflects the actual status of the respective GPIO pin.\nThese registers are shadow registers of GPIOx_PIN register.\nNote 1: For GPE_SHADOW, bits [15:10] are reserved.\nNote2: For GPF_SHADOW, bits [15:6] are reserved.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PIN8</name>
              <description>GPIO Port [A/B/C/D/E/F] Pin Values\nThe value read from each of these bit reflects the actual status of the respective GPIO pin.\nThese registers are shadow registers of GPIOx_PIN register.\nNote 1: For GPE_SHADOW, bits [15:10] are reserved.\nNote2: For GPF_SHADOW, bits [15:6] are reserved.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PIN9</name>
              <description>GPIO Port [A/B/C/D/E/F] Pin Values\nThe value read from each of these bit reflects the actual status of the respective GPIO pin.\nThese registers are shadow registers of GPIOx_PIN register.\nNote 1: For GPE_SHADOW, bits [15:10] are reserved.\nNote2: For GPF_SHADOW, bits [15:6] are reserved.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PIN10</name>
              <description>GPIO Port [A/B/C/D/E/F] Pin Values\nThe value read from each of these bit reflects the actual status of the respective GPIO pin.\nThese registers are shadow registers of GPIOx_PIN register.\nNote 1: For GPE_SHADOW, bits [15:10] are reserved.\nNote2: For GPF_SHADOW, bits [15:6] are reserved.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PIN11</name>
              <description>GPIO Port [A/B/C/D/E/F] Pin Values\nThe value read from each of these bit reflects the actual status of the respective GPIO pin.\nThese registers are shadow registers of GPIOx_PIN register.\nNote 1: For GPE_SHADOW, bits [15:10] are reserved.\nNote2: For GPF_SHADOW, bits [15:6] are reserved.</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PIN12</name>
              <description>GPIO Port [A/B/C/D/E/F] Pin Values\nThe value read from each of these bit reflects the actual status of the respective GPIO pin.\nThese registers are shadow registers of GPIOx_PIN register.\nNote 1: For GPE_SHADOW, bits [15:10] are reserved.\nNote2: For GPF_SHADOW, bits [15:6] are reserved.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PIN13</name>
              <description>GPIO Port [A/B/C/D/E/F] Pin Values\nThe value read from each of these bit reflects the actual status of the respective GPIO pin.\nThese registers are shadow registers of GPIOx_PIN register.\nNote 1: For GPE_SHADOW, bits [15:10] are reserved.\nNote2: For GPF_SHADOW, bits [15:6] are reserved.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PIN14</name>
              <description>GPIO Port [A/B/C/D/E/F] Pin Values\nThe value read from each of these bit reflects the actual status of the respective GPIO pin.\nThese registers are shadow registers of GPIOx_PIN register.\nNote 1: For GPE_SHADOW, bits [15:10] are reserved.\nNote2: For GPF_SHADOW, bits [15:6] are reserved.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PIN15</name>
              <description>GPIO Port [A/B/C/D/E/F] Pin Values\nThe value read from each of these bit reflects the actual status of the respective GPIO pin.\nThese registers are shadow registers of GPIOx_PIN register.\nNote 1: For GPE_SHADOW, bits [15:10] are reserved.\nNote2: For GPF_SHADOW, bits [15:6] are reserved.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="GPA_SHADOW">
          <name>GPB_SHADOW</name>
          <displayName>GPB_SHADOW</displayName>
          <description>GPIO Port B Pin Value Shadow Register</description>
          <addressOffset>0x204</addressOffset>
       </register>
       <register derivedFrom="GPA_SHADOW">
          <name>GPC_SHADOW</name>
          <displayName>GPC_SHADOW</displayName>
          <description>GPIO Port C Pin Value Shadow Register</description>
          <addressOffset>0x208</addressOffset>
       </register>
       <register derivedFrom="GPA_SHADOW">
          <name>GPD_SHADOW</name>
          <displayName>GPD_SHADOW</displayName>
          <description>GPIO Port D Pin Value Shadow Register</description>
          <addressOffset>0x20C</addressOffset>
       </register>
       <register derivedFrom="GPA_SHADOW">
          <name>GPE_SHADOW</name>
          <displayName>GPE_SHADOW</displayName>
          <description>GPIO Port E Pin Value Shadow Register</description>
          <addressOffset>0x210</addressOffset>
       </register>
       <register derivedFrom="GPA_SHADOW">
          <name>GPF_SHADOW</name>
          <displayName>GPF_SHADOW</displayName>
          <description>GPIO Port F Pin Value Shadow Register</description>
          <addressOffset>0x214</addressOffset>
       </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>TMR23</name>
      <description>TMR Register Map</description>
      <groupName>TMR</groupName>
      <baseAddress>0x40110000</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x0</offset>
        <size>0x1C</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x20</offset>
        <size>0x4</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x100</offset>
        <size>0x1C</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x120</offset>
        <size>0x4</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>TIMER2_CTL</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>TIMER2_CTL</displayName>
          <description>Timer 2 Control and Status Register</description>
          <addressOffset>0x0</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CNTEN</name>
              <description>Timer Counting Enable Bit\nNote3: Writing this bit 1 will not take any effect if RSTCNT (TIMERx_CTL[1]) is also set to 1 at the same time.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Stops/Suspends counting</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Starts counting</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RSTCNT</name>
              <description>Timer Counter Reset Bit\nSetting this bit will reset the internal 8-bit prescale counter, 24-bit up counter value CNT (TIMERx_CNT[23:0]) and also force CNTEN (TIMERx_CTL[0]) to 0.\nNote: This bit will be auto cleared and takes at least 3 TIMERx_CLK clock cycles.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reset internal 8-bit prescale counter, 24-bit up counter value and CNTEN bit</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>WKEN</name>
              <description>Wake-up Function Enable Bit\nIf this bit is set to 1, while CNTIF (TIMERx_INTSTS[0]) or CAPIF (TIMERx_INTSTS[1]) is 1, the timer interrupt signal will generate a wake-up trigger event to CPU.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Wake-up function Disabled if timer interrupt signal generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Wake-up function Enabled if timer interrupt signal generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ICEDEBUG</name>
              <description>ICE Debug Mode Acknowledge Disable Bit\nTimer counter will keep going no matter CPU is held by ICE or not.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>ICE debug mode acknowledgement affects TIMER counting</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>ICE debug mode acknowledgement Disabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>OPMODE</name>
              <description>Timer Counting Mode Selection</description>
              <bitOffset>4</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The Timer controller is operated in One-shot mode</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The Timer controller is operated in Periodic mode</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>The Timer controller is operated in Toggle-output mode</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>The Timer controller is operated in Continuous Counting mode</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ACTSTS</name>
              <description>Timer Active Status Bit (Read Only)\nThis bit indicates the 24-bit up counter status.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>24-bit up counter is not active</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>24-bit up counter is active</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>TRGADC</name>
              <description>Trigger ADC Enable Bit\nIf this bit is set to 1, timer time-out interrupt or capture interrupt can trigger ADC.\nNote: If TRGSSEL (TIMERx_CTL[11]) is set to 0, the time-out interrupt signal will trigger ADC.\nIf TRGSSEL (TIMERx_CTL[11]) is set to 1, the capture interrupt signal will trigger ADC.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Timer interrupt trigger ADC Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Timer interrupt trigger ADC Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TRGPDMA</name>
              <description>Timer Trigger PDMA EnableBit\nIf this bit is set to 1, timer time-out interrupt or capture interrupt can trigger PDMA.\nNote: If TRGSSEL (TIMERx_CTL[11]) is set to 0, the time-out interrupt signal will trigger PDMA.\nIf TRGSSEL (TIMERx_CTL[11]) is set to 1, the capture interrupt signal will trigger PDMA.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Timer interrupt trigger PDMADisabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Timer interrupt trigger PDMAEnabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TRGSSEL</name>
              <description>Trigger Source Selection\nIf this bit is set to 1, capture interrupt can trigger ADC, PDMA and PWM. Otherwise, time-out interrupt can trigger ADC, PDMA and PWM.</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Time-out interrupt is used to trigger ADC, PDMA and PWM</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Capture interrupt is used to trigger ADC, PDMA and PWM</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>EXTCNTEN</name>
              <description>Event Counter Mode Enable Bit\nThis bit is for external counting pin function enabled. \nNote: When timer is used as an event counter, this bit should be set to 1 and HCLK as timer clock source.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Event counter mode Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Event counter mode Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CNTPHASE</name>
              <description>Timer External Count Phase</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>A Falling edge of external counting pin will be counted</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>A Rising edge of external counting pin will be counted</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CNTDBEN</name>
              <description>Timer Counter Pin De-bounce Enable Bit\nNote: If this bit is set to 1, the edge detection of Tx pin is detected with de-bounce circuit.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Tx (x= 0~3) pin de-bounce Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Tx (x= 0~3) pin de-bounce Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CAPEN</name>
              <description>Timer External Capture Pin Enable Bit\nThis bit enables the Tx_EXT pin. </description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Tx_EXT (x= 0~3) pin Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Tx_EXT (x= 0~3) pin Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CAPFUNCS</name>
              <description>Capture Function Selection</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>External Capture Mode Enabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>External Reset Mode Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CAPEDGE</name>
              <description>Timer External Capture Pin Edge Detection\nFor timer counter reset function and free-counting mode of timer capture function, the configurations are:</description>
              <bitOffset>18</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>A Falling edge on Tx_EXT (x= 0~3) pin will be detected.\n1stfalling edge on TC pin triggers 24-bit timer to start counting, while 2nd falling edge triggers 24-bit timer to stop counting</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>A Rising edge on Tx_EXT (x= 0~3) pin will be detected.\n1st rising edge on TC pin triggers 24-bit timer to start counting, while 2nd rising edge triggers 24-bit timer to stop counting</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Either Rising or Falling edge on Tx_EXT (x= 0~3) pin will be detected.\nFalling edge on TC pin triggers 24-bit timer to start counting, while rising edge triggers 24-bit timer to stop counting</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Either Rising or Falling edge on Tx_EXT (x= 0~3) pin will be detected.\nRising edge on TC pin triggers 24-bit timer to start counting, while falling edge triggers 24-bit timer to stop counting</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CAPCNTMD</name>
              <description>Timer Capture Counting Mode Selection\nThis bit indicates the behavior of 24-bit up-counting timer while CAPEN (TIMERx_CTL[16]) is set to high.\nIf this bit is 0, the free-counting mode, the behavior of 24-bit up-counting timer is defined by OPMODE (TIMERx_CTL[5:4]) field. When CAPEN (TIMERx_CTL[16]) is set, CAPFUNCS (TIMERx_CTL[17]) is 0, and the transition of TC pin matches the CAPEDGE (TIMERx_CTL[19:18]) setting, the value of 24-bit up-counting timer will be saved into register TIMERx_CAP.\nIf this bit is 1, Trigger-counting mode, 24-bit up-counting timer will be not counting and keep its value at 0. When CAPEN (TIMERx_CTL[16]) is set, CAPFUNCS (TIMERx_CTL[17]) is 0, and once the transition of external pin matches the 1st transition of CAPEDGE (TIMERx_CTL[19:18]) setting, the 24-bit up-counting timer will start counting. And then if the transition of external pin matches the 2nd transition of CAPEDGE (TIMERx_CTL[19:18]) setting, the 24-bit up-counting timer will stop counting. And its value will be saved into register TIMERx_CAP.</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Capture with free-counting timer mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Capture with trigger-counting timer mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CAPDBEN</name>
              <description>Timer External Capture Pin De-bounce Enable Bit\nNote1: If this bit is enabled, the edge detection of Tx_EXT pin is detected with de-bounce circuit.\nNote2: For Timer 1 and 3, when INTRTGEN (TIMERx_CTL[24]) is high, the capture signal is from internal of chip and the de-bounce circuit would not take effect no matter this bit is high or low.</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Tx_EXT (x= 0~3) pin de-bounce Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Tx_EXT (x= 0~3) pin de-bounce Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CMPCTL</name>
              <description>Timer Compared Mode Selection\nIf updated CMPDAT (TIMERx_CMP) value   CNT (TIMERx_CNT), CNT (TIMERx_CNT) will be reset to default value. At the same time, prescale counter reloaded.</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The behavior selection in one-shot, periodic or Toggle-output mode Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The behavior selection in one-shot, periodic or Toggle-output mode Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>INTRTGEN</name>
              <description>Inter-timer Trigger Function EnableBit\nNote:In TIMERx+1_CTL, this bit is always 0.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Inter-timer trigger function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Inter-timer trigger function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>INTRTGMD</name>
              <description>Inter-timer Trigger Mode Selection\nNote:In TIMERx+1_CTL, this bit is always 0.</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>TIMERx count the all input events from Tx pin</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>TIMERx ignored the number of first incoming events based on EVNTDPCNT (TIMERx_ECTL[31:24])</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TRGPWM</name>
              <description>Trigger PWM EnableBit\nIf this bit is set to 1, timer time-out interrupt or capture interrupt can trigger PWM.</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Timer interrupt trigger PWM Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Timer interrupt trigger PWM Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DSRCCTLF</name>
              <description>DSRC Control Timer Flag (Read Only)\nThis flag high indicates this timer is being controlled by DSRC. When DSRCCTLF is 1, write operation to register of this timer wouldn't take any effect.\nNote1:This bit is read only. Write operation wouldn't take any effect.\nNote2: This bit is only valid in Timer2. In Timer0, Timer1 and Timer3, read this bit always get 0.</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>DSRC control Timer Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>DSRC control Timer Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>TIMER2_PRECNT</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>TIMER2_PRECNT</displayName>
          <description>Timer 2 Pre-Scale Counter Register</description>
          <addressOffset>0x4</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PSC</name>
              <description>Prescale Counter\nNote: If the PSC value is changed, CNT (TIMERx_CNT) is reset to 0 and prescale counter is reloaded.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>TIMER2_CMP</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>TIMER2_CMP</displayName>
          <description>Timer 2 Compare Register</description>
          <addressOffset>0x8</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CMPDAT</name>
              <description>Timer Compared Value\nCMPDAT is a 24-bit compared value register. When the internal 24-bit up counter value is equal to CMPDAT value, the CNTIF (TIMERx_INTSTS[0] Timer Interrupt Flag) will be set to 1.\nNote1: Never write 0x0 or 0x1 in CMPDAT, or the core will run into unknown state.\nNote2:When the timer is operating in Continuous Counting mode (OPMODE (TIMERx_CTL[5:4] is 11), the 24-bit up counter will keep counting continuously even if user writes a new value into CMPDAT field. \nNote3: Whenthe timer is not operating inContinuous Counting mode (OPMODE (TIMERx_CTL[5:4] is not 11), the 24-bit up counter will restart counting from 0 and usethe newest CMPDAT value as the timer compared value when user writes a new value into the CMPDAT field.In addition, the prescale counter will be reloaded.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>TIMER2_INTEN</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>TIMER2_INTEN</displayName>
          <description>Timer 2 Interrupt Enable Register</description>
          <addressOffset>0xC</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CNTIEN</name>
              <description>Timer Interrupt EnableBit\nNote:If this bit is enabled, when the timer interrupt flag CNTIF(TIMERx_INTSTS[0]) is set to 1, the timer interrupt signal is generated and informed to CPU.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Timer Interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Timer Interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CAPIEN</name>
              <description>Timer External Capture Interrupt Enable Bit\nNote:CAPIEN is used to enable timer external interrupt. If CAPIEN is enabled, the timer will rise an interrupt when CAPIF (TIMERx_INTSTS[1]) is 1.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Tx_EXT (x= 0~3) pin detection Interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Tx_EXT (x= 0~3) pin detection Interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>TIMER2_INTSTS</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>TIMER2_INTSTS</displayName>
          <description>Timer 2 Interrupt Status Register</description>
          <addressOffset>0x10</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CNTIF</name>
              <description>Timer Interrupt Status\nThis bit indicates the interrupt flag status of Timer while 24-bit timer up counter CNT (TIMERx_CNT[23:0]) value reaches to CMPDAT (TIMERx_CMP[23:0]) value.\nNote: This bit is cleared by writing 1 to it.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>CNT (TIMERx_CNT[23:0])value matches the CMPDAT (TIMERx_CMP[23:0]) value</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CAPIF</name>
              <description>Timer External Capture Interrupt Flag\nThis bit indicates the timer external capture interrupt flag status.\nNote3: If a new incoming capture event detected before CPU clearing the CAPIF status, the Timer will keep register TIMERx_CAP unchanged and drop the new capture value.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Tx_EXT (x= 0~3) pin interrupt did not occur</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Tx_EXT (x= 0~3) pin interrupt occurred</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TWKF</name>
              <description>Timer Wake-up Flag\nThis bit indicates the interrupt wake-up flag status of timer.\nNote: This bit is cleared by writing 1 to it.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Timer does not cause CPU wake-up</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>CPU wake-up from Idle or Power-down mode if timer time-out interrupt signal generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CAPDATOF</name>
              <description>Capture Data Overflow Flag\nThis status is to indicate there is a new incoming capture event detected before CPU clearing the CAPIF (TIMERx_INTSTS[1]) status.\nIf the above condition occurred, the Timer will keep register TIMERx_CAP unchanged and drop the new capture value.\nNote: This bit is cleared by writing 1 to it.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>New incoming capture event didn't detect before CPU clearing CAPIF (TIMERx_INTSTS[1]) status</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>New incoming capture event detected before CPU clearing CAPIF (TIMERx_INTSTS[1]) status</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CAPFEDF</name>
              <description>Capture Falling Edge Detected Flag\nThis flag indicates theedge detected on Tx_EXT pin is rising edge or falling edge.\nNote1: The timer updates this flag when it updates the Timer Capture Data (TMR_CAP[23:0]) value.\nNote2:When a new incoming capture event detected before CPU clearing the CAPIF (TIMERx_INTSTS[1]) status, Timer will keep this bit unchanged.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Rising edge detected on Tx_EXT pin</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Falling edge detected on Tx_EXT pin</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>TIMER2_CNT</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>TIMER2_CNT</displayName>
          <description>Timer 2Counter Data Register</description>
          <addressOffset>0x14</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CNT</name>
              <description>Timer Counter Data (Read)\nCounter Reset (Write)\nUser can write any value to TIEMRx_CNT to reset internal 24-bit timer up-counter and 8-bit pre-scale counter. This reset operation wouldn't affect any other timer control registers and circuit. After reset completed, the 24-bit timer up-counter and 8-bit pre-scale counter restart the counting based on the TIMERx_CTL register setting.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RSTACT</name>
              <description>Reset Active\nThis bit indicates if the counter reset operation active.\nWhen user write this register, timer starts to reset its internal 24-bit timer up-counter and 8-bit pre-scale counter to 0. At the same time, timer set this flag to 1 to indicate the counter reset operation is in progress. Once the counter reset operation done, timer clear this bit to 0 automatically.\nNote: This bit is read only. Write operation wouldn't take any effect.</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Reset operation is done</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reset operation triggered by writing TIMERx_CNT is in progress</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>TIMER2_CAP</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>TIMER2_CAP</displayName>
          <description>Timer 2 Capture Data Register</description>
          <addressOffset>0x18</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CAPDAT</name>
              <description>Timer Capture Data Register\nWhen CAPEN (TIMERx_CTL[16]) bit is set, CAPFUNCS (TIMERx_CTL[17]) bit is 0, CAPCNTMD (TIMERx_CTL[20]) bit is 0, and the transition on Tx_EXT pin matched the CAPEDGE (TIMERx_CTL[19:18]) setting, CAPIF (TIMERx_INTSTS[1]) will set to 1 and the current timer counter value CNT (TIMERx_CNT[23:0]) will be auto-loaded into this CAPDAT field.\nWhen CAPEN (TIMERx_CTL[16]) bit is set, CAPFUNCS (TIMERx_CTL[17]) bit is 0, CAPCNTMD (TIMERx_CTL[20]) bit is 1, and the transition on Tx_EXT pin matched the 2nd transition of CAPEDGE (TIMERx_CTL[19:18]) setting, CAPIF (TIMERx_INTSTS[1]) will set to 1 and the current timer counter value CNT (TIMERx_CNT[23:0]) will be auto-loaded into this CAPDAT field.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>TIMER2_ECTL</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>TIMER2_ECTL</displayName>
          <description>Timer 2Extended Control Register</description>
          <addressOffset>0x20</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>EVNTDPCNT</name>
              <description>Event Drop Count\nThis field indicates timer how many events dropped after inter-timer trigger function enable.\nFor example, if user configured EVNTDPCNT to 7, timer would drop 7 first incoming events and starts the inter-timer trigger operation when it get 8th event.\nNote: ECNTDPCNT only takes effect when INTRTGEN (TIMERx_CTL[24]) INTRTGMD (TIMERx_CTL[25]) are both set to 1.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="TIMER2_CTL">
          <name>TIMER3_CTL</name>
          <displayName>TIMER3_CTL</displayName>
          <description>Timer 3 Control and Status Register</description>
          <addressOffset>0x100</addressOffset>
       </register>
       <register derivedFrom="TIMER2_PRECNT">
          <name>TIMER3_PRECNT</name>
          <displayName>TIMER3_PRECNT</displayName>
          <description>Timer 3 Pre-Scale Counter Register</description>
          <addressOffset>0x104</addressOffset>
       </register>
       <register derivedFrom="TIMER2_CMP">
          <name>TIMER3_CMP</name>
          <displayName>TIMER3_CMP</displayName>
          <description>Timer 3 Compare Register</description>
          <addressOffset>0x108</addressOffset>
       </register>
       <register derivedFrom="TIMER2_INTEN">
          <name>TIMER3_INTEN</name>
          <displayName>TIMER3_INTEN</displayName>
          <description>Timer 3 Interrupt Enable Register</description>
          <addressOffset>0x10C</addressOffset>
       </register>
       <register derivedFrom="TIMER2_INTSTS">
          <name>TIMER3_INTSTS</name>
          <displayName>TIMER3_INTSTS</displayName>
          <description>Timer 3 Interrupt Status Register</description>
          <addressOffset>0x110</addressOffset>
       </register>
       <register derivedFrom="TIMER2_CNT">
          <name>TIMER3_CNT</name>
          <displayName>TIMER3_CNT</displayName>
          <description>Timer 3 Counter Data Register</description>
          <addressOffset>0x114</addressOffset>
       </register>
       <register derivedFrom="TIMER2_CAP">
          <name>TIMER3_CAP</name>
          <displayName>TIMER3_CAP</displayName>
          <description>Timer 3 Capture Data Register</description>
          <addressOffset>0x118</addressOffset>
       </register>
       <register derivedFrom="TIMER2_ECTL">
          <name>TIMER3_ECTL</name>
          <displayName>TIMER3_ECTL</displayName>
          <description>Timer 3 Extended Control Register</description>
          <addressOffset>0x120</addressOffset>
       </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>PWM0</name>
      <description>PWM0 Register Map</description>
      <groupName>PWM0</groupName>
      <baseAddress>0x40040000</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x0</offset>
        <size>0x8</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x10</offset>
        <size>0x18</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x30</offset>
        <size>0x4</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x38</offset>
        <size>0x4</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x40</offset>
        <size>0x4</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x50</offset>
        <size>0x18</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x70</offset>
        <size>0xC</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x90</offset>
        <size>0x4</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x98</offset>
        <size>0x4</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0xA0</offset>
        <size>0x4</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0xB0</offset>
        <size>0x40</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0xF8</offset>
        <size>0x8</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x120</offset>
        <size>0x4</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x200</offset>
        <size>0x3C</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x250</offset>
        <size>0x8</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x300</offset>
        <size>0x8</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x30C</offset>
        <size>0x4</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x314</offset>
        <size>0x4</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x31C</offset>
        <size>0x18</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0xFFC</offset>
        <size>0x4</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>PWM0_CTL0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PWM0_CTL0</displayName>
          <description>PWM0 Control Register 0</description>
          <addressOffset>0x0</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CTRLDn</name>
              <description>Center Re-load\nEach bit n controls the corresponding PWM0 channel n.\nIn up-down counter type, PERIOD will load to PBUF at the end point of each period. CMPDAT will load to CMPBUF at the center point of a period.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>IMMLDENn</name>
              <description>Immediately Load Enable Bits\nEach bit n controls the corresponding PWM0 channel n.\nNote: If IMMLDENn is enabled, WINLDENn and CTRLDn will be invalid.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>6</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PERIOD will load to PBUF at the end point of each period. CMPDAT will load to CMPBUF at the end point or center point of each period by setting CTRLD bit</description>
                    <value>0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PERIOD/CMPDAT will load to PBUF and CMPBUF immediately when software update PERIOD/CMPDAT</description>
                    <value>1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DBGHALT</name>
              <description>ICE Debug Mode Counter Halt (Write Protect)\nIf counter halt is enabled, PWM0 all counters will keep current value until exit ICE debug mode. \nNote:This bit is write protected. Refer toSYS_REGLCTL register.</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>ICE debug mode counter halt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>ICE debug mode counter halt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DBGTRIOFF</name>
              <description>ICE Debug Mode Acknowledge Disable Bit (Write Protect)\nPWM0 pin will keep output no matter ICE debug mode acknowledged or not.\nNote: This bit is write protected. Refer toSYS_REGLCTL register.</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>ICE debug mode acknowledgement effects PWM0 output</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>ICE debug mode acknowledgement disabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PWM0_CTL1</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PWM0_CTL1</displayName>
          <description>PWM0 Control Register 1</description>
          <addressOffset>0x4</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CNTTYPE0</name>
              <description>PWM0 Counter Behavior Type 0\nEach bit n controls corresponding PWM0 channel n.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Up counter type (supports in capture mode)</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Down count type (supports in capture mode)</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Up-down counter type</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Reserved</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CNTTYPE2</name>
              <description>PWM0 Counter Behavior Type 2\nEach bit n controls corresponding PWM0 channel n.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Up counter type (supports in capture mode)</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Down count type (supports in capture mode)</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Up-down counter type</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Reserved</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CNTTYPE4</name>
              <description>PWM0 Counter Behavior Type 4\nEach bit n controls corresponding PWM0 channel n.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Up counter type (supports in capture mode)</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Down count type (supports in capture mode)</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Up-down counter type</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Reserved</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PWMMODEn</name>
              <description>PWM0 Mode\nEach bit n controls the corresponding PWM0 channel n.\nNote: When operating in group function, these bits must all set to the same mode.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>3</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM0 independent mode</description>
                    <value>0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PWM0 complementary mode</description>
                    <value>1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PWM0_CLKSRC</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PWM0_CLKSRC</displayName>
          <description>PWM0 Clock Source Register</description>
          <addressOffset>0x10</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ECLKSRC0</name>
              <description>PWM0_CH01 External Clock Source Select</description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWMx_CLK, x denotes 0 or 1</description>
                    <value>#000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>TIMER0 overflow</description>
                    <value>#001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>TIMER1 overflow</description>
                    <value>#010</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>TIMER2 overflow</description>
                    <value>#011</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>4</name>
                    <description>TIMER3 overflow</description>
                    <value>#100</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ECLKSRC2</name>
              <description>PWM0_CH23 External Clock Source Select</description>
              <bitOffset>8</bitOffset>
              <bitWidth>3</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWMx_CLK, x denotes 0 or 1</description>
                    <value>#000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>TIMER0 overflow</description>
                    <value>#001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>TIMER1 overflow</description>
                    <value>#010</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>TIMER2 overflow</description>
                    <value>#011</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>4</name>
                    <description>TIMER3 overflow</description>
                    <value>#100</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ECLKSRC4</name>
              <description>PWM0_CH45 External Clock Source Select</description>
              <bitOffset>16</bitOffset>
              <bitWidth>3</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWMx_CLK, x denotes 0 or 1</description>
                    <value>#000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>TIMER0 overflow</description>
                    <value>#001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>TIMER1 overflow</description>
                    <value>#010</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>TIMER2 overflow</description>
                    <value>#011</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>4</name>
                    <description>TIMER3 overflow</description>
                    <value>#100</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PWM0_CLKPSC0_1</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PWM0_CLKPSC0_1</displayName>
          <description>PWM0 Clock Pre-Scale Register 0_1</description>
          <addressOffset>0x14</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CLKPSC</name>
              <description>PWM0 Counter Clock Pre-scale \nThe clock of PWM0 counter is decided by clock prescaler. Each PWM0 pair share one PWM0 counter clock prescaler. The clock of PWM0 counter is divided by (CLKPSC+ 1).</description>
              <bitOffset>0</bitOffset>
              <bitWidth>12</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PWM0_CLKPSC0_1">
          <name>PWM0_CLKPSC2_3</name>
          <displayName>PWM0_CLKPSC2_3</displayName>
          <description>PWM0 Clock Pre-Scale Register 2_3</description>
          <addressOffset>0x18</addressOffset>
       </register>
       <register derivedFrom="PWM0_CLKPSC0_1">
          <name>PWM0_CLKPSC4_5</name>
          <displayName>PWM0_CLKPSC4_5</displayName>
          <description>PWM0 Clock Pre-Scale Register 4_5</description>
          <addressOffset>0x1C</addressOffset>
       </register>
       <register>
          <name>PWM0_CNTEN</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PWM0_CNTEN</displayName>
          <description>PWM0 Counter Enable Register</description>
          <addressOffset>0x20</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CNTEN0</name>
              <description>PWM0 Counter Enable Bit 0</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM0 Counter0_1 and clock prescaler0 Stop Running</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PWM0 Counter0_1 and clock prescaler0 Start Running</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CNTEN2</name>
              <description>PWM0 Counter Enable Bit 2</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM0 Counter2_3 and clock prescaler2 Stop Running</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PWM0 Counter2_3 and clock prescaler2 Start Running</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CNTEN4</name>
              <description>PWM0 Counter Enable Bit4</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM0 Counter4_5 and clock prescaler4 Stop Running.  ....</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PWM0 Counter4_5 and clock prescaler4 Start Running</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PWM0_CNTCLR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PWM0_CNTCLR</displayName>
          <description>PWM0 Clear Counter Register</description>
          <addressOffset>0x24</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CNTCLR0</name>
              <description>Clear PWM0 Counter Control Bit 0\nIt is automatically cleared by hardware.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Clear 16-bit PWM0 counter to 0000H</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CNTCLR2</name>
              <description>Clear PWM0 Counter Control Bit 2\nIt is automatically cleared by hardware.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Clear 16-bit PWM0 counter to 0000H</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CNTCLR4</name>
              <description>Clear PWM0 Counter Control Bit 4\nIt is automatically cleared by hardware.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Clear 16-bit PWM0 counter to 0000H</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PWM0_PERIOD0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PWM0_PERIOD0</displayName>
          <description>PWM0 Period Register 0</description>
          <addressOffset>0x30</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PERIOD</name>
              <description>PWM0 Period Register\nUp-Count mode: In this mode, PWM0 counter counts from 0 to PERIOD, and restarts from 0.\nDown-Count mode: In this mode, PWM0 counter counts from PERIOD to 0, and restarts from PERIOD.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PWM0_PERIOD0">
          <name>PWM0_PERIOD2</name>
          <displayName>PWM0_PERIOD2</displayName>
          <description>PWM0 Period Register 2</description>
          <addressOffset>0x38</addressOffset>
       </register>
       <register derivedFrom="PWM0_PERIOD0">
          <name>PWM0_PERIOD4</name>
          <displayName>PWM0_PERIOD4</displayName>
          <description>PWM0 Period Register 4</description>
          <addressOffset>0x40</addressOffset>
       </register>
       <register>
          <name>PWM0_CMPDAT0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PWM0_CMPDAT0</displayName>
          <description>PWM0 Comparator Register 0</description>
          <addressOffset>0x50</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CMPDAT</name>
              <description>PWM0 Comparator Register\nCMPDAT use to compare with CNTR to generate PWM0 waveform, interrupt and trigger ADC.\nIn independent mode, CMPDAT0~5 denote as 6 independent PWM0_CH0~5 compared point.\nIn complementary mode, CMPDAT0, 2, 4 denote as first compared point, and CMPDAT1, 3, 5 denote as second compared point for the corresponding 3 complementary pairs PWM0_CH0 and PWM0_CH1, PWM0_CH2 and PWM0_CH3, PWM0_CH4 and PWM0_CH5.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PWM0_CMPDAT0">
          <name>PWM0_CMPDAT1</name>
          <displayName>PWM0_CMPDAT1</displayName>
          <description>PWM0 Comparator Register 1</description>
          <addressOffset>0x54</addressOffset>
       </register>
       <register derivedFrom="PWM0_CMPDAT0">
          <name>PWM0_CMPDAT2</name>
          <displayName>PWM0_CMPDAT2</displayName>
          <description>PWM0 Comparator Register 2</description>
          <addressOffset>0x58</addressOffset>
       </register>
       <register derivedFrom="PWM0_CMPDAT0">
          <name>PWM0_CMPDAT3</name>
          <displayName>PWM0_CMPDAT3</displayName>
          <description>PWM0 Comparator Register 3</description>
          <addressOffset>0x5C</addressOffset>
       </register>
       <register derivedFrom="PWM0_CMPDAT0">
          <name>PWM0_CMPDAT4</name>
          <displayName>PWM0_CMPDAT4</displayName>
          <description>PWM0 Comparator Register 4</description>
          <addressOffset>0x60</addressOffset>
       </register>
       <register derivedFrom="PWM0_CMPDAT0">
          <name>PWM0_CMPDAT5</name>
          <displayName>PWM0_CMPDAT5</displayName>
          <description>PWM0 Comparator Register 5</description>
          <addressOffset>0x64</addressOffset>
       </register>
       <register>
          <name>PWM0_DTCTL0_1</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PWM0_DTCTL0_1</displayName>
          <description>PWM0 Dead-Time Control Register 0_1</description>
          <addressOffset>0x70</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DTCNT</name>
              <description>Dead-time Counter (Write Protect)\nThe dead-time can be calculated from the following formula: \nNote:This register is write protected. Refer toSYS_REGLCTL register.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>12</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DTEN</name>
              <description>Enable Dead-time Insertion for PWM0 Pair (PWM0_CH0, PWM0_CH1)(PWM0_CH2, PWM0_CH3)(PWM0_CH4, PWM0_CH5)(Write Protect)\nDead-time insertion is only active when this PWM0 pair complementary mode is enabled. If dead- time insertion is inactive, the outputs of pin pair are complementary without any delay.\nNote:This register is write protected. Refer toSYS_REGLCTL register.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Dead-time insertion Disabled on the pin pair</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Dead-time insertion Enabled on the pin pair</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DTCKSEL</name>
              <description>Dead-time Clock Select (Write Protect)\nNote:This register is write protected. Refer toREGWRPROT register.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Dead-time clock source from PWM0_CLKn</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Dead-time clock source from prescaler output</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PWM0_DTCTL0_1">
          <name>PWM0_DTCTL2_3</name>
          <displayName>PWM0_DTCTL2_3</displayName>
          <description>PWM0 Dead-Time Control Register 2_3</description>
          <addressOffset>0x74</addressOffset>
       </register>
       <register derivedFrom="PWM0_DTCTL0_1">
          <name>PWM0_DTCTL4_5</name>
          <displayName>PWM0_DTCTL4_5</displayName>
          <description>PWM0 Dead-Time Control Register 4_5</description>
          <addressOffset>0x78</addressOffset>
       </register>
       <register>
          <name>PWM0_CNT0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PWM0_CNT0</displayName>
          <description>PWM0 Counter Register 0</description>
          <addressOffset>0x90</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CNT</name>
              <description>PWM0 Data Register(Read Only)\nUser can monitor CNTR to know the current value in 16-bit period counter.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>DIRF</name>
              <description>PWM0 Direction Indicator Flag (Read Only)</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Counter is Down count</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Counter is UP count</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PWM0_CNT0">
          <name>PWM0_CNT2</name>
          <displayName>PWM0_CNT2</displayName>
          <description>PWM0 Counter Register 2</description>
          <addressOffset>0x98</addressOffset>
       </register>
       <register derivedFrom="PWM0_CNT0">
          <name>PWM0_CNT4</name>
          <displayName>PWM0_CNT4</displayName>
          <description>PWM0 Counter Register 4</description>
          <addressOffset>0xA0</addressOffset>
       </register>
       <register>
          <name>PWM0_WGCTL0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PWM0_WGCTL0</displayName>
          <description>PWM0Waveform Generation Control Register 0</description>
          <addressOffset>0xB0</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ZPCTLn</name>
              <description>PWM0 Zero Point Control\nEach bit n controls the corresponding PWM0 channel n.\nPWM0 can control output level when PWM0 counter count to zero.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>12</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Do nothing</description>
                    <value>00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PWM0 zero point output Low</description>
                    <value>01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>10</name>
                    <description>PWM0 zero point output High</description>
                    <value>10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>11</name>
                    <description>PWM0 zero point output Toggle</description>
                    <value>11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PRDPCTLn</name>
              <description>PWM0 Period (Center) Point Control\nEach bit n controls the corresponding PWM0 channel n.\nPWM0 can control output level when PWM0 counter count to (PERIODn+1).\nNote: This bit is center point control when PWM0 counter operating in up-down counter type.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>12</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Do nothing</description>
                    <value>00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PWM0 period (center) point output Low</description>
                    <value>01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>10</name>
                    <description>PWM0 period (center) point output High</description>
                    <value>10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>11</name>
                    <description>PWM0 period (center) point output Toggle</description>
                    <value>11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PWM0_WGCTL1</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PWM0_WGCTL1</displayName>
          <description>PWM0Waveform Generation Control Register 1</description>
          <addressOffset>0xB4</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CMPUCTLn</name>
              <description>PWM0 Compare Up Point Control\nEach bit n controls the corresponding PWM0 channel n.\nPWM0 can control output level when PWM0 counter up count to CMPDAT.\nNote: In complementary mode, CMPUCTL1, 3, 5 use as another CMPUCTL for channel 0, 2, 4.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>12</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Do nothing</description>
                    <value>00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PWM0 compare up point output Low</description>
                    <value>01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>10</name>
                    <description>PWM0 compare up point output High</description>
                    <value>10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>11</name>
                    <description>PWM0 compare up point output Toggle</description>
                    <value>11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CMPDCTLn</name>
              <description>PWM0 Compare Down Point Control\nEach bit n controls the corresponding PWM0 channel n.\nPWM0 can control output level when PWM0 counter down count to CMPDAT.\nNote: In complementary mode, CMPDCTL1, 3, 5 use as another CMPDCTL for channel 0, 2, 4.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>12</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Do nothing</description>
                    <value>00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PWM0 compare down point output Low</description>
                    <value>01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>10</name>
                    <description>PWM0 compare down point output High</description>
                    <value>10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>11</name>
                    <description>PWM0 compare down point output Toggle</description>
                    <value>11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PWM0_MSKEN</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PWM0_MSKEN</displayName>
          <description>PWM0 Mask Enable Register</description>
          <addressOffset>0xB8</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MSKENn</name>
              <description>PWM0 Mask Enable Bits\nEach bit n controls the corresponding PWM0 channel n.\nThe PWM0 output signal will be masked when this bit is enabled. The corresponding PWM0 channel n will output MSKDATn (PWM0_MSK[5:0]) data. </description>
              <bitOffset>0</bitOffset>
              <bitWidth>6</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM0 output signal is non-masked</description>
                    <value>0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PWM0 output signal is masked and output MSKDATn data</description>
                    <value>1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PWM0_MSK</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PWM0_MSK</displayName>
          <description>PWM0 Mask Data Register</description>
          <addressOffset>0xBC</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MSKDATn</name>
              <description>PWM0 Mask Data Bits\nThis data bit control the state of PWM0_CHn output pin, if corresponding mask function is enabled.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>6</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Output logic low to PWM0_CHn</description>
                    <value>0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Output logic high to PWM0_CHn</description>
                    <value>1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PWM0_BNF</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PWM0_BNF</displayName>
          <description>PWM0 Brake Noise Filter Register</description>
          <addressOffset>0xC0</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BRK0FEN</name>
              <description>PWM0 Brake 0 Noise Filter Enable Bit</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Noise filter of PWM0 Brake 0 Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Noise filter of PWM0 Brake 0 Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BRK0FCS</name>
              <description>Brake 0 Edge Detector Filter Clock Selection</description>
              <bitOffset>1</bitOffset>
              <bitWidth>3</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Filter clock = HCLK</description>
                    <value>#000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Filter clock = HCLK/2</description>
                    <value>#001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Filter clock = HCLK/4</description>
                    <value>#010</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Filter clock = HCLK/8</description>
                    <value>#011</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>4</name>
                    <description>Filter clock = HCLK/16</description>
                    <value>#100</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>5</name>
                    <description>Filter clock = HCLK/32</description>
                    <value>#101</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>6</name>
                    <description>Filter clock = HCLK/64</description>
                    <value>#110</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>7</name>
                    <description>Filter clock = HCLK/128</description>
                    <value>#111</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BRK0FCNT</name>
              <description>Brake 0 Edge Detector Filter Count\nThe register bits control the Brake0 filter counter to count from 0 to BRK1FCNT.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>BRK0PINV</name>
              <description>Brake 0 Pin Inverse</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The state of pin PWMx_BRAKE0 is passed to the negative edge detector</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The inversed state of pin PWMx_BRAKE10 is passed to the negative edge detector</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BRK1FEN</name>
              <description>PWM0 Brake 1 Noise Filter Enable Bit</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Noise filter of PWM0 Brake 1 Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Noise filter of PWM0 Brake 1 Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BRK1FCS</name>
              <description>Brake 1 Edge Detector Filter Clock Selection</description>
              <bitOffset>9</bitOffset>
              <bitWidth>3</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Filter clock = HCLK</description>
                    <value>#000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Filter clock = HCLK/2</description>
                    <value>#001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Filter clock = HCLK/4</description>
                    <value>#010</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Filter clock = HCLK/8</description>
                    <value>#011</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>4</name>
                    <description>Filter clock = HCLK/16</description>
                    <value>#100</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>5</name>
                    <description>Filter clock = HCLK/32</description>
                    <value>#101</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>6</name>
                    <description>Filter clock = HCLK/64</description>
                    <value>#110</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>7</name>
                    <description>Filter clock = HCLK/128</description>
                    <value>#111</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BRK1FCNT</name>
              <description>Brake 1 Edge Detector Filter Count\nThe register bits control the Brake1 filter counter to count from 0 to BRK1FCNT.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>BRK1PINV</name>
              <description>Brake 1 Pin Inverse</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The state of pin PWMx_BRAKE1 is passed to the negative edge detector</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The inversed state of pin PWMx_BRAKE1 is passed to the negative edge detector</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BK0SRC</name>
              <description>Brake 0 Pin Source Select\nFor PWM0 setting:</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Brake 0 pin source come from PWM0_BRAKE0.\nBrake 0 pin source come from PWM1_BRAKE0</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Brake 0 pin source come from PWM1_BRAKE0.\nBrake 0 pin source come from PWM0_BRAKE0</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BK1SRC</name>
              <description>Brake 1 Pin Source Select\nFor PWM0 setting:</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Brake 1 pin source come from PWM0_BRAKE1.\nBrake 1 pin source come from PWM1_BRAKE1</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Brake 1 pin source come from PWM1_BRAKE1.\nBrake 1 pin source come from PWM0_BRAKE1</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PWM0_FAILBRK</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PWM0_FAILBRK</displayName>
          <description>PWM0 System Fail Brake Control Register</description>
          <addressOffset>0xC4</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BODBRKEN</name>
              <description>Brown-out Detection Trigger PWM0 Brake Function 0 Enable Bit</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Brake Function triggered by BOD Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Brake Function triggered by BOD Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CORBRKEN</name>
              <description>Core Lockup Detection Trigger PWM0 Brake Function 0 Enable Bit</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Brake Function triggered by Core lockup detection Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Brake Function triggered by Core lockup detection Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PWM0_BRKCTL0_1</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PWM0_BRKCTL0_1</displayName>
          <description>PWM0 Brake Edge Detect Control Register 0_1</description>
          <addressOffset>0xC8</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BRKP0EEN</name>
              <description>Enable PWMx_BRAKE0 Pin As Edge-detect Brake Source(Write Protect)\nNote: This register is write protected. Refer toSYS_REGLCTL register.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>BKP0 pin as edge-detect brake source Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>BKP0 pin as edge-detect brake source Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BRKP1EEN</name>
              <description>Enable PWMx_BRAKE1 Pin As Edge-detect Brake Source(Write Protect)\nNote: This register is write protected. Refer toSYS_REGLCTL register.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>BKP1 pin as edge-detect brake source Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>BKP1 pin as edge-detect brake source Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SYSEEN</name>
              <description>Enable System Fail As Edge-detect Brake Source(Write Protect)\nNote: This register is write protected. Refer toSYS_REGLCTL register.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>System Fail condition as edge-detect brake source Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>System Fail condition as edge-detect brake source Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BRKP0LEN</name>
              <description>Enable BKP0 Pin As Level-detect Brake Source(Write Protect)\nNote: This register is write protected. Refer toSYS_REGLCTL register.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWMx_BRAKE0 pin as level-detect brake source Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PWMx_BRAKE0 pin as level-detect brake source Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BRKP1LEN</name>
              <description>Enable BKP1 Pin As Level-detect Brake Source(Write Protect)\nNote: This register is write protected. Refer toSYS_REGLCTL register.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWMx_BRAKE1 pin as level-detect brake source Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PWMx_BRAKE1 pin as level-detect brake source Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SYSLEN</name>
              <description>Enable System Fail As Level-detect Brake Source(Write Protect)\nNote: This register is write protected. Refer toSYS_REGLCTL register.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>System Fail condition as level-detect brake source Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>System Fail condition as level-detect brake source Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BRKAEVEN</name>
              <description>PWM0 Brake Action Select for Even Channel (Write Protect)\nNote: This register is write protected. Refer toSYS_REGLCTL register.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM0 even channelbrake function not affect channel output</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PWM0 even channel output tri-state when brake happened</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>PWM0 even channel output low level whenbrake happened</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>PWM0 even channel output high level when brake happened</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BRKAODD</name>
              <description>PWM0 Brake Action Select for Odd Channel (Write Protect)\nNote: This register is write protected. Refer toSYS_REGLCTL register.</description>
              <bitOffset>18</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM0 odd channel brake function not affect channel output</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PWM0 odd channel output tri-state when brake happened</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>PWM0 odd channel output low level whenbrake happened</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>PWM0 odd channel output high level when brake happened</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PWM0_BRKCTL0_1">
          <name>PWM0_BRKCTL2_3</name>
          <displayName>PWM0_BRKCTL2_3</displayName>
          <description>PWM0 Brake Edge Detect Control Register 2_3</description>
          <addressOffset>0xCC</addressOffset>
       </register>
       <register derivedFrom="PWM0_BRKCTL0_1">
          <name>PWM0_BRKCTL4_5</name>
          <displayName>PWM0_BRKCTL4_5</displayName>
          <description>PWM0 Brake Edge Detect Control Register 4_5</description>
          <addressOffset>0xD0</addressOffset>
       </register>
       <register>
          <name>PWM0_POLCTL</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PWM0_POLCTL</displayName>
          <description>PWM0 Pin Polar Inverse Register</description>
          <addressOffset>0xD4</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PINVn</name>
              <description>PWM0 PIN Polar Inverse Control\nThe register controls polarity state of PWM0 output. Each bit n controls the corresponding PWM0 channel n.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>6</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM0 output polar inverse Disabled</description>
                    <value>0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PWM0 output polar inverse Enabled</description>
                    <value>1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PWM0_POEN</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PWM0_POEN</displayName>
          <description>PWM0 Output Enable Register</description>
          <addressOffset>0xD8</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>POENn</name>
              <description>PWM0 Pin Output Enable Bits\nEach bit n controls the corresponding PWM0 channel n.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>6</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM0 pin at tri-state</description>
                    <value>0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PWM0 pin in output mode</description>
                    <value>1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PWM0_SWBRK</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PWM0_SWBRK</displayName>
          <description>PWM0 Software Brake Control Register</description>
          <addressOffset>0xDC</addressOffset>
          <access>write-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BRKETRGn</name>
              <description>PWM0 Edge Brake Software Trigger (Write Only)(Write Protect)\nEach bit n controls the corresponding PWM0 pair n.\nWrite 1 to this bit will trigger Edge brake, and set BRKEIFn to 1 in PWM0_INTSTS1 register. \nNote:This register is write protected. Refer toSYS_REGLCTL register.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>BRKLTRGn</name>
              <description>PWM0 Level Brake Software Trigger (Write Only)(Write Protect)\nEach bit n controls the corresponding PWM0 pair n.\nWrite 1 to this bit will trigger level brake, and set BRKLIFn to 1 in PWM0_INTSTS1 register. \nNote:This register is write protected. Refer toSYS_REGLCTL register.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>3</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PWM0_INTEN0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PWM0_INTEN0</displayName>
          <description>PWM0 Interrupt Enable Register 0</description>
          <addressOffset>0xE0</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ZIEN0</name>
              <description>PWM0 Zero Point Interrupt Enable Bit 0\nNote: Odd channels will read always 0 at complementary mode.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM0counter0_1 zero point interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PWM0counter0_1 zero point interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ZIEN2</name>
              <description>PWM0 Zero Point Interrupt Enable Bit 2\nNote: Odd channels will read always 0 at complementary mode.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM0counter2_3 zero point interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PWM0counter2_3 zero point interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ZIEN4</name>
              <description>PWM0 Zero Point Interrupt Enable Bit 4\nNote: Odd channels will read always 0 at complementary mode.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM0counter4_5 zero point interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PWM0counter4_5 zero point interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PIEN0</name>
              <description>PWM0 Period Point Interrupt Enable Bit 0\nNote: When operating in up-down counter type, period point means center point.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM0counter0_1 period point interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PWM0counter0_1 period point interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PIEN2</name>
              <description>PWM0 Period Point Interrupt Enable Bit 2\nNote: When operating in up-down counter type, period point means center point.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM0counter2_3 period point interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PWM0counter2_3 period point interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PIEN4</name>
              <description>PWM0 Period Point Interrupt Enable Bit 4\nNote: When operating in up-down counter type, period point means center point.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM0counter4_5 period point interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PWM0counter4_5 period point interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CMPUIENn</name>
              <description>PWM0 Compare Up Count Interrupt Enable Bits\nEach bit n controls the corresponding PWM0 channel n.\nNote: In complementary mode, CMPUIEN1, 3, 5 use as another CMPUIEN for channel 0, 2, 4.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>6</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Compare up count interrupt Disabled</description>
                    <value>0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Compare up count interrupt Enabled</description>
                    <value>1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CMPDIENn</name>
              <description>PWM0 Compare Down Count Interrupt Enable Bits\nEach bit n controls the corresponding PWM0 channel n.\nNote: In complementary mode, CMPDIEN1, 3, 5 use as another CMPDIEN for channel 0, 2, 4.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>6</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Compare down count interrupt Disabled</description>
                    <value>0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Compare down count interrupt Enabled</description>
                    <value>1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PWM0_INTEN1</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PWM0_INTEN1</displayName>
          <description>PWM0 Interrupt Enable Register 1</description>
          <addressOffset>0xE4</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BRKEIEN0_1</name>
              <description>PWM0 Edge-detect Brake Interrupt Enable Bitfor Channel0/1(Write Protect)\nNote: This register is write protected. Refer toSYS_REGLCTL register.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Edge-detect Brake interrupt for channel0/1 Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Edge-detect Brake interrupt for channel0/1 Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BRKEIEN2_3</name>
              <description>PWM0 Edge-detect Brake Interrupt Enable Bitfor Channel2/3(Write Protect)\nNote: This register is write protected. Refer toSYS_REGLCTL register.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Edge-detect Brake interrupt for channel2/3 Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Edge-detect Brake interrupt for channel2/3 Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BRKEIEN4_5</name>
              <description>PWM0 Edge-detect Brake Interrupt Enable Bitfor Channel4/5(Write Protect)\nNote: This register is write protected. Refer toSYS_REGLCTL register.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Edge-detect Brake interrupt for channel4/5 Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Edge-detect Brake interrupt for channel4/5 Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BRKLIEN0_1</name>
              <description>PWM0 Level-detect Brake Interrupt Enable Bitfor Channel0/1(Write Protect)\nNote: This register is write protected. Refer toSYS_REGLCTL register.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Level-detect Brake interrupt for channel0/1 Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Level-detect Brake interrupt for channel0/1 Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BRKLIEN2_3</name>
              <description>PWM0 Level-detect Brake Interrupt Enable Bitfor Channel2/3(Write Protect)\nNote: This register is write protected. Refer toSYS_REGLCTL register.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Level-detect Brake interrupt for channel2/3 Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Level-detect Brake interrupt for channel2/3 Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BRKLIEN4_5</name>
              <description>PWM0 Level-detect Brake Interrupt Enable Bit for Channel4/5(Write Protect)\nNote: This register is write protected. Refer toSYS_REGLCTL register.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Level-detect Brake interrupt for channel4/5 Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Level-detect Brake interrupt for channel4/5 Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PWM0_INTSTS0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PWM0_INTSTS0</displayName>
          <description>PWM0 Interrupt Flag Register 0</description>
          <addressOffset>0xE8</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ZIF0</name>
              <description>PWM0 Zero Point Interrupt Flag 0\nThis bit is set by hardware when PWM0_CH0 counter reaches zero, software can write 1 to clear this bit to zero.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ZIF2</name>
              <description>PWM0 Zero Point Interrupt Flag 2\nThis bit is set by hardware when PWM0_CH2 counter reaches zero, software can write 1 to clear this bit to zero.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ZIF4</name>
              <description>PWM0 Zero Point Interrupt Flag 4\nThis bit is set by hardware when PWM0_CH4 counter reaches zero, software can write 1 to clear this bit to zero.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PIF0</name>
              <description>PWM0 Period Point Interrupt Flag 0\nThis bit is set by hardware when PWM0_CH0 counter reaches PWM0_PERIOD0, software can write 1 to clear this bit to zero.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PIF2</name>
              <description>PWM0 Period Point Interrupt Flag 2\nThis bit is set by hardware when PWM0_CH2 counter reaches PWM0_PERIOD2, software can write 1 to clear this bit to zero.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PIF4</name>
              <description>PWM0 Period Point Interrupt Flag 4\nThis bit is set by hardware when PWM0_CH4 counter reaches PWM0_PERIOD4, software can write 1 to clear this bit to zero.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CMPUIFn</name>
              <description>PWM0 Compare Up Count Interrupt Flag\nFlag is set by hardware when PWM0 counter up count and reaches PWM0_CMPDATn, software can clear this bit by writing 1 to it. Each bit n controls the corresponding PWM0 channel n.\nNote1: If CMPDAT equal to PERIOD, this flag is not working in up counter type selection.\nNote2: In complementary mode, CMPUIF1, 3, 5 use as another CMPUIF for channel 0, 2, 4.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CMPDIFn</name>
              <description>PWM0 Compare Down Count Interrupt Flag\nEach bit n controls the corresponding PWM0 channel n.\nFlag is set by hardware when PWM0 counter down count and reaches PWM0_CMPDATn, software can clear this bit by writing 1 to it.\nNote1: If CMPDAT equal to PERIOD, this flag is not working in down counter type selection.\nNote2: In complementary mode, CMPDIF1, 3, 5 use as another CMPDIF for channel 0, 2, 4.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PWM0_INTSTS1</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PWM0_INTSTS1</displayName>
          <description>PWM0 Interrupt Flag Register 1</description>
          <addressOffset>0xEC</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BRKEIF0</name>
              <description>PWM0 Channel0 Edge-detect Brake Interrupt Flag (Write Protect)\nNote: This bit is write protected. Refer toSYS_REGLCTL register.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM0 channel0 edge-detect brake event do not happened</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>When PWM0 channel0 edge-detect brake event happened, this bit is set to 1, writing 1 to clear</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BRKEIF1</name>
              <description>PWM0 Channel1 Edge-detect Brake Interrupt Flag (Write Protect)\nNote: This bit is write protected. Refer toSYS_REGLCTL register.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM0 channel1 edge-detect brake event do not happened</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>When PWM0 channel1 edge-detect brake event happened, this bit is set to 1, writing 1 to clear</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BRKEIF2</name>
              <description>PWM0 Channel2 Edge-detect Brake Interrupt Flag (Write Protect)\nNote: This bit is write protected. Refer toSYS_REGLCTL register.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM0 channel2 edge-detect brake event do not happened</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>When PWM0 channel2 edge-detect brake event happened, this bit is set to 1, writing 1 to clear</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BRKEIF3</name>
              <description>PWM0 Channel3 Edge-detect Brake Interrupt Flag (Write Protect)\nNote: This bit is write protected. Refer toSYS_REGLCTL register.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM0 channel3 edge-detect brake event do not happened</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>When PWM0 channel3 edge-detect brake event happened, this bit is set to 1, writing 1 to clear</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BRKEIF4</name>
              <description>PWM0 Channel4 Edge-detect Brake Interrupt Flag (Write Protect)\nNote: This bit is write protected. Refer toSYS_REGLCTL register.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM0 channel4 edge-detect brake event do not happened</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>When PWM0 channel4 edge-detect brake event happened, this bit is set to 1, writing 1 to clear</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BRKEIF5</name>
              <description>PWM0 Channel5 Edge-detect Brake Interrupt Flag (Write Protect)\nNote: This bit is write protected. Refer toSYS_REGLCTL register.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM0 channel5 edge-detect brake event do not happened</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>When PWM0 channel5 edge-detect brake event happened, this bit is set to 1, writing 1 to clear</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BRKLIF0</name>
              <description>PWM0 Channel0 Level-detect Brake Interrupt Flag (Write Protect)\nNote: This bit is write protected. Refer toSYS_REGLCTL register.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM0 channel0 level-detect brake event do not happened</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>When PWM0 channel0 level-detect brake event happened, this bit is set to 1, writing 1 to clear</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BRKLIF1</name>
              <description>PWM0 Channel1 Level-detect Brake Interrupt Flag (Write Protect)\nNote: This bit is write protected. Refer toSYS_REGLCTL register.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM0 channel1 level-detect brake event do not happened</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>When PWM0 channel1 level-detect brake event happened, this bit is set to 1, writing 1 to clear</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BRKLIF2</name>
              <description>PWM0 Channel2 Level-detect Brake Interrupt Flag (Write Protect)\nNote: This bit is write protected. Refer toSYS_REGLCTL register.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM0 channel2 level-detect brake event do not happened</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>When PWM0 channel2 level-detect brake event happened, this bit is set to 1, writing 1 to clear</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BRKLIF3</name>
              <description>PWM0 Channel3 Level-detect Brake Interrupt Flag (Write Protect)\nNote: This bit is write protected. Refer toSYS_REGLCTL register.</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM0 channel3 level-detect brake event do not happened</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>When PWM0 channel3 level-detect brake event happened, this bit is set to 1, writing 1 to clear</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BRKLIF4</name>
              <description>PWM0 Channel4 Level-detect Brake Interrupt Flag (Write Protect)\nNote: This bit is write protected. Refer toSYS_REGLCTL register.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM0 channel4 level-detect brake event do not happened</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>When PWM0 channel4 level-detect brake event happened, this bit is set to 1, writing 1 to clear</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BRKLIF5</name>
              <description>PWM0 Channel5 Level-detect Brake Interrupt Flag(Write Protect)\nNote: This bit is write protected. Refer toSYS_REGLCTL register.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM0 channel5 level-detect brake event do not happened</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>When PWM0 channel5 level-detect brake event happened, this bit is set to 1, writing 1 to clear</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BRKESTS0</name>
              <description>PWM0 Channel0 Edge-detect Brake Status (Read Only)</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM0 channel0 edge-detect brake state is released</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>When PWM0 channel0 edge-detect brake detects a falling edge of any enabled brake source; this flag will be set to indicate the PWM0 channel0 at brake state, writing 1 to clear</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>BRKESTS1</name>
              <description>PWM0 Channel1 Edge-detect Brake Status (Read Only)</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM0 channel1 edge-detect brake state is released</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>When PWM0 channel1 edge-detect brake detects a falling edge of any enabled brake source; this flag will be set to indicate the PWM0 channel1 at brake state, writing 1 to clear</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>BRKESTS2</name>
              <description>PWM0 Channel2 Edge-detect Brake Status (Read Only)</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM0 channel2 edge-detect brake state is released</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>When PWM0 channel2 edge-detect brake detects a falling edge of any enabled brake source; this flag will be set to indicate the PWM0 channel2 at brake state, writing 1 to clear</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>BRKESTS3</name>
              <description>PWM0 Channel3 Edge-detect Brake Status (Read Only)</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM0 channel3 edge-detect brake state is released</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>When PWM0 channel3 edge-detect brake detects a falling edge of any enabled brake source; this flag will be set to indicate the PWM0 channel3 at brake state, writing 1 to clear</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>BRKESTS4</name>
              <description>PWM0 Channel4 Edge-detect Brake Status (Read Only)</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM0 channel4 edge-detect brake state is released</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>When PWM0 channel4 edge-detect brake detects a falling edge of any enabled brake source; this flag will be set to indicate the PWM0 channel4 at brake state, writing 1 to clear</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>BRKESTS5</name>
              <description>PWM0 Channel5 Edge-detect Brake Status (Read Only)</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM0 channel5 edge-detect brake state is released</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>When PWM0 channel5 edge-detect brake detects a falling edge of any enabled brake source; this flag will be set to indicate the PWM0 channel5 at brake state, writing 1 to clear</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>BRKLSTS0</name>
              <description>PWM0 Channel0 Level-detect Brake Status (Read Only)\nNote: This bit is read only and auto cleared by hardware. When enabled brake source return to high level, PWM0 will release brake state until current PWM0 period finished. The PWM0 waveform will start output from next full PWM0 period.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM0 channel0 level-detect brake state is released</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>When PWM0 channel0 level-detect brake detects a falling edge of any enabled brake source; this flag will be set to indicate the PWM0 channel0 at brake state</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>BRKLSTS1</name>
              <description>PWM0 Channel1 Level-detect Brake Status (Read Only)\nNote: This bit is read only and auto cleared by hardware. When enabled brake source return to high level, PWM0 will release brake state until current PWM0 period finished. The PWM0 waveform will start output from next full PWM0 period.</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM0 channel1 level-detect brake state is released</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>When PWM0 channel1 level-detect brake detects a falling edge of any enabled brake source; this flag will be set to indicate the PWM0 channel1 at brake state</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>BRKLSTS2</name>
              <description>PWM0 Channel2 Level-detect Brake Status (Read Only)\nNote: This bit is read only and auto cleared by hardware. When enabled brake source return to high level, PWM0 will release brake state until current PWM0 period finished. The PWM0 waveform will start output from next full PWM0 period.</description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM0 channel2 level-detect brake state is released</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>When PWM0 channel2 level-detect brake detects a falling edge of any enabled brake source; this flag will be set to indicate the PWM0 channel2 at brake state</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>BRKLSTS3</name>
              <description>PWM0 Channel3 Level-detect Brake Status (Read Only)\nNote: This bit is read only and auto cleared by hardware. When enabled brake source return to high level, PWM0 will release brake state until current PWM0 period finished. The PWM0 waveform will start output from next full PWM0 period.</description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM0 channel3 level-detect brake state is released</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>When PWM0 channel3 level-detect brake detects a falling edge of any enabled brake source; this flag will be set to indicate the PWM0 channel3 at brake state</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>BRKLSTS4</name>
              <description>PWM0 Channel4 Level-detect Brake Status (Read Only)\nNote: This bit is read only and auto cleared by hardware. When enabled brake source return to high level, PWM0 will release brake state until current PWM0 period finished. The PWM0 waveform will start output from next full PWM0 period.</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM0 channel4 level-detect brake state is released</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>When PWM0 channel4 level-detect brake detects a falling edgeof any enabled brake source; this flag will be set to indicate the PWM0 channel4 at brake state</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>BRKLSTS5</name>
              <description>PWM0 Channel5 Level-detect Brake Status (Read Only)\nNote: This bit is read only and auto cleared by hardware. When enabled brake source return to high level, PWM0 will release brake state until current PWM0 period finished. The PWM0 waveform will start output from next full PWM0 period.</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM0 channel5 level-detect brake state is released</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>When PWM0 channel5 level-detect brake detects a falling edge of any enabled brake source; this flag will be set to indicate the PWM0 channel5 at brake state</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PWM0_ADCTS0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PWM0_ADCTS0</displayName>
          <description>PWM0 Trigger ADC Source Select Register 0</description>
          <addressOffset>0xF8</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TRGSEL0</name>
              <description>PWM0_CH0 Trigger ADC Source Select\nOthers reserved</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM0_CH0 zero point</description>
                    <value>#0000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PWM0_CH0 period point</description>
                    <value>#0001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>PWM0_CH0 zero or period point</description>
                    <value>#0010</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>PWM0_CH0 up-count CMPDAT point</description>
                    <value>#0011</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>4</name>
                    <description>PWM0_CH0 down-count CMPDAT point</description>
                    <value>#0100</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>5</name>
                    <description>Reserved</description>
                    <value>#0101</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>6</name>
                    <description>Reserved</description>
                    <value>#0110</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>7</name>
                    <description>Reserved</description>
                    <value>#0111</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>8</name>
                    <description>PWM0_CH1 up-count CMPDAT point</description>
                    <value>#1000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>9</name>
                    <description>PWM0_CH1 down-count CMPDAT point</description>
                    <value>#1001</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TRGEN0</name>
              <description>PWM0_CH0 Trigger EADC Enable Bit</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM0_CH0 Trigger EADC Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PWM0_CH0 Trigger EADC Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TRGSEL1</name>
              <description>PWM0_CH1 Trigger ADC Source Select\nOthers reserved</description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM0_CH0 zero point</description>
                    <value>#0000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PWM0_CH0 period point</description>
                    <value>#0001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>PWM0_CH0 zero or period point</description>
                    <value>#0010</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>PWM0_CH0 up-count CMPDAT point</description>
                    <value>#0011</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>4</name>
                    <description>PWM0_CH0 down-count CMPDAT point</description>
                    <value>#0100</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>5</name>
                    <description>Reserved</description>
                    <value>#0101</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>6</name>
                    <description>Reserved</description>
                    <value>#0110</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>7</name>
                    <description>Reserved</description>
                    <value>#0111</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>8</name>
                    <description>PWM0_CH1 up-count CMPDAT point</description>
                    <value>#1000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>9</name>
                    <description>PWM0_CH1 down-count CMPDAT point</description>
                    <value>#1001</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TRGEN1</name>
              <description>PWM0_CH1 Trigger EADC Enable Bit</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM0_CH1 Trigger EADC Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PWM0_CH1 Trigger EADC Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TRGSEL2</name>
              <description>PWM0_CH2 Trigger ADC Source Select\nOthers reserved</description>
              <bitOffset>16</bitOffset>
              <bitWidth>4</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM0_CH2 zero point</description>
                    <value>#0000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PWM0_CH2 period point</description>
                    <value>#0001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>PWM0_CH2 zero or period point</description>
                    <value>#0010</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>PWM0_CH2 up-count CMPDAT point</description>
                    <value>#0011</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>4</name>
                    <description>PWM0_CH2 down-count CMPDAT point</description>
                    <value>#0100</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>5</name>
                    <description>Reserved</description>
                    <value>#0101</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>6</name>
                    <description>Reserved</description>
                    <value>#0110</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>7</name>
                    <description>Reserved</description>
                    <value>#0111</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>8</name>
                    <description>PWM0_CH3 up-count CMPDAT point</description>
                    <value>#1000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>9</name>
                    <description>PWM0_CH3 down-count CMPDAT point</description>
                    <value>#1001</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TRGEN2</name>
              <description>PWM0_CH2 Trigger EADC Enable Bit</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM0_CH2 Trigger EADC Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PWM0_CH2 Trigger EADC Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TRGSEL3</name>
              <description>PWM0_CH3 Trigger ADC Source Select\nOthers reserved</description>
              <bitOffset>24</bitOffset>
              <bitWidth>4</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM0_CH2 zero point</description>
                    <value>#0000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PWM0_CH2 period point</description>
                    <value>#0001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>PWM0_CH2 zero or period point</description>
                    <value>#0010</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>PWM0_CH2 up-count CMPDAT point</description>
                    <value>#0011</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>4</name>
                    <description>PWM0_CH2 down-count CMPDAT point</description>
                    <value>#0100</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>5</name>
                    <description>Reserved</description>
                    <value>#0101</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>6</name>
                    <description>Reserved</description>
                    <value>#0110</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>7</name>
                    <description>Reserved</description>
                    <value>#0111</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>8</name>
                    <description>PWM0_CH3 up-count CMPDAT point</description>
                    <value>#1000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>9</name>
                    <description>PWM0_CH3 down-count CMPDAT point</description>
                    <value>#1001</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TRGEN3</name>
              <description>PWM0_CH3 Trigger EADC Enable Bit</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM0_CH3 Trigger EADC Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PWM0_CH3 Trigger EADC Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PWM0_ADCTS1</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PWM0_ADCTS1</displayName>
          <description>PWM0 Trigger ADC Source Select Register 1</description>
          <addressOffset>0xFC</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TRGSEL4</name>
              <description>PWM0_CH4 Trigger ADC Source Select\nOthers reserved</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM0_CH4 zero point</description>
                    <value>#0000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PWM0_CH4 period point</description>
                    <value>#0001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>PWM0_CH4 zero or period point</description>
                    <value>#0010</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>PWM0_CH4 up-count CMPDAT point</description>
                    <value>#0011</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>4</name>
                    <description>PWM0_CH4 down-count CMPDAT point</description>
                    <value>#0100</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>5</name>
                    <description>Reserved</description>
                    <value>#0101</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>6</name>
                    <description>Reserved</description>
                    <value>#0110</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>7</name>
                    <description>Reserved</description>
                    <value>#0111</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>8</name>
                    <description>PWM0_CH5 up-count CMPDAT point</description>
                    <value>#1000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>9</name>
                    <description>PWM0_CH5 down-count CMPDAT point</description>
                    <value>#1001</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TRGEN4</name>
              <description>PWM0_CH4 Trigger EADC Enable Bit</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM0_CH4 Trigger EADC Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PWM0_CH4 Trigger EADC Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TRGSEL5</name>
              <description>PWM0_CH5 Trigger ADC Source Select\nOthers reserved</description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM0_CH4 zero point</description>
                    <value>#0000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PWM0_CH4 period point</description>
                    <value>#0001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>PWM0_CH4 zero or period point</description>
                    <value>#0010</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>PWM0_CH4 up-count CMPDAT point</description>
                    <value>#0011</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>4</name>
                    <description>PWM0_CH4 down-count CMPDAT point</description>
                    <value>#0100</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>5</name>
                    <description>Reserved</description>
                    <value>#0101</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>6</name>
                    <description>Reserved</description>
                    <value>#0110</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>7</name>
                    <description>Reserved</description>
                    <value>#0111</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>8</name>
                    <description>PWM0_CH5 up-count CMPDAT point</description>
                    <value>#1000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>9</name>
                    <description>PWM0_CH5 down-count CMPDAT point</description>
                    <value>#1001</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TRGEN5</name>
              <description>PWM0_CH5 Trigger EADC Enable Bit</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM0_CH5 Trigger EADC Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PWM0_CH5 Trigger EADC Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PWM0_STATUS</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PWM0_STATUS</displayName>
          <description>PWM0 Status Register</description>
          <addressOffset>0x120</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CNTMAX0</name>
              <description>Time-base Counter 0 Equal to 0xFFFF Latched Status</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>indicates the time-base counter never reached its maximum value 0xFFFF</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>indicates the time-base counter reached its maximum value, software can write 1 to clear this bit</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CNTMAX2</name>
              <description>Time-base Counter 2 Equal to 0xFFFF Latched Status</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>indicates the time-base counter never reached its maximum value 0xFFFF</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>indicates the time-base counter reached its maximum value, software can write 1 to clear this bit</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CNTMAX4</name>
              <description>Time-base Counter 4 Equal to 0xFFFF Latched Status</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>indicates the time-base counter never reached its maximum value 0xFFFF</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>indicates the time-base counter reached its maximum value, software can write 1 to clear this bit</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ADCTRGn</name>
              <description>ADC Start of Conversion Status\nEach bit n controls the corresponding PWM0 channel n.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>6</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Indicates no ADC start of conversion trigger event has occurred</description>
                    <value>0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Indicates an ADC start of conversion trigger event has occurred, software can write 1 to clear this bit</description>
                    <value>1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PWM0_CAPINEN</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PWM0_CAPINEN</displayName>
          <description>PWM0 Capture Input Enable Register</description>
          <addressOffset>0x200</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CAPINENn</name>
              <description>Capture Input Enable Bits\nEach bit n controls the corresponding PWM0 channel n.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>6</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM0 Channel capture input path Disabled. The input of PWM0 channel capture function is always regarded as 0</description>
                    <value>0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PWM0 Channel capture input path Enabled. The input of PWM0 channel capture function comes from correlative multifunction pin</description>
                    <value>1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PWM0_CAPCTL</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PWM0_CAPCTL</displayName>
          <description>PWM0 Capture Control Register</description>
          <addressOffset>0x204</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CAPENn</name>
              <description>Capture Function Enable Bits\nEach bit n controls the corresponding PWM0 channel n.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>6</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Capture function Disabled. RCAPDAT/FCAPDAT register will not be updated</description>
                    <value>0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Capture function Enabled. Capture latched the PWM0 counter value when detected rising or falling edge of input signal and saved to RCAPDAT (Rising latch) and FCAPDAT (Falling latch)</description>
                    <value>1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CAPINVn</name>
              <description>Capture Inverter Enable Bits\nEach bit n controls the corresponding PWM0 channel n.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>6</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Capture source inverter Disabled</description>
                    <value>0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Capture source inverter Enabled. Reverse the input signal from GPIO</description>
                    <value>1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RCRLDENn</name>
              <description>Rising Capture Reload Enable Bits\nEach bit n controls the corresponding PWM0 channel n.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>6</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Risingcapture reload counter Disabled</description>
                    <value>0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Risingcapture reload counter Enabled</description>
                    <value>1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>FCRLDENn</name>
              <description>Falling Capture Reload EnableBits\nEach bit n controls the corresponding PWM0 channel n.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>6</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Falling capture reload counter Disabled</description>
                    <value>0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Falling capture reload counter Enabled</description>
                    <value>1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PWM0_CAPSTS</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PWM0_CAPSTS</displayName>
          <description>PWM0 Capture Status Register</description>
          <addressOffset>0x208</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CRIFOVn</name>
              <description>Capture Rising Interrupt Flag Overrun Status(Read Only)\nThis flag indicatesif rising latch happenedwhen the corresponding CAPRIFis 1. Each bit n controls the corresponding PWM0 channel n.\nNote:This bit will be cleared automatically when user clear corresponding CAPRIF.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>CFIFOVn</name>
              <description>Capture Falling Interrupt Flag Overrun Status(Read Only)\nThis flag indicatesif falling latch happenedwhen the corresponding CAPFIFis 1. Each bit n controls the corresponding PWM0 channel n.\nNote:This bit will be cleared automatically when user clear corresponding CAPFIF.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PWM0_RCAPDAT0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PWM0_RCAPDAT0</displayName>
          <description>PWM0 Rising Capture Data Register 0</description>
          <addressOffset>0x20C</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RCAPDAT</name>
              <description>PWM0 Rising Capture Data Register(Read Only)\nWhen rising capture condition happened, the PWM0 counter value will be saved in this register.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PWM0_FCAPDAT0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PWM0_FCAPDAT0</displayName>
          <description>PWM0 Falling Capture Data Register 0</description>
          <addressOffset>0x210</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>FCAPDAT</name>
              <description>PWM0 Falling Capture Data Register(Read Only)\nWhen falling capture condition happened, the PWM0 counter value will be saved in this register.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PWM0_RCAPDAT0">
          <name>PWM0_RCAPDAT1</name>
          <displayName>PWM0_RCAPDAT1</displayName>
          <description>PWM0 Rising Capture Data Register 1</description>
          <addressOffset>0x214</addressOffset>
       </register>
       <register derivedFrom="PWM0_FCAPDAT0">
          <name>PWM0_FCAPDAT1</name>
          <displayName>PWM0_FCAPDAT1</displayName>
          <description>PWM0 Falling Capture Data Register 1</description>
          <addressOffset>0x218</addressOffset>
       </register>
       <register derivedFrom="PWM0_RCAPDAT0">
          <name>PWM0_RCAPDAT2</name>
          <displayName>PWM0_RCAPDAT2</displayName>
          <description>PWM0 Rising Capture Data Register 2</description>
          <addressOffset>0x21C</addressOffset>
       </register>
       <register derivedFrom="PWM0_FCAPDAT0">
          <name>PWM0_FCAPDAT2</name>
          <displayName>PWM0_FCAPDAT2</displayName>
          <description>PWM0 Falling Capture Data Register 2</description>
          <addressOffset>0x220</addressOffset>
       </register>
       <register derivedFrom="PWM0_RCAPDAT0">
          <name>PWM0_RCAPDAT3</name>
          <displayName>PWM0_RCAPDAT3</displayName>
          <description>PWM0 Rising Capture Data Register 3</description>
          <addressOffset>0x224</addressOffset>
       </register>
       <register derivedFrom="PWM0_FCAPDAT0">
          <name>PWM0_FCAPDAT3</name>
          <displayName>PWM0_FCAPDAT3</displayName>
          <description>PWM0 Falling Capture Data Register 3</description>
          <addressOffset>0x228</addressOffset>
       </register>
       <register derivedFrom="PWM0_RCAPDAT0">
          <name>PWM0_RCAPDAT4</name>
          <displayName>PWM0_RCAPDAT4</displayName>
          <description>PWM0 Rising Capture Data Register 4</description>
          <addressOffset>0x22C</addressOffset>
       </register>
       <register derivedFrom="PWM0_FCAPDAT0">
          <name>PWM0_FCAPDAT4</name>
          <displayName>PWM0_FCAPDAT4</displayName>
          <description>PWM0 Falling Capture Data Register 4</description>
          <addressOffset>0x230</addressOffset>
       </register>
       <register derivedFrom="PWM0_RCAPDAT0">
          <name>PWM0_RCAPDAT5</name>
          <displayName>PWM0_RCAPDAT5</displayName>
          <description>PWM0 Rising Capture Data Register 5</description>
          <addressOffset>0x234</addressOffset>
       </register>
       <register derivedFrom="PWM0_FCAPDAT0">
          <name>PWM0_FCAPDAT5</name>
          <displayName>PWM0_FCAPDAT5</displayName>
          <description>PWM0 Falling Capture Data Register 5</description>
          <addressOffset>0x238</addressOffset>
       </register>
       <register>
          <name>PWM0_CAPIEN</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PWM0_CAPIEN</displayName>
          <description>PWM0 Capture Interrupt Enable Register</description>
          <addressOffset>0x250</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CAPRIENn</name>
              <description>PWM0 Capture Rising Latch Interrupt Enable Bits\nEach bit n controls the corresponding PWM0 channel n.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>6</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Capture rising edge latch interrupt Disabled</description>
                    <value>0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Capture rising edge latch interrupt Enabled</description>
                    <value>1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CAPFIENn</name>
              <description>PWM0 Capture Falling Latch Interrupt Enable Bits\nEach bit n controls the corresponding PWM0 channel n.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>6</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Capture falling edge latch interrupt Disabled</description>
                    <value>0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Capture falling edge latch interrupt Enabled</description>
                    <value>1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PWM0_CAPIF</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PWM0_CAPIF</displayName>
          <description>PWM0 Capture Interrupt Flag Register</description>
          <addressOffset>0x254</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CAPRIFn</name>
              <description>PWM0 Capture Rising Latch Interrupt Flag\nThis bit is writing 1 to clear. Each bit n controls the corresponding PWM0 channel n.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>6</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No capture rising latch condition happened</description>
                    <value>0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Capture rising latch condition happened, this flag will be set to high</description>
                    <value>1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CAPFIFn</name>
              <description>PWM0 Capture Falling Latch Interrupt Flag\nThis bit is writing 1 to clear. Each bit n controls the corresponding PWM0 channel n.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>6</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No capture falling latch condition happened</description>
                    <value>0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Capture falling latch condition happened, this flag will be set to high</description>
                    <value>1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PWM0_SELFTEST</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PWM0_SELFTEST</displayName>
          <description>PWM0 Self-test Mode Enable</description>
          <addressOffset>0x300</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
          </fields>
       </register>
       <register>
          <name>PWM0_PBUF0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PWM0_PBUF0</displayName>
          <description>PWM0 PERIOD0 Buffer</description>
          <addressOffset>0x304</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PBUF</name>
              <description>PWM0 Period Register Buffer(Read Only)\nUsed as PERIOD active register.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PWM0_PBUF0">
          <name>PWM0_PBUF2</name>
          <displayName>PWM0_PBUF2</displayName>
          <description>PWM0 PERIOD2 Buffer</description>
          <addressOffset>0x30C</addressOffset>
       </register>
       <register derivedFrom="PWM0_PBUF0">
          <name>PWM0_PBUF4</name>
          <displayName>PWM0_PBUF4</displayName>
          <description>PWM0 PERIOD4 Buffer</description>
          <addressOffset>0x314</addressOffset>
       </register>
       <register>
          <name>PWM0_CMPBUF0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PWM0_CMPBUF0</displayName>
          <description>PWM0 CMPDAT0 Buffer</description>
          <addressOffset>0x31C</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CMPBUF</name>
              <description>PWM0 Comparator Register Buffer(Read Only)\nUsed as CMP active register.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PWM0_CMPBUF0">
          <name>PWM0_CMPBUF1</name>
          <displayName>PWM0_CMPBUF1</displayName>
          <description>PWM0 CMPDAT1 Buffer</description>
          <addressOffset>0x320</addressOffset>
       </register>
       <register derivedFrom="PWM0_CMPBUF0">
          <name>PWM0_CMPBUF2</name>
          <displayName>PWM0_CMPBUF2</displayName>
          <description>PWM0 CMPDAT2 Buffer</description>
          <addressOffset>0x324</addressOffset>
       </register>
       <register derivedFrom="PWM0_CMPBUF0">
          <name>PWM0_CMPBUF3</name>
          <displayName>PWM0_CMPBUF3</displayName>
          <description>PWM0 CMPDAT3 Buffer</description>
          <addressOffset>0x328</addressOffset>
       </register>
       <register derivedFrom="PWM0_CMPBUF0">
          <name>PWM0_CMPBUF4</name>
          <displayName>PWM0_CMPBUF4</displayName>
          <description>PWM0 CMPDAT4 Buffer</description>
          <addressOffset>0x32C</addressOffset>
       </register>
       <register derivedFrom="PWM0_CMPBUF0">
          <name>PWM0_CMPBUF5</name>
          <displayName>PWM0_CMPBUF5</displayName>
          <description>PWM0 CMPDAT5 Buffer</description>
          <addressOffset>0x330</addressOffset>
       </register>
       <register>
          <name>PWM0_VERSION</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PWM0_VERSION</displayName>
          <description>PWM0 RTL Design Version Number</description>
          <addressOffset>0xFFC</addressOffset>
          <access>read-only</access>
          <resetValue>0x02010000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
          </fields>
       </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>WDT</name>
      <description>WDT Register Map</description>
      <groupName>WDT</groupName>
      <baseAddress>0x40004000</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x0</offset>
        <size>0xC</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>WDT_CTL</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>WDT_CTL</displayName>
          <description>Watchdog Timer Control Register</description>
          <addressOffset>0x0</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000070</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RSTCNT</name>
              <description>Reset Watchdog TimerCounter (Write Protect)\nPlease refer to open lock sequence to program it.\nSetting this bit will reset the Watchdog timer counter.\nNote: This bit will be auto cleared after 1 PCLK clock cycle.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reset the contents of the Watchdog timer</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RSTEN</name>
              <description>Watchdog Timer Reset Function EnableBit (Write Protect)\nPlease refer to open lock sequence to program it.\nSetting this bit will enable the Watchdog timer reset function.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Watchdog timer reset function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Watchdog timer reset function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>WKEN</name>
              <description>Watchdog Timer Wake-up Function EnableBit(Write Protect)\nPlease refer to open lock sequence to program it.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Watchdog timer Wake-up CPU function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Wake-up function Enabled so that Watchdog timer time-out can wake up CPU from Power-down mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>WDTEN</name>
              <description>Watchdog Timer EnableBit(Write Protect)\nPlease refer to open lock sequence to program it.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Watchdog timer Disabled (this action will reset the internal counter)</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Watchdog timer Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>WTIS</name>
              <description>Watchdog Timer Interval Selection(Write Protect)\nPlease refer to open lock sequence to program it.\nThe three bits select the time-out interval for the Watchdog timer. This count is free running counter.\nPlease refer toTable6.111.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>WTRDSEL</name>
              <description>Watchdog Timer Reset Delay Selection\nWhen watchdog time-out happened, software has a time named watchdog reset delay period to clear watchdog timer to prevent watchdog reset happened. Software can select a suitable value of watchdog reset delay period for different watchdog time-out period.\nNote: This bit will be reset if watchdog reset happened</description>
              <bitOffset>8</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Watchdog reset delay period is 1026 watchdog clock</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Watchdog reset delay period is 130 watchdog clock</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Watchdog reset delay period is 18 watchdog clock</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Watchdog reset delay period is 3 watchdog clock</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DBGEN</name>
              <description>WDT Debug Mode Enable Control (Write Protect)</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>WDT stopped counting if system is in Debug mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>WDT still counted even system is in Debug mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>WDT_INTEN</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>WDT_INTEN</displayName>
          <description>Watchdog Timer Interrupt Enable Register</description>
          <addressOffset>0x4</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WDTIEN</name>
              <description>Watchdog Timer Time-out Interrupt EnableBit</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Watchdog timer time-out interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Watchdog timer time-out interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>WDT_STATUS</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>WDT_STATUS</displayName>
          <description>Watchdog Timer Status Register</description>
          <addressOffset>0x8</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WDTIF</name>
              <description>Watchdog Timer Time-out Interrupt StatusFlag\nIf the Watchdog timer time-out interrupt is enabled, then the hardware will set this bit to indicate that the Watchdog timer time-out interrupt has occurred. If the Watchdog timer time-out interrupt is not enabled, then this bit indicates that a time-out period has elapsed.\nNote:This bit is read only, but can be cleared by writing "1" to it.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Watchdog timer time-out interrupt did not occur</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Watchdog timer time-out interrupt occurred</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RSTF</name>
              <description>Watchdog Timer Reset StatusFlag\nWhen the Watchdog timer initiates a reset, the hardware will set this bit. This flag can be read by software to determine the source of reset. Software is responsible to clear it manually by writing "1" to it. If RSTEN is disabled, then the Watchdog timer has no effect on this bit.\nNote: This bit is read only, but can be cleared by writing "1" to it.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Watchdog timer reset did not occur</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Watchdog timer reset occurred</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>WKF</name>
              <description>Watchdog Timer Wake-up StatusFlag\nIf Watchdog timer causes system to wake up from Power-down mode, this bit will be set to 1. It must be cleared by software with a write "1" to this bit.\nNote1: When system in Power-down mode and watchdog time-out, hardware will set WKF and WDTIF.\nNote2: After one engine clock, this bit can be cleared by writing "1" to it</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Watchdog timer does not cause system wake-up</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Wake system up from Power-down mode by Watchdog time-out</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>WWDT</name>
      <description>WWDT Register Map</description>
      <groupName>WWDT</groupName>
      <baseAddress>0x40004100</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x0</offset>
        <size>0x14</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>WWDT_RLDCNT</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>WWDT_RLDCNT</displayName>
          <description>Window Watchdog Timer Reload Counter Register</description>
          <addressOffset>0x0</addressOffset>
          <access>write-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RLDCNT</name>
              <description>Window Watchdog Timer Reload Counter Register\nWriting 0x00005AA5 to this register will reload the Window Watchdog Timer counter value to 0x3F.\nNote:This registercan only be written when WWDT counter value between 0 and WINCMP, otherwise WWDT will generate RESET signal.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>WWDT_CTL</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>WWDT_CTL</displayName>
          <description>Window Watchdog Timer Control Register</description>
          <addressOffset>0x4</addressOffset>
          <access>read-write</access>
          <resetValue>0x003F0800</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WWDTEN</name>
              <description>Window Watchdog EnableBit\nSet this bit to enable Window Watchdog timer.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Window Watchdog timer function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Window Watchdog timer function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PERIODSEL</name>
              <description>WWDT Pre-scale Period Select\nThese three bits select the pre-scale for the WWDT counter period.\nPlease refer toTable 6.121WWDT Prescaler Value Selection.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>WINCMP</name>
              <description>WWDT Window Compare Bits\nSet this register to adjust the valid reload window.\nNote:WWDT_RLDCNTregistercan only be written when WWDT counter value between 0 and WINCMP, otherwise WWDT will generate RESET signal.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DBGEN</name>
              <description>WWDT Debug EnableBit</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>WWDT stopped count if system is in Debug mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>WWDT still counted even system is in Debug mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>WWDT_INTEN</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>WWDT_INTEN</displayName>
          <description>Window Watchdog Timer Interrupt Enable Register</description>
          <addressOffset>0x8</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WWDTIEN</name>
              <description>WWDT Interrupt Enable Bit\nSetting this bit will enable the Window Watchdog timer interrupt function.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Watchdog timer interrupt function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Watchdog timer interrupt function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>WWDT_STATUS</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>WWDT_STATUS</displayName>
          <description>Window Watchdog Timer Status Register</description>
          <addressOffset>0xC</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WWDTIF</name>
              <description>WWDT Compare Match Interrupt Flag\nWhen WWCMP matches the WWDT counter, this bit is set to 1. This bit can be cleared by writing '1' to it.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>WWDTRF</name>
              <description>WWDT Reset Flag\nWhen the WWDT counter down counts to 0 or writes WWDT_RLDCNT during WWDT counter larger than WINCMP, chip will be reset and this bit is set to 1. This bit can be cleared by writing '1' to it.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>WWDT_CNT</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>WWDT_CNT</displayName>
          <description>Window Watchdog Timer Counter Value Register</description>
          <addressOffset>0x10</addressOffset>
          <access>read-only</access>
          <resetValue>0x0000003F</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CNTDAT</name>
              <description>WWDT Counter Value\nThis register reflects the current counter value of window watchdog.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>RTC</name>
      <description>RTC Register Map</description>
      <groupName>RTC</groupName>
      <baseAddress>0x40008000</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x0</offset>
        <size>0x54</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x100</offset>
        <size>0x10</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>RTC_INIT</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>RTC_INIT</displayName>
          <description>RTC Initiation Register</description>
          <addressOffset>0x0</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>INIT_ACTIVE</name>
              <description>RTC Active Status (Read Only)</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RTC is at reset state</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RTC is at normal active state</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>INIT</name>
              <description>RTC Initiation\nWhen RTC block is powered on, RTC is at reset state. User has to write a number (0x a5eb1357) to INIT to make RTC leaving reset state. Once the INIT is written as 0xa5eb1357, the RTC will be in un-reset state permanently.\nThe INIT is a write-only field and read value will be always 0.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>31</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>RTC_RWEN</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>RTC_RWEN</displayName>
          <description>RTC Access Enable Register</description>
          <addressOffset>0x4</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RWEN</name>
              <description>RTC Register Access Enable Password (Write Only)\nWriting 0xA965 to this register will enable RTC access and keep 1024 RTC clock.\nWriting other vaule will clear RWENF.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>RWENF</name>
              <description>RTC Register Access Enable Flag (Read Only)</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RTC register read/write Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RTC register read/write Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>RTCBUSY</name>
              <description>RTC Write Busy  Flag\n0: RTC  write access enable \n1: RTC write  access disable , RTC under Busy  Status.\nNote: BUSY  By  Exceed RTC IP Prcessing  Write Counter Capacity ( 6 counts  Per  1120 PCLK cycles) .</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>RTC_FREQADJ</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>RTC_FREQADJ</displayName>
          <description>RTC Frequency Compensation Register</description>
          <addressOffset>0x8</addressOffset>
          <access>read-write</access>
          <resetValue>0x00200000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>FREQADJ</name>
              <description>Frequence Compensation Register\nLXT period:  the clock period (Hz) of LXT.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>22</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>RTC_TIME</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>RTC_TIME</displayName>
          <description>RTC Time Loading Register</description>
          <addressOffset>0xC</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SEC</name>
              <description>1-Sec Time Digit (0~9)</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TENSEC</name>
              <description>10-Sec Time Digit (0~5)</description>
              <bitOffset>4</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MIN</name>
              <description>1-Min Time Digit (0~9)</description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TENMIN</name>
              <description>10-Min Time Digit (0~5)</description>
              <bitOffset>12</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>HR</name>
              <description>1-Hour Time Digit (0~9)</description>
              <bitOffset>16</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TENHR</name>
              <description>10-hour Time Digit (0~2)\nWhen RTC runs as 12-hour time scale mode, RTC_TIME[21] (the high bit of TENHR[1:0]) means AM/PM indication. (If RTC_TIME[21] is 1, it indicates PM time message.) the high bit of TENHR (RTC_TIME[21]) means AM/PM indication.</description>
              <bitOffset>20</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>RTC_CAL</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>RTC_CAL</displayName>
          <description>RTC Calendar Loading Register</description>
          <addressOffset>0x10</addressOffset>
          <access>read-write</access>
          <resetValue>0x00150808</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DAY</name>
              <description>1-Day Calendar Digit (0~9)</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TENDAY</name>
              <description>10-Day Calendar Digit (0~3)</description>
              <bitOffset>4</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MON</name>
              <description>1-Month Calendar Digit (0~9)</description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TENMON</name>
              <description>10-Month Calendar Digit (0~1)</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>YEAR</name>
              <description>1-Year Calendar Digit (0~9)</description>
              <bitOffset>16</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TENYEAR</name>
              <description>10-Year Calendar Digit (0~9)</description>
              <bitOffset>20</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>RTC_CLKFMT</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>RTC_CLKFMT</displayName>
          <description>RTC Time Scale Selection Register</description>
          <addressOffset>0x14</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000001</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>_24HEN</name>
              <description>24-hour /12-hour Time Scale Selection\nIndicates that RTC_TIME and RTC_TALM are in 24-hour time scale or 12-hour time scale</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>12-hour time scale with AM and PM indication selected</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>24-hour time scale selected</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>RTC_WEEKDAY</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>RTC_WEEKDAY</displayName>
          <description>RTC Day of the Week Register</description>
          <addressOffset>0x18</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000006</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WEEKDAY</name>
              <description>Day of the Week Register </description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Sunday</description>
                    <value>#000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Monday</description>
                    <value>#001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Tuesday</description>
                    <value>#010</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Wednesday</description>
                    <value>#011</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>4</name>
                    <description>Thursday</description>
                    <value>#100</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>5</name>
                    <description>Friday</description>
                    <value>#101</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>6</name>
                    <description>Saturday</description>
                    <value>#110</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>7</name>
                    <description>Reserved</description>
                    <value>#111</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>RTC_TALM</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>RTC_TALM</displayName>
          <description>RTC Time Alarm Register</description>
          <addressOffset>0x1C</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SEC</name>
              <description>1-Sec Time Digit of Alarm Setting (0~9)</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TENSEC</name>
              <description>10-Sec Time Digit of Alarm Setting (0~5)</description>
              <bitOffset>4</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MIN</name>
              <description>1-Min Time Digit of Alarm Setting (0~9)</description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TENMIN</name>
              <description>10-Min Time Digit of Alarm Setting (0~5)</description>
              <bitOffset>12</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>HR</name>
              <description>1-Hour Time Digit of Alarm Setting (0~9)</description>
              <bitOffset>16</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TENHR</name>
              <description>10-hour Time Digit of Alarm Setting (0~2)\nWhen RTC runs as 12-hour time scale mode, RTC_TIME[21] (the high bit of TENHR[1:0]) means AM/PM indication. (If RTC_TIME[21] is 1, it indicates PM time message.)the high bit of TENHR (RTC_TIME[21]) means AM/PM indication.</description>
              <bitOffset>20</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>RTC_CALM</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>RTC_CALM</displayName>
          <description>RTC Calendar Alarm Register</description>
          <addressOffset>0x20</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DAY</name>
              <description>1-Day Calendar Digit of Alarm Setting (0~9)</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TENDAY</name>
              <description>10-Day Calendar Digit of Alarm Setting (0~3)</description>
              <bitOffset>4</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MON</name>
              <description>1-Month Calendar Digit of Alarm Setting (0~9)</description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TENMON</name>
              <description>10-Month Calendar Digit of Alarm Setting (0~1)</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>YEAR</name>
              <description>1-Year Calendar Digit of Alarm Setting (0~9)</description>
              <bitOffset>16</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TENYEAR</name>
              <description>10-Year Calendar Digit of Alarm Setting (0~9)</description>
              <bitOffset>20</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>RTC_LEAPYEAR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>RTC_LEAPYEAR</displayName>
          <description>RTC Leap Year Indicator Register</description>
          <addressOffset>0x24</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>LEAPYEAR</name>
              <description>Leap Year Indication Register (Read Only)</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>This year is not a leap year</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>This year is leap year</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>RTC_INTEN</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>RTC_INTEN</displayName>
          <description>RTC Interrupt Enable Register</description>
          <addressOffset>0x28</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ALMIEN</name>
              <description>Alarm Interrupt Enable Bit</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RTC Alarm interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RTC Alarm interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TICKIEN</name>
              <description>Time Tick Interrupt Enable Bit</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RTC Time Tick interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RTC Time Tick interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SNPDIEN</name>
              <description>Snoop Detection Interrupt Enable Bit</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Snoop detectedinterrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Snoop detected interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>RTC_INTSTS</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>RTC_INTSTS</displayName>
          <description>RTC Interrupt Indicator Register</description>
          <addressOffset>0x2C</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ALMIF</name>
              <description>RTC Alarm Interrupt Flag\nWhen RTC time counters RTC_TIME and RTC_CAL match the alarm setting time registers RTC_TALM and RTC_CALM, this bit will be set to 1 and an interrupt will be generated if RTC Alarm Interrupt enabled ALMIEN (RTC_INTEN[0]) is set to 1. Chip will be waken up if RTC Alarm Interrupt is enabled when chip is at Power-down mode.\nNote: Write 1 to clear this bit.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Alarm condition is not matched</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Alarm condition is matched</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TICKIF</name>
              <description>RTC Time Tick Interrupt Flag\nWhen RTC time tick happened, this bit will be set to 1 and an interrupt will be generated if RTC Tick Interrupt enabled TICKIEN (RTC_INTEN[1]) is set to 1. Chip will also be waken up if RTC Tick Interrupt is enabled and this bit is set to 1 when chip is running at Power-down mode.\nNote:Write 1 to clear to clear this bit.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Tick condition does not occur</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Tick condition occur</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SNPDIF</name>
              <description>Snoop Detect Interrupt Flag\nWhen tamper pin transition event is detected, this bit is set to 1 and an interrupt is generated if Snoop Detection Interrupt enabled SNPDIEN (RTC_INTEN[2]) is set to1. Chip will be waken up from Power-down mode if spare register snooper detect interrupt is enabled.\nNote:Write 1 to clear this bit.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No snoop event is detected</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Snoop event is detected</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>RTC_TICK</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>RTC_TICK</displayName>
          <description>RTC Time Tick Register</description>
          <addressOffset>0x30</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TICK</name>
              <description>Time Tick Register\nThese bits are used to select RTC time tick period for Periodic Time Tick Interrupt request. \nNote:This register can be read back after the RTC register access enable bit RWENF (RTC_RWEN[16]) is active.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Time tick is 1 second</description>
                    <value>#000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Time tick is 1/2 second</description>
                    <value>#001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Time tick is 1/4 second</description>
                    <value>#010</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Time tick is 1/8 second</description>
                    <value>#011</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>4</name>
                    <description>Time tick is 1/16 second</description>
                    <value>#100</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>5</name>
                    <description>Time tick is 1/32 second</description>
                    <value>#101</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>6</name>
                    <description>Time tick is 1/64 second</description>
                    <value>#110</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>7</name>
                    <description>Time tick is 1/128 second</description>
                    <value>#111</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>RTC_TAMSK</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>RTC_TAMSK</displayName>
          <description>RTC Time Alarm Mask Register</description>
          <addressOffset>0x34</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MSEC</name>
              <description>Mask 1-Sec Time Digit of Alarm Setting (0~9)</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MTENSEC</name>
              <description>Mask 10-Sec Time Digit of Alarm Setting (0~5)</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MMIN</name>
              <description>Mask 1-Min Time Digit of Alarm Setting (0~9)</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MTENMIN</name>
              <description>Mask 10-Min Time Digit of Alarm Setting (0~5)</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MHR</name>
              <description>Mask 1-Hour Time Digit of Alarm Setting (0~9)</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MTENHR</name>
              <description>Mask 10-Hour Time Digit of Alarm Setting (0~2)</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>RTC_CAMSK</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>RTC_CAMSK</displayName>
          <description>RTC Calendar Alarm Mask Register</description>
          <addressOffset>0x38</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MDAY</name>
              <description>Mask 1-Day Calendar Digit of Alarm Setting (0~9)</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MTENDAY</name>
              <description>Mask 10-Day Calendar Digit of Alarm Setting (0~3)</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MMON</name>
              <description>Mask 1-Month Calendar Digit of Alarm Setting (0~9)</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MTENMON</name>
              <description>Mask 10-Month Calendar Digit of Alarm Setting (0~1)</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MYEAR</name>
              <description>Mask 1-Year Calendar Digit of Alarm Setting (0~9)</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MTENYEAR</name>
              <description>Mask 10-Year Calendar Digit of Alarm Setting (0~9)</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>RTC_SPRCTL</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>RTC_SPRCTL</displayName>
          <description>RTC Spare Functional Control Register</description>
          <addressOffset>0x3C</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SNPDEN</name>
              <description>Snoop Detection Enable Bit</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>TAMPER pin detection Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>TAMPER pin detection Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SNPTYPE0</name>
              <description>Snoop Detection Level\nThis bit controls TAMPER detect event is rising edge or falling edge.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Rising edge detection</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Falling edge detection</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SPRRWEN</name>
              <description>Spare Register Enable Bit\nNote: When spare register is disabled, RTC_SPR0 ~ RTC_SPR4 cannot be accessed\nDid  not change the content of the spare register,  but  read  data all "0"..</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Spare register Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Spare register Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SPRCSTS</name>
              <description>SPR Clear Flag \nThis bit indicates if the RTC_SPR0 ~RTC_SPR4 content is cleared when specify snoop event is detected.\nWrites 1 to clear this bit.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Spare register content is not cleared</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Spare register content is cleared</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>RTC_SPR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>RTC_SPR0</displayName>
          <description>RTC Spare Register 0</description>
          <addressOffset>0x40</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SPARE</name>
              <description>Spare Register\nThis field is used to store back-up information defined by user.\nThis field will be cleared by hardware automatically once a snooper pin event is detected.\nBefore storing back-up information in to RTC_SPRx register, user should write 0xA965 to RTC_RWEN[15:0] to make sure register read/write enable bit REWNF (RTC_RWEN[16]) is enabled.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="RTC_SPR0">
          <name>RTC_SPR1</name>
          <displayName>RTC_SPR1</displayName>
          <description>RTC Spare Register 1</description>
          <addressOffset>0x44</addressOffset>
       </register>
       <register derivedFrom="RTC_SPR0">
          <name>RTC_SPR2</name>
          <displayName>RTC_SPR2</displayName>
          <description>RTC Spare Register 2</description>
          <addressOffset>0x48</addressOffset>
       </register>
       <register derivedFrom="RTC_SPR0">
          <name>RTC_SPR3</name>
          <displayName>RTC_SPR3</displayName>
          <description>RTC Spare Register 3</description>
          <addressOffset>0x4C</addressOffset>
       </register>
       <register derivedFrom="RTC_SPR0">
          <name>RTC_SPR4</name>
          <displayName>RTC_SPR4</displayName>
          <description>RTC Spare Register 4</description>
          <addressOffset>0x50</addressOffset>
       </register>
       <register>
          <name>RTC_LXTCTL</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>RTC_LXTCTL</displayName>
          <description>RTC 32.768 kHz Oscillator Control Register</description>
          <addressOffset>0x100</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>LXT_TYPE</name>
              <description>LXT TYPE Selection </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Crystal type ( Crystal connect to X32KI with X32KO)</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Oscator illator type ( LXT source from  X32KI PIN ,  X32KO as  GPIO</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>RTC_LXTOCTL</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>RTC_LXTOCTL</displayName>
          <description>X32KO Pin Control Register</description>
          <addressOffset>0x104</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>OPMODE</name>
              <description>GPF0 Operation Mode</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>X32KO (PF.6) is input only mode, without pull-up resistor</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>X32KO (PF.6) is output push pull mode</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>X32KO (PF.6) is open drain mode</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>X32KO (PF.6) is input only mode with internal pull up</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DOUT</name>
              <description>IO Output Data</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>X32KO (PF.6) output low</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>X32KO (PF.6) output high</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CTLSEL</name>
              <description>IO Pin State Backup Selection\nWhen low speed 32 kHz oscillator is disabled, X32KO (PF.6) pin can be used as GPIO function. User can program CTLSEL bit to decide X32KO (PF.6) I/O function is controlled by system power domain GPIO module or VBAT power domain RTC_LXTOCTL control register.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>X32KO (PF.6) pin I/O function is controlled by GPIO module. It becomes floating when system power is turned off</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>X32KO (PF.6) pin I/O function is controlled by VBAT power domain, X32KO (PF.6) pin function and I/O status are controlled by OPMODE[1:0] and DOUT after CTLSEL it set to 1. I/O pin keeps the previous state after system power is turned off</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>RTC_LXTICTL</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>RTC_LXTICTL</displayName>
          <description>X32KI Pin Control Register</description>
          <addressOffset>0x108</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>OPMODE</name>
              <description>IO Operation Mode</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>X32KI (PF.7) is input only mode, without pull-up resistor</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>X32KI (PF.7) is output push pull mode</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>X32KI (PF.7) is open drain mode</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>X32KI (PF.7) is input only mode with internal pull up</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DOUT</name>
              <description>IO Output Data</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>X32KI (PF.7) output low</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>X32KI (PF.7) output high</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CTLSEL</name>
              <description>IO Pin State Backup Selection\nWhen low speed 32 kHz oscillator is disabled, X32KI (PF.7) pin can be used as GPIO function. User can program CTLSEL bit to decide X32KI (PF.7) I/O function is controlled by system power domain GPIO module or VBAT power domain RTC_LXTICTL control register.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>X32KI (PF.7) pin I/O function is controlled by GPIO module. It becomes floating state when system power is turned off</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>X32KI (PF.7) pin I/O function is controlled by VBAT power domain, X32KI (PF.7) pin function and I/O status are controlled by OPMODE[1:0] and DOUT after CTLSEL it set to 1. I/O pin keeps the previous state after system power is turned off</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>RTC_TAMPCTL</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>RTC_TAMPCTL</displayName>
          <description>TAMPER Pin Control Register</description>
          <addressOffset>0x10C</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>OPMODE</name>
              <description>IO Operation Mode</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>TAMPER (LQFP64:PB.13/LQFP48:PA.9/QFN32:PB.8) is input only mode, without pull-up resistor</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>TAMPER (LQFP64:PB.13/LQFP48:PA.9/QFN32:PB.8) is output push pull mode</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>TAMPER (LQFP64:PB.13/LQFP48:PA.9/QFN32:PB.8) is open drain mode</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>TAMPER (LQFP64:PB.13/LQFP48:PA.9/QFN32:PB.8) is input only mode with internal pull up</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DOUT</name>
              <description>IO Output Data</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>TAMPER (LQFP64:PB.13/LQFP48:PA.9/QFN32:PB.8) output low</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>TAMPER (LQFP64:PB.13/LQFP48:PA.9/QFN32:PB.8) output high</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CTLSEL</name>
              <description>IO Pin State Backup Selection\nWhen tamper function is disabled, TAMPER pin can be used as GPIO function. User can program CTLSEL bit to decide (LQFP64:PB.13/LQFP48:PA.9/QFN32:PB.8) I/O function is controlled by system power domain GPIO module or VBAT power domain RTC_TAMPCTL control register.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>TAMPER (LQFP64:PB.13/LQFP48:PA.9/QFN32:PB.8) I/O function is controlled by GPIO module. It becomes floating state when system power is turned off</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>TAMPER (LQFP64:PB.13/LQFP48:PA.9/QFN32:PB.8) I/O function is controlled by VBAT power domain. LQFP64:PB.13/LQFP48:PA.9/QFN32:PB.8 function and I/O status are controlled by OPMODE[1:0] and DOUT after CTLSEL it set to 1. I/O pin state keeps previous state after system power is turned off</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>UART0</name>
      <description>UART Register Map</description>
      <groupName>UART</groupName>
      <baseAddress>0x40050000</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x0</offset>
        <size>0x28</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x30</offset>
        <size>0x18</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>UART_DAT</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UART_DAT</displayName>
          <description>UART Receive/Transmit Buffer Register.</description>
          <addressOffset>0x0</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>DAT</name>
              <description>Receive /Transmit Buffer\nWrite Operation:\nBy writing one byte to this register, the data byte will be stored in transmitter FIFO. The UART Controller will send out the data stored in transmitter FIFO top location through the UART_DAT.\nRead Operation:\nBy reading this register, the UART will return an 8-bit data received from receiving FIFO.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UART_CTRL</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UART_CTRL</displayName>
          <description>UART Control Register.</description>
          <addressOffset>0x4</addressOffset>
          <access>read-write</access>
          <resetValue>0x0700000C</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RXRST</name>
              <description>RX Field Software Reset\nWhen RXRST (UART_CTRL[0]) is set, all the byte in the receiver FIFO and RX internal state machine are cleared.\nNote: This bit will automatically clear at least 3 UART peripheral clock cycles.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reset the RX internal state machine and pointers</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TXRST</name>
              <description>TX Field Software Reset\nWhen TXRST (UART_CTRL[1]) is set, all the byte in the transmit FIFO and TX internal state machine are cleared.\nNote: This bit will automatically clear at least 3 UART peripheral clock cycles</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reset the TX internal state machine and pointers</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RXOFF</name>
              <description>Receiver Disable Bit\nNote1:In RS-485 NMM mode, user can set this bit to receive data before detecting address byte.\nNote2: In RS-485 AAD mode, this bit will be setting to "1" automatically.\nNote3: In RS-485 AUD mode and LIN "break + sync +PID" header mode, hardware will control data automatically, so don't fill any value to this bit.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Receiver Enabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Receiver Disabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TXOFF</name>
              <description>Transfer Disable Bit</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Transfer Enabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Transfer Disabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ATORTSEN</name>
              <description>nRTS Auto-flow Control Enable Bit\nNote: When nRTS auto-flow is enabled, if the number of bytes in the RX FIFO equals the RTSTRGLV (UART_LINE[13:12]), the UART will de-assert nRTS signal.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>nRTS auto-flow control Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>nRTS auto-flow control Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ATOCTSEN</name>
              <description>nCTS Auto-flow Control Enable Bit\nNote:When nCTS auto-flow is enabled, the UART will send data to external device if nCTS input assert (UART will not send data to device until nCTS is asserted).</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>nCTS auto-flow control Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>nCTS auto-flow control Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RXDMAEN</name>
              <description>RX DMA Enable Bit\nThis bit can enable or disable RX DMA service.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RX DMA Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RX DMA Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TXDMAEN</name>
              <description>TX DMA Enable Bit\nThis bit can enable or disable TX DMA service.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>TX DMA Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>TX DMA Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>FTOEN</name>
              <description>Frame Time Out Enable Bit\nThis bit is used to enable the timer counter even the FIFO is still empty.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Frame time out Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Frame time out Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ABRDEN</name>
              <description>Auto-baud Rate Detect EnableBit\nNote: When the auto-baud rate detect operation finishes, hardware will clear this bit and the associated interrupt (ABRIF) will be generated (If ABRIEN (UART_INTEN [7]) be enabled).</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Auto-baud rate detect function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Auto-baud rate detect function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ABRDBITS</name>
              <description>Auto-baud Rate Detect Bit Length\nNote: The calculation of bit number includes the START bit.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>1-bit time from Start bit to the 1st rising edge. The input pattern shall be 0x01</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>2-bit time from Start bit to the 1st rising edge. The input pattern shall be 0x02</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>4-bit time from Start bit to the 1st rising edge. The input pattern shall be 0x08</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>8-bit time from Start bit to the 1st rising edge. The input pattern shall be 0x80</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UART_LINE</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UART_LINE</displayName>
          <description>UART Transfer Line Control Register.</description>
          <addressOffset>0x8</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WLS</name>
              <description>Word Length Selection\nThis field sets UART word length.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>5 bits</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>6 bits</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>7 bits</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>8 bits</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>NSB</name>
              <description>Number of "STOP Bit"</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>One "STOP bit" is generated in the transmitted data</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>When select 5-bit word length, 1.5 "STOP bit" is generated in the transmitted data. When select 6-, 7- and 8-bit word length, 2 "STOP bit" is generated in the transmitted data</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PBE</name>
              <description>Parity Bit EnableBit\nNote: Parity bit is generated on each outgoing character and is checked on each incoming data.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No parity bit generated Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Parity bit generated Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>EPE</name>
              <description>Even Parity EnableBit\nNote:This bit has effect only when PBE (UART_LINE[3]) is set.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Odd number of logic 1's is transmitted and checked in each word</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Even number of logic 1's is transmitted and checked in each word</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SPE</name>
              <description>Stick Parity Enable Bit\nNote: If PBE (UART_LINE[3]) and EPE (UART_LINE[4]) are logic 1, the parity bit is transmitted and checked as logic 0. If PBE (UART_LINE[3]) is 1 and EPE (UART_LINE[4]) is 0 then the parity bit is transmitted and checked as 1.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Stick parity Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Stick parity Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BCB</name>
              <description>Break Control Bit\nNote: When this bit is set to logic 1, the serial data output (TX) is forced to the Spacing State (logic 0). This bit acts only on TX line and has no effect on the transmitter logic.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Break Control Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Break Control Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RFITL</name>
              <description>RX FIFO Interrupt Trigger Level\nWhen the number of bytes in the receive FIFO equals the RFITL, the RDAIF will be set (if RDAIEN (UART_INTEN [0]) enabled, and an interrupt will be generated).\nNote: When operating in IrDA mode or RS-485 mode, the RFITL must be set to "0".</description>
              <bitOffset>8</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RX FIFO Interrupt Trigger Level is 1 byte</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RX FIFO Interrupt Trigger Level is 4 bytes</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>10</name>
                    <description>RX FIFO Interrupt Trigger Level is 8 bytes</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>11</name>
                    <description>RX FIFO Interrupt Trigger Level is 14 bytes</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RTSTRGLV</name>
              <description>nRTS Trigger Level for Auto-flow Control Use\nNote: This field is used for auto nRTS flow control.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>nRTS Trigger Level is 1 byte</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>nRTS Trigger Level is 4 bytes</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>nRTS Trigger Level is 8 bytes</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>nRTS Trigger Level is 14 bytes</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UART_INTEN</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UART_INTEN</displayName>
          <description>UART Interrupt Enable Register.</description>
          <addressOffset>0xC</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RDAIEN</name>
              <description>Receive Data Available Interrupt Enable Bit</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Receive data available interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Receive data available interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>THREIEN</name>
              <description>Transmit Holding Register Empty Interrupt Enable Bit</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Transmit holding register empty interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Transmit holding register empty interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RLSIEN</name>
              <description>Receive Line Status Interrupt Enable Bit</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Receive Line Status interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Receive Line Status interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>MODEMIEN</name>
              <description>Modem Status Interrupt Enable Bit</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Modem status interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Modem statusinterrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RXTOIEN</name>
              <description>RX Time-out Interrupt Enable Bit</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RX time-out interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RX time-outinterrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BUFERRIEN</name>
              <description>Buffer Error Interrupt Enable Bit</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Buffer error interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Buffer error interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>WKUPIEN</name>
              <description>Wake-up Interrupt EnableBit\nNote: Hardware will clear one of the wake-up status bits in UART_WKUPSTS when the wake-up operation finishes and "system clock" work stable.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Wake-up system function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Wake-up system function Enabled, when the system is in Power-down mode, one of the wake-up event will wake-up system from Power-down mode.</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ABRIEN</name>
              <description>Auto-baud Rate Interrupt Enable Bit</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Auto-baud rate interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Auto-baud rate interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>LINIEN</name>
              <description>LIN Bus Interrupt Enable Bit\nNote:This bit is used for LIN function mode.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>LIN bus interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>LIN bus interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TXENDIEN</name>
              <description>Transmitter Empty FInterrupt Enable Bit\nNote: If the bit is enabled, there is interrupt event when the TXENDF (UART_FIFOSTS[11]) is actived.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Transmit Empty interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Transmit Empty interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UART_INTSTS</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UART_INTSTS</displayName>
          <description>UART Interrupt Status Register.</description>
          <addressOffset>0x10</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000002</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RDAIF</name>
              <description>Receive Data Available Interrupt Flag (Read Only)\nWhen the number of bytes in the RX FIFO equals the RFITL then the RDAIF(UART_INTSTS[0]) will be set. If RDAIEN (UART_INTEN [0]) is enabled, the RDA interrupt will be generated.\nNote: This bit is read only and it will be cleared when the number of unread bytes of RX FIFO drops below the threshold level (RFITL(UART_LINE[9:8])</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No RDA interrupt flag is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RDA interrupt flag is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>THREIF</name>
              <description>Transmit Holding Register Empty Interrupt Flag (Read Only)\nThis bit is set when the last data of TX FIFO is transferred to Transmitter Shift Register. If THREIEN (UART_INTEN[1]) is enabled, the THRE interrupt will be generated.\nNote: This bit is read only and it will be cleared when writing data into UART_DAT (TX FIFO not empty)</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No THRE interrupt flag is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>THRE interrupt flag is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>RLSIF</name>
              <description>Receive Line Interrupt Flag (Read Only)\nThis bit is set when the RX receive data have parity error, frame error or break error (at least one of 3 bits, BIF(UART_FIFOSTS[6]), FEF(UART_FIFOSTS[5]) and PEF(UART_FIFOSTS[4]), is set). If RLSIEN (UART_INTEN [2]) is enabled, the RLS interrupt will be generated.\nNote2: This bit is read only and reset to 0 when all bits of BIF (UART_FIFOSTS[6]), FEF(UART_FIFOSTS[5]) and PEF(UART_FIFOSTS[4]) are cleared.\nNote3: In RS-485 function mode, this bit is read only and reset to 0 when all bits of BIF (UART_FIFOSTS[6]) , FEF(UART_FIFOSTS[5]) and PEF(UART_FIFOSTS[4]) and ADDRDETF (UART_TRSR[0]) are cleared.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No RLS interrupt flag is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RLS interrupt flag is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>MODEMIF</name>
              <description>MODEM Interrupt Flag (Read Only) Channel \nNote: This bit is read only and reset to 0 when bit CTSDETF is cleared by a write 1 on CTSDETF(UART_MODEM[18]).</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No Modem interrupt flag is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Modem interrupt flag is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>RXTOIF</name>
              <description>Rime-out Interrupt Flag (Read Only)\nThis bit is set when the RX FIFO is not empty and no activities occurred in the RX FIFO and the time-out counter equal to TOIC. If RXTOIEN (UART_INTEN [4]) is enabled, the Tout interrupt will be generated.\nNote: This bit is read only and user can read UART_DAT (RX is in active) to clear it</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No Time-out interrupt flag is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Time-out interrupt flag is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>BUFERRIF</name>
              <description>Buffer Error Interrupt Flag (Read Only)\nThis bit is set when the TX FIFO or RX FIFO overflows (TXOVIF (UART_FIFOSTS[8]) or RXOVIF (UART_FIFOSTS[0]) is set). When BUFERRIF (UART_INTSTS[5])is set, the transfer is not correct. If BFERRIEN (UART_INTEN [5]) is enabled, the buffer error interrupt will be generated.\nNote:This bit is read only. This bit is cleared if both of RXOVIF(UART_FIFOSTS[0]) and TXOVIF(UART_FIFOSTS[8]) are cleared to 0 by writing 1 to RXOVIF(UART_FIFOSTS[0]) and TXOVIF(UART_FIFOSTS[8]).</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No buffer error interrupt flag is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Buffer error interrupt flag is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>WKUPIF</name>
              <description>Wake-up Interrupt Flag (Read Only)\nThis bit is set if chip wake-up from power-down state by one of UART controller wake-up event.\nNote1: If WKDATEN (UART_INTEN[6]) is enabled, the wake-up interrupt is generated.\nNote2: This bit is read only, but can be cleared by writing '1' to one of UART_WKUPSTS[4:0] (THRTOWKSTS or THRWKSTS or CTSWKSTS or DATWKSTS or ADRWKSTS).</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Chip stays in power-down state</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Chip wake-up from power-down state by one of UART controller wake-up event</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>ABRIF</name>
              <description>Auto-baud Rate Interrupt Status Flag (Read Only)\nThis bit is set when auto-baud rate detection function finished or the auto-baud rate counter was overflow and if ABRIEN (UART_INTEN[7]) is set then the auto-baud rate interrupt will be generated.\nNote1: This bit is read only, but can be cleared by writing "1" to ABRDTOIF (UART_TRSR[2]) or ABRDIF (UART_TRSR[1]).\nNote2: This bit is cleared when both the ABRDTOIF and ABRDIF are cleared.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No Auto-Baud Rate interrupt is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Auto-Baud Rate interrupt is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>LINIF</name>
              <description>LIN Interrupt Status Flag (Read Only)\nThis bit is set when the LIN TX header transmitted, RX header received or the SIN does not equal SOUT and if LINIEN(UART_INTEN[8]) is set then the LIN interrupt will be generated.\nNote1: This bit is read only, but can be cleared by it by writing "1" to BITEF (UART_TRSR[5]), LINTXIF (UART_TRSR[3]) or LINRXIF (UART_TRSR[4]).\nNote2: This bit is cleared when both the BITEF, LINTXIF and LINRXIF are cleared.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No LIN interrupt is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>LIN interrupt is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UART_TRSR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UART_TRSR</displayName>
          <description>UART Transfer Status Register.</description>
          <addressOffset>0x14</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ADDRDETF</name>
              <description>RS-485 Address Byte Detection Status Flag (Read Only)\nNote1: This field is used for RS-485 function mode and ADDRDEN (UART_ATLCTL[19]) is set to 1 to enable Address detection mode .\nNote2: This bit is read only, but can be cleared by writing '1' to it.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Receiver detects a data that is not an address bit (bit 9 ='0')</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Receiver detects a data that is an address bit (bit 9 ='1')</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>ABRDIF</name>
              <description>Auto-baud Rate Interrupt (Read Only)\nThis bit is set to logic "1" when auto-baud rate detect function finished.\nNote: This bit is read only, but can be cleared by writing "1" to it.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No Auto- Baud Rate interrupt is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Auto-Baud Rate interrupt is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>ABRDTOIF</name>
              <description>Auto-baud Rate Time-out Interrupt(Read Only)\nNote1:This bit is set to logic "1" in Auto-baud Rate Detect mode and the baud rate counter is overflow.\nNote2: This bit is read only, but can be cleared by writing "1" to it.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Auto-baud rate counter is underflow</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Auto-baud rate counter is overflow</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>LINTXIF</name>
              <description>LIN TX Interrupt Flag (Read Only)\nThis bit is set to logic "1" when LIN transmitted header field. The header may be "break field" or "break field + sync field" or "break field + sync field + PID field", it can be choose by setting LINHSEL (UART_ATLCTL[5:4]) register.\nNote: This bit is read only, but can be cleared by writing "1" to it.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No LIN Transmit interrupt is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>LIN Transmit interrupt is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>LINRXIF</name>
              <description>LIN RX Interrupt Flag (Read Only)\nThis bit is set to logic "1" when received LIN header field. The header may be "break field" or "break field + sync field" or "break field + sync field + PID field", and it can be choose by setting LINHSEL (UART_ATLCTL[5:4]) register.\nNote: This bit is read only, but can be cleared by writing "1" to it.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No LIN Rx interrupt is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>LIN Rx interrupt is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>BITEF</name>
              <description>Bit Error Detect Status Flag (Read Only)\nAt TX transfer state, hardware will monitoring the bus state, if the input pin (SIN) state is not equal to the output pin (SOUT) state, BITEF will be set.\nWhen occur bit error, hardware will generate an interrupt to CPU (LININT).</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No Bit error interrupt is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Bit error interrupt is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>RXBUSY</name>
              <description>Receive Busy Status(Read Only)\nNote: The user can use this to check the busy status in receiver mode. If the user wants to enter power down, this bit shall be confirm in Idle state and there is 2 UART clock latency for receiver pin.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The receiver machine stays in idle state</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The receiver machine stays in no Idle state</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>SLVSYNCF</name>
              <description>LIN RX SYNC Error Flag (Read Only)\nThis bit is set to logic "1" when LIN received incorrect SYNC field.\nUser can choose the header by setting LINHSEL (UART_ATLCTL[5:4]) register.\nNote: This bit is read only, but can be cleared by writing "1" to LINRXIF.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No LIN Rx sync error is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>LIN Rx sync error is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UART_FIFOSTS</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UART_FIFOSTS</displayName>
          <description>UART FIFO Status Register.</description>
          <addressOffset>0x18</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000A02</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RXOVIF</name>
              <description>RX Overflow Error Status Flag (Read Only)\nThis bit is set when RX FIFO overflow. If the number of bytes of received data is greater than RX_FIFO (UART_DAT) size, this bit will be set.\nNote:This bit is read only, but can be cleared by writing "1" to it.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RX FIFO is not overflow</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RX FIFO is overflow</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>RXEMPTY</name>
              <description>Receiver FIFO Empty (Read Only)\nThis bit initiate RX FIFO empty or not.\nNote: When the last byte of RX FIFO has been read by CPU, hardware sets this bit high. It will be cleared when UART receives any new data.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RX FIFO is not empty</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RX FIFO is empty</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>RXFULL</name>
              <description>Receiver FIFO Full (Read Only)\nThis bit initiates RX FIFO full or not.\nNote: This bit is set when the number of usage in RX FIFO Buffer is equal to 16, otherwise is cleared by hardware.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RX FIFO is not full</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RX FIFO is full</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>PEF</name>
              <description>Parity Error State Status Flag (Read Only)\nThis bit is set to logic 1 whenever the received character does not have a valid "parity bit".\nNote: This bit is read only, but can be cleared by writing '1' to it.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No parity error is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Parity error is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>FEF</name>
              <description>Framing Error Flag (Read Only)\nThis bit is set to logic 1 whenever the received character does not have a valid "stop bit" (that is, the stop bit following the last data bit or parity bit is detected as logic 0).\nNote: This bit is read only, but can be cleared by writing '1' to it.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No framing error is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Framing error is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>BIF</name>
              <description>Break Interrupt Flag( Read Only)\nThis bit is set to logic 1 whenever the received data input (RX) is held in the "spacing state" (logic 0) for longer than a full word transmission time (that is, the total time of "start bit" + data bits + parity + stop bits).\nNote: This bit is read only, but can be cleared by writing '1' to it.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No Break interrupt is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Break interrupt is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>TXOVIF</name>
              <description>TX Overflow Error Interrupt Status Flag (Read Only)\nIf TX FIFO (UART_DAT) is full, an additional write to UART_DAT will cause this bit to logic 1.\nNote:This bit is read only, but can be cleared by writing "1" to it.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>TX FIFO did not overflow</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>TX FIFO overflowed</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>TXEMPTY</name>
              <description>Transmitter FIFO Empty (Read Only)\nThis bit indicates TX FIFO empty or not.\nNote: When the last byte of TX FIFO has been transferred to Transmitter Shift Register, hardware sets this bit high. It will be cleared when writing data into DAT (TX FIFO not empty).</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>TX FIFO is not empty</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>TX FIFO is empty</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>TXFULL</name>
              <description>Transmitter FIFO Full  (Read Only)\nThis bit indicates TX FIFO full or not.\nNote:This bit is set when the number of usage in TX FIFO Buffer is equal to 16, otherwise is cleared by hardware.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>TX FIFO is not full</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>TX FIFO is full</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>TXENDF</name>
              <description>Transmitter Empty Flag (Read Only)\nThis bit is set by hardware when TX FIFO (UART_DAT) is empty and the STOP bit of the last byte has been transmitted.\nNote:This bit is cleared automatically when TX FIFO is not empty or the last byte transmission has not completed.</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>TX FIFO is not empty or the STOP bit of the last byte has been not transmitted</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>TX FIFO is empty and the STOP bit of the last byte has been transmitted</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>RXPTR</name>
              <description>RX FIFO Pointer (Read Only)\nThis field indicates the RX FIFO Buffer Pointer. When UART receives one byte from external device, RXPTR increases one. When one byte of RX FIFO is read by CPU, RXPTR decreases one.\nThe Maximum value shown in RXPTR is 15. When the using level of RX FIFO Buffer equal to 16, the RXFULL bit is set to 1 and RXPTR will show 0. As one byte of RX FIFO is read by CPU, the RXFULL bit is cleared to 0 and RXPTR will show 15.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TXPTR</name>
              <description>TX-fIFO Pointer (Read Only)\nThis field indicates the TX FIFO Buffer Pointer. When CPU writes one byte into UART_DAT, TXPTR increases one. When one byte of TX FIFO is transferred to Transmitter Shift Register, TXPTR decreases one.\nThe Maximum value shown in TXPTR is 15. When the using level of TX FIFO Buffer equal to 16, the TXFULL bit is set to 1 and TXPTR will show 0. As one byte of TX FIFO is transferred to Transmitter Shift Register, the TXFULL bit is cleared to 0 and TXPTR will show 15.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UART_MODE</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UART_MODE</displayName>
          <description>UART Modem Control Status Register.</description>
          <addressOffset>0x1C</addressOffset>
          <access>read-write</access>
          <resetValue>0x00020002</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RTSACTLV</name>
              <description>nRTS Pin Active Level\nThis bit defines the active level state of nRTS pin output.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>nRTS pin output is high level active</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>nRTS pin output is low level active. (Default)</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RTSSTS</name>
              <description>nRTS Pin State (Read Only)\nThis bit mirror from nRTS pin output of voltage logic status.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>nRTS pin output is low level voltage logic state</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>nRTS pin output is high level voltage logic state</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>CTSACTLV</name>
              <description>nCTS Trigger Level\nThis bit defines the active level state of nCTS pin input.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>nCTS pin input is high level active</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>nCTS pin input is low level active. (Default)</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CTSSTS</name>
              <description>nCTS Pin Status (Read Only)\nThis bit mirror from nCTS pin input of voltage logic status.\nNote: This bit echoes when UART Controller peripheral clock is enabled, and nCTS multi-function port is selected.</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>nCTS pin input is low level voltage logic state</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>nCTS pin input is high level voltage logic state</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>CTSDETF</name>
              <description>Detect nCTS State Change Flag (Read Only)\nThis bit is set whenever nCTS input has change state, and it will generate Modem interrupt to CPU when MODEMIEN (UART_INTEN[3]).\nNote: This bit is read only, but it can be cleared by writing "1" to it.</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>nCTS input has not change state</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>nCTS input has change state</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UART_TOUT</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UART_TOUT</displayName>
          <description>UART Time-Out Control Register.</description>
          <addressOffset>0x20</addressOffset>
          <access>read-write</access>
          <resetValue>0x000001FF</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TOIC</name>
              <description>Time-out Comparator\nNote1: Fill all "0" to this field indicates to disable this function.\nNote2: The real time-out value is TOIC + 1.\nNote3: The counting clock is baud rate clock.\nNote4: The UART data format is start bit + 8 data bits + parity bit + stop bit, although software can configure this field by any value but it is recommend to fill this field great than 0xA.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>9</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DLY</name>
              <description>TX Delay Time Value\nThis field is used to programming the transfer delay time between the last stop bit and next start bit. The unit is bit time.\nNote1: Fill all "0" to this field indicates to disable this function.\nNote2: The real delay value is DLY.\nNote3:The counting clock is baud rate clock.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UART_BAUD</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UART_BAUD</displayName>
          <description>UART Baud Rate Divisor Register.</description>
          <addressOffset>0x24</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BRD</name>
              <description>Baud Rate Divider \nThe field indicates the baud rate divider. This filed is used in baud rate calculation. The detail description is shown inUART Controller Baud Rate Generation.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DIV16EN</name>
              <description>Divider 16 Enable Control\nNote: In IrDA mode, this bit must clear to "0".</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The equation of baud rate is UART_CLK / [(BRD+1)]</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The equation of baud rate is UART_CLK / [16 * (BRD+1)]</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UART_IRDA</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UART_IRDA</displayName>
          <description>UART IrDA Control Register.</description>
          <addressOffset>0x30</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000040</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TXEN</name>
              <description>IrDA Receiver/Transmitter Selection Enable Bit</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>IrDA Transmitter Disabled and Receiver Enabled. (Default)</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>IrDA Transmitter Enabled and Receiver Disabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TXINV</name>
              <description>IrDA Inverse Transmitting Output Signal </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>None inverse transmitting signal. (Default)</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Inverse transmitting output signal</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RXINV</name>
              <description>IrDA Inverse Receive Input Signal </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>None inverse receiving input signal</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Inverse receiving input signal. (Default)</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UART_ATLCTL</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UART_ATLCTL</displayName>
          <description>UART Alternate Control State Register.</description>
          <addressOffset>0x34</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BRKFL</name>
              <description>LIN TX Break Field Count \nThe field contains 3-bit LIN TX break field count.\nNote: The break field length is BRKFL + 8.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>LINHSEL</name>
              <description>LIN Header Selection</description>
              <bitOffset>4</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The LIN header includes "break field"</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The LIN header includes "break field + sync field"</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>The LIN header includes "break field + sync field + PID field"</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Reserved</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>LINRXEN</name>
              <description>LIN RX Enable Control\nWhen LIN RX mode enabled and received a break field or sync field or PID field (Select by LIN_Header_SEL), the controller will generator a interrupt to CPU (LININT)</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>LIN RX mode Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>LIN RX mode Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>LINTXEN</name>
              <description>LIN TX Header Trigger EnableBit\nThe LIN TX header can be "break field" or "break and sync field" or "break, sync and frame ID field", it is depend on setting LINHSEL (UART_ATLCTL[5:4]).\nNote1: This bit will be cleared automatically and generate a interrupt to CPU (LININT).\nNote2:When transmitter header field (it may be "break" or "break + sync" or "break + sync + frame ID" selected by LINHSEL (UART_ATLCTL[5:4]) field) transfer operation finished, this bit will be cleared automatically.\nNote3: If user wants to receive transmit data, it recommended to enable LINRXEN bit.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Send LIN TX header Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Send LIN TX header Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BITERREN</name>
              <description>Bit Error Detect EnableBit</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Bit error detection Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Bit error detection Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RS485NMM</name>
              <description>RS-485 Normal Multi-drop Operation Mode (NMM)\nNote: It cannot be active with RS-485_AAD operation mode.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RS-485 Normal Multi-drop Operation mode (NMM) Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RS-485 Normal Multi-drop Operation mode (NMM) Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RS485AAD</name>
              <description>RS-485 Auto Address Detection Operation Mode (AAD)\nNote: It cannot be active with RS485NMM operation mode.</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RS-485 Auto Address Detection Operation mode (AAD) Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RS-485 Auto Address Detection Operation mode (AAD) Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RS485AUD</name>
              <description>RS-485 Auto Direction Function (AUD)\nNote: It can be active with RS485AAD or RS485NMM operation mode.</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RS-485 Auto Direction Operation function (AUD) Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RS-485 Auto Direction Operation function (AUD) Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ADDRDEN</name>
              <description>RS-485 Address Detection Enable Bit\nThis bit is used to enable RS-485 Address Detection mode. \nNote: This bit is used for RS-485 any operation mode.</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Address detection mode Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Address detection mode Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ADRMPID</name>
              <description>Address / PID Match Value Register\nWhen in the RS-485 Function Mode, this field contains the RS-485 address match values.\nWhen in the LIN Function mode, this field contains the LIN protected identifier field, software fills ID0~ID5 (PID [5:0]), hardware will calculate P0 and P1.\n\nNote: This field is used for RS-485 auto address detection mode or used for LIN protected identifier field (PID).</description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UART_FUNCSEL</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UART_FUNCSEL</displayName>
          <description>UART Function Select Register.</description>
          <addressOffset>0x38</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>FUNCSEL</name>
              <description>Function Selection</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>UART function mode</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>LIN function mode</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>IrDA function mode</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>RS-485 function mode</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UART_BRCOMPAT</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UART_BRCOMPAT</displayName>
          <description>UART Baud Rate Compensation Register.</description>
          <addressOffset>0x3C</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BRCOMPAT</name>
              <description>Baud Rate Compensation Patten\nThese 9bits are used to define the relative bit is compensated or not. BRCOMPAT[7:0] is used to define the compensation of D[7:0] and BRCOMPAT{[8] is used to define the parity bit.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>9</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>BRCOMPDEC</name>
              <description>Baud Rate Compensation Decrease</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Positive (increase one module clock) compensation for each compensated bit</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Negative (decrease one module clock) compensation for each compensated bit</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UART_WKUPEN</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UART_WKUPEN</displayName>
          <description>UART Wake-up Enable Register.</description>
          <addressOffset>0x40</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WKCTSEN</name>
              <description>CTSn Wake-up Enable Bit\nWhen the system is in power-down mode, an external nCTS change will wake-up system from power-down mode.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>nCTS wake-up function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>nCTS wake-up function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>WKDATEN</name>
              <description>Incoming Data Wake-up Enable Bit\nNote: Hardware will clear this bit when the incoming data wake-up operation finishes and "system clock" work stable.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Incoming data wake-up function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Incoming data wake-up function Enabled when the system is in power-down mode, incoming data will wake-up system from power-down mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>WKTHREN</name>
              <description>FIFO Threshold Reach Wake-up Enable Bit\nNote: It is suggest the function is enabled in UART mode and the UART clock is selected in 32K.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Received FIFO threshold reach wake-up function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Received FIFO threshold reach wake-up function Enabled when the system is in power-down mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>WKTHRTOEN</name>
              <description>FIFO Threshold Reach Time Out Wake-up Enable Bit\nNote: It is suggest the function is enabled when the WKTHREN (UART_WKUPEN[2]) is set to 1.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Received FIFO threshold no reach and time out wake-up function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Received FIFO threshold no reach and time out wake-up function Enabled when the system is in power-down mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>WKADRMEN</name>
              <description>RS-485 Address Match Wake-up Enable Bit</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RS-485 ADD mode address match wake-up function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RS-485 AAD mode address match wake-up function Enabled when the system is in power-down mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UART_WKUPSTS</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UART_WKUPSTS</displayName>
          <description>UART Wake-up Status Register.</description>
          <addressOffset>0x44</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CTSWKSTS</name>
              <description>nCTS Wake-up Flag (Read Only)\nNote1: If WKCTSEN (UART_ WKUPEN [0])is enabled, the wake-up function is generated.\nNote2: This bit is read only, but can be cleared by writing '1' to it.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Chip stays in power-down state</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Chip wake-up from power-down state by nCTS wake-up</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>DATWKSTS</name>
              <description>Data Wake-up Flag (Read Only)\nThis bit is set if chip wake-up from power-down state by data wake-up.\nNote1: If WKDATEN (UART_ WKUPEN [1]) is enabled, the wake-up function is generated.\nNote2: This bit is read only, but can be cleared by writing '1' to it</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Chip stays in power-down state</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Chip wake-up from power-down state by data wake-up</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>THRWKSTS</name>
              <description>Threshold Wake-up Flag (Read Only)\nNote1: If WKTHREN (UART_ WKUPEN [2])is enabled, the wake-up function is generated.\nNote2: This bit is read only, but can be cleared by writing '1' to it.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Chip stays in power-down state</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Chip wake-up from power-down state by FIFO threshold wake-up</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>THRTOWKSTS</name>
              <description>Threshold Wake-up Time Out Flag (Read Only)\nNote1: If WKTHRTOEN (UART_ WKUPEN [3])is enabled, the wake-up function is generated.\nNote2: This bit is read only, but can be cleared by writing '1' to it.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Chip stays in power-down state</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Chip wake-up from power-down state by FIFO threshold time out wake-up</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>ADRWKSTS</name>
              <description>RS-485 Address Byte Detection Wake-up Flag (Read Only)\nNote1: If WKADRMEN (UART_WKUPEN[4])is enabled, the wake-up function is generated.\nNote2: This field is used for RS-485 function mode and ADDRDEN (UART_ATLCTL[19]) is set to 1 to enable Address detection mode .\nNote2: This bit is read only, but can be cleared by writing '1' to it.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Chip stays in power-down state</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Chip wake-up from power-down state by Receiver detects a data that is an address bit (bit 9 ='1')</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
          </fields>
       </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>UART1</name>
      <description>UART Register Map</description>
      <groupName>UART</groupName>
      <baseAddress>0x40150000</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x0</offset>
        <size>0x28</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x30</offset>
        <size>0x18</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>UART_DAT</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UART_DAT</displayName>
          <description>UART Receive/Transmit Buffer Register.</description>
          <addressOffset>0x0</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>DAT</name>
              <description>Receive /Transmit Buffer\nWrite Operation:\nBy writing one byte to this register, the data byte will be stored in transmitter FIFO. The UART Controller will send out the data stored in transmitter FIFO top location through the UART_DAT.\nRead Operation:\nBy reading this register, the UART will return an 8-bit data received from receiving FIFO.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UART_CTRL</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UART_CTRL</displayName>
          <description>UART Control Register.</description>
          <addressOffset>0x4</addressOffset>
          <access>read-write</access>
          <resetValue>0x0700000C</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RXRST</name>
              <description>RX Field Software Reset\nWhen RXRST (UART_CTRL[0]) is set, all the byte in the receiver FIFO and RX internal state machine are cleared.\nNote: This bit will automatically clear at least 3 UART peripheral clock cycles.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reset the RX internal state machine and pointers</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TXRST</name>
              <description>TX Field Software Reset\nWhen TXRST (UART_CTRL[1]) is set, all the byte in the transmit FIFO and TX internal state machine are cleared.\nNote: This bit will automatically clear at least 3 UART peripheral clock cycles</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reset the TX internal state machine and pointers</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RXOFF</name>
              <description>Receiver Disable Bit\nNote1:In RS-485 NMM mode, user can set this bit to receive data before detecting address byte.\nNote2: In RS-485 AAD mode, this bit will be setting to "1" automatically.\nNote3: In RS-485 AUD mode and LIN "break + sync +PID" header mode, hardware will control data automatically, so don't fill any value to this bit.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Receiver Enabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Receiver Disabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TXOFF</name>
              <description>Transfer Disable Bit</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Transfer Enabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Transfer Disabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ATORTSEN</name>
              <description>nRTS Auto-flow Control Enable Bit\nNote: When nRTS auto-flow is enabled, if the number of bytes in the RX FIFO equals the RTSTRGLV (UART_LINE[13:12]), the UART will de-assert nRTS signal.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>nRTS auto-flow control Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>nRTS auto-flow control Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ATOCTSEN</name>
              <description>nCTS Auto-flow Control Enable Bit\nNote:When nCTS auto-flow is enabled, the UART will send data to external device if nCTS input assert (UART will not send data to device until nCTS is asserted).</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>nCTS auto-flow control Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>nCTS auto-flow control Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RXDMAEN</name>
              <description>RX DMA Enable Bit\nThis bit can enable or disable RX DMA service.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RX DMA Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RX DMA Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TXDMAEN</name>
              <description>TX DMA Enable Bit\nThis bit can enable or disable TX DMA service.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>TX DMA Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>TX DMA Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>FTOEN</name>
              <description>Frame Time Out Enable Bit\nThis bit is used to enable the timer counter even the FIFO is still empty.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Frame time out Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Frame time out Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ABRDEN</name>
              <description>Auto-baud Rate Detect EnableBit\nNote: When the auto-baud rate detect operation finishes, hardware will clear this bit and the associated interrupt (ABRIF) will be generated (If ABRIEN (UART_INTEN [7]) be enabled).</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Auto-baud rate detect function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Auto-baud rate detect function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ABRDBITS</name>
              <description>Auto-baud Rate Detect Bit Length\nNote: The calculation of bit number includes the START bit.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>1-bit time from Start bit to the 1st rising edge. The input pattern shall be 0x01</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>2-bit time from Start bit to the 1st rising edge. The input pattern shall be 0x02</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>4-bit time from Start bit to the 1st rising edge. The input pattern shall be 0x08</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>8-bit time from Start bit to the 1st rising edge. The input pattern shall be 0x80</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UART_LINE</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UART_LINE</displayName>
          <description>UART Transfer Line Control Register.</description>
          <addressOffset>0x8</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WLS</name>
              <description>Word Length Selection\nThis field sets UART word length.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>5 bits</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>6 bits</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>7 bits</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>8 bits</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>NSB</name>
              <description>Number of "STOP Bit"</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>One "STOP bit" is generated in the transmitted data</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>When select 5-bit word length, 1.5 "STOP bit" is generated in the transmitted data. When select 6-, 7- and 8-bit word length, 2 "STOP bit" is generated in the transmitted data</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PBE</name>
              <description>Parity Bit EnableBit\nNote: Parity bit is generated on each outgoing character and is checked on each incoming data.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No parity bit generated Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Parity bit generated Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>EPE</name>
              <description>Even Parity EnableBit\nNote:This bit has effect only when PBE (UART_LINE[3]) is set.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Odd number of logic 1's is transmitted and checked in each word</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Even number of logic 1's is transmitted and checked in each word</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SPE</name>
              <description>Stick Parity Enable Bit\nNote: If PBE (UART_LINE[3]) and EPE (UART_LINE[4]) are logic 1, the parity bit is transmitted and checked as logic 0. If PBE (UART_LINE[3]) is 1 and EPE (UART_LINE[4]) is 0 then the parity bit is transmitted and checked as 1.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Stick parity Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Stick parity Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BCB</name>
              <description>Break Control Bit\nNote: When this bit is set to logic 1, the serial data output (TX) is forced to the Spacing State (logic 0). This bit acts only on TX line and has no effect on the transmitter logic.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Break Control Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Break Control Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RFITL</name>
              <description>RX FIFO Interrupt Trigger Level\nWhen the number of bytes in the receive FIFO equals the RFITL, the RDAIF will be set (if RDAIEN (UART_INTEN [0]) enabled, and an interrupt will be generated).\nNote: When operating in IrDA mode or RS-485 mode, the RFITL must be set to "0".</description>
              <bitOffset>8</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RX FIFO Interrupt Trigger Level is 1 byte</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RX FIFO Interrupt Trigger Level is 4 bytes</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>10</name>
                    <description>RX FIFO Interrupt Trigger Level is 8 bytes</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>11</name>
                    <description>RX FIFO Interrupt Trigger Level is 14 bytes</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RTSTRGLV</name>
              <description>nRTS Trigger Level for Auto-flow Control Use\nNote: This field is used for auto nRTS flow control.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>nRTS Trigger Level is 1 byte</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>nRTS Trigger Level is 4 bytes</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>nRTS Trigger Level is 8 bytes</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>nRTS Trigger Level is 14 bytes</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UART_INTEN</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UART_INTEN</displayName>
          <description>UART Interrupt Enable Register.</description>
          <addressOffset>0xC</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RDAIEN</name>
              <description>Receive Data Available Interrupt Enable Bit</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Receive data available interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Receive data available interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>THREIEN</name>
              <description>Transmit Holding Register Empty Interrupt Enable Bit</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Transmit holding register empty interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Transmit holding register empty interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RLSIEN</name>
              <description>Receive Line Status Interrupt Enable Bit</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Receive Line Status interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Receive Line Status interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>MODEMIEN</name>
              <description>Modem Status Interrupt Enable Bit</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Modem status interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Modem statusinterrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RXTOIEN</name>
              <description>RX Time-out Interrupt Enable Bit</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RX time-out interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RX time-outinterrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BUFERRIEN</name>
              <description>Buffer Error Interrupt Enable Bit</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Buffer error interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Buffer error interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>WKUPIEN</name>
              <description>Wake-up Interrupt EnableBit\nNote: Hardware will clear one of the wake-up status bits in UART_WKUPSTS when the wake-up operation finishes and "system clock" work stable.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Wake-up system function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Wake-up system function Enabled, when the system is in Power-down mode, one of the wake-up event will wake-up system from Power-down mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ABRIEN</name>
              <description>Auto-baud Rate Interrupt Enable Bit</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Auto-baud rate interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Auto-baud rate interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>LINIEN</name>
              <description>LIN Bus Interrupt Enable Bit\nNote:This bit is used for LIN function mode.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>LIN bus interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>LIN bus interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TXENDIEN</name>
              <description>Transmitter Empty FInterrupt Enable Bit\nNote: If the bit is enabled, there is interrupt event when the TXENDF (UART_FIFOSTS[11]) is actived.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Transmit Empty interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Transmit Empty interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UART_INTSTS</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UART_INTSTS</displayName>
          <description>UART Interrupt Status Register.</description>
          <addressOffset>0x10</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000002</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RDAIF</name>
              <description>Receive Data Available Interrupt Flag (Read Only)\nWhen the number of bytes in the RX FIFO equals the RFITL then the RDAIF(UART_INTSTS[0]) will be set. If RDAIEN (UART_INTEN [0]) is enabled, the RDA interrupt will be generated.\nNote: This bit is read only and it will be cleared when the number of unread bytes of RX FIFO drops below the threshold level (RFITL(UART_LINE[9:8])</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No RDA interrupt flag is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RDA interrupt flag is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>THREIF</name>
              <description>Transmit Holding Register Empty Interrupt Flag (Read Only)\nThis bit is set when the last data of TX FIFO is transferred to Transmitter Shift Register. If THREIEN (UART_INTEN[1]) is enabled, the THRE interrupt will be generated.\nNote: This bit is read only and it will be cleared when writing data into UART_DAT (TX FIFO not empty)</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No THRE interrupt flag is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>THRE interrupt flag is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>RLSIF</name>
              <description>Receive Line Interrupt Flag (Read Only)\nThis bit is set when the RX receive data have parity error, frame error or break error (at least one of 3 bits, BIF(UART_FIFOSTS[6]), FEF(UART_FIFOSTS[5]) and PEF(UART_FIFOSTS[4]), is set). If RLSIEN (UART_INTEN [2]) is enabled, the RLS interrupt will be generated.\nNote2: This bit is read only and reset to 0 when all bits of BIF (UART_FIFOSTS[6]), FEF(UART_FIFOSTS[5]) and PEF(UART_FIFOSTS[4]) are cleared.\nNote3: In RS-485 function mode, this bit is read only and reset to 0 when all bits of BIF (UART_FIFOSTS[6]) , FEF(UART_FIFOSTS[5]) and PEF(UART_FIFOSTS[4]) and ADDRDETF (UART_TRSR[0]) are cleared.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No RLS interrupt flag is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RLS interrupt flag is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>MODEMIF</name>
              <description>MODEM Interrupt Flag (Read Only) Channel \nNote: This bit is read only and reset to 0 when bit CTSDETF is cleared by a write 1 on CTSDETF(UART_MODEM[18]).</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No Modem interrupt flag is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Modem interrupt flag is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>RXTOIF</name>
              <description>Rime-out Interrupt Flag (Read Only)\nThis bit is set when the RX FIFO is not empty and no activities occurred in the RX FIFO and the time-out counter equal to TOIC. If RXTOIEN (UART_INTEN [4]) is enabled, the Tout interrupt will be generated.\nNote: This bit is read only and user can read UART_DAT (RX is in active) to clear it</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No Time-out interrupt flag is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Time-out interrupt flag is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>BUFERRIF</name>
              <description>Buffer Error Interrupt Flag (Read Only)\nThis bit is set when the TX FIFO or RX FIFO overflows (TXOVIF (UART_FIFOSTS[8]) or RXOVIF (UART_FIFOSTS[0]) is set). When BUFERRIF (UART_INTSTS[5])is set, the transfer is not correct. If BFERRIEN (UART_INTEN [5]) is enabled, the buffer error interrupt will be generated.\nNote:This bit is read only. This bit is cleared if both of RXOVIF(UART_FIFOSTS[0]) and TXOVIF(UART_FIFOSTS[8]) are cleared to 0 by writing 1 to RXOVIF(UART_FIFOSTS[0]) and TXOVIF(UART_FIFOSTS[8]).</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No buffer error interrupt flag is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Buffer error interrupt flag is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>WKUPIF</name>
              <description>Wake-up Interrupt Flag (Read Only)\nThis bit is set if chip wake-up from power-down state by one of UART controller wake-up event.\nNote1: If WKDATEN (UART_INTEN[6]) is enabled, the wake-up interrupt is generated.\nNote2: This bit is read only, but can be cleared by writing '1' to one of UART_WKUPSTS[4:0] (THRTOWKSTS or THRWKSTS or CTSWKSTS or DATWKSTS or ADRWKSTS).</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Chip stays in power-down state</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Chip wake-up from power-down state by one of UART controller wake-up event</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>ABRIF</name>
              <description>Auto-baud Rate Interrupt Status Flag (Read Only)\nThis bit is set when auto-baud rate detection function finished or the auto-baud rate counter was overflow and if ABRIEN (UART_INTEN[7]) is set then the auto-baud rate interrupt will be generated.\nNote1: This bit is read only, but can be cleared by writing "1" to ABRDTOIF (UART_TRSR[2]) or ABRDIF (UART_TRSR[1]).\nNote2: This bit is cleared when both the ABRDTOIF and ABRDIF are cleared.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No Auto-Baud Rate interrupt is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Auto-Baud Rate interrupt is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>LINIF</name>
              <description>LIN Interrupt Status Flag (Read Only)\nThis bit is set when the LIN TX header transmitted, RX header received or the SIN does not equal SOUT and if LINIEN(UART_INTEN[8]) is set then the LIN interrupt will be generated.\nNote1: This bit is read only, but can be cleared by it by writing "1" to BITEF (UART_TRSR[5]), LINTXIF (UART_TRSR[3]) or LINRXIF (UART_TRSR[4]).\nNote2: This bit is cleared when both the BITEF, LINTXIF and LINRXIF are cleared.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No LIN interrupt is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>LIN interrupt is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UART_TRSR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UART_TRSR</displayName>
          <description>UART Transfer Status Register.</description>
          <addressOffset>0x14</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ADDRDETF</name>
              <description>RS-485 Address Byte Detection Status Flag (Read Only)\nNote1: This field is used for RS-485 function mode and ADDRDEN (UART_ATLCTL[19]) is set to 1 to enable Address detection mode .\nNote2: This bit is read only, but can be cleared by writing '1' to it.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Receiver detects a data that is not an address bit (bit 9 ='0')</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Receiver detects a data that is an address bit (bit 9 ='1')</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>ABRDIF</name>
              <description>Auto-baud Rate Interrupt (Read Only)\nThis bit is set to logic "1" when auto-baud rate detect function finished.\nNote: This bit is read only, but can be cleared by writing "1" to it.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No Auto- Baud Rate interrupt is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Auto-Baud Rate interrupt is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>ABRDTOIF</name>
              <description>Auto-baud Rate Time-out Interrupt(Read Only)\nNote1:This bit is set to logic "1" in Auto-baud Rate Detect mode and the baud rate counter is overflow.\nNote2: This bit is read only, but can be cleared by writing "1" to it.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Auto-baud rate counter is underflow</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Auto-baud rate counter is overflow</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>LINTXIF</name>
              <description>LIN TX Interrupt Flag (Read Only)\nThis bit is set to logic "1" when LIN transmitted header field. The header may be "break field" or "break field + sync field" or "break field + sync field + PID field", it can be choose by setting LINHSEL (UART_ATLCTL[5:4]) register.\nNote: This bit is read only, but can be cleared by writing "1" to it.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No LIN Transmit interrupt is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>LIN Transmit interrupt is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>LINRXIF</name>
              <description>LIN RX Interrupt Flag (Read Only)\nThis bit is set to logic "1" when received LIN header field. The header may be "break field" or "break field + sync field" or "break field + sync field + PID field", and it can be choose by setting LINHSEL (UART_ATLCTL[5:4]) register.\nNote: This bit is read only, but can be cleared by writing "1" to it.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No LIN Rx interrupt is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>LIN Rx interrupt is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>BITEF</name>
              <description>Bit Error Detect Status Flag (Read Only)\nAt TX transfer state, hardware will monitoring the bus state, if the input pin (SIN) state is not equal to the output pin (SOUT) state, BITEF will be set.\nWhen occur bit error, hardware will generate an interrupt to CPU (LININT).</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No Bit error interrupt is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Bit error interrupt is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>RXBUSY</name>
              <description>Receive Busy Status(Read Only)\nNote: The user can use this to check the busy status in receiver mode. If the user wants to enter power down, this bit shall be confirm in Idle state and there is 2 UART clock latency for receiver pin.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The receiver machine stays in idle state</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The receiver machine stays in no Idle state</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>SLVSYNCF</name>
              <description>LIN RX SYNC Error Flag (Read Only)\nThis bit is set to logic "1" when LIN received incorrect SYNC field.\nUser can choose the header by setting LINHSEL (UART_ATLCTL[5:4]) register.\nNote: This bit is read only, but can be cleared by writing "1" to LINRXIF.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No LIN Rx sync error is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>LIN Rx sync error is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UART_FIFOSTS</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UART_FIFOSTS</displayName>
          <description>UART FIFO Status Register.</description>
          <addressOffset>0x18</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000A02</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RXOVIF</name>
              <description>RX Overflow Error Status Flag (Read Only)\nThis bit is set when RX FIFO overflow. If the number of bytes of received data is greater than RX_FIFO (UART_DAT) size, this bit will be set.\nNote:This bit is read only, but can be cleared by writing "1" to it.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RX FIFO is not overflow</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RX FIFO is overflow</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>RXEMPTY</name>
              <description>Receiver FIFO Empty (Read Only)\nThis bit initiate RX FIFO empty or not.\nNote: When the last byte of RX FIFO has been read by CPU, hardware sets this bit high. It will be cleared when UART receives any new data.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RX FIFO is not empty</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RX FIFO is empty</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>RXFULL</name>
              <description>Receiver FIFO Full (Read Only)\nThis bit initiates RX FIFO full or not.\nNote: This bit is set when the number of usage in RX FIFO Buffer is equal to 16, otherwise is cleared by hardware.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RX FIFO is not full</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RX FIFO is full</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>PEF</name>
              <description>Parity Error State Status Flag (Read Only)\nThis bit is set to logic 1 whenever the received character does not have a valid "parity bit".\nNote: This bit is read only, but can be cleared by writing '1' to it.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No parity error is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Parity error is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>FEF</name>
              <description>Framing Error Flag (Read Only)\nThis bit is set to logic 1 whenever the received character does not have a valid "stop bit" (that is, the stop bit following the last data bit or parity bit is detected as logic 0).\nNote: This bit is read only, but can be cleared by writing '1' to it.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No framing error is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Framing error is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>BIF</name>
              <description>Break Interrupt Flag( Read Only)\nThis bit is set to logic 1 whenever the received data input (RX) is held in the "spacing state" (logic 0) for longer than a full word transmission time (that is, the total time of "start bit" + data bits + parity + stop bits).\nNote: This bit is read only, but can be cleared by writing '1' to it.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No Break interrupt is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Break interrupt is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>TXOVIF</name>
              <description>TX Overflow Error Interrupt Status Flag (Read Only)\nIf TX FIFO (UART_DAT) is full, an additional write to UART_DAT will cause this bit to logic 1.\nNote:This bit is read only, but can be cleared by writing "1" to it.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>TX FIFO did not overflow</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>TX FIFO overflowed</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>TXEMPTY</name>
              <description>Transmitter FIFO Empty (Read Only)\nThis bit indicates TX FIFO empty or not.\nNote: When the last byte of TX FIFO has been transferred to Transmitter Shift Register, hardware sets this bit high. It will be cleared when writing data into DAT (TX FIFO not empty).</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>TX FIFO is not empty</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>TX FIFO is empty</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>TXFULL</name>
              <description>Transmitter FIFO Full  (Read Only)\nThis bit indicates TX FIFO full or not.\nNote:This bit is set when the number of usage in TX FIFO Buffer is equal to 16, otherwise is cleared by hardware.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>TX FIFO is not full</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>TX FIFO is full</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>TXENDF</name>
              <description>Transmitter Empty Flag (Read Only)\nThis bit is set by hardware when TX FIFO (UART_DAT) is empty and the STOP bit of the last byte has been transmitted.\nNote:This bit is cleared automatically when TX FIFO is not empty or the last byte transmission has not completed.</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>TX FIFO is not empty or the STOP bit of the last byte has been not transmitted</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>TX FIFO is empty and the STOP bit of the last byte has been transmitted</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>RXPTR</name>
              <description>RX FIFO Pointer (Read Only)\nThis field indicates the RX FIFO Buffer Pointer. When UART receives one byte from external device, RXPTR increases one. When one byte of RX FIFO is read by CPU, RXPTR decreases one.\nThe Maximum value shown in RXPTR is 15. When the using level of RX FIFO Buffer equal to 16, the RXFULL bit is set to 1 and RXPTR will show 0. As one byte of RX FIFO is read by CPU, the RXFULL bit is cleared to 0 and RXPTR will show 15.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TXPTR</name>
              <description>TX-fIFO Pointer (Read Only)\nThis field indicates the TX FIFO Buffer Pointer. When CPU writes one byte into UART_DAT, TXPTR increases one. When one byte of TX FIFO is transferred to Transmitter Shift Register, TXPTR decreases one.\nThe Maximum value shown in TXPTR is 15. When the using level of TX FIFO Buffer equal to 16, the TXFULL bit is set to 1 and TXPTR will show 0. As one byte of TX FIFO is transferred to Transmitter Shift Register, the TXFULL bit is cleared to 0 and TXPTR will show 15.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UART_MODE</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UART_MODE</displayName>
          <description>UART Modem Control Status Register.</description>
          <addressOffset>0x1C</addressOffset>
          <access>read-write</access>
          <resetValue>0x00020002</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RTSACTLV</name>
              <description>nRTS Pin Active Level\nThis bit defines the active level state of nRTS pin output.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>nRTS pin output is high level active</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>nRTS pin output is low level active. (Default)</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RTSSTS</name>
              <description>nRTS Pin State (Read Only)\nThis bit mirror from nRTS pin output of voltage logic status.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>nRTS pin output is low level voltage logic state</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>nRTS pin output is high level voltage logic state</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>CTSACTLV</name>
              <description>nCTS Trigger Level\nThis bit defines the active level state of nCTS pin input.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>nCTS pin input is high level active</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>nCTS pin input is low level active. (Default)</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CTSSTS</name>
              <description>nCTS Pin Status (Read Only)\nThis bit mirror from nCTS pin input of voltage logic status.\nNote: This bit echoes when UART Controller peripheral clock is enabled, and nCTS multi-function port is selected.</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>nCTS pin input is low level voltage logic state</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>nCTS pin input is high level voltage logic state</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>CTSDETF</name>
              <description>Detect nCTS State Change Flag (Read Only)\nThis bit is set whenever nCTS input has change state, and it will generate Modem interrupt to CPU when MODEMIEN (UART_INTEN[3]).\nNote: This bit is read only, but it can be cleared by writing "1" to it.</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>nCTS input has not change state</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>nCTS input has change state</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UART_TOUT</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UART_TOUT</displayName>
          <description>UART Time-Out Control Register.</description>
          <addressOffset>0x20</addressOffset>
          <access>read-write</access>
          <resetValue>0x000001FF</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TOIC</name>
              <description>Time-out Comparator\nNote1: Fill all "0" to this field indicates to disable this function.\nNote2: The real time-out value is TOIC + 1.\nNote3: The counting clock is baud rate clock.\nNote4: The UART data format is start bit + 8 data bits + parity bit + stop bit, although software can configure this field by any value but it is recommend to fill this field great than 0xA.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>9</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DLY</name>
              <description>TX Delay Time Value\nThis field is used to programming the transfer delay time between the last stop bit and next start bit. The unit is bit time.\nNote1: Fill all "0" to this field indicates to disable this function.\nNote2: The real delay value is DLY.\nNote3:The counting clock is baud rate clock.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UART_BAUD</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UART_BAUD</displayName>
          <description>UART Baud Rate Divisor Register.</description>
          <addressOffset>0x24</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BRD</name>
              <description>Baud Rate Divider \nThe field indicates the baud rate divider. This filed is used in baud rate calculation. The detail description is shown inUART Controller Baud Rate Generation.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DIV16EN</name>
              <description>Divider 16 Enable Control\nNote: In IrDA mode, this bit must clear to "0".</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The equation of baud rate is UART_CLK / [(BRD+1)]</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The equation of baud rate is UART_CLK / [16 * (BRD+1)]</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UART_IRDA</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UART_IRDA</displayName>
          <description>UART IrDA Control Register.</description>
          <addressOffset>0x30</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000040</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TXEN</name>
              <description>IrDA Receiver/Transmitter Selection Enable Bit</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>IrDA Transmitter Disabled and Receiver Enabled. (Default)</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>IrDA Transmitter Enabled and Receiver Disabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TXINV</name>
              <description>IrDA Inverse Transmitting Output Signal </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>None inverse transmitting signal. (Default)</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Inverse transmitting output signal</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RXINV</name>
              <description>IrDA Inverse Receive Input Signal </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>None inverse receiving input signal</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Inverse receiving input signal. (Default)</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UART_ATLCTL</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UART_ATLCTL</displayName>
          <description>UART Alternate Control State Register.</description>
          <addressOffset>0x34</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BRKFL</name>
              <description>LIN TX Break Field Count \nThe field contains 3-bit LIN TX break field count.\nNote: The break field length is BRKFL + 8.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>LINHSEL</name>
              <description>LIN Header Selection</description>
              <bitOffset>4</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The LIN header includes "break field"</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The LIN header includes "break field + sync field"</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>The LIN header includes "break field + sync field + PID field"</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Reserved</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>LINRXEN</name>
              <description>LIN RX Enable Control\nWhen LIN RX mode enabled and received a break field or sync field or PID field (Select by LIN_Header_SEL), the controller will generator a interrupt to CPU (LININT)</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>LIN RX mode Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>LIN RX mode Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>LINTXEN</name>
              <description>LIN TX Header Trigger EnableBit\nThe LIN TX header can be "break field" or "break and sync field" or "break, sync and frame ID field", it is depend on setting LINHSEL (UART_ATLCTL[5:4]).\nNote1: This bit will be cleared automatically and generate a interrupt to CPU (LININT).\nNote2:When transmitter header field (it may be "break" or "break + sync" or "break + sync + frame ID" selected by LINHSEL (UART_ATLCTL[5:4]) field) transfer operation finished, this bit will be cleared automatically.\nNote3: If user wants to receive transmit data, it recommended to enable LINRXEN bit.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Send LIN TX header Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Send LIN TX header Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BITERREN</name>
              <description>Bit Error Detect EnableBit</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Bit error detection Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Bit error detection Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RS485NMM</name>
              <description>RS-485 Normal Multi-drop Operation Mode (NMM)\nNote: It cannot be active with RS-485_AAD operation mode.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RS-485 Normal Multi-drop Operation mode (NMM) Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RS-485 Normal Multi-drop Operation mode (NMM) Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RS485AAD</name>
              <description>RS-485 Auto Address Detection Operation Mode (AAD)\nNote: It cannot be active with RS485NMM operation mode.</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RS-485 Auto Address Detection Operation mode (AAD) Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RS-485 Auto Address Detection Operation mode (AAD) Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RS485AUD</name>
              <description>RS-485 Auto Direction Function (AUD)\nNote: It can be active with RS485AAD or RS485NMM operation mode.</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RS-485 Auto Direction Operation function (AUD) Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RS-485 Auto Direction Operation function (AUD) Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ADDRDEN</name>
              <description>RS-485 Address Detection Enable Bit\nThis bit is used to enable RS-485 Address Detection mode. \nNote: This bit is used for RS-485 any operation mode.</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Address detection mode Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Address detection mode Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ADRMPID</name>
              <description>Address / PID Match Value Register\nWhen in the RS-485 Function Mode, this field contains the RS-485 address match values.\nWhen in the LIN Function mode, this field contains the LIN protected identifier field, software fills ID0~ID5 (PID [5:0]), hardware will calculate P0 and P1.\n\nNote: This field is used for RS-485 auto address detection mode or used for LIN protected identifier field (PID).</description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UART_FUNCSEL</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UART_FUNCSEL</displayName>
          <description>UART Function Select Register.</description>
          <addressOffset>0x38</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>FUNCSEL</name>
              <description>Function Selection</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>UART function mode</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>LIN function mode</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>IrDA function mode</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>RS-485 function mode</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UART_BRCOMPAT</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UART_BRCOMPAT</displayName>
          <description>UART Baud Rate Compensation Register.</description>
          <addressOffset>0x3C</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BRCOMPAT</name>
              <description>Baud Rate Compensation Patten\nThese 9bits are used to define the relative bit is compensated or not. BRCOMPAT[7:0] is used to define the compensation of D[7:0] and BRCOMPAT{[8] is used to define the parity bit.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>9</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>BRCOMPDEC</name>
              <description>Baud Rate Compensation Decrease</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Positive (increase one module clock) compensation for each compensated bit</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Negative (decrease one module clock) compensation for each compensated bit</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UART_WKUPEN</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UART_WKUPEN</displayName>
          <description>UART Wake-up Enable Register.</description>
          <addressOffset>0x40</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WKCTSEN</name>
              <description>CTSn Wake-up Enable Bit\nWhen the system is in power-down mode, an external nCTS change will wake-up system from power-down mode.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>nCTS wake-up function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>nCTS wake-up function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>WKDATEN</name>
              <description>Incoming Data Wake-up Enable Bit\nNote: Hardware will clear this bit when the incoming data wake-up operation finishes and "system clock" work stable.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Incoming data wake-up function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Incoming data wake-up function Enabled when the system is in power-down mode, incoming data will wake-up system from power-down mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>WKTHREN</name>
              <description>FIFO Threshold Reach Wake-up Enable Bit\nNote: It is suggest the function is enabled in UART mode and the UART clock is selected in 32K.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Received FIFO threshold reach wake-up function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Received FIFO threshold reach wake-up function Enabled when the system is in power-down mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>WKTHRTOEN</name>
              <description>FIFO Threshold Reach Time Out Wake-up Enable Bit\nNote: It is suggest the function is enabled when the WKTHREN (UART_WKUPEN[2]) is set to 1.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Received FIFO threshold no reach and time out wake-up function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Received FIFO threshold no reach and time out wake-up function Enabled when the system is in power-down mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>WKADRMEN</name>
              <description>RS-485 Address Match Wake-up Enable Bit</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RS-485 ADD mode address match wake-up function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RS-485 AAD mode address match wake-up function Enabled when the system is in power-down mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UART_WKUPSTS</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UART_WKUPSTS</displayName>
          <description>UART Wake-up Status Register.</description>
          <addressOffset>0x44</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CTSWKSTS</name>
              <description>nCTS Wake-up Flag (Read Only)\nNote1: If WKCTSEN (UART_ WKUPEN [0])is enabled, the wake-up function is generated.\nNote2: This bit is read only, but can be cleared by writing '1' to it.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Chip stays in power-down state</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Chip wake-up from power-down state by nCTS wake-up</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>DATWKSTS</name>
              <description>Data Wake-up Flag (Read Only)\nThis bit is set if chip wake-up from power-down state by data wake-up.\nNote1: If WKDATEN (UART_ WKUPEN [1]) is enabled, the wake-up function is generated.\nNote2: This bit is read only, but can be cleared by writing '1' to it</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Chip stays in power-down state</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Chip wake-up from power-down state by data wake-up</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>THRWKSTS</name>
              <description>Threshold Wake-up Flag (Read Only)\nNote1: If WKTHREN (UART_ WKUPEN [2])is enabled, the wake-up function is generated.\nNote2: This bit is read only, but can be cleared by writing '1' to it.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Chip stays in power-down state</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Chip wake-up from power-down state by FIFO threshold wake-up</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>THRTOWKSTS</name>
              <description>Threshold Wake-up Time Out Flag (Read Only)\nNote1: If WKTHRTOEN (UART_ WKUPEN [3])is enabled, the wake-up function is generated.\nNote2: This bit is read only, but can be cleared by writing '1' to it.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Chip stays in power-down state</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Chip wake-up from power-down state by FIFO threshold time out wake-up</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>ADRWKSTS</name>
              <description>RS-485 Address Byte Detection Wake-up Flag (Read Only)\nNote1: If WKADRMEN (UART_WKUPEN[4])is enabled, the wake-up function is generated.\nNote2: This field is used for RS-485 function mode and ADDRDEN (UART_ATLCTL[19]) is set to 1 to enable Address detection mode .\nNote2: This bit is read only, but can be cleared by writing '1' to it.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Chip stays in power-down state</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Chip wake-up from power-down state by Receiver detects a data that is an address bit (bit 9 ='1')</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
          </fields>
       </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>SC0</name>
      <description>SC Register Map</description>
      <groupName>SC</groupName>
      <baseAddress>0x40190000</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x0</offset>
        <size>0x38</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x40</offset>
        <size>0x4</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>SCn_DAT</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SCn_DAT</displayName>
          <description>SCn Receive/Transmit Holding Buffer Register.</description>
          <addressOffset>0x0</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>DAT</name>
              <description>Receive/Transmit Holding Buffer \nWrite Operation:\nBy writing data to DAT, the SC will send out an 8-bit data.\nNote: If SCEN(SC_CTL[0]) is not enabled, DAT cannot be programmed.\nRead Operation:\nBy reading DAT, the SC will return an 8-bit received data.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SCn_CTL</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SCn_CTL</displayName>
          <description>SCn Control Register.</description>
          <addressOffset>0x4</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SCEN</name>
              <description>SC Engine Enable Bit\nSet this bit to 1 to enable SC operation. If this bit is cleared, SC will force all transition to IDLE state\nNote1: SCEN must be set to 1 before filling in other registers, or smart card will not work properly.\nNote2: If SCEN is activated, all function can work correctly. If SCEN is not activated, when CPU write data to SMC, only Flip-flop which works in PCLK domain will turn on for two PCLK cycle, Flip-flop working in SCLK domain will not be turn on.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXOFF</name>
              <description>RX Transition Disable Bit\nNote1: If AUTOCEN (SC_CTL[3])is enabled, these fields must be ignored.\nNote2: After hardware activation and hardware warm reset are done, RXOFF is set to 0 automatically.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The receiver Enabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The receiver Disabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TXOFF</name>
              <description>TX Transition Disable Bit</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The transceiver Enabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The transceiver Disabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>AUTOCEN</name>
              <description>Auto Convention Enable Bit</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Auto-convention Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Auto-convention Enabled. When hardware receives TS in answer to reset state and the TS is direct convention, CONSEL(SC_CTL[5:4]) will be set to 00 automatically, otherwise if the TS is inverse convention, and CONSEL (SC_CTL[5:4]) will be set to 11</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CONSEL</name>
              <description>Convention Selection\nNote: If AUTOCEN(SC_CTL[3]) is enabled, this field is ignored.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Direct convention</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reserved</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Reserved</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Inverse convention</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RXTRGLV</name>
              <description>Rx Buffer Trigger Level \nWhen the number of bytes in the receiving buffer equals the RXTRGLV, the RDAIF will be set (if SC_INTEN [RDAIEN] is enabled, an interrupt will be generated).</description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>INTR_RDA Trigger Level with 01 Bytes</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>INTR_RDA Trigger Level with 02 Bytes</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>INTR_RDA Trigger Level with 03 Bytes</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Reserved</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BGT</name>
              <description>Block Guard Time (BGT)\nNote: The real block guard time is BGT + 1.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TMRSEL</name>
              <description>Timer Selection \nOther configurations are reserved</description>
              <bitOffset>13</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>All internal timer function Disabled</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Internal 24 bit timer and two 8 bit timers Enabled. Software can configure them by setting SC_TMRCTL0 [23:0], SC_TMRCTL1 [7:0] and SC_TMRCTL2 [7:0]</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>NSB</name>
              <description>Stop Bit Length\nThis field indicates the length of stop bit.\nNote: The default stop bit length is 2. SMC and UART adopt NSB to program the stop bit length.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The stop bit length is 2 ETU</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The stop bit length is 1 ETU</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RXRTY</name>
              <description>RX Error Retry Count Number\nThis field indicates the maximum number of receiver retries that are allowed when parity error has occurred\nNote1: The real retry number is RX_ERETRY + 1, so 8 is the maximum retry number.\nNote2: This field cannot be changed when RX_ERETRY_EN enabled. The change flow is to disable RX_ETRTRY_EN first and then fill in new retry value.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXRTYEN</name>
              <description>RX Error Retry Enable Bit\nThis bit enables receiver retry function when parity error has occurred.\nNote: Software must fill in the RXRTY value before enabling this bit.</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RX error retry function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RX error retry function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TXRTY</name>
              <description>TX Error Retry Count Number\nThis field indicates the maximum number of transmitter retries that are allowed when parity error has occurred.\nNote1: The real retry number is TXRTY + 1, so 8 is the maximum retry number.\nNote2: This field cannot be changed when TXRTYEN enabled. The change flow is to disable TXRTYEN first and then fill in new retry value.</description>
              <bitOffset>20</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TXRTYEN</name>
              <description>TX Error Retry Enable Bit\nThis bit enables transmitter retry function when parity error has occurred.</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>TX error retry function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>TX error retry function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CDDBSEL</name>
              <description>Card Detect De-bounce Selection\nThis field indicates the card detect de-bounce selection.\nOther configurations are reserved.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>De-bounce sample card insert once per 384 (128 * 3) engine clocks and de-bounce sample card removal once per 128 engine clocks</description>
                    <value>#00</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SYNC</name>
              <description>SYNC Flag Indicator(Read Only)\nDue to synchronization, software should check this bit before writing a new value to RXRTY and TXRTY.SYNC delay is </description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>synchronizing is completion, user can write new data to RXRTY and TXRTY</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Last value is synchronizing</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SCn_ALTCTL</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SCn_ALTCTL</displayName>
          <description>SCn Alternate Control Register.</description>
          <addressOffset>0x8</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TXRST</name>
              <description>TX Software Reset\nWhen TXRST is set, all the bytes in the transmit buffer and TX internal state machine will be cleared.\nNote: This bit will be auto cleared after reset is complete.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reset the TX internal state machine and pointers</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RXRST</name>
              <description>Rx Software Reset\nWhen RXRST is set, all the bytes in the receiver buffer and Rx internal state machine will be cleared.\nNote: This bit will be auto cleared after reset is complete.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reset the Rx internal state machine and pointers</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DACTEN</name>
              <description>Deactivation Sequence Generator Enable Bit\nThis bit enables SC controller to initiate the card by deactivation sequence\nNote1: When the deactivation sequence completed, this bit will be cleared automatically and the INITIF(SC_INTSTS[8]) will be set to 1.\nNote2: This field will be cleared by TXRST (SC_ALTCTL[0]) and RXRST(SC_ALTCTL[1]).Thus,do not fill in this bit, TXRST, and RXRST at the same time.\nNote3: If SCEN (SC_CTL[0]) is not enabled, this filed cannot be programmed.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Deactivation sequence generator Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ACTEN</name>
              <description>Activation Sequence Generator Enable Bit\nThis bit enables SC controller to initiate the card by activation sequence\nNote1: When the activation sequence completed, this bit will be cleared automatically and the INITIF(SC_INTSTS[8]) will be set to 1, RXOFF(SC_CTL[2]) will be clear to 0.\nNote2: This field will be cleared by TXRST(SC_ALTCTL[0]) and RXRST(SC_ALTCTL[1]).Thus,do not fill in this bit, TXRST(SC_ALTCTL[0]), and RXRST(SC_ALTCTL[1]) at the same time.\nNote3: If SCEN(SC_CTL[0]) is not enabled, this filed cannot be programmed.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Activation sequence generator Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>WARSTEN</name>
              <description>Warm Reset Sequence Generator Enable Bit\nThis bit enables SC controller to initiate the card by warm reset sequence\nNote1: When the warm reset sequence completed, this bit will be cleared automatically and the INITIF(SC_INTSTS[8]) will be set to 1, RXOFF(SC_CTL[2]) will be clear to 0.\nNote2: This field will be cleared by TXRST(SC_ALTCTL[0]) and RXRST(SC_ALTCTL[1]).Thus,do not fill in this bit, TXRST, and RXRST at the same time.\nNote3: If SCEN(SC_CTL[0]) is not enabled, this filed cannot be programmed.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Warm reset sequence generator Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CNTEN0</name>
              <description>Internal Timer0 Start Enable Bit\nThis bit enables Timer 0 to start counting. Software can fill 0 to stop it and set 1 to reload and count.\nNote3: If SCEN(SC_CTL[0]) is not enabled, this filed cannot be programmed.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Stops counting</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Start counting</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CNTEN1</name>
              <description>Internal Timer1 Start Enable Bit\nThis bit enables Timer 1 to start counting. Software can fill 0 to stop it and set 1 to reload and count.\nNote3: If SCEN(SC_CTL[0]) is not enabled, this filed cannot be programmed.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Stops counting</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Start counting</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CNTEN2</name>
              <description>Internal Timer2 Start Enable Bit\nThis bit enables Timer 2 to start counting. Software can fill 0 to stop it and set 1 to reload and count.\nNote3: If SCEN(SC_CTL[0]) is not enabled, this filed cannot be programmed.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Stops counting</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Start counting</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>INITSEL</name>
              <description>Initial Timing Selection\nThis fields indicates the timing of hardware initial state (activation or warm-reset or deactivation).\nUnit: SC clock\nActivation: Refer to SC Activation Sequence in Figure 6.154SC Activation Sequence.\nWarm-reset: Refer to Warm-Reset Sequence in Figure 6.155SC Warm Reset Sequence\nDeactivation: Refer to Deactivation Sequence in Figure 6.156SC Deactivation Sequence\nNote: When set Activation and Warm reset in mode 11, it may have deviation at most 128 cycles.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXBGTEN</name>
              <description>Receiver Block Guard Time Function Enable Bit</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Receiver block guard time function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Receiver block guard time function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ACTSTS0</name>
              <description>Internal Timer0 Active State (Read Only)\nThis bit indicates the timer counter status of timer0.\nNote: Timer0 is active does not always mean timer0 is counting the CNT(SC_TMRCTL0[23:0]).</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Timer0 is not active</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Timer0 is active</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>ACTSTS1</name>
              <description>Internal Timer1 Active State (Read Only)\nThis bit indicates the timer counter status of timer1.\nNote: Timer1 is active does not always mean timer1 is counting the CNT(SC_TMRCTL1[7:0]).</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Timer1 is not active</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Timer1 is active</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>ACTSTS2</name>
              <description>Internal Timer2 Active State (Read Only)\nThis bit indicates the timer counter status of timer2.\nNote: Timer2 is active does not always mean timer2 is counting the CNT(SC_TMRCTL2[7:0]).</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Timer2 is not active</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Timer2 is active</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>OUTSEL</name>
              <description>Smartcard Data Pin Output Mode Selection\nUse this bit to select smartcard data pin output mode.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Quasi mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Open-drain mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SCn_EGT</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SCn_EGT</displayName>
          <description>SCn Extra Guard Time Register.</description>
          <addressOffset>0xC</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>EGT</name>
              <description>Extra Guard Time\nThis field indicates the extra guard timer value.\nNote: The counter is ETU base .</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SCn_RXTOUT</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SCn_RXTOUT</displayName>
          <description>SCn Receive buffer Time-out Register.</description>
          <addressOffset>0x10</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RFTM</name>
              <description>SC Receiver FIFO Time-out \nNote1:The counter unit is ETU based and the interval of time-out is RFTM + 0.5.\nNote2: Filling in all 0 to this field indicates to disable this function.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>9</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SCn_ETUCTL</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SCn_ETUCTL</displayName>
          <description>SCn Element Time Unit Control Register.</description>
          <addressOffset>0x14</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000173</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ETURDIV</name>
              <description>ETU Rate Divider\nThe field indicates the clock rate divider.\nThe real ETU is ETURDIV + 1.\nNote: Software can configure this field, but this field must be greater than 0x004.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>12</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SCn_INTEN</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SCn_INTEN</displayName>
          <description>SCn Interrupt Enable Control Register.</description>
          <addressOffset>0x18</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RDAIEN</name>
              <description>Receive Data Reach Interrupt Enable Bit\nThis field is used to enable received data reaching trigger level RXTRGLV (SC_CTL[7:6]) interrupt.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Receive data reach trigger level interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Receive data reach trigger level interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TBEIEN</name>
              <description>Transmit Buffer Empty Interrupt Enable Bit\nThis field is used to enable transmit buffer empty interrupt.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Transmit buffer empty interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Transmit buffer empty interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TERRIEN</name>
              <description>Transfer Error Interrupt Enable Bit\nThis field is used to enable transfer error interrupt. The transfer error states is at SC_STATUS register which includes receiver break error BEF(SC_STATUS[6]), frame error FEF(SC_STATUS[5]), parity error PEF(SC_STATUS[4]), receiver buffer overflow error RXOV(SC_STATUS[0]), transmit buffer overflow error TXOV(SC_STATUS[8]), receiver retry over limit error RXOVERR(SC_STATUS[22]) and transmitter retry over limit error TXOVERR (SC_STATUS[30]).</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Transfer error interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Transfer error interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TMR0IEN</name>
              <description>Timer0 Interrupt Enable Bit\nThis field is used to enable TMR0 interrupt.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Timer0 interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Timer0 interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TMR1IEN</name>
              <description>Timer1 Interrupt Enable Bit\nThis field is used to enable the TMR1 interrupt.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Timer1 interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Timer1 interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TMR2IEN</name>
              <description>Timer2 Interrupt Enable Bit\nThis field is used to enable TMR2 interrupt.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Timer2 interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Timer2 interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BGTIEN</name>
              <description>Block Guard Time Interrupt Enable Bit\nThis field is used to enable block guard time interrupt.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Block guard time Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Block guard time Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CDIEN</name>
              <description>Card Detect Interrupt Enable Bit\nThis field is used to enable card detect interrupt. The card detect status is CINSERT(SC_STATUS[12]) </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Card detect interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Card detect interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>INITIEN</name>
              <description>Initial End Interrupt Enable Bit</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Initial end interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Initial end interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RXTOEN</name>
              <description>Receiver Buffer Time-out Interrupt Enable Bit\nThis field is used to enable receiver buffer time-out interrupt.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Receiver buffer time-out interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Receiver buffer time-out interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ACERRIEN</name>
              <description>Auto Convention Error Interrupt Enable Bit\nThis field is used to enable auto-convention error interrupt.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Auto-convention error interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Auto-convention error interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SCn_INTSTS</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SCn_INTSTS</displayName>
          <description>SCn Interrupt Status Register.</description>
          <addressOffset>0x1C</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000002</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RDAIF</name>
              <description>Receive Data Reach Interrupt Status Flag (Read Only)\nThis field is used for received data reaching trigger level RXTRGLV (SC_CTL[7:6]) interrupt status flag.\nNote: This field is the status flag of received data reaching RXTRGLV (SC_CTL[7:6]). If software reads data from SC_DAT and receiver buffer data byte number is less than RXTRGLV (SC_CTL[7:6]), this bit will be cleared automatically.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TBEIF</name>
              <description>Transmit Buffer Empty Interrupt Status Flag (Read Only)\nThis field is used for transmit buffer empty interrupt status flag.\nNote: This field is the status flag of transmit buffer empty state. If software wants to clear this bit, software must write data to DAT(SC_DAT[7:0]) buffer and then this bit will be cleared automatically.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TERRIF</name>
              <description>Transfer Error Interrupt Status Flag (Read Only)\nThis field is used for transfer error interrupt status flag. The transfer error states is at SC_STATUS register which includes receiver break error BEF(SC_STATUS[6]), frame error FEF(SC_STATUS[5], parity error PEF(SC_STATUS[4] and receiver buffer overflow error RXOV(SC_STATUS[0]), transmit buffer overflow error TXOV(SC_STATUS[8]), receiver retry over limit error RXOVERR(SC_STATUS[22] and transmitter retry over limit error TXOVERR(SC_STATUS[30]).\nNote: This field is the status flag of BEF(SC_STATUS[6]), FEF(SC_STATUS[5]), PEF(SC_STATUS[4]), RXOV(SC_STATUS[0]), TXOV(SC_STATUS[8]), RXOVERR(SC_STATUS[22]) or TXOVERR(SC_STATUS[30]). So, if software wants to clear this bit, software must write 1 to each field.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TMR0IF</name>
              <description>Timer0 Interrupt Status Flag (Read Only)\nThis field is used for TMR0 interrupt status flag.\nNote: This bit is read only, but it can be cleared by writing 1 to it.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TMR1IF</name>
              <description>Timer1 Interrupt Status Flag (Read Only)\nThis field is used for TMR1 interrupt status flag.\nNote: This bit is read only, but it can be cleared by writing 1 to it.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TMR2IF</name>
              <description>Timer2 Interrupt Status Flag (Read Only)\nThis field is used for TMR2 interrupt status flag.\nNote: This bit is read only, but it can be cleared by writing 1 to it.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>BGTIF</name>
              <description>Block Guard Time Interrupt Status Flag (Read Only)\nThis field is used for block guard time interrupt status flag.\nNote1: This bit is valid when RXBGTEN (SC_ALTCTL[12]) is enabled.\nNote2: This bit is read only, but it can be cleared by writing "1" to it.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>CDIF</name>
              <description>Card Detect Interrupt Status Flag (Read Only)\nThis field is used for card detect interrupt status flag. The card detect status is CINSERT (SC_STATUS[12]) and CREMOVE(SC_STATUS[11]).\nNote: This field is the status flag of CINSERT(SC_STATUS[12]) or CREMOVE(SC_STATUS[11])]. So if software wants to clear these bits, software must write 1 to these field.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>INITIF</name>
              <description>Initial End Interrupt Status Flag (Read Only)\nThis field is used for activation (ACTEN(SC_ALTCTL[3])), deactivation (DACTEN (SC_ALTCTL[2])) and warm reset (WARSTEN (SC_ALTCTL[4])) sequence interrupt status flag.\nNote: This bit is read only, but it can be cleared by writing 1 to it.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RBTOIF</name>
              <description>Receiver Buffer Time-out Interrupt Status Flag (Read Only)\nThis field is used for receiver buffer time-out interrupt status flag.\nNote: This field is the status flag of receiver buffer time-out state. If software wants to clear this bit, software must read all receiver buffer remaining data by reading SC_DAT buffer,</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ACERRIF</name>
              <description>Auto Convention Error Interrupt Status Flag (Read Only)\nThis field indicates auto convention sequence error. If the received TS at ATR state is neither 0x3B nor 0x3F, this bit will be set.\nNote: This bit is read only, but it can be cleared by writing 1 to it.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SCn_STATUS</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SCn_STATUS</displayName>
          <description>SCn Transfer Status Register.</description>
          <addressOffset>0x20</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000202</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RXOV</name>
              <description>RX Overflow Error Status Flag (Read Only)\nThis bit is set when RX buffer overflow.\nIf the number of received bytes is greater than Rx Buffer size (4 bytes), this bit will be set.\nNote: This bit is read only, but it can be cleared by writing 1 to it.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RXEMPTY</name>
              <description>Receiver Buffer Empty Status Flag(Read Only)\nThis bit indicates RX buffer empty or not.\nWhen the last byte of Rx buffer has been read by CPU, hardware sets this bit high. It will be cleared when SC receives any new data.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RXFULL</name>
              <description>Receiver Buffer Full Status Flag (Read Only)\nThis bit indicates RX buffer full or not.\nThis bit is set when RX pointer is equal to 4, otherwise it is cleared by hardware.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PEF</name>
              <description>Receiver Parity Error Status Flag (Read Only)\nThis bit is set to logic 1 whenever the received character does not have a valid "parity bit".\nNote1: This bit is read only, but it can be cleared by writing 1 to it.\nNote2: If CPU sets receiver retries function by setting RXRTYEN(SC_CTL[19]) , hardware will not set this flag.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>FEF</name>
              <description>Receiver Frame Error Status Flag (Read Only)\nThis bit is set to logic 1 whenever the received character does not have a valid "stop bit" (that is, the stop bit following the last data bit or parity bit is detected as logic 0). \nNote1: This bit is read only, but it can be cleared by writing 1 to it.\nNote2: If CPU sets receiver retries function by setting RXRTYEN(SC_CTL[19]) , hardware will not set this flag.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>BEF</name>
              <description>Receiver Break Error Status Flag (Read Only)\nThis bit is set to logic 1 whenever the received data input (RX) held in the "spacing state" (logic 0) is longer than a full word transmission time (that is, the total time of "start bit" + data bits + parity + stop bits). .\nNote1: This bit is read only, but it can be cleared by writing 1 to it.\nNote2: If CPU sets receiver retries function by setting RXRTYEN(SC_CTL[19]) , hardware will not set this flag.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TXOV</name>
              <description>TX Overflow Error Interrupt Status Flag (Read Only)\nIf TX buffer is full, an additional write to DAT(SC_DAT[7:0]) will cause this bit be set to "1" by hardware. \nNote: This bit is read only, but it can be cleared by writing 1 to it.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TXEMPTY</name>
              <description>Transmit Buffer Empty Status Flag (Read Only)\nThis bit indicates TX buffer empty or not.\nWhen the last byte of TX buffer has been transferred to Transmitter Shift Register, hardware sets this bit high. It will be cleared when writing data into DAT(SC_DAT[7:0]) (TX buffer not empty).</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TXFULL</name>
              <description>Transmit Buffer Full Status Flag (Read Only)\nThis bit indicates TX buffer full or not.This bit is set when TX pointer is equal to 4, otherwise is cleared by hardware.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RXPOINT</name>
              <description>Receiver Buffer Pointer Status Flag (Read Only)\nThis field indicates the RX buffer pointer status flag. When SC receives one byte from external device, RXPOINT(SC_STATUS[17:16]) increases one. When one byte of RX buffer is read by CPU, RXPOINT(SC_STATUS[17:16]) decreases one.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RXRERR</name>
              <description>Receiver Retry Error (Read Only)\nThis bit is set by hardware when RX has any error and retries transfer.\nNote1: This bit is read only, but it can be cleared by writing 1 to it.\nNote2 This bit is a flag and cannot generate any interrupt to CPU.\nNote3: If CPU enables receiver retry function by setting RXRTYEN (SC_CTL[19]) , the PEF(SC_STATUS[4]) flag will be ignored (hardware will not set PEF(SC_STATUS[4])).</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RXOVERR</name>
              <description>Receiver over Retry Error (Read Only)\nThis bit is set by hardware when RX transfer error retry over retry number limit.\nNote1: This bit is read only, but it can be cleared by writing 1 to it.\nNote2: If CPU enables receiver retries function by setting RXRTYEN (SC_CTL[19]), the PEF(SC_STATUS[4]) flag will be ignored (hardware will not set PEF(SC_STATUS[4])).</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RXACT</name>
              <description>Receiver in Active Status Flag (Read Only)\nThis bit is set by hardware when RX transfer is in active.\nThis bit is cleared automatically when RX transfer is finished.</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TXPOINT</name>
              <description>Transmit Buffer Pointer Status Flag (Read Only)\nThis field indicates the TX buffer pointer status flag. When CPU writes data into SC_DAT, TXPOINT increases one. When one byte of TX Buffer is transferred to transmitter shift register, TXPOINT decreases one.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TXRERR</name>
              <description>Transmitter Retry Error (Read Only)\nThis bit is set by hardware when transmitter re-transmits.\nNote1: This bit is read only, but it can be cleared by writing 1 to it.\nNote2 This bit is a flag and cannot generate any interrupt to CPU.</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TXOVERR</name>
              <description>Transmitter over Retry Error (Read Only)\nThis bit is set by hardware when transmitter re-transmits over retry number limitation.\nNote: This bit is read only, but it can be cleared by writing 1 to it.</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TXACT</name>
              <description>Transmit in Active Status Flag (Read Only)</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>This bit is cleared automatically when TX transfer is finished or the last byte transmission has completed</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>This bit is set by hardware when TX transfer is in active and the STOP bit of the last byte has been transmitted</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SCn_PINCTL</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SCn_PINCTL</displayName>
          <description>SCn Pin Control State Register.</description>
          <addressOffset>0x24</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFF0F</resetMask>
          <fields>
            <field>
              <name>PWREN</name>
              <description>SC_PWREN Pin Signal\nSoftware can set PWREN (SC_PINCTL[0]) and PWRINV (SC_PINCTL[11])to decide SC_PWR pin is in high or low level.\nWrite this field to drive SC_PWR pin\nRefer PWRINV (SC_PINCTL[11]) description for programming SC_PWR pin voltage level.\nRead this field to get SC_PWR pin status.\nNote: When operating at hardware activation, warm reset or deactivation mode, this bit will be changed automatically. Thus,do not fill in this field when operating in these modes.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>SC_PWR pin status is low</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>SC_PWR pin status is high</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SCRST</name>
              <description>SC_RST Pin Signal\nThis bit is the pin status of SC_RST but user can drive SC_RST pin to high or low by setting this bit.\nWrite this field to drive SC_RST pin.\nNote: When operating at activation, warm reset or deactivation mode, this bit will be changed automatically. Thus,do not fill in this field when operating in these modes.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Drive SC_RST pin to low.\nSC_RST pin status is low</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Drive SC_RST pin to high.\nSC_RST pin status is high</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CREMOVE</name>
              <description>Card Detect Removal Status of SC_CD Pin (Read Only)\nThis bit is set whenever card has been removal.\nNote1: This bit is read only, but it can be cleared by writing "1" to it.\nNote2: Card detect engine will start after SCEN (SC_CTL[0])set.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Card removed</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>CINSERT</name>
              <description>Card Detect Insert Status of SC_CD Pin (Read Only)\nThis bit is set whenever card has been inserted.\nNote1: This bit is read only, but it can be cleared by writing "1" to it.\nNote2: Thecard detect engine will start after SCEN (SC_CTL[0]) set.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Card insert</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>CDPINSTS</name>
              <description>Card Detect Status of SC_CD Pin Status (Read Only)\nThis bit is the pin status flag of SC_CD</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The SC_CD pin state at low</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The SC_CD pin state at high</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>CLKKEEP</name>
              <description>SC Clock Enable Bit \nNote: When operating in activation, warm reset or deactivation mode, this bit will be changed automatically. Thus,do not fill in this field when operating in these modes.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>SC clock generation Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>SC clock always keeps free running</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ADACEN</name>
              <description>Auto Deactivation When Card Removal\nNote: When the card is removed, hardware will stop any process and then do deactivation sequence (if this bit is set). If this process completes, hardware will generate an interrupt INITIF to CPU.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Auto deactivation Disabled when hardware detected the card removal</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Auto deactivation Enabled when hardware detected the card removal</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SCDOUT</name>
              <description>SC Data Output Pin \nThis bit is the pin status of SCDATOUT but user can drive SCDATOUT pin to high or low by setting this bit.\nNote: When SC is at activation, warm reset or deactivation mode, this bit will be changed automatically. Thus,do not fill in this field when SC is in these modes.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Drive SCDATOUT pin to low</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Drive SCDATOUT pin to high</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CDLV</name>
              <description>Card Detect Level\ndetected. \nNote: Software must select card detect level before Smart Card engine is enabled.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>When hardware detects the card detect pin (SC_CD) from high to low, it indicates a</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>When hardware detects the card detect pin from low to high, it indicates a card is</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PWRINV</name>
              <description>SC_POW Pin Inverse\nThis bit is used for inverse the SC_POW pin.\nThere are four kinds of combination for SC_POW pin setting by PWRINV(SC_PINCTL[11]) and PWREN(SC_PINCTL[0]). PWRINV (SC_PINCTL[11]) is bit 1 and PWREN(SC_PINCTL[0]) is bit 0 for SC_POW_Pin as high or low voltage selection.\nNote:Software must select PWRINV (SC_PINCTL[11]) before Smart Card is enabled by SCEN (SC_CTL[0]).</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DATSTS</name>
              <description>SC Data Input Pin Status (Read Only)\nThis bit is the pin status of SC_DAT</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The SC_DAT pin is low</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The SC_DAT pin is high</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>SYNC</name>
              <description>SYNC Flag Indicator(Read Only)\nDue to synchronization, software should check this bit when writing a new value to SC_PINCTL register.</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Synchronizing is completion, user can write new data to SC_PINCTL register</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Last value is synchronizing</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SCn_TMRCTL0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SCn_TMRCTL0</displayName>
          <description>SCn Internal Timer 0 Control Register.</description>
          <addressOffset>0x28</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CNT</name>
              <description>Timer 0 Counter Value (ETU Based)\nThis field indicates the internal timer operation values.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OPMODE</name>
              <description>Timer 0 Operation Mode Selection\nThis field indicates the internal 24-bit timer operation selection.\nRefer toTable6.153TimerOperation Modefor programming Timer0.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SYNC</name>
              <description>SYNC Flag Indicator(Read Only)\nDue to synchronization, software should check this bit when writing a new value to the SC_TMRCTL0 register.</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Synchronizing is completion, user can write new data to SC_TMRCTL0 register</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Last value is synchronizing</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SCn_TMRCTL1</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SCn_TMRCTL1</displayName>
          <description>SCn Internal Timer 1 Control Register.</description>
          <addressOffset>0x2C</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CNT</name>
              <description>Timer 1 Counter Value (ETU Based)\nThis field indicates the internal timer operation values.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OPMODE</name>
              <description>Timer 1 Operation Mode Selection\nThis field indicates the internal 8-bit timer operation selection.\nRefer toTable6.153TimerOperation Modefor programming Timer1.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SYNC</name>
              <description>SYNC Flag Indicator(Read Only)\nDue to synchronization, software should check this bit when writing a new value to the SC_TMRCTL1 register.</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Synchronizing is completion, user can write new data to SC_TMRCTL1 register</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Last value is synchronizing</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SCn_TMRCTL2</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SCn_TMRCTL2</displayName>
          <description>SCn Internal Timer 2 Control Register.</description>
          <addressOffset>0x30</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CNT</name>
              <description>Timer 2 Counter Value (ETU Based)\nThis field indicates the internal timer operation values.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OPMODE</name>
              <description>Timer 2 Operation Mode Selection\nThis field indicates the internal 8-bit timer operation selection\nRefer to Table6.153TimerOperation Modefor programming Timer2.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SYNC</name>
              <description>SYNC Flag Indicator(Read Only)\nDue to synchronization, software should check this bit when writing a new value to SC_TMRCTL2 register.</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Synchronizing is completion, user can write new data to SC_TMRCTL2 register</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Last value is synchronizing</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SCn_UARTCTL</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SCn_UARTCTL</displayName>
          <description>SCn UART Mode Control Register.</description>
          <addressOffset>0x34</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>UARTEN</name>
              <description>UART Mode Enable Bit\nNote3: When UART is enabled, hardware will generate a resetto reset FIFO and internal state machine.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Smart Card mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>UART mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>WLS</name>
              <description>Word Length Selection\nNote: In smart card mode, this WLS must be '00'</description>
              <bitOffset>4</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Word length is 8 bits</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Word length is 7 bits</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Word length is 6 bits</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Word length is 5 bits</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PBOFF</name>
              <description>Parity Bit Disable Control\nNote: In smart card mode, this field must be '0' (default setting is with parity bit)</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Parity bit is generated or checked between the "last data word bit" and "stop bit" of the serial data</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Parity bit is not generated (transmitting data) or checked (receiving data) during transfer</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>OPE</name>
              <description>Odd Parity Enable Bit\nNote: This bit has effect only when PBOFF bit is '0'.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Even number of logic 1's are transmitted or check the data word and parity bits in receiving mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Odd number of logic 1's are transmitted or check the data word and parity bits in receiving mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SCn_ACTCTL</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SCn_ACTCTL</displayName>
          <description>SCn Activation Control Register.</description>
          <addressOffset>0x40</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>T1EXT</name>
              <description>Configurable Cycles T1EXT in Hardware Activation \nThis field provide the configurable cycles to extend the Activation time T1\nThe cycle scaling factor is 2048.\nNote: setting 0 to this field conforms to the protocol ISO/IEC 7816-3</description>
              <bitOffset>0</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>SC1</name>
      <description>SC Register Map</description>
      <groupName>SC</groupName>
      <baseAddress>0x401B0000</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x0</offset>
        <size>0x38</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x40</offset>
        <size>0x4</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>SCn_DAT</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SCn_DAT</displayName>
          <description>SCn Receive/Transmit Holding Buffer Register.</description>
          <addressOffset>0x0</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>DAT</name>
              <description>Receive/Transmit Holding Buffer \nWrite Operation:\nBy writing data to DAT, the SC will send out an 8-bit data.\nNote: If SCEN(SC_CTL[0]) is not enabled, DAT cannot be programmed.\nRead Operation:\nBy reading DAT, the SC will return an 8-bit received data.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SCn_CTL</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SCn_CTL</displayName>
          <description>SCn Control Register.</description>
          <addressOffset>0x4</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SCEN</name>
              <description>SC Engine Enable Bit\nSet this bit to 1 to enable SC operation. If this bit is cleared, SC will force all transition to IDLE state\nNote1: SCEN must be set to 1 before filling in other registers, or smart card will not work properly.\nNote2: If SCEN is activated, all function can work correctly. If SCEN is not activated, when CPU write data to SMC, only Flip-flop which works in PCLK domain will turn on for two PCLK cycle, Flip-flop working in SCLK domain will not be turn on.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXOFF</name>
              <description>RX Transition Disable Bit\nNote1: If AUTOCEN (SC_CTL[3])is enabled, these fields must be ignored.\nNote2: After hardware activation and hardware warm reset are done, RXOFF is set to 0 automatically.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The receiver Enabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The receiver Disabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TXOFF</name>
              <description>TX Transition Disable Bit</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The transceiver Enabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The transceiver Disabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>AUTOCEN</name>
              <description>Auto Convention Enable Bit</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Auto-convention Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Auto-convention Enabled. When hardware receives TS in answer to reset state and the TS is direct convention, CONSEL(SC_CTL[5:4]) will be set to 00 automatically, otherwise if the TS is inverse convention, and CONSEL (SC_CTL[5:4]) will be set to 11</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CONSEL</name>
              <description>Convention Selection\nNote: If AUTOCEN(SC_CTL[3]) is enabled, this field is ignored.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Direct convention</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reserved</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Reserved</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Inverse convention</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RXTRGLV</name>
              <description>Rx Buffer Trigger Level \nWhen the number of bytes in the receiving buffer equals the RXTRGLV, the RDAIF will be set (if SC_INTEN [RDAIEN] is enabled, an interrupt will be generated).</description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>INTR_RDA Trigger Level with 01 Bytes</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>INTR_RDA Trigger Level with 02 Bytes</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>INTR_RDA Trigger Level with 03 Bytes</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Reserved</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BGT</name>
              <description>Block Guard Time (BGT)\nNote: The real block guard time is BGT + 1.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TMRSEL</name>
              <description>Timer Selection \nOther configurations are reserved</description>
              <bitOffset>13</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>All internal timer function Disabled</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Internal 24 bit timer and two 8 bit timers Enabled. Software can configure them by setting SC_TMRCTL0 [23:0], SC_TMRCTL1 [7:0] and SC_TMRCTL2 [7:0]</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>NSB</name>
              <description>Stop Bit Length\nThis field indicates the length of stop bit.\nNote: The default stop bit length is 2. SMC and UART adopt NSB to program the stop bit length.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The stop bit length is 2 ETU</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The stop bit length is 1 ETU</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RXRTY</name>
              <description>RX Error Retry Count Number\nThis field indicates the maximum number of receiver retries that are allowed when parity error has occurred\nNote1: The real retry number is RX_ERETRY + 1, so 8 is the maximum retry number.\nNote2: This field cannot be changed when RX_ERETRY_EN enabled. The change flow is to disable RX_ETRTRY_EN first and then fill in new retry value.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXRTYEN</name>
              <description>RX Error Retry Enable Bit\nThis bit enables receiver retry function when parity error has occurred.\nNote: Software must fill in the RXRTY value before enabling this bit.</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RX error retry function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RX error retry function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TXRTY</name>
              <description>TX Error Retry Count Number\nThis field indicates the maximum number of transmitter retries that are allowed when parity error has occurred.\nNote1: The real retry number is TXRTY + 1, so 8 is the maximum retry number.\nNote2: This field cannot be changed when TXRTYEN enabled. The change flow is to disable TXRTYEN first and then fill in new retry value.</description>
              <bitOffset>20</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TXRTYEN</name>
              <description>TX Error Retry Enable Bit\nThis bit enables transmitter retry function when parity error has occurred.</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>TX error retry function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>TX error retry function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CDDBSEL</name>
              <description>Card Detect De-bounce Selection\nThis field indicates the card detect de-bounce selection.\nOther configurations are reserved.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>De-bounce sample card insert once per 384 (128 * 3) engine clocks and de-bounce sample card removal once per 128 engine clocks</description>
                    <value>#00</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SYNC</name>
              <description>SYNC Flag Indicator(Read Only)\nDue to synchronization, software should check this bit before writing a new value to RXRTY and TXRTY.SYNC delay is </description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>synchronizing is completion, user can write new data to RXRTY and TXRTY</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Last value is synchronizing</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SCn_ALTCTL</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SCn_ALTCTL</displayName>
          <description>SCn Alternate Control Register.</description>
          <addressOffset>0x8</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TXRST</name>
              <description>TX Software Reset\nWhen TXRST is set, all the bytes in the transmit buffer and TX internal state machine will be cleared.\nNote: This bit will be auto cleared after reset is complete.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reset the TX internal state machine and pointers</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RXRST</name>
              <description>Rx Software Reset\nWhen RXRST is set, all the bytes in the receiver buffer and Rx internal state machine will be cleared.\nNote: This bit will be auto cleared after reset is complete.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reset the Rx internal state machine and pointers</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DACTEN</name>
              <description>Deactivation Sequence Generator Enable Bit\nThis bit enables SC controller to initiate the card by deactivation sequence\nNote1: When the deactivation sequence completed, this bit will be cleared automatically and the INITIF(SC_INTSTS[8]) will be set to 1.\nNote2: This field will be cleared by TXRST (SC_ALTCTL[0]) and RXRST(SC_ALTCTL[1]).Thus,do not fill in this bit, TXRST, and RXRST at the same time.\nNote3: If SCEN (SC_CTL[0]) is not enabled, this filed cannot be programmed.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Deactivation sequence generator Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ACTEN</name>
              <description>Activation Sequence Generator Enable Bit\nThis bit enables SC controller to initiate the card by activation sequence\nNote1: When the activation sequence completed, this bit will be cleared automatically and the INITIF(SC_INTSTS[8]) will be set to 1, RXOFF(SC_CTL[2]) will be clear to 0.\nNote2: This field will be cleared by TXRST(SC_ALTCTL[0]) and RXRST(SC_ALTCTL[1]).Thus,do not fill in this bit, TXRST(SC_ALTCTL[0]), and RXRST(SC_ALTCTL[1]) at the same time.\nNote3: If SCEN(SC_CTL[0]) is not enabled, this filed cannot be programmed.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Activation sequence generator Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>WARSTEN</name>
              <description>Warm Reset Sequence Generator Enable Bit\nThis bit enables SC controller to initiate the card by warm reset sequence\nNote1: When the warm reset sequence completed, this bit will be cleared automatically and the INITIF(SC_INTSTS[8]) will be set to 1, RXOFF(SC_CTL[2]) will be clear to 0.\nNote2: This field will be cleared by TXRST(SC_ALTCTL[0]) and RXRST(SC_ALTCTL[1]).Thus,do not fill in this bit, TXRST, and RXRST at the same time.\nNote3: If SCEN(SC_CTL[0]) is not enabled, this filed cannot be programmed.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Warm reset sequence generator Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CNTEN0</name>
              <description>Internal Timer0 Start Enable Bit\nThis bit enables Timer 0 to start counting. Software can fill 0 to stop it and set 1 to reload and count.\nNote3: If SCEN(SC_CTL[0]) is not enabled, this filed cannot be programmed.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Stops counting</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Start counting</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CNTEN1</name>
              <description>Internal Timer1 Start Enable Bit\nThis bit enables Timer 1 to start counting. Software can fill 0 to stop it and set 1 to reload and count.\nNote3: If SCEN(SC_CTL[0]) is not enabled, this filed cannot be programmed.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Stops counting</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Start counting</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CNTEN2</name>
              <description>Internal Timer2 Start Enable Bit\nThis bit enables Timer 2 to start counting. Software can fill 0 to stop it and set 1 to reload and count.\nNote3: If SCEN(SC_CTL[0]) is not enabled, this filed cannot be programmed.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Stops counting</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Start counting</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>INITSEL</name>
              <description>Initial Timing Selection\nThis fields indicates the timing of hardware initial state (activation or warm-reset or deactivation).\nUnit: SC clock\nActivation: Refer to SC Activation Sequence in Figure 6.154SC Activation Sequence.\nWarm-reset: Refer to Warm-Reset Sequence in Figure 6.155SC Warm Reset Sequence\nDeactivation: Refer to Deactivation Sequence in Figure 6.156SC Deactivation Sequence\nNote: When set Activation and Warm reset in mode 11, it may have deviation at most 128 cycles.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXBGTEN</name>
              <description>Receiver Block Guard Time Function Enable Bit</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Receiver block guard time function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Receiver block guard time function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ACTSTS0</name>
              <description>Internal Timer0 Active State (Read Only)\nThis bit indicates the timer counter status of timer0.\nNote: Timer0 is active does not always mean timer0 is counting the CNT(SC_TMRCTL0[23:0]).</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Timer0 is not active</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Timer0 is active</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>ACTSTS1</name>
              <description>Internal Timer1 Active State (Read Only)\nThis bit indicates the timer counter status of timer1.\nNote: Timer1 is active does not always mean timer1 is counting the CNT(SC_TMRCTL1[7:0]).</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Timer1 is not active</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Timer1 is active</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>ACTSTS2</name>
              <description>Internal Timer2 Active State (Read Only)\nThis bit indicates the timer counter status of timer2.\nNote: Timer2 is active does not always mean timer2 is counting the CNT(SC_TMRCTL2[7:0]).</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Timer2 is not active</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Timer2 is active</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>OUTSEL</name>
              <description>Smartcard Data Pin Output Mode Selection\nUse this bit to select smartcard data pin output mode.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Quasi mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Open-drain mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SCn_EGT</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SCn_EGT</displayName>
          <description>SCn Extra Guard Time Register.</description>
          <addressOffset>0xC</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>EGT</name>
              <description>Extra Guard Time\nThis field indicates the extra guard timer value.\nNote: The counter is ETU base .</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SCn_RXTOUT</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SCn_RXTOUT</displayName>
          <description>SCn Receive buffer Time-out Register.</description>
          <addressOffset>0x10</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RFTM</name>
              <description>SC Receiver FIFO Time-out \nNote1:The counter unit is ETU based and the interval of time-out is RFTM + 0.5.\nNote2: Filling in all 0 to this field indicates to disable this function.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>9</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SCn_ETUCTL</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SCn_ETUCTL</displayName>
          <description>SCn Element Time Unit Control Register.</description>
          <addressOffset>0x14</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000173</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ETURDIV</name>
              <description>ETU Rate Divider\nThe field indicates the clock rate divider.\nThe real ETU is ETURDIV + 1.\nNote: Software can configure this field, but this field must be greater than 0x004.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>12</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SCn_INTEN</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SCn_INTEN</displayName>
          <description>SCn Interrupt Enable Control Register.</description>
          <addressOffset>0x18</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RDAIEN</name>
              <description>Receive Data Reach Interrupt Enable Bit\nThis field is used to enable received data reaching trigger level RXTRGLV (SC_CTL[7:6]) interrupt.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Receive data reach trigger level interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Receive data reach trigger level interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TBEIEN</name>
              <description>Transmit Buffer Empty Interrupt Enable Bit\nThis field is used to enable transmit buffer empty interrupt.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Transmit buffer empty interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Transmit buffer empty interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TERRIEN</name>
              <description>Transfer Error Interrupt Enable Bit\nThis field is used to enable transfer error interrupt. The transfer error states is at SC_STATUS register which includes receiver break error BEF(SC_STATUS[6]), frame error FEF(SC_STATUS[5]), parity error PEF(SC_STATUS[4]), receiver buffer overflow error RXOV(SC_STATUS[0]), transmit buffer overflow error TXOV(SC_STATUS[8]), receiver retry over limit error RXOVERR(SC_STATUS[22]) and transmitter retry over limit error TXOVERR (SC_STATUS[30]).</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Transfer error interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Transfer error interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TMR0IEN</name>
              <description>Timer0 Interrupt Enable Bit\nThis field is used to enable TMR0 interrupt.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Timer0 interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Timer0 interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TMR1IEN</name>
              <description>Timer1 Interrupt Enable Bit\nThis field is used to enable the TMR1 interrupt.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Timer1 interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Timer1 interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TMR2IEN</name>
              <description>Timer2 Interrupt Enable Bit\nThis field is used to enable TMR2 interrupt.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Timer2 interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Timer2 interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BGTIEN</name>
              <description>Block Guard Time Interrupt Enable Bit\nThis field is used to enable block guard time interrupt.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Block guard time Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Block guard time Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CDIEN</name>
              <description>Card Detect Interrupt Enable Bit\nThis field is used to enable card detect interrupt. The card detect status is CINSERT(SC_STATUS[12]) </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Card detect interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Card detect interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>INITIEN</name>
              <description>Initial End Interrupt Enable Bit</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Initial end interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Initial end interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RXTOEN</name>
              <description>Receiver Buffer Time-out Interrupt Enable Bit\nThis field is used to enable receiver buffer time-out interrupt.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Receiver buffer time-out interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Receiver buffer time-out interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ACERRIEN</name>
              <description>Auto Convention Error Interrupt Enable Bit\nThis field is used to enable auto-convention error interrupt.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Auto-convention error interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Auto-convention error interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SCn_INTSTS</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SCn_INTSTS</displayName>
          <description>SCn Interrupt Status Register.</description>
          <addressOffset>0x1C</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000002</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RDAIF</name>
              <description>Receive Data Reach Interrupt Status Flag (Read Only)\nThis field is used for received data reaching trigger level RXTRGLV (SC_CTL[7:6]) interrupt status flag.\nNote: This field is the status flag of received data reaching RXTRGLV (SC_CTL[7:6]). If software reads data from SC_DAT and receiver buffer data byte number is less than RXTRGLV (SC_CTL[7:6]), this bit will be cleared automatically.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TBEIF</name>
              <description>Transmit Buffer Empty Interrupt Status Flag (Read Only)\nThis field is used for transmit buffer empty interrupt status flag.\nNote: This field is the status flag of transmit buffer empty state. If software wants to clear this bit, software must write data to DAT(SC_DAT[7:0]) buffer and then this bit will be cleared automatically.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TERRIF</name>
              <description>Transfer Error Interrupt Status Flag (Read Only)\nThis field is used for transfer error interrupt status flag. The transfer error states is at SC_STATUS register which includes receiver break error BEF(SC_STATUS[6]), frame error FEF(SC_STATUS[5], parity error PEF(SC_STATUS[4] and receiver buffer overflow error RXOV(SC_STATUS[0]), transmit buffer overflow error TXOV(SC_STATUS[8]), receiver retry over limit error RXOVERR(SC_STATUS[22] and transmitter retry over limit error TXOVERR(SC_STATUS[30]).\nNote: This field is the status flag of BEF(SC_STATUS[6]), FEF(SC_STATUS[5]), PEF(SC_STATUS[4]), RXOV(SC_STATUS[0]), TXOV(SC_STATUS[8]), RXOVERR(SC_STATUS[22]) or TXOVERR(SC_STATUS[30]). So, if software wants to clear this bit, software must write 1 to each field.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TMR0IF</name>
              <description>Timer0 Interrupt Status Flag (Read Only)\nThis field is used for TMR0 interrupt status flag.\nNote: This bit is read only, but it can be cleared by writing 1 to it.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TMR1IF</name>
              <description>Timer1 Interrupt Status Flag (Read Only)\nThis field is used for TMR1 interrupt status flag.\nNote: This bit is read only, but it can be cleared by writing 1 to it.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TMR2IF</name>
              <description>Timer2 Interrupt Status Flag (Read Only)\nThis field is used for TMR2 interrupt status flag.\nNote: This bit is read only, but it can be cleared by writing 1 to it.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>BGTIF</name>
              <description>Block Guard Time Interrupt Status Flag (Read Only)\nThis field is used for block guard time interrupt status flag.\nNote1: This bit is valid when RXBGTEN (SC_ALTCTL[12]) is enabled.\nNote2: This bit is read only, but it can be cleared by writing "1" to it.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>CDIF</name>
              <description>Card Detect Interrupt Status Flag (Read Only)\nThis field is used for card detect interrupt status flag. The card detect status is CINSERT (SC_STATUS[12]) and CREMOVE(SC_STATUS[11]).\nNote: This field is the status flag of CINSERT(SC_STATUS[12]) or CREMOVE(SC_STATUS[11])]. So if software wants to clear these bits, software must write 1 to these field.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>INITIF</name>
              <description>Initial End Interrupt Status Flag (Read Only)\nThis field is used for activation (ACTEN(SC_ALTCTL[3])), deactivation (DACTEN (SC_ALTCTL[2])) and warm reset (WARSTEN (SC_ALTCTL[4])) sequence interrupt status flag.\nNote: This bit is read only, but it can be cleared by writing 1 to it.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RBTOIF</name>
              <description>Receiver Buffer Time-out Interrupt Status Flag (Read Only)\nThis field is used for receiver buffer time-out interrupt status flag.\nNote: This field is the status flag of receiver buffer time-out state. If software wants to clear this bit, software must read all receiver buffer remaining data by reading SC_DAT buffer,</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ACERRIF</name>
              <description>Auto Convention Error Interrupt Status Flag (Read Only)\nThis field indicates auto convention sequence error. If the received TS at ATR state is neither 0x3B nor 0x3F, this bit will be set.\nNote: This bit is read only, but it can be cleared by writing 1 to it.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SCn_STATUS</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SCn_STATUS</displayName>
          <description>SCn Transfer Status Register.</description>
          <addressOffset>0x20</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000202</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RXOV</name>
              <description>RX Overflow Error Status Flag (Read Only)\nThis bit is set when RX buffer overflow.\nIf the number of received bytes is greater than Rx Buffer size (4 bytes), this bit will be set.\nNote: This bit is read only, but it can be cleared by writing 1 to it.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RXEMPTY</name>
              <description>Receiver Buffer Empty Status Flag(Read Only)\nThis bit indicates RX buffer empty or not.\nWhen the last byte of Rx buffer has been read by CPU, hardware sets this bit high. It will be cleared when SC receives any new data.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RXFULL</name>
              <description>Receiver Buffer Full Status Flag (Read Only)\nThis bit indicates RX buffer full or not.\nThis bit is set when RX pointer is equal to 4, otherwise it is cleared by hardware.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PEF</name>
              <description>Receiver Parity Error Status Flag (Read Only)\nThis bit is set to logic 1 whenever the received character does not have a valid "parity bit".\nNote1: This bit is read only, but it can be cleared by writing 1 to it.\nNote2: If CPU sets receiver retries function by setting RXRTYEN(SC_CTL[19]) , hardware will not set this flag.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>FEF</name>
              <description>Receiver Frame Error Status Flag (Read Only)\nThis bit is set to logic 1 whenever the received character does not have a valid "stop bit" (that is, the stop bit following the last data bit or parity bit is detected as logic 0). \nNote1: This bit is read only, but it can be cleared by writing 1 to it.\nNote2: If CPU sets receiver retries function by setting RXRTYEN(SC_CTL[19]) , hardware will not set this flag.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>BEF</name>
              <description>Receiver Break Error Status Flag (Read Only)\nThis bit is set to logic 1 whenever the received data input (RX) held in the "spacing state" (logic 0) is longer than a full word transmission time (that is, the total time of "start bit" + data bits + parity + stop bits). .\nNote1: This bit is read only, but it can be cleared by writing 1 to it.\nNote2: If CPU sets receiver retries function by setting RXRTYEN(SC_CTL[19]) , hardware will not set this flag.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TXOV</name>
              <description>TX Overflow Error Interrupt Status Flag (Read Only)\nIf TX buffer is full, an additional write to DAT(SC_DAT[7:0]) will cause this bit be set to "1" by hardware. \nNote: This bit is read only, but it can be cleared by writing 1 to it.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TXEMPTY</name>
              <description>Transmit Buffer Empty Status Flag (Read Only)\nThis bit indicates TX buffer empty or not.\nWhen the last byte of TX buffer has been transferred to Transmitter Shift Register, hardware sets this bit high. It will be cleared when writing data into DAT(SC_DAT[7:0]) (TX buffer not empty).</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TXFULL</name>
              <description>Transmit Buffer Full Status Flag (Read Only)\nThis bit indicates TX buffer full or not.This bit is set when TX pointer is equal to 4, otherwise is cleared by hardware.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RXPOINT</name>
              <description>Receiver Buffer Pointer Status Flag (Read Only)\nThis field indicates the RX buffer pointer status flag. When SC receives one byte from external device, RXPOINT(SC_STATUS[17:16]) increases one. When one byte of RX buffer is read by CPU, RXPOINT(SC_STATUS[17:16]) decreases one.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RXRERR</name>
              <description>Receiver Retry Error (Read Only)\nThis bit is set by hardware when RX has any error and retries transfer.\nNote1: This bit is read only, but it can be cleared by writing 1 to it.\nNote2 This bit is a flag and cannot generate any interrupt to CPU.\nNote3: If CPU enables receiver retry function by setting RXRTYEN (SC_CTL[19]) , the PEF(SC_STATUS[4]) flag will be ignored (hardware will not set PEF(SC_STATUS[4])).</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RXOVERR</name>
              <description>Receiver over Retry Error (Read Only)\nThis bit is set by hardware when RX transfer error retry over retry number limit.\nNote1: This bit is read only, but it can be cleared by writing 1 to it.\nNote2: If CPU enables receiver retries function by setting RXRTYEN (SC_CTL[19]), the PEF(SC_STATUS[4]) flag will be ignored (hardware will not set PEF(SC_STATUS[4])).</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RXACT</name>
              <description>Receiver in Active Status Flag (Read Only)\nThis bit is set by hardware when RX transfer is in active.\nThis bit is cleared automatically when RX transfer is finished.</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TXPOINT</name>
              <description>Transmit Buffer Pointer Status Flag (Read Only)\nThis field indicates the TX buffer pointer status flag. When CPU writes data into SC_DAT, TXPOINT increases one. When one byte of TX Buffer is transferred to transmitter shift register, TXPOINT decreases one.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TXRERR</name>
              <description>Transmitter Retry Error (Read Only)\nThis bit is set by hardware when transmitter re-transmits.\nNote1: This bit is read only, but it can be cleared by writing 1 to it.\nNote2 This bit is a flag and cannot generate any interrupt to CPU.</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TXOVERR</name>
              <description>Transmitter over Retry Error (Read Only)\nThis bit is set by hardware when transmitter re-transmits over retry number limitation.\nNote: This bit is read only, but it can be cleared by writing 1 to it.</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TXACT</name>
              <description>Transmit in Active Status Flag (Read Only)</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>This bit is cleared automatically when TX transfer is finished or the last byte transmission has completed</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>This bit is set by hardware when TX transfer is in active and the STOP bit of the last byte has been transmitted</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SCn_PINCTL</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SCn_PINCTL</displayName>
          <description>SCn Pin Control State Register.</description>
          <addressOffset>0x24</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFF0F</resetMask>
          <fields>
            <field>
              <name>PWREN</name>
              <description>SC_PWREN Pin Signal\nSoftware can set PWREN (SC_PINCTL[0]) and PWRINV (SC_PINCTL[11])to decide SC_PWR pin is in high or low level.\nWrite this field to drive SC_PWR pin\nRefer PWRINV (SC_PINCTL[11]) description for programming SC_PWR pin voltage level.\nRead this field to get SC_PWR pin status.\nNote: When operating at hardware activation, warm reset or deactivation mode, this bit will be changed automatically. Thus,do not fill in this field when operating in these modes.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>SC_PWR pin status is low</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>SC_PWR pin status is high</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SCRST</name>
              <description>SC_RST Pin Signal\nThis bit is the pin status of SC_RST but user can drive SC_RST pin to high or low by setting this bit.\nWrite this field to drive SC_RST pin.\nNote: When operating at activation, warm reset or deactivation mode, this bit will be changed automatically. Thus,do not fill in this field when operating in these modes.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Drive SC_RST pin to low.\nSC_RST pin status is low</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Drive SC_RST pin to high.\nSC_RST pin status is high</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CREMOVE</name>
              <description>Card Detect Removal Status of SC_CD Pin (Read Only)\nThis bit is set whenever card has been removal.\nNote1: This bit is read only, but it can be cleared by writing "1" to it.\nNote2: Card detect engine will start after SCEN (SC_CTL[0])set.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Card removed</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>CINSERT</name>
              <description>Card Detect Insert Status of SC_CD Pin (Read Only)\nThis bit is set whenever card has been inserted.\nNote1: This bit is read only, but it can be cleared by writing "1" to it.\nNote2: Thecard detect engine will start after SCEN (SC_CTL[0]) set.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Card insert</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>CDPINSTS</name>
              <description>Card Detect Status of SC_CD Pin Status (Read Only)\nThis bit is the pin status flag of SC_CD</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The SC_CD pin state at low</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The SC_CD pin state at high</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>CLKKEEP</name>
              <description>SC Clock Enable Bit \nNote: When operating in activation, warm reset or deactivation mode, this bit will be changed automatically. Thus,do not fill in this field when operating in these modes.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>SC clock generation Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>SC clock always keeps free running</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ADACEN</name>
              <description>Auto Deactivation When Card Removal\nNote: When the card is removed, hardware will stop any process and then do deactivation sequence (if this bit is set). If this process completes, hardware will generate an interrupt INITIF to CPU.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Auto deactivation Disabled when hardware detected the card removal</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Auto deactivation Enabled when hardware detected the card removal</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SCDOUT</name>
              <description>SC Data Output Pin \nThis bit is the pin status of SCDATOUT but user can drive SCDATOUT pin to high or low by setting this bit.\nNote: When SC is at activation, warm reset or deactivation mode, this bit will be changed automatically. Thus,do not fill in this field when SC is in these modes.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Drive SCDATOUT pin to low</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Drive SCDATOUT pin to high</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CDLV</name>
              <description>Card Detect Level\ndetected. \nNote: Software must select card detect level before Smart Card engine is enabled.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>When hardware detects the card detect pin (SC_CD) from high to low, it indicates a</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>When hardware detects the card detect pin from low to high, it indicates a card is</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PWRINV</name>
              <description>SC_POW Pin Inverse\nThis bit is used for inverse the SC_POW pin.\nThere are four kinds of combination for SC_POW pin setting by PWRINV(SC_PINCTL[11]) and PWREN(SC_PINCTL[0]). PWRINV (SC_PINCTL[11]) is bit 1 and PWREN(SC_PINCTL[0]) is bit 0 for SC_POW_Pin as high or low voltage selection.\nNote:Software must select PWRINV (SC_PINCTL[11]) before Smart Card is enabled by SCEN (SC_CTL[0]).</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DATSTS</name>
              <description>SC Data Input Pin Status (Read Only)\nThis bit is the pin status of SC_DAT</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The SC_DAT pin is low</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The SC_DAT pin is high</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>SYNC</name>
              <description>SYNC Flag Indicator(Read Only)\nDue to synchronization, software should check this bit when writing a new value to SC_PINCTL register.</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Synchronizing is completion, user can write new data to SC_PINCTL register</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Last value is synchronizing</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SCn_TMRCTL0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SCn_TMRCTL0</displayName>
          <description>SCn Internal Timer 0 Control Register.</description>
          <addressOffset>0x28</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CNT</name>
              <description>Timer 0 Counter Value (ETU Based)\nThis field indicates the internal timer operation values.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OPMODE</name>
              <description>Timer 0 Operation Mode Selection\nThis field indicates the internal 24-bit timer operation selection.\nRefer toTable6.153TimerOperation Modefor programming Timer0.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SYNC</name>
              <description>SYNC Flag Indicator(Read Only)\nDue to synchronization, software should check this bit when writing a new value to the SC_TMRCTL0 register.</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Synchronizing is completion, user can write new data to SC_TMRCTL0 register</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Last value is synchronizing</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SCn_TMRCTL1</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SCn_TMRCTL1</displayName>
          <description>SCn Internal Timer 1 Control Register.</description>
          <addressOffset>0x2C</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CNT</name>
              <description>Timer 1 Counter Value (ETU Based)\nThis field indicates the internal timer operation values.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OPMODE</name>
              <description>Timer 1 Operation Mode Selection\nThis field indicates the internal 8-bit timer operation selection.\nRefer toTable6.153TimerOperation Modefor programming Timer1.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SYNC</name>
              <description>SYNC Flag Indicator(Read Only)\nDue to synchronization, software should check this bit when writing a new value to the SC_TMRCTL1 register.</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Synchronizing is completion, user can write new data to SC_TMRCTL1 register</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Last value is synchronizing</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SCn_TMRCTL2</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SCn_TMRCTL2</displayName>
          <description>SCn Internal Timer 2 Control Register.</description>
          <addressOffset>0x30</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CNT</name>
              <description>Timer 2 Counter Value (ETU Based)\nThis field indicates the internal timer operation values.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OPMODE</name>
              <description>Timer 2 Operation Mode Selection\nThis field indicates the internal 8-bit timer operation selection\nRefer to Table6.153TimerOperation Modefor programming Timer2.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SYNC</name>
              <description>SYNC Flag Indicator(Read Only)\nDue to synchronization, software should check this bit when writing a new value to SC_TMRCTL2 register.</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Synchronizing is completion, user can write new data to SC_TMRCTL2 register</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Last value is synchronizing</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SCn_UARTCTL</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SCn_UARTCTL</displayName>
          <description>SCn UART Mode Control Register.</description>
          <addressOffset>0x34</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>UARTEN</name>
              <description>UART Mode Enable Bit\nNote3: When UART is enabled, hardware will generate a resetto reset FIFO and internal state machine.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Smart Card mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>UART mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>WLS</name>
              <description>Word Length Selection\nNote: In smart card mode, this WLS must be '00'</description>
              <bitOffset>4</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Word length is 8 bits</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Word length is 7 bits</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Word length is 6 bits</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Word length is 5 bits</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PBOFF</name>
              <description>Parity Bit Disable Control\nNote: In smart card mode, this field must be '0' (default setting is with parity bit)</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Parity bit is generated or checked between the "last data word bit" and "stop bit" of the serial data</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Parity bit is not generated (transmitting data) or checked (receiving data) during transfer</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>OPE</name>
              <description>Odd Parity Enable Bit\nNote: This bit has effect only when PBOFF bit is '0'.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Even number of logic 1's are transmitted or check the data word and parity bits in receiving mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Odd number of logic 1's are transmitted or check the data word and parity bits in receiving mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SCn_ACTCTL</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SCn_ACTCTL</displayName>
          <description>SCn Activation Control Register.</description>
          <addressOffset>0x40</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>T1EXT</name>
              <description>Configurable Cycles T1EXT in Hardware Activation \nThis field provide the configurable cycles to extend the Activation time T1\nThe cycle scaling factor is 2048.\nNote: setting 0 to this field conforms to the protocol ISO/IEC 7816-3</description>
              <bitOffset>0</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>I2C0</name>
      <description>I2C Register Map</description>
      <groupName>I2C</groupName>
      <baseAddress>0x40020000</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x0</offset>
        <size>0x20</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x28</offset>
        <size>0x8</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x40</offset>
        <size>0x8</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>I2C_CTL</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>I2C_CTL</displayName>
          <description>I2C Control Register</description>
          <addressOffset>0x0</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>I2CEN</name>
              <description>I2C Function EnableBit</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>I2C function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>I2C function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>AA</name>
              <description>Assert Acknowledge Control Bit</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>STO</name>
              <description>I2C STOP Control Bit\nIn Master mode, setting STO to transmit a STOP condition to bus then I2C controller will check the bus condition if a STOP condition is detected. This bit will be cleared by hardware automatically.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>STA</name>
              <description>I2C START Command\nSetting STA to logic 1 to enter Master mode, the I2C hardware sends a START or repeat START condition to bus when the bus is free.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SI</name>
              <description>I2C Status\nWhen a new state is present in the I2C_STATUS register, if the INTEN bit is set, the I2C interrupt is requested. It must write one by software to this bit after the INTSTS (I2C_INTSTS[0]) is set to 1 and the I2C protocol function will go ahead until the STOP is active or the I2CEN is disabled.\nNote:If software wants to skip clearing INTSTS (I2C_INTSTS[0]), it also can write 1 to SI bit and must set INTEN bit. That INTSTS (I2C_INTSTS[0]) wll be cleared when SI is cleared.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>I2C's Status disabled and the I2C protocol function will go ahead</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>I2C's Status active</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>INTEN</name>
              <description>Interrupt EnableBit</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>I2C interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>I2C interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>I2C_INTSTS</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>I2C_INTSTS</displayName>
          <description>I2C Interrupt Status Register</description>
          <addressOffset>0x4</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>INTSTS</name>
              <description>I2C STATUS's Interrupt Status\nWhen a new I2C state is present in the I2C_STATUS register, the INTSTS flag is set by hardware. If bit INTEN (I2C_CTL [7]) is set, the I2C interrupt is requested.This bit must be cleared by software writing '1' .\nNote:If software wants to skip clearing INTSTS, it can also write 1 to SI (I2C_CTL [4]) bit and must set INTEN (I2C_CTL [7]) bit. INISTS wll be cleared when SI is cleared.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TOIF</name>
              <description>Time-out Status\nNote:This bit can be cleared by writing '1' to it.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No Time-out flag</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Time-out flag active and it is set by hardware. It can interrupt CPU when INTEN bit is set</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>WKAKDONE</name>
              <description>Wake-up Address Frame Acknowledge Bit Done\nNote:This bit can be cleared by writing'1' toit.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The ACK bit cycle of address match frame is not done</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The ACK bit cycle of address match frame is done in power-down</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>I2C_STATUS</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>I2C_STATUS</displayName>
          <description>I2C Status Register</description>
          <addressOffset>0x8</addressOffset>
          <access>read-only</access>
          <resetValue>0x000000F8</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>STATUS</name>
              <description>I2C Status Bits (Read Only)</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>I2C_CLKDIV</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>I2C_CLKDIV</displayName>
          <description>I2C Clock Divided Register</description>
          <addressOffset>0xC</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DIVIDER</name>
              <description>I2C Clock DividedBits\nNote:The minimum value of I2C_CLKDIV is 4.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>I2C_TOCTL</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>I2C_TOCTL</displayName>
          <description>I2C Time-out Control Register</description>
          <addressOffset>0x10</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TOCEN</name>
              <description>Time-out Counter Enable Bit\nWhen this bit is set to enabled and clcok be stretched, the 14 bits time-out counter will start counting.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Time-out counter Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Time-out counter Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TOCDIV4</name>
              <description>Time-out Counter Input Clock Divider by 4\nWhen enabled, the time-out period is extended 4 times.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Time-out counter input clock divider by 4Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Time-out counter input clock divider by 4 Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>I2C_DAT</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>I2C_DAT</displayName>
          <description>I2C Data Register</description>
          <addressOffset>0x14</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DAT</name>
              <description>I2C Data\nBit [7:0] is located with the 8-bit transferred/received data of I2C serial port.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>I2C_ADDR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>I2C_ADDR0</displayName>
          <description>I2C Slave Address Register0</description>
          <addressOffset>0x18</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>GC</name>
              <description>General Call FunctionControl\nNote: Refer to Address Register section for more detailed information..</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>General Call Function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>General Call Function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ADDR</name>
              <description>I2C Salve Address Bits\nThe content of this register is irrelevant when the device is in Master mode. In the Slave mode, the seven most significant bits must be loaded with the device's own address. The device will react if either of the address is matched.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>7</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="I2C_ADDR0">
          <name>I2C_ADDR1</name>
          <displayName>I2C_ADDR1</displayName>
          <description>I2C Slave Address Register1</description>
          <addressOffset>0x1C</addressOffset>
       </register>
       <register>
          <name>I2C_ADDRMSK0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>I2C_ADDRMSK0</displayName>
          <description>I2C Slave Address Mask Register0</description>
          <addressOffset>0x28</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ADDRMSK</name>
              <description>I2C Slave Address Mask Bits\nI2C bus controllers support multiple address recognition with two address mask register. When the bit in the address mask register is set to one, it means the received corresponding address bit is don't-care. If the bit is set to zero, that means the received corresponding register bit should be exact the same as address register.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>7</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Mask disable (the received corresponding register bit should be exact the same as address register)</description>
                    <value>0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Mask enable (the received corresponding address bit is don't care)</description>
                    <value>1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="I2C_ADDRMSK0">
          <name>I2C_ADDRMSK1</name>
          <displayName>I2C_ADDRMSK1</displayName>
          <description>I2C Slave Address Mask Register1</description>
          <addressOffset>0x2C</addressOffset>
       </register>
       <register>
          <name>I2C_CTL2</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>I2C_CTL2</displayName>
          <description>I2C Control Register 2</description>
          <addressOffset>0x40</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WKUPEN</name>
              <description>I2C Wake-up Function EnableBit</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>I2C wake-up function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>I2C wake-up function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>OVIEN</name>
              <description>I2C Overrun Interrupt Control Bit</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Overrun event interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Send a interrupt to system when the TWOLVBUF bit is enabled and there is overrun event in received buffer</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>URIEN</name>
              <description>I2C Underrun Interrupt Control Bit</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Underrun event interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Send a interrupt to system when theTWOLVBUF bit is enabled and there is underrun event happened in transmitted buffer</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TWOLVBUF</name>
              <description>Two Level Buffer Enable Bit</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Two level bufferDisabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Two level bufferEnabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>NOSTRETCH</name>
              <description>I2C BuS Stretch</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The I2C SCL bus is stretched by hardware if the SI (I2C_CTL[4]) is not cleared</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The I2C SCL bus is not stretched by hardware if the SI is not cleared</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DATMODE</name>
              <description>Data Mode Enable Bit</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Data mode Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Data mode Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>MSDAT</name>
              <description>Master or Slave in Data Mode Enable Control</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Master writes data to device</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Slave reads data from device</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>I2C_STATUS2</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>I2C_STATUS2</displayName>
          <description>I2C Status Register 2</description>
          <addressOffset>0x44</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000040</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WKIF</name>
              <description>Wake-up Interrupt Flag\nNote:This bit can be cleared by writing '1' toit.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Wake-up flag is inactive</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Wake-up flag is active</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>OVIF</name>
              <description>I2C Overrun Status Bit\nNote:This bit can be cleared by writing '1' toit.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The received buffer is not overrun when the TWOLVBUF = 1</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The received buffer is overrun when the TWOLVBUF = 1</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>URIF</name>
              <description>I2C Underrun Status Bit\nNote:This bit can be cleared by writing '1' toit.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The transmitted buffer is not underrun when the TWOLVBUF = 1</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The transmitted buffer is underrun when the TWOLVBUF = 1</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>WRSTSWK</name>
              <description>I2C Read/Write Status Bit in Address Wake-up Frame</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Write command is recorded on the address match wake-up frame</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Read command is recorded on the address match wake-up frame</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>FULL</name>
              <description>I2C Two Level Buffer Full</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>TX buffer no full when the TWOLVBUF = 1</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>TX buffer full when the TWOLVBUF = 1</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>EMPTY</name>
              <description>I2C Two Level Buffer Empty</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RX buffer is not empty when the TWOLVBUF = 1</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RX buffer is empty when the TWOLVBUF = 1</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BUSFREE</name>
              <description>Bus Free Status\nThe bus status in the controller.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>I2C's "Start" condition is detected on the bus</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Bus is free and released by "STOP" condition or the controller is disabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>I2C1</name>
      <description>I2C Register Map</description>
      <groupName>I2C</groupName>
      <baseAddress>0x40120000</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x0</offset>
        <size>0x20</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x28</offset>
        <size>0x8</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x40</offset>
        <size>0x8</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>I2C_CTL</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>I2C_CTL</displayName>
          <description>I2C Control Register</description>
          <addressOffset>0x0</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>I2CEN</name>
              <description>I2C Function EnableBit</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>I2C function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>I2C function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>AA</name>
              <description>Assert Acknowledge Control Bit</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>STO</name>
              <description>I2C STOP Control Bit\nIn Master mode, setting STO to transmit a STOP condition to bus then I2C controller will check the bus condition if a STOP condition is detected. This bit will be cleared by hardware automatically.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>STA</name>
              <description>I2C START Command\nSetting STA to logic 1 to enter Master mode, the I2C hardware sends a START or repeat START condition to bus when the bus is free.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SI</name>
              <description>I2C Status\nWhen a new state is present in the I2C_STATUS register, if the INTEN bit is set, the I2C interrupt is requested. It must write one by software to this bit after the INTSTS (I2C_INTSTS[0]) is set to 1 and the I2C protocol function will go ahead until the STOP is active or the I2CEN is disabled.\nNote:If software wants to skip clearing INTSTS (I2C_INTSTS[0]), it also can write 1 to SI bit and must set INTEN bit. That INTSTS (I2C_INTSTS[0]) wll be cleared when SI is cleared.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>I2C's Status disabled and the I2C protocol function will go ahead</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>I2C's Status active</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>INTEN</name>
              <description>Interrupt EnableBit</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>I2C interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>I2C interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>I2C_INTSTS</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>I2C_INTSTS</displayName>
          <description>I2C Interrupt Status Register</description>
          <addressOffset>0x4</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>INTSTS</name>
              <description>I2C STATUS's Interrupt Status\nWhen a new I2C state is present in the I2C_STATUS register, the INTSTS flag is set by hardware. If bit INTEN (I2C_CTL [7]) is set, the I2C interrupt is requested.This bit must be cleared by software writing '1' .\nNote:If software wants to skip clearing INTSTS, it can also write 1 to SI (I2C_CTL [4]) bit and must set INTEN (I2C_CTL [7]) bit. INISTS wll be cleared when SI is cleared.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TOIF</name>
              <description>Time-out Status\nNote:This bit can be cleared by writing '1' to it.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No Time-out flag</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Time-out flag active and it is set by hardware. It can interrupt CPU when INTEN bit is set</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>WKAKDONE</name>
              <description>Wake-up Address Frame Acknowledge Bit Done\nNote:This bit can be cleared by writing'1' toit.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The ACK bit cycle of address match frame is not done</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The ACK bit cycle of address match frame is done in power-down</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>I2C_STATUS</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>I2C_STATUS</displayName>
          <description>I2C Status Register</description>
          <addressOffset>0x8</addressOffset>
          <access>read-only</access>
          <resetValue>0x000000F8</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>STATUS</name>
              <description>I2C Status Bits (Read Only)</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>I2C_CLKDIV</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>I2C_CLKDIV</displayName>
          <description>I2C Clock Divided Register</description>
          <addressOffset>0xC</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DIVIDER</name>
              <description>I2C Clock DividedBits\nNote:The minimum value of I2C_CLKDIV is 4.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>I2C_TOCTL</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>I2C_TOCTL</displayName>
          <description>I2C Time-out Control Register</description>
          <addressOffset>0x10</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TOCEN</name>
              <description>Time-out Counter Enable Bit\nWhen this bit is set to enabled and clcok be stretched, the 14 bits time-out counter will start counting.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Time-out counter Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Time-out counter Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TOCDIV4</name>
              <description>Time-out Counter Input Clock Divider by 4\nWhen enabled, the time-out period is extended 4 times.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Time-out counter input clock divider by 4Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Time-out counter input clock divider by 4 Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>I2C_DAT</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>I2C_DAT</displayName>
          <description>I2C Data Register</description>
          <addressOffset>0x14</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DAT</name>
              <description>I2C Data\nBit [7:0] is located with the 8-bit transferred/received data of I2C serial port.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>I2C_ADDR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>I2C_ADDR0</displayName>
          <description>I2C Slave Address Register0</description>
          <addressOffset>0x18</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>GC</name>
              <description>General Call FunctionControl\nNote: Refer to Address Register section for more detailed information..</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>General Call Function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>General Call Function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ADDR</name>
              <description>I2C Salve Address Bits\nThe content of this register is irrelevant when the device is in Master mode. In the Slave mode, the seven most significant bits must be loaded with the device's own address. The device will react if either of the address is matched.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>7</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="I2C_ADDR0">
          <name>I2C_ADDR1</name>
          <displayName>I2C_ADDR1</displayName>
          <description>I2C Slave Address Register1</description>
          <addressOffset>0x1C</addressOffset>
       </register>
       <register>
          <name>I2C_ADDRMSK0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>I2C_ADDRMSK0</displayName>
          <description>I2C Slave Address Mask Register0</description>
          <addressOffset>0x28</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ADDRMSK</name>
              <description>I2C Slave Address Mask Bits\nI2C bus controllers support multiple address recognition with two address mask register. When the bit in the address mask register is set to one, it means the received corresponding address bit is don't-care. If the bit is set to zero, that means the received corresponding register bit should be exact the same as address register.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>7</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Mask disable (the received corresponding register bit should be exact the same as address register)</description>
                    <value>0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Mask enable (the received corresponding address bit is don't care)</description>
                    <value>1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="I2C_ADDRMSK0">
          <name>I2C_ADDRMSK1</name>
          <displayName>I2C_ADDRMSK1</displayName>
          <description>I2C Slave Address Mask Register1</description>
          <addressOffset>0x2C</addressOffset>
       </register>
       <register>
          <name>I2C_CTL2</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>I2C_CTL2</displayName>
          <description>I2C Control Register 2</description>
          <addressOffset>0x40</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WKUPEN</name>
              <description>I2C Wake-up Function EnableBit</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>I2C wake-up function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>I2C wake-up function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>OVIEN</name>
              <description>I2C Overrun Interrupt Control Bit</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Overrun event interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Send a interrupt to system when the TWOLVBUF bit is enabled and there is overrun event in received buffer</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>URIEN</name>
              <description>I2C Underrun Interrupt Control Bit</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Underrun event interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Send a interrupt to system when theTWOLVBUF bit is enabled and there is underrun event happened in transmitted buffer</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TWOLVBUF</name>
              <description>Two Level Buffer Enable Bit</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Two level bufferDisabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Two level bufferEnabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>NOSTRETCH</name>
              <description>I2C BuS Stretch</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The I2C SCL bus is stretched by hardware if the SI (I2C_CTL[4]) is not cleared</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The I2C SCL bus is not stretched by hardware if the SI is not cleared</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DATMODE</name>
              <description>Data Mode Enable Bit</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Data mode Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Data mode Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>MSDAT</name>
              <description>Master or Slave in Data Mode Enable Control</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Master writes data to device</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Slave reads data from device</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>I2C_STATUS2</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>I2C_STATUS2</displayName>
          <description>I2C Status Register 2</description>
          <addressOffset>0x44</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000040</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WKIF</name>
              <description>Wake-up Interrupt Flag\nNote:This bit can be cleared by writing '1' toit.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Wake-up flag is inactive</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Wake-up flag is active</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>OVIF</name>
              <description>I2C Overrun Status Bit\nNote:This bit can be cleared by writing '1' toit.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The received buffer is not overrun when the TWOLVBUF = 1</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The received buffer is overrun when the TWOLVBUF = 1</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>URIF</name>
              <description>I2C Underrun Status Bit\nNote:This bit can be cleared by writing '1' toit.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The transmitted buffer is not underrun when the TWOLVBUF = 1</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The transmitted buffer is underrun when the TWOLVBUF = 1</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>WRSTSWK</name>
              <description>I2C Read/Write Status Bit in Address Wake-up Frame</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Write command is recorded on the address match wake-up frame</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Read command is recorded on the address match wake-up frame</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>FULL</name>
              <description>I2C Two Level Buffer Full</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>TX buffer no full when the TWOLVBUF = 1</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>TX buffer full when the TWOLVBUF = 1</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>EMPTY</name>
              <description>I2C Two Level Buffer Empty</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RX buffer is not empty when the TWOLVBUF = 1</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RX buffer is empty when the TWOLVBUF = 1</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BUSFREE</name>
              <description>Bus Free Status\nThe bus status in the controller.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>I2C's "Start" condition is detected on the bus</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Bus is free and released by "STOP" condition or the controller is disabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>SPI0</name>
      <description>SPI Register Map</description>
      <groupName>SPI</groupName>
      <baseAddress>0x40030000</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x0</offset>
        <size>0x18</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x20</offset>
        <size>0x8</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x38</offset>
        <size>0x8</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x50</offset>
        <size>0x4</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>SPI_CTL</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SPI_CTL</displayName>
          <description>SPI Control Register</description>
          <addressOffset>0x0</addressOffset>
          <access>read-write</access>
          <resetValue>0x10003004</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>GOBUSY</name>
              <description>SPI Transfer Control Bit and Busy Status\nIf the FIFO mode is disabled, during the data transfer, this bit keeps the value of '1'. As the transfer is finished, this bit will be cleared automatically. Software can read this bit to check if the SPI is in busy status.\nIn FIFO mode, this bit will be controlled by hardware. Software should not modify this bit. In slave mode, this bit always returns 1 when software reads this register. In master mode, this bit reflects the busy or idle status of SPI.\nNote:\n1.When FIFO mode is disabled, all configurations should be set before writing "1" to the GOBUSY bit in the SPI_CTL register.\n2. When FIFO bit is disabled and the software uses TX or RX PDMA function to transfer data, this bit will be cleared after the PDMA controller finishes the data transfer.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Writing this bit "0" will stop data transfer if SPI is transferring</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>In Master mode, writing "1" to this bit will start the SPI data transfer; In Slave mode, writing '1' to this bit indicates that the slave is ready to communicate with a master</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RXNEG</name>
              <description>Receiveon Negative Edge\nNote: Refer to Edge section.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The received data is latched on the rising edge of SPI_SCLK</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The received data is latched on the falling edge of SPI_SCLK</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TXNEG</name>
              <description>Transmit on Negative Edge\nNote: Refer to Edge section.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The transmitted data output is changed on the rising edge of SPI_SCLK</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The transmitted data output is changed on the falling edge of SPI_SCLK</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DWIDTH</name>
              <description>Data Width\nThis field specifies how many bits can be transmitted / received in one transaction. The minimum bit length is 8 bits and can be up to 32 bits.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>5</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>32 bits are transmitted in one transaction</description>
                    <value>#00000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>8</name>
                    <description>8 bits are transmitted in one transaction</description>
                    <value>#01000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>9</name>
                    <description>9 bits are transmitted in one transaction</description>
                    <value>#01001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>10</name>
                    <description>10 bits are transmitted in one transaction</description>
                    <value>#01010</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>30</name>
                    <description>30 bits are transmitted in one transaction</description>
                    <value>#11110</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>31</name>
                    <description>31 bits are transmitted in one transaction</description>
                    <value>#11111</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>LSB</name>
              <description>Send LSB First\nNote: Refer to LSB first section.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The MSB, which bit of transmit/receive register depends on the setting of DWIDTH (SPI_CTL[7:3]), is transmitted/received first</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The LSB, bit 0 of the SPI_TX0/1, is sent first to the the SPI data output pin, and the first bit received from the SPI data input pin will be put in the LSB position of theRX register (SPI_RX0/1)</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CLKPOL</name>
              <description>Clock Polarity\nNote: Refer to Clock Parity section.</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The default level of SCLK is low</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The default level of SCLK is high</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SUSPITV</name>
              <description>Suspend Interval (Master Only)</description>
              <bitOffset>12</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>UNITIEN</name>
              <description>Unit Transfer Interrupt Enable Bit</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>SPI unit transfer interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>SPI unit transferinterrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SLAVE</name>
              <description>Slave Mode Selection\nNote: Refer to Slave Selection section</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>SPI controller set as Master mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>SPI controller set as Slave mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>REORDER</name>
              <description>Byte Reorder Function EnableBit\nNote: The suspend interval is defined in SUSPITV.Refer to Byte Reorder section.\nNote: Byte Suspend is only used in SPI Byte Reorder mode.</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Byte reorderfunction Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable byte reorder function and insert a byte suspend interval among each byte. The setting of DWIDTH must be configured as 00b ( 32 bits/ word)</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>FIFOM</name>
              <description>FIFO Mode EnableBit\nNote: Refer to FIFO Mode section.</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>FIFO mode Disabled (in Normal mode)</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>FIFO mode Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TWOBIT</name>
              <description>2-bit Transfer Mode Enable Bit\nRefer to Two Bit Transfer Mode section\nNote: automatically</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>2-bit transfer mode Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>2-bit transfer mode Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DUALDIR</name>
              <description>Dual I/O Mode Direction Control\nRefer to Dual I/O Mode section.</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Date read in the Dual I/O Mode function</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Data write in the Dual I/O Mode function.</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DUALIOEN</name>
              <description>Dual I/O Mode EnableBit\nRefer to Dual I/O Mode section.</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Dual I/O Mode function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Dual I/O Mode function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>WKSSEN</name>
              <description>Wake-up by Slave Select EnableBit\nNote: The Slave select wake-up function is only available in SPI Slave mode. When the system enters Power-down mode, the system can be wake-up from the SPI controller if this bit is enabled and there is any toggle on the SPI_SS port. After the system wake-up, this bit must be cleared by user to disable the wake-up requirement.</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Wake-up function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Wake-up function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>WKCLKEN</name>
              <description>Wake-up by SPI Clock EnableBit\nNote: When the system enters Power-down mode, the system can be wake-up from the SPI controller if this bit is enabled and there is any toggle on the SPI_CLK port. After the system wake-up, this bit must be cleared by user to disable the wake-up requirement.</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Wake-up function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Wake-up function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SPI_STATUS</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SPI_STATUS</displayName>
          <description>SPI Status Register</description>
          <addressOffset>0x4</addressOffset>
          <access>read-write</access>
          <resetValue>0x00008005</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RXEMPTY</name>
              <description>Receive FIFO Buffer Empty Indicator(Read Only)</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Received data FIFO is not empty in the FIFO mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Received data FIFO is empty in the FIFO mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>RXFULL</name>
              <description>Receive FIFO Buffer Full Indicator(Read Only)</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Received data FIFO is not full in FIFO mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Received data FIFO is full in the FIFO mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>TXEMPTY</name>
              <description>Transmit FIFO Buffer Empty Indicator(Read Only)</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Transmitted data FIFO is not empty in the FIFO mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Transmitted data FIFO is empty in the FIFO mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>TXFULL</name>
              <description>Transmit FIFO Buffer Full Indicator (Read Only)</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Transmitted data FIFO is not full in the FIFO mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Transmitted data FIFO is full in the FIFO mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>LTRIGF</name>
              <description>Level Trigger Accomplish Flag(Read Only)\nIn Slave mode, this bit indicates whether the received bit number meets the requirement or not after the current transaction done.\nNote: This bit is READ only. As the software sets the GOBUSY bit to 1, the LTRIGF will be cleared to 0 after 4 SPI peripheral clock periods plus 1 system clock period. In FIFO mode, this bit is unmeaning.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The transferred bit length of one transaction does not meet the specified requirement</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The transferred bit length meets the specified requirement which defined in DWIDTH</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>SLVSTAIF</name>
              <description>Slave Start Interrupt Flag\nIt is used to dedicate that the transfer has started in Slave mode with no slave select.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Slave started transfer no active</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Transfer has started in Slave mode with no slave select. It is automatically cleared by transfer done or writing '1'</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>UNITIF</name>
              <description>Unit Transfer Interrupt Flag\nNote 2: This bitcan be cleared by writing "1" to it.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No transaction has been finished since this bit was cleared to 0.\nTransfer is not finished yet</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>SPI controller has finished one unit transfer.\nTransfer is done. The interrupt is requested when the UNITIEN(SPI_CTL[17]) bit is enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RXTHIF</name>
              <description>RX FIFO Threshold Interrupt Flag(Read Only)</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RX valid data counts small or equal than RXTH (SPI_FIFOCTL[27:24])</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RX valid data counts bigger than RXTH</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>RXOVIF</name>
              <description>Receive FIFO Overrun Interrupt Flag\nNote 1: If SPI receives data when RX FIFO is full, this bit will set to 1, and the received data will be dropped.\nNote 2: This bit will be cleared by writing 1 to it.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No FIFO over run</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Receive FIFO over run</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TXTHIF</name>
              <description>Transmit FIFO Threshold Interrupt Flag(Read Only)</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>TX valid data counts bigger than TXTH (SPI_FIFOCTL[31:28])</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>TX valid data counts small or equal than TXTH</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>RXTOIF</name>
              <description>Receive Time-outInterrupt Flag\nRefer to Time Out section.\nNote: This bit will be cleared by writing 1 to it.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>There is not time-out event on the received buffer</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Time out event active in RX FIFO is not empty</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SLVTOIF</name>
              <description>Slave Time-out Interrupt Flag\nIf SLVTOIEN (SPI_SSCTL[6]) is set to 1, this bit will be asserted when slave time-out event occur. Software can clear this bit by setting RXFBCLR (SPI_FIFOCTL[0]) or writing 1 to clear this bit.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Slave time-out does not occur yet</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Slave time-out has occurred</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SLVTXSKE</name>
              <description>Slave Mode Transmit Skew Buffer Empty Status\nThis bit indicates the empty status of transmit skew buffer which is used in Slave mode.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXCNT</name>
              <description>Receive FIFO Data Counts (Read Only)\nThis bit field indicates the valid data count of receive FIFO buffer.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TXCNT</name>
              <description>Transmit FIFO Data Counts (Read Only)\nThis bit field indicates the valid data count of transmit FIFO buffer.</description>
              <bitOffset>20</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>WKSSIF</name>
              <description>Wake-up by Slave Select Interrupt Flag\nWhen chip is woken up from Power-down mode by the toggle event on SPI_SS port, this bit is set to 1. This bit can be cleared by writing '1' to it.</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>WKCLKIF</name>
              <description>Wake-up by SPI Clock Interrupt Flag\nWhen chip is woken up from Power-down mode by the toggle event on SPI_CLK port, this bit is set to 1. This bit can be cleared by writing '1' to it.</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SPI_CLKDIV</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SPI_CLKDIV</displayName>
          <description>SPI Clock Divider Register</description>
          <addressOffset>0x8</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DIVIDER</name>
              <description>Clock Divider\nThe value is the 1th frequency divider of the PCLK to generate the serial clock of SPI_SCLK. The desired frequency is obtained according to the following equation:\nWhere\n is the SPI peripheral clock source. It is defined in the CLK_SEL2[21:20] in Clock control section (CLK_BA + 0x18).</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SPI_SSCTL</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SPI_SSCTL</displayName>
          <description>SPI Slave Select Control Register</description>
          <addressOffset>0xC</addressOffset>
          <access>read-write</access>
          <resetValue>0x24000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SS</name>
              <description>Slave SelectionControl (Master Only)\nIf AUTOSS bit (SPI_SSCTL[3]) is cleared, writing "1" to SS[0] (SPI_CTL[0]) bit sets the SPI_SS0 line to an active state and writing "0" sets the line back to inactive state(the same as SPI_CTL[1] for SPI_SS1).\nNote:\n1. This interface can only drive one device/slave at a given time. Therefore, the slaves select of the selected device must be set to its active level before starting any read or write transfer.\n2. SPI_SS0 is also defined as device/slave select input in Slave mode. And that the slave select input must be driven by edge active trigger which level depend on the SSACTPOL setting, otherwise the SPI slave core will go into dead path until the edge active triggers again or reset the SPI core by software.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Both SPI_SS1 and SPI_SS0 are inactive</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>SPI_SS1 is inactive, SPI_SS0 is active.\nSPI_SS1 is inactive, SPI_SS0 is active on the duration of transaction</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>SPI_SS1 is active, SPI_SS0 is inactive.\nSPI_SS1 is active on the duration of transaction, SPI_SS0 is inactive</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Both SPI_SS1 and SPI_SS0 are active..\nBoth SPI_SS1 and SPI_SS0 are active on the duration of transaction</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SSACTPOL</name>
              <description>Slave Selection Active Polarity\nIt defines the active polarity of slave selection signal (SPI_SS[1:0]).</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The SPI_SS slave select signal is active Low</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The SPI_SS slave select signal is active High</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>AUTOSS</name>
              <description>Automatic Slave Selection Function Enable Bit (Master Only)</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>If this bit is set as "0", slave select signals are asserted and de-asserted by setting and clearing related bits in SS[1:0] (SPI_CTL[1:0])</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>If this bit is set as "1", SPI_SS0 and SPI_SS1 signals are generated automatically. It means that device/slave select signal, which is set in SS[1:0] (SPI_CTL[1:0]) is asserted by the SPI controller when transmit/receive is started, and is de-asserted after each transaction is done</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SSLTRIG</name>
              <description>Slave Select Level Trigger Control</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The input slave select signal is edge-trigger</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The slave select signal will be level-trigger. It depends on SSACTPOL to decide the signal is active low or active high</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SLV3WIRE</name>
              <description>Slave 3-wire Mode Enable Bit\nThis bit is used to ignore the slave select signal in Slave mode. The SPI controller can work with 3-wire interface including SPI_CLK, SPI_MISO, and SPI_MOSI when it is set as a slave device.\nNote 1:Refer to No Slave Select Mode.\nNote 2: In no slave select signal mode, hardware will set the SSLTRIG (SPI_SSCTL[4]) as "1" automatically.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The controller is 4-wire bi-direction interface</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The controller is 3-wire bi-direction interface in Slave mode. When this bit is set as 1, the controller start to transmit/receive data after the GOBUSY bit active and the SPI clock input</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SLVTOIEN</name>
              <description>Slave Time-out Interrupt Enable Bit\nThis bit is used to enable the slave time-out function in slave mode and there will be an interrupt if slave time-out event occur</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Slave time-out function and interrupt both Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Slave time-out function and interrupt both Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SLVABORT</name>
              <description>Abort in Slave Mode with No Slave Selected\nRefer to No Slave Select Mode.\nNote: It is auto cleared to "0" by hardware when the abort event is active.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No force the slave abort</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Force the current transfer done in no slave select mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SSTAIEN</name>
              <description>Slave Start Interrupt EnableBit\nRefer to No Slave Select Mode.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Transfer start interrupt Disabled in no slave select mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Transaction start interrupt Enabled in no slave select mode. It is cleared when the current transfer done or the SLVSTAIF bit cleared (write 1 clear)</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SSINAIEN</name>
              <description>Slave Select Inactive Interrupt Enable Bit\nIt is used to enable the interrupt when the transfer has done in slave mode.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No any interrupt, even there is slave select inactive event</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>There is interrupt event when the slave select becomes inactive from active condition. It is used to inform the user to know that the transaction has finished and the slave select into the inactive state</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SLVTOCNT</name>
              <description>Slave Mode Time-out Period\nIn Slave mode, these bits indicate the time-out period when there is bus clock input during slave select active. The clock source of the time-out counter is Slave peripheral clock. If the value is 0, it indicates the slave mode time-out function is disabled.</description>
              <bitOffset>20</bitOffset>
              <bitWidth>10</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SPI_RX0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SPI_RX0</displayName>
          <description>SPI Receive Data FIFO Register 0</description>
          <addressOffset>0x10</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RX</name>
              <description>Receive Data Register (Read Only)\nThe received data can be read on it. If the FIFO bit is set as 1, the user also checks the RXEMPTY, SPI_STATUS[0], to check if there is any more received data or not.\nNote:The SPI_RX1 is used only in TWOBIT bit (SPI_CTL[22])is set 1. The first channel's received data shall be read from SPI_RX0 and the second channel's received data shall be read from SPI_RX1 in two-bit mode. SPI_RX0 shall be read first in TWOBIT mode.\nIn FIFO and two-bit mode, the first read back data in SPI_RX0 is the first channel data and the second read back data in SPI_RX0 is the second channel data.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="SPI_RX0">
          <name>SPI_RX1</name>
          <displayName>SPI_RX1</displayName>
          <description>SPI Receive Data FIFO Register 1</description>
          <addressOffset>0x14</addressOffset>
       </register>
       <register>
          <name>SPI_TX0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SPI_TX0</displayName>
          <description>SPI Transmit Data FIFO Register 0</description>
          <addressOffset>0x20</addressOffset>
          <access>write-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TX</name>
              <description>Transmit Data Register (Write Only)\nThe Data Transmit Registers hold the data to be transmitted in the next transfer. The number of valid bits depends on the setting of transmit bit length field of the SPI_CTL register.\nFor example, if DWIDTH is set to 0x8, the bit SPI_TX[7:0] will be transmitted in next transfer. If DWIDTH is set to 0x0, the SPI controller will perform a 32-bit transfer.\nNote:\n1. The SPI_TX1 is used only when TWOBIT bit (SPI_CTL[22])is set 1. The first channel's transmitted data shall be written into SPI_TX0 and the second channel's transmitted data shall be written into SPI_TX1 in two-bit mode. SPI_TX0 shall be written first in TWOBIT mode.\nIn FIFO and two-bit mode, the first written into data in SPI_TX0 is the first channel's transmitted data and the second written data in SPI_TX1 is the second channel's transmitted data.\n2.If the SPI controller operates as slave device and FIFO mode is disabled, software must update the transmit data register before setting the GOBUSY bit to 1.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="SPI_TX0">
          <name>SPI_TX1</name>
          <displayName>SPI_TX1</displayName>
          <description>SPI Transmit Data FIFO Register 1</description>
          <addressOffset>0x24</addressOffset>
       </register>
       <register>
          <name>SPI_PDMACTL</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SPI_PDMACTL</displayName>
          <description>SPI PDMA Control Register</description>
          <addressOffset>0x38</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TXPDMAEN</name>
              <description>Transmit PDMA Enable Bit\nRefer to PDMA section for more detailed information.\nSPI_CTLNote:\n1. Two transaction need minimal 18 APB clock + 8 SPI peripheral clocks suspend interval in master mode for edge mode and 18 APB clock + 9.5 SPI peripheral clocks for level mode.\n2. If the 2-bit function is enabled, the requirement timing shall append 18 APB clock based on the above clock period.\nHardware will clear this bit to 0 automatically after PDMA transfer is done.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Transmit PDMA function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Transmit PDMA function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RXPDMAEN</name>
              <description>Receiving PDMA EnableBit\nRefer to PDMA section for more detail information.\nNote:\nHardware will clear this bit to 0 automatically after PDMA transfer done.\nIn Slave mode and the FIFO bit is disabled, if the receive PDMA is enabled but the transmit PDMA is disabled, the minimal suspend interval between two successive  transactions input is need to be larger than 9 SPI peripheral clock + 4 APB clock for edge mode and 9.5 SPI peripheral clock + 4 APB clock.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Receiver PDMA function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Receiver PDMA function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PDMARST</name>
              <description>PDMA Reset\nIt is used to reset the SPI PDMA function into default state.\nNote:It is auto cleared to "0" after the reset function has done.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>After reset PDMA function or in normal operation</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reset PDMA function</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SPI_FIFOCTL</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SPI_FIFOCTL</displayName>
          <description>SPI FIFO Control Register</description>
          <addressOffset>0x3C</addressOffset>
          <access>read-write</access>
          <resetValue>0x44000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RXFBCLR</name>
              <description>Receive FIFO Buffer Clear\nNote:This bit is used to clear the receiver counter in FIFO Mode. This bit can be written "1" to clear the receiver counter and this bit will be cleared to "0" automatically after clearing receiving counter. After the clear operation, the flag of RXEMPTY in SPI_STATUS[0] will be set to "1".</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No clear the received FIFO</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Clear the received FIFO</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TXFBCLR</name>
              <description>Transmit FIFO Buffer Clear\nNote:This bit is used to clear the transmit counter in FIFO Mode. This bit can be written "1" to clear the transmitting counter and this bit will be cleared to "0" automatically after clearing transmitting counter. After the clear operation, the flag of TXEMPTY in SPI_STATUS[2] will be set to "1".</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Not clear the transmitted FIFO</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Clear the transmitted FIFO</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RXTHIEN</name>
              <description>Receive Threshold Interrupt Enable Bit</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RX threshold interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RX threshold interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TXTHIEN</name>
              <description>Transmit Threshold Interrupt Enable Bit</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>TX threshold interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>TX threshold interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RXOVIEN</name>
              <description>ReceiveFIFO Overrun Interrupt Enable Bit</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RXFIFO overrun interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RX FIFO overrun interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RXTOIEN</name>
              <description>RX Read Time Out Interrupt Enable Bit</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RXread Time-out Interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RX read Time-out Interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RXTH</name>
              <description>Received FIFO Threshold\nIf RX valid data counts are greater than RXTH, RXTHIF (SPI_STATUS[8])will be set to 1..</description>
              <bitOffset>24</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TXTH</name>
              <description>Transmit FIFO Threshold\nIf TX valid data counts are smaller than or equal to TXTH, TXTHIF(SPI_STATUS[10])will be set to 1.</description>
              <bitOffset>28</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SPI_INTERNAL</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SPI_INTERNAL</displayName>
          <description>SPI INTERNAL Register</description>
          <addressOffset>0x50</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
          </fields>
       </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>SPI1</name>
      <description>SPI Register Map</description>
      <groupName>SPI</groupName>
      <baseAddress>0x40130000</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x0</offset>
        <size>0x18</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x20</offset>
        <size>0x8</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x38</offset>
        <size>0x8</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x50</offset>
        <size>0x4</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>SPI_CTL</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SPI_CTL</displayName>
          <description>SPI Control Register</description>
          <addressOffset>0x0</addressOffset>
          <access>read-write</access>
          <resetValue>0x10003004</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>GOBUSY</name>
              <description>SPI Transfer Control Bit and Busy Status\nIf the FIFO mode is disabled, during the data transfer, this bit keeps the value of '1'. As the transfer is finished, this bit will be cleared automatically. Software can read this bit to check if the SPI is in busy status.\nIn FIFO mode, this bit will be controlled by hardware. Software should not modify this bit. In slave mode, this bit always returns 1 when software reads this register. In master mode, this bit reflects the busy or idle status of SPI.\nNote:\n1.When FIFO mode is disabled, all configurations should be set before writing "1" to the GOBUSY bit in the SPI_CTL register.\n2. When FIFO bit is disabled and the software uses TX or RX PDMA function to transfer data, this bit will be cleared after the PDMA controller finishes the data transfer.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Writing this bit "0" will stop data transfer if SPI is transferring</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>In Master mode, writing "1" to this bit will start the SPI data transfer; In Slave mode, writing '1' to this bit indicates that the slave is ready to communicate with a master</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RXNEG</name>
              <description>Receiveon Negative Edge\nNote: Refer to Edge section.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The received data is latched on the rising edge of SPI_SCLK</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The received data is latched on the falling edge of SPI_SCLK</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TXNEG</name>
              <description>Transmit on Negative Edge\nNote: Refer to Edge section.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The transmitted data output is changed on the rising edge of SPI_SCLK</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The transmitted data output is changed on the falling edge of SPI_SCLK</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DWIDTH</name>
              <description>Data Width\nThis field specifies how many bits can be transmitted / received in one transaction. The minimum bit length is 8 bits and can be up to 32 bits.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>5</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>32 bits are transmitted in one transaction</description>
                    <value>#00000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>8</name>
                    <description>8 bits are transmitted in one transaction</description>
                    <value>#01000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>9</name>
                    <description>9 bits are transmitted in one transaction</description>
                    <value>#01001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>10</name>
                    <description>10 bits are transmitted in one transaction</description>
                    <value>#01010</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>30</name>
                    <description>30 bits are transmitted in one transaction</description>
                    <value>#11110</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>31</name>
                    <description>31 bits are transmitted in one transaction</description>
                    <value>#11111</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>LSB</name>
              <description>Send LSB First\nNote: Refer to LSB first section.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The MSB, which bit of transmit/receive register depends on the setting of DWIDTH (SPI_CTL[7:3]), is transmitted/received first</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The LSB, bit 0 of the SPI_TX0/1, is sent first to the the SPI data output pin, and the first bit received from the SPI data input pin will be put in the LSB position of theRX register (SPI_RX0/1)</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CLKPOL</name>
              <description>Clock Polarity\nNote: Refer to Clock Parity section.</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The default level of SCLK is low</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The default level of SCLK is high</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SUSPITV</name>
              <description>Suspend Interval (Master Only)</description>
              <bitOffset>12</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>UNITIEN</name>
              <description>Unit Transfer Interrupt Enable Bit</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>SPI unit transfer interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>SPI unit transferinterrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SLAVE</name>
              <description>Slave Mode Selection\nNote: Refer to Slave Selection section</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>SPI controller set as Master mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>SPI controller set as Slave mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>REORDER</name>
              <description>Byte Reorder Function EnableBit\nNote: The suspend interval is defined in SUSPITV.Refer to Byte Reorder section.\nNote: Byte Suspend is only used in SPI Byte Reorder mode.</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Byte reorderfunction Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable byte reorder function and insert a byte suspend interval among each byte. The setting of DWIDTH must be configured as 00b ( 32 bits/ word)</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>FIFOM</name>
              <description>FIFO Mode EnableBit\nNote: Refer to FIFO Mode section.</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>FIFO mode Disabled (in Normal mode)</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>FIFO mode Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TWOBIT</name>
              <description>2-bit Transfer Mode Enable Bit\nRefer to Two Bit Transfer Mode section\nNote: automatically</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>2-bit transfer mode Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>2-bit transfer mode Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DUALDIR</name>
              <description>Dual I/O Mode Direction Control\nRefer to Dual I/O Mode section.</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Date read in the Dual I/O Mode function</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Data write in the Dual I/O Mode function</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DUALIOEN</name>
              <description>Dual I/O Mode EnableBit\nRefer to Dual I/O Mode section.</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Dual I/O Mode function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Dual I/O Mode function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>WKSSEN</name>
              <description>Wake-up by Slave Select EnableBit\nNote: The Slave select wake-up function is only available in SPI Slave mode. When the system enters Power-down mode, the system can be wake-up from the SPI controller if this bit is enabled and there is any toggle on the SPI_SS port. After the system wake-up, this bit must be cleared by user to disable the wake-up requirement.</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Wake-up function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Wake-up function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>WKCLKEN</name>
              <description>Wake-up by SPI Clock EnableBit\nNote: When the system enters Power-down mode, the system can be wake-up from the SPI controller if this bit is enabled and there is any toggle on the SPI_CLK port. After the system wake-up, this bit must be cleared by user to disable the wake-up requirement.</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Wake-up function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Wake-up function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SPI_STATUS</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SPI_STATUS</displayName>
          <description>SPI Status Register</description>
          <addressOffset>0x4</addressOffset>
          <access>read-write</access>
          <resetValue>0x00008005</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RXEMPTY</name>
              <description>Receive FIFO Buffer Empty Indicator(Read Only)</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Received data FIFO is not empty in the FIFO mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Received data FIFO is empty in the FIFO mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>RXFULL</name>
              <description>Receive FIFO Buffer Full Indicator(Read Only)</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Received data FIFO is not full in FIFO mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Received data FIFO is full in the FIFO mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>TXEMPTY</name>
              <description>Transmit FIFO Buffer Empty Indicator(Read Only)</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Transmitted data FIFO is not empty in the FIFO mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Transmitted data FIFO is empty in the FIFO mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>TXFULL</name>
              <description>Transmit FIFO Buffer Full Indicator (Read Only)</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Transmitted data FIFO is not full in the FIFO mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Transmitted data FIFO is full in the FIFO mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>LTRIGF</name>
              <description>Level Trigger Accomplish Flag(Read Only)\nIn Slave mode, this bit indicates whether the received bit number meets the requirement or not after the current transaction done.\nNote: This bit is READ only. As the software sets the GOBUSY bit to 1, the LTRIGF will be cleared to 0 after 4 SPI peripheral clock periods plus 1 system clock period. In FIFO mode, this bit is unmeaning.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The transferred bit length of one transaction does not meet the specified requirement</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The transferred bit length meets the specified requirement which defined in DWIDTH</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>SLVSTAIF</name>
              <description>Slave Start Interrupt Flag\nIt is used to dedicate that the transfer has started in Slave mode with no slave select.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Slave started transfer no active</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Transfer has started in Slave mode with no slave select. It is automatically cleared by transfer done or writing '1'</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>UNITIF</name>
              <description>Unit Transfer Interrupt Flag\nNote 2: This bitcan be cleared by writing "1" to it.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No transaction has been finished since this bit was cleared to 0.\nTransfer is not finished yet</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>SPI controller has finished one unit transfer.\nTransfer is done. The interrupt is requested when the UNITIEN(SPI_CTL[17]) bit is enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RXTHIF</name>
              <description>RX FIFO Threshold Interrupt Flag(Read Only)</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RX valid data counts small or equal than RXTH (SPI_FIFOCTL[27:24])</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RX valid data counts bigger than RXTH</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>RXOVIF</name>
              <description>Receive FIFO Overrun Interrupt Flag\nNote 1: If SPI receives data when RX FIFO is full, this bit will set to 1, and the received data will be dropped.\nNote 2: This bit will be cleared by writing 1 to it.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No FIFO over run</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Receive FIFO over run</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TXTHIF</name>
              <description>Transmit FIFO Threshold Interrupt Flag(Read Only)</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>TX valid data counts bigger than TXTH (SPI_FIFOCTL[31:28])</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>TX valid data counts small or equal than TXTH</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>RXTOIF</name>
              <description>Receive Time-outInterrupt Flag\nRefer to Time Out section.\nNote: This bit will be cleared by writing 1 to it.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>There is not time-out event on the received buffer</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Time out event active in RX FIFO is not empty</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SLVTOIF</name>
              <description>Slave Time-out Interrupt Flag\nIf SLVTOIEN (SPI_SSCTL[6]) is set to 1, this bit will be asserted when slave time-out event occur. Software can clear this bit by setting RXFBCLR (SPI_FIFOCTL[0]) or writing 1 to clear this bit.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Slave time-out does not occur yet</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Slave time-out has occurred</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SLVTXSKE</name>
              <description>Slave Mode Transmit Skew Buffer Empty Status\nThis bit indicates the empty status of transmit skew buffer which is used in Slave mode.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXCNT</name>
              <description>Receive FIFO Data Counts (Read Only)\nThis bit field indicates the valid data count of receive FIFO buffer.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TXCNT</name>
              <description>Transmit FIFO Data Counts (Read Only)\nThis bit field indicates the valid data count of transmit FIFO buffer.</description>
              <bitOffset>20</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>WKSSIF</name>
              <description>Wake-up by Slave Select Interrupt Flag\nWhen chip is woken up from Power-down mode by the toggle event on SPI_SS port, this bit is set to 1. This bit can be cleared by writing '1' to it.</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>WKCLKIF</name>
              <description>Wake-up by SPI Clock Interrupt Flag\nWhen chip is woken up from Power-down mode by the toggle event on SPI_CLK port, this bit is set to 1. This bit can be cleared by writing '1' to it.</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SPI_CLKDIV</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SPI_CLKDIV</displayName>
          <description>SPI Clock Divider Register</description>
          <addressOffset>0x8</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DIVIDER</name>
              <description>Clock Divider\nThe value is the 1th frequency divider of the PCLK to generate the serial clock of SPI_SCLK. The desired frequency is obtained according to the following equation:\nWhere\n is the SPI peripheral clock source. It is defined in the CLK_SEL2[21:20] in Clock control section (CLK_BA + 0x18).</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SPI_SSCTL</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SPI_SSCTL</displayName>
          <description>SPI Slave Select Control Register</description>
          <addressOffset>0xC</addressOffset>
          <access>read-write</access>
          <resetValue>0x24000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SS</name>
              <description>Slave SelectionControl (Master Only)\nIf AUTOSS bit (SPI_SSCTL[3]) is cleared, writing "1" to SS[0] (SPI_CTL[0]) bit sets the SPI_SS0 line to an active state and writing "0" sets the line back to inactive state(the same as SPI_CTL[1] for SPI_SS1).\nNote:\n1. This interface can only drive one device/slave at a given time. Therefore, the slaves select of the selected device must be set to its active level before starting any read or write transfer.\n2. SPI_SS0 is also defined as device/slave select input in Slave mode. And that the slave select input must be driven by edge active trigger which level depend on the SSACTPOL setting, otherwise the SPI slave core will go into dead path until the edge active triggers again or reset the SPI core by software.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Both SPI_SS1 and SPI_SS0 are inactive</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>SPI_SS1 is inactive, SPI_SS0 is active.\nSPI_SS1 is inactive, SPI_SS0 is active on the duration of transaction</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>SPI_SS1 is active, SPI_SS0 is inactive.\nSPI_SS1 is active on the duration of transaction, SPI_SS0 is inactive</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Both SPI_SS1 and SPI_SS0 are active..\nBoth SPI_SS1 and SPI_SS0 are active on the duration of transaction</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SSACTPOL</name>
              <description>Slave Selection Active Polarity\nIt defines the active polarity of slave selection signal (SPI_SS[1:0]).</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The SPI_SS slave select signal is active Low</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The SPI_SS slave select signal is active High</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>AUTOSS</name>
              <description>Automatic Slave Selection Function Enable Bit (Master Only)</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>If this bit is set as "0", slave select signals are asserted and de-asserted by setting and clearing related bits in SS[1:0] (SPI_CTL[1:0])</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>If this bit is set as "1", SPI_SS0 and SPI_SS1 signals are generated automatically. It means that device/slave select signal, which is set in SS[1:0] (SPI_CTL[1:0]) is asserted by the SPI controller when transmit/receive is started, and is de-asserted after each transaction is done</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SSLTRIG</name>
              <description>Slave Select Level Trigger Control</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The input slave select signal is edge-trigger</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The slave select signal will be level-trigger. It depends on SSACTPOL to decide the signal is active low or active high</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SLV3WIRE</name>
              <description>Slave 3-wire Mode Enable Bit\nThis bit is used to ignore the slave select signal in Slave mode. The SPI controller can work with 3-wire interface including SPI_CLK, SPI_MISO, and SPI_MOSI when it is set as a slave device.\nNote 1:Refer to No Slave Select Mode.\nNote 2: In no slave select signal mode, hardware will set the SSLTRIG (SPI_SSCTL[4]) as "1" automatically.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The controller is 4-wire bi-direction interface</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The controller is 3-wire bi-direction interface in Slave mode. When this bit is set as 1, the controller start to transmit/receive data after the GOBUSY bit active and the SPI clock input</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SLVTOIEN</name>
              <description>Slave Time-out Interrupt Enable Bit\nThis bit is used to enable the slave time-out function in slave mode and there will be an interrupt if slave time-out event occur</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Slave time-out function and interrupt both Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Slave time-out function and interrupt both Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SLVABORT</name>
              <description>Abort in Slave Mode with No Slave Selected\nRefer to No Slave Select Mode.\nNote: It is auto cleared to "0" by hardware when the abort event is active.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No force the slave abort</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Force the current transfer done in no slave select mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SSTAIEN</name>
              <description>Slave Start Interrupt EnableBit\nRefer to No Slave Select Mode.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Transfer start interrupt Disabled in no slave select mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Transaction start interrupt Enabled in no slave select mode. It is cleared when the current transfer done or the SLVSTAIF bit cleared (write 1 clear)</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SSINAIEN</name>
              <description>Slave Select Inactive Interrupt Enable Bit\nIt is used to enable the interrupt when the transfer has done in slave mode.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No any interrupt, even there is slave select inactive event</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>There is interrupt event when the slave select becomes inactive from active condition. It is used to inform the user to know that the transaction has finished and the slave select into the inactive state</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SLVTOCNT</name>
              <description>Slave Mode Time-out Period\nIn Slave mode, these bits indicate the time-out period when there is bus clock input during slave select active. The clock source of the time-out counter is Slave peripheral clock. If the value is 0, it indicates the slave mode time-out function is disabled.</description>
              <bitOffset>20</bitOffset>
              <bitWidth>10</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SPI_RX0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SPI_RX0</displayName>
          <description>SPI Receive Data FIFO Register 0</description>
          <addressOffset>0x10</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RX</name>
              <description>Receive Data Register (Read Only)\nThe received data can be read on it. If the FIFO bit is set as 1, the user also checks the RXEMPTY, SPI_STATUS[0], to check if there is any more received data or not.\nNote:The SPI_RX1 is used only in TWOBIT bit (SPI_CTL[22])is set 1. The first channel's received data shall be read from SPI_RX0 and the second channel's received data shall be read from SPI_RX1 in two-bit mode. SPI_RX0 shall be read first in TWOBIT mode.\nIn FIFO and two-bit mode, the first read back data in SPI_RX0 is the first channel data and the second read back data in SPI_RX0 is the second channel data.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="SPI_RX0">
          <name>SPI_RX1</name>
          <displayName>SPI_RX1</displayName>
          <description>SPI Receive Data FIFO Register 1</description>
          <addressOffset>0x14</addressOffset>
       </register>
       <register>
          <name>SPI_TX0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SPI_TX0</displayName>
          <description>SPI Transmit Data FIFO Register 0</description>
          <addressOffset>0x20</addressOffset>
          <access>write-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TX</name>
              <description>Transmit Data Register (Write Only)\nThe Data Transmit Registers hold the data to be transmitted in the next transfer. The number of valid bits depends on the setting of transmit bit length field of the SPI_CTL register.\nFor example, if DWIDTH is set to 0x8, the bit SPI_TX[7:0] will be transmitted in next transfer. If DWIDTH is set to 0x0, the SPI controller will perform a 32-bit transfer.\nNote:\n1. The SPI_TX1 is used only when TWOBIT bit (SPI_CTL[22])is set 1. The first channel's transmitted data shall be written into SPI_TX0 and the second channel's transmitted data shall be written into SPI_TX1 in two-bit mode. SPI_TX0 shall be written first in TWOBIT mode.\nIn FIFO and two-bit mode, the first written into data in SPI_TX0 is the first channel's transmitted data and the second written data in SPI_TX1 is the second channel's transmitted data.\n2.If the SPI controller operates as slave device and FIFO mode is disabled, software must update the transmit data register before setting the GOBUSY bit to 1.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="SPI_TX0">
          <name>SPI_TX1</name>
          <displayName>SPI_TX1</displayName>
          <description>SPI Transmit Data FIFO Register 1</description>
          <addressOffset>0x24</addressOffset>
       </register>
       <register>
          <name>SPI_PDMACTL</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SPI_PDMACTL</displayName>
          <description>SPI PDMA Control Register</description>
          <addressOffset>0x38</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TXPDMAEN</name>
              <description>Transmit PDMA Enable Bit\nRefer to PDMA section for more detailed information.\nSPI_CTLNote:\n1. Two transaction need minimal 18 APB clock + 8 SPI peripheral clocks suspend interval in master mode for edge mode and 18 APB clock + 9.5 SPI peripheral clocks for level mode.\n2. If the 2-bit function is enabled, the requirement timing shall append 18 APB clock based on the above clock period.\nHardware will clear this bit to 0 automatically after PDMA transfer is done.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Transmit PDMA function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Transmit PDMA function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RXPDMAEN</name>
              <description>Receiving PDMA EnableBit\nRefer to PDMA section for more detail information.\nNote:\nHardware will clear this bit to 0 automatically after PDMA transfer done.\nIn Slave mode and the FIFO bit is disabled, if the receive PDMA is enabled but the transmit PDMA is disabled, the minimal suspend interval between two successive  transactions input is need to be larger than 9 SPI peripheral clock + 4 APB clock for edge mode and 9.5 SPI peripheral clock + 4 APB clock.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Receiver PDMA function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Receiver PDMA function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PDMARST</name>
              <description>PDMA Reset\nIt is used to reset the SPI PDMA function into default state.\nNote:It is auto cleared to "0" after the reset function has done.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>After reset PDMA function or in normal operation</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reset PDMA function</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SPI_FIFOCTL</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SPI_FIFOCTL</displayName>
          <description>SPI FIFO Control Register</description>
          <addressOffset>0x3C</addressOffset>
          <access>read-write</access>
          <resetValue>0x44000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RXFBCLR</name>
              <description>Receive FIFO Buffer Clear\nNote:This bit is used to clear the receiver counter in FIFO Mode. This bit can be written "1" to clear the receiver counter and this bit will be cleared to "0" automatically after clearing receiving counter. After the clear operation, the flag of RXEMPTY in SPI_STATUS[0] will be set to "1".</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No clear the received FIFO</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Clear the received FIFO</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TXFBCLR</name>
              <description>Transmit FIFO Buffer Clear\nNote:This bit is used to clear the transmit counter in FIFO Mode. This bit can be written "1" to clear the transmitting counter and this bit will be cleared to "0" automatically after clearing transmitting counter. After the clear operation, the flag of TXEMPTY in SPI_STATUS[2] will be set to "1".</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Not clear the transmitted FIFO</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Clear the transmitted FIFO</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RXTHIEN</name>
              <description>Receive Threshold Interrupt Enable Bit</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RX threshold interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RX threshold interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TXTHIEN</name>
              <description>Transmit Threshold Interrupt Enable Bit</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>TX threshold interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>TX threshold interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RXOVIEN</name>
              <description>ReceiveFIFO Overrun Interrupt Enable Bit</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RXFIFO overrun interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RX FIFO overrun interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RXTOIEN</name>
              <description>RX Read Time Out Interrupt Enable Bit</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RXread Time-out Interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RX read Time-out Interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RXTH</name>
              <description>Received FIFO Threshold\nIf RX valid data counts are greater than RXTH, RXTHIF (SPI_STATUS[8])will be set to 1..</description>
              <bitOffset>24</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TXTH</name>
              <description>Transmit FIFO Threshold\nIf TX valid data counts are smaller than or equal to TXTH, TXTHIF(SPI_STATUS[10])will be set to 1.</description>
              <bitOffset>28</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SPI_INTERNAL</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SPI_INTERNAL</displayName>
          <description>SPI INTERNAL Register</description>
          <addressOffset>0x50</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
          </fields>
       </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>SPI2</name>
      <description>SPI Register Map</description>
      <groupName>SPI</groupName>
      <baseAddress>0x400D0000</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x0</offset>
        <size>0x18</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x20</offset>
        <size>0x8</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x38</offset>
        <size>0x8</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x50</offset>
        <size>0x4</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>SPI_CTL</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SPI_CTL</displayName>
          <description>SPI Control Register</description>
          <addressOffset>0x0</addressOffset>
          <access>read-write</access>
          <resetValue>0x10003004</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>GOBUSY</name>
              <description>SPI Transfer Control Bit and Busy Status\nIf the FIFO mode is disabled, during the data transfer, this bit keeps the value of '1'. As the transfer is finished, this bit will be cleared automatically. Software can read this bit to check if the SPI is in busy status.\nIn FIFO mode, this bit will be controlled by hardware. Software should not modify this bit. In slave mode, this bit always returns 1 when software reads this register. In master mode, this bit reflects the busy or idle status of SPI.\nNote:\n1.When FIFO mode is disabled, all configurations should be set before writing "1" to the GOBUSY bit in the SPI_CTL register.\n2. When FIFO bit is disabled and the software uses TX or RX PDMA function to transfer data, this bit will be cleared after the PDMA controller finishes the data transfer.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Writing this bit "0" will stop data transfer if SPI is transferring</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>In Master mode, writing "1" to this bit will start the SPI data transfer; In Slave mode, writing '1' to this bit indicates that the slave is ready to communicate with a master</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RXNEG</name>
              <description>Receiveon Negative Edge\nNote: Refer to Edge section.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The received data is latched on the rising edge of SPI_SCLK</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The received data is latched on the falling edge of SPI_SCLK</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TXNEG</name>
              <description>Transmit on Negative Edge\nNote: Refer to Edge section.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The transmitted data output is changed on the rising edge of SPI_SCLK</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The transmitted data output is changed on the falling edge of SPI_SCLK</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DWIDTH</name>
              <description>Data Width\nThis field specifies how many bits can be transmitted / received in one transaction. The minimum bit length is 8 bits and can be up to 32 bits.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>5</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>32 bits are transmitted in one transaction</description>
                    <value>#00000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>8</name>
                    <description>8 bits are transmitted in one transaction</description>
                    <value>#01000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>9</name>
                    <description>9 bits are transmitted in one transaction</description>
                    <value>#01001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>10</name>
                    <description>10 bits are transmitted in one transaction</description>
                    <value>#01010</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>30</name>
                    <description>30 bits are transmitted in one transaction</description>
                    <value>#11110</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>31</name>
                    <description>31 bits are transmitted in one transaction</description>
                    <value>#11111</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>LSB</name>
              <description>Send LSB First\nNote: Refer to LSB first section.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The MSB, which bit of transmit/receive register depends on the setting of DWIDTH (SPI_CTL[7:3]), is transmitted/received first</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The LSB, bit 0 of the SPI_TX0/1, is sent first to the the SPI data output pin, and the first bit received from the SPI data input pin will be put in the LSB position of theRX register (SPI_RX0/1)</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CLKPOL</name>
              <description>Clock Polarity\nNote: Refer to Clock Parity section.</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The default level of SCLK is low</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The default level of SCLK is high</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SUSPITV</name>
              <description>Suspend Interval (Master Only)</description>
              <bitOffset>12</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>UNITIEN</name>
              <description>Unit Transfer Interrupt Enable Bit</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>SPI unit transfer interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>SPI unit transferinterrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SLAVE</name>
              <description>Slave Mode Selection\nNote: Refer to Slave Selection section</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>SPI controller set as Master mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>SPI controller set as Slave mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>REORDER</name>
              <description>Byte Reorder Function EnableBit\nNote: The suspend interval is defined in SUSPITV.Refer to Byte Reorder section.\nNote: Byte Suspend is only used in SPI Byte Reorder mode.</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Byte reorderfunction Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable byte reorder function and insert a byte suspend interval among each byte. The setting of DWIDTH must be configured as 00b ( 32 bits/ word)</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>FIFOM</name>
              <description>FIFO Mode EnableBit\nNote: Refer to FIFO Mode section.</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>FIFO mode Disabled (in Normal mode)</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>FIFO mode Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TWOBIT</name>
              <description>2-bit Transfer Mode Enable Bit\nRefer to Two Bit Transfer Mode section\nNote: automatically</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>2-bit transfer mode Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>2-bit transfer mode Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DUALDIR</name>
              <description>Dual I/O Mode Direction Control\nRefer to Dual I/O Mode section.</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Date read in the Dual I/O Mode function</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Data write in the Dual I/O Mode function</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DUALIOEN</name>
              <description>Dual I/O Mode EnableBit\nRefer to Dual I/O Mode section.</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Dual I/O Mode function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Dual I/O Mode function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>WKSSEN</name>
              <description>Wake-up by Slave Select EnableBit\nNote: The Slave select wake-up function is only available in SPI Slave mode. When the system enters Power-down mode, the system can be wake-up from the SPI controller if this bit is enabled and there is any toggle on the SPI_SS port. After the system wake-up, this bit must be cleared by user to disable the wake-up requirement.</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Wake-up function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Wake-up function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>WKCLKEN</name>
              <description>Wake-up by SPI Clock EnableBit\nNote: When the system enters Power-down mode, the system can be wake-up from the SPI controller if this bit is enabled and there is any toggle on the SPI_CLK port. After the system wake-up, this bit must be cleared by user to disable the wake-up requirement.</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Wake-up function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Wake-up function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SPI_STATUS</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SPI_STATUS</displayName>
          <description>SPI Status Register</description>
          <addressOffset>0x4</addressOffset>
          <access>read-write</access>
          <resetValue>0x00008005</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RXEMPTY</name>
              <description>Receive FIFO Buffer Empty Indicator(Read Only)</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Received data FIFO is not empty in the FIFO mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Received data FIFO is empty in the FIFO mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>RXFULL</name>
              <description>Receive FIFO Buffer Full Indicator(Read Only)</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Received data FIFO is not full in FIFO mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Received data FIFO is full in the FIFO mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>TXEMPTY</name>
              <description>Transmit FIFO Buffer Empty Indicator(Read Only)</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Transmitted data FIFO is not empty in the FIFO mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Transmitted data FIFO is empty in the FIFO mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>TXFULL</name>
              <description>Transmit FIFO Buffer Full Indicator (Read Only)</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Transmitted data FIFO is not full in the FIFO mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Transmitted data FIFO is full in the FIFO mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>LTRIGF</name>
              <description>Level Trigger Accomplish Flag(Read Only)\nIn Slave mode, this bit indicates whether the received bit number meets the requirement or not after the current transaction done.\nNote: This bit is READ only. As the software sets the GOBUSY bit to 1, the LTRIGF will be cleared to 0 after 4 SPI peripheral clock periods plus 1 system clock period. In FIFO mode, this bit is unmeaning.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The transferred bit length of one transaction does not meet the specified requirement</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The transferred bit length meets the specified requirement which defined in DWIDTH</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>SLVSTAIF</name>
              <description>Slave Start Interrupt Flag\nIt is used to dedicate that the transfer has started in Slave mode with no slave select.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Slave started transfer no active</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Transfer has started in Slave mode with no slave select. It is automatically cleared by transfer done or writing '1'</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>UNITIF</name>
              <description>Unit Transfer Interrupt Flag\nNote 2: This bitcan be cleared by writing "1" to it.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No transaction has been finished since this bit was cleared to 0.\nTransfer is not finished yet</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>SPI controller has finished one unit transfer.\nTransfer is done. The interrupt is requested when the UNITIEN(SPI_CTL[17]) bit is enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RXTHIF</name>
              <description>RX FIFO Threshold Interrupt Flag(Read Only)</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RX valid data counts small or equal than RXTH (SPI_FIFOCTL[27:24])</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RX valid data counts bigger than RXTH</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>RXOVIF</name>
              <description>Receive FIFO Overrun Interrupt Flag\nNote 1: If SPI receives data when RX FIFO is full, this bit will set to 1, and the received data will be dropped.\nNote 2: This bit will be cleared by writing 1 to it.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No FIFO over run</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Receive FIFO over run</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TXTHIF</name>
              <description>Transmit FIFO Threshold Interrupt Flag(Read Only)</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>TX valid data counts bigger than TXTH (SPI_FIFOCTL[31:28])</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>TX valid data counts small or equal than TXTH</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>RXTOIF</name>
              <description>Receive Time-outInterrupt Flag\nRefer to Time Out section.\nNote: This bit will be cleared by writing 1 to it.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>There is not time-out event on the received buffer</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Time out event active in RX FIFO is not empty</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SLVTOIF</name>
              <description>Slave Time-out Interrupt Flag\nIf SLVTOIEN (SPI_SSCTL[6]) is set to 1, this bit will be asserted when slave time-out event occur. Software can clear this bit by setting RXFBCLR (SPI_FIFOCTL[0]) or writing 1 to clear this bit.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Slave time-out does not occur yet</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Slave time-out has occurred</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SLVTXSKE</name>
              <description>Slave Mode Transmit Skew Buffer Empty Status\nThis bit indicates the empty status of transmit skew buffer which is used in Slave mode.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXCNT</name>
              <description>Receive FIFO Data Counts (Read Only)\nThis bit field indicates the valid data count of receive FIFO buffer.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TXCNT</name>
              <description>Transmit FIFO Data Counts (Read Only)\nThis bit field indicates the valid data count of transmit FIFO buffer.</description>
              <bitOffset>20</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>WKSSIF</name>
              <description>Wake-up by Slave Select Interrupt Flag\nWhen chip is woken up from Power-down mode by the toggle event on SPI_SS port, this bit is set to 1. This bit can be cleared by writing '1' to it.</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>WKCLKIF</name>
              <description>Wake-up by SPI Clock Interrupt Flag\nWhen chip is woken up from Power-down mode by the toggle event on SPI_CLK port, this bit is set to 1. This bit can be cleared by writing '1' to it.</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SPI_CLKDIV</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SPI_CLKDIV</displayName>
          <description>SPI Clock Divider Register</description>
          <addressOffset>0x8</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DIVIDER</name>
              <description>Clock Divider\nThe value is the 1th frequency divider of the PCLK to generate the serial clock of SPI_SCLK. The desired frequency is obtained according to the following equation:\nWhere\n is the SPI peripheral clock source. It is defined in the CLK_SEL2[21:20] in Clock control section (CLK_BA + 0x18).</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SPI_SSCTL</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SPI_SSCTL</displayName>
          <description>SPI Slave Select Control Register</description>
          <addressOffset>0xC</addressOffset>
          <access>read-write</access>
          <resetValue>0x24000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SS</name>
              <description>Slave SelectionControl (Master Only)\nIf AUTOSS bit (SPI_SSCTL[3]) is cleared, writing "1" to SS[0] (SPI_CTL[0]) bit sets the SPI_SS0 line to an active state and writing "0" sets the line back to inactive state(the same as SPI_CTL[1] for SPI_SS1).\nNote:\n1. This interface can only drive one device/slave at a given time. Therefore, the slaves select of the selected device must be set to its active level before starting any read or write transfer.\n2. SPI_SS0 is also defined as device/slave select input in Slave mode. And that the slave select input must be driven by edge active trigger which level depend on the SSACTPOL setting, otherwise the SPI slave core will go into dead path until the edge active triggers again or reset the SPI core by software.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Both SPI_SS1 and SPI_SS0 are inactive</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>SPI_SS1 is inactive, SPI_SS0 is active.\nSPI_SS1 is inactive, SPI_SS0 is active on the duration of transaction</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>SPI_SS1 is active, SPI_SS0 is inactive.\nSPI_SS1 is active on the duration of transaction, SPI_SS0 is inactive</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Both SPI_SS1 and SPI_SS0 are active..\nBoth SPI_SS1 and SPI_SS0 are active on the duration of transaction</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SSACTPOL</name>
              <description>Slave Selection Active Polarity\nIt defines the active polarity of slave selection signal (SPI_SS[1:0]).</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The SPI_SS slave select signal is active Low</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The SPI_SS slave select signal is active High</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>AUTOSS</name>
              <description>Automatic Slave Selection Function Enable Bit (Master Only)</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>If this bit is set as "0", slave select signals are asserted and de-asserted by setting and clearing related bits in SS[1:0] (SPI_CTL[1:0])</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>If this bit is set as "1", SPI_SS0 and SPI_SS1 signals are generated automatically. It means that device/slave select signal, which is set in SS[1:0] (SPI_CTL[1:0]) is asserted by the SPI controller when transmit/receive is started, and is de-asserted after each transaction is done</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SSLTRIG</name>
              <description>Slave Select Level Trigger Control</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The input slave select signal is edge-trigger</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The slave select signal will be level-trigger. It depends on SSACTPOL to decide the signal is active low or active high</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SLV3WIRE</name>
              <description>Slave 3-wire Mode Enable Bit\nThis bit is used to ignore the slave select signal in Slave mode. The SPI controller can work with 3-wire interface including SPI_CLK, SPI_MISO, and SPI_MOSI when it is set as a slave device.\nNote 1:Refer to No Slave Select Mode.\nNote 2: In no slave select signal mode, hardware will set the SSLTRIG (SPI_SSCTL[4]) as "1" automatically.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The controller is 4-wire bi-direction interface</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The controller is 3-wire bi-direction interface in Slave mode. When this bit is set as 1, the controller start to transmit/receive data after the GOBUSY bit active and the SPI clock input</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SLVTOIEN</name>
              <description>Slave Time-out Interrupt Enable Bit\nThis bit is used to enable the slave time-out function in slave mode and there will be an interrupt if slave time-out event occur</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Slave time-out function and interrupt both Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Slave time-out function and interrupt both Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SLVABORT</name>
              <description>Abort in Slave Mode with No Slave Selected\nRefer to No Slave Select Mode.\nNote: It is auto cleared to "0" by hardware when the abort event is active.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No force the slave abort</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Force the current transfer done in no slave select mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SSTAIEN</name>
              <description>Slave Start Interrupt EnableBit\nRefer to No Slave Select Mode.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Transfer start interrupt Disabled in no slave select mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Transaction start interrupt Enabled in no slave select mode. It is cleared when the current transfer done or the SLVSTAIF bit cleared (write 1 clear)</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SSINAIEN</name>
              <description>Slave Select Inactive Interrupt Enable Bit\nIt is used to enable the interrupt when the transfer has done in slave mode.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No any interrupt, even there is slave select inactive event</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>There is interrupt event when the slave select becomes inactive from active condition. It is used to inform the user to know that the transaction has finished and the slave select into the inactive state</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SLVTOCNT</name>
              <description>Slave Mode Time-out Period\nIn Slave mode, these bits indicate the time-out period when there is bus clock input during slave select active. The clock source of the time-out counter is Slave peripheral clock. If the value is 0, it indicates the slave mode time-out function is disabled.</description>
              <bitOffset>20</bitOffset>
              <bitWidth>10</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SPI_RX0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SPI_RX0</displayName>
          <description>SPI Receive Data FIFO Register 0</description>
          <addressOffset>0x10</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RX</name>
              <description>Receive Data Register (Read Only)\nThe received data can be read on it. If the FIFO bit is set as 1, the user also checks the RXEMPTY, SPI_STATUS[0], to check if there is any more received data or not.\nNote:The SPI_RX1 is used only in TWOBIT bit (SPI_CTL[22])is set 1. The first channel's received data shall be read from SPI_RX0 and the second channel's received data shall be read from SPI_RX1 in two-bit mode. SPI_RX0 shall be read first in TWOBIT mode.\nIn FIFO and two-bit mode, the first read back data in SPI_RX0 is the first channel data and the second read back data in SPI_RX0 is the second channel data.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="SPI_RX0">
          <name>SPI_RX1</name>
          <displayName>SPI_RX1</displayName>
          <description>SPI Receive Data FIFO Register 1</description>
          <addressOffset>0x14</addressOffset>
       </register>
       <register>
          <name>SPI_TX0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SPI_TX0</displayName>
          <description>SPI Transmit Data FIFO Register 0</description>
          <addressOffset>0x20</addressOffset>
          <access>write-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TX</name>
              <description>Transmit Data Register (Write Only)\nThe Data Transmit Registers hold the data to be transmitted in the next transfer. The number of valid bits depends on the setting of transmit bit length field of the SPI_CTL register.\nFor example, if DWIDTH is set to 0x8, the bit SPI_TX[7:0] will be transmitted in next transfer. If DWIDTH is set to 0x0, the SPI controller will perform a 32-bit transfer.\nNote:\n1. The SPI_TX1 is used only when TWOBIT bit (SPI_CTL[22])is set 1. The first channel's transmitted data shall be written into SPI_TX0 and the second channel's transmitted data shall be written into SPI_TX1 in two-bit mode. SPI_TX0 shall be written first in TWOBIT mode.\nIn FIFO and two-bit mode, the first written into data in SPI_TX0 is the first channel's transmitted data and the second written data in SPI_TX1 is the second channel's transmitted data.\n2.If the SPI controller operates as slave device and FIFO mode is disabled, software must update the transmit data register before setting the GOBUSY bit to 1.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="SPI_TX0">
          <name>SPI_TX1</name>
          <displayName>SPI_TX1</displayName>
          <description>SPI Transmit Data FIFO Register 1</description>
          <addressOffset>0x24</addressOffset>
       </register>
       <register>
          <name>SPI_PDMACTL</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SPI_PDMACTL</displayName>
          <description>SPI PDMA Control Register</description>
          <addressOffset>0x38</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TXPDMAEN</name>
              <description>Transmit PDMA Enable Bit\nRefer to PDMA section for more detailed information.\nSPI_CTLNote:\n1. Two transaction need minimal 18 APB clock + 8 SPI peripheral clocks suspend interval in master mode for edge mode and 18 APB clock + 9.5 SPI peripheral clocks for level mode.\n2. If the 2-bit function is enabled, the requirement timing shall append 18 APB clock based on the above clock period.\nHardware will clear this bit to 0 automatically after PDMA transfer is done.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Transmit PDMA function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Transmit PDMA function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RXPDMAEN</name>
              <description>Receiving PDMA EnableBit\nRefer to PDMA section for more detail information.\nNote:\nHardware will clear this bit to 0 automatically after PDMA transfer done.\nIn Slave mode and the FIFO bit is disabled, if the receive PDMA is enabled but the transmit PDMA is disabled, the minimal suspend interval between two successive  transactions input is need to be larger than 9 SPI peripheral clock + 4 APB clock for edge mode and 9.5 SPI peripheral clock + 4 APB clock.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Receiver PDMA function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Receiver PDMA function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PDMARST</name>
              <description>PDMA Reset\nIt is used to reset the SPI PDMA function into default state.\nNote:It is auto cleared to "0" after the reset function has done.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>After reset PDMA function or in normal operation</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reset PDMA function</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SPI_FIFOCTL</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SPI_FIFOCTL</displayName>
          <description>SPI FIFO Control Register</description>
          <addressOffset>0x3C</addressOffset>
          <access>read-write</access>
          <resetValue>0x44000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RXFBCLR</name>
              <description>Receive FIFO Buffer Clear\nNote:This bit is used to clear the receiver counter in FIFO Mode. This bit can be written "1" to clear the receiver counter and this bit will be cleared to "0" automatically after clearing receiving counter. After the clear operation, the flag of RXEMPTY in SPI_STATUS[0] will be set to "1".</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No clear the received FIFO</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Clear the received FIFO</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TXFBCLR</name>
              <description>Transmit FIFO Buffer Clear\nNote:This bit is used to clear the transmit counter in FIFO Mode. This bit can be written "1" to clear the transmitting counter and this bit will be cleared to "0" automatically after clearing transmitting counter. After the clear operation, the flag of TXEMPTY in SPI_STATUS[2] will be set to "1".</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Not clear the transmitted FIFO</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Clear the transmitted FIFO</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RXTHIEN</name>
              <description>Receive Threshold Interrupt Enable Bit</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RX threshold interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RX threshold interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TXTHIEN</name>
              <description>Transmit Threshold Interrupt Enable Bit</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>TX threshold interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>TX threshold interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RXOVIEN</name>
              <description>ReceiveFIFO Overrun Interrupt Enable Bit</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RXFIFO overrun interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RX FIFO overrun interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RXTOIEN</name>
              <description>RX Read Time Out Interrupt Enable Bit</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RXread Time-out Interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RX read Time-out Interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RXTH</name>
              <description>Received FIFO Threshold\nIf RX valid data counts are greater than RXTH, RXTHIF (SPI_STATUS[8])will be set to 1..</description>
              <bitOffset>24</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TXTH</name>
              <description>Transmit FIFO Threshold\nIf TX valid data counts are smaller than or equal to TXTH, TXTHIF(SPI_STATUS[10])will be set to 1.</description>
              <bitOffset>28</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SPI_INTERNAL</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SPI_INTERNAL</displayName>
          <description>SPI INTERNAL Register</description>
          <addressOffset>0x50</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
          </fields>
       </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>SPI3</name>
      <description>SPI Register Map</description>
      <groupName>SPI</groupName>
      <baseAddress>0x401E0000</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x0</offset>
        <size>0x18</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x20</offset>
        <size>0x8</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x38</offset>
        <size>0x8</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x50</offset>
        <size>0x4</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>SPI_CTL</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SPI_CTL</displayName>
          <description>SPI Control Register</description>
          <addressOffset>0x0</addressOffset>
          <access>read-write</access>
          <resetValue>0x10003004</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>GOBUSY</name>
              <description>SPI Transfer Control Bit and Busy Status\nIf the FIFO mode is disabled, during the data transfer, this bit keeps the value of '1'. As the transfer is finished, this bit will be cleared automatically. Software can read this bit to check if the SPI is in busy status.\nIn FIFO mode, this bit will be controlled by hardware. Software should not modify this bit. In slave mode, this bit always returns 1 when software reads this register. In master mode, this bit reflects the busy or idle status of SPI.\nNote:\n1.When FIFO mode is disabled, all configurations should be set before writing "1" to the GOBUSY bit in the SPI_CTL register.\n2. When FIFO bit is disabled and the software uses TX or RX PDMA function to transfer data, this bit will be cleared after the PDMA controller finishes the data transfer.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Writing this bit "0" will stop data transfer if SPI is transferring</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>In Master mode, writing "1" to this bit will start the SPI data transfer; In Slave mode, writing '1' to this bit indicates that the slave is ready to communicate with a master</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RXNEG</name>
              <description>Receiveon Negative Edge\nNote: Refer to Edge section.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The received data is latched on the rising edge of SPI_SCLK</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The received data is latched on the falling edge of SPI_SCLK</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TXNEG</name>
              <description>Transmit on Negative Edge\nNote: Refer to Edge section.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The transmitted data output is changed on the rising edge of SPI_SCLK</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The transmitted data output is changed on the falling edge of SPI_SCLK</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DWIDTH</name>
              <description>Data Width\nThis field specifies how many bits can be transmitted / received in one transaction. The minimum bit length is 8 bits and can be up to 32 bits.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>5</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>32 bits are transmitted in one transaction</description>
                    <value>#00000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>8</name>
                    <description>8 bits are transmitted in one transaction</description>
                    <value>#01000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>9</name>
                    <description>9 bits are transmitted in one transaction</description>
                    <value>#01001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>10</name>
                    <description>10 bits are transmitted in one transaction</description>
                    <value>#01010</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>30</name>
                    <description>30 bits are transmitted in one transaction</description>
                    <value>#11110</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>31</name>
                    <description>31 bits are transmitted in one transaction</description>
                    <value>#11111</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>LSB</name>
              <description>Send LSB First\nNote: Refer to LSB first section.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The MSB, which bit of transmit/receive register depends on the setting of DWIDTH (SPI_CTL[7:3]), is transmitted/received first</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The LSB, bit 0 of the SPI_TX0/1, is sent first to the the SPI data output pin, and the first bit received from the SPI data input pin will be put in the LSB position of theRX register (SPI_RX0/1)</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CLKPOL</name>
              <description>Clock Polarity\nNote: Refer to Clock Parity section.</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The default level of SCLK is low</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The default level of SCLK is high</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SUSPITV</name>
              <description>Suspend Interval (Master Only)</description>
              <bitOffset>12</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>UNITIEN</name>
              <description>Unit Transfer Interrupt Enable Bit</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>SPI unit transfer interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>SPI unit transferinterrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SLAVE</name>
              <description>Slave Mode Selection\nNote: Refer to Slave Selection section</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>SPI controller set as Master mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>SPI controller set as Slave mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>REORDER</name>
              <description>Byte Reorder Function EnableBit\nNote: The suspend interval is defined in SUSPITV.Refer to Byte Reorder section.\nNote: Byte Suspend is only used in SPI Byte Reorder mode.</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Byte reorderfunction Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable byte reorder function and insert a byte suspend interval among each byte. The setting of DWIDTH must be configured as 00b ( 32 bits/ word)</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>FIFOM</name>
              <description>FIFO Mode EnableBit\nNote: Refer to FIFO Mode section.</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>FIFO mode Disabled (in Normal mode)</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>FIFO mode Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TWOBIT</name>
              <description>2-bit Transfer Mode Enable Bit\nRefer to Two Bit Transfer Mode section\nNote: automatically</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>2-bit transfer mode Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>2-bit transfer mode Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DUALDIR</name>
              <description>Dual I/O Mode Direction Control\nRefer to Dual I/O Mode section.</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Date read in the Dual I/O Mode function</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Data write in the Dual I/O Mode function</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DUALIOEN</name>
              <description>Dual I/O Mode EnableBit\nRefer to Dual I/O Mode section.</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Dual I/O Mode function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Dual I/O Mode function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>WKSSEN</name>
              <description>Wake-up by Slave Select EnableBit\nNote: The Slave select wake-up function is only available in SPI Slave mode. When the system enters Power-down mode, the system can be wake-up from the SPI controller if this bit is enabled and there is any toggle on the SPI_SS port. After the system wake-up, this bit must be cleared by user to disable the wake-up requirement.</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Wake-up function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Wake-up function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>WKCLKEN</name>
              <description>Wake-up by SPI Clock EnableBit\nNote: When the system enters Power-down mode, the system can be wake-up from the SPI controller if this bit is enabled and there is any toggle on the SPI_CLK port. After the system wake-up, this bit must be cleared by user to disable the wake-up requirement.</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Wake-up function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Wake-up function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SPI_STATUS</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SPI_STATUS</displayName>
          <description>SPI Status Register</description>
          <addressOffset>0x4</addressOffset>
          <access>read-write</access>
          <resetValue>0x00008005</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RXEMPTY</name>
              <description>Receive FIFO Buffer Empty Indicator(Read Only)</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Received data FIFO is not empty in the FIFO mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Received data FIFO is empty in the FIFO mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>RXFULL</name>
              <description>Receive FIFO Buffer Full Indicator(Read Only)</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Received data FIFO is not full in FIFO mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Received data FIFO is full in the FIFO mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>TXEMPTY</name>
              <description>Transmit FIFO Buffer Empty Indicator(Read Only)</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Transmitted data FIFO is not empty in the FIFO mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Transmitted data FIFO is empty in the FIFO mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>TXFULL</name>
              <description>Transmit FIFO Buffer Full Indicator (Read Only)</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Transmitted data FIFO is not full in the FIFO mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Transmitted data FIFO is full in the FIFO mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>LTRIGF</name>
              <description>Level Trigger Accomplish Flag(Read Only)\nIn Slave mode, this bit indicates whether the received bit number meets the requirement or not after the current transaction done.\nNote: This bit is READ only. As the software sets the GOBUSY bit to 1, the LTRIGF will be cleared to 0 after 4 SPI peripheral clock periods plus 1 system clock period. In FIFO mode, this bit is unmeaning.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The transferred bit length of one transaction does not meet the specified requirement</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The transferred bit length meets the specified requirement which defined in DWIDTH</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>SLVSTAIF</name>
              <description>Slave Start Interrupt Flag\nIt is used to dedicate that the transfer has started in Slave mode with no slave select.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Slave started transfer no active</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Transfer has started in Slave mode with no slave select. It is automatically cleared by transfer done or writing '1'</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>UNITIF</name>
              <description>Unit Transfer Interrupt Flag\nNote 2: This bitcan be cleared by writing "1" to it.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No transaction has been finished since this bit was cleared to 0.\nTransfer is not finished yet</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>SPI controller has finished one unit transfer.\nTransfer is done. The interrupt is requested when the UNITIEN(SPI_CTL[17]) bit is enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RXTHIF</name>
              <description>RX FIFO Threshold Interrupt Flag(Read Only)</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RX valid data counts small or equal than RXTH (SPI_FIFOCTL[27:24])</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RX valid data counts bigger than RXTH</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>RXOVIF</name>
              <description>Receive FIFO Overrun Interrupt Flag\nNote 1: If SPI receives data when RX FIFO is full, this bit will set to 1, and the received data will be dropped.\nNote 2: This bit will be cleared by writing 1 to it.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No FIFO over run</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Receive FIFO over run</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TXTHIF</name>
              <description>Transmit FIFO Threshold Interrupt Flag(Read Only)</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>TX valid data counts bigger than TXTH (SPI_FIFOCTL[31:28])</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>TX valid data counts small or equal than TXTH</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>RXTOIF</name>
              <description>Receive Time-outInterrupt Flag\nRefer to Time Out section.\nNote: This bit will be cleared by writing 1 to it.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>There is not time-out event on the received buffer</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Time out event active in RX FIFO is not empty</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SLVTOIF</name>
              <description>Slave Time-out Interrupt Flag\nIf SLVTOIEN (SPI_SSCTL[6]) is set to 1, this bit will be asserted when slave time-out event occur. Software can clear this bit by setting RXFBCLR (SPI_FIFOCTL[0]) or writing 1 to clear this bit.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Slave time-out does not occur yet</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Slave time-out has occurred</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SLVTXSKE</name>
              <description>Slave Mode Transmit Skew Buffer Empty Status\nThis bit indicates the empty status of transmit skew buffer which is used in Slave mode.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXCNT</name>
              <description>Receive FIFO Data Counts (Read Only)\nThis bit field indicates the valid data count of receive FIFO buffer.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TXCNT</name>
              <description>Transmit FIFO Data Counts (Read Only)\nThis bit field indicates the valid data count of transmit FIFO buffer.</description>
              <bitOffset>20</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>WKSSIF</name>
              <description>Wake-up by Slave Select Interrupt Flag\nWhen chip is woken up from Power-down mode by the toggle event on SPI_SS port, this bit is set to 1. This bit can be cleared by writing '1' to it.</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>WKCLKIF</name>
              <description>Wake-up by SPI Clock Interrupt Flag\nWhen chip is woken up from Power-down mode by the toggle event on SPI_CLK port, this bit is set to 1. This bit can be cleared by writing '1' to it.</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SPI_CLKDIV</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SPI_CLKDIV</displayName>
          <description>SPI Clock Divider Register</description>
          <addressOffset>0x8</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DIVIDER</name>
              <description>Clock Divider\nThe value is the 1th frequency divider of the PCLK to generate the serial clock of SPI_SCLK. The desired frequency is obtained according to the following equation:\nWhere\n is the SPI peripheral clock source. It is defined in the CLK_SEL2[21:20] in Clock control section (CLK_BA + 0x18).</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SPI_SSCTL</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SPI_SSCTL</displayName>
          <description>SPI Slave Select Control Register</description>
          <addressOffset>0xC</addressOffset>
          <access>read-write</access>
          <resetValue>0x24000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SS</name>
              <description>Slave SelectionControl (Master Only)\nIf AUTOSS bit (SPI_SSCTL[3]) is cleared, writing "1" to SS[0] (SPI_CTL[0]) bit sets the SPI_SS0 line to an active state and writing "0" sets the line back to inactive state(the same as SPI_CTL[1] for SPI_SS1).\nNote:\n1. This interface can only drive one device/slave at a given time. Therefore, the slaves select of the selected device must be set to its active level before starting any read or write transfer.\n2. SPI_SS0 is also defined as device/slave select input in Slave mode. And that the slave select input must be driven by edge active trigger which level depend on the SSACTPOL setting, otherwise the SPI slave core will go into dead path until the edge active triggers again or reset the SPI core by software.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Both SPI_SS1 and SPI_SS0 are inactive</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>SPI_SS1 is inactive, SPI_SS0 is active.\nSPI_SS1 is inactive, SPI_SS0 is active on the duration of transaction</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>SPI_SS1 is active, SPI_SS0 is inactive.\nSPI_SS1 is active on the duration of transaction, SPI_SS0 is inactive</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Both SPI_SS1 and SPI_SS0 are active..\nBoth SPI_SS1 and SPI_SS0 are active on the duration of transaction</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SSACTPOL</name>
              <description>Slave Selection Active Polarity\nIt defines the active polarity of slave selection signal (SPI_SS[1:0]).</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The SPI_SS slave select signal is active Low</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The SPI_SS slave select signal is active High</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>AUTOSS</name>
              <description>Automatic Slave Selection Function Enable Bit (Master Only)</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>If this bit is set as "0", slave select signals are asserted and de-asserted by setting and clearing related bits in SS[1:0] (SPI_CTL[1:0])</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>If this bit is set as "1", SPI_SS0 and SPI_SS1 signals are generated automatically. It means that device/slave select signal, which is set in SS[1:0] (SPI_CTL[1:0]) is asserted by the SPI controller when transmit/receive is started, and is de-asserted after each transaction is done</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SSLTRIG</name>
              <description>Slave Select Level Trigger Control</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The input slave select signal is edge-trigger</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The slave select signal will be level-trigger. It depends on SSACTPOL to decide the signal is active low or active high</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SLV3WIRE</name>
              <description>Slave 3-wire Mode Enable Bit\nThis bit is used to ignore the slave select signal in Slave mode. The SPI controller can work with 3-wire interface including SPI_CLK, SPI_MISO, and SPI_MOSI when it is set as a slave device.\nNote 1:Refer to No Slave Select Mode.\nNote 2: In no slave select signal mode, hardware will set the SSLTRIG (SPI_SSCTL[4]) as "1" automatically.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The controller is 4-wire bi-direction interface</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The controller is 3-wire bi-direction interface in Slave mode. When this bit is set as 1, the controller start to transmit/receive data after the GOBUSY bit active and the SPI clock input</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SLVTOIEN</name>
              <description>Slave Time-out Interrupt Enable Bit\nThis bit is used to enable the slave time-out function in slave mode and there will be an interrupt if slave time-out event occur</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Slave time-out function and interrupt both Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Slave time-out function and interrupt both Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SLVABORT</name>
              <description>Abort in Slave Mode with No Slave Selected\nRefer to No Slave Select Mode.\nNote: It is auto cleared to "0" by hardware when the abort event is active.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No force the slave abort</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Force the current transfer done in no slave select mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SSTAIEN</name>
              <description>Slave Start Interrupt EnableBit\nRefer to No Slave Select Mode.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Transfer start interrupt Disabled in no slave select mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Transaction start interrupt Enabled in no slave select mode. It is cleared when the current transfer done or the SLVSTAIF bit cleared (write 1 clear)</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SSINAIEN</name>
              <description>Slave Select Inactive Interrupt Enable Bit\nIt is used to enable the interrupt when the transfer has done in slave mode.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No any interrupt, even there is slave select inactive event</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>There is interrupt event when the slave select becomes inactive from active condition. It is used to inform the user to know that the transaction has finished and the slave select into the inactive state</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SLVTOCNT</name>
              <description>Slave Mode Time-out Period\nIn Slave mode, these bits indicate the time-out period when there is bus clock input during slave select active. The clock source of the time-out counter is Slave peripheral clock. If the value is 0, it indicates the slave mode time-out function is disabled.</description>
              <bitOffset>20</bitOffset>
              <bitWidth>10</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SPI_RX0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SPI_RX0</displayName>
          <description>SPI Receive Data FIFO Register 0</description>
          <addressOffset>0x10</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RX</name>
              <description>Receive Data Register (Read Only)\nThe received data can be read on it. If the FIFO bit is set as 1, the user also checks the RXEMPTY, SPI_STATUS[0], to check if there is any more received data or not.\nNote:The SPI_RX1 is used only in TWOBIT bit (SPI_CTL[22])is set 1. The first channel's received data shall be read from SPI_RX0 and the second channel's received data shall be read from SPI_RX1 in two-bit mode. SPI_RX0 shall be read first in TWOBIT mode.\nIn FIFO and two-bit mode, the first read back data in SPI_RX0 is the first channel data and the second read back data in SPI_RX0 is the second channel data.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="SPI_RX0">
          <name>SPI_RX1</name>
          <displayName>SPI_RX1</displayName>
          <description>SPI Receive Data FIFO Register 1</description>
          <addressOffset>0x14</addressOffset>
       </register>
       <register>
          <name>SPI_TX0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SPI_TX0</displayName>
          <description>SPI Transmit Data FIFO Register 0</description>
          <addressOffset>0x20</addressOffset>
          <access>write-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TX</name>
              <description>Transmit Data Register (Write Only)\nThe Data Transmit Registers hold the data to be transmitted in the next transfer. The number of valid bits depends on the setting of transmit bit length field of the SPI_CTL register.\nFor example, if DWIDTH is set to 0x8, the bit SPI_TX[7:0] will be transmitted in next transfer. If DWIDTH is set to 0x0, the SPI controller will perform a 32-bit transfer.\nNote:\n1. The SPI_TX1 is used only when TWOBIT bit (SPI_CTL[22])is set 1. The first channel's transmitted data shall be written into SPI_TX0 and the second channel's transmitted data shall be written into SPI_TX1 in two-bit mode. SPI_TX0 shall be written first in TWOBIT mode.\nIn FIFO and two-bit mode, the first written into data in SPI_TX0 is the first channel's transmitted data and the second written data in SPI_TX1 is the second channel's transmitted data.\n2.If the SPI controller operates as slave device and FIFO mode is disabled, software must update the transmit data register before setting the GOBUSY bit to 1.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="SPI_TX0">
          <name>SPI_TX1</name>
          <displayName>SPI_TX1</displayName>
          <description>SPI Transmit Data FIFO Register 1</description>
          <addressOffset>0x24</addressOffset>
       </register>
       <register>
          <name>SPI_PDMACTL</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SPI_PDMACTL</displayName>
          <description>SPI PDMA Control Register</description>
          <addressOffset>0x38</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TXPDMAEN</name>
              <description>Transmit PDMA Enable Bit\nRefer to PDMA section for more detailed information.\nSPI_CTLNote:\n1. Two transaction need minimal 18 APB clock + 8 SPI peripheral clocks suspend interval in master mode for edge mode and 18 APB clock + 9.5 SPI peripheral clocks for level mode.\n2. If the 2-bit function is enabled, the requirement timing shall append 18 APB clock based on the above clock period.\nHardware will clear this bit to 0 automatically after PDMA transfer is done.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Transmit PDMA function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Transmit PDMA function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RXPDMAEN</name>
              <description>Receiving PDMA EnableBit\nRefer to PDMA section for more detail information.\nNote:\nHardware will clear this bit to 0 automatically after PDMA transfer done.\nIn Slave mode and the FIFO bit is disabled, if the receive PDMA is enabled but the transmit PDMA is disabled, the minimal suspend interval between two successive  transactions input is need to be larger than 9 SPI peripheral clock + 4 APB clock for edge mode and 9.5 SPI peripheral clock + 4 APB clock.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Receiver PDMA function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Receiver PDMA function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PDMARST</name>
              <description>PDMA Reset\nIt is used to reset the SPI PDMA function into default state.\nNote:It is auto cleared to "0" after the reset function has done.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>After reset PDMA function or in normal operation</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reset PDMA function</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SPI_FIFOCTL</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SPI_FIFOCTL</displayName>
          <description>SPI FIFO Control Register</description>
          <addressOffset>0x3C</addressOffset>
          <access>read-write</access>
          <resetValue>0x44000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RXFBCLR</name>
              <description>Receive FIFO Buffer Clear\nNote:This bit is used to clear the receiver counter in FIFO Mode. This bit can be written "1" to clear the receiver counter and this bit will be cleared to "0" automatically after clearing receiving counter. After the clear operation, the flag of RXEMPTY in SPI_STATUS[0] will be set to "1".</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No clear the received FIFO</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Clear the received FIFO</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TXFBCLR</name>
              <description>Transmit FIFO Buffer Clear\nNote:This bit is used to clear the transmit counter in FIFO Mode. This bit can be written "1" to clear the transmitting counter and this bit will be cleared to "0" automatically after clearing transmitting counter. After the clear operation, the flag of TXEMPTY in SPI_STATUS[2] will be set to "1".</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Not clear the transmitted FIFO</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Clear the transmitted FIFO</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RXTHIEN</name>
              <description>Receive Threshold Interrupt Enable Bit</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RX threshold interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RX threshold interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TXTHIEN</name>
              <description>Transmit Threshold Interrupt Enable Bit</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>TX threshold interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>TX threshold interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RXOVIEN</name>
              <description>ReceiveFIFO Overrun Interrupt Enable Bit</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RXFIFO overrun interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RX FIFO overrun interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RXTOIEN</name>
              <description>RX Read Time Out Interrupt Enable Bit</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RXread Time-out Interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RX read Time-out Interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RXTH</name>
              <description>Received FIFO Threshold\nIf RX valid data counts are greater than RXTH, RXTHIF (SPI_STATUS[8])will be set to 1..</description>
              <bitOffset>24</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TXTH</name>
              <description>Transmit FIFO Threshold\nIf TX valid data counts are smaller than or equal to TXTH, TXTHIF(SPI_STATUS[10])will be set to 1.</description>
              <bitOffset>28</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SPI_INTERNAL</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SPI_INTERNAL</displayName>
          <description>SPI INTERNAL Register</description>
          <addressOffset>0x50</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
          </fields>
       </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>DSRC</name>
      <description>DSRC Register Map</description>
      <groupName>DSRC</groupName>
      <baseAddress>0x401F0000</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x0</offset>
        <size>0x1C</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x20</offset>
        <size>0x8</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x38</offset>
        <size>0xC</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x200</offset>
        <size>0x4</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x210</offset>
        <size>0xC</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>DSRC_CTL</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>DSRC_CTL</displayName>
          <description>DSRC Control Register</description>
          <addressOffset>0x0</addressOffset>
          <access>read-write</access>
          <resetValue>0x00008000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DSRCEN</name>
              <description>DSRC Enable Bit\nNote: When DSRC is enabled, SPI1 will set SUSPITV (SPI_CTL[15:12]), DWIDTH (SPI_CTL[7:3]), REORDER (SPI_CTL[19]), FIFOM (SPI_CTL[21]), TWOBIT (SPI_CTL[22]), and DUALIOEN (SPI_CTL[29]) set as 0x0, 0x8, 0, 1, 0, and 0 automatically for data byte transaction in DSRC application.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>DSRC Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>DSRC Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SWRXEN</name>
              <description>Software Control RX_ON Enable Bit</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Software control RX_ON signal Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Software control RX_ON signal Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CODECEN</name>
              <description>CODEC Enable Bit\nNote: When both DSRCEN and CODECEN are enabled, the SPI1 will set TXNEG (SPI_CTL[2]), RXNEG (SPI_CTL[1]), CLKPOL (SPI_CTL[11]), SS (SPI_SSCTL[1:0]), SSACTPOL (SPI_SSCTL[2]), AUTOSS (SPI_SSCTL[3]) and SLV3WIRE (SPI_SSCTL[5]) as 0, 1, 0, 0x1, 1, 1, and 1 automatically for FM0 (or Manchester) CODEC communication. In this codition, SPI1 will set the SLAVE (SPI_CTL[18]) bit automatically and operate as Master mode in data transmitting phase and Slave 3-wired mode in data receiving phase automatically.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>CODEC Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>CODEC Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CODECFMT</name>
              <description>CODEC Format Select Bit</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>FM0 CODEC</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>MONCHESTER CODEC</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BRDETEN</name>
              <description>Bit Rate Detection Enable Bit \nNote: This function is only for FM0 CODEC.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Bit rate detection Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Bit rate detection Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BRATEMOD</name>
              <description>Bit Rate Error Mode</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The DSRC receives the start of frame again</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The DSRC does not care the bit rate error message and continue receiving data</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CRCEN</name>
              <description>CRC Engine Enable Bit</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>CRC function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>CRC function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CRCMSB</name>
              <description>CRC Generation on Data MSB\nNote: If the input data is 0xaa, the sequence of CRC bit generation is 01010101 when the bit is set as 0. Otherwise, the sequence of CRC bit generation is 10101010 when the bit is set as 1.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The CRC generation start on the LSB input data first</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The CRC generation start on the MSB input data first</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CHKSREV</name>
              <description>Checksum Reverse\nNote: If the checksum data is 0XDD7B0F2E, the bit order reversed for CRC checksum is 0x74F0DEBB.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No bit order reverse for CRC checksum</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Bit order reverse for CRC checksum</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CHKSFMT</name>
              <description>Checksum Format</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No 1's complement for CRC checksum</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>1's complement for CRC checksum</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SEEDM</name>
              <description>CRC Seed Mode</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The transmit CRC seed initial value is CRCSEED0 (DSRC_CRCSEED[15:0])</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The transmit CRC seed initial value is CRCSEED1 (DSRC_CRCSEED[31:15])</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PREAMFMT</name>
              <description>Preamble Pattern Format\nNote: It is MSB first to be sent.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The preamble length is half word and its pattern is PREPAT (DSRC_PREAMBLE[15:0])</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The preamble length is one word and its pattern is PREPAT (DSRC_PREAMBLE[31:0])</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PDRXDIS</name>
              <description>Power-down Mode RXON Disable Bit </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RXON signal is always controlled by RXON(DSRC_CTL[23]) bit</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RXON signal is disabled during DSRC Power-Down period</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>WKHXTEN</name>
              <description>Wake-up HXT Clock Enable Bit \nSetting this bit to 1 enables RF wake-up HXT clock.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RF wake-up HXT clock Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RF T wake-up HXT clock Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TBPEN</name>
              <description>TBP Enable Bit\nSetting this bit to 1 enables TBP operation.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>TBP function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>TBP function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TRANSFIN</name>
              <description>TBP Transfer Done\nWhen the TTDMAEN (DSRC_CTL[20]) is disabled and the transmitted data is written into DSRC_TX by user, this bit shall be set into the TBP to terminate the processor before the last the transmitted data. The minimum length of transmitted data is 2 bytes.\nNote: This bit will be cleared after the TTBP transfer is done.</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Indicate the TTBP processor is not finished</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Inform the TTBP to finish the transparent bit processor after the current byte processed done</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TTDMAEN</name>
              <description>TBP Transmit DMA Enable Bit</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>TBP Transmitting DMA Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>TBP Transmitting DMA Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TRDMAEN</name>
              <description>TBP Receive DMA Enable Bit</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>TBP Receiving DMA Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>TBP Receiving DMA Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CRCBSWAP</name>
              <description>CRC BYTE SWAP</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The received CRC value is not byte swap</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The received CRC value is byte swap</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>FORCETX</name>
              <description>Force TX State Control Bit\nNote: This bit will be cleared automatically</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>DSRC returns TX state to transmit data immediately</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>FORCERX</name>
              <description>Force RX State Control Bit\nNote: This bit will be cleared automatically.</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>DSRC returns Start_Rx state immediately</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RXON</name>
              <description>RX_ON Control Bit</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RX_ON signal Enabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RX_ON signal Disabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>WKPOL</name>
              <description>Wake-up Pin Polarity Control Bit</description>
              <bitOffset>26</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Wake-up pin rising edge wake-up DSRC</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Wake-up pin falling edge wake-up DSRC</description>
                    <value>#01</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BRATEACC</name>
              <description>Bit Rate Accuracy Control Bits\nPlease refer to Table 6.181.\nNote: This function is only for FM0 CODEC.</description>
              <bitOffset>28</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>DSRC_INTEN</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>DSRC_INTEN</displayName>
          <description>DSRC Interrupt Enable Register</description>
          <addressOffset>0x4</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CRCCORIE</name>
              <description>CRC Check Correct Interrupt Enable Bit</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>CRC check done without error Interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>CRC check done without error Interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CRCERRIE</name>
              <description>CRC Error Interrupt Enable Bit</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>CRC error interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>CRC rate error interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>STRFRMIE</name>
              <description>Start Field of Frame Detection Interrupt Enable Bit</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Start Field of Frame detection interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Start Field of Frame detection interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>STPFRMIE</name>
              <description>Stop Field of Frame Detection Interrupt Enable Bit</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Stop Field of Frame detection Interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Stop Field of Frame detection Interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RXDATERRIE</name>
              <description>Received Data Error Interrupt Enable Bit</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Received DATA Error interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Received DATA Rate Error interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BRATERRIE</name>
              <description>Bit Rate Error Interrupt Enable Bit</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Bit Rate Error interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Bit Rate Error interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RTBPDIE</name>
              <description>TBP Byte Receive Done Interrupt Enable Bit</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The TBP byte receive done interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The TBP byte receive done interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TXDONEIE</name>
              <description>Transmit Data Done Interrupt Enable Bit</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Transmit data done interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Transmit data done interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>T2TOIE</name>
              <description>Timer 2 Time-out Interrupt Enable Bit</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>T2 Time-out interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>T2 Time-out interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>T3TOIE</name>
              <description>Timer 3 Time-out Interrupt Enable Bit</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>T3 Time-out interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>T3 Time-out interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>T4TOIE</name>
              <description>Timer 4 Time-out Interrupt Enable Bit</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>T4 Time-out interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>T4 Time-out interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>EPWKIE</name>
              <description>External Pin Wake-up Interrupt Enable Bit</description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>External Pin Wake-up event interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>External Pin Wake-up event interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>DSRC_STATUS</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>DSRC_STATUS</displayName>
          <description>DSRC Status Register</description>
          <addressOffset>0x8</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CRCCOR</name>
              <description>CRC CorrectBit</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>This flag indicates CRC check done and result is not correct on CHKSUM0 (DSRC_CHKSUM[15:0]) and CHKSUM1 (DSRC_CHKSUM[31:16])</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>If the CRC function is enabled (CRCEN(DSRC_CTL[8])=1, this flag indicates CRC check done and result is correct on CHKSUM0 (DSRC_CHKSUM[15:0]) or CHKSUM1 (DSRC_CHKSUM[31:16]), else writ 1 to this bit to indicate that MCU CRC check correct</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CRCERR</name>
              <description>CRC Error Bit</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>This flag indicates CRC check done and result is correct</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>If the CRC function is enabled (CRCEN(DSRC_CTL[8])=1,this flag indicates CRC check done and result is error on CHKSUM0 (DSRC_CHKSUM[15:0]) and CHKSUM1 (DSRC_CHKSUM[31:16]), else writ 1 to this bit to indicate that MCU CRC check error</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>STRFRM</name>
              <description>Start Field of Frame Detection Flag\nThis flag indicates start field of frame is detected.\nNote: Write 1 to clear this flag.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>STPFRM</name>
              <description>Stop Field of Frame Detection Flag\nThis flag indicates stop field of frame is detected.\nNote: Write 1 to clear this flag.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXDATERR</name>
              <description>Received Data Error Flag\nNote: Write 1 to clear this flag.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The received data packet error happened</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The received data packet has successive 7 bit 1. It indicates the receive frame shall be thrown out</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BRATERR</name>
              <description>Bit Rate Error Flag\nThis flag indicates FM0 or MANCHESTER bit rate error depending on CODECFMT (DSRC_CTL[3]) setting if BRDETEN (DSRC_CTL[4]) is set to 1.\nNote: Write 1 to clear this flag.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TTBPDONE</name>
              <description>TBP Byte Transfer Done\nNote 1: This bit is automatically cleared by TBP_TXDMA_ACK when the TTDMAEN (DSRC_CTL[18]) is set or by the write signal of DSRC_TX register when the TTDMAEN (DSRC_CTL[18]) is not set.\nNote 2: If the TTDMAEN (DSRC_CTL[18]) is not set, the first TTBPDONE is set after the TTBP module send out the PREAMBLE and Head 7E patterns. The first transmitted data shall be written into the TX (DSRC_TX) after this flag is set.\nNote 3: After the TRANFIN (DSRC_CTL[17]) is set, this bit won't report the byte transfer done status again. The user shall check the TXDONE (DSRC_STATUS[12]) to know the current transfer has done both on the TTBP and SPI device.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The TBP byte transfer is not finished</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The TBP byte transfer has been finished</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RTBPDONE</name>
              <description>TBP Byte Receive Done\nNote: This bit is automatically cleared by TBP_RXDMA_ACK when the TRDMAEN (DSRC_CTL[19]) is set or by the read signal of DSRC_RX register when the TRDMAEN (DSRC_CTL[19]) is not set.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The TBP byte receive is not finished</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The TBP byte receive has done</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TXFINISH</name>
              <description>TX Transfer Finish\nNote:Write 1 to clear this flag.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The TX transfer is not finished</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>All the data processed by the TTBP block and the CRC, trail 7E patterns had been transmitted finish by SPI interface</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TTBPFULL</name>
              <description>TTBPTransmit Full\nNote: If the TTDMAEN (DSRC_CTL[18] is disabled, the transmitted data can be written into the DSRC_TX register when the TTBPDONE (DSRC_STATUS[8]) is set to 1 and the TTBPFULL must be set as 0. Otherwise, the TTBP transmit done flag TTBPDONE (DSRC_STATUS[8]) won't be active in next data.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>TBP TX Transmit is not full</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>TBP TX Transmit is full</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>T2TO</name>
              <description>Timer 2 Time-out Flag\nThis flag is set after the Timer Controller finishes counting the value set by DSRC_TMR2.\nNote1: The Timer Counter is started when DSRC wake-up and the counter is cleared when the Start of Frame is detected before T2TO event is set.\nNote2: Write 1 to clear this flag.</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>T3TO</name>
              <description>Timer 3 Time-out Flag\nThis flag is set after the Timer Controller finishes counting the value set by DSRC_TMR3.\nNote1: The Timer Counter is startedwhen the Start of Frame is detected and the counter is cleared when the Stop of Frame is detect before the T3TO event is set.\nNote2: Write 1 to clear this flag.</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>T4TO</name>
              <description>Timer 4 Time-out Flag\nThis flag is set after the Timer Controller finishes counting the value set by DSRC_TMR4.\nNote1: The Timer Counter is started when SPI detected the Stop of Frame and DSRC CRC correct flag is active.\nNote2: Write 1 to clear this flag.</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CRC0_OK</name>
              <description>CRC0 Compare OK\nNote: Writing1 to CRCCOR (DSRC_STATUS[0]), CRCERR (DSRC_STATUS[1]) and itself can clear this flag.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The compare result between the receive CRC data and the CHKSUM0 (DSRC_CHKSUM[15:0])is not the same</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The compare result between the receive CRC data and the CHKSUM0 (DSRC_CHKSUM[15:0]) is the same</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CRC1_OK</name>
              <description>CRC1 Compare OK\nNote: Writing1 to CRCCOR (DSRC_STATUS[0]), CRCERR (DSRC_STATUS[1]) and itself can clear this flag.</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The compare result between the receive CRC data and the CHKSUM1 (DSRC_CHKSUM[31:16])is not the same</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The compare result between the receive CRC data and the CHKSUM1 (DSRC_CHKSUM[31:16]) is the same</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>EPWKF</name>
              <description>External Pin Wake-up Event Flag\nNote: Write 1 to clear this flag.</description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No external pin wake-up event happened</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>External pin wake-up event happened</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>DSRC_PREAMBLE</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>DSRC_PREAMBLE</displayName>
          <description>DSRC Preamble Pattern Register</description>
          <addressOffset>0xC</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PREPAT</name>
              <description>The Preamble Pattern\nThe bit field indicates the preamble pattern of DSRC. If the PREAMFMT (DSRC_CTL[24]) is set to 1, 32-bit preamble pattern is transmitted and the transmitted sequence is PREPAT[31:24], PREPAT[23:16], PREPAT[15:8] and PREPAT[7:0].\nIf the PREAMFMT (DSRC_CTL[24]) is set to 0, 16-bit preamble pattern is transmitted and the transmitted sequence is PREPAT[15:8] and PREPAT[7:0].</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>DSRC_CRCSEED</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>DSRC_CRCSEED</displayName>
          <description>DSRC CRC Seed Initial Register</description>
          <addressOffset>0x10</addressOffset>
          <access>read-write</access>
          <resetValue>0x0000FFFF</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CRCSEED0</name>
              <description>The CRC Seed Initial Pattern 0\nThe bits field indicates the CRC seed initial pattern 0 of DSRC.\nFor receiver:\nThe CRC will be calculated by the initial value. The TBP will auto compare the calculated result with the received CRC data and report its compare result into CRC0_OK (DSRC_STATUAS[24])\nFor Transmit:\nThe bit field is used to generate the CRC when the SEEDM (DSRC_CTL[20]) is set to 0.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CRCSEED1</name>
              <description>The CRC Seed Initial Pattern 1\nThe bit field indicates the CRC seed initial pattern 1 of DSRC.\nFor receiver:\nThe CRC will be calculated by the initial value. The TBP will auto compare the calculated result with the received CRC data and report its compare result into CRC1_OK (DSRC_STATUAS[25])\nFor transmitter:\nThe bit field is used to generate the CRC when the SEEDM (DSRC_CTL[20]) is set to 1.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>DSRC_RBCNT</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>DSRC_RBCNT</displayName>
          <description>DSRC Receive Byte Count Register</description>
          <addressOffset>0x14</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TBPBCNT</name>
              <description>TBP Receive Byte Count\nThe bits field indicates the number of receive byte count on RTBP when the CRCCOR (DSRC_STATUS[0]) is set to 1 and the STPFRM(DSRC_STATUS[3]) is set to 1. Otherwise, the value is 0.\nNote 1: The 2 bytes CRC is not calculated in this field.\nNote 2: If there is CRC calculation check error, the value will be cleared by hardware to calculate the next incoming data stream.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>9</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>DSRC_CHKSUM</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>DSRC_CHKSUM</displayName>
          <description>DSRC Checksum Register</description>
          <addressOffset>0x18</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CHECKSUM0</name>
              <description>The CRC Checksum0\nThe bit field indicates the CRC checksum of the initial value is CHKSUM0 (DSRC_CHKSUM[15:0]).</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>CHECKSUM1</name>
              <description>The CRC Checksum1\nThe bit field indicates the CRC checksum of the initial value is CHKSUM1 (DSRC_CHKSUM[31:16])</description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>DSRC_TX</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>DSRC_TX</displayName>
          <description>DSRC TX Data Register</description>
          <addressOffset>0x20</addressOffset>
          <access>write-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TX</name>
              <description>TBP Transmit Data\nThe bit field indicates the transmitted data on the TBP before being transmitted to TTBP.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>DSRC_RX</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>DSRC_RX</displayName>
          <description>DSRC RX Data Register</description>
          <addressOffset>0x24</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RX</name>
              <description>TBP Receiver Data\nThe bit field indicates the received data on the TBP after the RTBP.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>DSRC_TMR2</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>DSRC_TMR2</displayName>
          <description>DSRC Timer 2 Register</description>
          <addressOffset>0x38</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CMPDAT</name>
              <description>Timer Compared Value\nCMPDAT is a 24-bit compared value register. When the internal 24-bit up counter value is equal to CMPDAT value, the CNTIF (TIMERx_INTSTS[0] Timer Interrupt Flag) will be set to 1.\nNote1: Never write 0x0 or 0x1 in CMPDAT, or the core will run into unknown state.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PSC</name>
              <description>Prescale Counter</description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>DSRC_TMR3</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>DSRC_TMR3</displayName>
          <description>DSRC Timer 3 Register</description>
          <addressOffset>0x3C</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CMPDAT</name>
              <description>Timer Compared Value\nCMPDAT is a 24-bit compared value register. When the internal 24-bit up counter value is equal to CMPDAT value, the CNTIF (TIMERx_INTSTS[0] Timer Interrupt Flag) will be set to 1.\nNote1: Never write 0x0 or 0x1 in CMPDAT, or the core will run into unknown state.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PSC</name>
              <description>Prescale Counter</description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>DSRC_TMR4</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>DSRC_TMR4</displayName>
          <description>DSRC Timer 4 Register</description>
          <addressOffset>0x40</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CMPDAT</name>
              <description>Timer Compared Value\nCMPDAT is a 24-bit compared value register. When the internal 24-bit up counter value is equal to CMPDAT value, the CNTIF (TIMERx_INTSTS[0] Timer Interrupt Flag) will be set to 1.\nNote1: Never write 0x0 or 0x1 in CMPDAT, or the core will run into unknown state.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PSC</name>
              <description>Prescale Counter</description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>DSRC_CTL2</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>DSRC_CTL2</displayName>
          <description>DSRC Control Register 2</description>
          <addressOffset>0x200</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000400</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SOFNUM</name>
              <description>Start of Frame Number for Transmission\nThis bit field is used to define the number of SOF packet which is repeated send in the SPI bus before the transmitted data.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>1 Start field of frame after the Preamble</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>2Start field of frame after the Preamble</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>3Start field of framesafter the Preamble</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>4 Start field of frames after the Preamble</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CODECDEGSEL</name>
              <description>FM0 CODEC Deglitch Selection\nThis bits field is used to define how much width of glitch would be filtered.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>3</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>disable to the CODECdeglitch selection</description>
                    <value>#000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Filter the glitches that the width is 0.25us or less</description>
                    <value>#001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Filter the glitches that the width is 0.50us or less</description>
                    <value>#010</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Filter the glitches that the width is 0.75us or less</description>
                    <value>#011</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>4</name>
                    <description>Filter the glitches that the width is 1.00us or less</description>
                    <value>#100</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>5</name>
                    <description>Filter the glitches that the width is 1.25us or less</description>
                    <value>#101</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>DSRC_TXR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>DSRC_TXR</displayName>
          <description>DSRC Transmit Data After TTBP Register</description>
          <addressOffset>0x210</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TXDATR</name>
              <description>Transmit Data After TTBP \nThe bits field indicates the transmitted data after the TTBP. When the 8-Bit transmitted data is processed by the TTBP, the register indicates the processed content.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>DSRC_RXR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>DSRC_RXR</displayName>
          <description>DSRC Receive Data Before RTBP Register</description>
          <addressOffset>0x214</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RXDATR</name>
              <description>Receive Data Before RTBP \nThe bits field indicates the current receive data before the RTBP (It comes from the SPI RX buffer). Before the 8-Bit is processed by the RTBP, the register indicates the un-processed content.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>DSRC_ICR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>DSRC_ICR</displayName>
          <description>DSRC Internal Use Control Register</description>
          <addressOffset>0x218</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
          </fields>
       </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>ADC</name>
      <description>ADC Register Map</description>
      <groupName>ADC</groupName>
      <baseAddress>0x400E0000</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x0</offset>
        <size>0x20</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x30</offset>
        <size>0x2C</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x60</offset>
        <size>0x18</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>ADC_DAT0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>ADC_DAT0</displayName>
          <description>A/D Data Register 0</description>
          <addressOffset>0x0</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RESULT</name>
              <description>A/D Conversion Result\nThis field contains conversion result of ADC.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>12</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>VALID</name>
              <description>Valid Flag\nThis bit is set to 1 when ADC conversion is completed and cleared by hardware after the ADC_DATx register is read.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Data in RESULT (ADC_DAT[11:0]) bits is not valid</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Data in RESULT (ADC_DAT[11:0]) bits is valid</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>OV</name>
              <description>Overrun Flag\nIf converted data in RESULT (ADC_DAT[11:0]) has not been read before the new conversion result is loaded to this register, OVis set to 1. It is cleared by hardware after the ADC_DATx register is read.</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Data in RESULT (ADC_DAT[11:0]) is recent conversion result</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Data in RESULT (ADC_DAT[11:0]) overwrote</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="ADC_DAT0">
          <name>ADC_DAT1</name>
          <displayName>ADC_DAT1</displayName>
          <description>A/D Data Register 1</description>
          <addressOffset>0x4</addressOffset>
       </register>
       <register derivedFrom="ADC_DAT0">
          <name>ADC_DAT2</name>
          <displayName>ADC_DAT2</displayName>
          <description>A/D Data Register 2</description>
          <addressOffset>0x8</addressOffset>
       </register>
       <register derivedFrom="ADC_DAT0">
          <name>ADC_DAT3</name>
          <displayName>ADC_DAT3</displayName>
          <description>A/D Data Register 3</description>
          <addressOffset>0xC</addressOffset>
       </register>
       <register derivedFrom="ADC_DAT0">
          <name>ADC_DAT4</name>
          <displayName>ADC_DAT4</displayName>
          <description>A/D Data Register 4</description>
          <addressOffset>0x10</addressOffset>
       </register>
       <register derivedFrom="ADC_DAT0">
          <name>ADC_DAT5</name>
          <displayName>ADC_DAT5</displayName>
          <description>A/D Data Register 5</description>
          <addressOffset>0x14</addressOffset>
       </register>
       <register derivedFrom="ADC_DAT0">
          <name>ADC_DAT6</name>
          <displayName>ADC_DAT6</displayName>
          <description>A/D Data Register 6</description>
          <addressOffset>0x18</addressOffset>
       </register>
       <register derivedFrom="ADC_DAT0">
          <name>ADC_DAT7</name>
          <displayName>ADC_DAT7</displayName>
          <description>A/D Data Register 7</description>
          <addressOffset>0x1C</addressOffset>
       </register>
       <register derivedFrom="ADC_DAT0">
          <name>ADC_DAT12</name>
          <displayName>ADC_DAT12</displayName>
          <description>A/D Data Register 12</description>
          <addressOffset>0x30</addressOffset>
       </register>
       <register derivedFrom="ADC_DAT0">
          <name>ADC_DAT13</name>
          <displayName>ADC_DAT13</displayName>
          <description>A/D Data Register 13</description>
          <addressOffset>0x34</addressOffset>
       </register>
       <register derivedFrom="ADC_DAT0">
          <name>ADC_DAT14</name>
          <displayName>ADC_DAT14</displayName>
          <description>A/D Data Register 14</description>
          <addressOffset>0x38</addressOffset>
       </register>
       <register derivedFrom="ADC_DAT0">
          <name>ADC_DAT15</name>
          <displayName>ADC_DAT15</displayName>
          <description>A/D Data Register 15</description>
          <addressOffset>0x3C</addressOffset>
       </register>
       <register derivedFrom="ADC_DAT0">
          <name>ADC_DAT16</name>
          <displayName>ADC_DAT16</displayName>
          <description>A/D Data Register 16</description>
          <addressOffset>0x40</addressOffset>
       </register>
       <register derivedFrom="ADC_DAT0">
          <name>ADC_DAT17</name>
          <displayName>ADC_DAT17</displayName>
          <description>A/D Data Register 17</description>
          <addressOffset>0x44</addressOffset>
       </register>
       <register>
          <name>ADC_CTL</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>ADC_CTL</displayName>
          <description>A/D Control Register</description>
          <addressOffset>0x48</addressOffset>
          <access>read-write</access>
          <resetValue>0x0A0D0000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ADCEN</name>
              <description>A/D Converter EnableBit\nNote: Before starting A/D conversion function, this bit should be set to 1. Clear it to 0 to disable A/D converter analog circuit to save power consumption.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>A/D Converter Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>A/D Converter Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ADCIEN</name>
              <description>A/D Interrupt EnableBit\nA/D conversion end interrupt request is generated if ADCIEN(ADC_CTL[1]) bit is set to 1.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>A/D interrupt function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>A/D interrupt function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ADMD</name>
              <description>A/D Converter Operation Mode</description>
              <bitOffset>2</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Single conversion</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reserved</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Single-cycle scan</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Continuous scan</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>HWTRGSEL</name>
              <description>Hardware Trigger Source Select Bit\nIn hardware trigger mode, ADC starts to convert by the external trigger from STADC pin or PWM trigger.\nNote:Software should disable HWTRGEN (ADC_CTL[8]) and clear SWTRG (ADC_CTL[11]) before change HWTRGSEL (ADC_CTL[5:4]).</description>
              <bitOffset>4</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>A/D conversion is started by external STADC pin</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reserved</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Reserved</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>A/D conversion is started by PWM0 trigger</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>HWTRGCOND</name>
              <description>Hardware External Trigger Condition\nThese two bits decide external pin STADC trigger event is level or edge. The signal must be kept at stable state at least 8 PCLKs for level trigger and 4 PCLKs at high and low state.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Low level</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>High level</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Falling edge</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Rising edge</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>HWTRGEN</name>
              <description>Hardware External Trigger EnableBit\nEnable or disable triggering of A/D conversion by external STADC pin. If external trigger is enabled, ADC starts to convert by the selected hardware trigger source.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>External trigger Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>External trigger Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PTEN</name>
              <description>PDMA Transfer EnableBit\nWhen A/D conversion is completed, the converted data is loaded into ADC_DATx, software can enable this bit to generate a PDMA data transfer request.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PDMA data transfer Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PDMA data transfer in ADC_DATx Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DIFF</name>
              <description>Differential Mode Selection\nNote: Calibration should calibrated each time when switching between single-ended and differential mode.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>ADC is operated in single-ended mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>ADC is operated in differential mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SWTRG</name>
              <description>Software Trigger A/D Conversion Start\nADC can be start to convert from three sources: software write, external pin STADC and PWM trigger. SWTRG(ADC_CTL[11]) is cleared to 0 by hardware automatically at the end of single mode and single-cycle scan mode on specified channels. In continuous scan mode, A/D conversion is continuously performed sequentially unless software writes 0 to this bit or chip reset.\nNote: After ADC conversion is done, SW needs to wait at least one ADC clock before to set this bit high again.</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Conversion stopped and A/D converter enter idle state</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Conversion starts</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TMSEL</name>
              <description>Select A/D Enable Time-out Source\nSelects one of four timer events sourceto trigger ADC starts to convert.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>TMR0</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>TMR1</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>TMR2</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>TMR3</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TMTRGMOD</name>
              <description>Timer Event Trigger ADC Conversion Mode\nNote1: setting TMSEL (ADC_CTL[13:12]) to select timer event from timer0~3.\nNote2:If timer event is used as ADC trigger source, ADCEN (ADC_CTL[0]) needs to be disabled.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Timer event trigger ADC conversion disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>ADC can be start to conversion by timer out event</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>REFSEL</name>
              <description>Reference Voltage Source Selection</description>
              <bitOffset>16</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Select</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Select</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Select</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Reserved</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RESSEL</name>
              <description>Resolution Selection</description>
              <bitOffset>18</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>6-bit. ADC result will put at RESULT(ADC_DATx[5:0])</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>8-bit. ADC result will put at RESULT(ADC_DATx[7:0])</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>10-bit. ADC result will put at RESULT(ADC_DATx[9:0])</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>12-bit. ADC result will put at RESULT(ADC_DATx[11:0])</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TMPDMACNT</name>
              <description>Timer Event PDMA Count\nWhen each timer event occur PDMA will transfer TMPDMACNT +1 ADC result in the amount of this register setting.\nNote: The total amount of PDMA transferring data should be set in PDMA byte count register. When PDMA finish is set, ADC will not be enabled and will start transfer even though the timer event occurred.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>ADC_CHEN</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>ADC_CHEN</displayName>
          <description>A/D Channel Enable Register</description>
          <addressOffset>0x4C</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CHEN0</name>
              <description>Analog Input Channel 0 Enable Bit (Convert Input Voltage From PA.0)\nNote:If software enables more than one channel, the channel with the smallest number will be selected and the other enabled channels will be ignored.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Channel 0 Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Channel 0 Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CHEN1</name>
              <description>Analog Input Channel 1 EnableBit (Convert Input Voltage From PA.1)</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Channel 1 Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Channel 1 Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CHEN2</name>
              <description>Analog Input Channel 2 EnableBit (Convert Input Voltage From PA.2)</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Channel 2 Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Channel 2 Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CHEN3</name>
              <description>Analog Input Channel 3 EnableBit (Convert Input Voltage From PA.3)</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Channel 3 Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Channel 3 Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CHEN4</name>
              <description>Analog Input Channel 4 EnableBit (Convert Input Voltage From PA.4)</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Channel 4 Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Channel 4 Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CHEN5</name>
              <description>Analog Input Channel 5 EnableBit (Convert Input Voltage From PA.5)</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Channel 5 Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Channel 5 Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CHEN6</name>
              <description>Analog Input Channel 6 EnableBit (Convert Input Voltage From PA.6)</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Channel 6 Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Channel 6 Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CHEN7</name>
              <description>Analog Input Channel 7 EnableBit (Convert Input Voltage From PA.7)</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Channel 7 Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Channel 7 Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CHEN12</name>
              <description>Analog Input Channel 12 Enable Bit (Convert VBG)</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Channel 12 Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Channel 12 Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CHEN13</name>
              <description>Analog Input Channel 13 Enable Bit (Convert VBAT)</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Channel 13 Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Channel 13 Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CHEN14</name>
              <description>Analog Input Channel 14 EnableBit (Convert VTEMP)</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Channel 14 Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Channel 14 Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CHEN15</name>
              <description>Analog Input Channel 15 EnableBit (Convert Int_VREF)</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Channel 15 Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Channel 15 Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CHEN16</name>
              <description>Analog Input Channel 16 EnableBit (Convert AVDD)</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Channel 16 Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Channel 16 Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CHEN17</name>
              <description>Analog Input Channel 17 EnableBit (ConvertAVSS)</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Channel 17 Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Channel 17 Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>ADC_CMP0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>ADC_CMP0</displayName>
          <description>A/D Compare Register 0</description>
          <addressOffset>0x50</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ADCMPEN</name>
              <description>A/D Compare EnableBit\nSet 1 to this bit to enable comparing CMPDAT (ADC_CMPx[27:16]) with specified channel conversion results when converted data is loaded into the ADC_DATx register.\nNote:When this bit is set to 1 and CMPMCNT (ADC_CMPx[11:8]) is 0, the ADCMPFx (ADC_STATUS[2:1]) will be set once the match is hit.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Compare function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Compare function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ADCMPIE</name>
              <description>A/D Compare Interrupt EnableBit\nIf the compare function is enabled and the compare condition matches the setting of CMPCOND (ADC_CMPx[2]) and CMPMCNT (ADC_CMPx[11:8]), ADCMPFx(ADC_STATUS[2:1]) bit will be asserted, in the meanwhile, if ADCMPIE(ADC_CMPx[1]) is set to 1, a compare interrupt request will generate.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Compare function interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Compare function interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CMPCOND</name>
              <description>Compare Condition\nNote: When the internal counter reaches the value to (CMPMATCNT +1), the ADCMPFx (ADC_STATUS[2:1]) bit will be set.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Set the compare condition as that when a A/D conversion result is less than the CMPDAT(ADC_CMPx[27:16]), the internal match counter will increase one</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Set the compare condition as that when a A/D conversion result is more than or equal to the CMPDAT(ADC_CMPx[27:16]), the internal match counter will increase one</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CMPCH</name>
              <description>Compare Channel Selection\nSet this field to select which channel's result to be compared.\nNote: Valid setting of this field is channel 0~17, but channel 8~12 are reserved.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CMPMCNT</name>
              <description>Compare Match Count\nWhen the specified A/D channel analog conversion result matches the compare condition defined by CMPCOND (ADC_CMPx[2]), the internal match counter will increase 1. \nNote:When the internal counter reaches the value to (CMPMCNT+1), the ADCMPFx (ADC_STATUS[2:1]) bit will be set.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CMPDAT</name>
              <description>Comparison Data\nThe 12 bits data is used to compare with conversion result of specified channel. Software can use it to monitor the external analog input pin voltage variation in scan mode without imposing a load on software.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>12</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="ADC_CMP0">
          <name>ADC_CMP1</name>
          <displayName>ADC_CMP1</displayName>
          <description>A/D Compare Register 1</description>
          <addressOffset>0x54</addressOffset>
       </register>
       <register>
          <name>ADC_STATUS</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>ADC_STATUS</displayName>
          <description>A/D Status Register</description>
          <addressOffset>0x58</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ADIF</name>
              <description>A/D Conversion End Flag\nA status flag that indicates the end of A/D conversion, ADIF (ADC_STATUS[0]) is set to 1 at these two conditions:\nWhen A/D conversion ends in single mode\nWhen A/D conversion ends on all specified channels in scan mode.\nNote: This bit can be cleared to 0 by software writing 1.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ADCMPF0</name>
              <description>A/D Compare Flag0\nWhen the selected channel A/D conversion result meets the setting condition in ADC_CMP0, this bit is set to 1.\nThis flag can be cleared by writing 1 to it.\nNote: This flag can be cleared by software writing 1 to it, when this flag is set, the matching counter will be reset to 0,and continue to count when user writes 1 to clear ADCMPF0 (ADC_STATUS[1]).</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Conversion result in ADC_DATx does not meet the CMPDAT (ADC_CMP0[27:16]) setting</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Conversion result in ADC_DATx meets the CMPDAT (ADC_CMP0[27:16]) setting</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ADCMPF1</name>
              <description>A/D Compare Flag1\nWhen the selected channel A/D conversion result meets the setting condition in ADC_CMP1, this bit is set to 1.\nNote: This flag can be cleared by software writing 1 to it, when this flag is set, the matching counter will be reset to 0,and continue to count when user writes 1 to clear ADCMPF1 (ADC_STATUS[2]).</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Conversion result in ADC_DATx does not meet the CMPDAT (ADC_CMP1[27:16]) setting</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Conversion result in ADC_DATx meets the CMPDAT (ADC_CMP1[27:16]) setting</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BUSY</name>
              <description>BUSY/IDLE(Read Only)\nNote:This bit is mirror of SWTRG (ADC_CTL [11]) bit.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>A/D converter is in idle state</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>A/D converter is busy at conversion</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>CHANNEL</name>
              <description>Current Conversion Channel(Read Only)</description>
              <bitOffset>4</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>INITRDY</name>
              <description>ADC Initial Ready by Power-up Sequence Completed\nNote: This bit will be set after system reset occurred and automatically cleared by power-up event.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>ADC not powered up after system reset</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>ADC has been powered up since the last system reset</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>ADC_PDMA</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>ADC_PDMA</displayName>
          <description>A/D PDMA Current Transfer Data Register</description>
          <addressOffset>0x60</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>AD_PDMA</name>
              <description>ADC PDMA Current Transfer Data(Read Only)\nDuring PDMAtransfer, reading these bits can monitor the current PDMA transfer data.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>12</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>ADC_PWD</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>ADC_PWD</displayName>
          <description>A/D Power Management Register</description>
          <addressOffset>0x64</addressOffset>
          <access>read-write</access>
          <resetValue>0x0001E102</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PWUPRDY</name>
              <description>ADC Power-up Sequence Completed and Ready for Conversion</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>ADC is not ready for conversion, itmay be in power saving state or in the progress of power up</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>ADC is ready for conversion</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PWDCALEN</name>
              <description>Power Up Calibration Function EnableBit\nNote:This bit works together with CALSEL (ADC_CALCTL[3]),see the following\n{PWDCALEN,CALFBSEL}Description:\nPWDCALEN is 0 and CALFBSEL is 0: No need to calibrate. \nPWDCALEN is 0 and CALFBSEL is 1: No need to calibrate.\nPWDCALEN is 1 and CALFBSEL is 0: Load calibration word when power up.\nPWDCALEN is 1 and CALFBSEL is 1: Calibrate when power up.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Power up without calibration</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Power up with calibration</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PWDMOD</name>
              <description>ADC Power Saving Mode\nSet this bit fields to select ADC power saving mode.\nNote1: Different power saving mode has different power down/up sequence.To avoid ADC powering up with wrong sequence, user must keep PWMOD (ADC_PWD[3:2]) consistent each time in power down and power up. \nNote2:While the ADC is powered up from power saving mode (set to 00b/01b/11b) without calibration, the PWDCALEN(ADC_PWD[1]) is set to 0, and the calibration value will be reset.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Reserved</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>ADC Power-down mode</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>ADC Standby mode</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Reserved</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>ADC_CALCTL</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>ADC_CALCTL</displayName>
          <description>A/D Calibration Control Register</description>
          <addressOffset>0x68</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000009</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CALEN</name>
              <description>Calibration Function EnableBit\nEnable this bit to turn on the calibration function block.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Bypass calibrationfunctionalblock</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enabledcalibrationfunctionalblock</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CALSTART</name>
              <description>Calibration Functional Block Start</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Stops calibration functional block</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Starts calibration functional block</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CALDONE</name>
              <description>Calibrate Functional Block Done\nNote:This bit is set by hardware and auto cleard by hardware, This bit can also be cleared by software writing 1.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Not yet</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Selected calibrationfunctional block complete</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CALSEL</name>
              <description>Calibration Functional Block Selection</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Load calibration functional block</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Calibration functional block</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>ADC_CALWORD</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>ADC_CALWORD</displayName>
          <description>A/D Calibration Load word Register</description>
          <addressOffset>0x6C</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFF00</resetMask>
          <fields>
            <field>
              <name>CALWORD</name>
              <description>Calibration Word Bits\nWrite to this register with the previous calibration word before load calibration action, read this register after calibration done.\nNote:The calibration block contains two parts "CALIBRATION" and "LOAD CALIBRATION"; if thecalibration block configure as "CALIBRATION"; then this register represent the result of calibration when calibration is completed; if configure as "LOAD CALIBRATION" ; configure this register before loading calibration action, after loading calibration complete, the loaded calibration word will apply to the ADC;while in loading calibration function the loaded value will not be equal to the original CALWORD until calibration is done.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>7</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>ADC_EXTSMPT0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>ADC_EXTSMPT0</displayName>
          <description>A/D Sampling Time Counter Register 0</description>
          <addressOffset>0x70</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>EXTSMPT_CH0</name>
              <description>Additional ADC Sample Clockfor Channel 0\nIf the ADC input is unstable, user can set this register to increase the sampling time to get a stable ADC input signal. The default sampling time is 1 ADC clocks. The additional clock number will be inserted to lengthen the sampling clock.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Number of additional clock cycles is 0</description>
                    <value>0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Number of additional clock cycles is 1</description>
                    <value>1</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Number of additional clock cycles is 2</description>
                    <value>2</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Number of additional clock cycles is 4</description>
                    <value>3</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>4</name>
                    <description>Number of additional clock cycles is 8</description>
                    <value>4</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>5</name>
                    <description>Number of additional clock cycles is 16</description>
                    <value>5</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>6</name>
                    <description>Number of additional clock cycles is 32</description>
                    <value>6</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>7</name>
                    <description>Number of additional clock cycles is 64</description>
                    <value>7</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>8</name>
                    <description>Number of additional clock cycles is 128</description>
                    <value>8</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>9</name>
                    <description>Number of additional clock cycles is 256</description>
                    <value>9</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>10</name>
                    <description>Number of additional clock cycles is 512</description>
                    <value>10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>11</name>
                    <description>Number of additional clock cycles is 1024</description>
                    <value>11</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>12</name>
                    <description>Number of additional clock cycles is 1024</description>
                    <value>12</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>13</name>
                    <description>Number of additional clock cycles is 1024</description>
                    <value>13</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>14</name>
                    <description>Number of additional clock cycles is 1024</description>
                    <value>14</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>15</name>
                    <description>Number of additional clock cycles is 1024</description>
                    <value>15</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>EXTSMPT_CH1</name>
              <description>Additional ADC Sample Clockfor Channel 1\nThe same as channel 0 description.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EXTSMPT_CH2</name>
              <description>Additional ADC Sample Clockfor Channel 2\nThe same as channel 0 description.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EXTSMPT_CH3</name>
              <description>Additional ADC Sample Clockfor Channel 3\nThe same as channel 0 description.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EXTSMPT_CH4</name>
              <description>Additional ADC Sample Clockfor Channel 4\nThe same as channel 0 description.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EXTSMPT_CH5</name>
              <description>Additional ADC Sample Clockfor Channel 5\nThe same as channel 0 description.</description>
              <bitOffset>20</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EXTSMPT_CH6</name>
              <description>Additional ADC Sample Clockfor Channel 6\nThe same as channel 0 description.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EXTSMPT_CH7</name>
              <description>Additional ADC Sample Clockfor Channel 7\nThe same as channel 0 description.</description>
              <bitOffset>28</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>ADC_EXTSMPT1</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>ADC_EXTSMPT1</displayName>
          <description>A/D Sampling Time Counter Register 1</description>
          <addressOffset>0x74</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>EXTSMPT_INTCH</name>
              <description>Additional ADC Sample Clock for Internal Channel (VTEMP, AVDD, AVSS, Int_VREF, VBAT, VBG)\nThe same as channel 0 description.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>ACMP0</name>
      <description>ACMP0 Register Map</description>
      <groupName>ACMP0</groupName>
      <baseAddress>0x401D0000</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x0</offset>
        <size>0xC</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>ACMP_CTL0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>ACMP_CTL0</displayName>
          <description>Analog Comparator 0 Control Register</description>
          <addressOffset>0x0</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ACMPEN</name>
              <description>Comparator Enable Bit</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Comparator 0 Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Comparator 0 Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ACMPIE</name>
              <description>Comparator Interrupt Enable Bit</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Comparator 0 interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Comparator 0 interrupt Enabled. If WKEN (ACMP_CTL0[31]) is set to 1, the wake-up interrupt function will be enabled as well</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>HYSEN</name>
              <description>Comparator Hysteresis Enable Bit</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Comparator 0 hysteresis Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Comparator 0 hysteresis Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>NEGSEL</name>
              <description>Comparator Negative Input Selection</description>
              <bitOffset>4</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>ACMP0_N pin</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Internal comparator reference voltage (CRV)</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Internal reference voltage (Int_VREF)</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>AVSS pin</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>WKEN</name>
              <description>Power-down Wake-up Enable Bit</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Wake-up function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Wake-up function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>ACMP_STATUS</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>ACMP_STATUS</displayName>
          <description>Analog Comparator Status Register</description>
          <addressOffset>0x4</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ACMPIF</name>
              <description>ComparatorInterrupt Flag\nThis bit is set by hardware whenever the comparator 0 output changes state. This will generate an interrupt if ACMPIE (ACMP_CTL0[1]) is set to 1\nNote: Write "1" to clear this bit to 0.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ACMPO</name>
              <description>ComparatorOutput\nSynchronized to the PCLK to allow reading by software. Cleared when the comparator 0 is disabled, i.e. ACMPEN (ACMP_CTL0[0]) is cleared to 0.\nNote: This bit is read only.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>ACMP_VREF</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>ACMP_VREF</displayName>
          <description>Analog Comparator Reference Voltage Control Register</description>
          <addressOffset>0x8</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CRVCTL</name>
              <description>Comparator Reference Voltage Setting</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CRVEN</name>
              <description>CRV Enable Bit</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>CRV Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>CRV Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CRVSSEL</name>
              <description>CRV Source Voltage Selection</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>VDDA is selected as CRV source voltage</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The reference voltage defined by SYS_VREFCTL register is selected as CRV source voltage</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
      </registers>
    </peripheral>
  </peripherals>
</device>
