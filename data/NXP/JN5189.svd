<?xml version="1.0" encoding="UTF-8"?>
<device schemaVersion="1.3" xmlns:xs="http://www.w3.org/2001/XMLSchema-instance" xs:noNamespaceSchemaLocation="CMSIS-SVD.xsd">
  <vendor>nxp.com</vendor>
  <name>JN5189</name>
  <version>1.0</version>
  <description>JN5189HN,JN5189THN</description>
  <licenseText>
Copyright 2016-2020 NXP
All rights reserved.

SPDX-License-Identifier: BSD-3-Clause
  </licenseText>
  <cpu>
    <name>CM4</name>
    <revision>r0p1</revision>
    <endian>little</endian>
    <mpuPresent>true</mpuPresent>
    <fpuPresent>false</fpuPresent>
    <vtorPresent>true</vtorPresent>
    <nvicPrioBits>3</nvicPrioBits>
    <vendorSystickConfig>false</vendorSystickConfig>
  </cpu>
  <addressUnitBits>8</addressUnitBits>
  <width>32</width>
  <peripherals>
    <peripheral>
      <name>SYSCON</name>
      <description>This is the description of component syscon. It is the System Control APB bus interface. More details will follow.</description>
      <groupName>SYSCON</groupName>
      <baseAddress>0x40000000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>0xFF4</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>MEMORYREMAP</name>
          <description>Memory Remap control register</description>
          <addressOffset>0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xE400000</resetValue>
          <resetMask>0xFF7F7FF</resetMask>
          <fields>
            <field>
              <name>MAP</name>
              <description>Select the location of the vector table : 0: Vector Table in ROM. 1: Vector Table in RAM. 2: Vector Table in Flash. 3: Vector Table in Flash.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>QSPI_REMAP_APP_0</name>
              <description>Address bits to use when QSPI Flash address [19:18] = 0 (256-KB unit page). Setting 00 gives no remapping.</description>
              <bitOffset>20</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>QSPI_REMAP_APP_1</name>
              <description>Address bits to use when QSPI Flash address [19:18] = 1 (256-KB unit page). Setting 01 gives no remapping.</description>
              <bitOffset>22</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>QSPI_REMAP_APP_2</name>
              <description>Address bits to use when QSPI Flash address [19:18] = 2 (256-KB unit page). Setting 10 gives no remapping.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>QSPI_REMAP_APP_3</name>
              <description>Address bits to use when QSPI Flash address [19:18] = 3 (256-KB unit page). Setting 11 gives no remapping.</description>
              <bitOffset>26</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>AHBMATPRIO</name>
          <description>AHB Matrix priority control register</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>AHBMATPRIO</name>
              <description>AHB Matrix priority control register</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SYSTCKCAL</name>
          <description>System tick counter calibration</description>
          <addressOffset>0x40</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0x3FFFFFF</resetMask>
          <fields>
            <field>
              <name>CAL</name>
              <description>Cortex System tick timer calibration value, readable from Cortex SYST_CALIB.TENMS register field. Set this value to be the number of clock periods to give 10ms period. SYSTICK freq is a function of the mainclk and SYSTICKCLKDIV register. If the tick timer is configured to use the System clock directly then this value must reflect the 10ms tick count for that clock.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SKEW</name>
              <description>Cortex System tick timer SYST_CALIB.SKEW setting. When 0, the value of SYST_CALIB.TENMS field is considered to be precise. When 1, the value of TENMS is not considered to be precise.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>NOREF</name>
              <description>Cortex System tick timer SYST_CALIB.NOREF setting. When 0, a separate reference clock is available. When 1, a separate reference clock is not available.</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>NMISRC</name>
          <description>NMI Source Select</description>
          <addressOffset>0x48</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0x8000003F</resetMask>
          <fields>
            <field>
              <name>IRQM40</name>
              <description>The number of the interrupt source within the interrupt array that acts as the Non-Maskable Interrupt (NMI) for the Cortex-M4, if enabled by NMIENM40. This can also cause the device to wakeup from sleep.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>NMIENM40</name>
              <description>Write a 1 to this bit to enable the Non-Maskable Interrupt (NMI) source selected by IRQM40. The NMI Interrupt should be disabled before changing the source selection (IRQM40)</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ASYNCAPBCTRL</name>
          <description>Asynchronous APB Control</description>
          <addressOffset>0x4C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0x1</resetMask>
          <fields>
            <field>
              <name>ENABLE</name>
              <description>Enables the asynchronous APB bridge and subsystem</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PRESETCTRL0</name>
          <description>Peripheral reset control 0</description>
          <alternateGroup>PRESETCTRL</alternateGroup>
          <addressOffset>0x100</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0x1BFC7D00</resetMask>
          <fields>
            <field>
              <name>SPIFI_RST</name>
              <description>Quad SPI Flash controller reset control. 0: Clear reset to this function. 1: Assert reset to this function.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_RST</name>
              <description>Input Mux reset control. 0: Clear reset to this function. 1: Assert reset to this function.</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>IOCON_RST</name>
              <description>I/O controller reset control. 0: Clear reset to this function. 1: Assert reset to this function.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO_RST</name>
              <description>GPIO reset control. 0: Clear reset to this function. 1: Assert reset to this function.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PINT_RST</name>
              <description>Pin interrupt (PINT) reset control. 0: Clear reset to this function. 1: Assert reset to this function.</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GINT_RST</name>
              <description>Group interrupt (GINT) reset control. 0: Clear reset to this function. 1: Assert reset to this function.</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DMA_RST</name>
              <description>DMA reset control. 0: Clear reset to this function. 1: Assert reset to this function.</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ISO7816_RST</name>
              <description>ISO7816 reset control. 0: Clear reset to this function. 1: Assert reset to this function.</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>WWDT_RST</name>
              <description>Watchdog Timer reset control. 0: Clear reset to this function. 1: Assert reset to this function.</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RTC_RST</name>
              <description>Real Time Clock (RTC) reset control. 0: Clear reset to this function. 1: Assert reset to this function.</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ANA_INT_CTRL_RST</name>
              <description>Analog Modules Interrupt Controller reset control. 0: Clear reset to this function. 1: Assert reset to this function.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>WAKE_UP_TIMERS_RST</name>
              <description>Wake up Timers reset control. 0: Clear reset to this function. 1: Assert reset to this function. This will clear interrupt status flag. However, configuration for wake timers that is in SYSCON will not be reset, these should be managed through the SYSCON regsiters.</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ADC_RST</name>
              <description>ADC reset control. 0: Clear reset to this function. 1: Assert reset to this function.</description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PRESETCTRLS0</name>
          <description>Pin assign register</description>
          <alternateGroup>PRESETCTRL</alternateGroup>
          <addressOffset>0x100</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xFFFFFFFF</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DATA</name>
              <description>no description available</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PRESETCTRL1</name>
          <description>Peripheral reset control 1</description>
          <alternateGroup>PRESETCTRL</alternateGroup>
          <addressOffset>0x104</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0xFBFF800</resetMask>
          <fields>
            <field>
              <name>USART0_RST</name>
              <description>UART0 reset control. 0: Clear reset to this function. 1: Assert reset to this function.</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>USART1_RST</name>
              <description>UART1 reset control. 0: Clear reset to this function. 1: Assert reset to this function.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C0_RST</name>
              <description>I2C0 reset control. 0: Clear reset to this function. 1: Assert reset to this function.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C1_RST</name>
              <description>I2C1 reset control. 0: Clear reset to this function. 1: Assert reset to this function.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SPI0_RST</name>
              <description>SPI0 reset control. 0: Clear reset to this function. 1: Assert reset to this function.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SPI1_RST</name>
              <description>SPI1 reset control. 0: Clear reset to this function. 1: Assert reset to this function.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>IR_RST</name>
              <description>Infra Red reset control. 0: Clear reset to this function. 1: Assert reset to this function.</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PWM_RST</name>
              <description>PWM reset control. 0: Clear reset to this function. 1: Assert reset to this function.</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RNG_RST</name>
              <description>Random Number Generator reset control. 0: Clear reset to this function. 1: Assert reset to this function.</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C2_RST</name>
              <description>I2C2 reset control. 0: Clear reset to this function. 1: Assert reset to this function.</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ZIGBEE_RST</name>
              <description>Zigbee reset control. 0: Clear reset to this function. 1: Assert reset to this function.</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MODEM_MASTER_RST</name>
              <description>MODEM AHB Master Interface reset control. 0: Clear reset to this function. 1: Assert reset to this function.</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>AES_RST</name>
              <description>AES256 reset control. 0: Clear reset to this function. 1: Assert reset to this function.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RFP_RST</name>
              <description>RFP (Radio controller) reset control. 0: Clear reset to this function. 1: Assert reset to this function.</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DMIC_RST</name>
              <description>DMIC Reset control. 0: Clear reset to this function. 1: Assert reset to this function.</description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>HASH_RST</name>
              <description>HASH reset control. 0: Clear reset to this function. 1: Assert reset to this function.</description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PRESETCTRLS1</name>
          <description>Pin assign register</description>
          <alternateGroup>PRESETCTRL</alternateGroup>
          <addressOffset>0x104</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xFFFFFFFF</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DATA</name>
              <description>no description available</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PRESETCTRLSET0</name>
          <description>Set bits in PRESETCTRL0. It is recommended that changes to PRESETCTRL registers be accomplished by using the related PRESETCTRLSET and PRESETCTRLCLR registers.</description>
          <alternateGroup>PRESETCTRLSET</alternateGroup>
          <addressOffset>0x120</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SPIFI_RST_SET</name>
              <description>Writing one to this register sets the SPIFI_RST bit in the PRESETCTRL0 register</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>MUX_RST_SET</name>
              <description>Writing one to this register sets the MUX_RST bit in the PRESETCTRL0 register</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>IOCON_RST_SET</name>
              <description>Writing one to this register sets the IOCON_RST bit in the PRESETCTRL0 register</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>GPIO_RST_SET</name>
              <description>Writing one to this register sets the GPIO_RST bit in the PRESETCTRL0 register</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>PINT_RST_SET</name>
              <description>Writing one to this register sets the PINT_RST bit in the PRESETCTRL0 register</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>GINT_RST_SET</name>
              <description>Writing one to this register sets the GINT_RST bit in the PRESETCTRL0 register</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>DMA_RST_SET</name>
              <description>Writing one to this register sets the DMA_RST bit in the PRESETCTRL0 register</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>ISO7816_RST_SET</name>
              <description>Writing one to this register sets the ISO7816_RST bit in the PRESETCTRL0 register</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>WWDT_RST_SET</name>
              <description>Writing one to this register sets the WWDT_RST bit in the PRESETCTRL0 register</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>RTC_RST_SET</name>
              <description>Writing one to this register sets the RTC_RST bit in the PRESETCTRL0 register</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>ANA_INT_CTRL_RST_SET</name>
              <description>Writing one to this register sets the ANA_INT_CTRL_RST bit in the PRESETCTRL0 register</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>WAKE_UP_TIMERS_RST_SET</name>
              <description>Writing one to this register sets the WAKE_UP_TIMERS bit in the PRESETCTRL0 register</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>ADC_RST_SET</name>
              <description>Writing one to this register sets the ADC_RST bit in the PRESETCTRL0 register</description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PRESETCTRLSETS0</name>
          <description>Pin assign register</description>
          <alternateGroup>PRESETCTRLSET</alternateGroup>
          <addressOffset>0x120</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xFFFFFFFF</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DATA</name>
              <description>no description available</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PRESETCTRLSET1</name>
          <description>Set bits in PRESETCTRL1. It is recommended that changes to PRESETCTRL registers be accomplished by using the related PRESETCTRLSET and PRESETCTRLCLR registers.</description>
          <alternateGroup>PRESETCTRLSET</alternateGroup>
          <addressOffset>0x124</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>USART0_RST_SET</name>
              <description>Writing one to this register sets the UART0_RST bit in the PRESETCTRL1 register</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>USART1_RST_SET</name>
              <description>Writing one to this register sets the UART1_RST bit in the PRESETCTRL1 register</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>I2C0_RST_SET</name>
              <description>Writing one to this register sets the I2C0_RST bit in the PRESETCTRL1 register</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>I2C1_RST_SET</name>
              <description>Writing one to this register sets the I2C1_RST bit in the PRESETCTRL1 register</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>SPI0_RST_SET</name>
              <description>Writing one to this register sets the SPI0_RST bit in the PRESETCTRL1 register</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>SPI1_RST_SET</name>
              <description>Writing one to this register sets the SPI1_RST bit in the PRESETCTRL1 register</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>IR_RST_SET</name>
              <description>Writing one to this register sets the IR_RST bit in the PRESETCTRL1 register</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>PWM_RST_SET</name>
              <description>Writing one to this register sets the PWM_RST bit in the PRESETCTRL1 register</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>RNG_RST_SET</name>
              <description>Writing one to this register sets the RNG_RST bit in the PRESETCTRL1 register</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>I2C2_RST_SET</name>
              <description>Writing one to this register sets the I2C2_RST bit in the PRESETCTRL1 register</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>ZIGBEE_RST_SET</name>
              <description>Writing one to this register sets the ZIGBEE_RST bit in the PRESETCTRL1 register</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>MODEM_MASTER_RST_SET</name>
              <description>Writing one to this register sets the MODEM_MASTER_RST bit in the PRESETCTRL1 register</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>AES_RST_SET</name>
              <description>Writing one to this register sets the AES_RST bit in the PRESETCTRL1 register</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>RFP_RST_SET</name>
              <description>Writing one to this register sets the RFP_RST bit in the PRESETCTRL1 register</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>DMIC_RST_SET</name>
              <description>Writing one to this register sets the DMIC_RST bit in the PRESETCTRL1 register</description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>HASH_RST_SET</name>
              <description>Writing one to this register sets the HASH_RST bit in the PRESETCTRL1 register</description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PRESETCTRLSETS1</name>
          <description>Pin assign register</description>
          <alternateGroup>PRESETCTRLSET</alternateGroup>
          <addressOffset>0x124</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xFFFFFFFF</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DATA</name>
              <description>no description available</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PRESETCTRLCLR0</name>
          <description>Clear bits in PRESETCTRL0. It is recommended that changes to PRESETCTRL registers be accomplished by using the related PRESETCTRLSET and PRESETCTRLCLR registers.</description>
          <alternateGroup>PRESETCTRLCLR</alternateGroup>
          <addressOffset>0x140</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SPIFI_RST_CLR</name>
              <description>Writing one to this register clears the SPIFI_RST bit in the PRESETCTRL0 register</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>MUX_RST_CLR</name>
              <description>Writing one to this register clears the MUX_RST bit in the PRESETCTRL0 register</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>IOCON_RST_CLR</name>
              <description>Writing one to this register clears the IOCON_RST bit in the PRESETCTRL0 register</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>GPIO_RST_CLR</name>
              <description>Writing one to this register clears the GPIO_RST bit in the PRESETCTRL0 register</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>PINT_RST_CLR</name>
              <description>Writing one to this register clears the PINT_RST bit in the PRESETCTRL0 register</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>GINT_RST_CLR</name>
              <description>Writing one to this register clears the GINT_RST bit in the PRESETCTRL0 register</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>DMA_RST_CLR</name>
              <description>Writing one to this register clears the DMA_RST bit in the PRESETCTRL0 register</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>ISO7816_RST_CLR</name>
              <description>Writing one to this register clears the ISO7816_RST bit in the PRESETCTRL0 register</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>WWDT_RST_CLR</name>
              <description>Writing one to this register clears the WWDT_RST bit in the PRESETCTRL0 register</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>RTC_RST_CLR</name>
              <description>Writing one to this register clears the RTC_RST bit in the PRESETCTRL0 register</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>ANA_INT_CTRL_RST_CLR</name>
              <description>Writing one to this register clears the ANA_INT_CTRL_RST bit in the PRESETCTRL0 register</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>WAKE_UP_TIMERS_RST_CLR</name>
              <description>Writing one to this register clears the WAKE_UP_TIMERS_RST bit in the PRESETCTRL0 register</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>ADC_RST_CLR</name>
              <description>Writing one to this register clears the ADC_RST bit in the PRESETCTRL0 register</description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PRESETCTRLCLRS0</name>
          <description>Pin assign register</description>
          <alternateGroup>PRESETCTRLCLR</alternateGroup>
          <addressOffset>0x140</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xFFFFFFFF</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DATA</name>
              <description>no description available</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PRESETCTRLCLR1</name>
          <description>Clear bits in PRESETCTRL1. It is recommended that changes to PRESETCTRL registers be accomplished by using the related PRESETCTRLSET and PRESETCTRLCLR registers.</description>
          <alternateGroup>PRESETCTRLCLR</alternateGroup>
          <addressOffset>0x144</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>USART0_RST_CLR</name>
              <description>Writing one to this register clears the UART0_RST bit in the PRESETCTRL1 register</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>USART1_RST_CLR</name>
              <description>Writing one to this register clears the UART1_RST bit in the PRESETCTRL1 register</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>I2C0_RST_CLR</name>
              <description>Writing one to this register clears the I2C0_RST bit in the PRESETCTRL1 register</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>I2C1_RST_CLR</name>
              <description>Writing one to this register clears the I2C1_RST bit in the PRESETCTRL1 register</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>SPI0_RST_CLR</name>
              <description>Writing one to this register clears the SPI0_RST bit in the PRESETCTRL1 register</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>SPI1_RST_CLR</name>
              <description>Writing one to this register clears the SPI1_RST bit in the PRESETCTRL1 register</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>IR_RST_CLR</name>
              <description>Writing one to this register clears the IR_RST bit in the PRESETCTRL1 register</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>PWM_RST_CLR</name>
              <description>Writing one to this register clears the PWM_RST bit in the PRESETCTRL1 register</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>RNG_RST_CLR</name>
              <description>Writing one to this register clears the RNG_RST bit in the PRESETCTRL1 register</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>I2C2_RST_CLR</name>
              <description>Writing one to this register clears the I2C2_RST bit in the PRESETCTRL1 register</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>ZIGBEE_RST_CLR</name>
              <description>Writing one to this register clears the ZIGBEE_RST bit in the PRESETCTRL1 register</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>MODEM_MASTER_RST_CLR</name>
              <description>Writing one to this register clears the MODEM_MASTER_RST bit in the PRESETCTRL1 register</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>AES_RST_CLR</name>
              <description>Writing one to this register clears the AES_RST bit in the PRESETCTRL1 register</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>RFP_RST_CLR</name>
              <description>Writing one to this register clears the RFP_RST bit in the PRESETCTRL1 register</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>DMIC_RST_CLR</name>
              <description>Writing one to this register clears the DMIC_RST bit in the PRESETCTRL1 register</description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>HASH_RST_CLR</name>
              <description>Writing one to this register clears the HASH_RST bit in the PRESETCTRL1 register</description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PRESETCTRLCLRS1</name>
          <description>Pin assign register</description>
          <alternateGroup>PRESETCTRLCLR</alternateGroup>
          <addressOffset>0x144</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xFFFFFFFF</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DATA</name>
              <description>no description available</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>AHBCLKCTRL0</name>
          <description>AHB Clock control 0</description>
          <alternateGroup>AHBCLKCTRL</alternateGroup>
          <addressOffset>0x200</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x102</resetValue>
          <resetMask>0x1BFC6D1A</resetMask>
          <fields>
            <field>
              <name>SRAM_CTRL0</name>
              <description>Enables the clock for the SRAM Controller 0 (SRAM 0 to SRAM 7). 0: Disable. 1: Enable.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SRAM_CTRL1</name>
              <description>Enables the clock for the SRAM Controller 1 (SRAM 8 to SRAM 11). 0: Disable. 1: Enable.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SPIFI</name>
              <description>Enables the clock for the Quad SPI Flash controller [Note: SPIFI IOs need configuring for high drive]. 0: Disable. 1: Enable.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX</name>
              <description>Enables the clock for the Input Mux. 0: Disable. 1: Enable.</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>IOCON</name>
              <description>Enables the clock for the I/O controller block. 0: Disable. 1: Enable.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO</name>
              <description>Enables the clock for the GPIO. 0: Disable. 1: Enable.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PINT</name>
              <description>Enables the clock for the Pin interrupt block (PINT). 0: Disable. 1: Enable.</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GINT</name>
              <description>Enables the clock for the Group interrupt block (GINT). 0: Disable. 1: Enable.</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DMA</name>
              <description>Enables the clock for the DMA controller. 0: Disable. 1: Enable.</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ISO7816</name>
              <description>Enables the clock for the ISO7816 smart card interface. 0: Disable. 1: Enable.</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>WWDT</name>
              <description>Enables the clock for the Watchdog Timer. 0: Disable. 1: Enable.</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RTC</name>
              <description>Enables the clock for the RTC. 0: Disable. 1: Enable.</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ANA_INT_CTRL</name>
              <description>Enables the clock for the Analog Interrupt Control module (for BOD and comparator status and interrupt control). 0: Disable. 1: Enable.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>WAKE_UP_TIMERS</name>
              <description>Enables the clock for the Wake up Timers. 0: Disable. 1: Enable.</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ADC</name>
              <description>Enables the clock for the ADC Controller. 0: Disable. 1: Enable.</description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>AHBCLKCTRLS0</name>
          <description>Pin assign register</description>
          <alternateGroup>AHBCLKCTRL</alternateGroup>
          <addressOffset>0x200</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xFFFFFFFF</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DATA</name>
              <description>no description available</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>AHBCLKCTRL1</name>
          <description>AHB Clock control 1</description>
          <alternateGroup>AHBCLKCTRL</alternateGroup>
          <addressOffset>0x204</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0xFBFF800</resetMask>
          <fields>
            <field>
              <name>USART0</name>
              <description>Enable the clock for the UART0. 0: Disable. 1: Enable.</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>USART1</name>
              <description>Enable the clock for the UART1. 0: Disable. 1: Enable.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C0</name>
              <description>Enable the clock for the I2C0. 0: Disable. 1: Enable.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C1</name>
              <description>Enable the clock for the I2C1. 0: Disable. 1: Enable.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SPI0</name>
              <description>Enable the clock for the SPI0. 0: Disable. 1: Enable.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SPI1</name>
              <description>Enable the clock for the SPI1. 0: Disable. 1: Enable.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>IR</name>
              <description>Enable the clock for the Infra Red. 0: Disable. 1: Enable.</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PWM</name>
              <description>Enable the clock for the PWM. 0: Disable. 1: Enable.</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RNG</name>
              <description>Enable the clock for the Random Number Generator. 0: Disable. 1: Enable.</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C2</name>
              <description>Enable the clock for the I2C2. 0: Disable. 1: Enable.</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ZIGBEE</name>
              <description>Enable the clock for the Zigbee Modem . 0: Disable. 1: Enable.</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MODEM_MASTER</name>
              <description>Enable the clock for the Modem AHB Master Interface. 0: Disable. 1: Enable.</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>AES</name>
              <description>Enable the clock for the AES. 0: Disable. 1: Enable.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RFP</name>
              <description>Enable the clock for the RFP (Radio Front End controller). 0: Disable. 1: Enable.</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DMIC</name>
              <description>Enable the clock for the DMIC. 0: Disable. 1: Enable.</description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>HASH</name>
              <description>Enable the clock for the Hash. 0: Disable. 1: Enable.</description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>AHBCLKCTRLS1</name>
          <description>Pin assign register</description>
          <alternateGroup>AHBCLKCTRL</alternateGroup>
          <addressOffset>0x204</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xFFFFFFFF</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DATA</name>
              <description>no description available</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>AHBCLKCTRLSET0</name>
          <description>Set bits in AHBCLKCTRL0</description>
          <alternateGroup>AHBCLKCTRLSET</alternateGroup>
          <addressOffset>0x220</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SRAM_CTRL0_CLK_SET</name>
              <description>Writing one to this register sets the SRAM_CTRL0 bit in the AHBCLKCTRL0 register.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>SRAM_CTRL1_CLK_SET</name>
              <description>Writing one to this register sets the SRAM_CTRL1 bit in the AHBCLKCTRL0 register.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>SPIFI_CLK_SET</name>
              <description>Writing one to this register sets the SPIFI bit in the AHBCLKCTRL0 register.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>MUX_CLK_SET</name>
              <description>Writing one to this register sets the MUX bit in the AHBCLKCTRL0 register.</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>IOCON_CLK_SET</name>
              <description>Writing one to this register sets the IOCON bit in the AHBCLKCTRL0 register.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>GPIO_CLK_SET</name>
              <description>Writing one to this register sets the GPIO bit in the AHBCLKCTRL0 register.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>PINT_CLK_SET</name>
              <description>Writing one to this register sets the PINT bit in the AHBCLKCTRL0 register.</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>GINT_CLK_SET</name>
              <description>Writing one to this register sets the GINT bit in the AHBCLKCTRL0 register.</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>DMA_CLK_SET</name>
              <description>Writing one to this register sets the DMA bit in the AHBCLKCTRL0 register.</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>ISO7816_CLK_SET</name>
              <description>Writing one to this register sets the ISO7816 bit in the AHBCLKCTRL0 register.</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>WWDT_CLK_SET</name>
              <description>Writing one to this register sets the WWDT bit in the AHBCLKCTRL0 register.</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>RTC_CLK_SET</name>
              <description>Writing one to this register sets the RTC bit in the AHBCLKCTRL0 register.</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>ANA_INT_CTRL_CLK_SET</name>
              <description>Writing one to this register sets the ANA_INT_CTRL bit in the AHBCLKCTRL0 register.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>WAKE_UP_TIMERS_CLK_SET</name>
              <description>Writing one to this register sets the WAKE_UP_TIMERS bit in the AHBCLKCTRL0 register.</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>ADC_CLK_SET</name>
              <description>Writing one to this register sets the ADC bit in the AHBCLKCTRL0 register.</description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>AHBCLKCTRLSETS0</name>
          <description>Pin assign register</description>
          <alternateGroup>AHBCLKCTRLSET</alternateGroup>
          <addressOffset>0x220</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xFFFFFFFF</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DATA</name>
              <description>no description available</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>AHBCLKCTRLSET1</name>
          <description>Set bits in AHBCLKCTRL1</description>
          <alternateGroup>AHBCLKCTRLSET</alternateGroup>
          <addressOffset>0x224</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>USART0_CLK_SET</name>
              <description>Writing one to this register sets the UART0 bit in the AHBCLKCTRL1 register.</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>USART1_CLK_SET</name>
              <description>Writing one to this register sets the UART1 bit in the AHBCLKCTRL1 register.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>I2C0_CLK_SET</name>
              <description>Writing one to this register sets the I2C0 bit in the AHBCLKCTRL1 register.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>I2C1_CLK_SET</name>
              <description>Writing one to this register sets the I2C1 bit in the AHBCLKCTRL1 register.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>SPI0_CLK_SET</name>
              <description>Writing one to this register sets the SPI0 bit in the AHBCLKCTRL1 register.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>SPI1_CLK_SET</name>
              <description>Writing one to this register sets the SPI1 bit in the AHBCLKCTRL1 register.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>IR_CLK_SET</name>
              <description>Writing one to this register sets the IR bit in the AHBCLKCTRL1 register.</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>PWM_CLK_SET</name>
              <description>Writing one to this register sets the PWM bit in the AHBCLKCTRL1 register.</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>RNG_CLK_SET</name>
              <description>Writing one to this register sets the RNG bit in the AHBCLKCTRL1 register.</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>I2C2_CLK_SET</name>
              <description>Writing one to this register sets the I2C2 bit in the AHBCLKCTRL1 register.</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>ZIGBEE_CLK_SET</name>
              <description>Writing one to this register sets the ZIGBEE bit in the AHBCLKCTRL1 register.</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>MODEM_MASTER_CLK_SET</name>
              <description>Writing one to this register sets the MODEM_MASTER bit in the AHBCLKCTRL1 register.</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>AES_CLK_SET</name>
              <description>Writing one to this register sets the AES bit in the AHBCLKCTRL1 register.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>RFP_CLK_SET</name>
              <description>Writing one to this register sets the RFP bit in the AHBCLKCTRL1 register.</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>DMIC_CLK_SET</name>
              <description>Writing one to this register sets the DMIC bit in the AHBCLKCTRL1 register.</description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>HASH_CLK_SET</name>
              <description>Writing one to this register sets the HASH bit in the AHBCLKCTRL1 register.</description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>AHBCLKCTRLSETS1</name>
          <description>Pin assign register</description>
          <alternateGroup>AHBCLKCTRLSET</alternateGroup>
          <addressOffset>0x224</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xFFFFFFFF</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DATA</name>
              <description>no description available</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>AHBCLKCTRLCLR0</name>
          <description>Clear bits in AHBCLKCTRL0</description>
          <alternateGroup>AHBCLKCTRLCLR</alternateGroup>
          <addressOffset>0x240</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>ROM_CLK_CLR</name>
              <description>Writing one to this register clears the ROM bit in the AHBCLKCTRL0 register.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>SRAM_CTRL0_CLK_CLR</name>
              <description>Writing one to this register clears the SRAM_CTRL0 bit in the AHBCLKCTRL0 register.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>SRAM_CTRL1_CLK_CLR</name>
              <description>Writing one to this register clears the SRAM_CTRL1 bit in the AHBCLKCTRL0 register.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>FLASH_CLK_CLR</name>
              <description>Writing one to this register clears the FLASH bit in the AHBCLKCTRL0 register.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>SPIFI_CLK_CLR</name>
              <description>Writing one to this register clears the SPIFI bit in the AHBCLKCTRL0 register.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>MUX_CLK_CLR</name>
              <description>Writing one to this register clears the MUX bit in the AHBCLKCTRL0 register.</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>IOCON_CLK_CLR</name>
              <description>Writing one to this register clears the IOCON bit in the AHBCLKCTRL0 register.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>GPIO_CLK_CLR</name>
              <description>Writing one to this register clears the GPIO bit in the AHBCLKCTRL0 register.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>PINT_CLK_CLR</name>
              <description>Writing one to this register clears the PINT bit in the AHBCLKCTRL0 register.</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>GINT_CLK_CLR</name>
              <description>Writing one to this register clears the GINT bit in the AHBCLKCTRL0 register.</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>DMA_CLK_CLR</name>
              <description>Writing one to this register clears the DMA bit in the AHBCLKCTRL0 register.</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>ISO7816_CLK_CLR</name>
              <description>Writing one to this register clears the ISO7816 bit in the AHBCLKCTRL0 register.</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>WWDT_CLK_CLR</name>
              <description>Writing one to this register clears the WWDT bit in the AHBCLKCTRL0 register.</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>RTC_CLK_CLR</name>
              <description>Writing one to this register clears the RTC bit in the AHBCLKCTRL0 register.</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>ANA_INT_CTRL_CLK_SET</name>
              <description>Writing one to this register clears the ANA_INT_CTRL bit in the AHBCLKCTRL0 register.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>WAKE_UP_TIMERS_CLK_SET</name>
              <description>Writing one to this register clears the WAKE_UP_TIMERS bit in the AHBCLKCTRL0 register.</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>ADC_CLK_CLR</name>
              <description>Writing one to this register clears the ADC bit in the AHBCLKCTRL0 register.</description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>EFUSE_CLK_CLR</name>
              <description>Writing one to this register clears the EFUSE bit in the AHBCLKCTRL0 register.</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>AHBCLKCTRLCLRS0</name>
          <description>Pin assign register</description>
          <alternateGroup>AHBCLKCTRLCLR</alternateGroup>
          <addressOffset>0x240</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xFFFFFFFF</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DATA</name>
              <description>no description available</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>AHBCLKCTRLCLR1</name>
          <description>Clear bits in AHBCLKCTRL1</description>
          <alternateGroup>AHBCLKCTRLCLR</alternateGroup>
          <addressOffset>0x244</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>USART0_CLK_CLR</name>
              <description>Writing one to this register clears the UART0 bit in the AHBCLKCTRL1 register.</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>USART1_CLK_CLR</name>
              <description>Writing one to this register clears the UART1 bit in the AHBCLKCTRL1 register.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>I2C0_CLK_CLR</name>
              <description>Writing one to this register clears the I2C0 bit in the AHBCLKCTRL1 register.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>I2C1_CLK_CLR</name>
              <description>Writing one to this register clears the I2C1 bit in the AHBCLKCTRL1 register.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>SPI0_CLK_CLR</name>
              <description>Writing one to this register clears the SPI0 bit in the AHBCLKCTRL1 register.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>SPI1_CLK_CLR</name>
              <description>Writing one to this register clears the SPI1 bit in the AHBCLKCTRL1 register.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>IR_CLK_CLR</name>
              <description>Writing one to this register clears the IR bit in the AHBCLKCTRL1 register.</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>PWM_CLK_CLR</name>
              <description>Writing one to this register clears the PWM bit in the AHBCLKCTRL1 register.</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>RNG_CLK_CLR</name>
              <description>Writing one to this register clears the RNG bit in the AHBCLKCTRL1 register.</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>I2C2_CLK_CLR</name>
              <description>Writing one to this register clears the I2C2 bit in the AHBCLKCTRL1 register.</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>ZIGBEE_CLK_CLR</name>
              <description>Writing one to this register clears the ZIGBEE bit in the AHBCLKCTRL1 register.</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>MODEM_MASTER_CLK_CLR</name>
              <description>Writing one to this register clears the MODEM_MASTER bit in the AHBCLKCTRL1 register.</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>AES_CLK_CLR</name>
              <description>Writing one to this register clears the AES bit in the AHBCLKCTRL1 register.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>RFP_CLK_CLR</name>
              <description>Writing one to this register clears the RFP bit in the AHBCLKCTRL1 register.</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>DMIC_CLK_CLR</name>
              <description>Writing one to this register clears the DMIC bit in the AHBCLKCTRL1 register.</description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>HASH_CLK_CLR</name>
              <description>Writing one to this register clears the HASH bit in the AHBCLKCTRL1 register.</description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>AHBCLKCTRLCLRS1</name>
          <description>Pin assign register</description>
          <alternateGroup>AHBCLKCTRLCLR</alternateGroup>
          <addressOffset>0x244</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xFFFFFFFF</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DATA</name>
              <description>no description available</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MAINCLKSEL</name>
          <description>Main clock source select</description>
          <addressOffset>0x280</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0x7</resetMask>
          <fields>
            <field>
              <name>SEL</name>
              <description>Main clock source selection:</description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>FRO12M</name>
                  <description>12 MHz free running oscillator (FRO)</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>XTAL32M</name>
                  <description>32 MHz crystal oscillator (XTAL)</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>FRO32M</name>
                  <description>32 MHz free running oscillator (FRO)</description>
                  <value>0x3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>FRO48M</name>
                  <description>48 MHz free running oscillator (FRO)</description>
                  <value>0x4</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>OSC32CLKSEL</name>
          <description>OSC32KCLK and OSC32MCLK clock sources select. Note: this register is not locked by CLOCKGENUPDATELOCKOUT</description>
          <addressOffset>0x284</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0x3</resetMask>
          <fields>
            <field>
              <name>SEL32MHZ</name>
              <description>OSC32MCLK clock source selection</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>FRO32M</name>
                  <description>32 MHz free running oscillator (FRO)</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>XTAL32M</name>
                  <description>32 MHz crystal oscillator</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SEL32KHZ</name>
              <description>OSC32KCLK clock source selection</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>FRO32K</name>
                  <description>32 KHz free running oscillator (FRO)</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>XTAL32K</name>
                  <description>32 KHz crystal oscillator</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>CLKOUTSEL</name>
          <description>CLKOUT clock source select</description>
          <addressOffset>0x288</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x7</resetValue>
          <resetMask>0x7</resetMask>
          <fields>
            <field>
              <name>SEL</name>
              <description>CLKOUT clock source selection</description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>MAINCLK</name>
                  <description>CPU &amp; System Bus clock</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>XTAL32K</name>
                  <description>32 KHz crystal oscillator (XTAL)</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>FRO32K</name>
                  <description>32 KHz free running oscillator (FRO)</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>XTAL32M</name>
                  <description>32 MHz crystal oscillator (XTAL)</description>
                  <value>0x3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>FRO48M</name>
                  <description>48 MHz free running oscillator (FRO)</description>
                  <value>0x5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>FRO1M</name>
                  <description>1 MHz free running oscillator (FRO)</description>
                  <value>0x6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>TESTCLK</name>
                  <description>No clock</description>
                  <value>0x7</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>SPIFICLKSEL</name>
          <description>SPIFI clock source select</description>
          <addressOffset>0x2A0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x7</resetValue>
          <resetMask>0x7</resetMask>
          <fields>
            <field>
              <name>SEL</name>
              <description>SPIFICLK clock source selection</description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>MAINCLK</name>
                  <description>CPU &amp; System Bus clock</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>XTAL32M</name>
                  <description>32 MHz crystal oscillator (XTAL)</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>TESTCLK0</name>
                  <description>No clock</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>TESTCLK1</name>
                  <description>No clock</description>
                  <value>0x3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>TESTCLK2</name>
                  <description>No clock</description>
                  <value>0x4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>TESTCLK3</name>
                  <description>No clock</description>
                  <value>0x5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>TESTCLK4</name>
                  <description>No clock</description>
                  <value>0x6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>TESTCLK5</name>
                  <description>No clock</description>
                  <value>0x7</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>ADCCLKSEL</name>
          <description>ADC clock source select</description>
          <addressOffset>0x2A4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x3</resetValue>
          <resetMask>0x3</resetMask>
          <fields>
            <field>
              <name>SEL</name>
              <description>ADCCLK clock source selection</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>XTAL32M</name>
                  <description>32 MHz crystal oscillator (XTAL)</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>FRO12M</name>
                  <description>FRO 12 MHz</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>TESTCLK</name>
                  <description>No clock</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>USARTCLKSEL</name>
          <description>USART0 &amp; 1 clock source select</description>
          <addressOffset>0x2B0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x3</resetValue>
          <resetMask>0x3</resetMask>
          <fields>
            <field>
              <name>SEL</name>
              <description>USARTCLK (USART0 &amp; 1) clock source selection</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>OSC32MCLK</name>
                  <description>Either 32 MHz FRO or 32 MHz XTAL (see OSC32CLKSEL)</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>FRO48M</name>
                  <description>48 MHz free running oscillator (FRO)</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>FRGCLK</name>
                  <description>Fractional Rate Generator clock (see FRGCLKSEL)</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>TESTCLK</name>
                  <description>No clock</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>I2CCLKSEL</name>
          <description>I2C0, 1 and 2 clock source select</description>
          <addressOffset>0x2B4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x3</resetValue>
          <resetMask>0x3</resetMask>
          <fields>
            <field>
              <name>SEL</name>
              <description>I2CCLK (I2C0 &amp; 1) clock source selection</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>OSC32MCLK</name>
                  <description>Either 32 MHz FRO or 32 MHz XTAL (see OSC32CLKSEL)</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>FRO48M</name>
                  <description>48 MHz free running oscillator (FRO)</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>TESTCLK</name>
                  <description>No clock</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>SPICLKSEL</name>
          <description>SPI0 &amp; 1 clock source select</description>
          <addressOffset>0x2B8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x3</resetValue>
          <resetMask>0x3</resetMask>
          <fields>
            <field>
              <name>SEL</name>
              <description>SPICLK (SPI0 &amp; 1) clock source selection</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>OSC32MCLK</name>
                  <description>Either 32 MHz FRO or 32 MHz XTAL (see OSC32CLKSEL)</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>FRO48M</name>
                  <description>48 MHz free running oscillator (FRO)</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>TESTCLK</name>
                  <description>No clock</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>IRCLKSEL</name>
          <description>Infra Red clock source select</description>
          <addressOffset>0x2BC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x3</resetValue>
          <resetMask>0x3</resetMask>
          <fields>
            <field>
              <name>SEL</name>
              <description>IRCLK (IR Blaster) clock source selection</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>OSC32MCLK</name>
                  <description>Either 32 MHz FRO or 32 MHz XTAL (see OSC32CLKSEL)</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>FRO48M</name>
                  <description>48 MHz free running oscillator (FRO)</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>TESTCLK</name>
                  <description>No clock</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>PWMCLKSEL</name>
          <description>PWM clock source select</description>
          <addressOffset>0x2C0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x3</resetValue>
          <resetMask>0x3</resetMask>
          <fields>
            <field>
              <name>SEL</name>
              <description>PWMCLK (PWM) clock source selection</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>OSC32MCLK</name>
                  <description>Either 32 MHz FRO or 32 MHz XTAL (see OSC32CLKSEL)</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>FRO48M</name>
                  <description>48 MHz free running oscillator (FRO)</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>TESTCLK</name>
                  <description>No Clock</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>WDTCLKSEL</name>
          <description>Watchdog Timer clock source select</description>
          <addressOffset>0x2C4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x3</resetValue>
          <resetMask>0x3</resetMask>
          <fields>
            <field>
              <name>SEL</name>
              <description>WDTCLK (Watchdog Timer) clock source selection</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>OSC32MCLK</name>
                  <description>Either 32 MHz FRO or 32 MHz XTAL (see OSC32CLKSEL)</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>OSC32KCLK</name>
                  <description>Either 32 KHz FRO or 32 KHz XTAL (see OSC32CLKSEL)</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>FRO1M</name>
                  <description>1 MHz FRO</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>TESTCLK</name>
                  <description>No Clock</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>MODEMCLKSEL</name>
          <description>Modem clock source select</description>
          <addressOffset>0x2CC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x3</resetValue>
          <resetMask>0x3</resetMask>
          <fields>
            <field>
              <name>SEL_ZIGBEE</name>
              <description>Zigbee Modem clock source selection</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>XTAL32M</name>
                  <description>32 MHz XTAL</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>TESTCLK</name>
                  <description>No Clock</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>FRGCLKSEL</name>
          <description>Fractional Rate Generator (FRG) clock source select. The FRG is one of the USART clocking options.</description>
          <addressOffset>0x2E8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x3</resetValue>
          <resetMask>0x3</resetMask>
          <fields>
            <field>
              <name>SEL</name>
              <description>Fractional Rate Generator clock source selection</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>MAINCLK</name>
                  <description>System Bus clock</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>OSC32MCLK</name>
                  <description>Either 32 MHz FRO or 32 MHz XTAL (see OSC32CLKSEL)</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>FRO48M</name>
                  <description>48 MHz free running oscillator (FRO)</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>TESTCLK</name>
                  <description>No Clock</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DMICCLKSEL</name>
          <description>Digital microphone (DMIC) subsystem clock select</description>
          <addressOffset>0x2EC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x7</resetValue>
          <resetMask>0x7</resetMask>
          <fields>
            <field>
              <name>SEL</name>
              <description>DMIC clock source selection</description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>MAINCLK</name>
                  <description>System Bus clock</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>OSC32KCLK</name>
                  <description>Either 32 KHz FRO or 32 KHz XTAL (see OSC32CLKSEL)</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>FRO48M</name>
                  <description>48 MHz free running oscillator (FRO)</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>MCLK</name>
                  <description>External clock</description>
                  <value>0x3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>FRO1M</name>
                  <description>1 MHz free running oscillator (FRO)</description>
                  <value>0x4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>FRO12M</name>
                  <description>12 MHz free running oscillator (FRO)</description>
                  <value>0x5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>TESTCLK</name>
                  <description>No Clock</description>
                  <value>0x7</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>WKTCLKSEL</name>
          <description>Wake-up Timer clock select</description>
          <addressOffset>0x2F0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x3</resetValue>
          <resetMask>0x3</resetMask>
          <fields>
            <field>
              <name>SEL</name>
              <description>Wake-up Timers clock source selection</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>OSC32KCLK</name>
                  <description>Either 32 KHz FRO or 32 KHz XTAL (see OSC32CLKSEL)</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>TESTCLK</name>
                  <description>No Clock</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>SYSTICKCLKDIV</name>
          <description>SYSTICK clock divider. The SYSTICK clock can drive the SYSTICK function within the processor.</description>
          <addressOffset>0x300</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x40000000</resetValue>
          <resetMask>0xE00000FF</resetMask>
          <fields>
            <field>
              <name>DIV</name>
              <description>Clock divider setting, divider ratio is (DIV+1). E.g. 0: Divide by 1 and 255: Divide by 256.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RESET</name>
              <description>Resets the divider counter. Can be used to make sure a new divider value is used right away rather than completing the previous count.</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>HALT</name>
              <description>Halts the divider counter. The intent is to allow the divider s clock source to be changed without the risk of a glitch at the output.</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>REQFLAG</name>
              <description>Divider status flag. Set when a change is made to the divider value, cleared when the change is complete.</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TRACECLKDIV</name>
          <description>TRACE clock divider, used for part of the Serial debugger (SWD) feature.</description>
          <addressOffset>0x304</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x40000000</resetValue>
          <resetMask>0xE00000FF</resetMask>
          <fields>
            <field>
              <name>DIV</name>
              <description>Clock divider setting, divider ratio is (DIV+1). E.g. 0: Divide by 1 and 255: Divide by 256.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RESET</name>
              <description>Resets the divider counter. Can be used to make sure a new divider value is used right away rather than completing the previous count.</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>HALT</name>
              <description>Halts the divider counter. The intent is to allow the divider s clock source to be changed without the risk of a glitch at the output.</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>REQFLAG</name>
              <description>Divider status flag. Set when a change is made to the divider value, cleared when the change is complete.</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>WDTCLKDIV</name>
          <description>Watchdog Timer clock divider</description>
          <addressOffset>0x36C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x40000000</resetValue>
          <resetMask>0xE00000FF</resetMask>
          <fields>
            <field>
              <name>DIV</name>
              <description>Clock divider setting, divider ratio is (DIV+1). E.g. 0: Divide by 1 and 255: Divide by 256.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RESET</name>
              <description>Resets the divider counter. Can be used to make sure a new divider value is used right away rather than completing the previous count.</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>HALT</name>
              <description>Halts the divider counter. The intent is to allow the divider s clock source to be changed without the risk of a glitch at the output.</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>REQFLAG</name>
              <description>Divider status flag. Set when a change is made to the divider value, cleared when the change is complete.</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>IRCLKDIV</name>
          <description>Infra Red clock divider</description>
          <addressOffset>0x378</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x40000000</resetValue>
          <resetMask>0xE000000F</resetMask>
          <fields>
            <field>
              <name>DIV</name>
              <description>Clock divider setting, divider ratio is (DIV+1). E.g. 0: Divide by 1 and 15: Divide by 16.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RESET</name>
              <description>Resets the divider counter. Can be used to make sure a new divider value is used right away rather than completing the previous count.</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>HALT</name>
              <description>Halts the divider counter. The intent is to allow the divider s clock source to be changed without the risk of a glitch at the output.</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>REQFLAG</name>
              <description>Divider status flag. Set when a change is made to the divider value, cleared when the change is complete.</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>AHBCLKDIV</name>
          <description>System clock divider</description>
          <addressOffset>0x380</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0x800000FF</resetMask>
          <fields>
            <field>
              <name>DIV</name>
              <description>Clock divider setting, divider ratio is (DIV+1). E.g. 0: Divide by 1 and 255: Divide by 256.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>REQFLAG</name>
              <description>Divider status flag. Set when a change is made to the divider value, cleared when the change is complete.</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CLKOUTDIV</name>
          <description>CLKOUT clock divider</description>
          <addressOffset>0x384</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x40000000</resetValue>
          <resetMask>0xE000000F</resetMask>
          <fields>
            <field>
              <name>DIV</name>
              <description>Clock divider setting, divider ratio is (DIV+1). E.g. 0: Divide by 1 and 15: Divide by 16.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RESET</name>
              <description>Resets the divider counter. Can be used to make sure a new divider value is used right away rather than completing the previous count.</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>HALT</name>
              <description>Halts the divider counter. The intent is to allow the divider s clock source to be changed without the risk of a glitch at the output.</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>REQFLAG</name>
              <description>Divider status flag. Set when a change is made to the divider value, cleared when the change is complete.</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SPIFICLKDIV</name>
          <description>SPIFI clock divider</description>
          <addressOffset>0x390</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x40000000</resetValue>
          <resetMask>0xE0000003</resetMask>
          <fields>
            <field>
              <name>DIV</name>
              <description>Clock divider setting, divider ratio is (DIV+1). E.g. 0: Divide by 1 and 3: Divide by 4.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RESET</name>
              <description>Resets the divider counter. Can be used to make sure a new divider value is used right away rather than completing the previous count.</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>HALT</name>
              <description>Halts the divider counter. The intent is to allow the divider s clock source to be changed without the risk of a glitch at the output.</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>REQFLAG</name>
              <description>Divider status flag. Set when a change is made to the divider value, cleared when the change is complete.</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ADCCLKDIV</name>
          <description>ADC clock divider</description>
          <addressOffset>0x394</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x40000000</resetValue>
          <resetMask>0xE0000007</resetMask>
          <fields>
            <field>
              <name>DIV</name>
              <description>Clock divider setting, divider ratio is (DIV+1). E.g. 0: Divide by 1 and 7: Divide by 8.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RESET</name>
              <description>Resets the divider counter. Can be used to make sure a new divider value is used right away rather than completing the previous count.</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>HALT</name>
              <description>Halts the divider counter. The intent is to allow the divider s clock source to be changed without the risk of a glitch at the output.</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>REQFLAG</name>
              <description>Divider status flag. Set when a change is made to the divider value, cleared when the change is complete.</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RTCCLKDIV</name>
          <description>Real Time Clock divider (1 KHz clock generation)</description>
          <addressOffset>0x398</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x40000000</resetValue>
          <resetMask>0xE000001F</resetMask>
          <fields>
            <field>
              <name>DIV</name>
              <description>Clock divider setting, divider ratio is (DIV+1). E.g. 0: Divide by 1 and 31: Divide by 32.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RESET</name>
              <description>Resets the divider counter. Can be used to make sure a new divider value is used right away rather than completing the previous count.</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>HALT</name>
              <description>Halts the divider counter. The intent is to allow the divider s clock source to be changed without the risk of a glitch at the output.</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>REQFLAG</name>
              <description>Divider status flag. Set when a change is made to the divider value, cleared when the change is complete.</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>FRGCTRL</name>
          <description>Fractional rate generator divider. The FRG is one of the USART clocking options.</description>
          <addressOffset>0x3A0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xFF</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>DIV</name>
              <description>Denominator of the fractional divider is equal to the (DIV+1). Always set to 0xFF to use with the fractional baud rate generator : fout = fin / (1 + MULT/(DIV+1))</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MULT</name>
              <description>Numerator of the fractional divider. MULT is equal to the programmed value</description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMICCLKDIV</name>
          <description>DMIC clock divider</description>
          <addressOffset>0x3A8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x40000000</resetValue>
          <resetMask>0xE00000FF</resetMask>
          <fields>
            <field>
              <name>DIV</name>
              <description>Clock divider setting, divider ratio is (DIV+1). E.g. 0: Divide by 1 and 255: Divide by 256.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RESET</name>
              <description>Resets the divider counter. Can be used to make sure a new divider value is used right away rather than completing the previous count.</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>HALT</name>
              <description>Halts the divider counter. The intent is to allow the divider s clock source to be changed without the risk of a glitch at the output.</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>REQFLAG</name>
              <description>Divider status flag. Set when a change is made to the divider value, cleared when the change is complete.</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RTC1HZCLKDIV</name>
          <description>Real Time Clock divider (1 Hz clock generation. The divider is fixed to 32768)</description>
          <addressOffset>0x3AC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x40000000</resetValue>
          <resetMask>0xE0000000</resetMask>
          <fields>
            <field>
              <name>RESET</name>
              <description>Resets the divider counter. Can be used to make sure a new divider value is used right away rather than completing the previous count.</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>HALT</name>
              <description>Halts the divider counter. The intent is to allow the divider s clock source to be changed without the risk of a glitch at the output.</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>REQFLAG</name>
              <description>Divider status flag. Set when a change is made to the divider value, cleared when the change is complete.</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CLOCKGENUPDATELOCKOUT</name>
          <description>Control clock configuration registers access (like xxxDIV, xxxSEL)</description>
          <addressOffset>0x3FC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0x1</resetMask>
          <fields>
            <field>
              <name>LOCK</name>
              <description>When set, disables access to clock control registers (like xxxDIV, xxxSEL). Affects all clock control registers except OSC32CLKSEL.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RNGCLKCTRL</name>
          <description>Random Number Generator Clocks control</description>
          <addressOffset>0x59C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0x1</resetMask>
          <fields>
            <field>
              <name>ENABLE</name>
              <description>Enable the clocks used by the Random Number Generator (RNG)</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SRAMCTRL</name>
          <description>All SRAMs common control signals</description>
          <addressOffset>0x5A0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0x7FFFF</resetMask>
          <fields>
            <field>
              <name>SMB</name>
              <description>SMB</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MODEMCTRL</name>
          <description>32K clock enable</description>
          <addressOffset>0x5CC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0x200</resetMask>
          <fields>
            <field>
              <name>BLE_LP_OSC32K_EN</name>
              <description>1 = enable the 32K clock to the USART 0 &amp; 1, LSPI0 &amp; 1, PMC and the frequency measure block. Note: despite its name, this control bit affects peripheral clocking,</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>XTAL32KCAP</name>
          <description>XTAL 32 KHz oscillator Capacitor control</description>
          <addressOffset>0x5D4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x2142</resetValue>
          <resetMask>0x3FFF</resetMask>
          <fields>
            <field>
              <name>XO_OSC_CAP_IN</name>
              <description>Internal Capacitor setting for XTAL_32K_P. This setting selects the internal capacitance, to ground, that is connected to this XTAL pin. During device testing the capacitor banks are calibrated so accurate setting of the capacitance can be achieved. Software function are provided to support the setting of this register. Capacitance range is to apporximately 24pF.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>7</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>XO_OSC_CAP_OUT</name>
              <description>Internal Capacitor setting for XTAL_32K_N. This setting selects the internal capacitance, to ground, that is connected to this XTAL pin. During device testing the capacitor banks are calibrated so accurate setting of the capacitance can be achieved. Software function are provided to support the setting of this register. Capacitance range is to apporximately 24pF.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>7</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>XTAL32MCTRL</name>
          <description>XTAL 32 MHz oscillator control register</description>
          <addressOffset>0x5D8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x2</resetValue>
          <resetMask>0x3</resetMask>
          <fields>
            <field>
              <name>DEACTIVATE_PMC_CTRL</name>
              <description>The 32MHz XTAL is enabled whenever the device is active due to internal control signals from the PMC. This control bit can deactivate this. 0: Enable XTAL 32 MHz controls coming from PMC. 1: Disable XTAL 32 MHz controls coming from PMC.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>STARTER0</name>
          <description>Start logic 0 wake-up enable register. Enable an interrupt for wake-up from deep-sleep mode. Some bits can also control wake-up from powerdown mode</description>
          <alternateGroup>STARTER</alternateGroup>
          <addressOffset>0x680</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0x7FFFFFFF</resetMask>
          <fields>
            <field>
              <name>WDT_BOD</name>
              <description>WWDT and BOD Interrupt wake-up. 0 = Wake-up disabled. 1 = Wake-up enabled. Valid from Deep-Sleep and Powerdown.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DMA</name>
              <description>DMA Operation in Deep-Sleep and Powerdown not supported. Leave set to 0.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GINT</name>
              <description>Group Interrupt 0 (GINT0) interrupt wake-up. 0 = Wake-up disabled. 1 = Wake-up enabled. Valid from Deep-Sleep.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>IRBLASTER</name>
              <description>Infra Red Blaster interrupt wake-up. 0 = Wake-up disabled. 1 = Wake-up enabled. Valid from Deep-Sleep.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PINT0</name>
              <description>Pattern Interupt 0 (PINT0) interrupt wake-up. 0 = Wake-up disabled. 1 = Wake-up enabled. Valid from Deep-Sleep.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PINT1</name>
              <description>Pattern Interupt 1 (PINT1) interrupt wake-up. 0 = Wake-up disabled. 1 = Wake-up enabled. Valid from Deep-Sleep.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PINT2</name>
              <description>Pattern Interupt 2 (PINT2) interrupt wake-up. 0 = Wake-up disabled. 1 = Wake-up enabled. Valid from Deep-Sleep.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PINT3</name>
              <description>Pattern Interupt 3 (PINT3) interrupt wake-up. 0 = Wake-up disabled. 1 = Wake-up enabled. Valid from Deep-Sleep.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SPIFI</name>
              <description>SPI Flash Interface (SPIFI) interrupt wake-up. 0 = Wake-up disabled. 1 = Wake-up enabled. Valid from Deep-Sleep.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TIMER0</name>
              <description>Counter/Timer0 interrupt wake-up. 0 = Wake-up disabled. 1 = Wake-up enabled. Valid from Deep-Sleep.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TIMER1</name>
              <description>Counter/Timer1 interrupt wake-up. 0 = Wake-up disabled. 1 = Wake-up enabled. Valid from Deep-Sleep.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>USART0</name>
              <description>USART0 interrupt wake-up. 0 = Wake-up disabled. 1 = Wake-up enabled. Valid from Deep-Sleep and Powerdown.</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>USART1</name>
              <description>USART1 interrupt wake-up. 0 = Wake-up disabled. 1 = Wake-up enabled. Valid from Deep-Sleep.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C0</name>
              <description>I2C0 interrupt wake-up. 0 = Wake-up disabled. 1 = Wake-up enabled. Valid from Deep-Sleep and Powerdown.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C1</name>
              <description>I2C1 interrupt wake-up. 0 = Wake-up disabled. 1 = Wake-up enabled. Valid from Deep-Sleep.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SPI0</name>
              <description>SPI0 interrupt wake-up. 0 = Wake-up disabled. 1 = Wake-up enabled. Valid from Deep-Sleep and Powerdown.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SPI1</name>
              <description>SPI1 interrupt wake-up. 0 = Wake-up disabled. 1 = Wake-up enabled. Valid from Deep-Sleep.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PWM0</name>
              <description>PWM0 interrupt wake-up. 0 = Wake-up disabled. 1 = Wake-up enabled. Valid from Deep-Sleep.</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PWM1</name>
              <description>PWM1 interrupt wake-up. 0 = Wake-up disabled. 1 = Wake-up enabled. Valid from Deep-Sleep.</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PWM2</name>
              <description>PWM2 interrupt wake-up. 0 = Wake-up disabled. 1 = Wake-up enabled. Valid from Deep-Sleep.</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PWM3</name>
              <description>PWM3 interrupt wake-up. 0 = Wake-up disabled. 1 = Wake-up enabled. Valid from Deep-Sleep.</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PWM4</name>
              <description>PWM4 interrupt wake-up. 0 = Wake-up disabled. 1 = Wake-up enabled. Valid from Deep-Sleep.</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PWM5</name>
              <description>PWM5 interrupt wake-up. 0 = Wake-up disabled. 1 = Wake-up enabled. Valid from Deep-Sleep.</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PWM6</name>
              <description>PWM6 interrupt wake-up. 0 = Wake-up disabled. 1 = Wake-up enabled. Valid from Deep-Sleep.</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PWM7</name>
              <description>PWM7 interrupt wake-up. 0 = Wake-up disabled. 1 = Wake-up enabled. Valid from Deep-Sleep.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PWM8</name>
              <description>PWM8 interrupt wake-up. 0 = Wake-up disabled. 1 = Wake-up enabled. Valid from Deep-Sleep.</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PWM9</name>
              <description>PWM9 interrupt wake-up. 0 = Wake-up disabled. 1 = Wake-up enabled. Valid from Deep-Sleep.</description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PWM10</name>
              <description>PWM10 interrupt wake-up. 0 = Wake-up disabled. 1 = Wake-up enabled. Valid from Deep-Sleep.</description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C2</name>
              <description>I2C2 interrupt wake-up. 0 = Wake-up disabled. 1 = Wake-up enabled. Valid from Deep-Sleep.</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RTC</name>
              <description>Real Time Clock (RTC) interrupt wake-up. 0 = Wake-up disabled. 1 = Wake-up enabled. Valid from Deep-Sleep and Powerdown.</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>NFCTAG</name>
              <description>NFC Tag interrupt wake-up. 0 = Wake-up disabled. 1 = Wake-up enabled. Valid from Deep-Sleep. Only supported on devices with internal NFC tag.</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>STARTERS0</name>
          <description>Pin assign register</description>
          <alternateGroup>STARTER</alternateGroup>
          <addressOffset>0x680</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xFFFFFFFF</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DATA</name>
              <description>no description available</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>STARTER1</name>
          <description>Start logic 1 wake-up enable register. Enable an interrupt for wake-up from deep-sleep mode. Some bits can also control wake-up from powerdown mode</description>
          <alternateGroup>STARTER</alternateGroup>
          <addressOffset>0x684</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0x8003FC1D</resetMask>
          <fields>
            <field>
              <name>ADC_SEQA</name>
              <description>ADC Sequence A interrupt wake-up. 0 = Wake-up disabled. 1 = Wake-up enabled. Valid from Deep-Sleep.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ADC_THCMP_OVR</name>
              <description>ADC threshold and error interrupt wake-up. 0 = Wake-up disabled. 1 = Wake-up enabled. Valid from Deep-Sleep.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DMIC</name>
              <description>Digital Microphone (DMIC) interrupt wake-up. 0 = Wake-up disabled. 1 = Wake-up enabled. Valid from Deep-Sleep.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>HWVAD</name>
              <description>Hardware Voice Activity Detector (HWVAD) interrupt wake-up. 0 = Wake-up disabled. 1 = Wake-up enabled. Valid from Deep-Sleep.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ZIGBEE_MAC</name>
              <description>Zigbee MAC interrupt wake-up. 0 = Wake-up disabled. 1 = Wake-up enabled. Valid from Deep-Sleep.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ZIGBEE_MODEM</name>
              <description>Zigbee Modem interrupt wake-up. 0 = Wake-up disabled. 1 = Wake-up enabled. Valid from Deep-Sleep.</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RFP_TMU</name>
              <description>Radio Controller Timing Controller (RFP TMU) interrupt wake-up. 0 = Wake-up disabled. 1 = Wake-up enabled. Valid from Deep-Sleep.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RFP_AGC</name>
              <description>Radio Control AGC (RFP AGC) interrupt wake-up. 0 = Wake-up disabled. 1 = Wake-up enabled. Valid from Deep-Sleep.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ISO7816</name>
              <description>ISO7816 Smart Card interface interrupt wake-up. 0 = Wake-up disabled. 1 = Wake-up enabled. Valid from Deep-Sleep.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ANA_COMP</name>
              <description>Analog Comparator interrupt wake-up. 0 = Wake-up disabled. 1 = Wake-up enabled. Valid from Deep-Sleep and Powerdown.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>WAKE_UP_TIMER0</name>
              <description>Wake-up Timer0 interrupt wake-up. 0 = Wake-up disabled. 1 = Wake-up enabled. Valid from Deep-Sleep and Powerdown.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>WAKE_UP_TIMER1</name>
              <description>Wake-up Timer1 interrupt wake-up. 0 = Wake-up disabled. 1 = Wake-up enabled. Valid from Deep-Sleep and Powerdown.</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO</name>
              <description>GPIO interrupt wake-up. 0 = Wake-up disabled. 1 = Wake-up enabled. Set this bit to allow GPIO or NTAG_INT to cause a wake-up in Deep-Sleep and Power-down mode.</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>STARTERS1</name>
          <description>Pin assign register</description>
          <alternateGroup>STARTER</alternateGroup>
          <addressOffset>0x684</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xFFFFFFFF</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DATA</name>
              <description>no description available</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>STARTERSET0</name>
          <description>Set bits in STARTER0</description>
          <alternateGroup>STARTERSET</alternateGroup>
          <addressOffset>0x6A0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>WDT_BOD_SET</name>
              <description>Writing one to this bit sets the corresponding bit in the STARTER0 register</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>DMA_SET</name>
              <description>Writing one to this bit sets the corresponding bit in the STARTER0 register</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>GINT_SET</name>
              <description>Writing one to this bit sets the corresponding bit in the STARTER0 register</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>IRBLASTER_SET</name>
              <description>Writing one to this bit sets the corresponding bit in the STARTER0 register</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>PINT0_SET</name>
              <description>Writing one to this bit sets the corresponding bit in the STARTER0 register</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>PINT1_SET</name>
              <description>Writing one to this bit sets the corresponding bit in the STARTER0 register</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>PINT2_SET</name>
              <description>Writing one to this bit sets the corresponding bit in the STARTER0 register</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>PINT3_SET</name>
              <description>Writing one to this bit sets the corresponding bit in the STARTER0 register</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>SPIFI_SET</name>
              <description>Writing one to this bit sets the corresponding bit in the STARTER0 register</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>TIMER0_SET</name>
              <description>Writing one to this bit sets the corresponding bit in the STARTER0 register</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>TIMER1_SET</name>
              <description>Writing one to this bit sets the corresponding bit in the STARTER0 register</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>USART0_SET</name>
              <description>Writing one to this bit sets the corresponding bit in the STARTER0 register</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>USART1_SET</name>
              <description>Writing one to this bit sets the corresponding bit in the STARTER0 register</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>I2C0_SET</name>
              <description>Writing one to this bit sets the corresponding bit in the STARTER0 register</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>I2C1_SET</name>
              <description>Writing one to this bit sets the corresponding bit in the STARTER0 register</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>SPI0_SET</name>
              <description>Writing one to this bit sets the corresponding bit in the STARTER0 register</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>SPI1_SET</name>
              <description>Writing one to this bit sets the corresponding bit in the STARTER0 register</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>PWM0_SET</name>
              <description>Writing one to this bit sets the corresponding bit in the STARTER0 register</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>PWM1_SET</name>
              <description>Writing one to this bit sets the corresponding bit in the STARTER0 register</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>PWM2_SET</name>
              <description>Writing one to this bit sets the corresponding bit in the STARTER0 register</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>PWM3_SET</name>
              <description>Writing one to this bit sets the corresponding bit in the STARTER0 register</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>PWM4_SET</name>
              <description>Writing one to this bit sets the corresponding bit in the STARTER0 register</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>PWM5_SET</name>
              <description>Writing one to this bit sets the corresponding bit in the STARTER0 register</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>PWM6_SET</name>
              <description>Writing one to this bit sets the corresponding bit in the STARTER0 register</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>PWM7_SET</name>
              <description>Writing one to this bit sets the corresponding bit in the STARTER0 register</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>PWM8_SET</name>
              <description>Writing one to this bit sets the corresponding bit in the STARTER0 register</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>PWM9_SET</name>
              <description>Writing one to this bit sets the corresponding bit in the STARTER0 register</description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>PWM10_SET</name>
              <description>Writing one to this bit sets the corresponding bit in the STARTER0 register</description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>I2C2_SET</name>
              <description>Writing one to this bit sets the corresponding bit in the STARTER0 register</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>RTC_SET</name>
              <description>Writing one to this bit sets the corresponding bit in the STARTER0 register</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>NFCTAG_SET</name>
              <description>Writing one to this bit sets the corresponding bit in the STARTER0 register</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>STARTERSETS0</name>
          <description>Pin assign register</description>
          <alternateGroup>STARTERSET</alternateGroup>
          <addressOffset>0x6A0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xFFFFFFFF</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DATA</name>
              <description>no description available</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>STARTERSET1</name>
          <description>Set bits in STARTER1</description>
          <alternateGroup>STARTERSET</alternateGroup>
          <addressOffset>0x6A4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>ADC_SEQA_SET</name>
              <description>Writing one to this bit sets the corresponding bit in the STARTER1 register</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>ADC_THCMP_OVR_SET</name>
              <description>Writing one to this bit sets the corresponding bit in the STARTER1 register</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>DMIC_SET</name>
              <description>Writing one to this bit sets the corresponding bit in the STARTER1 register</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>HWVAD_SET</name>
              <description>Writing one to this bit sets the corresponding bit in the STARTER1 register</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>ZIGBEE_MAC_SET</name>
              <description>Writing one to this bit sets the corresponding bit in the STARTER1 register</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>ZIGBEE_MODEM_SET</name>
              <description>Writing one to this bit sets the corresponding bit in the STARTER1 register</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>RFP_TMU_SET</name>
              <description>Writing one to this bit sets the corresponding bit in the STARTER1 register</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>RFP_AGC_SET</name>
              <description>Writing one to this bit sets the corresponding bit in the STARTER1 register</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>ISO7816_SET</name>
              <description>Writing one to this bit sets the corresponding bit in the STARTER1 register</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>ANA_COMP_SET</name>
              <description>Writing one to this bit sets the corresponding bit in the STARTER1 register</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>WAKE_UP_TIMER0_SET</name>
              <description>Writing one to this bit sets the corresponding bit in the STARTER1 register</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>WAKE_UP_TIMER1_SET</name>
              <description>Writing one to this bit sets the corresponding bit in the STARTER1 register</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>GPIO_SET</name>
              <description>Writing one to this bit sets the corresponding bit in the STARTER1 register</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>STARTERSETS1</name>
          <description>Pin assign register</description>
          <alternateGroup>STARTERSET</alternateGroup>
          <addressOffset>0x6A4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xFFFFFFFF</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DATA</name>
              <description>no description available</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>STARTERCLR0</name>
          <description>Clear bits in STARTER0</description>
          <alternateGroup>STARTERCLR</alternateGroup>
          <addressOffset>0x6C0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>WDT_BOD_CLR</name>
              <description>Writing one to this bit clears the corresponding bit in the STARTER0 register</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>DMA_CLR</name>
              <description>Writing one to this bit clears the corresponding bit in the STARTER0 register</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>GINT_CLR</name>
              <description>Writing one to this bit clears the corresponding bit in the STARTER0 register</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>IRBLASTER_CLR</name>
              <description>Writing one to this bit clears the corresponding bit in the STARTER0 register</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>PINT0_CLR</name>
              <description>Writing one to this bit clears the corresponding bit in the STARTER0 register</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>PINT1_CLR</name>
              <description>Writing one to this bit clears the corresponding bit in the STARTER0 register</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>PINT2_CLR</name>
              <description>Writing one to this bit clears the corresponding bit in the STARTER0 register</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>PINT3_CLR</name>
              <description>Writing one to this bit clears the corresponding bit in the STARTER0 register</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>SPIFI_CLR</name>
              <description>Writing one to this bit clears the corresponding bit in the STARTER0 register</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>TIMER0_CLR</name>
              <description>Writing one to this bit clears the corresponding bit in the STARTER0 register</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>TIMER1_CLR</name>
              <description>Writing one to this bit clears the corresponding bit in the STARTER0 register</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>USART0_CLR</name>
              <description>Writing one to this bit clears the corresponding bit in the STARTER0 register</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>USART1_CLR</name>
              <description>Writing one to this bit clears the corresponding bit in the STARTER0 register</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>I2C0_CLR</name>
              <description>Writing one to this bit clears the corresponding bit in the STARTER0 register</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>I2C1_CLR</name>
              <description>Writing one to this bit clears the corresponding bit in the STARTER0 register</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>SPI0_CLR</name>
              <description>Writing one to this bit clears the corresponding bit in the STARTER0 register</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>SPI1_CLR</name>
              <description>Writing one to this bit clears the corresponding bit in the STARTER0 register</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>PWM0_CLR</name>
              <description>Writing one to this bit clears the corresponding bit in the STARTER0 register</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>PWM1_CLR</name>
              <description>Writing one to this bit clears the corresponding bit in the STARTER0 register</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>PWM2_CLR</name>
              <description>Writing one to this bit clears the corresponding bit in the STARTER0 register</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>PWM3_CLR</name>
              <description>Writing one to this bit clears the corresponding bit in the STARTER0 register</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>PWM4_CLR</name>
              <description>Writing one to this bit clears the corresponding bit in the STARTER0 register</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>PWM5_CLR</name>
              <description>Writing one to this bit clears the corresponding bit in the STARTER0 register</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>PWM6_CLR</name>
              <description>Writing one to this bit clears the corresponding bit in the STARTER0 register</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>PWM7_CLR</name>
              <description>Writing one to this bit clears the corresponding bit in the STARTER0 register</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>PWM8_CLR</name>
              <description>Writing one to this bit clears the corresponding bit in the STARTER0 register</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>PWM9_CLR</name>
              <description>Writing one to this bit clears the corresponding bit in the STARTER0 register</description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>PWM10_CLR</name>
              <description>Writing one to this bit clears the corresponding bit in the STARTER0 register</description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>I2C2_CLR</name>
              <description>Writing one to this bit clears the corresponding bit in the STARTER0 register</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>RTC_CLR</name>
              <description>Writing one to this bit clears the corresponding bit in the STARTER0 register</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>NFCTAG_CLR</name>
              <description>Writing one to this bit clears the corresponding bit in the STARTER0 register</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>STARTERCLRS0</name>
          <description>Pin assign register</description>
          <alternateGroup>STARTERCLR</alternateGroup>
          <addressOffset>0x6C0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xFFFFFFFF</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DATA</name>
              <description>no description available</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>STARTERCLR1</name>
          <description>Clear bits in STARTER1</description>
          <alternateGroup>STARTERCLR</alternateGroup>
          <addressOffset>0x6C4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>ADC_SEQA_CLR</name>
              <description>Writing one to this bit clears the corresponding bit in the STARTER1 register</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>ADC_THCMP_OVR_CLR</name>
              <description>Writing one to this bit clears the corresponding bit in the STARTER1 register</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>DMIC_CLR</name>
              <description>Writing one to this bit clears the corresponding bit in the STARTER1 register</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>HWVAD_CLR</name>
              <description>Writing one to this bit clears the corresponding bit in the STARTER1 register</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>ZIGBEE_MAC_CLR</name>
              <description>Writing one to this bit clears the corresponding bit in the STARTER1 register</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>ZIGBEE_MODEM_CLR</name>
              <description>Writing one to this bit clears the corresponding bit in the STARTER1 register</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>RFP_TMU_CLR</name>
              <description>Writing one to this bit clears the corresponding bit in the STARTER1 register</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>RFP_AGC_CLR</name>
              <description>Writing one to this bit clears the corresponding bit in the STARTER1 register</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>ISO7816_CLR</name>
              <description>Writing one to this bit clears the corresponding bit in the STARTER1 register</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>ANA_COMP_CLR</name>
              <description>Writing one to this bit clears the corresponding bit in the STARTER1 register</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>WAKE_UP_TIMER0_CLR</name>
              <description>Writing one to this bit clears the corresponding bit in the STARTER1 register</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>WAKE_UP_TIMER1_CLR</name>
              <description>Writing one to this bit clears the corresponding bit in the STARTER1 register</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>GPIO_CLR</name>
              <description>Writing one to this bit clears the corresponding bit in the STARTER1 register</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>STARTERCLRS1</name>
          <description>Pin assign register</description>
          <alternateGroup>STARTERCLR</alternateGroup>
          <addressOffset>0x6C4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xFFFFFFFF</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DATA</name>
              <description>no description available</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RETENTIONCTRL</name>
          <description>I/O retention control register</description>
          <addressOffset>0x708</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0x1</resetMask>
          <fields>
            <field>
              <name>IOCLAMP</name>
              <description>Global control of activation of I/O clamps to allow IOs to hold a value during a power mode cycle. To use enable before the power down and then disable after a wake up. Note that each I/O clamp must also be enabled/disabled individually in IOCON module and also that for an I2C IO cell it must be in GPIO mode for the clamping to work. 0: I/O clamp is disable 1: I/O clamp is enable</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CPSTACK</name>
          <description>CPSTACK</description>
          <addressOffset>0x808</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CPSTACK</name>
              <description>CPSTACK</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ANACTRL_CTRL</name>
          <description>Analog Interrupt control register. Requires AHBCLKCTRL0.ANA_INT_CTRL to be set.</description>
          <addressOffset>0xA00</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0x7</resetMask>
          <fields>
            <field>
              <name>COMPINTRLVL</name>
              <description>Analog Comparator interrupt type: 0: Analog Comparator interrupt is edge sensitive. 1: Analog Comparator interrupt is level sensitive.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>COMPINTRPOL</name>
              <description>Analog Comparator interrupt Polarity: When COMPINTRLVL = 0 (edge sensitive): 00: rising edge. 01: falling edge. 10: both edges (rising and falling). 11: both edges (rising and falling). When COMPINTRLVL = 1 (level sensitive): 00: Low level ('0'). 01: Low level ('0'). 10: High level ('1'). 11: High level ('1').</description>
              <bitOffset>1</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ANACTRL_VAL</name>
          <description>Analog modules (BOD and Analog Comparator) outputs current values (BOD 'Power OK' and Analog comparator out). Requires AHBCLKCTRL0.ANA_INT_CTRL to be set.</description>
          <addressOffset>0xA04</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0</resetValue>
          <resetMask>0x19</resetMask>
          <fields>
            <field>
              <name>BODVBAT</name>
              <description>BOD VBAT Status : 0 = Power not OK ; 1 = Power OK</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ANACOMP</name>
              <description>Analog comparator Status : 0 = Comparator in 0 &lt; in 1 ; 1 = Comparator in 0 &gt; in 1.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>BODVBATHIGH</name>
              <description>Not(BOD VBAT). Inverse of BOD VBAT. 0 = Power OK; 1 = Power not OK</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ANACTRL_STAT</name>
          <description>Analog modules (BOD and Analog Comparator) interrupt status. Requires AHBCLKCTRL0.ANA_INT_CTRL to be set.</description>
          <addressOffset>0xA08</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0x19</resetMask>
          <fields>
            <field>
              <name>BODVBAT</name>
              <description>BOD VBAT Interrupt status. 0: No interrupt pending. 1: Interrupt pending. Write 1 to clear.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ANACOMP</name>
              <description>Analog comparator Interrupt status. 0: No interrupt pending. 1: Interrupt pending. Write 1 to clear.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>BODVBATHIGH</name>
              <description>NOT(BOD VBAT) interrupt status. Will be set when BOD VBAT goes high. Write 1 to clear.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ANACTRL_INTENSET</name>
          <description>Analog modules (BOD and Analog Comparator) Interrupt Enable Read and Set register. Read value indicates which interrupts are enabled. Writing ones sets the corresponding interrupt enable bits. Note, interrupt enable bits are cleared using ANACTRL_INTENCLR. Requires AHBCLKCTRL0.ANA_INT_CTRL to be set to use this register.</description>
          <addressOffset>0xA0C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0x19</resetMask>
          <fields>
            <field>
              <name>BODVBAT</name>
              <description>BOD VBAT Interrupt Enable Read and Set register</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ANACOMP</name>
              <description>Analog comparator Interrupt Enable Read and Set register</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>BODVBATHIGH</name>
              <description>NOT(BOD VBAT) Interrupt Enable Read and Set register</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ANACTRL_INTENCLR</name>
          <description>Analog modules (BOD and Analog Comparator) Interrupt Enable Clear register. Writing ones clears the corresponding interrupt enable bits. Note, interrupt enable bits are set in ANACTRL_INTENSET. Requires AHBCLKCTRL0.ANA_INT_CTRL to be set to use this register.</description>
          <addressOffset>0xA10</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>BODVBAT</name>
              <description>BOD VBAT Interrupt Enable Clear register</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>ANACOMP</name>
              <description>Analog comparator Interrupt Enable Clear register</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>BODVBATHIGH</name>
              <description>NOT(BOD VBAT) Interrupt Enable Clear register</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ANACTRL_INTSTAT</name>
          <description>Analog modules (BOD and Analog Comparator) Interrupt Status register (masked with interrupt enable). Requires AHBCLKCTRL0.ANA_INT_CTRL to be set to use this register. Interrupt status bit are cleared using ANACTRL_STAT.</description>
          <addressOffset>0xA14</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0</resetValue>
          <resetMask>0x19</resetMask>
          <fields>
            <field>
              <name>BODVBAT</name>
              <description>BOD VBAT Interrupt (after interrupt mask). 0 = No interrupt pending. 1 = Interrupt pending. Only set when BODVBAT is enabled in INTENSET</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ANACOMP</name>
              <description>Analog comparator Interrupt (after interrupt mask). 0 = No interrupt pending. 1 = Interrupt pending. Only set when ANACOMP is enabled in INTENSET</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>BODVBATHIGH</name>
              <description>NOT(BOD VBAT) Interrupt (after interrupt mask). 0 = No interrupt pending. 1 = Interrupt pending. Only set when BODVBATHIGH is enabled in INTENSET</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CLOCK_CTRL</name>
          <description>Various system clock controls : Flash clock (48 MHz) control, clocks to Frequency Measure function</description>
          <addressOffset>0xA18</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x1</resetValue>
          <resetMask>0x7</resetMask>
          <fields>
            <field>
              <name>FLASH48MHZ_ENA</name>
              <description>Enable Flash 48 MHz clock. 0 = Disabled. 1 = Enabled.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>XTAL32MHZ_FREQM_ENA</name>
              <description>Enable XTAL32MHz clock for Frequency Measure module. 0 = Disabled. 1 = Enabled.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FRO1MHZ_FREQM_ENA</name>
              <description>Enable FRO 1MHz clock for Frequency Measure module. 0 = Disabled. 1 = Enabled.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>WKT_CTRL</name>
          <description>Wake-up timers control</description>
          <addressOffset>0xA20</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0xF</resetMask>
          <fields>
            <field>
              <name>WKT0_ENA</name>
              <description>Enable wake-up timer 0: 0 = Disabled. 1 = Enabled (counter is running).</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>WKT1_ENA</name>
              <description>Enable wake-up timer 1: 0 = Disabled. 1 = Enabled (counter is running).</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>WKT0_CLK_ENA</name>
              <description>Enable wake-up timer 0 clock: 0 = Disabled. 1 = Enabled.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>WKT1_CLK_ENA</name>
              <description>Enable wake-up timer 1 clock: 0 = Disabled. 1 = Enabled.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>WKT_LOAD_WKT0_LSB</name>
          <description>Wake-up timer 0 reload value least significant bits ([31:0]).</description>
          <addressOffset>0xA24</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WKT0_LOAD_LSB</name>
              <description>Wake-up timer 0 reload value, least significant bits ([31:0]). Write when timer is not enabled</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>WKT_LOAD_WKT0_MSB</name>
          <description>Wake-up timer 0 reload value most significant bits ([8:0]).</description>
          <addressOffset>0xA28</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0x1FF</resetMask>
          <fields>
            <field>
              <name>WKT0_LOAD_MSB</name>
              <description>Wake-up timer 0 reload value, most significant bits ([8:0]). Write when timer is not enabled</description>
              <bitOffset>0</bitOffset>
              <bitWidth>9</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>WKT_LOAD_WKT1</name>
          <description>Wake-up timer 1 reload value.</description>
          <addressOffset>0xA2C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0xFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WKT1_LOAD</name>
              <description>Wake-up timer 1 reload value. Write when timer is not enabled</description>
              <bitOffset>0</bitOffset>
              <bitWidth>28</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>WKT_VAL_WKT0_LSB</name>
          <description>Wake-up timer 0 current value least significant bits ([31:0]). WARNING : reading not reliable: read this register several times until you get a stable value.</description>
          <addressOffset>0xA30</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0xFFFFFFFF</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WKT0_VAL_LSB</name>
              <description>Wake-up timer 0 value, least significant bits ([31:0]). Reread until stable value seen.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>WKT_VAL_WKT0_MSB</name>
          <description>Wake-up timer 0 current value most significant bits ([8:0]). WARNING : reading not reliable: read this register several times until you get a stable value.</description>
          <addressOffset>0xA34</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x1FF</resetValue>
          <resetMask>0x1FF</resetMask>
          <fields>
            <field>
              <name>WKT0_VAL_MSB</name>
              <description>Wake-up timer 0 value, most significant bits ([8:0]). Reread until stable value seen.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>9</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>WKT_VAL_WKT1</name>
          <description>Wake-up timer 1 current value. WARNING : reading not reliable: read this register several times until you get a stable value.</description>
          <addressOffset>0xA38</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0xFFFFFFF</resetValue>
          <resetMask>0xFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WKT1_VAL</name>
              <description>Wake-up timer 1 value. Reread until stable value seen.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>28</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>WKT_STAT</name>
          <description>Wake-up timers status</description>
          <addressOffset>0xA3C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0xF</resetMask>
          <fields>
            <field>
              <name>WKT0_TIMEOUT</name>
              <description>Timeout Status of Wake-up timer 0 : 0 = timeout not reached ; 1 = timeout reached. Write 1 to clear.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>WKT1_TIMEOUT</name>
              <description>Timeout Status of Wake-up timer 1 : 0 = timeout not reached ; 1 = timeout reached. Write 1 to clear.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>WKT0_RUNNING</name>
              <description>Running Status of Wake-up timer 0 : 0 = not running ; 1 = running</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>WKT1_RUNNING</name>
              <description>Running Status of Wake-up timer 1 : 0 = not running ; 1 = running</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>WKT_INTENSET</name>
          <description>Interrupt Enable Read and Set register</description>
          <addressOffset>0xA40</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0x3</resetMask>
          <fields>
            <field>
              <name>WKT0_TIMEOUT</name>
              <description>Wake-up Timer 0 Timeout Interrupt Enable Read and Set register. Read value of '1' indicates that the interrupt is enabled. Set this bit to enable the interrupt. Use WKT_INTENCLR to disable the interrupt.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>WKT1_TIMEOUT</name>
              <description>Wake-up Timer 1 Timeout Interrupt Enable Read and Set register. Read value of '1' indicates that the interrupt is enabled. Set this bit to enable the interrupt. Use WKT_INTENCLR to disable the interrupt.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>WKT_INTENCLR</name>
          <description>Interrupt Enable Clear register</description>
          <addressOffset>0xA44</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>WKT0_TIMEOUT</name>
              <description>Wake-up Timer 0 Timeout Interrupt Enable Clear register. Set this bit to disable the interrupt.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>WKT1_TIMEOUT</name>
              <description>Wake-up Timer 1 Timeout Interrupt Enable Clear register. Set this bit to disable the interrupt.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>WKT_INTSTAT</name>
          <description>Interrupt Status register</description>
          <addressOffset>0xA48</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0</resetValue>
          <resetMask>0x3</resetMask>
          <fields>
            <field>
              <name>WKT0_TIMEOUT</name>
              <description>Wake-up Timer 0 Timeout Interrupt. 0: No interrupt pending. 1: Interrupt pending. Only set when WKT0_TIMEOUT is enable in INTENSET</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>WKT1_TIMEOUT</name>
              <description>Wake-up Timer 1 Timeout Interrupt. 0: No interrupt pending. 1: Interrupt pending. Only set when WKT1_TIMEOUT is enable in INTENSET</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GPIOPSYNC</name>
          <description>Enable bypass of the first stage of synchonization inside GPIO_INT module.</description>
          <addressOffset>0xE08</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0x1</resetMask>
          <fields>
            <field>
              <name>PSYNC</name>
              <description>Enable bypass of the first stage of synchonization inside GPIO_INT module.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DIEID</name>
          <description>Chip revision ID &amp; Number</description>
          <addressOffset>0xFB0</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0xE2111</resetValue>
          <resetMask>0xFFFFFF</resetMask>
          <fields>
            <field>
              <name>REV_ID</name>
              <description>Chip Revision ID</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>MCO_NUM_IN_DIE_ID</name>
              <description>Chip Number</description>
              <bitOffset>4</bitOffset>
              <bitWidth>20</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CODESECURITYPROT</name>
          <description>Security code to allow test access via SWD/JTAG. Reset with POR, SW reset or BOD</description>
          <addressOffset>0xFF0</addressOffset>
          <size>32</size>
          <access>write-only</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SEC_CODE</name>
              <description>Security code to allow debug via SWD and JTAG access in test mode. Write once register, value 0x87654321 disables the access and therefore prevents any chance to enable it. Writing any other value enables the access and locks the mode. In some cases the boot code will secure the device by writing to this register to disable SWD and JTAG. This would prevent the application being able to re-enable this access.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>OTPC</name>
      <description>This is the description of component otpc It is an eFUSE OTP (One Time Programmable memory) controller with APB bus interface. More details will follow.</description>
      <groupName>OTPC</groupName>
      <baseAddress>0x40002000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>0x18</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>ADDR</name>
          <description>Address register for reading the E-Fuse OTP</description>
          <addressOffset>0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0xFFF</resetMask>
          <fields>
            <field>
              <name>ADDR</name>
              <description>Address of OTP value to be read</description>
              <bitOffset>0</bitOffset>
              <bitWidth>12</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>READ</name>
          <description>Register for reading the E-Fuse OTP.</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>READ</name>
              <description>When 1 is written, the OTP is read. Note, this operation only occurs if correct SEQ value is also written.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>SEQ</name>
              <description>Read unlock sequence: only when 0x7F12 is written is the Read command accepted.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RDATA</name>
          <description>Register for the OTP read back data.</description>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0</resetValue>
          <resetMask>0x8000FFFF</resetMask>
          <fields>
            <field>
              <name>DATA</name>
              <description>Read back data from the E-Fuse OTP.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>VALID</name>
              <description>Valid bit. This bit will be cleared when a Read command has been given and will be set when the sequencer has successfully captured the E-Fuse OTP data.</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>I2C0</name>
      <description>This is the description of component i2c It is an Inter IC with APB bus interface. More details will follow.</description>
      <alternatePeripheral>FLEXCOMM2</alternatePeripheral>
      <groupName>I2C</groupName>
      <headerStructName>I2C</headerStructName>
      <baseAddress>0x40003000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>0x1000</size>
        <usage>registers</usage>
      </addressBlock>
      <interrupt>
        <name>FLEXCOMM2</name>
        <value>13</value>
      </interrupt>
      <registers>
        <register>
          <name>CFG</name>
          <description>Configuration for shared functions.</description>
          <addressOffset>0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0x3F</resetMask>
          <fields>
            <field>
              <name>MSTEN</name>
              <description>Master Enable. When disabled, configurations settings for the Master function are not changed, but the Master function is internally reset.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SLVEN</name>
              <description>Slave Enable. When disabled, configurations settings for the Slave function are not changed, but the Slave function is internally reset.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MONEN</name>
              <description>Monitor Enable. When disabled, configurations settings for the Monitor function are not changed, but the Monitor function is internally reset.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TIMEOUT</name>
              <description>I2C bus Time-out Enable. When disabled, the time-out function is internally reset.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MONCLKSTR</name>
              <description>Monitor function Clock Stretching.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>HSCAPABLE</name>
              <description>High-speed mode Capable enable. Since High Speed mode alters the way I2C pins drive and filter, as well as the timing for certain I2C signalling, enabling High-speed mode applies to all functions: master, slave, and monitor.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>STAT</name>
          <description>Status register for Master, Slave and Monitor functions.</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x801</resetValue>
          <resetMask>0x30FFF5F</resetMask>
          <fields>
            <field>
              <name>MSTPENDING</name>
              <description>Master Pending. Indicates that the Master is waiting to continue communication on the I2C-bus (pending) or is idle. When the master is pending, the MSTSTATE bits indicate what type of software service if any the master expects. This flag will cause an interrupt when set if, enabled via the INTENSET register. The MSTPENDING flag is not set when the DMA is handling an event (if the MSTDMA bit in the MSTCTL register is set). If the master is in the idle state, and no communication is needed, mask this interrupt. 0: In progress. Communication is in progress and the Master function is busy and cannot currently accept a command. 1: Pending. The Master function needs software service or is in the idle state. If the master is not in the idle state, it is waiting to receive or transmit data or the NACK bit.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>MSTSTATE</name>
              <description>Master State code. The master state code reflects the master state when the MSTPENDING bit is set, that is the master is pending or in the idle state. Each value of this field indicates a specific required service for the Master function. All other values are reserved. 0: Idle. The Master function is available to be used for a new transaction. 1: Receive ready. Received data available (Master Receiver mode). Address plus Read was previously sent and Acknowledged by slave. 2: Transmit ready. Data can be transmitted (Master Transmitter mode). Address plus Write was previously sent and Acknowledged by slave. 3: NACK address. Slave NACKed address. 4: NACK data. Slave NACKed transmitted data.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>MSTARBLOSS</name>
              <description>Master Arbitration Loss flag. This flag can be cleared by software writing a 1 to this bit. It is also cleared automatically a 1 is written to MSTCONTINUE. 0: No Arbitration Loss has occurred. 1: Arbitration Loss. The mater function has experienced an Arbitration Loss. At this point, the Master function has already stopped driving the bus and gone to an idle state. Software can respond by doing nothing, or by sending a Start in order to attempt to gain control of the bus when it next becomes idle.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MSTSTSTPERR</name>
              <description>Master Start/Stop Error flag. This flag can be cleared by software writing a 1 to this bit. It is also cleared automatically a 1 is written to MSTCONTINUE. 0: No start/stop Error has occurred. 1: The master function has experienced a Start/Stop Error. A Start or Stop was detected at a time when it is not allowed by the I2C specification. The Master interface has stopped driving the bus and gone to an idle state, no action is required. A request for a Start could be made, or software could attempt to insure that thet bus has not stalled.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SLVPENDING</name>
              <description>Slave Pending. Indicates that the Slave function is waiting to continue communication on the I2C-bus and needs software service. This flag will cause an interrupt when set if enabled via INTENSET. The SLVPENDING flag is not set when the DMA is handling an event (if the SLVDMA bit in the SLVCTL register is set). The SLVPENDING flag is read-only and is automatically cleared when a 1 is written to the SLVCONTINUE bit in the SLVCTL register. The point in time when SlvPending is set depends on whether the I2C interface is in HSCAPABLE mode. When the I2C interface is configured to be HSCAPABLE, HS master codes are detected automatically. Due to the requirements of the HS I2C specification, slave addresses must also be detected automatically, since the address must be acknowledged before the clock can be stretched. 0: In progress. The slave function does not currently need service. 1: Pending. The Slave function needs service. Information on what is needed can be found in the adjacent SLVSTATE field.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>SLVSTATE</name>
              <description>Slave State code. Each value of this field indicates a specific required service for the Slave function. All other values are reserved. See Table 393 for state values and actions. Remark: note that the occurrence of some states and how they are handled are affected by DMA mode and Automatic Operation modes. Slave state codes are: 0: Slave address. Address plus R/W received. At least one of the four slave addresses has been matched by hardware. 1: Slave receive. Received data is available (Slave Receiver mode). 2: Slave transmit. Data can be transmitted (Slave transmitter mode).</description>
              <bitOffset>9</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>SLVNOTSTR</name>
              <description>Slave Not Stretching. Indicates when the slave function is stretching the I2C clock. This is needed in order to gracefully invoke Deep Sleep or Power-down modes during slave operation. This read-only flag reflects the slave function status in real time. 0: stretching. The slave function is currently stretching the I2C bus clock. Deep-sleep mode can not be entered at this time. 1. Not stretching. The slave function is not currently stretching the I2C bus clock. Deep-sleep mode could be entered at this time.</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>SLVIDX</name>
              <description>Slave address match Index. This field is valid when the I2C slave function has been selected by receiving an address that matches one of the slave addresses defined by any enabled slave address registers, and provides an identification of the address that was matched. It is possible that more than one address could be matched, but only one match can be reported here. 0: Address 0. Slave address 0 was matched. 1: Address 1. Slave address 1 was matched. 2: Address 2. Slave address 2 was matched. 3: Address 3. Slave address 3 was matched.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>SLVSEL</name>
              <description>Slave selected flag. SLVSEL is set after an address match when software tells the Slave function to acknowledge the address, or when the address has been automatically acknowledged. It is cleared when another address cycle presents an address that does not match an enabled address on the Slave function, when slave software decides to NACK a matched address, when there is a Stop detected on the bus, when the master NACKs slave data, and in some combinations of Automatic Operation. SLVSEL is not cleared if software NACKs data. 0: Not selected. The slave function is not currently selected. 1: Selected. The slave function is currently selected.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SLVDESEL</name>
              <description>Slave Deselected flag. This flag will cause an interrupt when set if enabled via INTENSET. This flag can be cleared by writing a 1 to this bit. 0: Not deselected. The slave function has not become deslected. This does not mean that it is currently selected. That information can be found in the SLVSEL flag. 1: Deselected. The slave function has become deselected. This is specifically caused by the SLVSEL flag changing from 1 to 0. See the description of SLVSEL for details on when that event occurs.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MONRDY</name>
              <description>Monitor Ready. This flag is cleared when the MONRXDAT register is read. 0: No data. The Monitor function does not currently have data available. 1: Data waiting. The Monitor function has data waiting to be read.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>MONOV</name>
              <description>Monitor Overflow flag. 0: No overrun. Monitor data has not overrun 1: Overrun. A monitor data overrun has occurred. This can only happen when Monitor clock stretching is not enabled via the MOCCLKSTR bit in the CFG register. Writing 1 to this bit clears the flag.</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MONACTIVE</name>
              <description>Monitor Active flag. Indicates when the Monitor function considers the I2C bus to be active. Active is defined here as when some Master is on the bus: a bus Start has occurred more recently than a bus Stop. 0: Inactive. The Monitor function considers the I2C bus to be inactive. 1: Active. The Monitor function considers the I2C bus to be active.</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>MONIDLE</name>
              <description>Monitor Idle flag. This flag is set when the Monitor function sees the I2C bus change from active to inactive. This can be used by software to decide when to process data accumulated by the Monitor function. This flag will cause an interrupt when set if enabled via the INTENSET register. The flag can be cleared by writing a 1 to this bit. 0: Not idle. The I2C bus is not idle, or this flag has been cleared by software. 1: Idle. The I2C bus has gone idle at least once since the last time this flag was cleared by software.</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EVENTTIMEOUT</name>
              <description>Event Time-out Interrupt flag. Indicates when the time between events has been longer than the time specified by the TIMEOUT register. Events include Start, Stop, and clock edges. The flag is cleared by writing a 1 to this bit. No time-out is created when the I2C-bus is idle. 0: No time-out. I2C bus events have not casued a time-out. 1: Event time-out. The time between I2C bus events has been longer than the time specified by the TIMEOUT register.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SCLTIMEOUT</name>
              <description>SCL Time-out Interrupt flag. Indicates when SCL has remained low longer than the time specific by the TIMEOUT register. The flag is cleared by writing a 1 to this bit. 0: No time-out. SCL low time has not caused a time-out. 1: Time-out. SCL low time has not caused a time-out.</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTENSET</name>
          <description>Interrupt Enable Set and read register.</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0x30B8951</resetMask>
          <fields>
            <field>
              <name>MSTPENDINGEN</name>
              <description>Master Pending interrupt Enable. 0: interrupt is disabled. 1: interrupt is enabled.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MSTARBLOSSEN</name>
              <description>Master Arbitration Loss interrupt Enable. 0: interrupt is disabled. 1: interrupt is enabled.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MSTSTSTPERREN</name>
              <description>Master Start/Stop Error interrupt Enable. 0: interrupt is disabled. 1: interrupt is enabled.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SLVPENDINGEN</name>
              <description>Slave Pending interrupt Enable. 0: interrupt is disabled. 1: interrupt is enabled.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SLVNOTSTREN</name>
              <description>Slave Not Stretching interrupt Enable. 0: interrupt is disabled. 1: interrupt is enabled.</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SLVDESELEN</name>
              <description>Slave Deselect interrupt Enable. 0: interrupt is disabled. 1: interrupt is enabled.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MONRDYEN</name>
              <description>Monitor data Ready interrupt Enable. 0: interrupt is disabled. 1: interrupt is enabled.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MONOVEN</name>
              <description>Monitor Overrun interrupt Enable. 0: interrupt is disabled. 1: interrupt is enabled.</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MONIDLEEN</name>
              <description>Monitor Idle interrupt Enable. 0: interrupt is disabled. 1: interrupt is enabled.</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EVENTTIMEOUTEN</name>
              <description>Event time-out interrupt Enable. 0: interrupt is disabled. 1: interrupt is enabled.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SCLTIMEOUTEN</name>
              <description>SCL time-out interrupt Enable. 0: interrupt is disabled. 1: interrupt is enabled.</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTENCLR</name>
          <description>Interrupt Enable Clear register. Writing a 1 to this bit clears the corresponding bit in the INTENSET register, disabling that interrupt. This is a Write-only register.</description>
          <addressOffset>0xC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>MSTPCLRDINGCLR</name>
              <description>Master Pending interrupt clear.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>MSTARBLOSSCLR</name>
              <description>Master Arbitration Loss interrupt clear.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>MSTSTSTPERRCLR</name>
              <description>Master Start/Stop Error interrupt clear.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>SLVPENDINGCLR</name>
              <description>Slave Pending interrupt clear.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>SLVNOTSTRCLR</name>
              <description>Slave Not Stretching interrupt clear.</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>SLVDESELCLR</name>
              <description>Slave Deselect interrupt clear.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>MONRDYCLR</name>
              <description>Monitor data Ready interrupt clear.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>MONOVCLR</name>
              <description>Monitor Overrun interrupt clear.</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>MONIDLECLR</name>
              <description>Monitor Idle interrupt clear.</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>EVCLRTTIMEOUTCLR</name>
              <description>Event time-out interrupt clear.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>SCLTIMEOUTCLR</name>
              <description>SCL time-out interrupt clear.</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TIMEOUT</name>
          <description>Time-out value register.</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xFFFF</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>TOMIN</name>
              <description>Time-out time value, bottom four bits. These are hard-wired to 0xF. This gives a minimum time-out of 16 I2C function clocks and also a time-out resolution of 16 I2C function clocks.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TO</name>
              <description>Time-out time value. Specifies the time-out interval value in increments of 16 I2C function clocks, as defined by the CLKDIV register. To change this value while I2C is in operation, disable all time-outs, write a new value to TIMEOUT, then re-enable time-outs. 0x000: A time-out will occur after 16 counts of the I2C function clock. 0x001: A time-out will occur after 32 counts of the I2C function clock. ... 0xFFF: A time-out will occur after 65,536 counts of the I2C function clock.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>12</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CLKDIV</name>
          <description>Clock pre-divider for the entire I2C interface. This determines what time increments are used for the MSTTIME register and controls some timing of the Slave function.</description>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>DIVVAL</name>
              <description>This field controls how the I2C clock (FCLK) is used by the I2C functions that need an internal clock in order to operate. I2C block should be configured for 8MHz clock, this will limit SCL master clock range from 444kHz to 2MHz. 0x0000 = FCLK is used directly by the I2C. 0x0001 = FCLK is divided by 2 before use. 0x0002 = FCLK is divided by 3 before use. ... 0xFFFF = FCLK is divided by 65,536 before use.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTSTAT</name>
          <description>Interrupt Status register for Master, Slave and Monitor functions.</description>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0</resetValue>
          <resetMask>0x30B8951</resetMask>
          <fields>
            <field>
              <name>MSTPENDING</name>
              <description>Master Pending interrupt.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>MSTARBLOSS</name>
              <description>Master Arbitration Loss interrupt.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>MSTSTSTPERR</name>
              <description>Master Start/Stop Error interrupt.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>SLVPENDING</name>
              <description>Slave Pending interrupt.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>SLVNOTSTR</name>
              <description>Slave Not Stretching interrupt.</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>SLVDESEL</name>
              <description>Slave Deselect interrupt.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>MONRDY</name>
              <description>Monitor data Ready interrupt.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>MONOV</name>
              <description>Monitor Overrun interrupt.</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>MONIDLE</name>
              <description>Monitor Idle interrupt.</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>EVTTIMEOUT</name>
              <description>Event time-out interrupt.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>SCLTIMEOUT</name>
              <description>SCL time-out interrupt.</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MSTCTL</name>
          <description>Master control register.</description>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0xF</resetMask>
          <fields>
            <field>
              <name>MSTCONTINUE</name>
              <description>Master Continue. This bit is write-only. 0: No effect. 1: Continue. Informs the Master function to continue to the next operation. This must be done after writing transmit data, reading received data, or other housekeeping related to the next bus operation.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MSTSTART</name>
              <description>Master Start control. This bit is write-only. 0: No effect. 1. Start. A start will be generated on the I2C bus at the next allowed time.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MSTSTOP</name>
              <description>Master Stop control. This bit is write-only. 0: No effect. 1. Stop. A stop will be generated on the I2C bus at the next allowed time, preceded by a NACK to the slave if the master is receiving data from the salve (Master Receiver mode).</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MSTDMA</name>
              <description>Master DMA enable. Data operations of the I2C can be performed with DMA. Protocol type operations such as Start, address, Stop, and address match must always be done with software, typically via an interrupt. Address acknowledgement must also be done by software except when the I2C is configured to be HSCAPABLE (and address acknowledgement is handled entirely by hardware) or when Automatic Operation is enabled. When a DMA data transfer is complete, MSTDMA must be cleared prior to beginning the next operation, typically a Start or Stop.This bit is read/write. 0: Disable. No DMA requests are generated for master operation. 1: Enable. A DMA request is generated for I2C master data operations. When this I2C master is generating Acknowledge bits in Master Receiver mode, the acknowledge is generated automatically.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MSTTIME</name>
          <description>Master timing configuration.</description>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x77</resetValue>
          <resetMask>0x77</resetMask>
          <fields>
            <field>
              <name>MSTSCLLOW</name>
              <description>Master SCL Low time. Specifies the minimum low time that will be asserted by this master on SCL. Other devices on the bus (masters or slaves) could lengthen this time. This corresponds to the parameter tLOW in the I2C bus specification. I2C bus specification parameters tBUF and tSU;STA have the same values and are also controlled by MSTSCLLOW. The minimum SCL low time is (MSTSCLLOW + 2) clocks of the I2C clock pre-divider.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MSTSCLHIGH</name>
              <description>Master SCL High time. Specifies the minimum high time that will be asserted by this master on SCL. Other masters in a multi-master system could shorten this time. This corresponds to the parameter tHIGH in the I2C bus specification. I2C bus specification parameters tSU;STO and tHD;STA have the same values and are also controlled by MSTSCLHIGH.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MSTDAT</name>
          <description>Combined Master receiver and transmitter data register.</description>
          <addressOffset>0x28</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>DATA</name>
              <description>Master function data register. Read: read the most recently received data for the Master function. Write: transmit data using the Master function.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SLVCTL</name>
          <description>Slave control register.</description>
          <addressOffset>0x40</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0x30B</resetMask>
          <fields>
            <field>
              <name>SLVCONTINUE</name>
              <description>Slave Continue. 0: no effect 1: Continue. Informs the Slave function to continue to the next operation, by clearing the SLVPENDING flag in the STAT register. This must be done after writing transmit data, reading recevied data, or any other housekeeping related to the next bus operation. Automatic Operation has different requirements. SLVCONTINUE should not be set unless SLVPENDING=1.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SLVNACK</name>
              <description>Slave NACK. 0: No effect. 1: NACK. Causes the Slave function to NACK the master when the slave is receiving data from the master (Slave Receiver mode).</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SLVDMA</name>
              <description>Slave DMA enable. 0: Slave DMA enable. 1: Enabled. DMA requests are issued for I2C slave data transmission and reception.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>AUTOACK</name>
              <description>Automatic Acknowledge.When this bit is set, it will cause an I2C header which matches SLVADR0 and the direction set by AUTOMATCHREAD to be ACKed immediately; this is used with DMA to allow processing of the data without intervention. If this bit is clear and a header matches SLVADR0, the behavior is controlled by AUTONACK in the SLVADR0 register: allowing NACK or interrupt. 0: Normal, non-automatic operation. If AUTONACK = 0, an SlvPending interrupt is generated when a matching address is received. If AUTONACK-1, receiver addresses are NACKed (ignored). 1: A header with matching SLVADR0 and matching direction as set by AUTOMATCHREAD will be ACKed immediately, allowing the master to move on to the data bytes. If the address matches SLVADR0, but the direction does not match AUTOMATCHREAD, the behaviour will depend on the AUTONACK bit in the SLVADR0 register: if AUTONACK is set, then it will be Nacked; else if AUTONACK is cl;ear, then a SlvPending interrupt is geernated.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>AUTOMATCHREAD</name>
              <description>When AUTOACK is set, this bit controls whether it matches a read or write request on the next header with an address matching SLVADR0. Since DMA needs to be configured to match the transfer direction, the direction needs to be specified. This bit allows a direction to be chosen for the next operation. 0: The expected next operation in Automatic Mode is an I2C write. 1: The expected next operation in Automatic Mode is an I2C read.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SLVDAT</name>
          <description>Combined Slave receiver and transmitter data register.</description>
          <addressOffset>0x44</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>DATA</name>
              <description>Slave function data register. Read: read the most recently received data for the Slave function. Write: transmit data using the Slave function.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>4</dim>
          <dimIncrement>0x4</dimIncrement>
          <name>SLVADR[%s]</name>
          <description>Slave address 0.</description>
          <addressOffset>0x48</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x1</resetValue>
          <resetMask>0x80FF</resetMask>
          <fields>
            <field>
              <name>SADISABLE</name>
              <description>Slave Address 0 Disable. 0: Slave Address 0 is enabled. 1: Slave Address 0 is ignored.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SLVADR</name>
              <description>Slave Address. Seven bit slave address that is compared to received addresses if enabled. The compare can be affected by the setting of the SLVQUAL0 register.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>7</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>AUTONACK</name>
              <description>Automatic NACK operation. Used in conjunction with AUTOACK and AUTOMATCHREAD, allows software to ignore I2C traffic while handling previous I2C data or other operations. 0: Normal operation, matching I2C addresses are not ignored. 1: Automatic-only mode. If AUTOACK is not set, all incoming I2C addresses are ignored.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SLVQUAL0</name>
          <description>Slave Qualification for address 0.</description>
          <addressOffset>0x58</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>QUALMODE0</name>
              <description>Qualify mode for slave address 0. 0: Mask. The SLVQUAL0 field is used as a logical mask for matching address 0. 1: Extend. The SLVQAL0 field is used to extend address 0 matching in a range of addresses.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SLVQUAL0</name>
              <description>Slave address Qualifier for address 0. A value of 0 causes the address in SLVADR0 to be used as-is, assuming that it is enabled. If QUALMODE0 = 0, any bit in this field which is set to 1 will cause an automatic match of the corresponding bit of the received address when it is compared to the SLVADR0 register. If QUALMODE0 = 1, an address range is matched for address 0. This range extends from the value defined by SLVADR0 to the address defined by SLVQUAL0 (address matches when SLVADR0[7:1] received address SLVQUAL0[7:1]).</description>
              <bitOffset>1</bitOffset>
              <bitWidth>7</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MONRXDAT</name>
          <description>Monitor receiver data register.</description>
          <addressOffset>0x80</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0</resetValue>
          <resetMask>0x7FF</resetMask>
          <fields>
            <field>
              <name>MONRXDAT</name>
              <description>Monitor function Receiver Data. This reflects every data byte that passes on the I2C pins.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>MONSTART</name>
              <description>Monitor Received Start. 0: No start detected. The monitor function has not detected a Start event on the I2C bus. 1: Start detected. The Monitor function has detected a Start event on the I2C bus.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>MONRESTART</name>
              <description>Monitor Received Repeated Start. 0: No repeated start detected. The Monitor function has not detected a Repeated Start event on the I2C bus. 1: Repeate start detected. The Monitor function has detected a Repeated Start event on the I2C bus.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>MONNACK</name>
              <description>Monitor Received NACK. 0: Acknowledged. The data currently being provided by the Monitor function was acknowledged by at least one master or slave recevier. 1: Not Acknowledged. The data currently being provided by the Monitor function was not acknowledged by any receiver.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ID</name>
          <description>I2C Module Identifier</description>
          <addressOffset>0xFFC</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0xE0301300</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>APERTURE</name>
              <description>Aperture i.e. number minus 1 of consecutive packets 4 Kbytes reserved for this IP</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>MIN_REV</name>
              <description>Minor revision i.e. with no software consequences</description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>MAJ_REV</name>
              <description>Major revision i.e. there may be software incompatability between major revisions.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ID</name>
              <description>Identifier. This is the unique identifier of the module</description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral derivedFrom="I2C0">
      <name>I2C1</name>
      <description>This is the description of component i2c It is an Inter IC with APB bus interface. More details will follow.</description>
      <alternatePeripheral>FLEXCOMM3</alternatePeripheral>
      <groupName>I2C</groupName>
      <baseAddress>0x40004000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>0x1000</size>
        <usage>registers</usage>
      </addressBlock>
      <interrupt>
        <name>FLEXCOMM3</name>
        <value>14</value>
      </interrupt>
    </peripheral>
    <peripheral derivedFrom="I2C0">
      <name>I2C2</name>
      <description>This is the description of component i2c It is an Inter IC with APB bus interface. More details will follow.</description>
      <alternatePeripheral>FLEXCOMM6</alternatePeripheral>
      <groupName>I2C</groupName>
      <baseAddress>0x40005000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>0x1000</size>
        <usage>registers</usage>
      </addressBlock>
      <interrupt>
        <name>FLEXCOMM6</name>
        <value>28</value>
      </interrupt>
    </peripheral>
    <peripheral>
      <name>ISO7816</name>
      <description>This is the description of component iso7816 It is an ISO7816 controller with APB bus interface. More details will follow.</description>
      <groupName>ISO7816</groupName>
      <baseAddress>0x40006000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>0x6C</size>
        <usage>registers</usage>
      </addressBlock>
      <interrupt>
        <name>ISO7816</name>
        <value>46</value>
      </interrupt>
      <registers>
        <register>
          <name>SSR</name>
          <description>Slot Select Register</description>
          <addressOffset>0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x1</resetValue>
          <resetMask>0x1</resetMask>
          <fields>
            <field>
              <name>SOFTRESETN</name>
              <description>When set to logic 0 this bit resets the whole Contact UART (software reset), sets to logic 1 automatically by hardware after after one clock cycle if slot 1 is not activated else after one clock cycle after slot 1 has been automatically deactivated. Software should check soft reset is finished by reading SSR register before any further action.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SEQ_EN</name>
              <description>Set this bit to enable the sequencer. If this field is 0b, the sequencer will not respond to the Start control bit.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PDR1_LSB</name>
          <description>Programmable Divider Register (LSB) slot 1. Least significant byte of a 16-bit counter defining the ETU. The ETU counter counts a number of cycles of the Contact Interface clock, this defines the ETU. The minimum acceptable value is 0001 0000b.</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x74</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDR1_LSB</name>
              <description>Programmable Divider Register (LSB) slot 1. Least significant byte of a 16-bit counter defining the ETU. The ETU counter counts a number of cycles of the Contact Interface clock, this defines the ETU. The minimum acceptable value is 0001 0000b.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PDR1_MSB</name>
          <description>Programmable Divider Register (MSB) slot 1. Most significant byte of a 16-bit counter defining the ETU. The ETU counter counts a number of cycles of the Contact Interface clock, this defines the ETU</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x1</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDR1_MSB</name>
              <description>Programmable Divider Register (MSB) slot 1. Most significant byte of a 16-bit counter defining the ETU. The ETU counter counts a number of cycles of the Contact Interface clock, this defines the ETU</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>FCR</name>
          <description>FIFO Control Register</description>
          <addressOffset>0xC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x1</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>FTC</name>
              <description>FIFO Threshold Configuration: Define the number of received or transmitted characters in the FIFO triggering the ft bit in USR1. The FIFO depth is 32 bytes. In reception mode, it enables to know that a number equals to ftc(4:0) + 1 bytes have been received. In transmission mode, ftc(4:0) equals to the number of remaining bytes into the FIFO. Be careful: in reception mode 00000 = length 1, and in transmission mode 00000 = length 0.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PEC</name>
              <description>Parity Error Count [For protocol T = 0] Set the number of allowed repetitions in reception or transmission mode before setting pe in ct_usr1_reg. The value 000 indicates that, if only one parity error has occurred, bit pe is set at logic 1; the value 111 indicates that bit pe will be set at logic 1 after 8 parity errors. If a correct character is received before the programmed error number is reached, the error counter will be reset. If the programmed number of allowed parity errors is reached, bit pe in register ct_usr1_reg will be set at logic 1. If a transmitted character has been naked by the card, then the Contact UART will automatically retransmit it up to a number of times equal to the value programmed in bits PEC(2:0); the character will be resent at 15 ETU. If a transmitted character is considered as correct by the card after having been naked a number of times less than the value programmed in bits PEC(2:0) +1, the error counter will be reset. If a transmitted has been naked by the card a number of times equal to the value programmed in bits PEC(2:0) +1, the transmission stops and bit pe in register ct_usr1_reg is set at logic 1. The firmware is supposed to deactivate the card. If not, the firmware has the possibility to pursue the transmission. By reading the number of bytes present into the FIFO (ffl bits), it can determine which character has been naked PEC +1 times by the card. It will then flush the FIFO (FIFO flush bit). The next step consits in unlocking the transmission using dispe bit. By writing this bit at logic level one (and then at logic level zero if the firmware still wants to check parity errors), the transmission is unlocked. The firmware can now write bytes into the FIFO. In transmission mode, if bits PEC(2:0) are at logic 0, then the automatic retransmission is invalidated. There is no retransmission; the transmission continues with the next character sent at 13 ETU. [For protocol T = 1]: The error counter has no action: bit pe is set at logic 1 at the first wrong received character.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GTR1</name>
          <description>Guard Time Register slot 1. Value used by the Contact UART notably in transmission mode. The Contact UART will wait this number of ETUs before transmitting the character. In protocol T=1, gtr = FFh means operation at 11 ETUs. In protocol T=0, gtr = FFh means operation at 12 ETUs.</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>GTR1</name>
              <description>Guard Time Register slot 1. Value used by the Contact UART notably in transmission mode. The Contact UART will wait this number of ETUs before transmitting the character. In protocol T=1, gtr = FFh means operation at 11 ETUs. In protocol T=0, gtr = FFh means operation at 12 ETUs.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UCR11</name>
          <description>UART Configuration Register 1 slot 1</description>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0x3F</resetMask>
          <fields>
            <field>
              <name>CONV</name>
              <description>CONVention: Bit CONV is set to logic 1 if the convention is direct. Bit CONV is either automatically written by hardware according to the convention detected during ATR, or by software if the bit AUTOCONV in register ct_ucr1_reg is set to logic 1.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>LCT</name>
              <description>Last Character to Transmit: Bit LCT is set to logic 1 by software before writing the last character to be transmitted in register ct_utr_reg. It allows automatic change to reception mode. It is reset to logic 0 by hardware at the end of a successful transmission after 11.75 ETUs in protocol T = 0 and after 10.75 ETUs in protocol T = 1. When bit LCT is being reset to logic 0, bit T/R is also reset to logic 0 and the UART is ready to receive a character. LCT bit can be set to logic 1 by software not only when writing the last character to be transmitted but also during the transmission or even at the beginning of the transmission. It will be taken into account when the FIFO becomes empty, which implies for the software to be able to regularly re-load the FIFO when transmitting more than 32 bytes to ensure there is at least one byte into the FIFO as long as the transmission is not finished. Else, a switch to reception mode will prematurely occur before having transmitted all the bytes.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>T_R</name>
              <description>Transmit/Receive: Defines the mode: logic 1 means transmission and logic 0 reception. Bit T/R is set by software for transmission mode. Bit T/R is automatically reset to logic 0 by hardware, if bit LCT has been used before transmitting the last character. Note that when switching from/to reception to/from transmission mode, the FIFO is flushed. Any remaining bytes are lost.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PROT</name>
              <description>PROTocol: Selects the protocol: logic 1 means T=1 and logic 0 T=0.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FC</name>
              <description>Described in a separated document.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FIP</name>
              <description>Force Inverse Parity: If bit FIP is set to logic 1, the Contact UART will NAK a correctly received character, and will transmit characters with wrong parity bits.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UCR21</name>
          <description>UART Configuration Register 2 slot 1</description>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0xDF</resetMask>
          <fields>
            <field>
              <name>AUTOCONVN</name>
              <description>AUTOmatically detected CONVention: If bit AUTOCONV = 1, then the convention is set by software using bit CONV in register ct_ucr1_reg. If the bit is reset to logic 0, then the configuration is automatically detected on the first received character and the bit automatically set after convention detection.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MANBGT</name>
              <description>MANual BGT: When set to logic 1, BGT is managed by software, else by hardware.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DISFT</name>
              <description>DISable Fifo Threshold interrupt bit: When set to logic 1 the bit ft in register ct_usr1_reg will not generate interrupt.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DISPE</name>
              <description>DISable Parity Error interrupt bit: When set to logic 1, the parity is not checked in both reception and transmission modes, the bit pe in register ct_usr1_reg will not generate interrupt.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DISATRCOUNTER</name>
              <description>DISable ATR counter: [For Slot 1 only] When set to logic 1 the bits EARLY and MUTE in register ct_usr1_reg will not generate interrupt. This bit should be set before activating.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FIFOFLUSH</name>
              <description>FIFO flush: When set to logic 1, the FIFO is flushed whatever the mode (reception or transmission) is. It can be used before any reception or transmission of characters but not while receiving or transmitting a character. It is reset to logic 0 by hardware after one clk_ip cycle.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>WRDACC</name>
              <description>FIFO WoRD ACCess: When set to logic 1, the FIFO supports word (4 bytes) access (read and write), access failure is indicated by bit wrdaccerr in register USR2. When set to logic 0, the FIFO supports byte access (read and write).</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CCR1</name>
          <description>Clock Configuration Register slot 1</description>
          <addressOffset>0x1C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0x3F</resetMask>
          <fields>
            <field>
              <name>ACC</name>
              <description>Asynchronous Card Clock: Defines the card clock frequency: 000: card clock frequency = fclk_ip; 001: card clock frequency = fclk_ip /2; 010: card clock frequency = fclk_ip /3; 011: card clock frequency = fclk_ip /4; 100: card clock frequency = fclk_ip /5; 101: card clock frequency = fclk_ip /6; 110: card clock frequency = fclk_ip /8; 111: card clock frequency = fclk_ip /16. All frequency changes are synchronous, thus ensuring that no spikes or unwanted pulse widths occur during changes. In conjunction with registers ct_etucr_lsb_reg and ct_etucr_msb_reg, the bits ACC2, ACC1 and ACC0 defines the baudrate used by the Contact UART.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SAN</name>
              <description>Synchronous/Asynchronous Card: [For Slot 1]: When set to logic 1, the Contact UART supports synchronous card. The Contact UART is then bypassed, only bit 0 of registers ct_urr_reg and ct_utr_reg is connected to pin I/O. In this case, the card clock is controlled by bit SHL and RST card is controlled by bit RSTIN in register ct_pcr_reg. When set to logic 0, the Contact UART supports asynchronous card. Dynamic change (while activated) is not supported. The choice should be done before activating the card. [For Slot AUX]: When set to logic 1, the Contact UART supports synchronous card. The Contact UART is then bypassed, only bit 0 of registers ct_urr_reg and ct_utr_reg is connected to pin I/O. In this case, the card clock is controlled by bit SHL. When set to logic 0, the Contact UART supports asynchronous card. Dynamic change (while CLKAUXen = 1) is not supported. The choice should be done before enabling CLKAUX clock.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CST</name>
              <description>Clock STop: [For Slot 1]: In the case of an asynchronous card, bit CST defines whether the clock to the card is stopped or not; if bit CST is reset to logic 0, then the clock is determined by bits ACC0, ACC1 and ACC2. [For Slot AUX]+I40: This bit is not available for the auxiliary slot (ct_ccr2_reg) since clock stop feature is supported using CLKAUXen bit in ct_ssr_reg register.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SHL</name>
              <description>Stop HIGH or LOW: - Slot 1: If bits SAN = 0 and CST = 1, then the clock is stopped at LOW level. If bit SHL = 0, and at HIGH level if bit SHL = 1. I+I10f bit SAN = 1, then contact CLK is the copy of the value of bit SHL.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PCR</name>
          <description>Power Control Register</description>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xC0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PCR</name>
              <description>Power Control Register</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ECR</name>
          <description>Early answer Counter register</description>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xAA</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ECR</name>
              <description>Early answer Counter register</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MCRL_LSB</name>
          <description>Mute card Counter RST Low register (LSB)</description>
          <addressOffset>0x28</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x74</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MCRL_LSB</name>
              <description>Mute card Counter RST Low register (LSB)</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MCRL_MSB</name>
          <description>Mute card Counter RST Low register (MSB)</description>
          <addressOffset>0x2C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xA4</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MCRL_MSB</name>
              <description>Mute card Counter RST Low register (MSB)</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MCRH_LSB</name>
          <description>Mute card Counter RST High register (LSB)</description>
          <addressOffset>0x30</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x74</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MCRH_LSB</name>
              <description>Mute card Counter RST High register (LSB)</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MCRH_MSB</name>
          <description>Mute card Counter RST High register (MSB)</description>
          <addressOffset>0x34</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xA4</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MCRH_MSB</name>
              <description>Mute card Counter RST High register (MSB)</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>URR_UTR</name>
          <description>UART Receive Register / UART Transmit Register</description>
          <addressOffset>0x3C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>URR_UTR</name>
              <description>UART Receive Register / UART Transmit Register</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TOR1</name>
          <description>Time-Out Register 1</description>
          <addressOffset>0x4C</addressOffset>
          <size>32</size>
          <access>write-only</access>
          <resetValue>0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TOR1</name>
              <description>Time-Out Register 1</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TOR2</name>
          <description>Time-Out Register 2</description>
          <addressOffset>0x50</addressOffset>
          <size>32</size>
          <access>write-only</access>
          <resetValue>0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TOR2</name>
              <description>Time-Out Register 2</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TOR3</name>
          <description>Time-Out Register 3</description>
          <addressOffset>0x54</addressOffset>
          <size>32</size>
          <access>write-only</access>
          <resetValue>0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TOR3</name>
              <description>Time-Out Register 3</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TOC</name>
          <description>Time-Out Configuration register</description>
          <addressOffset>0x58</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TOC</name>
              <description>Time-Out Configuration register</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>FSR</name>
          <description>FIFO Status Register</description>
          <addressOffset>0x5C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>FSR</name>
              <description>FIFO Status Register</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MSR</name>
          <description>Mixed Status Register</description>
          <addressOffset>0x60</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x2</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MSR</name>
              <description>Mixed Status Register</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>USR1</name>
          <description>UART Status Register 1</description>
          <addressOffset>0x64</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>USR1</name>
              <description>UART Status Register 1</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>USR2</name>
          <description>UART Status Register 2</description>
          <addressOffset>0x68</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>USR2</name>
              <description>UART Status Register 2</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>CIC_IRB</name>
      <description>This is the description of component cic_irb. It is an Infra Red Blaster Controller with a VPB bus interface. More details will follow.</description>
      <groupName>CIC_IRB</groupName>
      <baseAddress>0x40007000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>0x1000</size>
        <usage>registers</usage>
      </addressBlock>
      <interrupt>
        <name>CIC_IRB</name>
        <value>3</value>
      </interrupt>
      <registers>
        <register>
          <name>CONF</name>
          <description>IR Blaster configuration</description>
          <addressOffset>0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x21</resetValue>
          <resetMask>0x3F</resetMask>
          <fields>
            <field>
              <name>ENV_INI</name>
              <description>Initial envelope value. This is the level of the first envelope after IR Blaster start or restart.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>LOW</name>
                  <description>First envelope will be a low level</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HIGH</name>
                  <description>First envelope will be a high level</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>MODE</name>
              <description>Blaster mode</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NORMAL</name>
                  <description>Normal mode. IR Blaster will stop when it encouter an envelope with ENV_LAST bit = '1'</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUTO</name>
                  <description>Automatic restart. IR Blaster will transmit all envelopes and stop only when FIFO becames empty. ENV_LAST bit only generates an interrupt but doesn't stop transmission.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>OUT</name>
              <description>Output logic function</description>
              <bitOffset>2</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>AND</name>
                  <description>envelope AND carrier</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>OR</name>
                  <description>envelope OR carrier</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NAND</name>
                  <description>envelope NAND carrier</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NOR</name>
                  <description>envelope NOR carrier</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>NO_CAR</name>
              <description>No carrier</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NORMAL</name>
                  <description>Normal. IR_OUT = envelope + carrier</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>STOP</name>
                  <description>Carrier is inhibited. IR_OUT = envelope only</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CAR_INI</name>
              <description>Initial carrier value.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>ZERO</name>
                  <description>Carrier starts with '0' (the carrier is low during CHIGH[1:0] and high during CLOW[2:0])</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ONE</name>
                  <description>Carrier starts with '1' (the carrier is high during CHIGH[1:0] and low during CLOW[2:0])</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>CARRIER</name>
          <description>IR Blaster carrier configuration</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0x1FFFFF</resetMask>
          <fields>
            <field>
              <name>CTU</name>
              <description>Carrier Time Unit (CTU) CTU = CTU * TIRCP, TIRCP = IR module clock period = 1/48MHz. Value 0x0 is equivalent to 0x1. It is recommended to modify this field when the blaster unit is disable (i.e when ENA_ST = '0' in STATUS register)</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CLOW</name>
              <description>Carrier low period. Carrier low level duration = (CLOW + 1) * CTU. It is recommended to modify this field when the blaster unit is disable (i.e when ENA_ST = '0' in STATUS register)</description>
              <bitOffset>16</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CHIGH</name>
              <description>Carrier high period Carrier high level duration = (CHIGH + 1) * CTU. It is recommended to modify this field when the blaster unit is disable (i.e when ENA_ST = '0' in STATUS register)</description>
              <bitOffset>19</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>FIFO_IN</name>
          <description>IR Blaster Envelope FIFO input</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0x3FFF</resetMask>
          <fields>
            <field>
              <name>ENV</name>
              <description>Envelope duration expressed in carrier period number. Tenvelope = ENV * (CHIGH + CLOW + 2 ) * CTU. Value 0x000 has the same behaviour has value 0x001.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>12</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ENV_INT</name>
              <description>Generate an interrupt when starting emission of the envelope</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_INT</name>
                  <description>Don't generate interrupt</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INT</name>
                  <description>Generate interrupt</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ENV_LAST</name>
              <description>Last envelope.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NOT_LAST</name>
                  <description>IR Blaster loads the next envelope when this envelope finishes.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LAST</name>
                  <description>IR Blaster stops and generates an interrupt when this envelope is completly transmitted. If MODE = '1', then IR Blaster only generates an interrupt</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>STATUS</name>
          <description>IR Blaster Status</description>
          <addressOffset>0xC</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x40</resetValue>
          <resetMask>0x1FF</resetMask>
          <fields>
            <field>
              <name>FIFO_LVL</name>
              <description>Current IR Blaster FIFO level</description>
              <bitOffset>0</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>EMPTY</name>
                  <description>FIFO is empty</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>FULL</name>
                  <description>FIFO is full</description>
                  <value>0x10</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>FIFO_FULL</name>
              <description>IR Blaster FIFO full flag</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NOT_FULL</name>
                  <description>FIFO is not full</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>FULL</name>
                  <description>FIFO is full (FIFO level = 100000)</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>FIFO_EMPTY</name>
              <description>IR Blaster FIFO empty flag</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NOT_EMPTY</name>
                  <description>FIFO is not empty</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>EMPTY</name>
                  <description>FIFO is empty (FIFO level = 000000)</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ENA_ST</name>
              <description>IR Blaster status</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DISABLE</name>
                  <description>IR Blaster is disabled</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENABLE</name>
                  <description>IR Blaster is enabled</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RUN_ST</name>
              <description>IR Blaster run status</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NOT_RUNNING</name>
                  <description>IR Blaster is not running. Either transmission has not yet been started or it is finished.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RUNNING</name>
                  <description>IR Blaster is running.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>CMD</name>
          <description>IR Blaster Commands</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>ENA</name>
              <description>Enable IR Blaster. This bit is self clearing.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_EFFECT</name>
                  <description>No effect</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENABLE</name>
                  <description>Enable IR Blaster</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DIS</name>
              <description>Disable IR Blaster. This bit is self clearing.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_EFFECT</name>
                  <description>No effect</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DISABLE</name>
                  <description>Disable IR Blaster. The transmission of envelopes is immediatly stopped. The FIFO is not reinitialized (the content of the FIFO is conserved).</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>START</name>
              <description>Start IR Blaster. This bit is self clearing.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_EFFECT</name>
                  <description>No effect</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>START</name>
                  <description>Start transmission Before setting this field, the blaster must be enable (the bit field ENA must be set first).</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>FIFO_RST</name>
              <description>Reset IR Blaster FIFO. This bit is self clearing.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_EFFECT</name>
                  <description>No effect</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RESET</name>
                  <description>Reset FIFO. IR Blaster FIFO is completly re-initialized all data present in FIFO are erased.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>INT_STATUS</name>
          <description>Interrupt Status</description>
          <addressOffset>0xFE0</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0</resetValue>
          <resetMask>0x7</resetMask>
          <fields>
            <field>
              <name>ENV_START_INT</name>
              <description>IR Blaster has started to transmit an envelope with ENV_INT bit = '1</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NOT_PENDING</name>
                  <description>Interrupt is not pending</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PENDING</name>
                  <description>Interrupt is pending</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ENV_LAST_INT</name>
              <description>IR Blaster has finished to transmit an envelope with ENV_LAST bit = '1'.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NOT_PENDING</name>
                  <description>Interrupt is not pending</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PENDING</name>
                  <description>Interrupt is pending</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>FIFO_UFL_INT</name>
              <description>IR Blaster FIFO underflow. IR Blaster has tried to transmit a data but the FIFO was empty.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NOT_PENDING</name>
                  <description>Interrupt is not pending</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PENDING</name>
                  <description>Interrupt is pending</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>INT_ENA</name>
          <description>Interrupt Enable</description>
          <addressOffset>0xFE4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0x7</resetMask>
          <fields>
            <field>
              <name>ENV_START_ENA</name>
              <description>Enable/Disable ENV_START interrupt</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DISABLE</name>
                  <description>Disable ENV_START interrupt</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENABLE</name>
                  <description>Enable ENV_START interrupt</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ENV_LAST_ENA</name>
              <description>Enable/Disable ENV_LAST interrupt</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DISABLE</name>
                  <description>Disable ENV_LAST interrupt</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENABLE</name>
                  <description>Enable ENV_LAST interrupt</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>FIFO_UFL_ENA</name>
              <description>Enable/Disable FIFO_UFL interrupt</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DISABLE</name>
                  <description>Disable FIFO_UFL interrupt</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENABLE</name>
                  <description>Enable FIFO_UFL nterrupt</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>INT_CLR</name>
          <description>Interrupt Clear</description>
          <addressOffset>0xFE8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>ENV_START_CLR</name>
              <description>Clear ENV_START interrupt</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_EFFECT</name>
                  <description>no effect</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CLEAR</name>
                  <description>clear ENV_START interrupt This bit is self clearing</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ENV_LAST_CLR</name>
              <description>Clear ENV_LAST interrupt</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_EFFECT</name>
                  <description>no effect</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CLEAR</name>
                  <description>clear ENV_LAST interrupt This bit is self clearing</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>FIFO_UFL_CLR</name>
              <description>Clear FIFO_UFL interrupt</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_EFFECT</name>
                  <description>no effect</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CLEAR</name>
                  <description>clear FIFO_UFL interrupt This bit is self clearing</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>INT_SET</name>
          <description>Interrupt Set</description>
          <addressOffset>0xFEC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>ENV_START_SET</name>
              <description>Set ENV_START interrupt</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_EFFECT</name>
                  <description>no effect</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CLEAR</name>
                  <description>set ENV_START interrupt This bit is self clearing</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ENV_LAST_SET</name>
              <description>Set ENV_LAST interrupt</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_EFFECT</name>
                  <description>no effect</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CLEAR</name>
                  <description>set ENV_LAST interrupt This bit is self clearing</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>FIFO_UFL_SET</name>
              <description>Set FIFO_UFL interrupt</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_EFFECT</name>
                  <description>no effect</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CLEAR</name>
                  <description>set FIFO_UFL interrupt This bit is self clearing</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>MODULE_ID</name>
          <description>IR Blaster Module Identifier</description>
          <addressOffset>0xFFC</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x1313000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>APERTURE</name>
              <description>Aperture i.e. number minus 1 of consecutive packets 4 Kbytes reserved for this IP</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>MIN_REV</name>
              <description>Minor revision i.e. with no software consequences</description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>MAJ_REV</name>
              <description>Major revision i.e. implies software modifications</description>
              <bitOffset>12</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ID</name>
              <description>Identifier. This is the unique identifier of the module</description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>FLASH</name>
      <description>This is the description of component input mux. . More details will follow.</description>
      <groupName>FLASH</groupName>
      <baseAddress>0x40009000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>0x1000</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>CMD</name>
          <description>command register</description>
          <addressOffset>0</addressOffset>
          <size>32</size>
          <access>write-only</access>
          <resetValue>0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CMD</name>
              <description>command register</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>EVENT</name>
          <description>event register</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>RST</name>
              <description>When bit is set, the controller and flash are reset.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>WAKEUP</name>
              <description>When bit is set, the controller wakes up from whatever low power or powerdown mode was active. If not in a powerdown mode, this bit has no effect.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>ABORT</name>
              <description>When bit is set, a running program/erase command is aborted.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>AUTOPROG</name>
          <description>specifies what commands are performed on AHB write</description>
          <addressOffset>0xC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0x3</resetMask>
          <fields>
            <field>
              <name>AUTOPROG</name>
              <description>Auto programmings configuration. 00: auto programming switched off. 01: execute write word . 10: execute write word then, if the last word in a page was written, program page . 11: reserved for future use / no action.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>STARTA</name>
          <description>start address for next flash command</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0x3FFFF</resetMask>
          <fields>
            <field>
              <name>STARTA</name>
              <description>Address / Start address for commands that take an address (range) as a parameter. The address is in units of memory words, not bytes.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>18</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>STOPA</name>
          <description>end address for next flash command, if command operates on address ranges</description>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0x3FFFF</resetMask>
          <fields>
            <field>
              <name>STOPA</name>
              <description>Stop address for commands that take an address range as a parameter (the word specified by STOPA is included in the address range). The address is in units of memory words, not bytes.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>18</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>4</dim>
          <dimIncrement>0x4</dimIncrement>
          <name>DATAW[%s]</name>
          <description>data register, word 0-3; Memory data, or command parameter, or command result.</description>
          <addressOffset>0x80</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DATAW</name>
              <description>data register, word 0-3; Memory data, or command parameter, or command result.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INT_CLR_ENABLE</name>
          <description>Clear interrupt enable bits</description>
          <addressOffset>0xFD8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>FAIL</name>
              <description>When a CLR_ENABLE bit is written to 1, the corresponding INT_ENABLE bit is cleared</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>ERR</name>
              <description>When a CLR_ENABLE bit is written to 1, the corresponding INT_ENABLE bit is cleared</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>DONE</name>
              <description>When a CLR_ENABLE bit is written to 1, the corresponding INT_ENABLE bit is cleared</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>ECC_ERR</name>
              <description>When a CLR_ENABLE bit is written to 1, the corresponding INT_ENABLE bit is cleared</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INT_SET_ENABLE</name>
          <description>Set interrupt enable bits</description>
          <addressOffset>0xFDC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>FAIL</name>
              <description>When a SET_ENABLE bit is written to 1, the corresponding INT_ENABLE bit is set</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>ERR</name>
              <description>When a SET_ENABLE bit is written to 1, the corresponding INT_ENABLE bit is set</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>DONE</name>
              <description>When a SET_ENABLE bit is written to 1, the corresponding INT_ENABLE bit is set</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>ECC_ERR</name>
              <description>When a SET_ENABLE bit is written to 1, the corresponding INT_ENABLE bit is set</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INT_STATUS</name>
          <description>Interrupt status bits</description>
          <addressOffset>0xFE0</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0</resetValue>
          <resetMask>0xF</resetMask>
          <fields>
            <field>
              <name>FAIL</name>
              <description>This status bit is set if execution of a (legal) command failed. The flag can be set at any time during command execution, not just at the end.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ERR</name>
              <description>This status bit is set if execution of an illegal command is detected. A command is illegal if it is unknown, or it is not allowed in the current mode, or it is violating access restrictions, or it has invalid parameters.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>DONE</name>
              <description>This status bit is set at the end of command execution</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ECC_ERR</name>
              <description>This status bit is set if, during a memory read operation (either a user-requested read, or a speculative read, or reads performed by a controller command), a correctable or uncorrectable error is detected by ECC decoding logic.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INT_ENABLE</name>
          <description>Interrupt enable bits</description>
          <addressOffset>0xFE4</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0</resetValue>
          <resetMask>0xF</resetMask>
          <fields>
            <field>
              <name>FAIL</name>
              <description>If an INT_ENABLE bit is set, an interrupt request will be generated if the corresponding INT_STATUS bit is high.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ERR</name>
              <description>If an INT_ENABLE bit is set, an interrupt request will be generated if the corresponding INT_STATUS bit is high.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>DONE</name>
              <description>If an INT_ENABLE bit is set, an interrupt request will be generated if the corresponding INT_STATUS bit is high.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ECC_ERR</name>
              <description>If an INT_ENABLE bit is set, an interrupt request will be generated if the corresponding INT_STATUS bit is high.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INT_CLR_STATUS</name>
          <description>Clear interrupt status bits</description>
          <addressOffset>0xFE8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>FAIL</name>
              <description>When a CLR_STATUS bit is written to 1, the corresponding INT_STATUS bit is cleared</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>ERR</name>
              <description>When a CLR_STATUS bit is written to 1, the corresponding INT_STATUS bit is cleared</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>DONE</name>
              <description>When a CLR_STATUS bit is written to 1, the corresponding INT_STATUS bit is cleared</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>ECC_ERR</name>
              <description>When a CLR_STATUS bit is written to 1, the corresponding INT_STATUS bit is cleared</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INT_SET_STATUS</name>
          <description>Set interrupt status bits</description>
          <addressOffset>0xFEC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>FAIL</name>
              <description>When a SET_STATUS bit is written to 1, the corresponding INT_STATUS bit is set</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>ERR</name>
              <description>When a SET_STATUS bit is written to 1, the corresponding INT_STATUS bit is set</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>DONE</name>
              <description>When a SET_STATUS bit is written to 1, the corresponding INT_STATUS bit is set</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>ECC_ERR</name>
              <description>When a SET_STATUS bit is written to 1, the corresponding INT_STATUS bit is set</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MODULE_ID</name>
          <description>Controller and Memory module identification</description>
          <addressOffset>0xFFC</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0xC40F1500</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>APERTURE</name>
              <description>Aperture i.e. number minus 1 of consecutive packets 4 Kbytes reserved for this IP</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>MINOR_REV</name>
              <description>Minor revision i.e. with no software consequences</description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>MAJOR_REV</name>
              <description>Major revision i.e. implies software modifications</description>
              <bitOffset>12</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ID</name>
              <description>Identifier. This is the unique identifier of the module</description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>WWDT</name>
      <description>This is the description of component wwdt It is an Windowed Watchdog Timer with APB bus interface. More details will follow.</description>
      <groupName>WWDT</groupName>
      <baseAddress>0x4000A000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>0x1C</size>
        <usage>registers</usage>
      </addressBlock>
      <interrupt>
        <name>WDT_BOD</name>
        <value>0</value>
      </interrupt>
      <registers>
        <register>
          <name>MOD</name>
          <description>Watchdog mode register. This register contains the basic mode and status of the Watchdog Timer.</description>
          <addressOffset>0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0x3F</resetMask>
          <fields>
            <field>
              <name>WDEN</name>
              <description>Watchdog enable bit. Once this bit is set to one and a watchdog feed is performed, the watchdog timer will run permanently. 0: The watchdog timer is stopped. 1: The watchdog timer is running.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>WDRESET</name>
              <description>Watchdog reset enable bit. Once this bit has been written with a 1 it cannot be re-written with a 0. 0: Interrupt. A watchdog time-out will not cause a chip reset. It will cause an interrupt of the watchdog. 1: Reset. A watchdog time-out will cause a chip reset.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>WDTOF</name>
              <description>Watchdog time-out flag. Set when the watchdog timer times out, by a feed error, or by events associated with WDPROTECT. Cleared by software writing a 0 to this bit position. Causes a chip reset if WDRESET = 1.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>WDINT</name>
              <description>Warning interrupt flag. Set when the timer reaches the value in WDWARNINT. Cleared by software writing a 1 to this bit position. Note that this bit cannot be cleared while the WARNINT value is equal to the value of the TV register. This can occur if the value of WARNINT is 0 and the WDRESET bit is 0 when TV decrements to 0.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>WDPROTECT</name>
              <description>Watchdog update mode. This bit can be set once by software and is only cleared by a reset. 0: Flexible. A feed sequence can be performed at any time; ie. the watchdog timer can be reloaded with time-out value (TC) at any time. 1: Threshold. A feed sequence can be performed only after the counter is below the value of WDWARNINT and WDWINDOW; ie. the watchdog timer can be reloaded with time-out value (TC) only when the counter timer value is below the value of WDWARNINT and WDWINDOW, otherwise a 'feed error' is created.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TC</name>
          <description>Watchdog timer constant register. This 24-bit register determines the time-out value.</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xFF</resetValue>
          <resetMask>0xFFFFFF</resetMask>
          <fields>
            <field>
              <name>COUNT</name>
              <description>Watchdog time-out value. If MOD.WDPROTECT is set then changing this value may cause an error.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>FEED</name>
          <description>Watchdog feed sequence register. Writing 0xAA followed by 0x55 to this register reloads the Watchdog timer with the value contained in TC.</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>FEED</name>
              <description>Feed value should be 0xAA followed by 0x55. Writing 0xAA followed by 0x55 to this register will reload the Watchdog timer with the TC value. This operation will also start the Watchdog if it is enabled via the WDMOD register. Setting the WDEN bit in the WDMOD register is not sufficient to enable the Watchdog. A valid feed sequence must be completed after setting WDEN before the Watchdog is capable of generating a reset. Until then, the Watchdog will ignore feed errors.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TV</name>
          <description>Watchdog timer value register. This 24-bit register reads out the current value of the Watchdog timer.</description>
          <addressOffset>0xC</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0xFF</resetValue>
          <resetMask>0xFFFFFF</resetMask>
          <fields>
            <field>
              <name>COUNT</name>
              <description>Counter timer value. The TV register is used to read the current value of Watchdog timer counter.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>WARNINT</name>
          <description>Watchdog Warning Interrupt compare value.</description>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0x3FF</resetMask>
          <fields>
            <field>
              <name>WARNINT</name>
              <description>Watchdog warning interrupt compare value.A match of the watchdog timer counter to WARNINT occurs when the bottom 10 bits of the counter have the same value as the 10 bits of WARNINT, and the remaining upper bits of the counter are all 0. This gives a maximum time of 1,023 watchdog timer counts (4,096 watchdog clocks) for the interrupt to occur prior to a watchdog event. If WARNINT is 0, the interrupt will occur at the same time as the watchdog event.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>10</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>WINDOW</name>
          <description>Watchdog Window compare value.</description>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xFFFFFF</resetValue>
          <resetMask>0xFFFFFF</resetMask>
          <fields>
            <field>
              <name>WINDOW</name>
              <description>Watchdog window value. The WINDOW register determines the highest TV value allowed when a watchdog feed is performed. If a feed sequence occurs when TV is greater than the value in WINDOW, a watchdog event will occur</description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>RTC</name>
      <description>This is the description of component rtc It is Real Time Clock with APB bus interface. More details will follow.</description>
      <groupName>RTC</groupName>
      <baseAddress>0x4000B000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>0x10</size>
        <usage>registers</usage>
      </addressBlock>
      <interrupt>
        <name>RTC</name>
        <value>29</value>
      </interrupt>
      <registers>
        <register>
          <name>CTRL</name>
          <description>RTC control register</description>
          <addressOffset>0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x1</resetValue>
          <resetMask>0xFD</resetMask>
          <fields>
            <field>
              <name>SWRESET</name>
              <description>Software reset control. 0: Not in reset. The RTC is not held in reset. This bit must be cleared prior to configuring or initiating any operation of the RTC. 1: In reset. The RTC is held in reset. All register bits within the RTC will be forced to their reset value except the OFD bit. This bit must be cleared before writing to any register in the RTC - including writes to set any of the other bits within this register. Do not attempt to write to any bits of this register at the same time that the reset bit is being cleared.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ALARM1HZ</name>
              <description>RTC 32-bit timer alarm flag status. 0: No match has occurred on the 32-bit RTC timer. Writing a 0 has no effect. 1: A match condition has occurred on the 32-bit RTC timer. This flag generates an RTC alarm interrupt request. RTC_ALARM which can also wake up the part from low power modes (excluding deep power down mode). Writing a 1 clears this bit.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>WAKE1KHZ</name>
              <description>RTC 16-bit timer wake-up flag status. 0: The RTC 16-bit timer is running. Writing a 0 has no effect. 1: The 16-bit timer has timed out. This flag generates an RTC wake-up interrupt request RTC-WAKE which can also wake up the part from low power modes (excluding deep power down mode). Writing a 1 clears this bit.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ALARMDPD_EN</name>
              <description>RTC 32-bit timer alarm enable for Low power mode. 0: Disable. A match on the 32-bit RTC timer will not bring the part out of power-down modes. 1: Enable. A match on the 32-bit RTC timer will bring the part out of power-down modes.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>WAKEDPD_EN</name>
              <description>RTC 16-bit timer wake-up enable for power-down modes. 0: Disable. A match on the 16-bit RTC timer will not bring the part out of power-down modes. 1: Enable. A match on the 16-bit RTC timer will bring the part out of power-down modes.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RTC1KHZ_EN</name>
              <description>RTC 16-bit timer clock enable. This bit can be set to 0 to conserve power if the 16-bit timer is not used. This bit has no effect when the RTC is disabled (bit 7 of this register is 0). 0: Disable. A match on the 16-bit RTC timer will not bring the part out of Deep power-down mode. 1: Enable. The 16-bit RTC timer is enabled.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RTC_EN</name>
              <description>RTC enable. 0: Disable. The RTC 32-bit timer and 16-bit timer clocks are shut down and the RTC operation is disabled. This bit should be 0 when writing to load a value in the RTC counter register. 1: Enable. The 32-bit RTC clock is running and RTC operation is enabled. This bit must be set to initiate operation of the RTC. To also enable the 16-bit timer clock, set bit 6 in this register.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MATCH</name>
          <description>RTC 32-bit counter match register</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xFFFFFFFF</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MATVAL</name>
              <description>Contains the match value against which the 1 Hz RTC timer will be compared to generate the alarm flag RTC_ALARM and generate an alarm interrupt/wake-up if enabled.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>COUNT</name>
          <description>RTC 32-bit counter register</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>VAL</name>
              <description>A read reflects the current value of the main, 32-bit, RTC timer. A write loads a new initial value into the timer. The RTC 32-bit counter will count up continuously at the 32-bit timer clock rate once the RTC Software Reset is removed (by clearing bit 0 of the CTRL register). Remark: Only write to this register when the RTC_EN bit in the RTC CTRL Register is 0.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>WAKE</name>
          <description>16-bit RTC timer register</description>
          <addressOffset>0xC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>VAL</name>
              <description>A read reflects the current value of 16-bit timer. A write pre-loads a start count value into the 16-bit timer and initializes a count-down sequence. Do not write to this register while counting is in progress.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>PWM</name>
      <description>This is the description of component pwm. It is a Pulse Width Modulation Controller with an APB bus interface. More details will follow.</description>
      <groupName>PWM</groupName>
      <baseAddress>0x4000C000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>0x1000</size>
        <usage>registers</usage>
      </addressBlock>
      <interrupt>
        <name>PWM0</name>
        <value>17</value>
      </interrupt>
      <interrupt>
        <name>PWM1</name>
        <value>18</value>
      </interrupt>
      <interrupt>
        <name>PWM2</name>
        <value>19</value>
      </interrupt>
      <interrupt>
        <name>PWM3</name>
        <value>20</value>
      </interrupt>
      <interrupt>
        <name>PWM4</name>
        <value>21</value>
      </interrupt>
      <interrupt>
        <name>PWM5</name>
        <value>22</value>
      </interrupt>
      <interrupt>
        <name>PWM6</name>
        <value>23</value>
      </interrupt>
      <interrupt>
        <name>PWM7</name>
        <value>24</value>
      </interrupt>
      <interrupt>
        <name>PWM8</name>
        <value>25</value>
      </interrupt>
      <interrupt>
        <name>PWM9</name>
        <value>26</value>
      </interrupt>
      <interrupt>
        <name>PWM10</name>
        <value>27</value>
      </interrupt>
      <registers>
        <register>
          <name>CTRL0</name>
          <description>PWM 1st Control Register (Channel 0 to Channel 10) for channel enables and interrupt enables. Note if all interrupts are enabled with short period timings it will not be possible to manage all the interrupts.</description>
          <addressOffset>0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0x7FF07FF</resetMask>
          <fields>
            <field>
              <name>PWM_EN_0</name>
              <description>PWM channel 0 enable. 0 = Disable / 1 = Enable.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PWM_EN_1</name>
              <description>PWM channel 1 enable. 0 = Disable / 1 = Enable.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PWM_EN_2</name>
              <description>PWM channel 2 enable. 0 = Disable / 1 = Enable.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PWM_EN_3</name>
              <description>PWM channel 3 enable. 0 = Disable / 1 = Enable.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PWM_EN_4</name>
              <description>PWM channel 4 enable. 0 = Disable / 1 = Enable.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PWM_EN_5</name>
              <description>PWM channel 5 enable. 0 = Disable / 1 = Enable.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PWM_EN_6</name>
              <description>PWM channel 6 enable. 0 = Disable / 1 = Enable.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PWM_EN_7</name>
              <description>PWM channel 7 enable. 0 = Disable / 1 = Enable.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PWM_EN_8</name>
              <description>PWM channel 8 enable. 0 = Disable / 1 = Enable.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PWM_EN_9</name>
              <description>PWM channel 9 enable. 0 = Disable / 1 = Enable.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PWM_EN_10</name>
              <description>PWM channel 10 enable. 0 = Disable / 1 = Enable. Note, this enables the common PWM mode where PWM10 will be routed to all PWM channels.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>INT_EN_0</name>
              <description>PWM channel 0 interrupt enable. 0 = Disable / 1 = Enable.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>INT_EN_1</name>
              <description>PWM channel 1 interrupt enable. 0 = Disable / 1 = Enable.</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>INT_EN_2</name>
              <description>PWM channel 2 interrupt enable. 0 = Disable / 1 = Enable.</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>INT_EN_3</name>
              <description>PWM channel 3 interrupt enable. 0 = Disable / 1 = Enable.</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>INT_EN_4</name>
              <description>PWM channel 4 interrupt enable. 0 = Disable / 1 = Enable.</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>INT_EN_5</name>
              <description>PWM channel 5 interrupt enable. 0 = Disable / 1 = Enable.</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>INT_EN_6</name>
              <description>PWM channel 6 interrupt enable. 0 = Disable / 1 = Enable.</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>INT_EN_7</name>
              <description>PWM channel 7 interrupt enable. 0 = Disable / 1 = Enable.</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>INT_EN_8</name>
              <description>PWM channel 8 interrupt enable. 0 = Disable / 1 = Enable.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>INT_EN_9</name>
              <description>PWM channel 9 interrupt enable. 0 = Disable / 1 = Enable.</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>INT_EN_10</name>
              <description>PWM channel 10 interrupt enable. 0 = Disable / 1 = Enable.</description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CTRL1</name>
          <description>PWM 2nd Control Register (Channel 0 to Channel 10) for channel polarity and output state for a disabled channel.</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0x3FF07FF</resetMask>
          <fields>
            <field>
              <name>POL_0</name>
              <description>PWM channel 0 waveform Polarity control. 0: Set high on compare match, set low at the end of PWM period. 1: Set low on compare match, set high at the end of PWM period</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>POL_1</name>
              <description>PWM channel 1 waveform Polarity control. 0: Set high on compare match, set low at the end of PWM period. 1: Set low on compare match, set high at the end of PWM period</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>POL_2</name>
              <description>PWM channel 2 waveform Polarity control. 0: Set high on compare match, set low at the end of PWM period. 1: Set low on compare match, set high at the end of PWM period</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>POL_3</name>
              <description>PWM channel 3 waveform Polarity control. 0: Set high on compare match, set low at the end of PWM period. 1: Set low on compare match, set high at the end of PWM period</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>POL_4</name>
              <description>PWM channel 4 waveform Polarity control. 0: Set high on compare match, set low at the end of PWM period. 1: Set low on compare match, set high at the end of PWM period</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>POL_5</name>
              <description>PWM channel 5 waveform Polarity control. 0: Set high on compare match, set low at the end of PWM period. 1: Set low on compare match, set high at the end of PWM period</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>POL_6</name>
              <description>PWM channel 6 waveform Polarity control. 0: Set high on compare match, set low at the end of PWM period. 1: Set low on compare match, set high at the end of PWM period</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>POL_7</name>
              <description>PWM channel 7 waveform Polarity control. 0: Set high on compare match, set low at the end of PWM period. 1: Set low on compare match, set high at the end of PWM period</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>POL_8</name>
              <description>PWM channel 8 waveform Polarity control. 0: Set high on compare match, set low at the end of PWM period. 1: Set low on compare match, set high at the end of PWM period</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>POL_9</name>
              <description>PWM channel 9 waveform Polarity control. 0: Set high on compare match, set low at the end of PWM period. 1: Set low on compare match, set high at the end of PWM period</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>POL_10</name>
              <description>PWM channel 10 waveform Polarity control. 0: Set high on compare match, set low at the end of PWM period. 1: Set low on compare match, set high at the end of PWM period</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DIS_LEVEL_0</name>
              <description>PWM channel 0 output level when PWM channel 0 is disable. 0 = Low Level / 1 = High Level.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DIS_LEVEL_1</name>
              <description>PWM channel 1 output level when PWM channel 0 is disable. 0 = Low Level / 1 = High Level.</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DIS_LEVEL_2</name>
              <description>PWM channel 2 output level when PWM channel 0 is disable. 0 = Low Level / 1 = High Level.</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DIS_LEVEL_3</name>
              <description>PWM channel 3 output level when PWM channel 0 is disable. 0 = Low Level / 1 = High Level.</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DIS_LEVEL_4</name>
              <description>PWM channel 4 output level when PWM channel 0 is disable. 0 = Low Level / 1 = High Level.</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DIS_LEVEL_5</name>
              <description>PWM channel 5 output level when PWM channel 0 is disable. 0 = Low Level / 1 = High Level.</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DIS_LEVEL_6</name>
              <description>PWM channel 6 output level when PWM channel 0 is disable. 0 = Low Level / 1 = High Level.</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DIS_LEVEL_7</name>
              <description>PWM channel 7 output level when PWM channel 0 is disable. 0 = Low Level / 1 = High Level.</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DIS_LEVEL_8</name>
              <description>PWM channel 8 output level when PWM channel 0 is disable. 0 = Low Level / 1 = High Level.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DIS_LEVEL_9</name>
              <description>PWM channel 9 output level when PWM channel 0 is disable. 0 = Low Level / 1 = High Level.</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PSCL01</name>
          <description>PWM Channels 0 &amp; 1 prescalers</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0x3FF03FF</resetMask>
          <fields>
            <field>
              <name>PSCL_0</name>
              <description>PWM channel 0 prescaler. The output frequency equals to clk/(PSCL_0 + 1)</description>
              <bitOffset>0</bitOffset>
              <bitWidth>10</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PSCL_1</name>
              <description>PWM channel 1 prescaler. The output frequency equals to clk/(PSCL_1 + 1)</description>
              <bitOffset>16</bitOffset>
              <bitWidth>10</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PSCL23</name>
          <description>PWM Channels 2 &amp; 3 prescalers</description>
          <addressOffset>0xC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0x3FF03FF</resetMask>
          <fields>
            <field>
              <name>PSCL_2</name>
              <description>PWM channel 2 prescaler. The output frequency equals to clk/(PSCL_2 + 1)</description>
              <bitOffset>0</bitOffset>
              <bitWidth>10</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PSCL_3</name>
              <description>PWM channel 3 prescaler. The output frequency equals to clk/(PSCL_3 + 1)</description>
              <bitOffset>16</bitOffset>
              <bitWidth>10</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PSCL45</name>
          <description>PWM Channels 4 &amp; 5 prescalers</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0x3FF03FF</resetMask>
          <fields>
            <field>
              <name>PSCL_4</name>
              <description>PWM channel 4 prescaler. The output frequency equals to clk/(PSCL_4 + 1)</description>
              <bitOffset>0</bitOffset>
              <bitWidth>10</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PSCL_5</name>
              <description>PWM channel 5 prescaler. The output frequency equals to clk/(PSCL_5 + 1)</description>
              <bitOffset>16</bitOffset>
              <bitWidth>10</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PSCL67</name>
          <description>PWM Channels 6 &amp; 7 prescalers</description>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0x3FF03FF</resetMask>
          <fields>
            <field>
              <name>PSCL_6</name>
              <description>PWM channel 6 prescaler. The output frequency equals to clk/(PSCL_6 + 1)</description>
              <bitOffset>0</bitOffset>
              <bitWidth>10</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PSCL_7</name>
              <description>PWM channel 7 prescaler. The output frequency equals to clk/(PSCL_7 + 1)</description>
              <bitOffset>16</bitOffset>
              <bitWidth>10</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PSCL89</name>
          <description>PWM Channels 8 &amp; 9 prescalers</description>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0x3FF03FF</resetMask>
          <fields>
            <field>
              <name>PSCL_8</name>
              <description>PWM channel 8 prescaler. The output frequency equals to clk/(PSCL_8 + 1)</description>
              <bitOffset>0</bitOffset>
              <bitWidth>10</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PSCL_9</name>
              <description>PWM channel 9 prescaler. The output frequency equals to clk/(PSCL_9 + 1)</description>
              <bitOffset>16</bitOffset>
              <bitWidth>10</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PSCL1011</name>
          <description>PWM Channel 10 prescaler</description>
          <addressOffset>0x1C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0x3FF</resetMask>
          <fields>
            <field>
              <name>PSCL_10</name>
              <description>PWM channel 10 prescaler. The output frequency equals to clk/(PSCL_10 + 1)</description>
              <bitOffset>0</bitOffset>
              <bitWidth>10</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PCP0</name>
          <description>PWM Channel 0 Period and Compare register. Counter will count down from period to zero. When Comapre value is reached PWM output will change on next counter decrement and be stable from 'Compare-1' to 0.</description>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xFFFFFFFF</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PERIOD</name>
              <description>PWM channel 0 period register. The actual period equals to [PERIOD + 1]. 'PERIOD' must not be 0x0.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>COMPARE</name>
              <description>PWM channel 0 compare register. 'COMPARE' must not be 0x0.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PCP1</name>
          <description>PWM Channel 1 Period and Compare register. Counter will count down from period to zero. When Comapre value is reached PWM output will change on next counter decrement and be stable from 'Compare-1' to 0.</description>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xFFFFFFFF</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PERIOD</name>
              <description>PWM channel 1 period register. The actual period equals to [PERIOD + 1]. 'PERIOD' must not be 0x0.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>COMPARE</name>
              <description>PWM channel 1 compare register. 'COMPARE' must not be 0x0.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PCP2</name>
          <description>PWM Channel 2 Period and Compare register. Counter will count down from period to zero. When Comapre value is reached PWM output will change on next counter decrement and be stable from 'Compare-1' to 0.</description>
          <addressOffset>0x28</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xFFFFFFFF</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PERIOD</name>
              <description>PWM channel 2 period register. The actual period equals to [PERIOD + 1]. 'PERIOD' must not be 0x0.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>COMPARE</name>
              <description>PWM channel 2 compare register. 'COMPARE' must not be 0x0.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PCP3</name>
          <description>PWM Channel 3 Period and Compare register. Counter will count down from period to zero. When Comapre value is reached PWM output will change on next counter decrement and be stable from 'Compare-1' to 0.</description>
          <addressOffset>0x2C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xFFFFFFFF</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PERIOD</name>
              <description>PWM channel 3 period register. The actual period equals to [PERIOD + 1]. 'PERIOD' must not be 0x0.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>COMPARE</name>
              <description>PWM channel 3 compare register. 'COMPARE' must not be 0x0.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PCP4</name>
          <description>PWM Channel 4 Period and Compare register. Counter will count down from period to zero. When Comapre value is reached PWM output will change on next counter decrement and be stable from 'Compare-1' to 0.</description>
          <addressOffset>0x30</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xFFFFFFFF</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PERIOD</name>
              <description>PWM channel 4 period register. The actual period equals to [PERIOD + 1]. 'PERIOD' must not be 0x0.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>COMPARE</name>
              <description>PWM channel 4 compare register. 'COMPARE' must not be 0x0.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PCP5</name>
          <description>PWM Channel 5 Period and Compare register. Counter will count down from period to zero. When Comapre value is reached PWM output will change on next counter decrement and be stable from 'Compare-1' to 0.</description>
          <addressOffset>0x34</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xFFFFFFFF</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PERIOD</name>
              <description>PWM channel 5 period register. The actual period equals to [PERIOD + 1]. 'PERIOD' must not be 0x0.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>COMPARE</name>
              <description>PWM channel 5 compare register. 'COMPARE' must not be 0x0.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PCP6</name>
          <description>PWM Channel 6 Period and Compare register. Counter will count down from period to zero. When Comapre value is reached PWM output will change on next counter decrement and be stable from 'Compare-1' to 0.</description>
          <addressOffset>0x38</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xFFFFFFFF</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PERIOD</name>
              <description>PWM channel 6 period register. The actual period equals to [PERIOD + 1]. 'PERIOD' must not be 0x0.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>COMPARE</name>
              <description>PWM channel 6 compare register. 'COMPARE' must not be 0x0.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PCP7</name>
          <description>PWM Channel 7 Period and Compare register. Counter will count down from period to zero. When Comapre value is reached PWM output will change on next counter decrement and be stable from 'Compare-1' to 0.</description>
          <addressOffset>0x3C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xFFFFFFFF</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PERIOD</name>
              <description>PWM channel 7 period register. The actual period equals to [PERIOD + 1]. 'PERIOD' must not be 0x0.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>COMPARE</name>
              <description>PWM channel 7 compare register. 'COMPARE' must not be 0x0.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PCP8</name>
          <description>PWM Channel 8 Period and Compare register. Counter will count down from period to zero. When Comapre value is reached PWM output will change on next counter decrement and be stable from 'Compare-1' to 0.</description>
          <addressOffset>0x40</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xFFFFFFFF</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PERIOD</name>
              <description>PWM channel 8 period register. The actual period equals to [PERIOD + 1]. 'PERIOD' must not be 0x0.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>COMPARE</name>
              <description>PWM channel 8 compare register. 'COMPARE' must not be 0x0.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PCP9</name>
          <description>PWM Channel 9 Period and Compare register. Counter will count down from period to zero. When Comapre value is reached PWM output will change on next counter decrement and be stable from 'Compare-1' to 0.</description>
          <addressOffset>0x44</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xFFFFFFFF</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PERIOD</name>
              <description>PWM channel 9 period register. The actual period equals to [PERIOD + 1]. 'PERIOD' must not be 0x0.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>COMPARE</name>
              <description>PWM channel 9 compare register. 'COMPARE' must not be 0x0.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PCP10</name>
          <description>PWM Channel 10 Period and Compare register. Counter will count down from period to zero. When Comapre value is reached all PWM outputs will change on next counter decrement and be stable from 'Compare-1' to 0.</description>
          <addressOffset>0x48</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xFFFFFFFF</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PERIOD</name>
              <description>PWM channel 10 period register. The actual period equals to [PERIOD + 1]. 'PERIOD' must not be 0x0.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>COMPARE</name>
              <description>PWM channel 10 compare register. 'COMPARE' must not be 0x0.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PST0</name>
          <description>PWM 1st Status Register (Channel 0 to Channel 3)</description>
          <addressOffset>0x4C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0x1010101</resetMask>
          <fields>
            <field>
              <name>INT_FLG_0</name>
              <description>PWM channel 0 interrupt flag. 0: No interrupt pending. 1: Interrupt pending. Write 1 to clear the interrupt.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>INT_FLG_1</name>
              <description>PWM channel 1 interrupt flag. 0: No interrupt pending. 1: Interrupt pending. Write 1 to clear the interrupt.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>INT_FLG_2</name>
              <description>PWM channel 2 interrupt flag. 0: No interrupt pending. 1: Interrupt pending. Write 1 to clear the interrupt.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>INT_FLG_3</name>
              <description>PWM channel 3 interrupt flag. 0: No interrupt pending. 1: Interrupt pending. Write 1 to clear the interrupt.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PST1</name>
          <description>PWM 2nd Status Register (Channel 4 to Channel 7)</description>
          <addressOffset>0x50</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0x1010101</resetMask>
          <fields>
            <field>
              <name>INT_FLG_4</name>
              <description>PWM channel 4 interrupt flag. 0: No interrupt pending. 1: Interrupt pending. Write 1 to clear the interrupt.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>INT_FLG_5</name>
              <description>PWM channel 5 interrupt flag. 0: No interrupt pending. 1: Interrupt pending. Write 1 to clear the interrupt.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>INT_FLG_6</name>
              <description>PWM channel 6 interrupt flag. 0: No interrupt pending. 1: Interrupt pending. Write 1 to clear the interrupt.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>INT_FLG_7</name>
              <description>PWM channel 7 interrupt flag. 0: No interrupt pending. 1: Interrupt pending. Write 1 to clear the interrupt.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PST2</name>
          <description>PWM 3rd Status Register (Channel 8 to Channel 10)</description>
          <addressOffset>0x54</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0x10101</resetMask>
          <fields>
            <field>
              <name>INT_FLG_8</name>
              <description>PWM channel 8 interrupt flag. 0: No interrupt pending. 1: Interrupt pending. Write 1 to clear the interrupt.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>INT_FLG_9</name>
              <description>PWM channel 9 interrupt flag. 0: No interrupt pending. 1: Interrupt pending. Write 1 to clear the interrupt.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>INT_FLG_10</name>
              <description>PWM channel 10 interrupt flag. 0: No interrupt pending. 1: Interrupt pending. Write 1 to clear the interrupt.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MODULE_ID</name>
          <description>PWM Module Identifier ('PW' in ASCII)</description>
          <addressOffset>0xFFC</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x50570000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>APERTURE</name>
              <description>Aperture i.e. number minus 1 of consecutive packets 4 Kbytes reserved for this IP</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>MIN_REV</name>
              <description>Minor revision i.e. with no software consequences</description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>MAJ_REV</name>
              <description>Major revision i.e. implies software modifications</description>
              <bitOffset>12</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ID</name>
              <description>Identifier. This is the unique identifier of the module</description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>RNG</name>
      <description>This is the description of component rng. It is an Universal Synchrnous/Asynchrnous Receiver/Transmitter with APB bus interface. More details will follow.</description>
      <groupName>RNG</groupName>
      <baseAddress>0x4000D000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>0x1000</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>RANDOM_NUMBER</name>
          <description>Random number</description>
          <addressOffset>0</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RAND_NUM</name>
              <description>This register contains a random 32 bit number which is computed on demand, at each time it is read. Weak cryptographic post-processing is used to maximize throughput. The block will start computing before the first register access and so the reset value is not relevant.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>COUNTER_VAL</name>
          <description>Counter values to show information about the random process</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0</resetValue>
          <resetMask>0x1FFF</resetMask>
          <fields>
            <field>
              <name>CLK_RATIO</name>
              <description>Gives the ratio between the internal clocks frequencies and the register clock frequency for evaluation and certification purposes. Internal clock frequencies are half the incoming ones: COUNTER_VAL = round[ (intFreq/2)/regFreq*256*(1&lt;&lt;(4*shift4x)) ] MODULO 256 If shitf4x==0, intFreq ~= regFreq*COUNTER_VAL/256*2 Use clock_sel to select which clock you want to measure, in this range: 1..5</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>REFRESH_CNT</name>
              <description>Incremented (till max possible value) each time COUNTER was updated since last reading to any *_NUMBER. This gives an indication on 'entropy refill'. Note that there is no linear accumulation of entropy: as implemented today, entropy refill will be about 4 bits each time 'refresh_cnt' reaches its maximum value. See user manual for further details on how to benefit from linear entropy accumulation using a specific procedure.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>COUNTER_CFG</name>
          <description>Register linked to the comupting of statistics, not required for normal operation.</description>
          <addressOffset>0xC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x2</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>MODE</name>
              <description>00: disabled 01: update once. Will return to 00 once done 10: free running: updates countinuously 11: reserved</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CLOCK_SEL</name>
              <description>Selects the internal clock on which to compute statistics. 1 is for first one, 2 for second one, . And 0 is for a XOR of results from all clocks</description>
              <bitOffset>2</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SHIFT4X</name>
              <description>To be used to add precision to clock_ratio and determine 'entropy refill'. Supported range is 0..4 Used as well for ONLINE_TEST</description>
              <bitOffset>5</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ONLINE_TEST_CFG</name>
          <description>Configuration for the online test features</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0x7</resetMask>
          <fields>
            <field>
              <name>ACTIVATE</name>
              <description>0: disabled 1: activated Update rhythm for VAL depends on COUNTER_CFG if data_sel is set to COUNTER. Otherwise VAL is updated each time RANDOM_NUMBER is read</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA_SEL</name>
              <description>Selects source on which to apply online test: 00: LSB of COUNTER: raw data from one or all sources of entropy 01: MSB of COUNTER: raw data from one or all sources of entropy (do not use) 10: RANDOM_NUMBER 11: not valid 'activate' should be set to 'disabled' before changing this field</description>
              <bitOffset>1</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ONLINE_TEST_VAL</name>
          <description>Online test results</description>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0</resetValue>
          <resetMask>0xFFF</resetMask>
          <fields>
            <field>
              <name>LIVE_CHI_SQUARED</name>
              <description>This value is updated as described in field 'activate'. This value is a statistic value that indicates the quality of entropy generation. Low value means good, high value means no good. If 'data_sel'&lt;10, increase 'shift4x' till 'chi' is correct and poll 'refresh_cnt' before reading RANDOM_NUMBER.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>MIN_CHI_SQUARED</name>
              <description>Minimum value of LIVE_CHI_SQUARED since the last reset of this field. This field is reset when 'activate'=0</description>
              <bitOffset>4</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>MAX_CHI_SQUARED</name>
              <description>Maximum value of LIVE_CHI_SQUARED since the last reset of this field. This field is reset when 'activate'=0</description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>POWERDOWN</name>
          <description>Powerdown mode and reset control, generally use of this register is not necessary</description>
          <addressOffset>0xFF4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0x80000003</resetMask>
          <fields>
            <field>
              <name>SOFT_RESET</name>
              <description>Request softreset that will go low automaticaly after acknowledge from CORE</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FORCE_SOFT_RESET</name>
              <description>When used with softreset it forces CORE_RESETN to low on acknowledge from CORE</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>POWERDOWN</name>
              <description>When set all accesses to standard registers are blocked</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MODULEID</name>
          <description>IP identifier</description>
          <addressOffset>0xFFC</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0xA0B83200</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>APERTURE</name>
              <description>Aperture i.e. number minus 1 of consecutive packets 4 Kbytes reserved for this IP</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>MIN_REV</name>
              <description>Minor revision i.e. with no software consequences</description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>MAJ_REV</name>
              <description>Major revision i.e. implies software modifications</description>
              <bitOffset>12</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ID</name>
              <description>Identifier. This is the unique identifier of the module</description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>INPUTMUX</name>
      <description>This is the description of component input mux. . More details will follow.</description>
      <groupName>INPUTMUX</groupName>
      <baseAddress>0x4000E000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>0x188</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <dim>8</dim>
          <dimIncrement>0x4</dimIncrement>
          <name>PINTSEL[%s]</name>
          <description>Pin interrupt select register</description>
          <addressOffset>0xC0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x1F</resetValue>
          <resetMask>0x1F</resetMask>
          <fields>
            <field>
              <name>INTPIN</name>
              <description>Pin number select for pin interrupt or pattern match engine input.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>19</dim>
          <dimIncrement>0x4</dimIncrement>
          <name>DMA_ITRIG_INMUX[%s]</name>
          <description>Trigger select register for DMA channel. Configurable for each of the DMA channels.</description>
          <addressOffset>0xE0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x1F</resetValue>
          <resetMask>0x1F</resetMask>
          <fields>
            <field>
              <name>INP</name>
              <description>Trigger input number (decimal value) for DMA channel n (n = 0 to 17). 0: ADC0 Sequence A interrupt; 1: Reserved; 2: Timer CT32B0 Match 0; 3: Timer CT32B0 Match 1; 4: Timer CT32B1 Match 0; 5: Timer CT32B1 Match 1; 6: Pin interrupt 0; 7: Pin interrupt 1; 8: Pin interrupt 2; 9: Pin interrupt 3; 10: AES RX; 11: AES TX; 12: Hash RX; 13: Hash TX; 14: DMA output trigger mux 0; 15: DMA output trigger mux 1; 16: DMA output trigger mux 2; 17: DMA output trigger mux 3; 18- 31: reserved.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>4</dim>
          <dimIncrement>0x4</dimIncrement>
          <name>DMA_OTRIG_INMUX[%s]</name>
          <description>DMA output trigger selection to become an input to the DMA trigger mux. Four selections can be made.</description>
          <addressOffset>0x160</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x1F</resetValue>
          <resetMask>0x1F</resetMask>
          <fields>
            <field>
              <name>INP</name>
              <description>DMA trigger output number (decimal value) for DMA channel n (n = 0 to 19).</description>
              <bitOffset>0</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>FREQMEAS_REF</name>
          <description>Selection for frequency measurement reference clock</description>
          <addressOffset>0x180</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xF</resetValue>
          <resetMask>0xF</resetMask>
          <fields>
            <field>
              <name>CLKIN</name>
              <description>Clock source number (decimal value) for frequency measure function ref clock: 0: CLK_IN (must be enabled in functional mux); 1: XTAL 32 MHz (must be enabled in clock_ctrl); 2: FRO 1 MHz (must be enabled in clock_ctrl); 3: 32 kHz oscillator (either FRO 32 KHz or XTAL 32 KHZ); 4: Main clock (divided); 5: PIO[4] (must be configured as GPIO); 6: PIO[20] (must be configured as GPIO); 7: PIO[16] (must be configured as GPIO); 8: PIO[15] (must be configured as GPIO); 9 - 15: reserved.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>FREQMEAS_TARGET</name>
          <description>Selection for frequency measurement target clock</description>
          <addressOffset>0x184</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xF</resetValue>
          <resetMask>0xF</resetMask>
          <fields>
            <field>
              <name>CLKIN</name>
              <description>Clock source number (decimal value) for frequency measure function target clock: 0: CLK_IN (must be enabled in functional mux); 1: XTAL 32 MHz (must be enabled in clock_ctrl); 2: FRO 1 MHz (must be enabled in clock_ctrl); 3: 32 kHz oscillator (either FRO 32 KHz or XTAL 32 KHZ); 4: Main clock (divided); 5: PIO[4] (must be configured as GPIO); 6: PIO[20] (must be configured as GPIO); 7: PIO[16] (must be configured as GPIO); 8: PIO[15] (must be configured as GPIO); 9 - 15: reserved.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>IOCON</name>
      <description>This is the description of component input mux. . More details will follow.</description>
      <groupName>IOCON</groupName>
      <baseAddress>0x4000F000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>0x58</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>PIO0_0</name>
          <description>Configuration array for PIO0 to PIO21. PIO[10] and PIO[11] use a different IO cell type to the other PIO pins and so there are some differences in the bit field descriptions of the PIO register for these Ios. Reset values vary depending on whether the IO is configured with a pull-up or pull-down resistor as default. The value is also affected by the IO type. Reset value 0x180 for PIO 0,3,4,5,8,9,12,13,14,15,16,21. Reset value 0x198 for PIO 1,2,6,7,17,18,19,20. Reset value 0x188 for PIO 10,11.</description>
          <addressOffset>0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x180</resetValue>
          <resetMask>0xFFF</resetMask>
          <fields>
            <field>
              <name>FUNC</name>
              <description>Select digital function assigned to this pin.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>ALT0</name>
                  <description>Alternative connection 0.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ALT1</name>
                  <description>Alternative connection 1.</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ALT2</name>
                  <description>Alternative connection 2.</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ALT3</name>
                  <description>Alternative connection 3.</description>
                  <value>0x3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ALT4</name>
                  <description>Alternative connection 4.</description>
                  <value>0x4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ALT5</name>
                  <description>Alternative connection 5.</description>
                  <value>0x5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ALT6</name>
                  <description>Alternative connection 6.</description>
                  <value>0x6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ALT7</name>
                  <description>Alternative connection 7.</description>
                  <value>0x7</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>MODE</name>
              <description>Select function mode (on-chip pull-up/pull-down resistor control). For MFIO type ONLY (all PIOs except PIO10 &amp; 11): 0x0 : Pull-up. Pull-up resistor enabled. 0x1 : Repeater mode (bus keeper) 0x2 : Plain Input 0x3 : Pull-down. Pull-down resistor enabled. Note: When the register is related to a general purpose MFIO type pad (that is all PIOs except PIO10 &amp; 11) - Bit [3] (of the register) is connected to EPD (enable pull-down) input of the MFIO pad. - Bit [4] (of the register) is connected to EPUN (enable pull-up NOT) input of MFIO pad.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>PULL_UP</name>
                  <description>Pull-up. Pull-up resistor enabled.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>REPEATER</name>
                  <description>Repeater. Repeater mode (bus keeper).</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INACTIVE</name>
                  <description>Inactive. Plain Input.</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PULL_DOWN</name>
                  <description>Pull-down. Pull-down resistor enabled.</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SLEW0</name>
              <description>This bit field is used in combination with SLEW1. The higher [SLEW1,SLEW0] the quicker the IO cell slew rate.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DISABLED</name>
                  <description>Driver slew0 rate is disabled.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENABLED</name>
                  <description>Driver slew0 rate is enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INVERT</name>
              <description>Input Polarity.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DISABLED</name>
                  <description>Disabled. Input function is not inverted.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENABLED</name>
                  <description>Enabled. Input function is inverted.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DIGIMODE</name>
              <description>Select Analog/Digital Mode. 0 Analog mode. 1 Digital mode. When in analog mode, the receiver path in the IO cell is disabled. In this mode, it is essential that the digital function (e.g. GPIO) is not configured as an output. Otherwise it may conflict with analog stuff (loopback of digital on analog input). In other words, the digital output is not automatically disabled when the IO is in analog mode. As a consequence, it is not possible to disable the receiver path when the IO is used for digital output purpose.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>ANALOG</name>
                  <description>Analog mode, digital input is disabled.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIGITAL</name>
                  <description>Digital mode, digital input is enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>FILTEROFF</name>
              <description>Controls Input Glitch Filter.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>ENABLED</name>
                  <description>Filter enabled. Noise pulses below approximately 1 ns are filtered out.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DISABLED</name>
                  <description>Filter disabled. No input filtering is done.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SLEW1</name>
              <description>Driver Slew Rate. This bit is used in combination with SLEW0. The higher [SLEW1,SLEW0], the quicker the slew rate.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DISABLED</name>
                  <description>Driver slew1 rate is disabled.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENABLED</name>
                  <description>Driver slew1 rate is enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>OD</name>
              <description>Controls open-drain mode.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NORMAL</name>
                  <description>Normal. Normal push-pull output</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>OPEN_DRAIN</name>
                  <description>Open-drain. Simulated open-drain output (high drive disabled).</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SSEL</name>
              <description>IO Clamping Function</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DISABLED</name>
                  <description>This bit controls the IO clamping function is disabled.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENABLED</name>
                  <description>This bit controls the IO clamping function is enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>PIO0_1</name>
          <description>Configuration array for PIO0 to PIO21. PIO[10] and PIO[11] use a different IO cell type to the other PIO pins and so there are some differences in the bit field descriptions of the PIO register for these Ios. Reset values vary depending on whether the IO is configured with a pull-up or pull-down resistor as default. The value is also affected by the IO type. Reset value 0x180 for PIO 0,3,4,5,8,9,12,13,14,15,16,21. Reset value 0x198 for PIO 1,2,6,7,17,18,19,20. Reset value 0x188 for PIO 10,11.</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x198</resetValue>
          <resetMask>0xFFF</resetMask>
          <fields>
            <field>
              <name>FUNC</name>
              <description>Select digital function assigned to this pin.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>ALT0</name>
                  <description>Alternative connection 0.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ALT1</name>
                  <description>Alternative connection 1.</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ALT2</name>
                  <description>Alternative connection 2.</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ALT3</name>
                  <description>Alternative connection 3.</description>
                  <value>0x3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ALT4</name>
                  <description>Alternative connection 4.</description>
                  <value>0x4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ALT5</name>
                  <description>Alternative connection 5.</description>
                  <value>0x5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ALT6</name>
                  <description>Alternative connection 6.</description>
                  <value>0x6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ALT7</name>
                  <description>Alternative connection 7.</description>
                  <value>0x7</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>MODE</name>
              <description>Select function mode (on-chip pull-up/pull-down resistor control). For MFIO type ONLY (all PIOs except PIO10 &amp; 11): 0x0 : Pull-up. Pull-up resistor enabled. 0x1 : Repeater mode (bus keeper) 0x2 : Plain Input 0x3 : Pull-down. Pull-down resistor enabled. Note: When the register is related to a general purpose MFIO type pad (that is all PIOs except PIO10 &amp; 11) - Bit [3] (of the register) is connected to EPD (enable pull-down) input of the MFIO pad. - Bit [4] (of the register) is connected to EPUN (enable pull-up NOT) input of MFIO pad.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>PULL_UP</name>
                  <description>Pull-up. Pull-up resistor enabled.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>REPEATER</name>
                  <description>Repeater. Repeater mode (bus keeper).</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INACTIVE</name>
                  <description>Inactive. Plain Input.</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PULL_DOWN</name>
                  <description>Pull-down. Pull-down resistor enabled.</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SLEW0</name>
              <description>This bit field is used in combination with SLEW1. The higher [SLEW1,SLEW0] the quicker the IO cell slew rate.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DISABLED</name>
                  <description>Driver slew0 rate is disabled.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENABLED</name>
                  <description>Driver slew0 rate is enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INVERT</name>
              <description>Input Polarity.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DISABLED</name>
                  <description>Disabled. Input function is not inverted.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENABLED</name>
                  <description>Enabled. Input function is inverted.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DIGIMODE</name>
              <description>Select Analog/Digital Mode. 0 Analog mode. 1 Digital mode. When in analog mode, the receiver path in the IO cell is disabled. In this mode, it is essential that the digital function (e.g. GPIO) is not configured as an output. Otherwise it may conflict with analog stuff (loopback of digital on analog input). In other words, the digital output is not automatically disabled when the IO is in analog mode. As a consequence, it is not possible to disable the receiver path when the IO is used for digital output purpose.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>ANALOG</name>
                  <description>Analog mode, digital input is disabled.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIGITAL</name>
                  <description>Digital mode, digital input is enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>FILTEROFF</name>
              <description>Controls Input Glitch Filter.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>ENABLED</name>
                  <description>Filter enabled. Noise pulses below approximately 1 ns are filtered out.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DISABLED</name>
                  <description>Filter disabled. No input filtering is done.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SLEW1</name>
              <description>Driver Slew Rate. This bit is used in combination with SLEW0. The higher [SLEW1,SLEW0], the quicker the slew rate.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DISABLED</name>
                  <description>Driver slew1 rate is disabled.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENABLED</name>
                  <description>Driver slew1 rate is enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>OD</name>
              <description>Controls open-drain mode.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NORMAL</name>
                  <description>Normal. Normal push-pull output</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>OPEN_DRAIN</name>
                  <description>Open-drain. Simulated open-drain output (high drive disabled).</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SSEL</name>
              <description>IO Clamping Function</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DISABLED</name>
                  <description>This bit controls the IO clamping function is disabled.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENABLED</name>
                  <description>This bit controls the IO clamping function is enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>PIO0_2</name>
          <description>Configuration array for PIO0 to PIO21. PIO[10] and PIO[11] use a different IO cell type to the other PIO pins and so there are some differences in the bit field descriptions of the PIO register for these Ios. Reset values vary depending on whether the IO is configured with a pull-up or pull-down resistor as default. The value is also affected by the IO type. Reset value 0x180 for PIO 0,3,4,5,8,9,12,13,14,15,16,21. Reset value 0x198 for PIO 1,2,6,7,17,18,19,20. Reset value 0x188 for PIO 10,11.</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x198</resetValue>
          <resetMask>0xFFF</resetMask>
          <fields>
            <field>
              <name>FUNC</name>
              <description>Select digital function assigned to this pin.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>ALT0</name>
                  <description>Alternative connection 0.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ALT1</name>
                  <description>Alternative connection 1.</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ALT2</name>
                  <description>Alternative connection 2.</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ALT3</name>
                  <description>Alternative connection 3.</description>
                  <value>0x3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ALT4</name>
                  <description>Alternative connection 4.</description>
                  <value>0x4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ALT5</name>
                  <description>Alternative connection 5.</description>
                  <value>0x5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ALT6</name>
                  <description>Alternative connection 6.</description>
                  <value>0x6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ALT7</name>
                  <description>Alternative connection 7.</description>
                  <value>0x7</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>MODE</name>
              <description>Select function mode (on-chip pull-up/pull-down resistor control). For MFIO type ONLY (all PIOs except PIO10 &amp; 11): 0x0 : Pull-up. Pull-up resistor enabled. 0x1 : Repeater mode (bus keeper) 0x2 : Plain Input 0x3 : Pull-down. Pull-down resistor enabled. Note: When the register is related to a general purpose MFIO type pad (that is all PIOs except PIO10 &amp; 11) - Bit [3] (of the register) is connected to EPD (enable pull-down) input of the MFIO pad. - Bit [4] (of the register) is connected to EPUN (enable pull-up NOT) input of MFIO pad.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>PULL_UP</name>
                  <description>Pull-up. Pull-up resistor enabled.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>REPEATER</name>
                  <description>Repeater. Repeater mode (bus keeper).</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INACTIVE</name>
                  <description>Inactive. Plain Input.</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PULL_DOWN</name>
                  <description>Pull-down. Pull-down resistor enabled.</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SLEW0</name>
              <description>This bit field is used in combination with SLEW1. The higher [SLEW1,SLEW0] the quicker the IO cell slew rate.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DISABLED</name>
                  <description>Driver slew0 rate is disabled.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENABLED</name>
                  <description>Driver slew0 rate is enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INVERT</name>
              <description>Input Polarity.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DISABLED</name>
                  <description>Disabled. Input function is not inverted.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENABLED</name>
                  <description>Enabled. Input function is inverted.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DIGIMODE</name>
              <description>Select Analog/Digital Mode. 0 Analog mode. 1 Digital mode. When in analog mode, the receiver path in the IO cell is disabled. In this mode, it is essential that the digital function (e.g. GPIO) is not configured as an output. Otherwise it may conflict with analog stuff (loopback of digital on analog input). In other words, the digital output is not automatically disabled when the IO is in analog mode. As a consequence, it is not possible to disable the receiver path when the IO is used for digital output purpose.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>ANALOG</name>
                  <description>Analog mode, digital input is disabled.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIGITAL</name>
                  <description>Digital mode, digital input is enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>FILTEROFF</name>
              <description>Controls Input Glitch Filter.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>ENABLED</name>
                  <description>Filter enabled. Noise pulses below approximately 1 ns are filtered out.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DISABLED</name>
                  <description>Filter disabled. No input filtering is done.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SLEW1</name>
              <description>Driver Slew Rate. This bit is used in combination with SLEW0. The higher [SLEW1,SLEW0], the quicker the slew rate.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DISABLED</name>
                  <description>Driver slew1 rate is disabled.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENABLED</name>
                  <description>Driver slew1 rate is enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>OD</name>
              <description>Controls open-drain mode.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NORMAL</name>
                  <description>Normal. Normal push-pull output</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>OPEN_DRAIN</name>
                  <description>Open-drain. Simulated open-drain output (high drive disabled).</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SSEL</name>
              <description>IO Clamping Function</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DISABLED</name>
                  <description>This bit controls the IO clamping function is disabled.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENABLED</name>
                  <description>This bit controls the IO clamping function is enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>PIO0_3</name>
          <description>Configuration array for PIO0 to PIO21. PIO[10] and PIO[11] use a different IO cell type to the other PIO pins and so there are some differences in the bit field descriptions of the PIO register for these Ios. Reset values vary depending on whether the IO is configured with a pull-up or pull-down resistor as default. The value is also affected by the IO type. Reset value 0x180 for PIO 0,3,4,5,8,9,12,13,14,15,16,21. Reset value 0x198 for PIO 1,2,6,7,17,18,19,20. Reset value 0x188 for PIO 10,11.</description>
          <addressOffset>0xC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x180</resetValue>
          <resetMask>0xFFF</resetMask>
          <fields>
            <field>
              <name>FUNC</name>
              <description>Select digital function assigned to this pin.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>ALT0</name>
                  <description>Alternative connection 0.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ALT1</name>
                  <description>Alternative connection 1.</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ALT2</name>
                  <description>Alternative connection 2.</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ALT3</name>
                  <description>Alternative connection 3.</description>
                  <value>0x3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ALT4</name>
                  <description>Alternative connection 4.</description>
                  <value>0x4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ALT5</name>
                  <description>Alternative connection 5.</description>
                  <value>0x5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ALT6</name>
                  <description>Alternative connection 6.</description>
                  <value>0x6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ALT7</name>
                  <description>Alternative connection 7.</description>
                  <value>0x7</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>MODE</name>
              <description>Select function mode (on-chip pull-up/pull-down resistor control). For MFIO type ONLY (all PIOs except PIO10 &amp; 11): 0x0 : Pull-up. Pull-up resistor enabled. 0x1 : Repeater mode (bus keeper) 0x2 : Plain Input 0x3 : Pull-down. Pull-down resistor enabled. Note: When the register is related to a general purpose MFIO type pad (that is all PIOs except PIO10 &amp; 11) - Bit [3] (of the register) is connected to EPD (enable pull-down) input of the MFIO pad. - Bit [4] (of the register) is connected to EPUN (enable pull-up NOT) input of MFIO pad.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>PULL_UP</name>
                  <description>Pull-up. Pull-up resistor enabled.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>REPEATER</name>
                  <description>Repeater. Repeater mode (bus keeper).</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INACTIVE</name>
                  <description>Inactive. Plain Input.</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PULL_DOWN</name>
                  <description>Pull-down. Pull-down resistor enabled.</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SLEW0</name>
              <description>This bit field is used in combination with SLEW1. The higher [SLEW1,SLEW0] the quicker the IO cell slew rate.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DISABLED</name>
                  <description>Driver slew0 rate is disabled.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENABLED</name>
                  <description>Driver slew0 rate is enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INVERT</name>
              <description>Input Polarity.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DISABLED</name>
                  <description>Disabled. Input function is not inverted.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENABLED</name>
                  <description>Enabled. Input function is inverted.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DIGIMODE</name>
              <description>Select Analog/Digital Mode. 0 Analog mode. 1 Digital mode. When in analog mode, the receiver path in the IO cell is disabled. In this mode, it is essential that the digital function (e.g. GPIO) is not configured as an output. Otherwise it may conflict with analog stuff (loopback of digital on analog input). In other words, the digital output is not automatically disabled when the IO is in analog mode. As a consequence, it is not possible to disable the receiver path when the IO is used for digital output purpose.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>ANALOG</name>
                  <description>Analog mode, digital input is disabled.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIGITAL</name>
                  <description>Digital mode, digital input is enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>FILTEROFF</name>
              <description>Controls Input Glitch Filter.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>ENABLED</name>
                  <description>Filter enabled. Noise pulses below approximately 1 ns are filtered out.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DISABLED</name>
                  <description>Filter disabled. No input filtering is done.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SLEW1</name>
              <description>Driver Slew Rate. This bit is used in combination with SLEW0. The higher [SLEW1,SLEW0], the quicker the slew rate.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DISABLED</name>
                  <description>Driver slew1 rate is disabled.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENABLED</name>
                  <description>Driver slew1 rate is enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>OD</name>
              <description>Controls open-drain mode.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NORMAL</name>
                  <description>Normal. Normal push-pull output</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>OPEN_DRAIN</name>
                  <description>Open-drain. Simulated open-drain output (high drive disabled).</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SSEL</name>
              <description>IO Clamping Function</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DISABLED</name>
                  <description>This bit controls the IO clamping function is disabled.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENABLED</name>
                  <description>This bit controls the IO clamping function is enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>PIO0_4</name>
          <description>Configuration array for PIO0 to PIO21. PIO[10] and PIO[11] use a different IO cell type to the other PIO pins and so there are some differences in the bit field descriptions of the PIO register for these Ios. Reset values vary depending on whether the IO is configured with a pull-up or pull-down resistor as default. The value is also affected by the IO type. Reset value 0x180 for PIO 0,3,4,5,8,9,12,13,14,15,16,21. Reset value 0x198 for PIO 1,2,6,7,17,18,19,20. Reset value 0x188 for PIO 10,11.</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x180</resetValue>
          <resetMask>0xFFF</resetMask>
          <fields>
            <field>
              <name>FUNC</name>
              <description>Select digital function assigned to this pin.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>ALT0</name>
                  <description>Alternative connection 0.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ALT1</name>
                  <description>Alternative connection 1.</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ALT2</name>
                  <description>Alternative connection 2.</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ALT3</name>
                  <description>Alternative connection 3.</description>
                  <value>0x3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ALT4</name>
                  <description>Alternative connection 4.</description>
                  <value>0x4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ALT5</name>
                  <description>Alternative connection 5.</description>
                  <value>0x5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ALT6</name>
                  <description>Alternative connection 6.</description>
                  <value>0x6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ALT7</name>
                  <description>Alternative connection 7.</description>
                  <value>0x7</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>MODE</name>
              <description>Select function mode (on-chip pull-up/pull-down resistor control). For MFIO type ONLY (all PIOs except PIO10 &amp; 11): 0x0 : Pull-up. Pull-up resistor enabled. 0x1 : Repeater mode (bus keeper) 0x2 : Plain Input 0x3 : Pull-down. Pull-down resistor enabled. Note: When the register is related to a general purpose MFIO type pad (that is all PIOs except PIO10 &amp; 11) - Bit [3] (of the register) is connected to EPD (enable pull-down) input of the MFIO pad. - Bit [4] (of the register) is connected to EPUN (enable pull-up NOT) input of MFIO pad.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>PULL_UP</name>
                  <description>Pull-up. Pull-up resistor enabled.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>REPEATER</name>
                  <description>Repeater. Repeater mode (bus keeper).</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INACTIVE</name>
                  <description>Inactive. Plain Input.</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PULL_DOWN</name>
                  <description>Pull-down. Pull-down resistor enabled.</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SLEW0</name>
              <description>This bit field is used in combination with SLEW1. The higher [SLEW1,SLEW0] the quicker the IO cell slew rate.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DISABLED</name>
                  <description>Driver slew0 rate is disabled.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENABLED</name>
                  <description>Driver slew0 rate is enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INVERT</name>
              <description>Input Polarity.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DISABLED</name>
                  <description>Disabled. Input function is not inverted.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENABLED</name>
                  <description>Enabled. Input function is inverted.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DIGIMODE</name>
              <description>Select Analog/Digital Mode. 0 Analog mode. 1 Digital mode. When in analog mode, the receiver path in the IO cell is disabled. In this mode, it is essential that the digital function (e.g. GPIO) is not configured as an output. Otherwise it may conflict with analog stuff (loopback of digital on analog input). In other words, the digital output is not automatically disabled when the IO is in analog mode. As a consequence, it is not possible to disable the receiver path when the IO is used for digital output purpose.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>ANALOG</name>
                  <description>Analog mode, digital input is disabled.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIGITAL</name>
                  <description>Digital mode, digital input is enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>FILTEROFF</name>
              <description>Controls Input Glitch Filter.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>ENABLED</name>
                  <description>Filter enabled. Noise pulses below approximately 1 ns are filtered out.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DISABLED</name>
                  <description>Filter disabled. No input filtering is done.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SLEW1</name>
              <description>Driver Slew Rate. This bit is used in combination with SLEW0. The higher [SLEW1,SLEW0], the quicker the slew rate.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DISABLED</name>
                  <description>Driver slew1 rate is disabled.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENABLED</name>
                  <description>Driver slew1 rate is enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>OD</name>
              <description>Controls open-drain mode.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NORMAL</name>
                  <description>Normal. Normal push-pull output</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>OPEN_DRAIN</name>
                  <description>Open-drain. Simulated open-drain output (high drive disabled).</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SSEL</name>
              <description>IO Clamping Function</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DISABLED</name>
                  <description>This bit controls the IO clamping function is disabled.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENABLED</name>
                  <description>This bit controls the IO clamping function is enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>PIO0_5</name>
          <description>Configuration array for PIO0 to PIO21. PIO[10] and PIO[11] use a different IO cell type to the other PIO pins and so there are some differences in the bit field descriptions of the PIO register for these Ios. Reset values vary depending on whether the IO is configured with a pull-up or pull-down resistor as default. The value is also affected by the IO type. Reset value 0x180 for PIO 0,3,4,5,8,9,12,13,14,15,16,21. Reset value 0x198 for PIO 1,2,6,7,17,18,19,20. Reset value 0x188 for PIO 10,11.</description>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x180</resetValue>
          <resetMask>0xFFF</resetMask>
          <fields>
            <field>
              <name>FUNC</name>
              <description>Select digital function assigned to this pin.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>ALT0</name>
                  <description>Alternative connection 0.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ALT1</name>
                  <description>Alternative connection 1.</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ALT2</name>
                  <description>Alternative connection 2.</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ALT3</name>
                  <description>Alternative connection 3.</description>
                  <value>0x3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ALT4</name>
                  <description>Alternative connection 4.</description>
                  <value>0x4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ALT5</name>
                  <description>Alternative connection 5.</description>
                  <value>0x5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ALT6</name>
                  <description>Alternative connection 6.</description>
                  <value>0x6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ALT7</name>
                  <description>Alternative connection 7.</description>
                  <value>0x7</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>MODE</name>
              <description>Select function mode (on-chip pull-up/pull-down resistor control). For MFIO type ONLY (all PIOs except PIO10 &amp; 11): 0x0 : Pull-up. Pull-up resistor enabled. 0x1 : Repeater mode (bus keeper) 0x2 : Plain Input 0x3 : Pull-down. Pull-down resistor enabled. Note: When the register is related to a general purpose MFIO type pad (that is all PIOs except PIO10 &amp; 11) - Bit [3] (of the register) is connected to EPD (enable pull-down) input of the MFIO pad. - Bit [4] (of the register) is connected to EPUN (enable pull-up NOT) input of MFIO pad.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>PULL_UP</name>
                  <description>Pull-up. Pull-up resistor enabled.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>REPEATER</name>
                  <description>Repeater. Repeater mode (bus keeper).</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INACTIVE</name>
                  <description>Inactive. Plain Input.</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PULL_DOWN</name>
                  <description>Pull-down. Pull-down resistor enabled.</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SLEW0</name>
              <description>This bit field is used in combination with SLEW1. The higher [SLEW1,SLEW0] the quicker the IO cell slew rate.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DISABLED</name>
                  <description>Driver slew0 rate is disabled.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENABLED</name>
                  <description>Driver slew0 rate is enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INVERT</name>
              <description>Input Polarity.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DISABLED</name>
                  <description>Disabled. Input function is not inverted.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENABLED</name>
                  <description>Enabled. Input function is inverted.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DIGIMODE</name>
              <description>Select Analog/Digital Mode. 0 Analog mode. 1 Digital mode. When in analog mode, the receiver path in the IO cell is disabled. In this mode, it is essential that the digital function (e.g. GPIO) is not configured as an output. Otherwise it may conflict with analog stuff (loopback of digital on analog input). In other words, the digital output is not automatically disabled when the IO is in analog mode. As a consequence, it is not possible to disable the receiver path when the IO is used for digital output purpose.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>ANALOG</name>
                  <description>Analog mode, digital input is disabled.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIGITAL</name>
                  <description>Digital mode, digital input is enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>FILTEROFF</name>
              <description>Controls Input Glitch Filter.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>ENABLED</name>
                  <description>Filter enabled. Noise pulses below approximately 1 ns are filtered out.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DISABLED</name>
                  <description>Filter disabled. No input filtering is done.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SLEW1</name>
              <description>Driver Slew Rate. This bit is used in combination with SLEW0. The higher [SLEW1,SLEW0], the quicker the slew rate.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DISABLED</name>
                  <description>Driver slew1 rate is disabled.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENABLED</name>
                  <description>Driver slew1 rate is enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>OD</name>
              <description>Controls open-drain mode.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NORMAL</name>
                  <description>Normal. Normal push-pull output</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>OPEN_DRAIN</name>
                  <description>Open-drain. Simulated open-drain output (high drive disabled).</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SSEL</name>
              <description>IO Clamping Function</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DISABLED</name>
                  <description>This bit controls the IO clamping function is disabled.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENABLED</name>
                  <description>This bit controls the IO clamping function is enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>PIO0_6</name>
          <description>Configuration array for PIO0 to PIO21. PIO[10] and PIO[11] use a different IO cell type to the other PIO pins and so there are some differences in the bit field descriptions of the PIO register for these Ios. Reset values vary depending on whether the IO is configured with a pull-up or pull-down resistor as default. The value is also affected by the IO type. Reset value 0x180 for PIO 0,3,4,5,8,9,12,13,14,15,16,21. Reset value 0x198 for PIO 1,2,6,7,17,18,19,20. Reset value 0x188 for PIO 10,11.</description>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x198</resetValue>
          <resetMask>0xFFF</resetMask>
          <fields>
            <field>
              <name>FUNC</name>
              <description>Select digital function assigned to this pin.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>ALT0</name>
                  <description>Alternative connection 0.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ALT1</name>
                  <description>Alternative connection 1.</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ALT2</name>
                  <description>Alternative connection 2.</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ALT3</name>
                  <description>Alternative connection 3.</description>
                  <value>0x3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ALT4</name>
                  <description>Alternative connection 4.</description>
                  <value>0x4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ALT5</name>
                  <description>Alternative connection 5.</description>
                  <value>0x5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ALT6</name>
                  <description>Alternative connection 6.</description>
                  <value>0x6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ALT7</name>
                  <description>Alternative connection 7.</description>
                  <value>0x7</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>MODE</name>
              <description>Select function mode (on-chip pull-up/pull-down resistor control). For MFIO type ONLY (all PIOs except PIO10 &amp; 11): 0x0 : Pull-up. Pull-up resistor enabled. 0x1 : Repeater mode (bus keeper) 0x2 : Plain Input 0x3 : Pull-down. Pull-down resistor enabled. Note: When the register is related to a general purpose MFIO type pad (that is all PIOs except PIO10 &amp; 11) - Bit [3] (of the register) is connected to EPD (enable pull-down) input of the MFIO pad. - Bit [4] (of the register) is connected to EPUN (enable pull-up NOT) input of MFIO pad.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>PULL_UP</name>
                  <description>Pull-up. Pull-up resistor enabled.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>REPEATER</name>
                  <description>Repeater. Repeater mode (bus keeper).</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INACTIVE</name>
                  <description>Inactive. Plain Input.</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PULL_DOWN</name>
                  <description>Pull-down. Pull-down resistor enabled.</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SLEW0</name>
              <description>This bit field is used in combination with SLEW1. The higher [SLEW1,SLEW0] the quicker the IO cell slew rate.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DISABLED</name>
                  <description>Driver slew0 rate is disabled.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENABLED</name>
                  <description>Driver slew0 rate is enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INVERT</name>
              <description>Input Polarity.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DISABLED</name>
                  <description>Disabled. Input function is not inverted.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENABLED</name>
                  <description>Enabled. Input function is inverted.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DIGIMODE</name>
              <description>Select Analog/Digital Mode. 0 Analog mode. 1 Digital mode. When in analog mode, the receiver path in the IO cell is disabled. In this mode, it is essential that the digital function (e.g. GPIO) is not configured as an output. Otherwise it may conflict with analog stuff (loopback of digital on analog input). In other words, the digital output is not automatically disabled when the IO is in analog mode. As a consequence, it is not possible to disable the receiver path when the IO is used for digital output purpose.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>ANALOG</name>
                  <description>Analog mode, digital input is disabled.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIGITAL</name>
                  <description>Digital mode, digital input is enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>FILTEROFF</name>
              <description>Controls Input Glitch Filter.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>ENABLED</name>
                  <description>Filter enabled. Noise pulses below approximately 1 ns are filtered out.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DISABLED</name>
                  <description>Filter disabled. No input filtering is done.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SLEW1</name>
              <description>Driver Slew Rate. This bit is used in combination with SLEW0. The higher [SLEW1,SLEW0], the quicker the slew rate.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DISABLED</name>
                  <description>Driver slew1 rate is disabled.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENABLED</name>
                  <description>Driver slew1 rate is enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>OD</name>
              <description>Controls open-drain mode.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NORMAL</name>
                  <description>Normal. Normal push-pull output</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>OPEN_DRAIN</name>
                  <description>Open-drain. Simulated open-drain output (high drive disabled).</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SSEL</name>
              <description>IO Clamping Function</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DISABLED</name>
                  <description>This bit controls the IO clamping function is disabled.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENABLED</name>
                  <description>This bit controls the IO clamping function is enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>PIO0_7</name>
          <description>Configuration array for PIO0 to PIO21. PIO[10] and PIO[11] use a different IO cell type to the other PIO pins and so there are some differences in the bit field descriptions of the PIO register for these Ios. Reset values vary depending on whether the IO is configured with a pull-up or pull-down resistor as default. The value is also affected by the IO type. Reset value 0x180 for PIO 0,3,4,5,8,9,12,13,14,15,16,21. Reset value 0x198 for PIO 1,2,6,7,17,18,19,20. Reset value 0x188 for PIO 10,11.</description>
          <addressOffset>0x1C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x198</resetValue>
          <resetMask>0xFFF</resetMask>
          <fields>
            <field>
              <name>FUNC</name>
              <description>Select digital function assigned to this pin.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>ALT0</name>
                  <description>Alternative connection 0.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ALT1</name>
                  <description>Alternative connection 1.</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ALT2</name>
                  <description>Alternative connection 2.</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ALT3</name>
                  <description>Alternative connection 3.</description>
                  <value>0x3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ALT4</name>
                  <description>Alternative connection 4.</description>
                  <value>0x4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ALT5</name>
                  <description>Alternative connection 5.</description>
                  <value>0x5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ALT6</name>
                  <description>Alternative connection 6.</description>
                  <value>0x6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ALT7</name>
                  <description>Alternative connection 7.</description>
                  <value>0x7</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>MODE</name>
              <description>Select function mode (on-chip pull-up/pull-down resistor control). For MFIO type ONLY (all PIOs except PIO10 &amp; 11): 0x0 : Pull-up. Pull-up resistor enabled. 0x1 : Repeater mode (bus keeper) 0x2 : Plain Input 0x3 : Pull-down. Pull-down resistor enabled. Note: When the register is related to a general purpose MFIO type pad (that is all PIOs except PIO10 &amp; 11) - Bit [3] (of the register) is connected to EPD (enable pull-down) input of the MFIO pad. - Bit [4] (of the register) is connected to EPUN (enable pull-up NOT) input of MFIO pad.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>PULL_UP</name>
                  <description>Pull-up. Pull-up resistor enabled.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>REPEATER</name>
                  <description>Repeater. Repeater mode (bus keeper).</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INACTIVE</name>
                  <description>Inactive. Plain Input.</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PULL_DOWN</name>
                  <description>Pull-down. Pull-down resistor enabled.</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SLEW0</name>
              <description>This bit field is used in combination with SLEW1. The higher [SLEW1,SLEW0] the quicker the IO cell slew rate.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DISABLED</name>
                  <description>Driver slew0 rate is disabled.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENABLED</name>
                  <description>Driver slew0 rate is enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INVERT</name>
              <description>Input Polarity.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DISABLED</name>
                  <description>Disabled. Input function is not inverted.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENABLED</name>
                  <description>Enabled. Input function is inverted.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DIGIMODE</name>
              <description>Select Analog/Digital Mode. 0 Analog mode. 1 Digital mode. When in analog mode, the receiver path in the IO cell is disabled. In this mode, it is essential that the digital function (e.g. GPIO) is not configured as an output. Otherwise it may conflict with analog stuff (loopback of digital on analog input). In other words, the digital output is not automatically disabled when the IO is in analog mode. As a consequence, it is not possible to disable the receiver path when the IO is used for digital output purpose.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>ANALOG</name>
                  <description>Analog mode, digital input is disabled.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIGITAL</name>
                  <description>Digital mode, digital input is enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>FILTEROFF</name>
              <description>Controls Input Glitch Filter.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>ENABLED</name>
                  <description>Filter enabled. Noise pulses below approximately 1 ns are filtered out.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DISABLED</name>
                  <description>Filter disabled. No input filtering is done.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SLEW1</name>
              <description>Driver Slew Rate. This bit is used in combination with SLEW0. The higher [SLEW1,SLEW0], the quicker the slew rate.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DISABLED</name>
                  <description>Driver slew1 rate is disabled.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENABLED</name>
                  <description>Driver slew1 rate is enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>OD</name>
              <description>Controls open-drain mode.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NORMAL</name>
                  <description>Normal. Normal push-pull output</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>OPEN_DRAIN</name>
                  <description>Open-drain. Simulated open-drain output (high drive disabled).</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SSEL</name>
              <description>IO Clamping Function</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DISABLED</name>
                  <description>This bit controls the IO clamping function is disabled.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENABLED</name>
                  <description>This bit controls the IO clamping function is enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>PIO0_8</name>
          <description>Configuration array for PIO0 to PIO21. PIO[10] and PIO[11] use a different IO cell type to the other PIO pins and so there are some differences in the bit field descriptions of the PIO register for these Ios. Reset values vary depending on whether the IO is configured with a pull-up or pull-down resistor as default. The value is also affected by the IO type. Reset value 0x180 for PIO 0,3,4,5,8,9,12,13,14,15,16,21. Reset value 0x198 for PIO 1,2,6,7,17,18,19,20. Reset value 0x188 for PIO 10,11.</description>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x180</resetValue>
          <resetMask>0xFFF</resetMask>
          <fields>
            <field>
              <name>FUNC</name>
              <description>Select digital function assigned to this pin.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>ALT0</name>
                  <description>Alternative connection 0.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ALT1</name>
                  <description>Alternative connection 1.</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ALT2</name>
                  <description>Alternative connection 2.</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ALT3</name>
                  <description>Alternative connection 3.</description>
                  <value>0x3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ALT4</name>
                  <description>Alternative connection 4.</description>
                  <value>0x4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ALT5</name>
                  <description>Alternative connection 5.</description>
                  <value>0x5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ALT6</name>
                  <description>Alternative connection 6.</description>
                  <value>0x6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ALT7</name>
                  <description>Alternative connection 7.</description>
                  <value>0x7</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>MODE</name>
              <description>Select function mode (on-chip pull-up/pull-down resistor control). For MFIO type ONLY (all PIOs except PIO10 &amp; 11): 0x0 : Pull-up. Pull-up resistor enabled. 0x1 : Repeater mode (bus keeper) 0x2 : Plain Input 0x3 : Pull-down. Pull-down resistor enabled. Note: When the register is related to a general purpose MFIO type pad (that is all PIOs except PIO10 &amp; 11) - Bit [3] (of the register) is connected to EPD (enable pull-down) input of the MFIO pad. - Bit [4] (of the register) is connected to EPUN (enable pull-up NOT) input of MFIO pad.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>PULL_UP</name>
                  <description>Pull-up. Pull-up resistor enabled.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>REPEATER</name>
                  <description>Repeater. Repeater mode (bus keeper).</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INACTIVE</name>
                  <description>Inactive. Plain Input.</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PULL_DOWN</name>
                  <description>Pull-down. Pull-down resistor enabled.</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SLEW0</name>
              <description>This bit field is used in combination with SLEW1. The higher [SLEW1,SLEW0] the quicker the IO cell slew rate.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DISABLED</name>
                  <description>Driver slew0 rate is disabled.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENABLED</name>
                  <description>Driver slew0 rate is enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INVERT</name>
              <description>Input Polarity.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DISABLED</name>
                  <description>Disabled. Input function is not inverted.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENABLED</name>
                  <description>Enabled. Input function is inverted.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DIGIMODE</name>
              <description>Select Analog/Digital Mode. 0 Analog mode. 1 Digital mode. When in analog mode, the receiver path in the IO cell is disabled. In this mode, it is essential that the digital function (e.g. GPIO) is not configured as an output. Otherwise it may conflict with analog stuff (loopback of digital on analog input). In other words, the digital output is not automatically disabled when the IO is in analog mode. As a consequence, it is not possible to disable the receiver path when the IO is used for digital output purpose.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>ANALOG</name>
                  <description>Analog mode, digital input is disabled.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIGITAL</name>
                  <description>Digital mode, digital input is enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>FILTEROFF</name>
              <description>Controls Input Glitch Filter.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>ENABLED</name>
                  <description>Filter enabled. Noise pulses below approximately 1 ns are filtered out.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DISABLED</name>
                  <description>Filter disabled. No input filtering is done.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SLEW1</name>
              <description>Driver Slew Rate. This bit is used in combination with SLEW0. The higher [SLEW1,SLEW0], the quicker the slew rate.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DISABLED</name>
                  <description>Driver slew1 rate is disabled.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENABLED</name>
                  <description>Driver slew1 rate is enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>OD</name>
              <description>Controls open-drain mode.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NORMAL</name>
                  <description>Normal. Normal push-pull output</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>OPEN_DRAIN</name>
                  <description>Open-drain. Simulated open-drain output (high drive disabled).</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SSEL</name>
              <description>IO Clamping Function</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DISABLED</name>
                  <description>This bit controls the IO clamping function is disabled.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENABLED</name>
                  <description>This bit controls the IO clamping function is enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>PIO0_9</name>
          <description>Configuration array for PIO0 to PIO21. PIO[10] and PIO[11] use a different IO cell type to the other PIO pins and so there are some differences in the bit field descriptions of the PIO register for these Ios. Reset values vary depending on whether the IO is configured with a pull-up or pull-down resistor as default. The value is also affected by the IO type. Reset value 0x180 for PIO 0,3,4,5,8,9,12,13,14,15,16,21. Reset value 0x198 for PIO 1,2,6,7,17,18,19,20. Reset value 0x188 for PIO 10,11.</description>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x180</resetValue>
          <resetMask>0xFFF</resetMask>
          <fields>
            <field>
              <name>FUNC</name>
              <description>Select digital function assigned to this pin.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>ALT0</name>
                  <description>Alternative connection 0.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ALT1</name>
                  <description>Alternative connection 1.</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ALT2</name>
                  <description>Alternative connection 2.</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ALT3</name>
                  <description>Alternative connection 3.</description>
                  <value>0x3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ALT4</name>
                  <description>Alternative connection 4.</description>
                  <value>0x4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ALT5</name>
                  <description>Alternative connection 5.</description>
                  <value>0x5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ALT6</name>
                  <description>Alternative connection 6.</description>
                  <value>0x6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ALT7</name>
                  <description>Alternative connection 7.</description>
                  <value>0x7</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>MODE</name>
              <description>Select function mode (on-chip pull-up/pull-down resistor control). For MFIO type ONLY (all PIOs except PIO10 &amp; 11): 0x0 : Pull-up. Pull-up resistor enabled. 0x1 : Repeater mode (bus keeper) 0x2 : Plain Input 0x3 : Pull-down. Pull-down resistor enabled. Note: When the register is related to a general purpose MFIO type pad (that is all PIOs except PIO10 &amp; 11) - Bit [3] (of the register) is connected to EPD (enable pull-down) input of the MFIO pad. - Bit [4] (of the register) is connected to EPUN (enable pull-up NOT) input of MFIO pad.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>PULL_UP</name>
                  <description>Pull-up. Pull-up resistor enabled.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>REPEATER</name>
                  <description>Repeater. Repeater mode (bus keeper).</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INACTIVE</name>
                  <description>Inactive. Plain Input.</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PULL_DOWN</name>
                  <description>Pull-down. Pull-down resistor enabled.</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SLEW0</name>
              <description>This bit field is used in combination with SLEW1. The higher [SLEW1,SLEW0] the quicker the IO cell slew rate.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DISABLED</name>
                  <description>Driver slew0 rate is disabled.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENABLED</name>
                  <description>Driver slew0 rate is enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INVERT</name>
              <description>Input Polarity.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DISABLED</name>
                  <description>Disabled. Input function is not inverted.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENABLED</name>
                  <description>Enabled. Input function is inverted.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DIGIMODE</name>
              <description>Select Analog/Digital Mode. 0 Analog mode. 1 Digital mode. When in analog mode, the receiver path in the IO cell is disabled. In this mode, it is essential that the digital function (e.g. GPIO) is not configured as an output. Otherwise it may conflict with analog stuff (loopback of digital on analog input). In other words, the digital output is not automatically disabled when the IO is in analog mode. As a consequence, it is not possible to disable the receiver path when the IO is used for digital output purpose.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>ANALOG</name>
                  <description>Analog mode, digital input is disabled.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIGITAL</name>
                  <description>Digital mode, digital input is enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>FILTEROFF</name>
              <description>Controls Input Glitch Filter.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>ENABLED</name>
                  <description>Filter enabled. Noise pulses below approximately 1 ns are filtered out.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DISABLED</name>
                  <description>Filter disabled. No input filtering is done.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SLEW1</name>
              <description>Driver Slew Rate. This bit is used in combination with SLEW0. The higher [SLEW1,SLEW0], the quicker the slew rate.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DISABLED</name>
                  <description>Driver slew1 rate is disabled.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENABLED</name>
                  <description>Driver slew1 rate is enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>OD</name>
              <description>Controls open-drain mode.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NORMAL</name>
                  <description>Normal. Normal push-pull output</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>OPEN_DRAIN</name>
                  <description>Open-drain. Simulated open-drain output (high drive disabled).</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SSEL</name>
              <description>IO Clamping Function</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DISABLED</name>
                  <description>This bit controls the IO clamping function is disabled.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENABLED</name>
                  <description>This bit controls the IO clamping function is enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>PIO0_10</name>
          <description>Configuration array for PIO0 to PIO21. PIO[10] and PIO[11] use a different IO cell type to the other PIO pins and so there are some differences in the bit field descriptions of the PIO register for these Ios. Reset values vary depending on whether the IO is configured with a pull-up or pull-down resistor as default. The value is also affected by the IO type. Reset value 0x180 for PIO 0,3,4,5,8,9,12,13,14,15,16,21. Reset value 0x198 for PIO 1,2,6,7,17,18,19,20. Reset value 0x188 for PIO 10,11.</description>
          <addressOffset>0x28</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x188</resetValue>
          <resetMask>0x1FFF</resetMask>
          <fields>
            <field>
              <name>FUNC</name>
              <description>Select digital function assigned to this pin.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>ALT0</name>
                  <description>Alternative connection 0.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ALT1</name>
                  <description>Alternative connection 1.</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ALT2</name>
                  <description>Alternative connection 2.</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ALT3</name>
                  <description>Alternative connection 3.</description>
                  <value>0x3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ALT4</name>
                  <description>Alternative connection 4.</description>
                  <value>0x4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ALT5</name>
                  <description>Alternative connection 5.</description>
                  <value>0x5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ALT6</name>
                  <description>Alternative connection 6.</description>
                  <value>0x6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ALT7</name>
                  <description>Alternative connection 7.</description>
                  <value>0x7</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>EGP</name>
              <description>GPIO Mode of IO Cell.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>IIC</name>
                  <description>IIC mode.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>GPIO</name>
                  <description>GPIO mode.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ECS</name>
              <description>Pull-up current source enable when set. When IO is is IIC mode (EGP=0) and ECS is low, the IO cell is an open drain cell.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DISABLED</name>
                  <description>Pull-up current source disabled.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENABLED</name>
                  <description>Pull-up current source enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>EHS</name>
              <description>Speed selection. When IO is in GPIO mode set 1 for high speed GPIO, 0 for low speed GPIO. For IIC mode, this bit has no effect and the IO is always in low speed.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DISABLED</name>
                  <description>low speed for GPIO mode or i2c mode.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENABLED</name>
                  <description>High speed for GPIO mode.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INVERT</name>
              <description>Input Polarity.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DISABLED</name>
                  <description>Disabled. Input function is not inverted.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENABLED</name>
                  <description>Enabled. Input function is inverted.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DIGIMODE</name>
              <description>Select Analog/Digital Mode. 0 Analog mode. 1 Digital mode. When in analog mode, the receiver path in the IO cell is disabled. In this mode, it is essential that the digital function (e.g. GPIO) is not configured as an output. Otherwise it may conflict with analog stuff (loopback of digital on analog input). In other words, the digital output is not automatically disabled when the IO is in analog mode. As a consequence, it is not possible to disable the receiver path when the IO is used for digital output purpose.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>ANALOG</name>
                  <description>Analog mode, digital input is disabled.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIGITAL</name>
                  <description>Digital mode, digital input is enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>FILTEROFF</name>
              <description>Controls Input Glitch Filter.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>ENABLED</name>
                  <description>Filter enabled. Noise pulses below approximately 1 ns are filtered out.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DISABLED</name>
                  <description>Filter disabled. No input filtering is done.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>FSEL</name>
              <description>Control Input Glitch Filter.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DISABLED</name>
                  <description>Noise pulses below approximately 50ns are filtered out.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENABLED</name>
                  <description>Noise pulses below approximately 10 ns are filtered out. If IO is in GPIO mode this control bit is irrelevant, a 3 ns filter is used.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>OD</name>
              <description>Controls open-drain mode.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NORMAL</name>
                  <description>Normal. Normal push-pull output</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>OPEN_DRAIN</name>
                  <description>Open-drain. Simulated open-drain output (high drive disabled).</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>IO_CLAMP</name>
              <description>Assert to freeze the IO. Also needs SYSCON:RETENTIONCTRL set as well. Useful in power down mode. This mode is held through power down cycle. Before releasing this mode on a wake-up, ensure the IO is set to the required direction and value using GPIO DIR and PIN registers.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DISABLED</name>
                  <description>IO_CLAMP is disabled.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENABLED</name>
                  <description>IO_CLAMP is enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>PIO0_11</name>
          <description>Configuration array for PIO0 to PIO21. PIO[10] and PIO[11] use a different IO cell type to the other PIO pins and so there are some differences in the bit field descriptions of the PIO register for these Ios. Reset values vary depending on whether the IO is configured with a pull-up or pull-down resistor as default. The value is also affected by the IO type. Reset value 0x180 for PIO 0,3,4,5,8,9,12,13,14,15,16,21. Reset value 0x198 for PIO 1,2,6,7,17,18,19,20. Reset value 0x188 for PIO 10,11.</description>
          <addressOffset>0x2C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x188</resetValue>
          <resetMask>0x1FFF</resetMask>
          <fields>
            <field>
              <name>FUNC</name>
              <description>Select digital function assigned to this pin.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>ALT0</name>
                  <description>Alternative connection 0.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ALT1</name>
                  <description>Alternative connection 1.</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ALT2</name>
                  <description>Alternative connection 2.</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ALT3</name>
                  <description>Alternative connection 3.</description>
                  <value>0x3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ALT4</name>
                  <description>Alternative connection 4.</description>
                  <value>0x4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ALT5</name>
                  <description>Alternative connection 5.</description>
                  <value>0x5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ALT6</name>
                  <description>Alternative connection 6.</description>
                  <value>0x6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ALT7</name>
                  <description>Alternative connection 7.</description>
                  <value>0x7</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>EGP</name>
              <description>GPIO Mode of IO Cell.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>IIC</name>
                  <description>IIC mode.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>GPIO</name>
                  <description>GPIO mode.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ECS</name>
              <description>Pull-up current source enable when set. When IO is is IIC mode (EGP=0) and ECS is low, the IO cell is an open drain cell.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DISABLED</name>
                  <description>Pull-up current source disabled.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENABLED</name>
                  <description>Pull-up current source enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>EHS</name>
              <description>Speed selection. When IO is in GPIO mode set 1 for high speed GPIO, 0 for low speed GPIO. For IIC mode, this bit has no effect and the IO is always in low speed.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DISABLED</name>
                  <description>low speed for GPIO mode or i2c mode.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENABLED</name>
                  <description>High speed for GPIO mode.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INVERT</name>
              <description>Input Polarity.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DISABLED</name>
                  <description>Disabled. Input function is not inverted.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENABLED</name>
                  <description>Enabled. Input function is inverted.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DIGIMODE</name>
              <description>Select Analog/Digital Mode. 0 Analog mode. 1 Digital mode. When in analog mode, the receiver path in the IO cell is disabled. In this mode, it is essential that the digital function (e.g. GPIO) is not configured as an output. Otherwise it may conflict with analog stuff (loopback of digital on analog input). In other words, the digital output is not automatically disabled when the IO is in analog mode. As a consequence, it is not possible to disable the receiver path when the IO is used for digital output purpose.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>ANALOG</name>
                  <description>Analog mode, digital input is disabled.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIGITAL</name>
                  <description>Digital mode, digital input is enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>FILTEROFF</name>
              <description>Controls Input Glitch Filter.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>ENABLED</name>
                  <description>Filter enabled. Noise pulses below approximately 1 ns are filtered out.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DISABLED</name>
                  <description>Filter disabled. No input filtering is done.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>FSEL</name>
              <description>Control Input Glitch Filter.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DISABLED</name>
                  <description>Noise pulses below approximately 50ns are filtered out.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENABLED</name>
                  <description>Noise pulses below approximately 10 ns are filtered out. If IO is in GPIO mode this control bit is irrelevant, a 3 ns filter is used.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>OD</name>
              <description>Controls open-drain mode.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NORMAL</name>
                  <description>Normal. Normal push-pull output</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>OPEN_DRAIN</name>
                  <description>Open-drain. Simulated open-drain output (high drive disabled).</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>IO_CLAMP</name>
              <description>Assert to freeze the IO. Also needs SYSCON:RETENTIONCTRL set as well. Useful in power down mode. This mode is held through power down cycle. Before releasing this mode on a wake-up, ensure the IO is set to the required direction and value using GPIO DIR and PIN registers.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DISABLED</name>
                  <description>IO_CLAMP is disabled.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENABLED</name>
                  <description>IO_CLAMP is enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>PIO0_12</name>
          <description>Configuration array for PIO0 to PIO21. PIO[10] and PIO[11] use a different IO cell type to the other PIO pins and so there are some differences in the bit field descriptions of the PIO register for these Ios. Reset values vary depending on whether the IO is configured with a pull-up or pull-down resistor as default. The value is also affected by the IO type. Reset value 0x180 for PIO 0,3,4,5,8,9,12,13,14,15,16,21. Reset value 0x198 for PIO 1,2,6,7,17,18,19,20. Reset value 0x188 for PIO 10,11.</description>
          <addressOffset>0x30</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x182</resetValue>
          <resetMask>0xFFF</resetMask>
          <fields>
            <field>
              <name>FUNC</name>
              <description>Select digital function assigned to this pin.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>ALT0</name>
                  <description>Alternative connection 0.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ALT1</name>
                  <description>Alternative connection 1.</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ALT2</name>
                  <description>Alternative connection 2.</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ALT3</name>
                  <description>Alternative connection 3.</description>
                  <value>0x3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ALT4</name>
                  <description>Alternative connection 4.</description>
                  <value>0x4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ALT5</name>
                  <description>Alternative connection 5.</description>
                  <value>0x5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ALT6</name>
                  <description>Alternative connection 6.</description>
                  <value>0x6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ALT7</name>
                  <description>Alternative connection 7.</description>
                  <value>0x7</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>MODE</name>
              <description>Select function mode (on-chip pull-up/pull-down resistor control). For MFIO type ONLY (all PIOs except PIO10 &amp; 11): 0x0 : Pull-up. Pull-up resistor enabled. 0x1 : Repeater mode (bus keeper) 0x2 : Plain Input 0x3 : Pull-down. Pull-down resistor enabled. Note: When the register is related to a general purpose MFIO type pad (that is all PIOs except PIO10 &amp; 11) - Bit [3] (of the register) is connected to EPD (enable pull-down) input of the MFIO pad. - Bit [4] (of the register) is connected to EPUN (enable pull-up NOT) input of MFIO pad.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>PULL_UP</name>
                  <description>Pull-up. Pull-up resistor enabled.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>REPEATER</name>
                  <description>Repeater. Repeater mode (bus keeper).</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INACTIVE</name>
                  <description>Inactive. Plain Input.</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PULL_DOWN</name>
                  <description>Pull-down. Pull-down resistor enabled.</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SLEW0</name>
              <description>This bit field is used in combination with SLEW1. The higher [SLEW1,SLEW0] the quicker the IO cell slew rate.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DISABLED</name>
                  <description>Driver slew0 rate is disabled.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENABLED</name>
                  <description>Driver slew0 rate is enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INVERT</name>
              <description>Input Polarity.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DISABLED</name>
                  <description>Disabled. Input function is not inverted.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENABLED</name>
                  <description>Enabled. Input function is inverted.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DIGIMODE</name>
              <description>Select Analog/Digital Mode. 0 Analog mode. 1 Digital mode. When in analog mode, the receiver path in the IO cell is disabled. In this mode, it is essential that the digital function (e.g. GPIO) is not configured as an output. Otherwise it may conflict with analog stuff (loopback of digital on analog input). In other words, the digital output is not automatically disabled when the IO is in analog mode. As a consequence, it is not possible to disable the receiver path when the IO is used for digital output purpose.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>ANALOG</name>
                  <description>Analog mode, digital input is disabled.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIGITAL</name>
                  <description>Digital mode, digital input is enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>FILTEROFF</name>
              <description>Controls Input Glitch Filter.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>ENABLED</name>
                  <description>Filter enabled. Noise pulses below approximately 1 ns are filtered out.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DISABLED</name>
                  <description>Filter disabled. No input filtering is done.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SLEW1</name>
              <description>Driver Slew Rate. This bit is used in combination with SLEW0. The higher [SLEW1,SLEW0], the quicker the slew rate.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DISABLED</name>
                  <description>Driver slew1 rate is disabled.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENABLED</name>
                  <description>Driver slew1 rate is enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>OD</name>
              <description>Controls open-drain mode.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NORMAL</name>
                  <description>Normal. Normal push-pull output</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>OPEN_DRAIN</name>
                  <description>Open-drain. Simulated open-drain output (high drive disabled).</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SSEL</name>
              <description>IO Clamping Function</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DISABLED</name>
                  <description>This bit controls the IO clamping function is disabled.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENABLED</name>
                  <description>This bit controls the IO clamping function is enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>PIO0_13</name>
          <description>Configuration array for PIO0 to PIO21. PIO[10] and PIO[11] use a different IO cell type to the other PIO pins and so there are some differences in the bit field descriptions of the PIO register for these Ios. Reset values vary depending on whether the IO is configured with a pull-up or pull-down resistor as default. The value is also affected by the IO type. Reset value 0x180 for PIO 0,3,4,5,8,9,12,13,14,15,16,21. Reset value 0x198 for PIO 1,2,6,7,17,18,19,20. Reset value 0x188 for PIO 10,11.</description>
          <addressOffset>0x34</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x182</resetValue>
          <resetMask>0xFFF</resetMask>
          <fields>
            <field>
              <name>FUNC</name>
              <description>Select digital function assigned to this pin.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>ALT0</name>
                  <description>Alternative connection 0.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ALT1</name>
                  <description>Alternative connection 1.</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ALT2</name>
                  <description>Alternative connection 2.</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ALT3</name>
                  <description>Alternative connection 3.</description>
                  <value>0x3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ALT4</name>
                  <description>Alternative connection 4.</description>
                  <value>0x4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ALT5</name>
                  <description>Alternative connection 5.</description>
                  <value>0x5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ALT6</name>
                  <description>Alternative connection 6.</description>
                  <value>0x6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ALT7</name>
                  <description>Alternative connection 7.</description>
                  <value>0x7</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>MODE</name>
              <description>Select function mode (on-chip pull-up/pull-down resistor control). For MFIO type ONLY (all PIOs except PIO10 &amp; 11): 0x0 : Pull-up. Pull-up resistor enabled. 0x1 : Repeater mode (bus keeper) 0x2 : Plain Input 0x3 : Pull-down. Pull-down resistor enabled. Note: When the register is related to a general purpose MFIO type pad (that is all PIOs except PIO10 &amp; 11) - Bit [3] (of the register) is connected to EPD (enable pull-down) input of the MFIO pad. - Bit [4] (of the register) is connected to EPUN (enable pull-up NOT) input of MFIO pad.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>PULL_UP</name>
                  <description>Pull-up. Pull-up resistor enabled.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>REPEATER</name>
                  <description>Repeater. Repeater mode (bus keeper).</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INACTIVE</name>
                  <description>Inactive. Plain Input.</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PULL_DOWN</name>
                  <description>Pull-down. Pull-down resistor enabled.</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SLEW0</name>
              <description>This bit field is used in combination with SLEW1. The higher [SLEW1,SLEW0] the quicker the IO cell slew rate.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DISABLED</name>
                  <description>Driver slew0 rate is disabled.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENABLED</name>
                  <description>Driver slew0 rate is enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INVERT</name>
              <description>Input Polarity.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DISABLED</name>
                  <description>Disabled. Input function is not inverted.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENABLED</name>
                  <description>Enabled. Input function is inverted.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DIGIMODE</name>
              <description>Select Analog/Digital Mode. 0 Analog mode. 1 Digital mode. When in analog mode, the receiver path in the IO cell is disabled. In this mode, it is essential that the digital function (e.g. GPIO) is not configured as an output. Otherwise it may conflict with analog stuff (loopback of digital on analog input). In other words, the digital output is not automatically disabled when the IO is in analog mode. As a consequence, it is not possible to disable the receiver path when the IO is used for digital output purpose.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>ANALOG</name>
                  <description>Analog mode, digital input is disabled.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIGITAL</name>
                  <description>Digital mode, digital input is enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>FILTEROFF</name>
              <description>Controls Input Glitch Filter.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>ENABLED</name>
                  <description>Filter enabled. Noise pulses below approximately 1 ns are filtered out.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DISABLED</name>
                  <description>Filter disabled. No input filtering is done.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SLEW1</name>
              <description>Driver Slew Rate. This bit is used in combination with SLEW0. The higher [SLEW1,SLEW0], the quicker the slew rate.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DISABLED</name>
                  <description>Driver slew1 rate is disabled.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENABLED</name>
                  <description>Driver slew1 rate is enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>OD</name>
              <description>Controls open-drain mode.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NORMAL</name>
                  <description>Normal. Normal push-pull output</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>OPEN_DRAIN</name>
                  <description>Open-drain. Simulated open-drain output (high drive disabled).</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SSEL</name>
              <description>IO Clamping Function</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DISABLED</name>
                  <description>This bit controls the IO clamping function is disabled.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENABLED</name>
                  <description>This bit controls the IO clamping function is enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>PIO0_14</name>
          <description>Configuration array for PIO0 to PIO21. PIO[10] and PIO[11] use a different IO cell type to the other PIO pins and so there are some differences in the bit field descriptions of the PIO register for these Ios. Reset values vary depending on whether the IO is configured with a pull-up or pull-down resistor as default. The value is also affected by the IO type. Reset value 0x180 for PIO 0,3,4,5,8,9,12,13,14,15,16,21. Reset value 0x198 for PIO 1,2,6,7,17,18,19,20. Reset value 0x188 for PIO 10,11.</description>
          <addressOffset>0x38</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x180</resetValue>
          <resetMask>0xFFF</resetMask>
          <fields>
            <field>
              <name>FUNC</name>
              <description>Select digital function assigned to this pin.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>ALT0</name>
                  <description>Alternative connection 0.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ALT1</name>
                  <description>Alternative connection 1.</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ALT2</name>
                  <description>Alternative connection 2.</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ALT3</name>
                  <description>Alternative connection 3.</description>
                  <value>0x3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ALT4</name>
                  <description>Alternative connection 4.</description>
                  <value>0x4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ALT5</name>
                  <description>Alternative connection 5.</description>
                  <value>0x5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ALT6</name>
                  <description>Alternative connection 6.</description>
                  <value>0x6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ALT7</name>
                  <description>Alternative connection 7.</description>
                  <value>0x7</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>MODE</name>
              <description>Select function mode (on-chip pull-up/pull-down resistor control). For MFIO type ONLY (all PIOs except PIO10 &amp; 11): 0x0 : Pull-up. Pull-up resistor enabled. 0x1 : Repeater mode (bus keeper) 0x2 : Plain Input 0x3 : Pull-down. Pull-down resistor enabled. Note: When the register is related to a general purpose MFIO type pad (that is all PIOs except PIO10 &amp; 11) - Bit [3] (of the register) is connected to EPD (enable pull-down) input of the MFIO pad. - Bit [4] (of the register) is connected to EPUN (enable pull-up NOT) input of MFIO pad.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>PULL_UP</name>
                  <description>Pull-up. Pull-up resistor enabled.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>REPEATER</name>
                  <description>Repeater. Repeater mode (bus keeper).</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INACTIVE</name>
                  <description>Inactive. Plain Input.</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PULL_DOWN</name>
                  <description>Pull-down. Pull-down resistor enabled.</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SLEW0</name>
              <description>This bit field is used in combination with SLEW1. The higher [SLEW1,SLEW0] the quicker the IO cell slew rate.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DISABLED</name>
                  <description>Driver slew0 rate is disabled.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENABLED</name>
                  <description>Driver slew0 rate is enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INVERT</name>
              <description>Input Polarity.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DISABLED</name>
                  <description>Disabled. Input function is not inverted.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENABLED</name>
                  <description>Enabled. Input function is inverted.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DIGIMODE</name>
              <description>Select Analog/Digital Mode. 0 Analog mode. 1 Digital mode. When in analog mode, the receiver path in the IO cell is disabled. In this mode, it is essential that the digital function (e.g. GPIO) is not configured as an output. Otherwise it may conflict with analog stuff (loopback of digital on analog input). In other words, the digital output is not automatically disabled when the IO is in analog mode. As a consequence, it is not possible to disable the receiver path when the IO is used for digital output purpose.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>ANALOG</name>
                  <description>Analog mode, digital input is disabled.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIGITAL</name>
                  <description>Digital mode, digital input is enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>FILTEROFF</name>
              <description>Controls Input Glitch Filter.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>ENABLED</name>
                  <description>Filter enabled. Noise pulses below approximately 1 ns are filtered out.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DISABLED</name>
                  <description>Filter disabled. No input filtering is done.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SLEW1</name>
              <description>Driver Slew Rate. This bit is used in combination with SLEW0. The higher [SLEW1,SLEW0], the quicker the slew rate.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DISABLED</name>
                  <description>Driver slew1 rate is disabled.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENABLED</name>
                  <description>Driver slew1 rate is enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>OD</name>
              <description>Controls open-drain mode.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NORMAL</name>
                  <description>Normal. Normal push-pull output</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>OPEN_DRAIN</name>
                  <description>Open-drain. Simulated open-drain output (high drive disabled).</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SSEL</name>
              <description>IO Clamping Function</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DISABLED</name>
                  <description>This bit controls the IO clamping function is disabled.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENABLED</name>
                  <description>This bit controls the IO clamping function is enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>PIO0_15</name>
          <description>Configuration array for PIO0 to PIO21. PIO[10] and PIO[11] use a different IO cell type to the other PIO pins and so there are some differences in the bit field descriptions of the PIO register for these Ios. Reset values vary depending on whether the IO is configured with a pull-up or pull-down resistor as default. The value is also affected by the IO type. Reset value 0x180 for PIO 0,3,4,5,8,9,12,13,14,15,16,21. Reset value 0x198 for PIO 1,2,6,7,17,18,19,20. Reset value 0x188 for PIO 10,11.</description>
          <addressOffset>0x3C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x180</resetValue>
          <resetMask>0xFFF</resetMask>
          <fields>
            <field>
              <name>FUNC</name>
              <description>Select digital function assigned to this pin.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>ALT0</name>
                  <description>Alternative connection 0.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ALT1</name>
                  <description>Alternative connection 1.</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ALT2</name>
                  <description>Alternative connection 2.</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ALT3</name>
                  <description>Alternative connection 3.</description>
                  <value>0x3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ALT4</name>
                  <description>Alternative connection 4.</description>
                  <value>0x4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ALT5</name>
                  <description>Alternative connection 5.</description>
                  <value>0x5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ALT6</name>
                  <description>Alternative connection 6.</description>
                  <value>0x6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ALT7</name>
                  <description>Alternative connection 7.</description>
                  <value>0x7</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>MODE</name>
              <description>Select function mode (on-chip pull-up/pull-down resistor control). For MFIO type ONLY (all PIOs except PIO10 &amp; 11): 0x0 : Pull-up. Pull-up resistor enabled. 0x1 : Repeater mode (bus keeper) 0x2 : Plain Input 0x3 : Pull-down. Pull-down resistor enabled. Note: When the register is related to a general purpose MFIO type pad (that is all PIOs except PIO10 &amp; 11) - Bit [3] (of the register) is connected to EPD (enable pull-down) input of the MFIO pad. - Bit [4] (of the register) is connected to EPUN (enable pull-up NOT) input of MFIO pad.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>PULL_UP</name>
                  <description>Pull-up. Pull-up resistor enabled.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>REPEATER</name>
                  <description>Repeater. Repeater mode (bus keeper).</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INACTIVE</name>
                  <description>Inactive. Plain Input.</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PULL_DOWN</name>
                  <description>Pull-down. Pull-down resistor enabled.</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SLEW0</name>
              <description>This bit field is used in combination with SLEW1. The higher [SLEW1,SLEW0] the quicker the IO cell slew rate.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DISABLED</name>
                  <description>Driver slew0 rate is disabled.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENABLED</name>
                  <description>Driver slew0 rate is enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INVERT</name>
              <description>Input Polarity.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DISABLED</name>
                  <description>Disabled. Input function is not inverted.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENABLED</name>
                  <description>Enabled. Input function is inverted.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DIGIMODE</name>
              <description>Select Analog/Digital Mode. 0 Analog mode. 1 Digital mode. When in analog mode, the receiver path in the IO cell is disabled. In this mode, it is essential that the digital function (e.g. GPIO) is not configured as an output. Otherwise it may conflict with analog stuff (loopback of digital on analog input). In other words, the digital output is not automatically disabled when the IO is in analog mode. As a consequence, it is not possible to disable the receiver path when the IO is used for digital output purpose.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>ANALOG</name>
                  <description>Analog mode, digital input is disabled.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIGITAL</name>
                  <description>Digital mode, digital input is enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>FILTEROFF</name>
              <description>Controls Input Glitch Filter.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>ENABLED</name>
                  <description>Filter enabled. Noise pulses below approximately 1 ns are filtered out.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DISABLED</name>
                  <description>Filter disabled. No input filtering is done.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SLEW1</name>
              <description>Driver Slew Rate. This bit is used in combination with SLEW0. The higher [SLEW1,SLEW0], the quicker the slew rate.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DISABLED</name>
                  <description>Driver slew1 rate is disabled.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENABLED</name>
                  <description>Driver slew1 rate is enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>OD</name>
              <description>Controls open-drain mode.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NORMAL</name>
                  <description>Normal. Normal push-pull output</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>OPEN_DRAIN</name>
                  <description>Open-drain. Simulated open-drain output (high drive disabled).</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SSEL</name>
              <description>IO Clamping Function</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DISABLED</name>
                  <description>This bit controls the IO clamping function is disabled.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENABLED</name>
                  <description>This bit controls the IO clamping function is enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>PIO0_16</name>
          <description>Configuration array for PIO0 to PIO21. PIO[10] and PIO[11] use a different IO cell type to the other PIO pins and so there are some differences in the bit field descriptions of the PIO register for these Ios. Reset values vary depending on whether the IO is configured with a pull-up or pull-down resistor as default. The value is also affected by the IO type. Reset value 0x180 for PIO 0,3,4,5,8,9,12,13,14,15,16,21. Reset value 0x198 for PIO 1,2,6,7,17,18,19,20. Reset value 0x188 for PIO 10,11.</description>
          <addressOffset>0x40</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x180</resetValue>
          <resetMask>0xFFF</resetMask>
          <fields>
            <field>
              <name>FUNC</name>
              <description>Select digital function assigned to this pin.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>ALT0</name>
                  <description>Alternative connection 0.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ALT1</name>
                  <description>Alternative connection 1.</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ALT2</name>
                  <description>Alternative connection 2.</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ALT3</name>
                  <description>Alternative connection 3.</description>
                  <value>0x3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ALT4</name>
                  <description>Alternative connection 4.</description>
                  <value>0x4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ALT5</name>
                  <description>Alternative connection 5.</description>
                  <value>0x5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ALT6</name>
                  <description>Alternative connection 6.</description>
                  <value>0x6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ALT7</name>
                  <description>Alternative connection 7.</description>
                  <value>0x7</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>MODE</name>
              <description>Select function mode (on-chip pull-up/pull-down resistor control). For MFIO type ONLY (all PIOs except PIO10 &amp; 11): 0x0 : Pull-up. Pull-up resistor enabled. 0x1 : Repeater mode (bus keeper) 0x2 : Plain Input 0x3 : Pull-down. Pull-down resistor enabled. Note: When the register is related to a general purpose MFIO type pad (that is all PIOs except PIO10 &amp; 11) - Bit [3] (of the register) is connected to EPD (enable pull-down) input of the MFIO pad. - Bit [4] (of the register) is connected to EPUN (enable pull-up NOT) input of MFIO pad.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>PULL_UP</name>
                  <description>Pull-up. Pull-up resistor enabled.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>REPEATER</name>
                  <description>Repeater. Repeater mode (bus keeper).</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INACTIVE</name>
                  <description>Inactive. Plain Input.</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PULL_DOWN</name>
                  <description>Pull-down. Pull-down resistor enabled.</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SLEW0</name>
              <description>This bit field is used in combination with SLEW1. The higher [SLEW1,SLEW0] the quicker the IO cell slew rate.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DISABLED</name>
                  <description>Driver slew0 rate is disabled.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENABLED</name>
                  <description>Driver slew0 rate is enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INVERT</name>
              <description>Input Polarity.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DISABLED</name>
                  <description>Disabled. Input function is not inverted.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENABLED</name>
                  <description>Enabled. Input function is inverted.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DIGIMODE</name>
              <description>Select Analog/Digital Mode. 0 Analog mode. 1 Digital mode. When in analog mode, the receiver path in the IO cell is disabled. In this mode, it is essential that the digital function (e.g. GPIO) is not configured as an output. Otherwise it may conflict with analog stuff (loopback of digital on analog input). In other words, the digital output is not automatically disabled when the IO is in analog mode. As a consequence, it is not possible to disable the receiver path when the IO is used for digital output purpose.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>ANALOG</name>
                  <description>Analog mode, digital input is disabled.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIGITAL</name>
                  <description>Digital mode, digital input is enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>FILTEROFF</name>
              <description>Controls Input Glitch Filter.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>ENABLED</name>
                  <description>Filter enabled. Noise pulses below approximately 1 ns are filtered out.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DISABLED</name>
                  <description>Filter disabled. No input filtering is done.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SLEW1</name>
              <description>Driver Slew Rate. This bit is used in combination with SLEW0. The higher [SLEW1,SLEW0], the quicker the slew rate.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DISABLED</name>
                  <description>Driver slew1 rate is disabled.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENABLED</name>
                  <description>Driver slew1 rate is enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>OD</name>
              <description>Controls open-drain mode.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NORMAL</name>
                  <description>Normal. Normal push-pull output</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>OPEN_DRAIN</name>
                  <description>Open-drain. Simulated open-drain output (high drive disabled).</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SSEL</name>
              <description>IO Clamping Function</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DISABLED</name>
                  <description>This bit controls the IO clamping function is disabled.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENABLED</name>
                  <description>This bit controls the IO clamping function is enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>PIO0_17</name>
          <description>Configuration array for PIO0 to PIO21. PIO[10] and PIO[11] use a different IO cell type to the other PIO pins and so there are some differences in the bit field descriptions of the PIO register for these Ios. Reset values vary depending on whether the IO is configured with a pull-up or pull-down resistor as default. The value is also affected by the IO type. Reset value 0x180 for PIO 0,3,4,5,8,9,12,13,14,15,16,21. Reset value 0x198 for PIO 1,2,6,7,17,18,19,20. Reset value 0x188 for PIO 10,11.</description>
          <addressOffset>0x44</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x198</resetValue>
          <resetMask>0xFFF</resetMask>
          <fields>
            <field>
              <name>FUNC</name>
              <description>Select digital function assigned to this pin.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>ALT0</name>
                  <description>Alternative connection 0.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ALT1</name>
                  <description>Alternative connection 1.</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ALT2</name>
                  <description>Alternative connection 2.</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ALT3</name>
                  <description>Alternative connection 3.</description>
                  <value>0x3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ALT4</name>
                  <description>Alternative connection 4.</description>
                  <value>0x4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ALT5</name>
                  <description>Alternative connection 5.</description>
                  <value>0x5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ALT6</name>
                  <description>Alternative connection 6.</description>
                  <value>0x6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ALT7</name>
                  <description>Alternative connection 7.</description>
                  <value>0x7</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>MODE</name>
              <description>Select function mode (on-chip pull-up/pull-down resistor control). For MFIO type ONLY (all PIOs except PIO10 &amp; 11): 0x0 : Pull-up. Pull-up resistor enabled. 0x1 : Repeater mode (bus keeper) 0x2 : Plain Input 0x3 : Pull-down. Pull-down resistor enabled. Note: When the register is related to a general purpose MFIO type pad (that is all PIOs except PIO10 &amp; 11) - Bit [3] (of the register) is connected to EPD (enable pull-down) input of the MFIO pad. - Bit [4] (of the register) is connected to EPUN (enable pull-up NOT) input of MFIO pad.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>PULL_UP</name>
                  <description>Pull-up. Pull-up resistor enabled.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>REPEATER</name>
                  <description>Repeater. Repeater mode (bus keeper).</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INACTIVE</name>
                  <description>Inactive. Plain Input.</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PULL_DOWN</name>
                  <description>Pull-down. Pull-down resistor enabled.</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SLEW0</name>
              <description>This bit field is used in combination with SLEW1. The higher [SLEW1,SLEW0] the quicker the IO cell slew rate.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DISABLED</name>
                  <description>Driver slew0 rate is disabled.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENABLED</name>
                  <description>Driver slew0 rate is enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INVERT</name>
              <description>Input Polarity.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DISABLED</name>
                  <description>Disabled. Input function is not inverted.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENABLED</name>
                  <description>Enabled. Input function is inverted.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DIGIMODE</name>
              <description>Select Analog/Digital Mode. 0 Analog mode. 1 Digital mode. When in analog mode, the receiver path in the IO cell is disabled. In this mode, it is essential that the digital function (e.g. GPIO) is not configured as an output. Otherwise it may conflict with analog stuff (loopback of digital on analog input). In other words, the digital output is not automatically disabled when the IO is in analog mode. As a consequence, it is not possible to disable the receiver path when the IO is used for digital output purpose.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>ANALOG</name>
                  <description>Analog mode, digital input is disabled.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIGITAL</name>
                  <description>Digital mode, digital input is enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>FILTEROFF</name>
              <description>Controls Input Glitch Filter.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>ENABLED</name>
                  <description>Filter enabled. Noise pulses below approximately 1 ns are filtered out.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DISABLED</name>
                  <description>Filter disabled. No input filtering is done.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SLEW1</name>
              <description>Driver Slew Rate. This bit is used in combination with SLEW0. The higher [SLEW1,SLEW0], the quicker the slew rate.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DISABLED</name>
                  <description>Driver slew1 rate is disabled.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENABLED</name>
                  <description>Driver slew1 rate is enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>OD</name>
              <description>Controls open-drain mode.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NORMAL</name>
                  <description>Normal. Normal push-pull output</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>OPEN_DRAIN</name>
                  <description>Open-drain. Simulated open-drain output (high drive disabled).</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SSEL</name>
              <description>IO Clamping Function</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DISABLED</name>
                  <description>This bit controls the IO clamping function is disabled.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENABLED</name>
                  <description>This bit controls the IO clamping function is enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>PIO0_18</name>
          <description>Configuration array for PIO0 to PIO21. PIO[10] and PIO[11] use a different IO cell type to the other PIO pins and so there are some differences in the bit field descriptions of the PIO register for these Ios. Reset values vary depending on whether the IO is configured with a pull-up or pull-down resistor as default. The value is also affected by the IO type. Reset value 0x180 for PIO 0,3,4,5,8,9,12,13,14,15,16,21. Reset value 0x198 for PIO 1,2,6,7,17,18,19,20. Reset value 0x188 for PIO 10,11.</description>
          <addressOffset>0x48</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x198</resetValue>
          <resetMask>0xFFF</resetMask>
          <fields>
            <field>
              <name>FUNC</name>
              <description>Select digital function assigned to this pin.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>ALT0</name>
                  <description>Alternative connection 0.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ALT1</name>
                  <description>Alternative connection 1.</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ALT2</name>
                  <description>Alternative connection 2.</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ALT3</name>
                  <description>Alternative connection 3.</description>
                  <value>0x3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ALT4</name>
                  <description>Alternative connection 4.</description>
                  <value>0x4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ALT5</name>
                  <description>Alternative connection 5.</description>
                  <value>0x5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ALT6</name>
                  <description>Alternative connection 6.</description>
                  <value>0x6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ALT7</name>
                  <description>Alternative connection 7.</description>
                  <value>0x7</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>MODE</name>
              <description>Select function mode (on-chip pull-up/pull-down resistor control). For MFIO type ONLY (all PIOs except PIO10 &amp; 11): 0x0 : Pull-up. Pull-up resistor enabled. 0x1 : Repeater mode (bus keeper) 0x2 : Plain Input 0x3 : Pull-down. Pull-down resistor enabled. Note: When the register is related to a general purpose MFIO type pad (that is all PIOs except PIO10 &amp; 11) - Bit [3] (of the register) is connected to EPD (enable pull-down) input of the MFIO pad. - Bit [4] (of the register) is connected to EPUN (enable pull-up NOT) input of MFIO pad.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>PULL_UP</name>
                  <description>Pull-up. Pull-up resistor enabled.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>REPEATER</name>
                  <description>Repeater. Repeater mode (bus keeper).</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INACTIVE</name>
                  <description>Inactive. Plain Input.</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PULL_DOWN</name>
                  <description>Pull-down. Pull-down resistor enabled.</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SLEW0</name>
              <description>This bit field is used in combination with SLEW1. The higher [SLEW1,SLEW0] the quicker the IO cell slew rate.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DISABLED</name>
                  <description>Driver slew0 rate is disabled.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENABLED</name>
                  <description>Driver slew0 rate is enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INVERT</name>
              <description>Input Polarity.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DISABLED</name>
                  <description>Disabled. Input function is not inverted.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENABLED</name>
                  <description>Enabled. Input function is inverted.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DIGIMODE</name>
              <description>Select Analog/Digital Mode. 0 Analog mode. 1 Digital mode. When in analog mode, the receiver path in the IO cell is disabled. In this mode, it is essential that the digital function (e.g. GPIO) is not configured as an output. Otherwise it may conflict with analog stuff (loopback of digital on analog input). In other words, the digital output is not automatically disabled when the IO is in analog mode. As a consequence, it is not possible to disable the receiver path when the IO is used for digital output purpose.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>ANALOG</name>
                  <description>Analog mode, digital input is disabled.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIGITAL</name>
                  <description>Digital mode, digital input is enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>FILTEROFF</name>
              <description>Controls Input Glitch Filter.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>ENABLED</name>
                  <description>Filter enabled. Noise pulses below approximately 1 ns are filtered out.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DISABLED</name>
                  <description>Filter disabled. No input filtering is done.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SLEW1</name>
              <description>Driver Slew Rate. This bit is used in combination with SLEW0. The higher [SLEW1,SLEW0], the quicker the slew rate.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DISABLED</name>
                  <description>Driver slew1 rate is disabled.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENABLED</name>
                  <description>Driver slew1 rate is enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>OD</name>
              <description>Controls open-drain mode.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NORMAL</name>
                  <description>Normal. Normal push-pull output</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>OPEN_DRAIN</name>
                  <description>Open-drain. Simulated open-drain output (high drive disabled).</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SSEL</name>
              <description>IO Clamping Function</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DISABLED</name>
                  <description>This bit controls the IO clamping function is disabled.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENABLED</name>
                  <description>This bit controls the IO clamping function is enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>PIO0_19</name>
          <description>Configuration array for PIO0 to PIO21. PIO[10] and PIO[11] use a different IO cell type to the other PIO pins and so there are some differences in the bit field descriptions of the PIO register for these Ios. Reset values vary depending on whether the IO is configured with a pull-up or pull-down resistor as default. The value is also affected by the IO type. Reset value 0x180 for PIO 0,3,4,5,8,9,12,13,14,15,16,21. Reset value 0x198 for PIO 1,2,6,7,17,18,19,20. Reset value 0x188 for PIO 10,11.</description>
          <addressOffset>0x4C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x198</resetValue>
          <resetMask>0xFFF</resetMask>
          <fields>
            <field>
              <name>FUNC</name>
              <description>Select digital function assigned to this pin.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>ALT0</name>
                  <description>Alternative connection 0.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ALT1</name>
                  <description>Alternative connection 1.</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ALT2</name>
                  <description>Alternative connection 2.</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ALT3</name>
                  <description>Alternative connection 3.</description>
                  <value>0x3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ALT4</name>
                  <description>Alternative connection 4.</description>
                  <value>0x4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ALT5</name>
                  <description>Alternative connection 5.</description>
                  <value>0x5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ALT6</name>
                  <description>Alternative connection 6.</description>
                  <value>0x6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ALT7</name>
                  <description>Alternative connection 7.</description>
                  <value>0x7</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>MODE</name>
              <description>Select function mode (on-chip pull-up/pull-down resistor control). For MFIO type ONLY (all PIOs except PIO10 &amp; 11): 0x0 : Pull-up. Pull-up resistor enabled. 0x1 : Repeater mode (bus keeper) 0x2 : Plain Input 0x3 : Pull-down. Pull-down resistor enabled. Note: When the register is related to a general purpose MFIO type pad (that is all PIOs except PIO10 &amp; 11) - Bit [3] (of the register) is connected to EPD (enable pull-down) input of the MFIO pad. - Bit [4] (of the register) is connected to EPUN (enable pull-up NOT) input of MFIO pad.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>PULL_UP</name>
                  <description>Pull-up. Pull-up resistor enabled.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>REPEATER</name>
                  <description>Repeater. Repeater mode (bus keeper).</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INACTIVE</name>
                  <description>Inactive. Plain Input.</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PULL_DOWN</name>
                  <description>Pull-down. Pull-down resistor enabled.</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SLEW0</name>
              <description>This bit field is used in combination with SLEW1. The higher [SLEW1,SLEW0] the quicker the IO cell slew rate.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DISABLED</name>
                  <description>Driver slew0 rate is disabled.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENABLED</name>
                  <description>Driver slew0 rate is enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INVERT</name>
              <description>Input Polarity.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DISABLED</name>
                  <description>Disabled. Input function is not inverted.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENABLED</name>
                  <description>Enabled. Input function is inverted.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DIGIMODE</name>
              <description>Select Analog/Digital Mode. 0 Analog mode. 1 Digital mode. When in analog mode, the receiver path in the IO cell is disabled. In this mode, it is essential that the digital function (e.g. GPIO) is not configured as an output. Otherwise it may conflict with analog stuff (loopback of digital on analog input). In other words, the digital output is not automatically disabled when the IO is in analog mode. As a consequence, it is not possible to disable the receiver path when the IO is used for digital output purpose.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>ANALOG</name>
                  <description>Analog mode, digital input is disabled.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIGITAL</name>
                  <description>Digital mode, digital input is enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>FILTEROFF</name>
              <description>Controls Input Glitch Filter.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>ENABLED</name>
                  <description>Filter enabled. Noise pulses below approximately 1 ns are filtered out.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DISABLED</name>
                  <description>Filter disabled. No input filtering is done.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SLEW1</name>
              <description>Driver Slew Rate. This bit is used in combination with SLEW0. The higher [SLEW1,SLEW0], the quicker the slew rate.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DISABLED</name>
                  <description>Driver slew1 rate is disabled.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENABLED</name>
                  <description>Driver slew1 rate is enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>OD</name>
              <description>Controls open-drain mode.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NORMAL</name>
                  <description>Normal. Normal push-pull output</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>OPEN_DRAIN</name>
                  <description>Open-drain. Simulated open-drain output (high drive disabled).</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SSEL</name>
              <description>IO Clamping Function</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DISABLED</name>
                  <description>This bit controls the IO clamping function is disabled.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENABLED</name>
                  <description>This bit controls the IO clamping function is enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>PIO0_20</name>
          <description>Configuration array for PIO0 to PIO21. PIO[10] and PIO[11] use a different IO cell type to the other PIO pins and so there are some differences in the bit field descriptions of the PIO register for these Ios. Reset values vary depending on whether the IO is configured with a pull-up or pull-down resistor as default. The value is also affected by the IO type. Reset value 0x180 for PIO 0,3,4,5,8,9,12,13,14,15,16,21. Reset value 0x198 for PIO 1,2,6,7,17,18,19,20. Reset value 0x188 for PIO 10,11.</description>
          <addressOffset>0x50</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x198</resetValue>
          <resetMask>0xFFF</resetMask>
          <fields>
            <field>
              <name>FUNC</name>
              <description>Select digital function assigned to this pin.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>ALT0</name>
                  <description>Alternative connection 0.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ALT1</name>
                  <description>Alternative connection 1.</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ALT2</name>
                  <description>Alternative connection 2.</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ALT3</name>
                  <description>Alternative connection 3.</description>
                  <value>0x3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ALT4</name>
                  <description>Alternative connection 4.</description>
                  <value>0x4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ALT5</name>
                  <description>Alternative connection 5.</description>
                  <value>0x5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ALT6</name>
                  <description>Alternative connection 6.</description>
                  <value>0x6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ALT7</name>
                  <description>Alternative connection 7.</description>
                  <value>0x7</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>MODE</name>
              <description>Select function mode (on-chip pull-up/pull-down resistor control). For MFIO type ONLY (all PIOs except PIO10 &amp; 11): 0x0 : Pull-up. Pull-up resistor enabled. 0x1 : Repeater mode (bus keeper) 0x2 : Plain Input 0x3 : Pull-down. Pull-down resistor enabled. Note: When the register is related to a general purpose MFIO type pad (that is all PIOs except PIO10 &amp; 11) - Bit [3] (of the register) is connected to EPD (enable pull-down) input of the MFIO pad. - Bit [4] (of the register) is connected to EPUN (enable pull-up NOT) input of MFIO pad.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>PULL_UP</name>
                  <description>Pull-up. Pull-up resistor enabled.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>REPEATER</name>
                  <description>Repeater. Repeater mode (bus keeper).</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INACTIVE</name>
                  <description>Inactive. Plain Input.</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PULL_DOWN</name>
                  <description>Pull-down. Pull-down resistor enabled.</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SLEW0</name>
              <description>This bit field is used in combination with SLEW1. The higher [SLEW1,SLEW0] the quicker the IO cell slew rate.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DISABLED</name>
                  <description>Driver slew0 rate is disabled.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENABLED</name>
                  <description>Driver slew0 rate is enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INVERT</name>
              <description>Input Polarity.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DISABLED</name>
                  <description>Disabled. Input function is not inverted.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENABLED</name>
                  <description>Enabled. Input function is inverted.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DIGIMODE</name>
              <description>Select Analog/Digital Mode. 0 Analog mode. 1 Digital mode. When in analog mode, the receiver path in the IO cell is disabled. In this mode, it is essential that the digital function (e.g. GPIO) is not configured as an output. Otherwise it may conflict with analog stuff (loopback of digital on analog input). In other words, the digital output is not automatically disabled when the IO is in analog mode. As a consequence, it is not possible to disable the receiver path when the IO is used for digital output purpose.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>ANALOG</name>
                  <description>Analog mode, digital input is disabled.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIGITAL</name>
                  <description>Digital mode, digital input is enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>FILTEROFF</name>
              <description>Controls Input Glitch Filter.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>ENABLED</name>
                  <description>Filter enabled. Noise pulses below approximately 1 ns are filtered out.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DISABLED</name>
                  <description>Filter disabled. No input filtering is done.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SLEW1</name>
              <description>Driver Slew Rate. This bit is used in combination with SLEW0. The higher [SLEW1,SLEW0], the quicker the slew rate.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DISABLED</name>
                  <description>Driver slew1 rate is disabled.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENABLED</name>
                  <description>Driver slew1 rate is enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>OD</name>
              <description>Controls open-drain mode.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NORMAL</name>
                  <description>Normal. Normal push-pull output</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>OPEN_DRAIN</name>
                  <description>Open-drain. Simulated open-drain output (high drive disabled).</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SSEL</name>
              <description>IO Clamping Function</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DISABLED</name>
                  <description>This bit controls the IO clamping function is disabled.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENABLED</name>
                  <description>This bit controls the IO clamping function is enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>PIO0_21</name>
          <description>Configuration array for PIO0 to PIO21. PIO[10] and PIO[11] use a different IO cell type to the other PIO pins and so there are some differences in the bit field descriptions of the PIO register for these Ios. Reset values vary depending on whether the IO is configured with a pull-up or pull-down resistor as default. The value is also affected by the IO type. Reset value 0x180 for PIO 0,3,4,5,8,9,12,13,14,15,16,21. Reset value 0x198 for PIO 1,2,6,7,17,18,19,20. Reset value 0x188 for PIO 10,11.</description>
          <addressOffset>0x54</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x180</resetValue>
          <resetMask>0xFFF</resetMask>
          <fields>
            <field>
              <name>FUNC</name>
              <description>Select digital function assigned to this pin.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>ALT0</name>
                  <description>Alternative connection 0.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ALT1</name>
                  <description>Alternative connection 1.</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ALT2</name>
                  <description>Alternative connection 2.</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ALT3</name>
                  <description>Alternative connection 3.</description>
                  <value>0x3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ALT4</name>
                  <description>Alternative connection 4.</description>
                  <value>0x4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ALT5</name>
                  <description>Alternative connection 5.</description>
                  <value>0x5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ALT6</name>
                  <description>Alternative connection 6.</description>
                  <value>0x6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ALT7</name>
                  <description>Alternative connection 7.</description>
                  <value>0x7</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>MODE</name>
              <description>Select function mode (on-chip pull-up/pull-down resistor control). For MFIO type ONLY (all PIOs except PIO10 &amp; 11): 0x0 : Pull-up. Pull-up resistor enabled. 0x1 : Repeater mode (bus keeper) 0x2 : Plain Input 0x3 : Pull-down. Pull-down resistor enabled. Note: When the register is related to a general purpose MFIO type pad (that is all PIOs except PIO10 &amp; 11) - Bit [3] (of the register) is connected to EPD (enable pull-down) input of the MFIO pad. - Bit [4] (of the register) is connected to EPUN (enable pull-up NOT) input of MFIO pad.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>PULL_UP</name>
                  <description>Pull-up. Pull-up resistor enabled.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>REPEATER</name>
                  <description>Repeater. Repeater mode (bus keeper).</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INACTIVE</name>
                  <description>Inactive. Plain Input.</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PULL_DOWN</name>
                  <description>Pull-down. Pull-down resistor enabled.</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SLEW0</name>
              <description>This bit field is used in combination with SLEW1. The higher [SLEW1,SLEW0] the quicker the IO cell slew rate.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DISABLED</name>
                  <description>Driver slew0 rate is disabled.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENABLED</name>
                  <description>Driver slew0 rate is enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INVERT</name>
              <description>Input Polarity.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DISABLED</name>
                  <description>Disabled. Input function is not inverted.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENABLED</name>
                  <description>Enabled. Input function is inverted.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DIGIMODE</name>
              <description>Select Analog/Digital Mode. 0 Analog mode. 1 Digital mode. When in analog mode, the receiver path in the IO cell is disabled. In this mode, it is essential that the digital function (e.g. GPIO) is not configured as an output. Otherwise it may conflict with analog stuff (loopback of digital on analog input). In other words, the digital output is not automatically disabled when the IO is in analog mode. As a consequence, it is not possible to disable the receiver path when the IO is used for digital output purpose.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>ANALOG</name>
                  <description>Analog mode, digital input is disabled.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIGITAL</name>
                  <description>Digital mode, digital input is enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>FILTEROFF</name>
              <description>Controls Input Glitch Filter.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>ENABLED</name>
                  <description>Filter enabled. Noise pulses below approximately 1 ns are filtered out.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DISABLED</name>
                  <description>Filter disabled. No input filtering is done.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SLEW1</name>
              <description>Driver Slew Rate. This bit is used in combination with SLEW0. The higher [SLEW1,SLEW0], the quicker the slew rate.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DISABLED</name>
                  <description>Driver slew1 rate is disabled.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENABLED</name>
                  <description>Driver slew1 rate is enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>OD</name>
              <description>Controls open-drain mode.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NORMAL</name>
                  <description>Normal. Normal push-pull output</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>OPEN_DRAIN</name>
                  <description>Open-drain. Simulated open-drain output (high drive disabled).</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SSEL</name>
              <description>IO Clamping Function</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DISABLED</name>
                  <description>This bit controls the IO clamping function is disabled.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENABLED</name>
                  <description>This bit controls the IO clamping function is enabled.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>PINT</name>
      <description>This is the description of component pint It is a Pin Interrupt &amp; Pattern matching module with APB bus interface. More details will follow.</description>
      <groupName>PINT</groupName>
      <baseAddress>0x40010000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>0x34</size>
        <usage>registers</usage>
      </addressBlock>
      <interrupt>
        <name>PIN_INT0</name>
        <value>4</value>
      </interrupt>
      <interrupt>
        <name>PIN_INT1</name>
        <value>5</value>
      </interrupt>
      <interrupt>
        <name>PIN_INT2</name>
        <value>6</value>
      </interrupt>
      <interrupt>
        <name>PIN_INT3</name>
        <value>7</value>
      </interrupt>
      <registers>
        <register>
          <name>ISEL</name>
          <description>Pin Interrupt Mode register (only interrupts 0 to 3 supported to processor)</description>
          <addressOffset>0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>PMODE_PIN0</name>
              <description>Selects the interrupt mode for pin interrupt 0 (selected in PINTSEL0). 0: Edge sensitive. 1: Level sensitive.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PMODE_PIN1</name>
              <description>Selects the interrupt mode for pin interrupt 1 (selected in PINTSEL1). 0: Edge sensitive. 1: Level sensitive.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PMODE_PIN2</name>
              <description>Selects the interrupt mode for pin interrupt 2 (selected in PINTSEL2). 0: Edge sensitive. 1: Level sensitive.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PMODE_PIN3</name>
              <description>Selects the interrupt mode for pin interrupt 3 (selected in PINTSEL3). 0: Edge sensitive. 1: Level sensitive.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PMODE_PIN4</name>
              <description>Selects the interrupt mode for pin interrupt 4 (selected in PINTSEL4). [Note interrupt not supported to processor] 0: Edge sensitive. 1: Level sensitive.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PMODE_PIN5</name>
              <description>Selects the interrupt mode for pin interrupt 5 (selected in PINTSEL5). [Note interrupt not supported to processor] 0: Edge sensitive 1: Level sensitive</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PMODE_PIN6</name>
              <description>Selects the interrupt mode for pin interrupt 6 (selected in PINTSEL6). [Note interrupt not supported to processor] 0: Edge sensitive. 1: Level sensitive.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PMODE_PIN7</name>
              <description>Selects the interrupt mode for pin interrupt 7 (selected in PINTSEL7). [Note interrupt not supported to processor] 0: Edge sensitive. 1: Level sensitive.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>IENR</name>
          <description>Pin interrupt level or rising edge interrupt enable register (only interrupts 0 to 3 supported to processor)</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>ENRL_PIN0</name>
              <description>Enables the rising edge or level interrupt for pin interrupt 0 (selected in PINTSEL0). 0: Disable rising edge or level interrupt. 1: Enable rising edge or level interrupt.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ENRL_PIN1</name>
              <description>Enables the rising edge or level interrupt for pin interrupt 1 (selected in PINTSEL1). 0: Disable rising edge or level interrupt. 1: Enable rising edge or level interrupt.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ENRL_PIN2</name>
              <description>Enables the rising edge or level interrupt for pin interrupt 2 (selected in PINTSEL2). 0: Disable rising edge or level interrupt. 1: Enable rising edge or level interrupt.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ENRL_PIN3</name>
              <description>Enables the rising edge or level interrupt for pin interrupt 3 (selected in PINTSEL3). 0: Disable rising edge or level interrupt. 1: Enable rising edge or level interrupt.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ENRL_PIN4</name>
              <description>Enables the rising edge or level interrupt for pin interrupt 4 (selected in PINTSEL4). [Note interrupt not supported to processor] 0: Disable rising edge or level interrupt. 1: Enable rising edge or level interrupt.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ENRL_PIN5</name>
              <description>Enables the rising edge or level interrupt for pin interrupt 5 (selected in PINTSEL5). [Note interrupt not supported to processor] 0: Disable rising edge or level interrupt. 1: Enable rising edge or level interrupt.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ENRL_PIN6</name>
              <description>Enables the rising edge or level interrupt for pin interrupt 6 (selected in PINTSEL6). [Note interrupt not supported to processor] 0: Disable rising edge or level interrupt. 1: Enable rising edge or level interrupt.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ENRL_PIN7</name>
              <description>Enables the rising edge or level interrupt for pin interrupt 7 (selected in PINTSEL7). [Note interrupt not supported to processor] 0: Disable rising edge or level interrupt. 1: Enable rising edge or level interrupt.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SIENR</name>
          <description>Pin interrupt level or rising edge interrupt set register (only interrupts 0 to 3 supported to processor)</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SETENRL_PIN0</name>
              <description>Ones written to this address set bits in the IENR, thus enabling interrupts. Bit 0 sets bit 0 in the IENR register. 0: No operation. 1: Enable rising edge or level interrupt.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>SETENRL_PIN1</name>
              <description>Ones written to this address set bits in the IENR, thus enabling interrupts. Bit 1 sets bit 1 in the IENR register. 0: No operation. 1: Enable rising edge or level interrupt.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>SETENRL_PIN2</name>
              <description>Ones written to this address set bits in the IENR, thus enabling interrupts. Bit 2 sets bit 2 in the IENR register. 0: No operation. 1: Enable rising edge or level interrupt.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>SETENRL_PIN3</name>
              <description>Ones written to this address set bits in the IENR, thus enabling interrupts. Bit 3 sets bit 3 in the IENR register. 0: No operation. 1: Enable rising edge or level interrupt.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>SETENRL_PIN4</name>
              <description>Ones written to this address set bits in the IENR, thus enabling interrupts. Bit 4 sets bit 4 in the IENR register. [Note interrupt not supported to processor] 0: No operation. 1: Enable rising edge or level interrupt.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>SETENRL_PIN5</name>
              <description>Ones written to this address set bits in the IENR, thus enabling interrupts. Bit 5 sets bit 5 in the IENR register. [Note interrupt not supported to processor] 0: No operation. 1: Enable rising edge or level interrupt.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>SETENRL_PIN6</name>
              <description>Ones written to this address set bits in the IENR, thus enabling interrupts. Bit 6 sets bit 6 in the IENR register. [Note interrupt not supported to processor] 0: No operation. 1: Enable rising edge or level interrupt.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>SETENRL_PIN7</name>
              <description>Ones written to this address set bits in the IENR, thus enabling interrupts. Bit 7 sets bit 7 in the IENR register. [Note interrupt not supported to processor] 0: No operation. 1: Enable rising edge or level interrupt.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CIENR</name>
          <description>Pin interrupt level (rising edge interrupt) clear register (only interrupts 0 to 3 supported to processor)</description>
          <addressOffset>0xC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>CLRENRL_PIN0</name>
              <description>Ones written to this address clear bits in the IENR, thus disabling the interrupts. Bit 0 clears bit 0 in the IENR register. 0: No operation. 1: Disable rising edge or level interrupt.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>CLRENRL_PIN1</name>
              <description>Ones written to this address clear bits in the IENR, thus disabling the interrupts. Bit 1 clears bit 1 in the IENR register. 0: No operation. 1: Disable rising edge or level interrupt.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>CLRENRL_PIN2</name>
              <description>Ones written to this address clear bits in the IENR, thus disabling the interrupts. Bit 2 clears bit 2 in the IENR register. 0: No operation. 1: Disable rising edge or level interrupt.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>CLRENRL_PIN3</name>
              <description>Ones written to this address clear bits in the IENR, thus disabling the interrupts. Bit 3 clears bit 3 in the IENR register. 0: No operation. 1: Disable rising edge or level interrupt.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>CLRENRL_PIN4</name>
              <description>Ones written to this address clear bits in the IENR, thus disabling the interrupts. Bit 4 clears bit 4 in the IENR register. [Note interrupt not supported to processor] 0: No operation. 1: Disable rising edge or level interrupt.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>CLRENRL_PIN5</name>
              <description>Ones written to this address clear bits in the IENR, thus disabling the interrupts. Bit 5 clears bit 5 in the IENR register. [Note interrupt not supported to processor] 0: No operation. 1: Disable rising edge or level interrupt.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>CLRENRL_PIN6</name>
              <description>Ones written to this address clear bits in the IENR, thus disabling the interrupts. Bit 6 clears bit 6 in the IENR register. [Note interrupt not supported to processor] 0: No operation. 1: Disable rising edge or level interrupt.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>CLRENRL_PIN7</name>
              <description>Ones written to this address clear bits in the IENR, thus disabling the interrupts. Bit 7 clears bit 7 in the IENR register. [Note interrupt not supported to processor] 0: No operation. 1: Disable rising edge or level interrupt.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>IENF</name>
          <description>Pin interrupt active level or falling edge interrupt enable register</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>ENAF_PIN0</name>
              <description>Enables the falling edge or configures the active level interrupt for pin interrupt 0 (selected in PINTSEL0). 0: Disable falling edge interrupt or set active interrupt level LOW. 1: Enable falling edge interrupt enabled or set active interrupt level HIGH.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ENAF_PIN1</name>
              <description>Enables the falling edge or configures the active level interrupt for pin interrupt 1 (selected in PINTSEL1). 0: Disable falling edge interrupt or set active interrupt level LOW. 1: Enable falling edge interrupt enabled or set active interrupt level HIGH.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ENAF_PIN2</name>
              <description>Enables the falling edge or configures the active level interrupt for pin interrupt 2 (selected in PINTSEL2). 0: Disable falling edge interrupt or set active interrupt level LOW. 1: Enable falling edge interrupt enabled or set active interrupt level HIGH.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ENAF_PIN3</name>
              <description>Enables the falling edge or configures the active level interrupt for pin interrupt 3 (selected in PINTSEL3). 0: Disable falling edge interrupt or set active interrupt level LOW. 1: Enable falling edge interrupt enabled or set active interrupt level HIGH.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ENAF_PIN4</name>
              <description>Enables the falling edge or configures the active level interrupt for pin interrupt 4 (selected in PINTSEL4). [Note interrupt not supported to processor] 0: Disable falling edge interrupt or set active interrupt level LOW. 1: Enable falling edge interrupt enabled or set active interrupt level HIGH.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ENAF_PIN5</name>
              <description>Enables the falling edge or configures the active level interrupt for pin interrupt 5 (selected in PINTSEL5). [Note interrupt not supported to processor] 0: Disable falling edge interrupt or set active interrupt level LOW. 1: Enable falling edge interrupt enabled or set active interrupt level HIGH.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ENAF_PIN6</name>
              <description>Enables the falling edge or configures the active level interrupt for pin interrupt 6 (selected in PINTSEL6). [Note interrupt not supported to processor] 0: Disable falling edge interrupt or set active interrupt level LOW. 1: Enable falling edge interrupt enabled or set active interrupt level HIGH.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ENAF_PIN7</name>
              <description>Enables the falling edge or configures the active level interrupt for pin interrupt 7 (selected in PINTSEL7). [Note interrupt not supported to processor] 0: Disable falling edge interrupt or set active interrupt level LOW. 1: Enable falling edge interrupt enabled or set active interrupt level HIGH.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SIENF</name>
          <description>Pin interrupt active level or falling edge interrupt set register</description>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SETENAF_PIN0</name>
              <description>Ones written to this address set bits in the IENF, thus enabling interrupts. Bit 0 sets bit 0 in the IENF register. 0: No operation. 1: Select HIGH-active interrupt or enable falling edge interrupt.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>SETENAF_PIN1</name>
              <description>Ones written to this address set bits in the IENF, thus enabling interrupts. Bit 1 sets bit 1 in the IENF register. 0: No operation. 1: Select HIGH-active interrupt or enable falling edge interrupt.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>SETENAF_PIN2</name>
              <description>Ones written to this address set bits in the IENF, thus enabling interrupts. Bit 2 sets bit 2 in the IENF register. 0: No operation. 1: Select HIGH-active interrupt or enable falling edge interrupt.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>SETENAF_PIN3</name>
              <description>Ones written to this address set bits in the IENF, thus enabling interrupts. Bit 3 sets bit 3 in the IENF register. 0: No operation. 1: Select HIGH-active interrupt or enable falling edge interrupt.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>SETENAF_PIN4</name>
              <description>Ones written to this address set bits in the IENF, thus enabling interrupts. Bit 4 sets bit 4 in the IENF register. 0: No operation. 1: Select HIGH-active interrupt or enable falling edge interrupt.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>SETENAF_PIN5</name>
              <description>Ones written to this address set bits in the IENF, thus enabling interrupts. Bit 5 sets bit 5 in the IENF register. 0: No operation. 1: Select HIGH-active interrupt or enable falling edge interrupt.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>SETENAF_PIN6</name>
              <description>Ones written to this address set bits in the IENF, thus enabling interrupts. Bit 6 sets bit 6 in the IENF register. 0: No operation. 1: Select HIGH-active interrupt or enable falling edge interrupt.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>SETENAF_PIN7</name>
              <description>Ones written to this address set bits in the IENF, thus enabling interrupts. Bit 7 sets bit 7 in the IENF register. 0: No operation. 1: Select HIGH-active interrupt or enable falling edge interrupt.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CIENF</name>
          <description>Pin interrupt active level or falling edge interrupt clear register</description>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>CLRENAF_PIN0</name>
              <description>Ones written to this address clears bits in the IENF, thus disabling interrupts. Bit 0 clears bit 0 in the IENF register. 0: No operation. 1: LOW-active interrupt selected or falling edge interrupt disabled.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>CLRENAF_PIN1</name>
              <description>Ones written to this address clears bits in the IENF, thus disabling interrupts. Bit 1 clears bit 1 in the IENF register. 0: No operation. 1: LOW-active interrupt selected or falling edge interrupt disabled.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>CLRENAF_PIN2</name>
              <description>Ones written to this address clears bits in the IENF, thus disabling interrupts. Bit 2 clears bit 2 in the IENF register. 0: No operation. 1: LOW-active interrupt selected or falling edge interrupt disabled.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>CLRENAF_PIN3</name>
              <description>Ones written to this address clears bits in the IENF, thus disabling interrupts. Bit 3 clears bit 3 in the IENF register. 0: No operation. 1: LOW-active interrupt selected or falling edge interrupt disabled.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>CLRENAF_PIN4</name>
              <description>Ones written to this address clears bits in the IENF, thus disabling interrupts. Bit 4 clears bit 4 in the IENF register. 0: No operation. 1: LOW-active interrupt selected or falling edge interrupt disabled.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>CLRENAF_PIN5</name>
              <description>Ones written to this address clears bits in the IENF, thus disabling interrupts. Bit 5 clears bit 5 in the IENF register. 0: No operation. 1: LOW-active interrupt selected or falling edge interrupt disabled.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>CLRENAF_PIN6</name>
              <description>Ones written to this address clears bits in the IENF, thus disabling interrupts. Bit 6 clears bit 6 in the IENF register. 0: No operation. 1: LOW-active interrupt selected or falling edge interrupt disabled.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>CLRENAF_PIN7</name>
              <description>Ones written to this address clears bits in the IENF, thus disabling interrupts. Bit 7 clears bit 7 in the IENF register. 0: No operation. 1: LOW-active interrupt selected or falling edge interrupt disabled.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RISE</name>
          <description>Pin interrupt rising edge register</description>
          <addressOffset>0x1C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>RDET</name>
              <description>Rising edge detect. Bit n detects the rising edge of the pin selected in PINTSELn. Read 0: No rising edge has been detected on this pin since Reset or the last time a one was written to this bit. Write 0: no operation. Read 1: a rising edge has been detected since Reset or the last time a one was written to this bit. Write 1: clear rising edge detection for this pin.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>FALL</name>
          <description>Pin interrupt falling edge register</description>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>FDET</name>
              <description>Falling edge detect. Bit n detects the falling edge of the pin selected in PINTSELn. Read 0: No falling edge has been detected on this pin since Reset or the last time a one was written to this bit. Write 0: no operation. Read 1: a falling edge has been detected since Reset or the last time a one was written to this bit. Write 1: clear falling edge detection for this pin.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>IST</name>
          <description>Pin interrupt status register. For bits in this regsiter the following functionality occurs for the corresponding PIN bit: Read 0: interrupt is not being requested for this interrupt pin. Write 0: no operation. Read 1: interrupt is being requested for this interrupt pin. Write 1 (edge-sensitive): clear rising- and falling-edge detection for this pin. Write 1 (level-sensitive): switch the active level for this pin (in the IENF register).</description>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>PSTAT_PIN0</name>
              <description>Pin interrupt status. Bit 0 returns the status, clears the edge interrupt, or inverts the active level of the pin 0 (selected in PINTSEL0).</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PSTAT_PIN1</name>
              <description>Pin interrupt status. Bit 1 returns the status, clears the edge interrupt, or inverts the active level of the pin 1 (selected in PINTSEL0).</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PSTAT_PIN2</name>
              <description>Pin interrupt status. Bit 2 returns the status, clears the edge interrupt, or inverts the active level of the pin 2 (selected in PINTSEL2).</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PSTAT_PIN3</name>
              <description>Pin interrupt status. Bit 3 returns the status, clears the edge interrupt, or inverts the active level of the pin 3 (selected in PINTSEL3).</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PSTAT_PIN4</name>
              <description>Pin interrupt status. Bit 4 returns the status, clears the edge interrupt, or inverts the active level of the pin 4 (selected in PINTSEL4).</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PSTAT_PIN5</name>
              <description>Pin interrupt status. Bit 5 returns the status, clears the edge interrupt, or inverts the active level of the pin 5 (selected in PINTSEL5).</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PSTAT_PIN6</name>
              <description>Pin interrupt status. Bit 6 returns the status, clears the edge interrupt, or inverts the active level of the pin 6 (selected in PINTSEL6).</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PSTAT_PIN7</name>
              <description>Pin interrupt status. Bit 7 returns the status, clears the edge interrupt, or inverts the active level of the pin 7 (selected in PINTSEL7).</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PMCTRL</name>
          <description>Pattern match interrupt control register</description>
          <addressOffset>0x28</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0xFF000003</resetMask>
          <fields>
            <field>
              <name>SEL_PMATCH</name>
              <description>Specifies whether the 8 pin interrupts are controlled by the pin interrupt function or by the pattern match function. 0: Pin interrupt. Interrupts are driven in response to the standard pin interrupt function. 1: Pattern match. Interrupts are driven in response to pattern matches.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ENA_RXEV</name>
              <description>Enables the RXEV output to the CPU when the specified boolean expression evaluates to true. 0: Disabled. RXEV output to the CPU is disabled. 1: Enabled. RXEV output to the CPU is enabled.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PMAT</name>
              <description>This field displays the current state of pattern matches. A 1 in any bit of this field indicates that the corresponding product term is matched by the current state of the appropriate inputs.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PMSRC</name>
          <description>Pattern match interrupt bit-slice source register</description>
          <addressOffset>0x2C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0xFFFFFF00</resetMask>
          <fields>
            <field>
              <name>SRC0</name>
              <description>Selects the input source for bit slice 0. Value X selects the pin selected in the PINTSELX register as the source to this bit slice. For example 3 selects the pin selected in PINTSEL3 regsiter.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SRC1</name>
              <description>Selects the input source for bit slice 1. Value X selects the pin selected in the PINTSELX register as the source to this bit slice. For example 3 selects the pin selected in PINTSEL3 regsiter.</description>
              <bitOffset>11</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SRC2</name>
              <description>Selects the input source for bit slice 2. Value X selects the pin selected in the PINTSELX register as the source to this bit slice. For example 3 selects the pin selected in PINTSEL3 regsiter.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SRC3</name>
              <description>Selects the input source for bit slice 3. Value X selects the pin selected in the PINTSELX register as the source to this bit slice. For example 3 selects the pin selected in PINTSEL3 regsiter.</description>
              <bitOffset>17</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SRC4</name>
              <description>Selects the input source for bit slice 4. Value X selects the pin selected in the PINTSELX register as the source to this bit slice. For example 3 selects the pin selected in PINTSEL3 regsiter.</description>
              <bitOffset>20</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SRC5</name>
              <description>Selects the input source for bit slice 5. Value X selects the pin selected in the PINTSELX register as the source to this bit slice. For example 3 selects the pin selected in PINTSEL3 regsiter.</description>
              <bitOffset>23</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SRC6</name>
              <description>Selects the input source for bit slice 6. Value X selects the pin selected in the PINTSELX register as the source to this bit slice. For example 3 selects the pin selected in PINTSEL3 regsiter.</description>
              <bitOffset>26</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SRC7</name>
              <description>Selects the input source for bit slice 7. Value X selects the pin selected in the PINTSELX register as the source to this bit slice. For example 3 selects the pin selected in PINTSEL3 regsiter.</description>
              <bitOffset>29</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PMCFG</name>
          <description>Pattern match interrupt bit slice configuration register</description>
          <addressOffset>0x30</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0xFFFFFF7F</resetMask>
          <fields>
            <field>
              <name>PROD_ENDPTS0</name>
              <description>Determines whether slice 0 is an endpoint. 0: No effect. Slice 0 is not an endpoint. 1: endpoint. Slice 0 is the endpoint of a product term (minterm). Interrupt PINT0 in the NVIC is raised if the minterm evaluates as true.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PROD_ENDPTS1</name>
              <description>Determines whether slice 1 is an endpoint. 0: No effect. Slice 1 is not an endpoint. 1: endpoint. Slice 1 is the endpoint of a product term (minterm). Interrupt PINT1 in the NVIC is raised if the minterm evaluates as true.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PROD_ENDPTS2</name>
              <description>Determines whether slice 2 is an endpoint. 0: No effect. Slice 2 is not an endpoint. 1: endpoint. Slice 2 is the endpoint of a product term (minterm). Interrupt PINT2 in the NVIC is raised if the minterm evaluates as true.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PROD_ENDPTS3</name>
              <description>Determines whether slice 3 is an endpoint. 0: No effect. Slice 3 is not an endpoint. 1: endpoint. Slice 3 is the endpoint of a product term (minterm). Interrupt PINT3 in the NVIC is raised if the minterm evaluates as true.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PROD_ENDPTS4</name>
              <description>Determines whether slice 4 is an endpoint. 0: No effect. Slice 4 is not an endpoint. 1: endpoint. Slice 4 is the endpoint of a product term (minterm). No NVIC interrupt is assocaited with this.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PROD_ENDPTS5</name>
              <description>Determines whether slice 5 is an endpoint. 0 No effect. Slice 5 is not an endpoint. 1: endpoint. Slice 5 is the endpoint of a product term (minterm). No NVIC interrupt is assocaited with this.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PROD_ENDPTS6</name>
              <description>Determines whether slice 6 is an endpoint. 0: No effect. Slice 6 is not an endpoint. 1: endpoint. Slice 6 is the endpoint of a product term (minterm). No NVIC interrupt is assocaited with this.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CFG0</name>
              <description>Specifies the match contribution condition for bit slice 0. 0x0: Constant HIGH. This bit slice always contributes to a product term match. 0x1: Sticky rising edge. Match occurs if a rising edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared. This bit is only cleared when the PMCFG or the PMSRC registers are written to. 0x2: Sticky falling edge. Match occurs if a falling edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared. This bit is only cleared when the PMCFG or the PMSRC registers are written to. 0x3: Sticky rising or falling edge. Match occurs if either a rising or falling edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared. This bit is only cleared when the PMCFG or the PMSRC registers are written to. 0x4: High level. Match (for this bit slice) occurs when there is a high level on the input specified for this bit slice in the PMSRC register. 0x5: Low level. Match occurs when there is a low level on the specified input. 0x6: Constant 0. This bit slice never contributes to a match (should be used to disable any unused bit slices). 0x7: Event. Non-sticky rising or falling edge. Match occurs on an event - i.e. when either a rising or falling edge is first detected on the specified input (this is a non-sticky version of value 0x3). This bit is cleared after one clock cycle.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CFG1</name>
              <description>Specifies the match contribution condition for bit slice 1. See CFG0 for the modes available.</description>
              <bitOffset>11</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CFG2</name>
              <description>Specifies the match contribution condition for bit slice 2. See CFG0 for the modes available.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CFG3</name>
              <description>Specifies the match contribution condition for bit slice 3. See CFG0 for the modes available.</description>
              <bitOffset>17</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CFG4</name>
              <description>Specifies the match contribution condition for bit slice 4. See CFG0 for the modes available.</description>
              <bitOffset>20</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CFG5</name>
              <description>Specifies the match contribution condition for bit slice 5. See CFG0 for the modes available.</description>
              <bitOffset>23</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CFG6</name>
              <description>Specifies the match contribution condition for bit slice 6. See CFG0 for the modes available.</description>
              <bitOffset>26</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CFG7</name>
              <description>Specifies the match contribution condition for bit slice 7. See CFG0 for the modes available.</description>
              <bitOffset>29</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>GINT0</name>
      <description>This is the description of component gint It is an Global Interrupt with APB bus interface. More details will follow.</description>
      <groupName>GINT</groupName>
      <baseAddress>0x40011000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>0x44</size>
        <usage>registers</usage>
      </addressBlock>
      <interrupt>
        <name>GINT0</name>
        <value>2</value>
      </interrupt>
      <registers>
        <register>
          <name>CTRL</name>
          <description>GPIO Grouped interrupt control register</description>
          <addressOffset>0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0x7</resetMask>
          <fields>
            <field>
              <name>INT</name>
              <description>Group interrupt status. This bit is cleared by writing a one to it. Writing zero has no effect.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>COMB</name>
              <description>Combine enabled inputs for group interrupt. 0: Or, OR functionality: A grouped interrupt is generated when any one of the enabled inputs is active (based on its programmed polarity) 1: And, AND functionality: An interrupt is generated when all enabled bits are active (based on their programmed polarity)</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TRIG</name>
              <description>Group interrupt trigger. 0: Edge Triggered. 1: Level Triggered.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PORT_POL0</name>
          <description>GPIO Grouped Interrupt polarity register. Configure the pin polarity of each PIO signal into the group interrupt function. If a bit is low then the corresponding PIO has an active low contribution into the group interrupt. If a bit is high then the corresponding PIO has an active high contribution.</description>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xFFFFFFFF</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>POL</name>
              <description>Configure pin polarity of pin PIOn.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>22</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PORT_ENA0</name>
          <description>GPIO Grouped Interrupt port enable register. When a bit is set then the corresponding PIO is enabled for the group interrupt function.</description>
          <addressOffset>0x40</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ENA</name>
              <description>Enable pin PIOn for group interrupt.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>22</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>PMC</name>
      <description>This is the description of component pmc. It is the Power Management Unit Controller. More details will follow.</description>
      <groupName>PMC</groupName>
      <baseAddress>0x40012000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>0xD0</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>CTRL</name>
          <description>Power Management Control [Reset by POR, RSTN, WDT ]</description>
          <addressOffset>0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0x3BF</resetMask>
          <fields>
            <field>
              <name>LPMODE</name>
              <description>Power Mode Control. 00: Active; 01: Deep Sleep; 10: Power Down; 11: Deep Power Down.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SYSTEMRESETENABLE</name>
              <description>ARM system reset request enable. If set enables the ARM system reset to affect the system.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>WDTRESETENABLE</name>
              <description>Watchdog Timer reset enable. If set allow a watchdog timer reset event to affect the system.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>WAKUPRESETENABLE</name>
              <description>Wake-up I/Os reset enable. When set, the I/O power domain is not shutoff in deep powerdown mode.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>NTAGWAKUPRESETENABLE</name>
              <description>Wake-up NTAG reset enable. When set, the device can wake from deep power down by edge on NTAG FD signal, even if I/O power domain is off (see WAKUPRESETENABLE). Note that if I/O power domain is ON, wake-up by NTAG FD is enabled by default thus content of this bit does not care. Do not set unless entering Deep Power Down.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SELLDOVOLTAGE</name>
              <description>0 = all LDOs current output levels are determined by their associated VADJ bitfield. 1 = all LDOs current output levels are determined by their associated VADJ_2 bitfield.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SWRRESETENABLE</name>
              <description>Software reset enable. If set enables the software reset to affect the system.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DCDC0</name>
          <description>DCDC control register (1st). This reigster is controlled by the boot code and the Low power API software. [Reset by all reset sources, except ARM SystemReset]</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x4B67D</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DCDC0</name>
              <description>DCDC control register (1st). This reigster is controlled by the boot code and the Low power API software. [Reset by all reset sources, except ARM SystemReset]</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DCDC1</name>
          <description>DCDC control register (2nd). This reigster is controlled by the boot code and the Low power API software. [Reset by all reset sources, except ARM SystemReset]</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x3C0647C</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DCDC1</name>
              <description>DCDC control register (2nd). This reigster is controlled by the boot code and the Low power API software. [Reset by all reset sources, except ARM SystemReset]</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>BIAS</name>
          <description>Bias current source control register. This reigster is controlled by the boot code and the Low power API software. [Reset by POR, RSTN, WDT ]</description>
          <addressOffset>0xC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x20F48</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BIAS</name>
              <description>Bias current source control register. This reigster is controlled by the boot code and the Low power API software. [Reset by POR, RSTN, WDT ]</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>LDOPMU</name>
          <description>PMU &amp; Always On domains LDO control. This reigster is controlled by the boot code and the Low power API software. [Reset by all reset sources, except ARM SystemReset]</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x3846E0B8</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>LDOPMU</name>
              <description>PMU &amp; Always On domains LDO control. This reigster is controlled by the boot code and the Low power API software. [Reset by all reset sources, except ARM SystemReset]</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>LDOMEM</name>
          <description>Memories LDO control register. This reigster is controlled by the boot code and the Low power API software. [Reset by all reset sources, except ARM SystemReset]</description>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xC673318</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>LDOMEM</name>
              <description>Memories LDO control register. This reigster is controlled by the boot code and the Low power API software. [Reset by all reset sources, except ARM SystemReset]</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>LDOCORE</name>
          <description>Digital Core LDO control register. This reigster is controlled by the boot code and the Low power API software. [Reset by all reset sources, except ARM SystemReset]</description>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x5E2D</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>LDOCORE</name>
              <description>Digital Core LDO control register. This reigster is controlled by the boot code and the Low power API software. [Reset by all reset sources, except ARM SystemReset]</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>LDOFLASHNV</name>
          <description>Flash LDO control register. This reigster is controlled by the boot code and the Low power API software. [Reset by all reset sources, except ARM SystemReset]</description>
          <addressOffset>0x1C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x2CC05</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>LDOFLASHNV</name>
              <description>Flash LDO control register. This reigster is controlled by the boot code and the Low power API software. [Reset by all reset sources, except ARM SystemReset]</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>LDOFLASHCORE</name>
          <description>Flash Core LDO control register. This reigster is controlled by the boot code and the Low power API software. [Reset by all reset sources, except ARM SystemReset]</description>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xBC6</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>LDOFLASHCORE</name>
              <description>Flash Core LDO control register. This reigster is controlled by the boot code and the Low power API software. [Reset by all reset sources, except ARM SystemReset]</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>LDOADC</name>
          <description>General Purpose ADC LDO control register This reigster is controlled by the boot code and the Low power API software. [Reset by all reset sources, except ARM SystemReset]</description>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xBC5</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>LDOADC</name>
              <description>General Purpose ADC LDO control register This reigster is controlled by the boot code and the Low power API software. [Reset by all reset sources, except ARM SystemReset]</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>BODVBAT</name>
          <description>VBAT Brown Out Dectector control register This reigster is controlled by the boot code and the Low power API software. [Reset by POR, RSTN, WDT ]</description>
          <addressOffset>0x30</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x69</resetValue>
          <resetMask>0x7F</resetMask>
          <fields>
            <field>
              <name>TRIGLVL</name>
              <description>BOD trigger level</description>
              <bitOffset>0</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>HYST</name>
              <description>BOD Hysteresis control</description>
              <bitOffset>5</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>FRO192M</name>
          <description>High Speed FRO control register This reigster is controlled by the boot code and the Low power API software. [Reset by POR, RSTN, WDT ]</description>
          <addressOffset>0x40</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x780820</resetValue>
          <resetMask>0x7FFFFFF</resetMask>
          <fields>
            <field>
              <name>DIVSEL</name>
              <description>Mode of operation (which clock to output). Each bit enables a clocks as shown. Enables are additive meaning that two or more clocks can be enabled together. xxxx1: 12MHz enabled; xxx1x: 32MHz enabled; xx1xx: 48MHz enabled; x1xxx: Not applicable; 1xxxx: Not applicable.</description>
              <bitOffset>20</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>FRO1M</name>
          <description>1 MHz Free Running Oscillator control register. [Reset by all reset sources, except ARM SystemReset]</description>
          <addressOffset>0x44</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x42</resetValue>
          <resetMask>0x3FFF</resetMask>
          <fields>
            <field>
              <name>FREQSEL</name>
              <description>Frequency trimming bits. This field is used to give accurate frequency for each device. The required setting is based upon calibration data sotred in flash during device test. This setting is applied by the clock driver function.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>7</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ATBCTRL</name>
              <description>Debug control bits to set the analog/digital test modes; only required for test purposes.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DIVSEL</name>
              <description>Divider selection bits.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ANAMUXCOMP</name>
          <description>Analog Comparator and Analog Mux control register. [Reset by all reset sources, except ARM SystemReset]</description>
          <addressOffset>0x50</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xA</resetValue>
          <resetMask>0x1E</resetMask>
          <fields>
            <field>
              <name>COMP_HYST</name>
              <description>Hysteris enabled in comparator when hyst = '1', no hysteresis when = '0'.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>COMP_INNINT</name>
              <description>Voltage reference inn_int input is selected for _n comparator input when sel_inn_int = 1 . This setting also requires PMU_BIASING to be active. Also flash biasing and DCDC converter needs to be enabled. If this setting = '0' then _n input comes from device pins, based on COMP_INPUTSWAP setting.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>COMP_LOWPOWER</name>
              <description>Comparator Low power mode enabled when set.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>COMP_INPUTSWAP</name>
              <description>Input swap is enabled when set. Comparator{ _p, _n} ports are connected to {ACM, ACP}. Otherwsie normal configuration occurs, {_p, _n} is connected to {ACP, ACM} .</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PWRSWACK</name>
          <description>Power Switch acknowledge. [Reset by all reset sources, except ARM SystemReset]</description>
          <addressOffset>0x60</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0xE</resetValue>
          <resetMask>0xE</resetMask>
          <fields>
            <field>
              <name>PDCOMM0</name>
              <description>Comm0 (USART0, I2C0, SPI0) Power Domain power switch status.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PDSYSTEM</name>
              <description>System Power Domain power switch status.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PDMCURETENTION</name>
              <description>MCU Retention Power Domain power switch status.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DPDWKSRC</name>
          <description>Power Down and Deep Power Down wake-up source. [Reset by POR, RSTN, WDT ]</description>
          <addressOffset>0x64</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0x7FFFFF</resetMask>
          <fields>
            <field>
              <name>PIO0</name>
              <description>Enable / disable wakeup from Power down and Deep Power Down modes by GPIO0: 0: Disable; 1: Enable.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PIO1</name>
              <description>Enable / disable wakeup from Power down and Deep Power Down modes by GPIO1: 0: Disable; 1: Enable.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PIO2</name>
              <description>Enable / disable wakeup from Power down and Deep Power Down modes by GPIO2: 0: Disable; 1: Enable.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PIO3</name>
              <description>Enable / disable wakeup from Power down and Deep Power Down modes by GPIO3: 0: Disable; 1: Enable.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PIO4</name>
              <description>Enable / disable wakeup from Power down and Deep Power Down modes by GPIO4: 0: Disable; 1: Enable.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PIO5</name>
              <description>Enable / disable wakeup from Power down and Deep Power Down modes by GPIO5: 0: Disable; 1: Enable.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PIO6</name>
              <description>Enable / disable wakeup from Power down and Deep Power Down modes by GPIO6: 0: Disable; 1: Enable.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PIO7</name>
              <description>Enable / disable wakeup from Power down and Deep Power Down modes by GPIO7: 0: Disable; 1: Enable.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PIO8</name>
              <description>Enable / disable wakeup from Power down and Deep Power Down modes by GPIO8: 0: Disable; 1: Enable.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PIO9</name>
              <description>Enable / disable wakeup from Power down and Deep Power Down modes by GPIO9: 0: Disable; 1: Enable.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PIO10</name>
              <description>Enable / disable wakeup from Power down and Deep Power Down modes by GPIO10: 0: Disable; 1: Enable.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PIO11</name>
              <description>Enable / disable wakeup from Power down and Deep Power Down modes by GPIO11: 0: Disable; 1: Enable.</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PIO12</name>
              <description>Enable / disable wakeup from Power down and Deep Power Down modes by GPIO12: 0: Disable; 1: Enable.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PIO13</name>
              <description>Enable / disable wakeup from Power down and Deep Power Down modes by GPIO13: 0: Disable; 1: Enable.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PIO14</name>
              <description>Enable / disable wakeup from Power down and Deep Power Down modes by GPIO14: 0: Disable; 1: Enable.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PIO15</name>
              <description>Enable / disable wakeup from Power down and Deep Power Down modes by GPIO15: 0: Disable; 1: Enable.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PIO16</name>
              <description>Enable / disable wakeup from Power down and Deep Power Down modes by GPIO16: 0: Disable; 1: Enable.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PIO17</name>
              <description>Enable / disable wakeup from Power down and Deep Power Down modes by GPIO17: 0: Disable; 1: Enable.</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PIO18</name>
              <description>Enable / disable wakeup from Power down and Deep Power Down modes by GPIO18: 0: Disable; 1: Enable.</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PIO19</name>
              <description>Enable / disable wakeup from Power down and Deep Power Down modes by GPIO19: 0: Disable; 1: Enable.</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PIO20</name>
              <description>Enable / disable wakeup from Power down and Deep Power Down modes by GPIO20: 0: Disable; 1: Enable.</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PIO21</name>
              <description>Enable / disable wakeup from Power down and Deep Power Down modes by GPIO21: 0: Disable; 1: Enable.</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>NTAG_FD</name>
              <description>Enable / disable wakeup from Power down and Deep Power Down modes by NTAG_FD: 0: Disable; 1: Enable.</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>STATUSPWR</name>
          <description>Power OK and Ready signals from various analog modules (DCDC, LDO, ). [Reset by all reset sources, except ARM SystemReset]</description>
          <addressOffset>0x68</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x1D</resetValue>
          <resetMask>0x3F</resetMask>
          <fields>
            <field>
              <name>DCDCPWROK</name>
              <description>DCDC converter power OK</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>DCDCVXCTRLMON</name>
              <description>Picture of the DCDC output state.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>LDOCOREPWROK</name>
              <description>CORE LDO power OK. Max switch on time 2us.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>LDOFLASHNVPWROK</name>
              <description>Flash NV LDO power OK Max switch on time 20us.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>LDOFLASHCOREPWROK</name>
              <description>Flash Core LDO power OK Max switch on time should be considered as 10us.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>LDOADC1V1PWROK</name>
              <description>General Purpose ADC LDO power OK. Max switch on time is 8us.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>STATUSCLK</name>
          <description>FRO and XTAL status register. [Reset by all reset sources, except ARM SystemReset]</description>
          <addressOffset>0x6C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x5</resetValue>
          <resetMask>0x7</resetMask>
          <fields>
            <field>
              <name>FRO192MCLKVALID</name>
              <description>High Speed FRO (FRO 192 MHz) clock valid signal. The FRO192M clock generator also generates the FRO12M, FRO32M and FRO48M clock signals. These will also be valid when this flag is assertetd.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>XTAL32KOK</name>
              <description>XTAL oscillator 32KHz OK signal. When the XTAL is stable, then a transition from 1 to 0 will indicate a clock issue. Can not be used to identify a stable clock during XTAL start.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>FRO1MCLKVALID</name>
              <description>FRO 1 MHz CCO voltage detector output.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RESETCAUSE</name>
          <description>Reset Cause register. [Reset by POR]</description>
          <addressOffset>0x70</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x1</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>POR</name>
              <description>1 : The last chip reset was caused by a Power On Reset. Write '1' to clear this bit.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PADRESET</name>
              <description>1 : The last chip reset was caused by a Pad Reset. Write '1' to clear this bit.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>BODRESET</name>
              <description>1 : The last chip reset was caused by a Brown Out Detector. Write '1' to clear this bit.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SYSTEMRESET</name>
              <description>1 : The last chip reset was caused by a System Reset requested by the ARM CPU. Write '1' to clear this bit.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>WDTRESET</name>
              <description>1 : The last chip reset was caused by the Watchdog Timer. Write '1' to clear this bit.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>WAKEUPIORESET</name>
              <description>1 : The last chip reset was caused by a Wake-up I/O (GPIO or internal NTAG FD INT). Write '1' to clear this bit.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>WAKEUPPWDNRESET</name>
              <description>1 : The last CPU reset was caused by a Wake-up from Power down (many sources possible: timer, IO, ...). Write '1' to clear this bit. Check NVIC register if not waken-up by IO (NVIC_GetPendingIRQ).</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SWRRESET</name>
              <description>1 : The last chip reset was caused by a Software. Write '1' to clear this bit.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>AOREG0</name>
          <description>General purpose always on domain data storage. [Reset by all reset sources, except ARM SystemReset]</description>
          <addressOffset>0x80</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DATA31_0</name>
              <description>General purpose always on domain data storage. Only writable 1 time after any chip reset. After the 1st write, any further writes are blocked. After any chip reset the write block is disabled until after next write. The chip reset includes POR, RSTIN, WDT reset, SW reset and WAKEUP IO reset.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>AOREG1</name>
          <description>General purpose always on domain data storage. [Reset by POR, RSTN]</description>
          <addressOffset>0x84</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DATA31_0</name>
              <description>Reserved for use by NXP system software. General purpose always on domain data storage. Only reinitialized on Power On Reset and RSTIN Pin reset.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>AOREG2</name>
          <description>General purpose always on domain data storage. [Reset by POR, RSTN]</description>
          <addressOffset>0x88</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DATA31_0</name>
              <description>General purpose always on domain data storage. Only reinitialized on Power On Reset and RSTIN Pin reset.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DPDCTRL</name>
          <description>Configuration parameters for Power Down and Deep Power Down mode. [Reset by POR, RSTN, WDT ]</description>
          <addressOffset>0x98</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0x7</resetMask>
          <fields>
            <field>
              <name>XTAL32MSTARTENA</name>
              <description>Enable XTAL32MHz automatic start-up at power up &amp; wake up from power down or deep power down. Reset value is set by eFuse content. This register field will overwrite option selected by eFuse content only if power-up or wake-up is NOT triggered by any kind of reset. Thus if power-up or wake-up is triggered by I/O or a timer. On the contrary, if power-up or wake-up is triggered by POR (typically during initial power up) or watchdog reset or SW reset or PAD RSTN then eFuse content will reset this register and will be applied. Take care that option selected here can by masked in power down by a register of SYSCON - XTAL32MCTRL - which is itself reset after each deep power down. Thus SYSCON/XTAL32MCTRL will not have any impact after a deep power down, only after a power down.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>XTAL32MSTARTDLY</name>
              <description>Delay between xtal ldo enable and release of reset to xtal 0:16us 1:32us 2:48us 3:64us. LSB reset value set by efuse (wake-up by I/O only). This delay is applied within PMC for Efuse controlled XTAL start and also BLE link layer for BLE controlled auto-start.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PIOPORCAP</name>
          <description>The PIOPORCAP register captures the state of GPIO at power-on-reset or pin reset. Each bit represents the power-on reset state of one GPIO pin. [Reset by POR, RSTN]</description>
          <addressOffset>0x9C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x400000</resetValue>
          <resetMask>0x7FFFFF</resetMask>
          <fields>
            <field>
              <name>GPIO</name>
              <description>Capture of GPIO values at power-on-reset and pin reset.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>22</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>NTAG_FD</name>
              <description>Capture of NTAG_FD value at power-on-reset and pin reset.</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PIORESCAP</name>
          <description>The PIORESCAP0 register captures the state of GPIO port 0 when a reset other than a power-on reset or pin reset occurs. Each bit represents the reset state of one GPIO pin. [Reset by WDT, BOD, WAKEUP IO, ARM System reset ]</description>
          <addressOffset>0xA0</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x61FF39</resetValue>
          <resetMask>0x7FFFFF</resetMask>
          <fields>
            <field>
              <name>GPIO</name>
              <description>Capture of GPIO values.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>22</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>NTAG_FD</name>
              <description>Capture of NTAG_FD value.</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PDSLEEPCFG</name>
          <description>Controls the power to various modules in Low Power modes. [Reset by all reset sources, except ARM SystemReset]</description>
          <addressOffset>0xB0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xC0</resetValue>
          <resetMask>0x3FFDFF</resetMask>
          <fields>
            <field>
              <name>PDEN_DCDC</name>
              <description>Controls DCDC power in Power down and Deep Power down modes. Automatically switched off in deep power down. 0: DCDC is disabled in Power down and Deep Power down modes; 1: DCDC is enabled in Power down and Deep Power down modes.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PDEN_BIAS</name>
              <description>Controls Bias power in Power down and Deep Power down modes. 0: Bias is disabled in Power down and Deep Power down modes; 1: Bias is enabled in Power down and Deep Power down modes.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PDEN_LDO_MEM</name>
              <description>Controls LDO memories power in Power down mode. Automatically switched off in deep power down 0: LDO is disabled in Power down mode; 1: LDO is enabled in Power down mode.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PDEN_VBAT_BOD</name>
              <description>Controls VBAT BOD power in Power down and Deep Power down modes. 0: VBAT BOD is disabled in Power down and Deep Power down modes; 1: VBAT BOD is enabled in Power down and Deep Power down modes.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PDEN_FRO192M</name>
              <description>Controls FRO192M power in Deep Sleep, Power down and Deep Power down modes. This should be disabled before entering power down or deep power down mode. 0: FRO192M is disabled; 1: FRO192M is enabled.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PDEN_FRO1M</name>
              <description>Controls FRO1M power in Deep Sleep, Power down and Deep Power down modes. This should be disabled before entering power down (unless needed for low power timers) or deep power down mode. 0: FRO1M is disabled; 1: FRO1M is enabled.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PDEN_PD_FLASH</name>
              <description>Enable Flash power domain Power Down mode (power shutoff) when entering in DeepSleep. In PowerDown modes this domain is automatically powered off.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PDEN_PD_COMM0</name>
              <description>Enable Comm0 power domain (USART0, I2C0, SPI0) Power Down mode when entering in Powerdown mode. In Deep power down it is disabled by hardware. In deep sleep it is always enabled.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EN_PDMCU_RETENTION</name>
              <description>Enable MCU Power Domain state retention when entering in 'Powerdown' mode for modem and radio cal values</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PDEN_PD_MEM0</name>
              <description>Enable Power Down mode of SRAM 0 when entering in Powerdown mode. Automatically switched off in deep power down.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PDEN_PD_MEM1</name>
              <description>Enable Power Down mode of SRAM 1 when entering in Powerdown mode. Automatically switched off in deep power down.</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PDEN_PD_MEM2</name>
              <description>Enable Power Down mode of SRAM 2 when entering in Powerdown mode. Automatically switched off in deep power down.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PDEN_PD_MEM3</name>
              <description>Enable Power Down mode of SRAM 3 when entering in Powerdown mode. Automatically switched off in deep power down.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PDEN_PD_MEM4</name>
              <description>Enable Power Down mode of SRAM 4 when entering in Powerdown mode. Automatically switched off in deep power down.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PDEN_PD_MEM5</name>
              <description>Enable Power Down mode of SRAM 5 when entering in Powerdown mode. Automatically switched off in deep power down</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PDEN_PD_MEM6</name>
              <description>Enable Power Down mode of SRAM 6 when entering in Powerdown mode. Automatically switched off in deep power down</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PDEN_PD_MEM7</name>
              <description>Enable Power Down mode of SRAM 7 when entering in Powerdown mode. Automatically switched off in deep power down</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PDEN_PD_MEM8</name>
              <description>Enable Power Down mode of SRAM 8 when entering in Powerdown mode. Automatically switched off in deep power down</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PDEN_PD_MEM9</name>
              <description>Enable Power Down mode of SRAM 9 when entering in Powerdown mode. Automatically switched off in deep power down</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PDEN_PD_MEM10</name>
              <description>Enable Power Down mode of SRAM 10 when entering in Powerdown mode. Automatically switched off in deep power down</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PDEN_PD_MEM11</name>
              <description>Enable Power Down mode of SRAM 11 when entering in Powerdown mode. Automatically switched off in deep power down</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PDRUNCFG</name>
          <description>Controls the power to various analog blocks. [Reset by all reset sources, except ARM SystemReset]</description>
          <addressOffset>0xB8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0xFC00000</resetMask>
          <fields>
            <field>
              <name>ENA_LDO_ADC</name>
              <description>LDO ADC enabled. See STATUSPWR.LDOADC1V1PWROK for when the power domain is ready.</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ENA_BOD_MEM</name>
              <description>BOD MEM enabled.</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ENA_BOD_CORE</name>
              <description>BOD CORE enabled.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ENA_FRO32K</name>
              <description>FRO32K enabled.</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ENA_XTAL32K</name>
              <description>XTAL32K enabled.</description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ENA_ANA_COMP</name>
              <description>Analog Comparator enabled.</description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>WAKEIOCAUSE</name>
          <description>Wake-up source from Power Down and Deep Power Down modes. Allow to identify the Wake-up source from Power-Down mode or Deep Power Down mode.[Reset by POR, RSTN, WDT ]</description>
          <addressOffset>0xBC</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0</resetValue>
          <resetMask>0x7FFFFF</resetMask>
          <fields>
            <field>
              <name>GPIO00</name>
              <description>Wake up was triggered by GPIO 00</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>GPIO01</name>
              <description>Wake up was triggered by GPIO 01</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>GPIO02</name>
              <description>Wake up was triggered by GPIO 02</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>GPIO03</name>
              <description>Wake up was triggered by GPIO 03</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>GPIO04</name>
              <description>Wake up was triggered by GPIO 04</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>GPIO05</name>
              <description>Wake up was triggered by GPIO 05</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>GPIO06</name>
              <description>Wake up was triggered by GPIO 06</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>GPIO07</name>
              <description>Wake up was triggered by GPIO 07</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>GPIO08</name>
              <description>Wake up was triggered by GPIO 08</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>GPIO09</name>
              <description>Wake up was triggered by GPIO 09</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>GPIO10</name>
              <description>Wake up was triggered by GPIO 10</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>GPIO11</name>
              <description>Wake up was triggered by GPIO 11</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>GPIO12</name>
              <description>Wake up was triggered by GPIO 12</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>GPIO13</name>
              <description>Wake up was triggered by GPIO 13</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>GPIO14</name>
              <description>Wake up was triggered by GPIO 14</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>GPIO15</name>
              <description>Wake up was triggered by GPIO 15</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>GPIO16</name>
              <description>Wake up was triggered by GPIO 16</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>GPIO17</name>
              <description>Wake up was triggered by GPIO 17</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>GPIO18</name>
              <description>Wake up was triggered by GPIO 18</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>GPIO19</name>
              <description>Wake up was triggered by GPIO 19</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>GPIO20</name>
              <description>Wake up was triggered by GPIO 20</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>GPIO21</name>
              <description>Wake up was triggered by GPIO 21</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>NTAG_FD</name>
              <description>Wake up was triggered by NTAG FD</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CTRLNORST</name>
          <description>Extension of CTRL register, but never reset except by POR</description>
          <addressOffset>0xCC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0x7</resetMask>
          <fields>
            <field>
              <name>FASTLDOENABLE</name>
              <description>Fast LDO wake-up enable. 3 bits for the different wake-up sources: {generic async wake up event as selected by SLEEPCON/STARTER0&amp;1, IO wake-up event, RSTN pad event}. If required, this field should only be managed by the Low power driver software.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>ASYNC_SYSCON</name>
      <description>This is the description of component async_syscon</description>
      <groupName>ASYNC_SYSCON</groupName>
      <baseAddress>0x40020000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>0xD0</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>ASYNCPRESETCTRL</name>
          <description>Asynchronous peripherals reset control. The ASYNCPRESETCTRL register allows software to reset specific peripherals attached to the async APB bridge. Writing a zero to any assigned bit in this register clears the reset and allows the specified peripheral to operate. Writing a one asserts the reset.</description>
          <addressOffset>0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0x6</resetMask>
          <fields>
            <field>
              <name>CT32B0</name>
              <description>Controls the reset for Counter/Timer CT32B0</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>CLEAR</name>
                  <description>Clear reset to Counter/Timer CT32B0.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ASSERT</name>
                  <description>Assert reset to Counter/Timer CT32B0.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CT32B1</name>
              <description>Controls the reset for Counter/Timer CT32B1</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>CLEAR</name>
                  <description>Clear reset to Counter/Timer CT32B1.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ASSERT</name>
                  <description>Assert reset to Counter/Timer CT32B1.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>ASYNCPRESETCTRLSET</name>
          <description>Set bits in ASYNCPRESETCTRL. Writing ones to this register sets the corresponding bit or bits in the ASYNCPRESETCTRL register, if they are implemented</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>CT32B0</name>
              <description>Writing 1 to this register sets the bit ASYNCPRESETCTRL.CT32B0</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_EFFECT</name>
                  <description>No effect.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SET</name>
                  <description>Set the bit ASYNCPRESETCTRL.CT32B0.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CT32B1</name>
              <description>Writing 1 to this register sets the bit ASYNCPRESETCTRL.CT32B1</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_EFFECT</name>
                  <description>No effect.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SET</name>
                  <description>Set the bit ASYNCPRESETCTRL.CT32B1.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>ASYNCPRESETCTRLCLR</name>
          <description>Clear bits in ASYNCPRESETCTRL. Writing ones to this register clears the corresponding bit or bits in the ASYNCPRESETCTRL register, if they are implemented</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>CT32B0</name>
              <description>Writing 1 to this register clears the bit ASYNCPRESETCTRL.CT32B0</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_EFFECT</name>
                  <description>No effect.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CLEAR</name>
                  <description>Clear the bit ASYNCPRESETCTRL.CT32B0.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CT32B1</name>
              <description>Writing 1 to this register clears the bit ASYNCPRESETCTRL.CT32B1</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_EFFECT</name>
                  <description>No effect.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CLEAR</name>
                  <description>Clear the bit ASYNCPRESETCTRL.CT32B1.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>ASYNCAPBCLKCTRL</name>
          <description>Asynchronous peripherals clock control. This register controls how the clock selected for the asynchronous APB peripherals is divided to provide the clock to the asynchronous peripherals</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0x6</resetMask>
          <fields>
            <field>
              <name>CT32B0</name>
              <description>Controls the clock for Counter/Timer CT32B0</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DISABLE</name>
                  <description>Disable clock to Counter/Timer CT32B0.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENABLE</name>
                  <description>Enable clock to Counter/Timer CT32B0.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CT32B1</name>
              <description>Controls the clock for Counter/Timer CT32B1</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DISABLE</name>
                  <description>Disable clock to Counter/Timer CT32B1.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENABLE</name>
                  <description>Enable clock to Counter/Timer CT32B1.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>ASYNCAPBCLKCTRLSET</name>
          <description>Set bits in ASYNCAPBCLKCTRL. Writing ones to this register sets the corresponding bit or bits in the ASYNCAPBCLKCTRLSET register, if they are implemented</description>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>CT32B0</name>
              <description>Writing 1 to this register sets the bit ASYNCAPBCLKCTRL.CT32B0</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_EFFECT</name>
                  <description>No effect.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SET</name>
                  <description>Set the bit ASYNCAPBCLKCTRL.CT32B0.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CT32B1</name>
              <description>Writing 1 to this register sets the bit ASYNCAPBCLKCTRL.CT32B1</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_EFFECT</name>
                  <description>No effect.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SET</name>
                  <description>Set the bit ASYNCAPBCLKCTRL.CT32B1.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>ASYNCAPBCLKCTRLCLR</name>
          <description>Clear bits in ASYNCAPBCLKCTRL. Writing ones to this register sets the corresponding bit or bits in the ASYNCAPBCLKCTRLSET register, if they are implemented</description>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>CT32B0</name>
              <description>Writing 1 to this register clears the bit ASYNCAPBCLKCTRL.CT32B0</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_EFFECT</name>
                  <description>No effect.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CLEAR</name>
                  <description>Clear the ASYNCAPBCLKCTRL.CT32B0.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CT32B1</name>
              <description>Writing 1 to this register clears the bit ASYNCAPBCLKCTRL.CT32B1</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_EFFECT</name>
                  <description>No effect.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CLEAR</name>
                  <description>Clear the bit ASYNCAPBCLKCTRL.CT32B1.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>ASYNCAPBCLKSELA</name>
          <description>Asynchronous APB clock source select</description>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0x3</resetMask>
          <fields>
            <field>
              <name>SEL</name>
              <description>Clock source for modules beyond asynchronous Bus bridge: ASYNC_SYSCON itself, timers 0/1.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>MAINCLK</name>
                  <description>System Bus clock.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>XTAL32M</name>
                  <description>32 MHz crystal oscillator (XTAL32M).</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>FRO32M</name>
                  <description>32 MHz free running oscillator (FRO32M).</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>FRO48M</name>
                  <description>48 MHz free running oscillator (FRO48M).</description>
                  <value>0x3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>TEMPSENSORCTRL</name>
          <description>Temperature Sensor controls</description>
          <addressOffset>0xA0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0xF</resetMask>
          <fields>
            <field>
              <name>ENABLE</name>
              <description>Temperature sensor enable</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CM</name>
              <description>Temerature sensor common mode output voltage selection: 0x0: high negative offset added; 0x1: intermediate negative offset added; 0x2: no offset added; 0x3: low positive offset added. Only setting 0x2 should be used.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>NFCTAGPADSCTRL</name>
          <description>NFC Tag pads control for I2C interface to internal NFC Tag (T parts only): I2C interface + 1 interrupt/ field detect input pad + NTAG VDD output pad</description>
          <addressOffset>0xA4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x66F3333</resetValue>
          <resetMask>0x1FFFFFFF</resetMask>
          <fields>
            <field>
              <name>I2C_SDA_EPD</name>
              <description>I2C_SDA, Enable weak pull down on IO pad. 0= disabled. 1=pull down enabled.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_SDA_EPUN</name>
              <description>I2C_SDA, Enable weak pull up on IO pad, active low. 0=pullup enabled. 1=pullup disabled</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_SDA_EHS0</name>
              <description>I2C_SDA IO Driver slew rate LSB. (I2C_SDA_EHS1, I2C_SDA_EHS0). RESERVED: use default value (0)</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_SDA_INVERT</name>
              <description>I2C_SDA Input polarity. 0 : Input function is not inverted. 1 : Input function is inverted.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_SDA_ENZI</name>
              <description>I2C_SDA Receiver enable, active high</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_SDA_FILTEROFF</name>
              <description>I2C_SDA input glitch filter control. 0 Filter enabled. Short noise pulses are filtered out. 1 Filter disabled. No input filtering is done.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_SDA_EHS1</name>
              <description>I2C_SDA IO Driver slew rate MSB. (I2C_SDA_EHS1, I2C_SDA_EHS0). RESERVED: use default value (0)</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_SDA_OD</name>
              <description>I2C_SDA, Controls open-drain mode. 0 Normal. Normal push-pull output 1 Open-drain. Simulated open-drain output (high drive disabled).</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_SCL_EPD</name>
              <description>I2C_SCL, Enable weak pull down on IO pad. 0: disabled; 1: pull down enabled.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_SCL_EPUN</name>
              <description>I2C_SCL, Enable weak pull up on IO pad, active low. 0: pullup enabled; 1: pullup disabled.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_SCL_EHS0</name>
              <description>I2C_SCL IO Driver slew rate LSB. (I2C_SCL_EHS1, I2C_SCL_EHS0). RESERVED: use default value (0)</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_SCL_ENZI</name>
              <description>I2C_SCL Receiver enable, active high</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_SCL_FILTEROFF</name>
              <description>I2C_SCL, input glitch filter control: 0: Filter enabled. Short noise pulses are filtered out; 1: Filter disabled. No input filtering is done.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_SCL_EHS1</name>
              <description>I2C_SCL IO Driver slew rate MSB. (I2C_SCL_EHS1, I2C_SCL_EHS0). RESERVED: use default value (0)</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_SCL_OD</name>
              <description>I2C_SCL open-drain mode control: 0: Normal. Normal push-pull output; 1: Open-drain. Simulated open-drain output (high drive disabled).</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>INT_INVERT</name>
              <description>NTAG INT/FD Input polarity: 0: Input function is not inverted; 1: Input function is inverted.</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>INT_ENZI</name>
              <description>Reserved. NTAG INT/FD IO cell always enabled, not configurable</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>INT_FILTEROFF</name>
              <description>Reserved. NTAG INT/FD IO cell always filters signal, not configurable</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>VDD_EPD</name>
              <description>NTAG VDD, Enable weak pull down on IO pad</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>VDD_EPUN</name>
              <description>NTAG_VDD, Enable weak pull up on IO pad, active low</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>VDD_EHS0</name>
              <description>NTAG VDD IO Driver slew rate LSB. (VDD_EHS1, VDD_EHS0) sets IO cell speed when enabled as an output. 00=Low speed, 01=nominal speed, 10=fast speed, 11=high speed. Recommendation is to use default value (0)</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>VDD_EHS1</name>
              <description>NTAG VDD IO Driver slew rate MSB. (VDD_EHS1, VDD_EHS0) sets IO cell speed when enabled as an output. 00: Low speed; 01: nominal speed; 10: fast speed; 11: high speed. Recommendation is to use default value (0)</description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>VDD_OD</name>
              <description>NTAG VDD open-drain mode control: 0: Normal. Normal push-pull output; 1: Open-drain. Simulated open-drain output (high drive disabled).</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>XTAL32MLDOCTRL</name>
          <description>XTAL 32 MHz LDO control register. If XTAL has been auto started due to EFUSE XTAL32MSTART_ENA or BLE low power timers then the effect of these need disabling via SYSCON.XTAL32MCTRL before the full control by this register is possible.</description>
          <addressOffset>0xA8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xA8</resetValue>
          <resetMask>0x3FF</resetMask>
          <fields>
            <field>
              <name>ENABLE</name>
              <description>Enable the LDO when set. Setting managed by software API.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>VOUT</name>
              <description>Adjust the output voltage level, setting managed by software API.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>IBIAS</name>
              <description>Adjust the biasing current, setting managed by software API.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>STABMODE</name>
              <description>Stability configuration, only required for test purposes.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>XTAL32MCTRL</name>
          <description>XTAL 32 MHz control register. If XTAL has been auto started due to EFUSE XTAL32MSTART_ENA or BLE low power timers then the effect of these need disabling via SYSCON.XTAL32MCTRL before the full control by this register is possible.</description>
          <addressOffset>0xAC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x2821428</resetValue>
          <resetMask>0x3FC3FFFF</resetMask>
          <fields>
            <field>
              <name>XO_ACBUF_PASS_ENABLE</name>
              <description>Bypass enable of XTAL AC buffer enable in pll and top level. Setting managed by software API.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>XO_AMP</name>
              <description>Amplitude selection , Min amp: 001, Max amp: 110. Setting managed by software API.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>XO_OSC_CAP_IN</name>
              <description>Internal Capacitor Selection for XTAL_P. Each XTAL pin has a capacitance value up to approximately 25pF. Device test calibration data is stored on chip so that a software function can configure a capacitiance with high accuracy.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>7</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>XO_OSC_CAP_OUT</name>
              <description>Internal Capacitor Selection for XTAL_N. Each XTAL pin has a capacitance value up to approximately 25pF. Device test calibration data is stored on chip so that a software function can configure a capacitiance with high accuracy.</description>
              <bitOffset>11</bitOffset>
              <bitWidth>7</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>XO_ENABLE</name>
              <description>Enable signal for 32MHz XTAL.</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>XO_GM</name>
              <description>Gm value for XTAL.. Setting managed by software API.</description>
              <bitOffset>23</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>XO_SLAVE</name>
              <description>XTAL in slave mode. Setting managed by software API.</description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>XO_STANDALONE_ENABLE</name>
              <description>Selection of the LDO and core XO reference biasing sources (1uA bandgap current and 0.6V bandgap voltage): 0: biasing provided by radio reference biasing sources. Don't switch to this value without prior radio biasing, LDO XO, core XO, LDO 1.4V and PLL current distribution enabling. 1: biasing is provided by Power Management Unit (PMU). Control of this bit is generally managed by the radio or clock software functions.</description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>XO32M_TO_MCU_ENABLE</name>
              <description>Enable the 32MHz clock to MCU and the clock generators.</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_TO_GPADC_ENABLE</name>
              <description>Enable the 16MHz clock to General Purpose ADC</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ANALOGID</name>
          <description>Analog Interfaces (PMU and Radio) identity registers</description>
          <addressOffset>0xB0</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x7</resetValue>
          <resetMask>0x3F</resetMask>
          <fields>
            <field>
              <name>PMUID</name>
              <description>PMU Identitty register used ti indicate a version of the PMU.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RADIOSTATUS</name>
          <description>All Radio Analog modules status register.</description>
          <addressOffset>0xB4</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0</resetValue>
          <resetMask>0x1</resetMask>
          <fields>
            <field>
              <name>PLLXOREADY</name>
              <description>Value of status output by 32M XTAL oscillator. Aserted to indicate that the clock is active. Note that the quality of the 32M clock may improve even after this is asserted. Additionally, if settings are changed such as ibias control then this status flag will probably remain asserted even though changes to the clock signal will be occuring,</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DCBUSCTRL</name>
          <description>DC Bus can be used during device test and evaluation to give observation of internal signals.</description>
          <addressOffset>0xBC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0x1FFFF</resetMask>
          <fields>
            <field>
              <name>ADDR</name>
              <description>ADDR[8] should be set to 1 before entering power down to prevent the risk of a small amount of leakage current during power down.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>9</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>FREQMECTRL</name>
          <description>Frequency measure register</description>
          <addressOffset>0xC0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CAPVAL</name>
              <description>Frequency Measure control and status; the function differs for a read and write operation. CAPVAL: FREQMECTRL[30:0] (Read-only) : Stores the target counter result from the last frequency measure activiation, this is used in the calculation of the unknown clock frequency of the reference or target clock. SCALE: FREQMECTRL[4:0] (Write-only) : define the count duration, (2^SCALE)-1, that reference counter counts to during measurement. Note that the value is 2 giving a minimum count 2^2-1 = 3. The result of freq_me_plus can be calculated as follows : freq_targetclk =freq_refclk* (CAPVAL+1) / ((2^SCALE)-1);</description>
              <bitOffset>0</bitOffset>
              <bitWidth>31</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PROG</name>
              <description>Set this bit to one to initiate a frequency measurement cycle. Hardware clears this bit when the measurement cycle has completed and there is valid capture data in the CAPVAL field (bits 13:0).</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>NFCTAG_VDD</name>
          <description>NFCTAG VDD output control</description>
          <addressOffset>0xC8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0x3</resetMask>
          <fields>
            <field>
              <name>NFCTAG_VDD_OUT</name>
              <description>Output value for the NFC Tag Vdd IO, if enabled with NFCTAG_VDD_OE.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>NFCTAG_VDD_OE</name>
              <description>Output enable for the NFC Tag Vdd IO cell.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SWRESETCTRL</name>
          <description>Full IC reset request (from Software application).</description>
          <addressOffset>0xCC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>ICRESETREQ</name>
              <description>IC reset request. This bit is only valid if VECTKEY is set correctly. 0: No effect; 1: Request a fulll IC reset level reset</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>VECTKEY</name>
              <description>Register Key: On write, write 0x05FA to VECTKEY, otherwise the write is ignored.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>CTIMER0</name>
      <description>This is the description of component ct32b It is standard 32-bit Counter/Timer with APB bus interface. More details will follow.</description>
      <groupName>CTIMER</groupName>
      <headerStructName>CTIMER</headerStructName>
      <baseAddress>0x40021000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>0x78</size>
        <usage>registers</usage>
      </addressBlock>
      <interrupt>
        <name>CTIMER0</name>
        <value>9</value>
      </interrupt>
      <registers>
        <register>
          <name>IR</name>
          <description>Interrupt Register. The IR can be written to clear interrupts. The IR can be read to identify which of eight possible interrupt sources are pending.</description>
          <addressOffset>0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>MR0INT</name>
              <description>Interrupt flag for match channel 0.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MR1INT</name>
              <description>Interrupt flag for match channel 1.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MR2INT</name>
              <description>Interrupt flag for match channel 2.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MR3INT</name>
              <description>Interrupt flag for match channel 3.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CR0INT</name>
              <description>Interrupt flag for capture channel 0 event.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CR1INT</name>
              <description>Interrupt flag for capture channel 1 event.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CR2INT</name>
              <description>Interrupt flag for capture channel 2 event.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CR3INT</name>
              <description>Interrupt flag for capture channel 3 event.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TCR</name>
          <description>Timer Control Register. The TCR is used to control the Timer Counter functions. The Timer Counter can be disabled or reset through the TCR.</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0x3</resetMask>
          <fields>
            <field>
              <name>CEN</name>
              <description>Counter enable. 0 Disabled.The counters are disabled. 1 Enabled. The Timer Counter and Prescale Counter are enabled.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CRST</name>
              <description>Counter reset. 0 Disabled. Do nothing. 1 Enabled. The Timer Counter and the Prescale Counter are synchronously reset on the next positive edge of the APB bus clock. The counters remain reset until TCR[1] is returned to zero.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TC</name>
          <description>Timer Counter. The 32 bit TC is incremented every PR+1 cycles of the APB bus clock. The TC is controlled through the TCR.</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TCVAL</name>
              <description>Timer counter value.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PR</name>
          <description>Prescale Register. When the Prescale Counter (PC) is equal to this value, the next clock increments the TC and clears the PC.</description>
          <addressOffset>0xC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PRVAL</name>
              <description>Prescale counter value.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PC</name>
          <description>Prescale Counter. The 32 bit PC is a counter which is incremented to the value stored in PR. When the value in PR is reached, the TC is incremented and the PC is cleared. The PC is observable and controllable through the bus interface.</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PCVAL</name>
              <description>Prescale counter value.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MCR</name>
          <description>Match Control Register. The MCR is used to control if an interrupt is generated and if the TC is reset when a Match occurs.</description>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0xFFF</resetMask>
          <fields>
            <field>
              <name>MR0I</name>
              <description>Interrupt on MR0: an interrupt is generated when MR0 matches the value in the TC. 0 = disabled. 1 = enabled.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MR0R</name>
              <description>Reset on MR0: the TC will be reset if MR0 matches it. 0 = disabled. 1 = enabled.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MR0S</name>
              <description>Stop on MR0: the TC and PC will be stopped and TCR[0] will be set to 0 if MR0 matches the TC. 0 = disabled. 1 = enabled.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MR1I</name>
              <description>Interrupt on MR1: an interrupt is generated when MR1 matches the value in the TC. 0 = disabled. 1 = enabled.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MR1R</name>
              <description>Reset on MR1: the TC will be reset if MR1 matches it. 0 = disabled. 1 = enabled.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MR1S</name>
              <description>Stop on MR1: the TC and PC will be stopped and TCR[0] will be set to 0 if MR1 matches the TC. 0 = disabled. 1 = enabled.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MR2I</name>
              <description>Interrupt on MR2: an interrupt is generated when MR2 matches the value in the TC. 0 = disabled. 1 = enabled.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MR2R</name>
              <description>Reset on MR2: the TC will be reset if MR2 matches it. 0 = disabled. 1 = enabled.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MR2S</name>
              <description>Stop on MR2: the TC and PC will be stopped and TCR[0] will be set to 0 if MR2 matches the TC. 0 = disabled. 1 = enabled.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MR3I</name>
              <description>Interrupt on MR3: an interrupt is generated when MR3 matches the value in the TC. 0 = disabled. 1 = enabled.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MR3R</name>
              <description>Reset on MR3: the TC will be reset if MR3 matches it. 0 = disabled. 1 = enabled.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MR3S</name>
              <description>Stop on MR3: the TC and PC will be stopped and TCR[0] will be set to 0 if MR3 matches the TC. 0 = disabled. 1 = enabled.</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>4</dim>
          <dimIncrement>0x4</dimIncrement>
          <name>MR[%s]</name>
          <description>Match Register . MR can be enabled through the MCR to reset the TC, stop both the TC and PC, and/or generate an interrupt every time MR matches the TC.</description>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MATCH</name>
              <description>Timer counter match value.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CCR</name>
          <description>Capture Control Register. The CCR controls which edges of the capture inputs are used to load the Capture Registers and whether or not an interrupt is generated when a capture takes place.</description>
          <addressOffset>0x28</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0x3F</resetMask>
          <fields>
            <field>
              <name>CAP0RE</name>
              <description>Rising edge of capture channel 0: a sequence of 0 then 1 causes CR0 to be loaded with the contents of TC. 0 = disabled. 1 = enabled.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CAP0FE</name>
              <description>Falling edge of capture channel 0: a sequence of 1 then 0 causes CR0 to be loaded with the contents of TC. 0 = disabled. 1 = enabled.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CAP0I</name>
              <description>Generate interrupt on channel 0 capture event: a CR0 load generates an interrupt.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CAP1RE</name>
              <description>Rising edge of capture channel 1: a sequence of 0 then 1 causes CR1 to be loaded with the contents of TC. 0 = disabled. 1 = enabled.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CAP1FE</name>
              <description>Falling edge of capture channel 1: a sequence of 1 then 0 causes CR1 to be loaded with the contents of TC. 0 = disabled. 1 = enabled.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CAP1I</name>
              <description>Generate interrupt on channel 1 capture event: a CR1 load generates an interrupt.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>2</dim>
          <dimIncrement>0x4</dimIncrement>
          <name>CR[%s]</name>
          <description>Capture Register . CR is loaded with the value of TC when there is an event on the CAPn.0 input.</description>
          <addressOffset>0x2C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CAP</name>
              <description>Timer counter capture value.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>EMR</name>
          <description>External Match Register. The EMR controls the match function and the external match pins.</description>
          <addressOffset>0x3C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0xFFF</resetMask>
          <fields>
            <field>
              <name>EM0</name>
              <description>External Match 0. This bit reflects the state of output MAT0, whether or not this output is connected to a pin. When a match occurs between the TC and MR0, this bit can either toggle, go LOW, go HIGH, or do nothing, as selected by EMR[5:4]. This bit is driven to the MAT pins if the match function is selected via IOCON. 0 = LOW. 1 = HIGH.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EM1</name>
              <description>External Match 1. This bit reflects the state of output MAT1, whether or not this output is connected to a pin. When a match occurs between the TC and MR1, this bit can either toggle, go LOW, go HIGH, or do nothing, as selected by EMR[7:6]. This bit is driven to the MAT pins if the match function is selected via IOCON. 0 = LOW. 1 = HIGH.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EM2</name>
              <description>External Match 2. This bit reflects the state of output MAT2, whether or not this output is connected to a pin. When a match occurs between the TC and MR2, this bit can either toggle, go LOW, go HIGH, or do nothing, as selected by EMR[9:8]. This bit is driven to the MAT pins if the match function is selected via IOCON. 0 = LOW. 1 = HIGH</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EM3</name>
              <description>External Match 3. This bit reflects the state of output MAT3, whether or not this output is connected to a pin. When a match occurs between the TC and MR3, this bit can either toggle, go LOW, go HIGH, or do nothing, as selected by MR[11:10]. This bit is driven to the MAT pins if the match function is selected via IOCON. 0 = LOW. 1 = HIGH.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EMC0</name>
              <description>External Match Control 0. Determines the functionality of External Match 0. 0x0 Do Nothing. 0x1 Clear. Clear the corresponding External Match bit/output to 0 (MAT0 pin is LOW if pinned out). 0x2 Set. Set the corresponding External Match bit/output to 1 (MAT0 pin is HIGH if pinned out). 0x3 Toggle. Toggle the corresponding External Match bit/output.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EMC1</name>
              <description>External Match Control 1. Determines the functionality of External Match 1. 0x0 Do Nothing. 0x1 Clear. Clear the corresponding External Match bit/output to 0 (MAT1 pin is LOW if pinned out). 0x2 Set. Set the corresponding External Match bit/output to 1 (MAT1 pin is HIGH if pinned out). 0x3 Toggle. Toggle the corresponding External Match bit/output.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EMC2</name>
              <description>External Match Control 2. Determines the functionality of External Match 2. 0x0 Do Nothing. 0x1 Clear. Clear the corresponding External Match bit/output to 0 (MAT2 pin is LOW if pinned out). 0x2 Set. Set the corresponding External Match bit/output to 1 (MAT2 pin is HIGH if pinned out). 0x3 Toggle. Toggle the corresponding External Match bit/output.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EMC3</name>
              <description>External Match Control 3. Determines the functionality of External Match 3. 0x0 Do Nothing. 0x1 Clear. Clear the corresponding External Match bit/output to 0 (MAT3 pin is LOW if pinned out). 0x2 Set. Set the corresponding External Match bit/output to 1 (MAT3 pin is HIGH if pinned out). 0x3 Toggle. Toggle the corresponding External Match bit/output.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CTCR</name>
          <description>Count Control Register. The CTCR selects between Timer and Counter mode, and in Counter mode selects the signal and edge(s) for counting.</description>
          <addressOffset>0x70</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>CTMODE</name>
              <description>Counter/Timer Mode This field selects which rising APB bus clock edges can increment Timer s Prescale Counter (PC), or clear PC and increment Timer Counter (TC). Timer Mode: the TC is incremented when the Prescale Counter matches the Prescale Register. 0x0 Timer Mode. Incremented every rising APB bus clock edge. 0x1 Counter Mode rising edge. TC is incremented on rising edges on the CAP input selected by bits 3:2. 0x2 Counter Mode falling edge. TC is incremented on falling edges on the CAP input selected by bits 3:2. 0x3 Counter Mode dual edge. TC is incremented on both edges on the CAP input selected by bits 3:2.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CINSEL</name>
              <description>Count Input Select When bits 1:0 in this register are not 00, these bits select which CAP pin is sampled for clocking. Note: If Counter mode is selected for a particular CAPn input in the CTCR, the 3 bits for that input in the Capture Control Register (CCR) must be programmed as 000. However, capture and/or interrupt can be selected for the other 3 CAPn inputs in the same timer. 0x0 Channel 0. CAPn.0 for CT32Bn 0x1 Channel 1. CAPn.1 for CT32Bn 0x2 Channel 2. CAPn.2 for CT32Bn 0x3 Channel 3. CAPn.3 for CT32Bn</description>
              <bitOffset>2</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ENCC</name>
              <description>Setting this bit to 1 enables clearing of the timer and the prescaler when the capture-edge event specified in bits 7:5 occurs.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SELCC</name>
              <description>Edge select. When bit 4 is 1, these bits select which capture input edge will cause the timer and prescaler to be cleared. These bits have no effect when bit 4 is low. Values 0x2 to 0x3 and 0x6 to 0x7 are reserved. 0 0x0 Channel 0 Rising Edge. Rising edge of the signal on capture channel 0 clears the timer (if bit 4 is set). 0x1 Channel 0 Falling Edge. Falling edge of the signal on capture channel 0 clears the timer (if bit 4 is set). 0x2 Channel 1 Rising Edge. Rising edge of the signal on capture channel 1 clears the timer (if bit 4 is set). 0x3 Channel 1 Falling Edge. Falling edge of the signal on capture channel 1 clears the timer (if bit 4 is set). 0x4 Channel 2 Rising Edge. Rising edge of the signal on capture channel 2 clears the timer (if bit 4 is set). 0x5 Channel 2 Falling Edge. Falling edge of the signal on capture channel 2 clears the timer (if bit 4 is set).</description>
              <bitOffset>5</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PWMC</name>
          <description>PWM Control Register. The PWMCON enables PWM mode for the external match pins.</description>
          <addressOffset>0x74</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0xF</resetMask>
          <fields>
            <field>
              <name>PWMEN0</name>
              <description>PWM mode enable for channel0. 0 Match. CT32Bn_MAT0 is controlled by EM0. 1 PWM. PWM mode is enabled for CT32Bn_MAT0.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PWMEN1</name>
              <description>PWM mode enable for channel1. 0 Match. CT32Bn_MAT01 is controlled by EM1. 1 PWM. PWM mode is enabled for CT32Bn_MAT1.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PWMEN2</name>
              <description>PWM mode enable for channel2. 0 Match. CT32Bn_MAT2 is controlled by EM2. 1 PWM. PWM mode is enabled for CT32Bn_MAT2.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PWMEN3</name>
              <description>PWM mode enable for channel3. Note: It is recommended to use match channel 3 to set the PWM cycle. 0 Match. CT32Bn_MAT3 is controlled by EM3. 1 PWM. PWM mode is enabled for CT132Bn_MAT3</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral derivedFrom="CTIMER0">
      <name>CTIMER1</name>
      <description>This is the description of component ct32b It is standard 32-bit Counter/Timer with APB bus interface. More details will follow.</description>
      <groupName>CTIMER</groupName>
      <baseAddress>0x40022000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>0x78</size>
        <usage>registers</usage>
      </addressBlock>
      <interrupt>
        <name>CTIMER1</name>
        <value>10</value>
      </interrupt>
    </peripheral>
    <peripheral>
      <name>GPIO</name>
      <description>This is the description of component gpio It is General Purpose I/O with APB bus interface. More details will follow.</description>
      <groupName>GPIO</groupName>
      <baseAddress>0x40080000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>0x2484</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <dim>22</dim>
          <dimIncrement>0x1</dimIncrement>
          <name>B[%s]</name>
          <description>Byte pin registers. Read 0: pin PIOn is LOW. Read 0xFF: pin PIOn is HIGH. Only 0 or 0xFF can be read. Write 0: clear output bit. Write any value 0x01 to 0xFF: set output bit. Reset values reflects the state of pin given by the relevant bit of PIN reset value</description>
          <addressOffset>0</addressOffset>
          <size>8</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>B</name>
              <description>Byte pin registers. Read 0: pin PIOn is LOW. Read 0xFF: pin PIOn is HIGH. Only 0 or 0xFF can be read. Write 0: clear output bit. Write any value 0x01 to 0xFF: set output bit. Reset values reflects the state of pin given by the relevant bit of PIN reset value</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>22</dim>
          <dimIncrement>0x4</dimIncrement>
          <name>W[%s]</name>
          <description>Word pin registers Read 0: pin PIOn is LOW. Read 0xFFFFFFFF: pin PIOn is HIGH. Only 0 or 0xFFFF FFFF can be read. Write 0: clear output bit. Write any value 0x00000001 to 0xFFFFFFFF: set output bit. Reset values reflects the state of pin given by the relevant bit of PIN reset value</description>
          <addressOffset>0x1000</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>W</name>
              <description>Word pin registers Read 0: pin PIOn is LOW. Read 0xFFFFFFFF: pin PIOn is HIGH. Only 0 or 0xFFFF FFFF can be read. Write 0: clear output bit. Write any value 0x00000001 to 0xFFFFFFFF: set output bit. Reset values reflects the state of pin given by the relevant bit of PIN reset value</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DIR0</name>
          <description>Direction register</description>
          <addressOffset>0x2000</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0x3FFFFF</resetMask>
          <fields>
            <field>
              <name>DIRP_PIO0</name>
              <description>Selects pin direction for pin PIO0 . 0 = input. 1 = output.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DIRP_PIO1</name>
              <description>Selects pin direction for pin PIO1 . 0 = input. 1 = output.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DIRP_PIO2</name>
              <description>Selects pin direction for pin PIO2 . 0 = input. 1 = output.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DIRP_PIO3</name>
              <description>Selects pin direction for pin PIO3 . 0 = input. 1 = output.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DIRP_PIO4</name>
              <description>Selects pin direction for pin PIO4 . 0 = input. 1 = output.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DIRP_PIO5</name>
              <description>Selects pin direction for pin PIO5 . 0 = input. 1 = output.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DIRP_PIO6</name>
              <description>Selects pin direction for pin PIO6 . 0 = input. 1 = output.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DIRP_PIO7</name>
              <description>Selects pin direction for pin PIO7 . 0 = input. 1 = output.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DIRP_PIO8</name>
              <description>Selects pin direction for pin PIO8 . 0 = input. 1 = output.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DIRP_PIO9</name>
              <description>Selects pin direction for pin PIO9 . 0 = input. 1 = output.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DIRP_PIO10</name>
              <description>Selects pin direction for pin PIO10 . 0 = input. 1 = output.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DIRP_PIO11</name>
              <description>Selects pin direction for pin PIO11 . 0 = input. 1 = output.</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DIRP_PIO12</name>
              <description>Selects pin direction for pin PIO12 . 0 = input. 1 = output.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DIRP_PIO13</name>
              <description>Selects pin direction for pin PIO13 . 0 = input. 1 = output.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DIRP_PIO14</name>
              <description>Selects pin direction for pin PIO14 . 0 = input. 1 = output.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DIRP_PIO15</name>
              <description>Selects pin direction for pin PIO15 . 0 = input. 1 = output.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DIRP_PIO16</name>
              <description>Selects pin direction for pin PIO16 . 0 = input. 1 = output.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DIRP_PIO17</name>
              <description>Selects pin direction for pin PIO17 . 0 = input. 1 = output.</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DIRP_PIO18</name>
              <description>Selects pin direction for pin PIO18 . 0 = input. 1 = output.</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DIRP_PIO19</name>
              <description>Selects pin direction for pin PIO19 . 0 = input. 1 = output.</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DIRP_PIO20</name>
              <description>Selects pin direction for pin PIO20 . 0 = input. 1 = output.</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DIRP_PIO21</name>
              <description>Selects pin direction for pin PIO21 . 0 = input. 1 = output.</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MASK0</name>
          <description>Mask register</description>
          <addressOffset>0x2080</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0x3FFFFF</resetMask>
          <fields>
            <field>
              <name>MASKP_PIO0</name>
              <description>Controls if PIO0 is active in MPIN register. 0 = Mask bit is clear, the PIO will be active. 1 = Mask bit is set, the PIO will not be active.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MASKP_PIO1</name>
              <description>Controls if PIO1 is active in MPIN register. 0 = Mask bit is clear, the PIO will be active. 1 = Mask bit is set, the PIO will not be active.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MASKP_PIO2</name>
              <description>Controls if PIO2 is active in MPIN register. 0 = Mask bit is clear, the PIO will be active. 1 = Mask bit is set, the PIO will not be active.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MASKP_PIO3</name>
              <description>Controls if PIO3 is active in MPIN register. 0 = Mask bit is clear, the PIO will be active. 1 = Mask bit is set, the PIO will not be active.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MASKP_PIO4</name>
              <description>Controls if PIO4 is active in MPIN register. 0 = Mask bit is clear, the PIO will be active. 1 = Mask bit is set, the PIO will not be active.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MASKP_PIO5</name>
              <description>Controls if PIO5 is active in MPIN register. 0 = Mask bit is clear, the PIO will be active. 1 = Mask bit is set, the PIO will not be active.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MASKP_PIO6</name>
              <description>Controls if PIO6 is active in MPIN register. 0 = Mask bit is clear, the PIO will be active. 1 = Mask bit is set, the PIO will not be active.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MASKP_PIO7</name>
              <description>Controls if PIO7 is active in MPIN register. 0 = Mask bit is clear, the PIO will be active. 1 = Mask bit is set, the PIO will not be active.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MASKP_PIO8</name>
              <description>Controls if PIO8 is active in MPIN register. 0 = Mask bit is clear, the PIO will be active. 1 = Mask bit is set, the PIO will not be active.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MASKP_PIO9</name>
              <description>Controls if PIO9 is active in MPIN register. 0 = Mask bit is clear, the PIO will be active. 1 = Mask bit is set, the PIO will not be active.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MASKP_PIO10</name>
              <description>Controls if PIO10 is active in MPIN register. 0 = Mask bit is clear, the PIO will be active. 1 = Mask bit is set, the PIO will not be active.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MASKP_PIO11</name>
              <description>Controls if PIO11 is active in MPIN register. 0 = Mask bit is clear, the PIO will be active. 1 = Mask bit is set, the PIO will not be active.</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MASKP_PIO12</name>
              <description>Controls if PIO12 is active in MPIN register. 0 = Mask bit is clear, the PIO will be active. 1 = Mask bit is set, the PIO will not be active.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MASKP_PIO13</name>
              <description>Controls if PIO13 is active in MPIN register. 0 = Mask bit is clear, the PIO will be active. 1 = Mask bit is set, the PIO will not be active.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MASKP_PIO14</name>
              <description>Controls if PIO14 is active in MPIN register. 0 = Mask bit is clear, the PIO will be active. 1 = Mask bit is set, the PIO will not be active.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MASKP_PIO15</name>
              <description>Controls if PIO150 is active in MPIN register. 0 = Mask bit is clear, the PIO will be active. 1 = Mask bit is set, the PIO will not be active.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MASKP_PIO16</name>
              <description>Controls if PIO16 is active in MPIN register. 0 = Mask bit is clear, the PIO will be active. 1 = Mask bit is set, the PIO will not be active.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MASKP_PIO17</name>
              <description>Controls if PIO17 is active in MPIN register. 0 = Mask bit is clear, the PIO will be active. 1 = Mask bit is set, the PIO will not be active.</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MASKP_PIO18</name>
              <description>Controls if PIO18 is active in MPIN register. 0 = Mask bit is clear, the PIO will be active. 1 = Mask bit is set, the PIO will not be active.</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MASKP_PIO19</name>
              <description>Controls if PIO19 is active in MPIN register. 0 = Mask bit is clear, the PIO will be active. 1 = Mask bit is set, the PIO will not be active.</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MASKP_PIO20</name>
              <description>Controls if PIO20 is active in MPIN register. 0 = Mask bit is clear, the PIO will be active. 1 = Mask bit is set, the PIO will not be active.</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MASKP_PIO21</name>
              <description>Controls if PIO21 is active in MPIN register. 0 = Mask bit is clear, the PIO will be active. 1 = Mask bit is set, the PIO will not be active.</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PIN0</name>
          <description>Pin register</description>
          <addressOffset>0x2100</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x21FF39</resetValue>
          <resetMask>0x3FFFFF</resetMask>
          <fields>
            <field>
              <name>PORT_PIO0</name>
              <description>Reads pin states or loads output bits. 0 = Read: pin is low; write: clear output bit. 1 = Read: pin is high; write: set output bit.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PORT_PIO1</name>
              <description>Reads pin states or loads output bits. 0 = Read: pin is low; write: clear output bit. 1 = Read: pin is high; write: set output bit.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PORT_PIO2</name>
              <description>Reads pin states or loads output bits. 0 = Read: pin is low; write: clear output bit. 1 = Read: pin is high; write: set output bit.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PORT_PIO3</name>
              <description>Reads pin states or loads output bits. 0 = Read: pin is low; write: clear output bit. 1 = Read: pin is high; write: set output bit.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PORT_PIO4</name>
              <description>Reads pin states or loads output bits. 0 = Read: pin is low; write: clear output bit. 1 = Read: pin is high; write: set output bit.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PORT_PIO5</name>
              <description>Reads pin states or loads output bits. 0 = Read: pin is low; write: clear output bit. 1 = Read: pin is high; write: set output bit.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PORT_PIO6</name>
              <description>Reads pin states or loads output bits. 0 = Read: pin is low; write: clear output bit. 1 = Read: pin is high; write: set output bit.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PORT_PIO7</name>
              <description>Reads pin states or loads output bits. 0 = Read: pin is low; write: clear output bit. 1 = Read: pin is high; write: set output bit.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PORT_PIO8</name>
              <description>Reads pin states or loads output bits. 0 = Read: pin is low; write: clear output bit. 1 = Read: pin is high; write: set output bit.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PORT_PIO9</name>
              <description>Reads pin states or loads output bits. 0 = Read: pin is low; write: clear output bit. 1 = Read: pin is high; write: set output bit.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PORT_PIO10</name>
              <description>Reads pin states or loads output bits. 0 = Read: pin is low; write: clear output bit. 1 = Read: pin is high; write: set output bit.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PORT_PIO11</name>
              <description>Reads pin states or loads output bits. 0 = Read: pin is low; write: clear output bit. 1 = Read: pin is high; write: set output bit.</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PORT_PIO12</name>
              <description>Reads pin states or loads output bits. 0 = Read: pin is low; write: clear output bit. 1 = Read: pin is high; write: set output bit.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PORT_PIO13</name>
              <description>Reads pin states or loads output bits. 0 = Read: pin is low; write: clear output bit. 1 = Read: pin is high; write: set output bit.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PORT_PIO14</name>
              <description>Reads pin states or loads output bits. 0 = Read: pin is low; write: clear output bit. 1 = Read: pin is high; write: set output bit.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PORT_PIO15</name>
              <description>Reads pin states or loads output bits. 0 = Read: pin is low; write: clear output bit. 1 = Read: pin is high; write: set output bit.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PORT_PIO16</name>
              <description>Reads pin states or loads output bits. 0 = Read: pin is low; write: clear output bit. 1 = Read: pin is high; write: set output bit.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PORT_PIO17</name>
              <description>Reads pin states or loads output bits. 0 = Read: pin is low; write: clear output bit. 1 = Read: pin is high; write: set output bit.</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PORT_PIO18</name>
              <description>Reads pin states or loads output bits. 0 = Read: pin is low; write: clear output bit. 1 = Read: pin is high; write: set output bit.</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PORT_PIO19</name>
              <description>Reads pin states or loads output bits. 0 = Read: pin is low; write: clear output bit. 1 = Read: pin is high; write: set output bit.</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PORT_PIO20</name>
              <description>Reads pin states or loads output bits. 0 = Read: pin is low; write: clear output bit. 1 = Read: pin is high; write: set output bit.</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PORT_PIO21</name>
              <description>Reads pin states or loads output bits. 0 = Read: pin is low; write: clear output bit. 1 = Read: pin is high; write: set output bit.</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MPIN0</name>
          <description>Masked Pin register</description>
          <addressOffset>0x2180</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x21FF39</resetValue>
          <resetMask>0x3FFFFF</resetMask>
          <fields>
            <field>
              <name>MPORT_PIO0</name>
              <description>Masked pin register. 0 = Read: pin is LOW and/or the corresponding bit in the MASK register is 1; write: clear output bit if the corresponding bit in the MASK register is 0. 1 = Read: pin is HIGH and the corresponding bit in the MASK register is 0; write: set output bit if the corresponding bit in the MASK register is 0.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MPORT_PIO1</name>
              <description>Masked pin register. 0 = Read: pin is LOW and/or the corresponding bit in the MASK register is 1; write: clear output bit if the corresponding bit in the MASK register is 0. 1 = Read: pin is HIGH and the corresponding bit in the MASK register is 0; write: set output bit if the corresponding bit in the MASK register is 0.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MPORT_PIO2</name>
              <description>Masked pin register. 0 = Read: pin is LOW and/or the corresponding bit in the MASK register is 1; write: clear output bit if the corresponding bit in the MASK register is 0. 1 = Read: pin is HIGH and the corresponding bit in the MASK register is 0; write: set output bit if the corresponding bit in the MASK register is 0.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MPORT_PIO3</name>
              <description>Masked pin register. 0 = Read: pin is LOW and/or the corresponding bit in the MASK register is 1; write: clear output bit if the corresponding bit in the MASK register is 0. 1 = Read: pin is HIGH and the corresponding bit in the MASK register is 0; write: set output bit if the corresponding bit in the MASK register is 0.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MPORT_PIO4</name>
              <description>Masked pin register. 0 = Read: pin is LOW and/or the corresponding bit in the MASK register is 1; write: clear output bit if the corresponding bit in the MASK register is 0. 1 = Read: pin is HIGH and the corresponding bit in the MASK register is 0; write: set output bit if the corresponding bit in the MASK register is 0.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MPORT_PIO5</name>
              <description>Masked pin register. 0 = Read: pin is LOW and/or the corresponding bit in the MASK register is 1; write: clear output bit if the corresponding bit in the MASK register is 0. 1 = Read: pin is HIGH and the corresponding bit in the MASK register is 0; write: set output bit if the corresponding bit in the MASK register is 0.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MPORT_PIO6</name>
              <description>Masked pin register. 0 = Read: pin is LOW and/or the corresponding bit in the MASK register is 1; write: clear output bit if the corresponding bit in the MASK register is 0. 1 = Read: pin is HIGH and the corresponding bit in the MASK register is 0; write: set output bit if the corresponding bit in the MASK register is 0.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MPORT_PIO7</name>
              <description>Masked pin register. 0 = Read: pin is LOW and/or the corresponding bit in the MASK register is 1; write: clear output bit if the corresponding bit in the MASK register is 0. 1 = Read: pin is HIGH and the corresponding bit in the MASK register is 0; write: set output bit if the corresponding bit in the MASK register is 0.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MPORT_PIO8</name>
              <description>Masked pin register. 0 = Read: pin is LOW and/or the corresponding bit in the MASK register is 1; write: clear output bit if the corresponding bit in the MASK register is 0. 1 = Read: pin is HIGH and the corresponding bit in the MASK register is 0; write: set output bit if the corresponding bit in the MASK register is 0.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MPORT_PIO9</name>
              <description>Masked pin register. 0 = Read: pin is LOW and/or the corresponding bit in the MASK register is 1; write: clear output bit if the corresponding bit in the MASK register is 0. 1 = Read: pin is HIGH and the corresponding bit in the MASK register is 0; write: set output bit if the corresponding bit in the MASK register is 0.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MPORT_PIO10</name>
              <description>Masked pin register. 0 = Read: pin is LOW and/or the corresponding bit in the MASK register is 1; write: clear output bit if the corresponding bit in the MASK register is 0. 1 = Read: pin is HIGH and the corresponding bit in the MASK register is 0; write: set output bit if the corresponding bit in the MASK register is 0.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MPORT_PIO11</name>
              <description>Masked pin register. 0 = Read: pin is LOW and/or the corresponding bit in the MASK register is 1; write: clear output bit if the corresponding bit in the MASK register is 0. 1 = Read: pin is HIGH and the corresponding bit in the MASK register is 0; write: set output bit if the corresponding bit in the MASK register is 0.</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MPORT_PIO12</name>
              <description>Masked pin register. 0 = Read: pin is LOW and/or the corresponding bit in the MASK register is 1; write: clear output bit if the corresponding bit in the MASK register is 0. 1 = Read: pin is HIGH and the corresponding bit in the MASK register is 0; write: set output bit if the corresponding bit in the MASK register is 0.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MPORT_PIO13</name>
              <description>Masked pin register. 0 = Read: pin is LOW and/or the corresponding bit in the MASK register is 1; write: clear output bit if the corresponding bit in the MASK register is 0. 1 = Read: pin is HIGH and the corresponding bit in the MASK register is 0; write: set output bit if the corresponding bit in the MASK register is 0.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MPORT_PIO14</name>
              <description>Masked pin register. 0 = Read: pin is LOW and/or the corresponding bit in the MASK register is 1; write: clear output bit if the corresponding bit in the MASK register is 0. 1 = Read: pin is HIGH and the corresponding bit in the MASK register is 0; write: set output bit if the corresponding bit in the MASK register is 0.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MPORT_PIO15</name>
              <description>Masked pin register. 0 = Read: pin is LOW and/or the corresponding bit in the MASK register is 1; write: clear output bit if the corresponding bit in the MASK register is 0. 1 = Read: pin is HIGH and the corresponding bit in the MASK register is 0; write: set output bit if the corresponding bit in the MASK register is 0.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MPORT_PIO16</name>
              <description>Masked pin register. 0 = Read: pin is LOW and/or the corresponding bit in the MASK register is 1; write: clear output bit if the corresponding bit in the MASK register is 0. 1 = Read: pin is HIGH and the corresponding bit in the MASK register is 0; write: set output bit if the corresponding bit in the MASK register is 0.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MPORT_PIO17</name>
              <description>Masked pin register. 0 = Read: pin is LOW and/or the corresponding bit in the MASK register is 1; write: clear output bit if the corresponding bit in the MASK register is 0. 1 = Read: pin is HIGH and the corresponding bit in the MASK register is 0; write: set output bit if the corresponding bit in the MASK register is 0.</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MPORT_PIO18</name>
              <description>Masked pin register. 0 = Read: pin is LOW and/or the corresponding bit in the MASK register is 1; write: clear output bit if the corresponding bit in the MASK register is 0. 1 = Read: pin is HIGH and the corresponding bit in the MASK register is 0; write: set output bit if the corresponding bit in the MASK register is 0.</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MPORT_PIO19</name>
              <description>Masked pin register. 0 = Read: pin is LOW and/or the corresponding bit in the MASK register is 1; write: clear output bit if the corresponding bit in the MASK register is 0. 1 = Read: pin is HIGH and the corresponding bit in the MASK register is 0; write: set output bit if the corresponding bit in the MASK register is 0.</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MPORT_PIO20</name>
              <description>Masked pin register. 0 = Read: pin is LOW and/or the corresponding bit in the MASK register is 1; write: clear output bit if the corresponding bit in the MASK register is 0. 1 = Read: pin is HIGH and the corresponding bit in the MASK register is 0; write: set output bit if the corresponding bit in the MASK register is 0.</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MPORT_PIO21</name>
              <description>Masked pin register. 0 = Read: pin is LOW and/or the corresponding bit in the MASK register is 1; write: clear output bit if the corresponding bit in the MASK register is 0. 1 = Read: pin is HIGH and the corresponding bit in the MASK register is 0; write: set output bit if the corresponding bit in the MASK register is 0.</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SET0</name>
          <description>Write: Set Pin register bits Read: output bits</description>
          <addressOffset>0x2200</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0x3FFFFF</resetMask>
          <fields>
            <field>
              <name>SETP_PIO0</name>
              <description>Read or set output bits. 0 = Read: output bit: write: no operation. 1 = Read: output bit; write: set output bit.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SETP_PIO1</name>
              <description>Read or set output bits. 0 = Read: output bit: write: no operation. 1 = Read: output bit; write: set output bit.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SETP_PIO2</name>
              <description>Read or set output bits. 0 = Read: output bit: write: no operation. 1 = Read: output bit; write: set output bit.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SETP_PIO3</name>
              <description>Read or set output bits. 0 = Read: output bit: write: no operation. 1 = Read: output bit; write: set output bit.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SETP_PIO4</name>
              <description>Read or set output bits. 0 = Read: output bit: write: no operation. 1 = Read: output bit; write: set output bit.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SETP_PIO5</name>
              <description>Read or set output bits. 0 = Read: output bit: write: no operation. 1 = Read: output bit; write: set output bit.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SETP_PIO6</name>
              <description>Read or set output bits. 0 = Read: output bit: write: no operation. 1 = Read: output bit; write: set output bit.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SETP_PIO7</name>
              <description>Read or set output bits. 0 = Read: output bit: write: no operation. 1 = Read: output bit; write: set output bit.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SETP_PIO8</name>
              <description>Read or set output bits. 0 = Read: output bit: write: no operation. 1 = Read: output bit; write: set output bit.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SETP_PIO9</name>
              <description>Read or set output bits. 0 = Read: output bit: write: no operation. 1 = Read: output bit; write: set output bit.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SETP_PIO10</name>
              <description>Read or set output bits. 0 = Read: output bit: write: no operation. 1 = Read: output bit; write: set output bit.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SETP_PIO11</name>
              <description>Read or set output bits. 0 = Read: output bit: write: no operation. 1 = Read: output bit; write: set output bit.</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SETP_PIO12</name>
              <description>Read or set output bits. 0 = Read: output bit: write: no operation. 1 = Read: output bit; write: set output bit.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SETP_PIO13</name>
              <description>Read or set output bits. 0 = Read: output bit: write: no operation. 1 = Read: output bit; write: set output bit.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SETP_PIO14</name>
              <description>Read or set output bits. 0 = Read: output bit: write: no operation. 1 = Read: output bit; write: set output bit.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SETP_PIO15</name>
              <description>Read or set output bits. 0 = Read: output bit: write: no operation. 1 = Read: output bit; write: set output bit.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SETP_PIO16</name>
              <description>Read or set output bits. 0 = Read: output bit: write: no operation. 1 = Read: output bit; write: set output bit.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SETP_PIO17</name>
              <description>Read or set output bits. 0 = Read: output bit: write: no operation. 1 = Read: output bit; write: set output bit.</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SETP_PIO18</name>
              <description>Read or set output bits. 0 = Read: output bit: write: no operation. 1 = Read: output bit; write: set output bit.</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SETP_PIO19</name>
              <description>Read or set output bits. 0 = Read: output bit: write: no operation. 1 = Read: output bit; write: set output bit.</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SETP_PIO20</name>
              <description>Read or set output bits. 0 = Read: output bit: write: no operation. 1 = Read: output bit; write: set output bit.</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SETP_PIO21</name>
              <description>Read or set output bits. 0 = Read: output bit: write: no operation. 1 = Read: output bit; write: set output bit.</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CLR0</name>
          <description>Clear Pin register bits</description>
          <addressOffset>0x2280</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>CLRP_PIO0</name>
              <description>Clear output bits. 0 = No operation. 1 = Clear output bit.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>CLRP_PIO1</name>
              <description>Clear output bits. 0 = No operation. 1 = Clear output bit.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>CLRP_PIO2</name>
              <description>Clear output bits. 0 = No operation. 1 = Clear output bit.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>CLRP_PIO3</name>
              <description>Clear output bits. 0 = No operation. 1 = Clear output bit.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>CLRP_PIO4</name>
              <description>Clear output bits. 0 = No operation. 1 = Clear output bit.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>CLRP_PIO5</name>
              <description>Clear output bits. 0 = No operation. 1 = Clear output bit.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>CLRP_PIO6</name>
              <description>Clear output bits. 0 = No operation. 1 = Clear output bit.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>CLRP_PIO7</name>
              <description>Clear output bits. 0 = No operation. 1 = Clear output bit.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>CLRP_PIO8</name>
              <description>Clear output bits. 0 = No operation. 1 = Clear output bit.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>CLRP_PIO9</name>
              <description>Clear output bits. 0 = No operation. 1 = Clear output bit.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>CLRP_PIO10</name>
              <description>Clear output bits. 0 = No operation. 1 = Clear output bit.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>CLRP_PIO11</name>
              <description>Clear output bits. 0 = No operation. 1 = Clear output bit.</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>CLRP_PIO12</name>
              <description>Clear output bits. 0 = No operation. 1 = Clear output bit.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>CLRP_PIO13</name>
              <description>Clear output bits. 0 = No operation. 1 = Clear output bit.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>CLRP_PIO14</name>
              <description>Clear output bits. 0 = No operation. 1 = Clear output bit.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>CLRP_PIO15</name>
              <description>Clear output bits. 0 = No operation. 1 = Clear output bit.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>CLRP_PIO16</name>
              <description>Clear output bits. 0 = No operation. 1 = Clear output bit.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>CLRP_PIO17</name>
              <description>Clear output bits. 0 = No operation. 1 = Clear output bit.</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>CLRP_PIO18</name>
              <description>Clear output bits. 0 = No operation. 1 = Clear output bit.</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>CLRP_PIO19</name>
              <description>Clear output bits. 0 = No operation. 1 = Clear output bit.</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>CLRP_PIO20</name>
              <description>Clear output bits. 0 = No operation. 1 = Clear output bit.</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>CLRP_PIO21</name>
              <description>Clear output bits. 0 = No operation. 1 = Clear output bit.</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>NOT0</name>
          <description>Toggle Pin register bits</description>
          <addressOffset>0x2300</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>NOTP_PIO0</name>
              <description>Toggle output bits. 0 = no operation. 1 = Toggle output bit.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>NOTP_PIO1</name>
              <description>Toggle output bits. 0 = no operation. 1 = Toggle output bit.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>NOTP_PIO2</name>
              <description>Toggle output bits. 0 = no operation. 1 = Toggle output bit.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>NOTP_PIO3</name>
              <description>Toggle output bits. 0 = no operation. 1 = Toggle output bit.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>NOTP_PIO4</name>
              <description>Toggle output bits. 0 = no operation. 1 = Toggle output bit.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>NOTP_PIO5</name>
              <description>Toggle output bits. 0 = no operation. 1 = Toggle output bit.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>NOTP_PIO6</name>
              <description>Toggle output bits. 0 = no operation. 1 = Toggle output bit.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>NOTP_PIO7</name>
              <description>Toggle output bits. 0 = no operation. 1 = Toggle output bit.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>NOTP_PIO8</name>
              <description>Toggle output bits. 0 = no operation. 1 = Toggle output bit.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>NOTP_PIO9</name>
              <description>Toggle output bits. 0 = no operation. 1 = Toggle output bit.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>NOTP_PIO10</name>
              <description>Toggle output bits. 0 = no operation. 1 = Toggle output bit.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>NOTP_PIO11</name>
              <description>Toggle output bits. 0 = no operation. 1 = Toggle output bit.</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>NOTP_PIO12</name>
              <description>Toggle output bits. 0 = no operation. 1 = Toggle output bit.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>NOTP_PIO13</name>
              <description>Toggle output bits. 0 = no operation. 1 = Toggle output bit.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>NOTP_PIO14</name>
              <description>Toggle output bits. 0 = no operation. 1 = Toggle output bit.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>NOTP_PIO15</name>
              <description>Toggle output bits. 0 = no operation. 1 = Toggle output bit.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>NOTP_PIO16</name>
              <description>Toggle output bits. 0 = no operation. 1 = Toggle output bit.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>NOTP_PIO17</name>
              <description>Toggle output bits. 0 = no operation. 1 = Toggle output bit.</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>NOTP_PIO18</name>
              <description>Toggle output bits. 0 = no operation. 1 = Toggle output bit.</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>NOTP_PIO19</name>
              <description>Toggle output bits. 0 = no operation. 1 = Toggle output bit.</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>NOTP_PIO20</name>
              <description>Toggle output bits. 0 = no operation. 1 = Toggle output bit.</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>NOTP_PIO21</name>
              <description>Toggle output bits. 0 = no operation. 1 = Toggle output bit.</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DIRSET0</name>
          <description>Set pin direction bits</description>
          <addressOffset>0x2380</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DIRSETP_PIO0</name>
              <description>Set direction bits. 0 = no operation. 1 = Set direction bit.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>DIRSETP_PIO1</name>
              <description>Set direction bits. 0 = no operation. 1 = Set direction bit.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>DIRSETP_PIO2</name>
              <description>Set direction bits. 0 = no operation. 1 = Set direction bit.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>DIRSETP_PIO3</name>
              <description>Set direction bits. 0 = no operation. 1 = Set direction bit.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>DIRSETP_PIO4</name>
              <description>Set direction bits. 0 = no operation. 1 = Set direction bit.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>DIRSETP_PIO5</name>
              <description>Set direction bits. 0 = no operation. 1 = Set direction bit.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>DIRSETP_PIO6</name>
              <description>Set direction bits. 0 = no operation. 1 = Set direction bit.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>DIRSETP_PIO7</name>
              <description>Set direction bits. 0 = no operation. 1 = Set direction bit.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>DIRSETP_PIO8</name>
              <description>Set direction bits. 0 = no operation. 1 = Set direction bit.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>DIRSETP_PIO9</name>
              <description>Set direction bits. 0 = no operation. 1 = Set direction bit.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>DIRSETP_PIO10</name>
              <description>Set direction bits. 0 = no operation. 1 = Set direction bit.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>DIRSETP_PIO11</name>
              <description>Set direction bits. 0 = no operation. 1 = Set direction bit.</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>DIRSETP_PIO12</name>
              <description>Set direction bits. 0 = no operation. 1 = Set direction bit.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>DIRSETP_PIO13</name>
              <description>Set direction bits. 0 = no operation. 1 = Set direction bit.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>DIRSETP_PIO14</name>
              <description>Set direction bits. 0 = no operation. 1 = Set direction bit.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>DIRSETP_PIO15</name>
              <description>Set direction bits. 0 = no operation. 1 = Set direction bit.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>DIRSETP_PIO16</name>
              <description>Set direction bits. 0 = no operation. 1 = Set direction bit.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>DIRSETP_PIO17</name>
              <description>Set direction bits. 0 = no operation. 1 = Set direction bit.</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>DIRSETP_PIO18</name>
              <description>Set direction bits. 0 = no operation. 1 = Set direction bit.</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>DIRSETP_PIO19</name>
              <description>Set direction bits. 0 = no operation. 1 = Set direction bit.</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>DIRSETP_PIO20</name>
              <description>Set direction bits. 0 = no operation. 1 = Set direction bit.</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>DIRSETP_PIO21</name>
              <description>Set direction bits. 0 = no operation. 1 = Set direction bit.</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DIRCLR0</name>
          <description>Clear pin direction bits</description>
          <addressOffset>0x2400</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DIRCLRP_PIO0</name>
              <description>Clear direction bits. 0 = no operation. 1 = Clear direction bit.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>DIRCLRP_PIO1</name>
              <description>Clear direction bits. 0 = no operation. 1 = Clear direction bit.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>DIRCLRP_PIO2</name>
              <description>Clear direction bits. 0 = no operation. 1 = Clear direction bit.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>DIRCLRP_PIO3</name>
              <description>Clear direction bits. 0 = no operation. 1 = Clear direction bit.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>DIRCLRP_PIO4</name>
              <description>Clear direction bits. 0 = no operation. 1 = Clear direction bit.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>DIRCLRP_PIO5</name>
              <description>Clear direction bits. 0 = no operation. 1 = Clear direction bit.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>DIRCLRP_PIO6</name>
              <description>Clear direction bits. 0 = no operation. 1 = Clear direction bit.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>DIRCLRP_PIO7</name>
              <description>Clear direction bits. 0 = no operation. 1 = Clear direction bit.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>DIRCLRP_PIO8</name>
              <description>Clear direction bits. 0 = no operation. 1 = Clear direction bit.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>DIRCLRP_PIO9</name>
              <description>Clear direction bits. 0 = no operation. 1 = Clear direction bit.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>DIRCLRP_PIO10</name>
              <description>Clear direction bits. 0 = no operation. 1 = Clear direction bit.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>DIRCLRP_PIO11</name>
              <description>Clear direction bits. 0 = no operation. 1 = Clear direction bit.</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>DIRCLRP_PIO12</name>
              <description>Clear direction bits. 0 = no operation. 1 = Clear direction bit.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>DIRCLRP_PIO13</name>
              <description>Clear direction bits. 0 = no operation. 1 = Clear direction bit.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>DIRCLRP_PIO14</name>
              <description>Clear direction bits. 0 = no operation. 1 = Clear direction bit.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>DIRCLRP_PIO15</name>
              <description>Clear direction bits. 0 = no operation. 1 = Clear direction bit.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>DIRCLRP_PIO16</name>
              <description>Clear direction bits. 0 = no operation. 1 = Clear direction bit.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>DIRCLRP_PIO17</name>
              <description>Clear direction bits. 0 = no operation. 1 = Clear direction bit.</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>DIRCLRP_PIO18</name>
              <description>Clear direction bits. 0 = no operation. 1 = Clear direction bit.</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>DIRCLRP_PIO19</name>
              <description>Clear direction bits. 0 = no operation. 1 = Clear direction bit.</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>DIRCLRP_PIO20</name>
              <description>Clear direction bits. 0 = no operation. 1 = Clear direction bit.</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>DIRCLRP_PIO21</name>
              <description>Clear direction bits. 0 = no operation. 1 = Clear direction bit.</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DIRNOT0</name>
          <description>Toggle pin direction bits</description>
          <addressOffset>0x2480</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DIRNOTP_PIO0</name>
              <description>Toggle direction bits. 0 = no operation. 1 = Toggle direction bit.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>DIRNOTP_PIO1</name>
              <description>Toggle direction bits. 0 = no operation. 1 = Toggle direction bit.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>DIRNOTP_PIO2</name>
              <description>Toggle direction bits. 0 = no operation. 1 = Toggle direction bit.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>DIRNOTP_PIO3</name>
              <description>Toggle direction bits. 0 = no operation. 1 = Toggle direction bit.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>DIRNOTP_PIO4</name>
              <description>Toggle direction bits. 0 = no operation. 1 = Toggle direction bit.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>DIRNOTP_PIO5</name>
              <description>Toggle direction bits. 0 = no operation. 1 = Toggle direction bit.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>DIRNOTP_PIO6</name>
              <description>Toggle direction bits. 0 = no operation. 1 = Toggle direction bit.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>DIRNOTP_PIO7</name>
              <description>Toggle direction bits. 0 = no operation. 1 = Toggle direction bit.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>DIRNOTP_PIO8</name>
              <description>Toggle direction bits. 0 = no operation. 1 = Toggle direction bit.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>DIRNOTP_PIO9</name>
              <description>Toggle direction bits. 0 = no operation. 1 = Toggle direction bit.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>DIRNOTP_PIO10</name>
              <description>Toggle direction bits. 0 = no operation. 1 = Toggle direction bit.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>DIRNOTP_PIO11</name>
              <description>Toggle direction bits. 0 = no operation. 1 = Toggle direction bit.</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>DIRNOTP_PIO12</name>
              <description>Toggle direction bits. 0 = no operation. 1 = Toggle direction bit.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>DIRNOTP_PIO13</name>
              <description>Toggle direction bits. 0 = no operation. 1 = Toggle direction bit.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>DIRNOTP_PIO14</name>
              <description>Toggle direction bits. 0 = no operation. 1 = Toggle direction bit.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>DIRNOTP_PIO15</name>
              <description>Toggle direction bits. 0 = no operation. 1 = Toggle direction bit.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>DIRNOTP_PIO16</name>
              <description>Toggle direction bits. 0 = no operation. 1 = Toggle direction bit.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>DIRNOTP_PIO17</name>
              <description>Toggle direction bits. 0 = no operation. 1 = Toggle direction bit.</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>DIRNOTP_PIO18</name>
              <description>Toggle direction bits. 0 = no operation. 1 = Toggle direction bit.</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>DIRNOTP_PIO19</name>
              <description>Toggle direction bits. 0 = no operation. 1 = Toggle direction bit.</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>DIRNOTP_PIO20</name>
              <description>Toggle direction bits. 0 = no operation. 1 = Toggle direction bit.</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>DIRNOTP_PIO21</name>
              <description>Toggle direction bits. 0 = no operation. 1 = Toggle direction bit.</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>SPIFI</name>
      <description>This is the description of component spifi It is General Purpose I/O with APB bus interface. More details will follow.</description>
      <groupName>SPIFI</groupName>
      <baseAddress>0x40084000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>0x20</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>CTRL</name>
          <description>SPIFI control register</description>
          <addressOffset>0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x400FFFFF</resetValue>
          <resetMask>0xF8EFFFFF</resetMask>
          <fields>
            <field>
              <name>TIMEOUT</name>
              <description>This field contains the number of serial clock periods without the processor reading data in memory mode, which will cause the SPIFI hardware to terminate the command by driving the CS pin high and negating the CMD bit in the Status register. (This allows the flash memory to enter a lower-power state.) If the processor reads data from the flash region after a time-out, the command in the Memory Command Register is issued again.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CSHIGH</name>
              <description>This field controls the minimum CS high time, expressed as a number of serial clock periods minus one.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>D_PRFTCH_DIS</name>
              <description>This bit allows conditioning of memory mode prefetches based on the AHB HPROT (instruction/data) access information. A 1 in this register means that the SPIFI will not attempt a speculative prefetch when it encounters data accesses.</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>INTEN</name>
              <description>If this bit is 1 when a command ends, the SPIFI will assert its interrupt request output. See INTRQ in the status register for further details.</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MODE3</name>
              <description>SPI Mode 3 select. 0: SCK LOW. The SPIFI drives SCK low after the rising edge at which the last bit of each command is captured, and keeps it low while CS is HIGH. 1: SCK HIGH. the SPIFI keeps SCK high after the rising edge for the last bit of each command and while CS is HIGH, and drives it low after it drives CS LOW. (Known serial flash devices can handle either mode, but some devices may require a particular mode for proper operation.) Remark: MODE3, RFCLK, and FBCLK should not all be 1, because in this case there is no final falling edge on SCK on which to sample the last data bit of the frame.</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PRFTCH_DIS</name>
              <description>Cache prefetching enable. The SPIFI includes an internal cache. A 1 in this bit disables prefetching of cache lines. 0: Enable. Cache prefetching enabled. 1: Disable. Disables prefetching of cache lines.</description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DUAL</name>
              <description>Select dual protocol. 0: Quad protocol. This protocol uses IO3:0. 1: Dual protocol. This protocol uses IO1:0.</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RFCLK</name>
              <description>Select active clock edge for input data. 0: Rising edge. Read data is sampled on rising edges on the clock, as in classic SPI operation. 1: Falling edge. Read data is sampled on falling edges of the clock, allowing a full serial clock of of time in order to maximize the serial clock frequency. Remark: MODE3, RFCLK, and FBCLK should not all be 1, because in this case there is no final falling edge on SCK on which to sample the last data bit of the frame.</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FBCLK</name>
              <description>Feedback clock select. 0: Internal clock. The SPIFI samples read data using an internal clock. 1: Feedback clock. Read data is sampled using a feedback clock from the SCK pin. This allows slightly more time for each received bit. Remark: MODE3, RFCLK, and FBCLK should not all be 1, because in this case there is no final falling edge on SCK on which to sample the last data bit of the frame.</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DMAEN</name>
              <description>A 1 in this bit enables the DMA Request output from the SPIFI. Set this bit only when a DMA channel is used to transfer data in peripheral mode. Do not set this bit when a DMA channel is used for memory-to-memory transfers from the SPIFI memory area. DRQEN should only be used in Command mode.</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CMD</name>
          <description>SPIFI command register</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DATALEN</name>
              <description>Except when the POLL bit in this register is 1, this field controls how many data bytes are in the command. 0 indicates that the command does not contain a data field.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>14</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>POLL</name>
              <description>This bit should be written as 1 only with an opcode that a) contains an input data field, and b) causes the serial flash device to return byte status repetitively (e.g., a Read Status command). When this bit is 1, the SPIFI hardware continues to read bytes until the test specified by the DATALEN field is met. The hardware tests the bit in each status byte selected by DATALEN bits 2:0, until a bit is found that is equal to DATALEN bit 3. When the test succeeds, the SPIFI captures the byte that meets this test so that it can be read from the Data Register, and terminates the command by raising CS. The end-of-command interrupt can be enabled to inform software when this occurs</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DOUT</name>
              <description>If the DATALEN field is not zero, this bit controls the direction of the data: 0: Input from serial flash. 1: Output to serial flash.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>INTLEN</name>
              <description>This field controls how many intermediate bytes precede the data. (Each such byte may require 8 or 2 SCK cycles, depending on whether the intermediate field is in serial, 2-bit, or 4-bit format.) Intermediate bytes are output by the SPIFI, and include post-address control information, dummy and delay bytes. See the description of the Intermediate Data register for the contents of such bytes.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FIELDFORM</name>
              <description>This field controls how the fields of the command are sent. 0x0: All serial. All fields of the command are serial. 0x1: Quad/dual data. Data field is quad/dual, other fields are serial. 0x2: Serial opcode. Opcode field is serial. Other fields are quad/dual. 0x3: All quad/dual. All fields of the command are in quad/dual format.</description>
              <bitOffset>19</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FRAMEFORM</name>
              <description>This field controls the opcode and address fields. 0x0: Reserved. 0x1: Opcode. Opcode only, no address. 0x2: Opcode one byte. Opcode, least significant byte of address. 0x3: Opcode two bytes. Opcode, two least significant bytes of address. 0x4: Opcode three bytes. Opcode, three least significant bytes of address. 0x5: Opcode four bytes. Opcode, 4 bytes of address. 0x6: No opcode three bytes. No opcode, 3 least significant bytes of address. 0x7: No opcode four bytes. No opcode, 4 bytes of address.</description>
              <bitOffset>21</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OPCODE</name>
              <description>The opcode of the command (not used for some FRAMEFORM values).</description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ADDR</name>
          <description>SPIFI address register</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ADDR</name>
              <description>SPIFI address register</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>IDATA</name>
          <description>SPIFI intermediate data register</description>
          <addressOffset>0xC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>IDATA</name>
              <description>SPIFI intermediate data register</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CLIMIT</name>
          <description>SPIFI limit register</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x8000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CLIMIT</name>
              <description>SPIFI limit register</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DATA</name>
          <description>SPIFI data register. Input or output data</description>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DATA</name>
              <description>SPIFI data register. Input or output data</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MCMD</name>
          <description>SPIFI memory command register</description>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0xFFFFC000</resetMask>
          <fields>
            <field>
              <name>POLL</name>
              <description>This bit should be written as 0.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DOUT</name>
              <description>This bit should be written as 0.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>INTLEN</name>
              <description>This field controls how many intermediate bytes precede the data. (Each such byte may require 8 or 2 SCK cycles, depending on whether the intermediate field is in serial, 2-bit, or 4-bit format.) Intermediate bytes are output by the SPIFI, and include post-address control information, dummy and delay bytes. See the description of the Intermediate Data register for the contents of such bytes.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FIELDFORM</name>
              <description>This field controls how the fields of the command are sent. 0x0 All serial. All fields of the command are serial. 0x1 Quad/dual data. Data field is quad/dual, other fields are serial. 0x2 Serial opcode. Opcode field is serial. Other fields are quad/dual. 0x3 All quad/dual. All fields of the command are in quad/dual format.</description>
              <bitOffset>19</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FRAMEFORM</name>
              <description>This field controls the opcode and address fields. 0x0: Reserved. 0x1: Opcode. Opcode only, no address. 0x2: Opcode one byte. Opcode, least-significant byte of address. 0x3: Opcode two bytes. Opcode, 2 least-significant bytes of address. 0x4: Opcode three bytes. Opcode, 3 least-significant bytes of address. 0x5: Opcode four bytes. Opcode, 4 bytes of address. 0x6: No opcode three bytes. No opcode, 3 least-significant bytes of address. 0x7: No opcode, 4 bytes of address.</description>
              <bitOffset>21</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OPCODE</name>
              <description>The opcode of the command (not used for some FRAMEFORM values).</description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>STAT</name>
          <description>SPIFI status register</description>
          <addressOffset>0x1C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x2000000</resetValue>
          <resetMask>0xFF000033</resetMask>
          <fields>
            <field>
              <name>MCINIT</name>
              <description>This bit is set when software successfully writes the Memory Command register, and is cleared by Reset or by writing a 1 to the RESET bit in this register.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CMD</name>
              <description>This bit is 1 when the Command register is written. It is cleared by a hardware reset, a write to the RESET bit in this register, or the deassertion of CS which indicates that the command has completed communication with the SPI Flash.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RESET</name>
              <description>Write a 1 to this bit to abort a current command or memory mode. This bit is cleared when the hardware is ready for a new command to be written to the Command register.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>INTRQ</name>
              <description>This bit reflects the SPIFI interrupt request. Write a 1 to this bit to clear it. This bit is set when a CMD was previously 1 and has been cleared due to the deassertion of CS.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>VERSION</name>
              <description>no description available</description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>DMA0</name>
      <description>dma</description>
      <groupName>DMA</groupName>
      <baseAddress>0x40085000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>0x530</size>
        <usage>registers</usage>
      </addressBlock>
      <interrupt>
        <name>DMA0</name>
        <value>1</value>
      </interrupt>
      <registers>
        <register>
          <name>CTRL</name>
          <description>DMA control.</description>
          <addressOffset>0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0x1</resetMask>
          <fields>
            <field>
              <name>ENABLE</name>
              <description>DMA controller master enable. 0: Disabled. The DMA controller is disabled. This clears any triggers that were asserted at the point when disabled, but does not prevent re-triggering when the DMA controller is re-enabled. 1: Enabled. The DMA controller is enabled.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTSTAT</name>
          <description>Interrupt status.</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0</resetValue>
          <resetMask>0x6</resetMask>
          <fields>
            <field>
              <name>ACTIVEINT</name>
              <description>Summarizes whether any enabled interrupts (other than error interrupts) are pending. 0: Not pending. No enabled interrupts are pending. 1: Pending. At least one enabled interrupt is pending.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ACTIVEERRINT</name>
              <description>Summarizes whether any error interrupts are pending. 0: Not pending. No error interrupts are pending. 1: Pending. At least one error interrupt is pending.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SRAMBASE</name>
          <description>SRAM address of the channel configuration table.</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0xFFFFFE00</resetMask>
          <fields>
            <field>
              <name>OFFSET</name>
              <description>Address bits 31:9 of the beginning of the DMA descriptor table. For 19 channels, the table must begin on a 512 byte boundary. The SRAMBASE register must be configured with an address (preferably in on-chip SRAM) where DMA descriptors will be stored.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>23</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ENABLESET0</name>
          <description>Channel Enable read and Set for all DMA channels</description>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ENA</name>
              <description>Enable for DMA channels. Bit n enables or disables DMA channel n. 0: disabled. 1: enabled.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ENABLECLR0</name>
          <description>Channel Enable Clear for all DMA channels.</description>
          <addressOffset>0x28</addressOffset>
          <size>32</size>
          <access>write-only</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>CLR</name>
              <description>Writing ones to this register clears the corresponding bits in ENABLESET0. Bit n clears the channel enable bit n.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ACTIVE0</name>
          <description>Channel Active status for all DMA channels.</description>
          <addressOffset>0x30</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ACT</name>
              <description>Active flag for DMA channel n. Bit n corresponds to DMA channel n. 0: not active. 1: active.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>BUSY0</name>
          <description>Channel Busy status for all DMA channels.</description>
          <addressOffset>0x38</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BSY</name>
              <description>Busy flag for DMA channel n. Bit n corresponds to DMA channel n. 0 : not busy. 1: busy.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ERRINT0</name>
          <description>Error Interrupt status for all DMA channels.</description>
          <addressOffset>0x40</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ERR</name>
              <description>Error Interrupt flag for DMA channel n. Bit n corresponds to DMA channel n. 0: error interrupt is not active. 1: error interrupt is active.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTENSET0</name>
          <description>Interrupt Enable read and Set for all DMA channels.</description>
          <addressOffset>0x48</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>INTEN</name>
              <description>Interrupt Enable read and set for DMA channel n. Bit n corresponds to DMA channel n. 0: interrupt for DMA channel is disabled. 1: interrupt for DMA channel is enabled.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTENCLR0</name>
          <description>Interrupt Enable Clear for all DMA channels.</description>
          <addressOffset>0x50</addressOffset>
          <size>32</size>
          <access>write-only</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>CLR</name>
              <description>Writing ones to this register clears corresponding bits in the INTENSET0. Bit n corresponds to DMA channel n.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTA0</name>
          <description>Interrupt A status for all DMA channels.</description>
          <addressOffset>0x58</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>IA</name>
              <description>Interrupt A status for DMA channel n. Bit n corresponds to DMA channel n. 0: the DMA channel interrupt A is not active. 1: the DMA channel interrupt A is active.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTB0</name>
          <description>Interrupt B status for all DMA channels.</description>
          <addressOffset>0x60</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>IB</name>
              <description>Interrupt B status for DMA channel n. Bit n corresponds to DMA channel n. 0: the DMA channel interrupt B is not active. 1: the DMA channel interrupt B is active.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SETVALID0</name>
          <description>Set ValidPending control bits for all DMA channels.</description>
          <addressOffset>0x68</addressOffset>
          <size>32</size>
          <access>write-only</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SV</name>
              <description>SETVALID control for DMA channel n. Bit n corresponds to DMA channel n. 0: no effect. 1: sets the VALIDPENDING control bit for DMA channel n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SETTRIG0</name>
          <description>Set Trigger control bits for all DMA channels.</description>
          <addressOffset>0x70</addressOffset>
          <size>32</size>
          <access>write-only</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>TRIG</name>
              <description>Set Trigger control bit for DMA channel n. Bit n corresponds to DMA channel n. 0: no effect. 1: sets the TRIG bit for DMA channel n.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ABORT0</name>
          <description>Channel Abort control for all DMA channels.</description>
          <addressOffset>0x78</addressOffset>
          <size>32</size>
          <access>write-only</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>ABORTCTRL</name>
              <description>Abort control for DMA channel 0. Bit n corresponds to DMA channel n. 0: no effect. 1: aborts DMA operations on channel n.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <cluster>
          <dim>19</dim>
          <dimIncrement>0x10</dimIncrement>
          <name>CHANNEL[%s]</name>
          <description>no description available</description>
          <addressOffset>0x400</addressOffset>
          <register>
            <name>CFG</name>
            <description>Configuration register for DMA channel x</description>
            <addressOffset>0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0</resetValue>
            <resetMask>0x7CF73</resetMask>
            <fields>
              <field>
                <name>PERIPHREQEN</name>
                <description>Peripheral request Enable. If a DMA channel is used to perform a memory-to-memory move, any peripheral DMA request associated with that channel can be disabled to prevent any interaction between the peripheral and the DMA controller. 0 Disabled. Peripheral DMA requests are disabled. 1 Enabled. Peripheral DMA requests are enabled.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>HWTRIGEN</name>
                <description>Hardware Triggering Enable for this channel. 0 Disabled. Hardware triggering is not used. 1 Enabled. Use hardware triggering.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIGPOL</name>
                <description>Trigger Polarity. Selects the polarity of a hardware trigger for this channel. 0 Active low - falling edge. Hardware trigger is active low or falling edge triggered, based on TRIGTYPE. 1 Active high - rising edge. Hardware trigger is active high or rising edge triggered, based on TRIGTYPE.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIGTYPE</name>
                <description>Trigger Type. Selects hardware trigger as edge triggered or level triggered. 0 Edge. Hardware trigger is edge triggered. Transfers will be initiated and completed, as specified for a single trigger. 1 Level. Hardware trigger is level triggered. Note that when level triggering without burst (BURSTPOWER = 0) is selected, only hardware triggers should be used on that channel. Transfers continue as long as the trigger level is asserted. Once the trigger is de-asserted, the transfer will be paused until the trigger is, again, asserted. However, the transfer will not be paused until any remaining transfers within the current BURSTPOWER length are completed.</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIGBURST</name>
                <description>Trigger Burst. Selects whether hardware triggers cause a single or burst transfer. 0 Single transfer. Hardware trigger causes a single transfer. 1 Burst transfer. When the trigger for this channel is set to edge triggered, a hardware trigger causes a burst transfer, as defined by BURSTPOWER. When the trigger for this channel is set to level triggered, a hardware trigger causes transfers to continue as long as the trigger is asserted, unless the transfer is complete.</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>BURSTPOWER</name>
                <description>Burst Power is used in two ways. It always selects the address wrap size when SRCBURSTWRAP and/or DSTBURSTWRAP modes are selected (see descriptions elsewhere in this register). When the TRIGBURST field elsewhere in this register = 1, Burst Power selects how many transfers are performed for each DMA trigger. This can be used, for example, with peripherals that contain a FIFO that can initiate a DMA operation when the FIFO reaches a certain level. 0000: Burst size = 1 (2^0). 0001: Burst size = 2 (2^1). 0010: Burst size = 4 (2^2). ... 1010: Burst size = 1024 (2^10). This corresponds to the maximum supported transfer count. others: not supported. The total transfer length as defined in the XFERCOUNT bits in the XFERCFG register must be an even multiple of the burst size.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>SRCBURSTWRAP</name>
                <description>Source Burst Wrap. When enabled, the source data address for the DMA is wrapped , meaning that the source address range for each burst will be the same. As an example, this could be used to read several sequential registers from a peripheral for each DMA burst, reading the same registers again for each burst. 0 Disabled. Source burst wrapping is not enabled for this DMA channel. 1 Enabled. Source burst wrapping is enabled for this DMA channel.</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>DSTBURSTWRAP</name>
                <description>Destination Burst Wrap. When enabled, the destination data address for the DMA is wrapped , meaning that the destination address range for each burst will be the same. As an example, this could be used to write several sequential registers to a peripheral for each DMA burst, writing the same registers again for each burst. 0 Disabled. Destination burst wrapping is not enabled for this DMA channel. 1 Enabled. Destination burst wrapping is enabled for this DMA channel.</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>CHPRIORITY</name>
                <description>Priority of this channel when multiple DMA requests are pending. Eight priority levels are supported: 0x0 = highest priority. 0x7 = lowest priority.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>3</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CTLSTAT</name>
            <description>Control and status register for DMA channel x</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0</resetValue>
            <resetMask>0x5</resetMask>
            <fields>
              <field>
                <name>VALIDPENDING</name>
                <description>Valid pending flag for this channel. This bit is set when a 1 is written to the corresponding bit in the related SETVALID register when CFGVALID = 1 for the same channel. 0 No effect. No effect on DMA operation. 1 Valid pending.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>TRIG</name>
                <description>Trigger flag. Indicates that the trigger for this channel is currently set. This bit is cleared at the end of an entire transfer or upon reload when CLRTRIG = 1. 0 Not triggered. The trigger for this DMA channel is not set. DMA operations will not be carried out. 1 Triggered. The trigger for this DMA channel is set. DMA operations will be carried out.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>XFERCFG</name>
            <description>Transfer configuration register for DMA channel x</description>
            <addressOffset>0x8</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0</resetValue>
            <resetMask>0x3FFF33F</resetMask>
            <fields>
              <field>
                <name>CFGVALID</name>
                <description>Configuration Valid flag. This bit indicates whether the current channel descriptor is valid and can potentially be acted upon, if all other activation criteria are fulfilled. 0 Not valid. The channel descriptor is not considered valid until validated by an associated SETVALID0 setting. 1 Valid. The current channel descriptor is considered valid.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>RELOAD</name>
                <description>Indicates whether the channel s control structure will be reloaded when the current descriptor is exhausted. Reloading allows ping-pong and linked transfers. 0 Disabled. Do not reload the channels control structure when the current descriptor is exhausted. 1 Enabled. Reload the channels control structure when the current descriptor is exhausted.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>SWTRIG</name>
                <description>Software Trigger. 0 Not set. When written by software, the trigger for this channel is not set. A new trigger, as defined by the HWTRIGEN, TRIGPOL, and TRIGTYPE will be needed to start the channel. 1 Set. When written by software, the trigger for this channel is set immediately. This feature should not be used with level triggering when TRIGBURST = 0.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>CLRTRIG</name>
                <description>Clear Trigger. 0 Not cleared. The trigger is not cleared when this descriptor is exhausted. If there is a reload, the next descriptor will be started. 1 Cleared. The trigger is cleared when this descriptor is exhausted.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>SETINTA</name>
                <description>Set Interrupt flag A for this channel. There is no hardware distinction between interrupt A and B. They can be used by software to assist with more complex descriptor usage. By convention, interrupt A may be used when only one interrupt flag is needed. 0 No effect. 1 Set. The INTA flag for this channel will be set when the current descriptor is exhausted.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>SETINTB</name>
                <description>Set Interrupt flag B for this channel. There is no hardware distinction between interrupt A and B. They can be used by software to assist with more complex descriptor usage. By convention, interrupt A may be used when only one interrupt flag is needed. 0 No effect. 1 Set. The INTB flag for this channel will be set when the current descriptor is exhausted.</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>WIDTH</name>
                <description>Transfer width used for this DMA channel. 0x0 8-bit. 8-bit transfers are performed (8-bit source reads and destination writes). 0x1 16-bit. 6-bit transfers are performed (16-bit source reads and destination writes). 0x2 32-bit. 32-bit transfers are performed (32-bit source reads and destination writes). 0x3 Reserved. Reserved setting, do not use.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>SRCINC</name>
                <description>Determines whether the source address is incremented for each DMA transfer. 0x0 No increment. The source address is not incremented for each transfer. This is the usual case when the source is a peripheral device. 0x1 1 x width. The source address is incremented by the amount specified by Width for each transfer. This is the usual case when the source is memory. 0x2 2 x width. The source address is incremented by 2 times the amount specified by Width for each transfer. 0x3 4 x width. The source address is incremented by 4 times the amount specified by Width for each transfer.</description>
                <bitOffset>12</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>DSTINC</name>
                <description>Determines whether the destination address is incremented for each DMA transfer. 0x0 No increment. The destination address is not incremented for each transfer. This is the usual case when the destination is a peripheral device. 0x1 1 x width. The destination address is incremented by the amount specified by Width for each transfer. This is the usual case when the destination is memory. 0x2 2 x width. The destination address is incremented by 2 times the amount specified by Width for each transfer. 0x3 4 x width. The destination address is incremented by 4 times the amount specified by Width for each transfer.</description>
                <bitOffset>14</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>XFERCOUNT</name>
                <description>Total number of transfers to be performed, minus 1 encoded. The number of bytes transferred is: (XFERCOUNT + 1) x data width (as defined by the WIDTH field). Remark: The DMA controller uses this bit field during transfer to count down. Hence, it cannot be used by software to read back the size of the transfer, for instance, in an interrupt handler. 0x0 = a total of 1 transfer will be performed. 0x1 = a total of 2 transfers will be performed. ... 0x3FF = a total of 1,024 transfers will be performed.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>10</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>RESERVED0</name>
            <description>Reserved</description>
            <addressOffset>0xC</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>DUMMYWORD</name>
                <description>Reserved. The value read from a reserved bit is not defined.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
      </registers>
    </peripheral>
    <peripheral>
      <name>AES0</name>
      <description>This is the description of component aes256 It is AES 128-192-256 with GCM mode. More details will follow.</description>
      <groupName>AES</groupName>
      <baseAddress>0x40086000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>0xA0</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>CFG</name>
          <description>Configuration</description>
          <addressOffset>0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x10001</resetValue>
          <resetMask>0x33303F7</resetMask>
          <fields>
            <field>
              <name>PROC_EN</name>
              <description>Processing Mode Enable. 00: Reserved. 01: Encrypt/Decrypt Only. 10: GF128 Hash Only. 11: Encrypt/Decrypt and Hash.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GF128_SEL</name>
              <description>GF128 Select Mode. 0: GF128 Hash Input Text. 1: GF128 Hash Output Text.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>INTEXT_BSWAP</name>
              <description>Input Text Byte Swap</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>INTEXT_WSWAP</name>
              <description>Input Text Word Swap</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OUTTEXT_BSWAP</name>
              <description>Output Text Byte Swap</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OUTTEXT_WSWAP</name>
              <description>Output Text Word Swap</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>KEY_CFG</name>
              <description>Key Configuration. 00: 128 Bit Key. 01: 192 Bit Key. 10: 256 Bit Key. 11: Reserved.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>INBLK_SEL</name>
              <description>Input Block Selection From: 00: Reserved. 01: Input Text. 10: Holding. 11: Input Text XOR Holding.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>HOLD_SEL</name>
              <description>Holding Select From: 00: Counter. 01: Input Text. 10: Output Block. 11: Input Text XOR Output Block.</description>
              <bitOffset>20</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OUTTEXT_SEL</name>
              <description>Output Text Selection From: 00: Output Block. 01: Output Block XOR Input Text. 10: Output Block XOR Holding. 11: Reserved.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CMD</name>
          <description>Command</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0x313</resetMask>
          <fields>
            <field>
              <name>COPY_SKEY</name>
              <description>Copies Secret Key and enables cipher. Secret key is typically held in OTP or other secure memory.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>COPY_TO_Y</name>
              <description>Copies Output Text to GF128 Y. Typically used for GCM where the Hash requires a Y input which is the result of an ECB encryption of 0s. Should be performed after encryption of 0s.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SWITCH_MODE</name>
              <description>Switches mode from Forward to Reverse or from Reverse to Forward. Must wait for Idle after command. Typically used for non-counter modes (ECB, CBC, CFB, OFB) to switch from forward to reverse mode for decryption.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ABORT</name>
              <description>Aborts Encrypt/Decrypt and GF128 Hash, clears INTEXT, clears OUTTEXT, and clears HOLDING</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>WIPE</name>
              <description>Performs Abort, clears KEY, disables cipher, and clears GF128_Y</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>STAT</name>
          <description>Status</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x3</resetValue>
          <resetMask>0x37</resetMask>
          <fields>
            <field>
              <name>IDLE</name>
              <description>When set, all state machines are idle</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>IN_READY</name>
              <description>When set, input Text can be written</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OUT_READY</name>
              <description>When set, output Text can be read</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>REVERSE</name>
              <description>When set, Cipher in reverse mode</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>KEY_VALID</name>
              <description>When set, Key is valid</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CTR_INCR</name>
          <description>Counter Increment. Increment value for HOLDING when in Counter modes</description>
          <addressOffset>0xC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CTR_INCR</name>
              <description>Counter Increment. Increment value for HOLDING when in Counter modes</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>8</dim>
          <dimIncrement>0x4</dimIncrement>
          <name>KEY[%s]</name>
          <description>Bits of the AES key</description>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <access>write-only</access>
          <resetValue>0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>KEY</name>
              <description>Contains the bits of the AES key.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>4</dim>
          <dimIncrement>0x4</dimIncrement>
          <name>INTEXT[%s]</name>
          <description>Input text bits</description>
          <addressOffset>0x40</addressOffset>
          <size>32</size>
          <access>write-only</access>
          <resetValue>0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>INTEXT</name>
              <description>Contains bits of the AES key.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>4</dim>
          <dimIncrement>0x4</dimIncrement>
          <name>HOLDING[%s]</name>
          <description>Holding register bits</description>
          <addressOffset>0x50</addressOffset>
          <size>32</size>
          <access>write-only</access>
          <resetValue>0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>HOLDING</name>
              <description>Contains the first word (bits 31:0) of the 128 bit Holding value.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>4</dim>
          <dimIncrement>0x4</dimIncrement>
          <name>OUTTEXT[%s]</name>
          <description>Output text bits</description>
          <addressOffset>0x60</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>OUTTEXT</name>
              <description>Contains the bits of the 128 bit Output text data.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>4</dim>
          <dimIncrement>0x4</dimIncrement>
          <name>GF128_Y[%s]</name>
          <description>Y bits input of GF128 hash</description>
          <addressOffset>0x70</addressOffset>
          <size>32</size>
          <access>write-only</access>
          <resetValue>0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>GF128_Y</name>
              <description>Contains the bits of the Y input of GF128 hash.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>4</dim>
          <dimIncrement>0x4</dimIncrement>
          <name>GF128_Z[%s]</name>
          <description>Result bits of GF128 hash</description>
          <addressOffset>0x80</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>GF128_Z</name>
              <description>Contains bits of the result of GF128 hash.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>4</dim>
          <dimIncrement>0x4</dimIncrement>
          <name>GCM_TAG[%s]</name>
          <description>GCM Tag bits</description>
          <addressOffset>0x90</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>GCM_TAG</name>
              <description>Contains bits of the 128 bit GCM tag.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>ADC0</name>
      <description>This is the description of component adc It is General Purpose ADC. More details will follow.</description>
      <groupName>ADC</groupName>
      <baseAddress>0x40089000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>0x78</size>
        <usage>registers</usage>
      </addressBlock>
      <interrupt>
        <name>ADC0_SEQA</name>
        <value>32</value>
      </interrupt>
      <interrupt>
        <name>ADC0_SEQB</name>
        <value>33</value>
      </interrupt>
      <interrupt>
        <name>ADC0_THCMP</name>
        <value>34</value>
      </interrupt>
      <registers>
        <register>
          <name>CTRL</name>
          <description>ADC Control register. Contains the clock divide value, resolution selection, sampling time selection, and mode controls.</description>
          <addressOffset>0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xE07</resetValue>
          <resetMask>0x7FFF</resetMask>
          <fields>
            <field>
              <name>CLKDIV</name>
              <description>Reserved. No changes to this fiedl are necessary.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ASYNMODE</name>
              <description>Select clock mode. 0: Synchronous mode. Not Supported. 1: Asynchronous mode. The ADC clock is based on the output of the ADC clock divider ADCCLKSEL in the SYSCON block.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RESOL</name>
              <description>The number of bits of ADC resolution. Note, whatever the resolution setting, the ADC data will always be shifted to use the MSBs of any ADC data words. Accuracy can be reduced to achieve higher conversion rates. A single conversion (including one conversion in a burst or sequence) requires the selected number of bits of resolution plus 3 ADC clocks. Remark: This field must only be altered when the ADC is fully idle. Changing it during any kind of ADC operation may have unpredictable results. Remark: ADC clock frequencies for various resolutions must not exceed: - 5x the system clock rate for 12-bit resolution. - 4.3x the system clock rate for 10-bit resolution. - 3.6x the system clock for 8-bit resolution. - 3x the bus clock rate for 6-bit resolution. Settings: 0x3: 6-bit resolution. An ADC conversion requires 9 ADC clocks, plus any clocks specified by the TSAMP field; 0x2: 8-bit resolution. An ADC conversion requires 11 ADC clocks, plus any clocks specified by the TSAMP field; 0x1:10-bit resolution. An ADC conversion requires 13 ADC clocks, plus any clocks specified by the TSAMP field; 0x0: 12-bit resolution. An ADC conversion requires 15 ADC clocks, plus any clocks specified by the TSAMP field.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RESOL_MASK_DIS</name>
              <description>According RESOL bit LSB bits are automatickly masked if RESOL_MASK_DIS = 0. If RESOL_MASK_DIS = 1, the 12bits comming from ADC are directly connect to register RESULT</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TSAMP</name>
              <description>Sample Time. The default sampling period (TSAMP = 000 ) at the start of each conversion is 2.5 ADC clock periods. Depending on a variety of factors, including operating conditions and the output impedance of the analog source, longer sampling times may be required. The TSAMP field should stay to default during application The TSAMP field specifies the number of additional ADC clock cycles, from zero to seven, by which the sample period will be extended. The total conversion time will increase by the same number of clocks. 000 - The sample period will be the default 2.5 ADC clocks. A complete conversion with 12-bits of accuracy will require 15 clocks. 001- The sample period will be extended by one ADC clock to a total of 3.5 clock periods. A complete 12-bit conversion will require 16 clocks. 010 - The sample period will be extended by two clocks to 4.5 ADC clock cycles. A complete 12-bit conversion will require 17 ADC clocks. ... 111 - The sample period will be extended by seven clocks to 9.5 ADC clock cycles. A complete 12-bit conversion will require 22 ADC clocks.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SEQ_CTRLA</name>
          <description>ADC Conversion Sequence-A control register: Controls triggering and channel selection for conversion sequence-A. Also specifies interrupt mode for sequence-A.</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0xDA0FF0FF</resetMask>
          <fields>
            <field>
              <name>CHANNELS</name>
              <description>Selects which one or more of the ADC channels will be sampled and converted when this sequence is launched. A 1 in any bit of this field will cause the corresponding channel to be included in the conversion sequence, where bit 0 corresponds to channel 0, bit 1 to channel 1 and so forth. Bit 6 is channel 6; the supply monitor. Bit 7 is channel 7; the temperature sensor. When this conversion sequence is triggered, either by a hardware trigger or via software command, ADC conversions will be performed on each enabled channel, in sequence, beginning with the lowest-ordered channel. Remark: This field can ONLY be changed while SEQA_ENA (bit 31) is LOW. It is allowed to change this field and set bit 31 in the same write.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TRIGGER</name>
              <description>Selects which of the available hardware trigger sources will cause this conversion sequence to be initiated. Program the trigger input number in this field. Setting: 0 : PINT0; 1 : PWM8; 2 : PWM9; 3 : ARM TX EV. Remark: In order to avoid generating a spurious trigger, it is recommended writing to+I32 this field only when SEQA_ENA (bit 31) is low. It is safe to change this field and set bit 31 in the same write.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TRIGPOL</name>
              <description>Select the polarity of the selected input trigger for this conversion sequence. Remark: In order to avoid generating a spurious trigger, it is recommended writing to this field only when SEQA_ENA (bit 31) is low. It is safe to change this field and set bit 31 in the same write. 0: A negative edge launches the conversion sequence on the selected trigger input. 1: A positive edge launches the conversion sequence on the selected trigger input.</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SYNCBYPASS</name>
              <description>Setting this bit allows the hardware trigger input to bypass synchronization flip-flop stages and therefore shorten the time between the trigger input signal and the start of a conversion. There are slightly different criteria for whether or not this bit can be set depending on the clock operating mode: Synchronous mode (the ASYNMODE in the CTRL register = 0): Synchronization may be bypassed (this bit may be set) if the selected trigger source is already synchronous with the main system clock (eg. coming from an on-chip, system-clock-based timer). Whether this bit is set or not, a trigger pulse must be maintained for at least one system clock period. Asynchronous mode (the ASYNMODE in the CTRL register = 1): Synchronization may be bypassed (this bit may be set) if it is certain that the duration of a trigger input pulse will be at least one cycle of the ADC clock (regardless of whether the trigger comes from and on-chip or off-chip source). If this bit is NOT set, the trigger pulse must at least be maintained for one system clock period. 0: Enable trigger synchronization. The hardware trigger bypass is not enabled. 1: Bypass trigger synchronization. The hardware trigger bypass is enabled.</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>START_BEHAVIOUR</name>
              <description>the Start behavior used on gpadc: writing 0 for repeat start after each input selection changed, used for seqA with multiple inputs. writing 1 for continuous start, this bit is only if seqA is used to have full speed on a single input. Remark: with 0 the word rate is divided by two.</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>START</name>
              <description>Writing a 1 to this field will launch one pass through this conversion sequence. The behavior will be identical to a sequence triggered by a hardware trigger. Do not write 1 to this bit if the BURST bit is set. Remark: This bit is only set to a 1 momentarily when written to launch a conversion sequence. It will consequently always read back as a zero.</description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>BURST</name>
              <description>Writing a 1 to this bit will cause this conversion sequence to be continuously cycled through. Other sequence A triggers will be ignored while this bit is set. Repeated conversions can be halted by clearing this bit. The sequence currently in progress will be completed before conversions are terminated. Note that a new sequence could begin just before BURST is cleared.</description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SINGLESTEP</name>
              <description>When this bit is set, a hardware trigger or a write to the START bit will launch a single conversion on the next channel in the sequence instead of the default response of launching an entire sequence of conversions. Once all of the channels comprising a sequence have been converted, a subsequent trigger will repeat the sequence beginning with the first enabled channel. Interrupt generation will still occur either after each individual conversion or at the end of the entire sequence, depending on the state of the MODE bit.</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MODE</name>
              <description>Indicates whether the primary method for retrieving conversion results for this sequence will be accomplished via reading the global data register (SEQA_GDAT) at the end of each conversion, or the individual channel result registers at the end of the entire sequence. Impacts when conversion-complete interrupt/DMA trigger for sequence-A will be generated and which overrun conditions contribute to an overrun interrupt as described below. 0: End of conversion. The sequence A interrupt/DMA trigger will be set at the end of each individual ADC conversion performed under sequence A. This flag will mirror the DATAVALID bit in the SEQA_GDAT register. The OVERRUN bit in the SEQA_GDAT register will contribute to generation of an overrun interrupt/DMA trigger if enabled. 1: End of sequence. The sequence A interrupt/DMA trigger will be set when the entire set of sequence-A conversions completes. This flag will need to be explicitly cleared by software or by the DMA-clear signal in this mode. The OVERRUN bit in the SEQA_GDAT register will NOT contribute to generation of an overrun interrupt/DMA trigger since it is assumed this register may not be utilized in this mode.</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SEQ_ENA</name>
              <description>Sequence Enable. In order to avoid spuriously triggering the sequence, care should be taken to only set the SEQA_ENA bit when the selected trigger input is in its INACTIVE state (as defined by the TRIGPOL bit). If this condition is not met, the sequence will be triggered immediately upon being enabled. Remark: In order to avoid spuriously triggering the sequence, care should be taken to only set the SEQA_ENA bit when the selected trigger input is in its INACTIVE state (as defined by the TRIGPOL bit). If this condition is not met, the sequence will be triggered immediately upon being enabled. 0: Disabled. Sequence A is disabled. Sequence A triggers are ignored. If this bit is cleared while sequence A is in progress, the sequence will be halted at the end of the current conversion. After the sequence is re-enabled, a new trigger will be required to restart the sequence beginning with the next enabled channel. 1: Enabled. Sequence A is enabled.</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SEQ_GDATA</name>
          <description>ADC Sequence-A Global Data register. This register contains the result of the most recent ADC conversion performed under sequence-A.</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0</resetValue>
          <resetMask>0xFC0FFFF0</resetMask>
          <fields>
            <field>
              <name>RESULT</name>
              <description>This field contains the 12-bit ADC conversion result from the most recent conversion performed under conversion sequence associated with this register. DATAVALID = 1 indicates that this result has not yet been read. If less than 12-bit resolultion is used the ADC result occupies the upper MSBs and unused LSBs should be ignored.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>12</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>THCMPRANGE</name>
              <description>Threshold Range Comparison result. 0x0 = In Range: The last completed conversion was greater than or equal to the value programmed into the designated LOW threshold register (THRn_LOW) but less than or equal to the value programmed into the designated HIGH threshold register (THRn_HIGH). 0x1 = Below Range: The last completed conversion on was less than the value programmed into the designated LOW threshold register (THRn_LOW). 0x2 = Above Range: The last completed conversion was greater than the value programmed into the designated HIGH threshold register (THRn_HIGH). 0x3 = Reserved.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>THCMPCROSS</name>
              <description>Threshold Crossing Comparison result. 0x0 = No threshold Crossing detected: The most recent completed conversion on this channel had the same relationship (above or below) to the threshold value established by the designated LOW threshold register (THRn_LOW) as did the previous conversion on this channel. 0x1 = Reserved. 0x2 = Downward Threshold Crossing Detected. Indicates that a threshold crossing in the downward direction has occurred - i.e. the previous sample on this channel was above the threshold value established by the designated LOW threshold register (THRn_LOW) and the current sample is below that threshold. 0x3 = Upward Threshold Crossing Detected. Indicates that a threshold crossing in the upward direction has occurred - i.e. the previous sample on this channel was below the threshold value established by the designated LOW threshold register (THRn_LOW) and the current sample is above that threshold.</description>
              <bitOffset>18</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>CHN</name>
              <description>These bits contain the channel from which the RESULT bits were converted (e.g. 0000 identifies channel 0, 0001 channel 1, etc.).</description>
              <bitOffset>26</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>OVERRUN</name>
              <description>This bit is set if a new conversion result is loaded into the RESULT field before a previous result has been read - i.e. while the DATAVALID bit is set. This bit is cleared, along with the DATAVALID bit, whenever this register is read. This bit will contribute to an overrun interrupt/DMA trigger if the MODE bit (in SEQA_CTRL) for the corresponding sequence is set to 0 (and if the overrun interrupt is enabled).</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>DATAVALID</name>
              <description>This bit is set to 1 at the end of each conversion when a new result is loaded into the RESULT field. It is cleared whenever this register is read. This bit will cause a conversion-complete interrupt for the corresponding sequence if the MODE bit (in SEQA_CTRL) for that sequence is set to 0 (and if the interrupt is enabled).</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>8</dim>
          <dimIncrement>0x4</dimIncrement>
          <name>DAT[%s]</name>
          <description>ADC Channel X [0:7] Data register. This register contains the result of the most recent conversion completed on channel X [0:7] .</description>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0</resetValue>
          <resetMask>0xFC0FFFF0</resetMask>
          <fields>
            <field>
              <name>RESULT</name>
              <description>This field contains the 12-bit ADC conversion result from the most recent conversion performed for this channel under conversion sequence associated with this register. DATAVALID = 1 indicates that this result has not yet been read. If less than 12-bit resolultion is used the ADC result occupies the upper MSBs and unused LSBs should be ignored.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>12</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>THCMPRANGE</name>
              <description>Threshold Range Comparison result for this channel. 0x0 = In Range: The last completed conversion was greater than or equal to the value programmed into the designated LOW threshold register (THRn_LOW) but less than or equal to the value programmed into the designated HIGH threshold register (THRn_HIGH). 0x1 = Below Range: The last completed conversion on was less than the value programmed into the designated LOW threshold register (THRn_LOW). 0x2 = Above Range: The last completed conversion was greater than the value programmed into the designated HIGH threshold register (THRn_HIGH). 0x3 = Reserved.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>THCMPCROSS</name>
              <description>Threshold Crossing Comparison result for this channel. 0x0 = No threshold Crossing detected: The most recent completed conversion on this channel had the same relationship (above or below) to the threshold value established by the designated LOW threshold register (THRn_LOW) as did the previous conversion on this channel. 0x1 = Reserved. 0x2 = Downward Threshold Crossing Detected. Indicates that a threshold crossing in the downward direction has occurred - i.e. the previous sample on this channel was above the threshold value established by the designated LOW threshold register (THRn_LOW) and the current sample is below that threshold. 0x3 = Upward Threshold Crossing Detected. Indicates that a threshold crossing in the upward direction has occurred - i.e. the previous sample on this channel was below the threshold value established by the designated LOW threshold register (THRn_LOW) and the current sample is above that threshold.</description>
              <bitOffset>18</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>CHANNEL</name>
              <description>This field is hard-coded to contain the channel number that this particular register relates to (i.e. this field will contain 0b0000 for the DAT0 register, 0b0001 for the DAT1 register, etc)</description>
              <bitOffset>26</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>OVERRUN</name>
              <description>This bit is set if a new conversion result is loaded into the RESULT field before a previous result has been read - i.e. while the DATAVALID bit is set. This bit is cleared, along with the DATAVALID bit, whenever this register is read or when the data related to this channel is read from the global SEQA_GDAT register. This bit will contribute to an overrun interrupt/DMA trigger if the MODE bit (in SEQA_CTRL) for the corresponding sequence is set to 0 (and if the overrun interrupt is enabled).</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>DATAVALID</name>
              <description>This bit is set to 1 at the end of each conversion for this channel when a new result is loaded into the RESULT field. It is cleared whenever this register is read or when the data related to this channel is read from the global SEQA_GDAT regsiter.</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>THR0_LOW</name>
          <description>ADC Low Compare Threshold register 0: Contains the lower threshold level for automatic threshold comparison for any channels linked to threshold pair 0.</description>
          <addressOffset>0x50</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0xFFF0</resetMask>
          <fields>
            <field>
              <name>THRLOW</name>
              <description>Low threshold value against which ADC results will be compared</description>
              <bitOffset>4</bitOffset>
              <bitWidth>12</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>THR1_LOW</name>
          <description>ADC Low Compare Threshold register 1: Contains the lower threshold level for automatic threshold comparison for any channels linked to threshold pair 1.</description>
          <addressOffset>0x54</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0xFFF0</resetMask>
          <fields>
            <field>
              <name>THRLOW</name>
              <description>Low threshold value against which ADC results will be compared</description>
              <bitOffset>4</bitOffset>
              <bitWidth>12</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>THR0_HIGH</name>
          <description>ADC High Compare Threshold register 0: Contains the upper threshold level for automatic threshold comparison for any channels linked to threshold pair 0.</description>
          <addressOffset>0x58</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0xFFF0</resetMask>
          <fields>
            <field>
              <name>THRHIGH</name>
              <description>High threshold value against which ADC results will be compared</description>
              <bitOffset>4</bitOffset>
              <bitWidth>12</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>THR1_HIGH</name>
          <description>ADC High Compare Threshold register 1: Contains the upper threshold level for automatic threshold comparison for any channels linked to threshold pair 1.</description>
          <addressOffset>0x5C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0xFFF0</resetMask>
          <fields>
            <field>
              <name>THRHIGH</name>
              <description>High threshold value against which ADC results will be compared</description>
              <bitOffset>4</bitOffset>
              <bitWidth>12</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CHAN_THRSEL</name>
          <description>ADC Channel-Threshold Select register. Specifies which set of threshold compare registers are to be used for each channel</description>
          <addressOffset>0x60</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>CH0_THRSEL</name>
              <description>Threshold select for channel 0. 0: Threshold 0. Results for this channel will be compared against the threshold levels indicated in the THR0_LOW and THR0_HIGH registers. 1: Threshold 1. Results for this channel will be compared against the threshold levels indicated in the THR1_LOW and THR1_HIGH registers.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CH1_THRSEL</name>
              <description>Threshold select for channel 1. See description for channel 0.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CH2_THRSEL</name>
              <description>Threshold select for channel 2. See description for channel 0.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CH3_THRSEL</name>
              <description>Threshold select for channel 3. See description for channel 0.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CH4_THRSEL</name>
              <description>Threshold select for channel 4. See description for channel 0.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CH5_THRSEL</name>
              <description>Threshold select for channel 5. See description for channel 0.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CH6_THRSEL</name>
              <description>Threshold select for channel 6. See description for channel 0.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CH7_THRSEL</name>
              <description>Threshold select for channel 7. See description for channel 0.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTEN</name>
          <description>ADC Interrupt Enable register. This register contains enable bits that enable the sequence-A, sequence-B, threshold compare and data overrun interrupts to be generated.</description>
          <addressOffset>0x64</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0x7FFFD</resetMask>
          <fields>
            <field>
              <name>SEQA_INTEN</name>
              <description>Sequence A interrupt enable. 0: Disabled. The sequence A interrupt/DMA trigger is disabled. 1: Enabled. The sequence A interrupt/DMA trigger is enabled and will be asserted either upon completion of each individual conversion performed as part of sequence A, or upon completion of the entire A sequence of conversions, depending on the MODE bit in the SEQA_CTRL register.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OVR_INTEN</name>
              <description>Overrun interrupt enable. 0: Disabled. The overrun interrupt is disabled. 1: Enabled. The overrun interrupt is enabled. Detection of an overrun condition on any of the 12 channel data registers will cause an overrun interrupt/DMA trigger. In addition, if the MODE bit for a particular sequence is 0, then an overrun in the global data register for that sequence will also cause this interrupt/DMA trigger to be asserted.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ADCMPINTEN0</name>
              <description>Threshold comparison interrupt enable for channel 0. 0x0: Disabled. 0x1: Outside threshold. 0x2: Crossing threshold. 0x3: Reserved</description>
              <bitOffset>3</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ADCMPINTEN1</name>
              <description>Channel 1 threshold comparison interrupt enable. See description for channel 0.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ADCMPINTEN2</name>
              <description>Channel 2 threshold comparison interrupt enable. See description for channel 0.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ADCMPINTEN3</name>
              <description>Channel 3 threshold comparison interrupt enable. See description for channel 0.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ADCMPINTEN4</name>
              <description>Channel 4 threshold comparison interrupt enable. See description for channel 0.</description>
              <bitOffset>11</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ADCMPINTEN5</name>
              <description>Channel 5 threshold comparison interrupt enable. See description for channel 0.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ADCMPINTEN6</name>
              <description>Channel 6 threshold comparison interrupt enable. See description for channel 0.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ADCMPINTEN7</name>
              <description>Channel 7 threshold comparison interrupt enable. See description for channel 0.</description>
              <bitOffset>17</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>FLAGS</name>
          <description>ADC Flags register. Contains the four interrupt/DMA trigger flags and the individual component overrun and threshold-compare flags. (The overrun bits replicate information stored in the result registers).</description>
          <addressOffset>0x68</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0xD10FF0FF</resetMask>
          <fields>
            <field>
              <name>THCMP0</name>
              <description>Threshold comparison event on Channel 0. Set to 1 upon either an out-of-range result or a threshold-crossing result if enabled to do so in the INTEN register. This bit is cleared by writing a 1.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>THCMP1</name>
              <description>Threshold comparison event on Channel 1. See description for channel 0.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>THCMP2</name>
              <description>Threshold comparison event on Channel 2. See description for channel 0.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>THCMP3</name>
              <description>Threshold comparison event on Channel 3. See description for channel 0.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>THCMP4</name>
              <description>Threshold comparison event on Channel 4. See description for channel 0.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>THCMP5</name>
              <description>Threshold comparison event on Channel 5. See description for channel 0.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>THCMP6</name>
              <description>Threshold comparison event on Channel 6. See description for channel 0.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>THCMP7</name>
              <description>Threshold comparison event on Channel 7. See description for channel 0.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OVERRUN0</name>
              <description>Mirrors the OVERRRUN status flag from the result register for ADC channel 0</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>OVERRUN1</name>
              <description>Mirrors the OVERRRUN status flag from the result register for ADC channel 1</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>OVERRUN2</name>
              <description>Mirrors the OVERRRUN status flag from the result register for ADC channel 2</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>OVERRUN3</name>
              <description>Mirrors the OVERRRUN status flag from the result register for ADC channel 3</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>OVERRUN4</name>
              <description>Mirrors the OVERRRUN status flag from the result register for ADC channel 4</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>OVERRUN5</name>
              <description>Mirrors the OVERRRUN status flag from the result register for ADC channel 5</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>OVERRUN6</name>
              <description>Mirrors the OVERRRUN status flag from the result register for ADC channel 6</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>OVERRUN7</name>
              <description>Mirrors the OVERRRUN status flag from the result register for ADC channel 7</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>SEQA_OVR</name>
              <description>Mirrors the global OVERRUN status flag in the SEQA_GDAT register</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>SEQA_INT</name>
              <description>Sequence A interrupt/DMA trigger. If the MODE bit in the SEQA_CTRL register is 0, this flag will mirror the DATAVALID bit in the sequence A global data register (SEQA_GDAT), which is set at the end of every ADC conversion performed as part of sequence A. It will be cleared automatically when the SEQA_GDAT register is read. If the MODE bit in the SEQA_CTRL register is 1, this flag will be set upon completion of an entire A sequence. In this case it must be cleared by writing a 1 to this SEQA_INT bit. This interrupt must be enabled in the INTEN register.</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>THCMP_INT</name>
              <description>Threshold Comparison Interrupt. This bit will be set if any of the THCMP flags in the lower bits of this register are set to 1 (due to an enabled out-of-range or threshold-crossing event on any channel). Each type of threshold comparison interrupt on each channel must be individually enabled in the INTEN register to cause this interrupt. This bit will be cleared when all of the individual threshold flags are cleared via writing 1s to those bits.</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>OVR_INT</name>
              <description>Overrun Interrupt flag. Any overrun bit in any of the individual channel data registers will cause this interrupt. In addition, if the MODE bit in either of the SEQn_CTRL registers is 0 then the OVERRUN bit in the corresponding SEQn_GDAT register will also cause this interrupt. This interrupt must be enabled in the INTEN register. This bit will be cleared when all of the individual overrun bits have been cleared via reading the corresponding data registers.</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>STARTUP</name>
          <description>ADC Startup register (typically only used by the ADC API).</description>
          <addressOffset>0x6C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0x1</resetMask>
          <fields>
            <field>
              <name>ADC_ENA</name>
              <description>ADC Enable bit. This bit can only be set to a 1 by software. It is cleared automatically whenever the ADC is powered down. This bit must not be set until at least 10 microseconds after the ADC is powered up (typically by altering a system-level ADC power control bit).</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GPADC_CTRL0</name>
          <description>Second ADC Control register : ADC internal LDO (within ADC sub-system)</description>
          <addressOffset>0x70</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x28D0</resetValue>
          <resetMask>0x3FFF9</resetMask>
          <fields>
            <field>
              <name>LDO_POWER_EN</name>
              <description>LDO Power enable signal (active high). This is for the LDO within the ADC itself. There is also LDOADC controlled from PMC that is outside the ADC block. The LDOADC should have been enabled for 10usec before enabling this LDO. After enabling this LDO it is necessary to wait for 230usec, before ADC sampling is commenced, so that full accuraccy of the ADC will be obtained.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>LDO_SEL_OUT</name>
              <description>Select LDO output voltage (10mV step) [between 0.64V and 0.95V]. This is for the LDO within the ADC itself. There is also LDOADC controlled from PMC that is outside the ADC block.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PASS_ENABLE</name>
              <description>Enable pass mode when set to high. This is for the LDO within the ADC itself. There is also LDOADC controlled from PMC that is outside the ADC block.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GPADC_TSAMP</name>
              <description>Extand ADC sampling time according to source impedance 1: 0.621 kOhm 20 (default): 55 kOhm 31: 87 kOhm</description>
              <bitOffset>9</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TEST</name>
              <description>Mode selection: '00': Normal functional mode (DIV4 mode). Input range is 0 to 3.6V, although max input voltage is affected by supply voltage of the device. '01': Multiplexer test mode '10': ADC in unity gain mode. (DIV1 mode). Input range is 0 to 0.9V. Voltages above this may damage the device. '11': Not used</description>
              <bitOffset>14</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GPADC_CTRL1</name>
          <description>Third ADC Control register : ADC internal gain and offset</description>
          <addressOffset>0x74</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x80200</resetValue>
          <resetMask>0xFFFFF</resetMask>
          <fields>
            <field>
              <name>OFFSET_CAL</name>
              <description>offset_cal the setting is used within the ADC to compensate for a DC shift in values for this particular device.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>10</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GAIN_CAL</name>
              <description>gain_cal the setting is used within the ADC to compensate for any gain variation for this particular device.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>10</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>DMIC0</name>
      <description>This is the description of component dmic It is General Purpose I/O with APB bus interface. More details will follow.</description>
      <groupName>DMIC</groupName>
      <baseAddress>0x4008A000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>0x1000</size>
        <usage>registers</usage>
      </addressBlock>
      <interrupt>
        <name>DMIC0</name>
        <value>35</value>
      </interrupt>
      <interrupt>
        <name>HWVAD0</name>
        <value>36</value>
      </interrupt>
      <registers>
        <cluster>
          <dim>2</dim>
          <dimIncrement>0x100</dimIncrement>
          <name>CHANNEL[%s]</name>
          <description>no description available</description>
          <addressOffset>0</addressOffset>
          <register>
            <name>OSR</name>
            <description>Oversample Rate register 0. This register selects the oversample rate (CIC decimation rate) for the input channel.</description>
            <addressOffset>0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>OSR</name>
                <description>Selects the oversample rate for the related input channel.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DIVHFCLK</name>
            <description>DMIC Clock Register 0. This register controls the clock pre-divider for the input channel.</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0</resetValue>
            <resetMask>0xF</resetMask>
            <fields>
              <field>
                <name>PDMDIV</name>
                <description>PDM clock divider value. 0: divide by 1; 1: divide by 2; 2: divide by 3; 3: divide by 4; 4: divide by 6; 5: divide by 8; 6: divide by 12; 7: divide by 16; 8: divide by 24; 9: divide by 32; 10: divide by 48; 11: divide by 64; 12: divide by 96; 13: divide by 128; others = reserved.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>PREAC2FSCOEF</name>
            <description>Pre-Emphasis Filter Coefficient for 2 FS register 0. This register seclects the pre-emphasis filter coeffcient for the input channel when 2 FS mode is used.</description>
            <addressOffset>0x8</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0</resetValue>
            <resetMask>0x3</resetMask>
            <fields>
              <field>
                <name>COMP</name>
                <description>Pre-emphasis filer coefficient for 2 FS mode. 0: Compensation = 0 1: Compensation = -0.16 2: Compensation = -0.15 3: Compensation = -0.13</description>
                <bitOffset>0</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>PREAC4FSCOEF</name>
            <description>Pre-Emphasis Filter Coefficient for 4 FS register 0. This register seclects the pre-emphasis filter coeffcient for the input channel when 4FS mode is used</description>
            <addressOffset>0xC</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0</resetValue>
            <resetMask>0x3</resetMask>
            <fields>
              <field>
                <name>COMP</name>
                <description>Pre-emphasis filer coefficient for 4 FS mode. 0: Compensation = 0; 1: Compensation = -0.16; 2: Compensation = -0.15; 3: Compensation = -0.13.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>GAINSHIFT</name>
            <description>Decimator Gain Shift register 0. This register adjusts the gain of the 4FS PCM data from the input filter.</description>
            <addressOffset>0x10</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0</resetValue>
            <resetMask>0x3F</resetMask>
            <fields>
              <field>
                <name>GAIN</name>
                <description>Gain control, as a positive or negative (two s complement) number of bits to shift.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>6</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>FIFO_CTRL</name>
            <description>FIFO Control register 0. This register configures FIFO usage.</description>
            <addressOffset>0x80</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0</resetValue>
            <resetMask>0x1F000F</resetMask>
            <fields>
              <field>
                <name>ENABLE</name>
                <description>FIFO enable. 0: FIFO is not enabled. Enabling a DMIC channel with the FIFO disabled could be useful in order to avoid a filter settling. delay when a channel is re-enabled after a period when the data was not needed. 1: FIFO is enabled. The FIFO must be enabled in order for the CPU or DMA to read data from the DMIC via the FIFODATA register.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>RESETN</name>
                <description>FIFO reset. 0: Reset the FIFO. This bit must be cleared before resuming operation. 1: Normal operation.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>INTEN</name>
                <description>Interrupt enable. 0: FIFO level interrupts are not enabled. 1: FIFO level interrupts are enabled.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>DMAEN</name>
                <description>DMA enable. 0: DMA requests are not enabled. 1: DMA requests based on FIFO level are enabled.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIGLVL</name>
                <description>FIFO trigger level. Selects the data trigger level for interrupt or DMA operation. If enabled to do so, the FIFO level can wake up the device. 0: trigger when the FIFO has received one entry (is no longer empty). 1: trigger when the FIFO has received two entries. 15: trigger when the FIFO has received 16 entries (has become full).</description>
                <bitOffset>16</bitOffset>
                <bitWidth>5</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>FIFO_STATUS</name>
            <description>FIFO Status register 0 . This register provides status information for the FIFO and also indicates an interrupt from the peripheral funcion.</description>
            <addressOffset>0x84</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0</resetValue>
            <resetMask>0x7</resetMask>
            <fields>
              <field>
                <name>INT</name>
                <description>Interrupt flag. Asserted when FIFO data reaches the level specified in the FIFOCTRL register. Writing a one to this bit clears the flag. Remark: note that the bus clock to the DMIC subsystem must be running in order for an interrupt to occur.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OVERRUN</name>
                <description>Overrun flag. Indicates that a FIFO overflow has occurred at some point. Writing a one to this bit clears the flag. This flag does not cause an interrupt.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>UNDERRUN</name>
                <description>Underrun flag. Indicates that a FIFO underflow has occurred at some point. Writing a one to this bit clears the flag.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>FIFO_DATA</name>
            <description>FIFO Data Register 0. This register is used to read values that have been received via the PDM stream.</description>
            <addressOffset>0x88</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0</resetValue>
            <resetMask>0xFFFFFF</resetMask>
            <fields>
              <field>
                <name>DATA</name>
                <description>Data from the top of the input filter FIFO.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>24</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>PHY_CTRL</name>
            <description>PHY Control / PDM Source Configuration register 0. This register configures how the PDM source signals are interpreted.</description>
            <addressOffset>0x8C</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0</resetValue>
            <resetMask>0x3</resetMask>
            <fields>
              <field>
                <name>PHY_FALL</name>
                <description>Capture PDM_DATA. 0: Capture PDM_DATA on the rising edge of PDM_CLK. 1: Capture PDM_DATA on the falling edge of PDM_CLK.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>PHY_HALF</name>
                <description>Half rate sampling. 0: Standard half rate sampling. The clock to the DMIC is sent at the same rate as the decimator is providing. 1: Use half rate sampling. The PDM clock to DMIC is divided by 2. Each PDM data is sampled twice into the decimator. The purpose of this mode is to allow slower sampling rate in quiet periods of listening for a trigger. Allowing the decimator to maintain the same decimation rate between the higher quality, higher PDM clock rate and the lower quality lower PDM clock rate means that the user can quickly switch to higher quality without re-configuring the decimator, and thus avoiding long filter settling times, when switching to higher quality (higher freq PDM clock) for recognition.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DC_CTRL</name>
            <description>DC Control register 0. This register controls the DC filter.</description>
            <addressOffset>0x90</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0</resetValue>
            <resetMask>0x1F3</resetMask>
            <fields>
              <field>
                <name>DCPOLE</name>
                <description>DC block filter. 0: Flat response, no filter. 1: 155 Hz. 2: 78 Hz. 3: 39 Hz. These frequencies assume a PCM output frequency of 16 MHz. If the actual PCM output frequency is 8 MHz, for example, the noted frequencies would be divided by 2.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>DCGAIN</name>
                <description>Fine gain adjustment in the form of a number of bits to downshift.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>SATURATEAT16BIT</name>
                <description>Selects 16-bit saturation. 0:Results roll over if out range and do not saturate. 1:If the result overflows, it saturates at 0xFFFF for positive overflow and 0x8000 for negative overflow.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
        <register>
          <name>CHANEN</name>
          <description>Channel Enable register. This register allows enabling either or both PDM channels.</description>
          <addressOffset>0xF00</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0x3</resetMask>
          <fields>
            <field>
              <name>EN_CH0</name>
              <description>Enable channel 0. When 1, PDM channel 0 is enabled.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EN_CH1</name>
              <description>Enable channel 1. When 1, PDM channel 1 is enabled.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>IOCFG</name>
          <description>I/O Configuration register. This register configures the use of the PDM pins.</description>
          <addressOffset>0xF0C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0x7</resetMask>
          <fields>
            <field>
              <name>CLK_BYPASS0</name>
              <description>Bypass CLK0. When 1, PDM_DATA1 becomes the clock for PDM channel 0. This provides for the possibility of an external codec taking over the PDM bus.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_BYPASS1</name>
              <description>Bypass CLK1. When 1, PDM_DATA1 becomes the clock for PDM channel 1. This provides for the possibility of an external codec taking over the PDM bus.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>STEREO_DATA0</name>
              <description>Stereo PDM select. When 1, PDM_DATA0 is routed to both PDM channels in a configuration that supports a single stereo digital microphone.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>USE2FS</name>
          <description>Use 2FS register. This register allow selecting 2FS output rather than 1FS output.</description>
          <addressOffset>0xF10</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0x1</resetMask>
          <fields>
            <field>
              <name>USE2FS</name>
              <description>Use 2FS register. 0: Use 1FS output for PCM data. 1: Use 2FS output for PCM data.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>HWVADGAIN</name>
          <description>HWVAD input gain register. This register controls the input gain of the HWVAD.</description>
          <addressOffset>0xF80</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x5</resetValue>
          <resetMask>0xF</resetMask>
          <fields>
            <field>
              <name>INPUTGAIN</name>
              <description>Shift value for input bits. 0x0: -10 bits; 0x1: -8 bits; 0x2: -6 bits; 0x3: -4 bits; 0x4: -2 bits; 0x5: 0 bits (default); 0x6: +2 bits; 0x7: +4 bits; 0x8: +6 bits; 0x9: +8 bits; 0xA: +10 bits; 0xB: +12 bits; 0xC: +14 bits; 0xD to 0xF: Reserved.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>HWVADHPFS</name>
          <description>HWVAD filter control register. This register controls the HWVAD filter setting.</description>
          <addressOffset>0xF84</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x1</resetValue>
          <resetMask>0x3</resetMask>
          <fields>
            <field>
              <name>HPFS</name>
              <description>High pass filter. 0: First filter by-pass; 1: High pass filter with -3dB cut-off at 1750Hz; 2: High pass filter with -3dB cut-off at 215Hz.; 3: Reserved. This filter setting parameter can be used to optimize performance for different background noise situations. In order to find the best setting, software needs to perform a rough spectral analysis of the audio signal. Rule of thumb: If the amount of low-frequency content in the background noise is small, then set HPFS=0x2, otherwise use 0x1.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>HWVADST10</name>
          <description>HWVAD control register. This register controls the operation of the filter block and resets the internal interrut flag.</description>
          <addressOffset>0xF88</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0x1</resetMask>
          <fields>
            <field>
              <name>ST10</name>
              <description>ST10. Once the HWVAD has triggered an interrupt, a short '1' pulse on bit ST10 clears the interrupt. Alternatively, keeping the bit on '1' level for some time has a special function for filter convergence. 0: Normal operation, waiting for HWVAD trigger event (stage 0). 1: Reset internal interrupt flag by writing a 1 pulse.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>HWVADRSTT</name>
          <description>HWVAD filter reset register</description>
          <addressOffset>0xF8C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0x1</resetMask>
          <fields>
            <field>
              <name>RSTT</name>
              <description>HWVAD filter reset. Writing a 1, then writing a '0' resets all filter values. 0: Filters anr not held in reset. 1: Holds the filters in reset.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>HWVADTHGN</name>
          <description>HWVAD noise estimator gain register</description>
          <addressOffset>0xF90</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0xF</resetMask>
          <fields>
            <field>
              <name>THGN</name>
              <description>Gain value for the noise estimator. Values 0 to 14. 0 corresponds to a gain of 1. THGN and THGS are used within the hardware to determine when to assert the HWVAD result.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>HWVADTHGS</name>
          <description>HWVAD signal estimator gain register</description>
          <addressOffset>0xF94</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x4</resetValue>
          <resetMask>0xF</resetMask>
          <fields>
            <field>
              <name>THGS</name>
              <description>Gain value for the signal estimator. Values 0 to 14. 0 corresponds to a gain of 1. THGN and THGS are used within the hardware to determine when to assert the HWVAD result.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>HWVADLOWZ</name>
          <description>HWVAD noise envelope estimator register</description>
          <addressOffset>0xF98</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>LOWZ</name>
              <description>Noise envelope estimator value. This register contains 2 bytes of the output of filter stage z7. It can be used as an indication for the noise floor and must be evaluated by software. Note: For power saving reasons this register is not synchronized to the AHB bus clock domain. To ensure correct data is read, the register should be read twice. If the data is the same, then the data is correct, if not, the register should be read one more time. The noise floor is a slowly moving calculation, so several reads in a row can guarantee that register value being read can be assured to not be in the middle of a transition.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ID</name>
          <description>Module Identification register</description>
          <addressOffset>0xFFC</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x2</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ID</name>
              <description>Indicates module ID and the number of channels in this DMIC interface.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>FLEXCOMM0</name>
      <description>LPC5411x Flexcomm serial communication</description>
      <groupName>FLEXCOMM</groupName>
      <headerStructName>FLEXCOMM</headerStructName>
      <baseAddress>0x4008B000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>0x1000</size>
        <usage>registers</usage>
      </addressBlock>
      <interrupt>
        <name>FLEXCOMM0</name>
        <value>11</value>
      </interrupt>
      <registers>
        <register>
          <name>PSELID</name>
          <description>Peripheral Select and Flexcomm ID register.</description>
          <addressOffset>0xFF8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x101000</resetValue>
          <resetMask>0xFFFFF0FF</resetMask>
          <fields>
            <field>
              <name>PERSEL</name>
              <description>Peripheral Select. This field is writable by software.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_PERIPH_SELECTED</name>
                  <description>No peripheral selected.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>USART</name>
                  <description>USART function selected.</description>
                  <value>0x1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SPI</name>
                  <description>SPI function selected.</description>
                  <value>0x2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2C</name>
                  <description>I2C function selected.</description>
                  <value>0x3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2S_TRANSMIT</name>
                  <description>I2S transmit function selected.</description>
                  <value>0x4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2S_RECEIVE</name>
                  <description>I2S receive function selected.</description>
                  <value>0x5</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>LOCK</name>
              <description>Lock the peripheral select. This field is writable by software.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>UNLOCKED</name>
                  <description>Peripheral select can be changed by software.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LOCKED</name>
                  <description>Peripheral select is locked and cannot be changed until this Flexcomm or the entire device is reset.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>USARTPRESENT</name>
              <description>USART present indicator. This field is Read-only.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NOT_PRESENT</name>
                  <description>This Flexcomm does not include the USART function.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PRESENT</name>
                  <description>This Flexcomm includes the USART function.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SPIPRESENT</name>
              <description>SPI present indicator. This field is Read-only.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NOT_PRESENT</name>
                  <description>This Flexcomm does not include the SPI function.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PRESENT</name>
                  <description>This Flexcomm includes the SPI function.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>I2CPRESENT</name>
              <description>I2C present indicator. This field is Read-only.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NOT_PRESENT</name>
                  <description>This Flexcomm does not include the I2C function.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PRESENT</name>
                  <description>This Flexcomm includes the I2C function.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>I2SPRESENT</name>
              <description>I 2S present indicator. This field is Read-only.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NOT_PRESENT</name>
                  <description>This Flexcomm does not include the I2S function.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PRESENT</name>
                  <description>This Flexcomm includes the I2S function.</description>
                  <value>0x1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ID</name>
              <description>Flexcomm ID.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PID</name>
          <description>Peripheral identification register.</description>
          <addressOffset>0xFFC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>Minor_Rev</name>
              <description>Minor revision of module implementation.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>Major_Rev</name>
              <description>Major revision of module implementation.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ID</name>
              <description>Module identifier for the selected function.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral derivedFrom="FLEXCOMM0">
      <name>FLEXCOMM2</name>
      <description>LPC5411x Flexcomm serial communication</description>
      <groupName>FLEXCOMM</groupName>
      <baseAddress>0x40003000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>0x1000</size>
        <usage>registers</usage>
      </addressBlock>
      <interrupt>
        <name>FLEXCOMM2</name>
        <value>13</value>
      </interrupt>
    </peripheral>
    <peripheral derivedFrom="FLEXCOMM0">
      <name>FLEXCOMM3</name>
      <description>LPC5411x Flexcomm serial communication</description>
      <groupName>FLEXCOMM</groupName>
      <baseAddress>0x40004000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>0x1000</size>
        <usage>registers</usage>
      </addressBlock>
      <interrupt>
        <name>FLEXCOMM3</name>
        <value>14</value>
      </interrupt>
    </peripheral>
    <peripheral derivedFrom="FLEXCOMM0">
      <name>FLEXCOMM6</name>
      <description>LPC5411x Flexcomm serial communication</description>
      <groupName>FLEXCOMM</groupName>
      <baseAddress>0x40005000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>0x1000</size>
        <usage>registers</usage>
      </addressBlock>
      <interrupt>
        <name>FLEXCOMM6</name>
        <value>28</value>
      </interrupt>
    </peripheral>
    <peripheral derivedFrom="FLEXCOMM0">
      <name>FLEXCOMM1</name>
      <description>LPC5411x Flexcomm serial communication</description>
      <groupName>FLEXCOMM</groupName>
      <baseAddress>0x4008C000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>0x1000</size>
        <usage>registers</usage>
      </addressBlock>
      <interrupt>
        <name>FLEXCOMM1</name>
        <value>12</value>
      </interrupt>
    </peripheral>
    <peripheral derivedFrom="FLEXCOMM0">
      <name>FLEXCOMM4</name>
      <description>LPC5411x Flexcomm serial communication</description>
      <groupName>FLEXCOMM</groupName>
      <baseAddress>0x4008D000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>0x1000</size>
        <usage>registers</usage>
      </addressBlock>
      <interrupt>
        <name>FLEXCOMM4</name>
        <value>15</value>
      </interrupt>
    </peripheral>
    <peripheral derivedFrom="FLEXCOMM0">
      <name>FLEXCOMM5</name>
      <description>LPC5411x Flexcomm serial communication</description>
      <groupName>FLEXCOMM</groupName>
      <baseAddress>0x4008E000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>0x1000</size>
        <usage>registers</usage>
      </addressBlock>
      <interrupt>
        <name>FLEXCOMM5</name>
        <value>16</value>
      </interrupt>
    </peripheral>
    <peripheral>
      <name>USART0</name>
      <description>This is the description of component usart. It is an Universal Synchrnous/Asynchrnous Receiver/Transmitter with APB bus interface. More details will follow.</description>
      <alternatePeripheral>FLEXCOMM0</alternatePeripheral>
      <groupName>USART</groupName>
      <headerStructName>USART</headerStructName>
      <baseAddress>0x4008B000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>0x1000</size>
        <usage>registers</usage>
      </addressBlock>
      <interrupt>
        <name>FLEXCOMM0</name>
        <value>11</value>
      </interrupt>
      <registers>
        <register>
          <name>CFG</name>
          <description>USART Configuration register. Basic USART configuration settings that typically are not changed during operation.</description>
          <addressOffset>0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0xFCDBFD</resetMask>
          <fields>
            <field>
              <name>ENABLE</name>
              <description>USART Enable. 0: Disabled. The USART is disabled and the internal state machine and counters are reset. While Enable = 0, all USART interrupts and DMA transfers are disabled. When Enable is set again, CFG and most other control bits remain unchanged. When re-enabled, the USART will immediately be ready to transmit because the transmitter has been reset and is therefore available. 1: Eanbled. The USART is enabled for operation.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DATALEN</name>
              <description>Selects the data size for the USART. 0: 7 bit Data Length; 1: 8 bit data length; 2: 9 bit data length. The 9th bit is commonly used for addressing in multidrop mode. See the ADDRDET bit in the CTRL regsiter. 3: Reserved.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PARITYSEL</name>
              <description>Selects what type of parity is used by the USART. 0: No parity; 1: Reserved; 2: Even Parity. Adds a bit to each character such that the number of 1s in a transmitted character is even, and the number of 1s in a received character is expected to be even. 3: Odd parity. Adds a bit to each character such that the number of 1s in a transmitted character is odd, and the number of 1s in a received character is expected to be odd.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>STOPLEN</name>
              <description>Number of stop bits appended to transmitted data. Only a single stop bit is required for received data. 0: 1 stop bit; 1: 2 stop bits. This setting should only be used for asynchronous communication.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MODE32K</name>
              <description>Selects standard or 32 kHz clocking mode. 0: Disabled. USART uses standard clocking. 1: Enabled. USART uses the 32 kHz clock from the RTC oscillator as the clock source to the BRG, and uses a special bit clocking scheme.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>LINMODE</name>
              <description>LIN bus break mode enable. 0: Disabled. Break detect and generate is configured for normal operation. 1: Enabled. Break detect and generate is configured for LIN bus operation.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CTSEN</name>
              <description>CTS Enable. Determines whether CTS is used for flow control. CTS can be from the input pin, or from the USART s own RTS if loopback mode is enabled. 0 : No flow control. The transmitter does not receive any automatic flow control signal. 1: Flow control enabled. The transmitter uses the CTS input (or RTS output in loopback mode) for flow control purposes.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SYNCEN</name>
              <description>Selects synchronous or asynchronous operation. 0: Asynchronous mode. 1: Synchronous mode.</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CLKPOL</name>
              <description>Selects the clock polarity and sampling edge of received data in synchronous mode. 0: Falling edge. Un_RXD is sampled on the falling edge of SCLK. 1: Rising edge. Un_RXD is sampled on the rising edge of SCLK.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SYNCMST</name>
              <description>Synchronous mode Master select. 0: Slave. When synchronous mode is enabled, the USART is a slave. 1: Master. When synchronous mode is enabled, the USART is a master.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>LOOP</name>
              <description>Selects data loopback mode. 0: Normal operaetion. 1: Loopback mode. This provides a mechanism to perform diagnostic loopback testing for USART data. Serial data from the transmitter (Un_TXD) is connected internally to serial input of the receive (Un_RXD). Un_TXD and Un_RTS activity will also appear on external pins if these functions are configured to appear on device pins. The receiver RTS signal is also looped back to CTS and performs flow control if enabled by CTSEN.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OETA</name>
              <description>Output Enable Turnaround time enable for RS-485 operation. 0: Disabled. If selected by OESEL, the Output Enable signal deasserted at the end of the last stop bit of a transmission. 1: Enabled. If selected by OESEL, the Output Enable signal remains asserted for one character time after the end of the last stop bit of a transmission. OE will also remain asserted if another transmit begins before it is deasserted.</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>AUTOADDR</name>
              <description>Automatic Address matching enable. 0: Disabled. When addressing is enabled by ADDRDET, address matching is done by software. This provides the possibility of versatile addressing (e.g. respond to more than one address). 1: Enabled. When addressing is enabled by ADDRDET, address matching is done by hardware, using the value in the ADDR register as the address to match.</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OESEL</name>
              <description>Output Enable Select. 0: Standard. The RTS signal is used as the standard flow control function. 1: RS-485. The RTS signal configured to provide an output enable signal to control an RS-485 transceiver.</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OEPOL</name>
              <description>Output Enable Polarity. 0: Low. If selected by OESEL, the output enable is active low. 1: High. If selected by OESEL, the output enable is active high.</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXPOL</name>
              <description>Receive data polarity. 0: Standard. The RX signal is used as it arrives from the pin. This means that the RX rest value is 1, start bit is 0, data is not inverted, and the stop bit is 1. 1: Inverted. The RX signal is inverted before being used by the USART. This means that the RX rest value is 0, start bit is 1, data is inverted, and the stop bit is 0.</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TXPOL</name>
              <description>Transmit data polarity. 0: Standard. The TX signal is sent out without change. This means that the TX rest value is 1, start bit is 0, data is not inverted, and the stop bit is 1. 1: Inverted. The TX signal is inverted by the USART before being sent out. This means that the TX rest value is 0, start bit is 1, data is inverted, and the stop bit is 0.</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CTL</name>
          <description>USART Control register. USART control settings that are more likely to change during operation.</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0x10346</resetMask>
          <fields>
            <field>
              <name>TXBRKEN</name>
              <description>Break Enable. 0: Normal Operation. 1: Continuous break. Continuous break is sent immediately when this bit is set, and remains until this bit is cleared. A break may be sent without danger of corrupting any currently transmitting character if the transmitter is first disabled (TXDIS in CTL is set) and then waiting for the transmitter to be disabled (TXDISINT in STAT = 1) before writing 1 to TXBRKEN.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ADDRDET</name>
              <description>Enable address detect mode. 0: Disabled. The USART presents all incoming data. 1: Enabled. The USART receiver ignores incoming data that does not have the most significant bit of the data (typically the 9th bit) = 1. When the data MSB bit = 1, the receiver treats the incoming data normally, generating a received data interrupt. Software can then check the data to see if this is an address that should be handled. If it is, the ADDRDET bit is cleared by software and further incoming data is handled normally.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TXDIS</name>
              <description>Transmit Disable. 0: Not disabled. USART transmitter is not disabled. 1: Disabled. USART transmitter is disabled after any character currently being transmitted is complete. This feature can be used to facilitate software flow control.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CC</name>
              <description>Continuous Clock generation. By default, SCLK is only output while data is being transmitted in synchronous mode. 0: Clock on character. In synchronous mode, SCLK cycles only when characters are being sent on Un_TXD or to complete a character that is being received. 1: Continuous clock. SCLK runs continuously in synchronous mode, allowing characters to be received on Un_RxD independently from transmission on Un_TXD).</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CLRCCONRX</name>
              <description>Clear Continuous Clock. 0: No effect. No effect on the CC bit. 1: Auto-clear. The CC bit is automatically cleared when a complete character has been received. This bit is cleared at the same time.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>AUTOBAUD</name>
              <description>Autobaud enable. 0: Disabled. USART is in normal operating mode. 1: Enabled. USART is in auto-baud mode. This bit should only be set when the USART receiver is idle. The first start bit of RX is measured and used the update the BRG register to match the received data rate. AUTOBAUD is cleared once this process is complete, or if there is an AERR.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>STAT</name>
          <description>USART Status register. The complete status value can be read here. Writing ones clears some bits in the register. Some bits can be cleared by writing a 1 to them.</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xA</resetValue>
          <resetMask>0x1FC7A</resetMask>
          <fields>
            <field>
              <name>RXIDLE</name>
              <description>Receiver Idle. When 0, indicates that the receiver is currently in the process of receiving data. When 1, indicates that the receiver is not currently in the process of receiving data.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TXIDLE</name>
              <description>Transmitter Idle. When 0, indicates that the transmitter is currently in the process of sending data.When 1, indicate that the transmitter is not currently in the process of sending data.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>CTS</name>
              <description>This bit reflects the current state of the CTS signal, regardless of the setting of the CTSEN bit in the CFG register. This will be the value of the CTS input pin unless loopback mode is enabled. Hence, reset value not applicable.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>DELTACTS</name>
              <description>This bit is set when a change in the state is detected for the CTS flag above. This bit is cleared by software.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TXDISSTAT</name>
              <description>Transmitter Disabled Status flag. When 1, this bit indicates that the USART transmitter is fully idle after being disabled via the TXDIS bit in the CFG register (TXDIS = 1).</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RXBRK</name>
              <description>Received Break. This bit reflects the current state of the receiver break detection logic. It is set when the Un_RXD pin remains low for 16 bit times. Note that FRAMERRINT will also be set when this condition occurs because the stop bit(s) for the character would be missing. RXBRK is cleared when the Un_RXD pin goes high.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>DELTARXBRK</name>
              <description>This bit is set when a change in the state of receiver break detection occurs. Cleared by software.</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>START</name>
              <description>This bit is set when a start is detected on the receiver input. Its purpose is primarily to allow wake-up from Deep sleep or Power-down mode immediately when a start is detected. Cleared by software.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FRAMERRINT</name>
              <description>Framing Error interrupt flag. This flag is set when a character is received with a missing stop bit at the expected location. This could be an indication of a baud rate or configuration mismatch with the transmitting source.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PARITYERRINT</name>
              <description>Parity Error interrupt flag. This flag is set when a parity error is detected in a received character.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXNOISEINT</name>
              <description>Received Noise interrupt flag. Three samples of received data are taken in order to determine the value of each received data bit, except in synchronous mode. This acts as a noise filter if one sample disagrees. This flag is set when a received data bit contains one disagreeing sample. This could indicate line noise, a baud rate or character format mismatch, or loss of synchronization during data reception.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ABERR</name>
              <description>Auto baud Error. An auto baud error can occur if the BRG counts to its limit before the end of the start bit that is being measured, essentially an auto baud time-out.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTENSET</name>
          <description>Interrupt Enable read and Set register for USART (not FIFO) status. Contains individual interrupt enable bits for each potential USART interrupt. A complete value may be read from this register. Writing a 1 to any implemented bit position causes that bit to be set.</description>
          <addressOffset>0xC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0x1F86D</resetMask>
          <fields>
            <field>
              <name>RXRDYEN</name>
              <description>When 1, enables an interrupt when RX becomes ready</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TXRDTEN</name>
              <description>When 1, enables an interrupt when TX becomes ready</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TXIDLEEN</name>
              <description>When 1, enables an interrupt when the transmitter becomes idle (TXIDLE = 1).</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DELTACTSEN</name>
              <description>Transmitter Idle. When 0, indicates that the transmitter is currently in the process of sending data.When 1, indicate that the transmitter is not currently in the process of sending data.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TXDISEN</name>
              <description>When 1, enables an interrupt when the transmitter is fully disabled as indicated by the TXDISINT flag in STAT. See description of the TXDISINT bit for details.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DELTARXBRKEN</name>
              <description>When 1, enables an interrupt when a change of state has occurred in the detection of a received break condition (break condition asserted or deasserted).</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>STARTEN</name>
              <description>When 1, enables an interrupt when a received start bit has been detected.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FRAMERREN</name>
              <description>When 1, enables an interrupt when a framing error has been detected.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PARITYERREN</name>
              <description>When 1, enables an interrupt when a parity error has been detected.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXNOISEEN</name>
              <description>When 1, enables an interrupt when noise is detected.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ABERREN</name>
              <description>When 1, enables an interrupt when an auto baud error occurs.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTENCLR</name>
          <description>Interrupt Enable Clear register. Allows clearing any combination of bits in the INTENSET register. Writing a 1 to any implemented bit position causes the corresponding bit to be cleared.</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>RXRDYCLR</name>
              <description>Writing 1 clears the corresponding bit in the INTENSET register.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>TXRDYCLR</name>
              <description>Writing 1 clears the corresponding bit in the INTENSET register.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>TXIDLECLR</name>
              <description>Writing 1 clears the corresponding bit in the INTENSET register.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>DELTACTSCLR</name>
              <description>Writing 1 clears the corresponding bit in the INTENSET register.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>TXDISCLR</name>
              <description>Writing 1 clears the corresponding bit in the INTENSET register.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>DELTARXBRKCLR</name>
              <description>Writing 1 clears the corresponding bit in the INTENSET register.</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>STARTCLR</name>
              <description>Writing 1 clears the corresponding bit in the INTENSET register.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>FRAMERRCLR</name>
              <description>Writing 1 clears the corresponding bit in the INTENSET register.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>PARITYERRCLR</name>
              <description>Writing 1 clears the corresponding bit in the INTENSET register.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>RXNOISECLR</name>
              <description>Writing 1 clears the corresponding bit in the INTENSET register.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>ABERRCLR</name>
              <description>Writing 1 clears the corresponding bit in the INTENSET register.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>BRG</name>
          <description>Baud Rate Generator register. 16-bit integer baud rate divisor value.</description>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>BRGVAL</name>
              <description>This value is used to divide the USART input clock to determine the baud rate, based on the input clock from the FRG. 0: FCLK is used directly by the USART function. 1: FCLK is divided by 2 before use by the USART function. 2: FCLK is divided by 3 before use by the USART function. ... 0xFFFF = FCLK is divided by 65,536 before use by the USART function.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTSTAT</name>
          <description>Interrupt status register. Reflects the status of interrupts that are currently enabled.</description>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0</resetValue>
          <resetMask>0x1F86F</resetMask>
          <fields>
            <field>
              <name>RX_RDY</name>
              <description>Receiver Ready Status</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RXIDLE</name>
              <description>Receiver Idle Status</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TX_RDY</name>
              <description>Transmitter Ready Status</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TXIDLE</name>
              <description>Transmitter Idle status.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>DELTACTS</name>
              <description>This bit is set when a change in the state of the CTS input is detected.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TXDIS</name>
              <description>Transmitter Disabled Interrupt flag.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>DELTARXBRK</name>
              <description>This bit is set when a change in the state of receiver break detection occurs.</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>START</name>
              <description>This bit is set when a start is detected on the receiver input.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>FRAMERR</name>
              <description>Framing Error interrupt flag.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PARITYERR</name>
              <description>Parity Error interrupt flag.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RXNOISE</name>
              <description>Received Noise interrupt flag.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ABERR</name>
              <description>Auto baud Error Interrupt flag.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>OSR</name>
          <description>Oversample selection register for asynchronous communication.</description>
          <addressOffset>0x28</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xF</resetValue>
          <resetMask>0xF</resetMask>
          <fields>
            <field>
              <name>OSRVAL</name>
              <description>Oversample Selection Value. 0 to 3: not supported. 0x4: 5 function clocks are used to transmit and receive each data bit. 0x5: 6 function clocks are used to transmit and receive each data bit. ... 0xF: 16 function clocks are used to transmit and receive each data bit.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ADDR</name>
          <description>Address register for automatic address matching.</description>
          <addressOffset>0x2C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>ADDRESS</name>
              <description>8-bit address used with automatic address matching. Used when address detection is enabled (ADDRDET in CTL = 1) and automatic address matching is enabled (AUTOADDR in CFG = 1).</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>FIFOCFG</name>
          <description>FIFO configuration and enable register.</description>
          <addressOffset>0xE00</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0x7F033</resetMask>
          <fields>
            <field>
              <name>ENABLETX</name>
              <description>Enable the transmit FIFO. 0: The transmit FIFO is not enabled. 1: The transmit FIFO is enabled. This is automatically enabled when PSELID.PERSEL is set to 1 to configure the USART functionality.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ENABLERX</name>
              <description>Enable the receive FIFO. 0: The receive FIFO is not enabled. 1: The receive FIFO is enabled. This is automatically enabled when PSELID.PERSEL is set to 1 to configure the USART functionality.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SIZE</name>
              <description>FIFO size configuration. This is a read-only field. 0x0 = FIFO is configured as 4 entries of 8 bits. 0x1, 0x2, 0x3 = not applicable.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>DMATX</name>
              <description>DMA configuration for transmit. 0: DMA is not used for the transmit function. 1: Generate a DMA request for the transmit function if the FIFO is not full. Generally, data interrupts would be disabled if DMA is enabled</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DMARX</name>
              <description>DMA configuration for receive. 0: DMA is not used for the receive function. 1: Generate a DMA request for the receive function if the FIFO is not empty. Generally, data interrupts would be disabled if DMA is enabled.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>WAKETX</name>
              <description>Wakeup for transmit FIFO level. This allows the device to be woken from reduced power modes (up to power-down, as long as the peripheral function works in that power mode) without enabling the TXLVL interrupt. Only DMA wakes up, processes data, and goes back to sleep. The CPU will remain stopped until woken by another cause, such as DMA completion. 0: Only enabled interrupts will wake up the device form reduced power modes. 1: A device wake-up for DMA will occur if the transmit FIFO level reaches the value specified by TXLVL in FIFOTRIG, even when the TXLVL interrupt is not enabled.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>WAKERX</name>
              <description>Wakeup for receive FIFO level. This allows the device to be woken from reduced power modes (up to power-down, as long as the peripheral function works in that power mode) without enabling the TXLVL interrupt. Only DMA wakes up, processes data, and goes back to sleep. The CPU will remain stopped until woken by another cause, such as DMA completion. 0: Only enabled interrupts will wake up the device form reduced power modes. 1: A device wake-up for DMA will occur if the receive FIFO level reaches the value specified by RXLVL in FIFOTRIG, even when the RXLVL interrupt is not enabled.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EMPTYTX</name>
              <description>Empty command for the transmit FIFO. When a 1 is written to this bit, the TX FIFO is emptied.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EMPTYRX</name>
              <description>Empty command for the receive FIFO. When a 1 is written to this bit, the RX FIFO is emptied.</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>POPDBG</name>
              <description>Pop FIFO for debug reads.</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>FIFOSTAT</name>
          <description>FIFO status register.</description>
          <addressOffset>0xE04</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x30</resetValue>
          <resetMask>0x1F1FFB</resetMask>
          <fields>
            <field>
              <name>TXERR</name>
              <description>TX FIFO error. Will be set if a transmit FIFO error occurs. This could be an overflow caused by pushing data into a full FIFO, or by an underflow if the FIFO is empty when data is needed. Cleared by writing a 1 to this bit.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXERR</name>
              <description>RX FIFO error. Will be set if a receive FIFO overflow occurs, caused by software or DMA not emptying the FIFO fast enough. Cleared by writing a 1 to this bit.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PERINT</name>
              <description>Peripheral interrupt. When 1, this indicates that the peripheral function has asserted an interrupt. The details can be found by reading the peripheral s STAT register.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TXEMPTY</name>
              <description>Transmit FIFO empty. When 1, the transmit FIFO is empty. The peripheral may still be processing the last piece of data.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TXNOTFULL</name>
              <description>Transmit FIFO not full. When 1, the transmit FIFO is not full, so more data can be written. When 0, the transmit FIFO is full and another write would cause it to overflow.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RXNOTEMPTY</name>
              <description>Receive FIFO not empty. When 1, the receive FIFO is not empty, so data can be read. When 0, the receive FIFO is empty.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RXFULL</name>
              <description>Receive FIFO full. When 1, the receive FIFO is full. Data needs to be read out to prevent the peripheral from causing an overflow.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TXLVL</name>
              <description>Transmit FIFO current level. A 0 means the TX FIFO is currently empty, and the TXEMPTY and TXNOTFULL flags will be 1. Other values tell how much data is actually in the TX FIFO at the point where the read occurs. If the TX FIFO is full, the TXEMPTY and TXNOTFULL flags will be 0.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RXLVL</name>
              <description>Receive FIFO current level. A 0 means the RX FIFO is currently empty, and the RXFULL and RXNOTEMPTY flags will be 0. Other values tell how much data is actually in the RX FIFO at the point where the read occurs. If the RX FIFO is full, the RXFULL and RXNOTEMPTY flags will be 1.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>FIFOTRIG</name>
          <description>FIFO trigger settings for interrupt and DMA request.</description>
          <addressOffset>0xE08</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0xF0F03</resetMask>
          <fields>
            <field>
              <name>TXLVLENA</name>
              <description>Transmit FIFO level trigger enable. This trigger will become an interrupt if enabled in FIFOINTENSET, or a DMA trigger if DMATX in FIFOCFG is set. 0: Transmit FIFO level does not generate a FIFO level trigger. 1: An interrupt will be generated if the transmit FIFO level reaches the value specified by the TXLVL field in this register.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXLVLENA</name>
              <description>Receive FIFO level trigger enable. This trigger will become an interrupt if enabled in FIFOINTENSET, or a DMA trigger if DMARX in FIFOCFG is set. 0: Receive FIFO level does not generate a FIFO level trigger. 1: An interrupt will be generated if the receive FIFO level reaches the value specified by the RXLVL field in this register.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TXLVL</name>
              <description>Transmit FIFO level trigger point. This field is used only when TXLVLENA = 1. 0: trigger when the TX FIFO becomes empty. 1: trigger when the TX FIFO level decreases to one entry. ... 3: trigger when the TX FIFO level decreases to 3 entries (is no longer full).</description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXLVL</name>
              <description>Receive FIFO level trigger point. The RX FIFO level is checked when a new piece of data is received. This field is used only when RXLVLENA = 1. 0: trigger when the RX FIFO has received one entry (is no longer empty). 1: trigger when the RX FIFO has received two entries. ... 3: trigger when the RX FIFO has received 4 entries (has become full).</description>
              <bitOffset>16</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>FIFOINTENSET</name>
          <description>FIFO interrupt enable set (enable) and read register.</description>
          <addressOffset>0xE10</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0xF</resetMask>
          <fields>
            <field>
              <name>TXERR</name>
              <description>Determines whether an interrupt occurs when a transmit error occurs, based on the TXERR flag in the FIFOSTAT register. 0: No interrupt will be generated for a transmit error. 1: An interrupt will be generated when a transmit error occurs.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXERR</name>
              <description>Determines whether an interrupt occurs when a receive error occurs, based on the RXERR flag in the FIFOSTAT register. 0: No interrupt will be generated for a receive error. 1: An interrupt will be generated when a receive error occurs.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TXLVL</name>
              <description>Determines whether an interrupt occurs when a the transmit FIFO reaches the level specified by the TXLVL field in the FIFOTRIG register. 0: No interrupt will be generated based on the TX FIFO level. 1: TXLVLENA in the FIFOTRIG register = 1, an interrupt will be generated when the TX FIFO level decreases to the level specified by TXLVL in the FIFOTRIG register.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXLVL</name>
              <description>Determines whether an interrupt occurs when a the receive FIFO reaches the level specified by the TXLVL field in the FIFOTRIG register. 0: No interrupt will be generated based on the RX FIFO level. 1: If RXLVLENA in the FIFOTRIG register = 1, an interrupt will be generated when the when the RX FIFO level increases to the level specified by RXLVL in the FIFOTRIG register.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>FIFOINTENCLR</name>
          <description>FIFO interrupt enable clear (disable) and read register.</description>
          <addressOffset>0xE14</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>TXERR</name>
              <description>Writing 1 clears the corresponding bit in the FIFOINTENSET register</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>RXERR</name>
              <description>Writing 1 clears the corresponding bit in the FIFOINTENSET register</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>TXLVL</name>
              <description>Writing 1 clears the corresponding bit in the FIFOINTENSET register</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>RXLVL</name>
              <description>Writing 1 clears the corresponding bit in the FIFOINTENSET register</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>FIFOINTSTAT</name>
          <description>FIFO interrupt status register. Reflects the status of interrupts that are currently enabled.</description>
          <addressOffset>0xE18</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0</resetValue>
          <resetMask>0x1F</resetMask>
          <fields>
            <field>
              <name>TXERR</name>
              <description>TX FIFO error.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RXERR</name>
              <description>RX FIFO error.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TXLVL</name>
              <description>Transmit FIFO level interrupt.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RXLVL</name>
              <description>Receive FIFO level interrupt.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PERINT</name>
              <description>Peripheral interrupt.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>FIFOWR</name>
          <description>FIFO write data. Used to write values to be transmitted to the FIFO.</description>
          <addressOffset>0xE20</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>TXDATA</name>
              <description>Transmit data to the FIFO. The number of bits used depends on the DATALEN</description>
              <bitOffset>0</bitOffset>
              <bitWidth>9</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>FIFORD</name>
          <description>FIFO read data. Used to read values that have been received.</description>
          <addressOffset>0xE30</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0</resetValue>
          <resetMask>0xE1FF</resetMask>
          <fields>
            <field>
              <name>RXDATA</name>
              <description>Received data from the FIFO. The number of bits used depends on the DATALEN and PARITYSEL settings.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>9</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>FRAMERR</name>
              <description>Framing Error status flag. This bit reflects the status for the data it is read along with from the FIFO, and indicates that the character was received with a missing stop bit at the expected location. This could be an indication of a baud rate or configuration mismatch with the transmitting source.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PARITYERR</name>
              <description>Parity Error status flag. This bit reflects the status for the data it is read along with from the FIFO. This bit will be set when a parity error is detected in a received character.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RXNOISE</name>
              <description>Received Noise flag.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>FIFORDNOPOP</name>
          <description>FIFO data read with no FIFO pop. This register acts in exactly the same way as FIFORD, except that it supplies data from the top of the FIFO without popping the FIFO (i.e. leaving the FIFO state unchanged). This could be used to allow system software to observe incoming data without interfering with the peripheral driver.</description>
          <addressOffset>0xE40</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0</resetValue>
          <resetMask>0xE1FF</resetMask>
          <fields>
            <field>
              <name>RXDATA</name>
              <description>Received data from the FIFO. The number of bits used depends on the DATALEN and PARITYSEL settings.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>9</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>FRAMERR</name>
              <description>Framing Error status flag. This bit reflects the status for the data it is read along with from the FIFO, and indicates that the character was received with a missing stop bit at the expected location. This could be an indication of a baud rate or configuration mismatch with the transmitting source.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PARITYERR</name>
              <description>Parity Error status flag. This bit reflects the status for the data it is read along with from the FIFO. This bit will be set when a parity error is detected in a received character.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RXNOISE</name>
              <description>Received Noise flag.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PSELID</name>
          <description>Flexcomm ID and peripheral function select register</description>
          <addressOffset>0xFF8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x102010</resetValue>
          <resetMask>0xFFFFF01F</resetMask>
          <fields>
            <field>
              <name>PERSEL</name>
              <description>Peripheral Select. This field is writable by software. 0x0: No peripheral selected. 0x1: USART function selected. 0x2 - 0x7: Reserved.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>LOCK</name>
              <description>Lock the peripheral select. This field is writable by software. 0: Peripheral select can be changed by software. 1: Peripheral select is locked and cannot be changed until this Flexcomm or the entire device is reset.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>USARTPRESENT</name>
              <description>USART present indicator. This field is Read-only. 0: This Flexcomm does not include the USART function. 1: This Flexcomm includes the USART function.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ID</name>
              <description>Flexcomm ID.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ID</name>
          <description>USART Module Identifier</description>
          <addressOffset>0xFFC</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0xE0102100</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>APERTURE</name>
              <description>Aperture i.e. number minus 1 of consecutive packets 4 Kbytes reserved for this IP</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>MIN_REV</name>
              <description>Minor revision i.e. with no software consequences</description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>MAJ_REV</name>
              <description>Major revision i.e. implies software modifications</description>
              <bitOffset>12</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ID</name>
              <description>Identifier. This is the unique identifier of the module</description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral derivedFrom="USART0">
      <name>USART1</name>
      <description>This is the description of component usart. It is an Universal Synchrnous/Asynchrnous Receiver/Transmitter with APB bus interface. More details will follow.</description>
      <alternatePeripheral>FLEXCOMM1</alternatePeripheral>
      <groupName>USART</groupName>
      <baseAddress>0x4008C000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>0x1000</size>
        <usage>registers</usage>
      </addressBlock>
      <interrupt>
        <name>FLEXCOMM1</name>
        <value>12</value>
      </interrupt>
    </peripheral>
    <peripheral>
      <name>SPI0</name>
      <description>This is the description of component spi. It is a Serial Peripheral Interface with APB bus interface. More details will follow.</description>
      <alternatePeripheral>FLEXCOMM4</alternatePeripheral>
      <groupName>SPI</groupName>
      <headerStructName>SPI</headerStructName>
      <baseAddress>0x4008D000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>0x1000</size>
        <usage>registers</usage>
      </addressBlock>
      <interrupt>
        <name>FLEXCOMM4</name>
        <value>15</value>
      </interrupt>
      <registers>
        <register>
          <name>CFG</name>
          <description>SPI Configuration register</description>
          <addressOffset>0x400</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0x7BD</resetMask>
          <fields>
            <field>
              <name>ENABLE</name>
              <description>SPI enable.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MASTER</name>
              <description>Master mode select.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>LSBF</name>
              <description>LSB First mode enable.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CPHA</name>
              <description>Clock Phase select.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CPOL</name>
              <description>Clock Polarity select.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>LOOP</name>
              <description>Loopback mode enable. Loopback mode applies only to Master mode, and connects transmit and receive data connected together to allow simple software testing.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SPOL0</name>
              <description>SSEL0 Polarity select.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SPOL1</name>
              <description>SSEL1 Polarity select. Valid only for SPI-1</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SPOL2</name>
              <description>SSEL2 Polarity select. Valid only for SPI-1</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DLY</name>
          <description>SPI Delay register</description>
          <addressOffset>0x404</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>PRE_DELAY</name>
              <description>Controls the amount of time between SSEL assertion and the beginning of a data transfer. There is always one SPI clock time between SSEL assertion and the first clock edge. This is not considered part of the pre-delay. 0x0 = No additional time is inserted. 0x1 = 1 SPI clock time is inserted. 0x2 = 2 SPI clock times are inserted. ... 0xF = 15 SPI clock times are inserted.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>POST_DELAY</name>
              <description>Controls the amount of time between the end of a data transfer and SSEL deassertion. 0x0 = No additional time is inserted. 0x1 = 1 SPI clock time is inserted. 0x2 = 2 SPI clock times are inserted. ... 0xF = 15 SPI clock times are inserted.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FRAME_DELAY</name>
              <description>If the EOFR flag is set, controls the minimum amount of time between the current frame and the next frame (or SSEL deassertion if EOTR). 0x0 = No additional time is inserted. 0x1 = 1 SPI clock time is inserted. 0x2 = 2 SPI clock times are inserted. ... 0xF = 15 SPI clock times are inserted.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TRANSFER_DELAY</name>
              <description>Controls the minimum amount of time that the SSEL is deasserted between transfers. 0x0 = The minimum time that SSEL is deasserted is 1 SPI clock time. (Zero added time.) 0x1 = The minimum time that SSEL is deasserted is 2 SPI clock times. 0x2 = The minimum time that SSEL is deasserted is 3 SPI clock times. ... 0xF = The minimum time that SSEL is deasserted is 16 SPI clock times.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>STAT</name>
          <description>SPI Status. Some status flags can be cleared by writing a 1 to that bit position.</description>
          <addressOffset>0x408</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x100</resetValue>
          <resetMask>0x1FC</resetMask>
          <fields>
            <field>
              <name>RXOV</name>
              <description>Receiver Overrun interrupt flag. This flag applies only to slave mode (Master = 0). This flag is set when the beginning of a received character is detected while the receiver buffer is still in use. If this occurs, the receiver buffer contents are preserved, and the incoming data is lost. Data received by the SPI should be considered undefined if RxOv is set.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TXUR</name>
              <description>Transmitter Underrun interrupt flag. This flag applies only to slave mode (Master = 0). In this case, the transmitter must begin sending new data on the next input clock if the transmitter is idle. If that data is not available in the transmitter holding register at that point, there is no data to transmit and the TXUR flag is set. Data transmitted by the SPI should be considered undefined if TXUR is set.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SSA</name>
              <description>Slave Select Assert. This flag is set whenever any slave select transitions from deasserted to asserted, in both master and slave modes. This allows determining when the SPI transmit/receive functions become busy, and allows waking up the device from reduced power modes when a slave mode access begins. This flag is cleared by software.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SSD</name>
              <description>Slave Select Deassert. This flag is set whenever any asserted slave selects transition to deasserted, in both master and slave modes. This allows determining when the SPI transmit/receive functions become idle. This flag is cleared by software.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>STALLED</name>
              <description>Stalled status flag. This indicates whether the SPI is currently in a stall condition.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ENDTRANSFER</name>
              <description>End Transfer control bit. Software can set this bit to force an end to the current transfer when the transmitter finishes any activity already in progress, as if the EOTR flag had been set prior to the last transmission. This capability is included to support cases where it is not known when transmit data is written that it will be the end of a transfer. The bit is cleared when the transmitter becomes idle as the transfer comes to an end. Forcing an end of transfer in this manner causes any specified FRAME_DELAY and TRANSFER_DELAY to be inserted.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MSTIDLE</name>
              <description>Master idle status flag. This bit is 1 whenever the SPI master function is fully idle. This means that the transmit holding register is empty and the transmitter is not in the process of sending data.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTENSET</name>
          <description>SPI Interrupt Enable read and Set. A complete value may be read from this register. Writing a 1 to any implemented bit position causes that bit to be set.</description>
          <addressOffset>0x40C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0x13C</resetMask>
          <fields>
            <field>
              <name>RXOVEN</name>
              <description>RX overrun interrupt enable. Determines whether an interrupt occurs when a receiver overrun occurs. This happens in slave mode when there is a need for the receiver to move newly received data to the RXDAT register when it is already in use. The interface prevents receiver overrun in Master mode by not allowing a new transmission to begin when a receiver overrun would otherwise occur.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TXUREN</name>
              <description>TX underrun interrupt enable. Determines whether an interrupt occurs when a transmitter underrun occurs. This happens in slave mode when there is a need to transmit data when none is available.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SSAEN</name>
              <description>Slave select assert interrupt enable. Determines whether an interrupt occurs when the Slave Select is asserted.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SSDEN</name>
              <description>Slave select deassert interrupt enable. Determines whether an interrupt occurs when the Slave Select is deasserted.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MSTIDLEEN</name>
              <description>Master idle interrupt enable.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTENCLR</name>
          <description>SPI Interrupt Enable Clear. Writing a 1 to any implemented bit position causes the corresponding bit in INTENSET to be cleared.</description>
          <addressOffset>0x410</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0x13C</resetMask>
          <fields>
            <field>
              <name>RXOVCLR</name>
              <description>Writing 1 clears the corresponding bit in the INTENSET register.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TXURCLR</name>
              <description>Writing 1 clears the corresponding bit in the INTENSET register.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SSACLR</name>
              <description>Writing 1 clears the corresponding bit in the INTENSET register.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SSDCLR</name>
              <description>Writing 1 clears the corresponding bit in the INTENSET register.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MSTIDLECLR</name>
              <description>Writing 1 clears the corresponding bit in the INTENSET register.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TXCTL</name>
          <description>SPI Transmit Control. If Transmit FIFO is enabled, in FIFOCFG, then values read in this register are affected values in FIFO.</description>
          <addressOffset>0x420</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0xF7F0000</resetMask>
          <fields>
            <field>
              <name>TXSSEL0_N</name>
              <description>Transmit Slave Select 0.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TXSSEL1_N</name>
              <description>Transmit Slave Select 1. Valid only for SPI-1</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TXSSEL2_N</name>
              <description>Transmit Slave Select 2. Valid only for SPI-1</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TXSSEL3_N</name>
              <description>[Reserved] Transmit Slave Select 3.</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EOTR</name>
              <description>End of Transfer.</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EOFR</name>
              <description>End of Frame.</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXIGNORE</name>
              <description>Receive Ignore.</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>LEN</name>
              <description>Data transfer Length.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DIV</name>
          <description>SPI clock Divider</description>
          <addressOffset>0x424</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>DIVVAL</name>
              <description>Rate divider value. Specifies how the SPI Module clock is divided to produce the SPI clock rate in master mode. DIVVAL is -1 encoded such that the value 0 results in SPICLK/1, the value 1 results in SPICLK/2, up to the maximum possible divide value of 0xFFFF, which results in SPICLK/65536.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTSTAT</name>
          <description>SPI Interrupt Status</description>
          <addressOffset>0x428</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0</resetValue>
          <resetMask>0x13C</resetMask>
          <fields>
            <field>
              <name>RXOV</name>
              <description>Receiver Overrun interrupt flag.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TXUR</name>
              <description>Transmitter Underrun interrupt flag.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>SSA</name>
              <description>Slave Select Assert.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>SSD</name>
              <description>Slave Select Deassert.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>MSTIDLE</name>
              <description>Master Idle status flag.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>FIFOCFG</name>
          <description>FIFO configuration and enable register.</description>
          <addressOffset>0xE00</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0x7F033</resetMask>
          <fields>
            <field>
              <name>ENABLETX</name>
              <description>Enable the transmit FIFO. This is automatically enabled when PSELID.PERSEL is set to 2 to configure for SPI functionality</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ENABLERX</name>
              <description>Enable the receive FIFO. This is automatically enabled when PSELID.PERSEL is set to 2 to configure for SPI functionality</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SIZE</name>
              <description>FIFO size configuration. This is a read-only field. 0x0 = Reset value. 0x1 = FIFO is configured as 4 entries of 16bits. This value is read after PSELID.PERSEL=2 for SPI functionlaity. 0x2, 0x3 = not applicable.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>DMATX</name>
              <description>DMA configuration for transmit.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DMARX</name>
              <description>DMA configuration for receive.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EMPTYTX</name>
              <description>Empty command for the transmit FIFO. When a 1 is written to this bit, the TX FIFO is emptied.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EMPTYRX</name>
              <description>Empty command for the receive FIFO. When a 1 is written to this bit, the RX FIFO is emptied.</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>POPDBG</name>
              <description>Pop FIFO for debug reads.</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>FIFOSTAT</name>
          <description>FIFO status register.</description>
          <addressOffset>0xE04</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x30</resetValue>
          <resetMask>0x1F1FFB</resetMask>
          <fields>
            <field>
              <name>TXERR</name>
              <description>TX FIFO error. Will be set if a transmit FIFO error occurs. This could be an overflow caused by pushing data into a full FIFO, or by an underflow if the FIFO is empty when data is needed. Cleared by writing a 1 to this bit.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXERR</name>
              <description>RX FIFO error. Will be set if a receive FIFO overflow occurs, caused by software or DMA not emptying the FIFO fast enough. Cleared by writing a 1 to this bit.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PERINT</name>
              <description>Peripheral interrupt. When 1, this indicates that the peripheral function has asserted an interrupt. The details can be found by reading the peripheral s STAT register.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TXEMPTY</name>
              <description>Transmit FIFO empty. When 1, the transmit FIFO is empty. The peripheral may still be processing the last piece of data.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TXNOTFULL</name>
              <description>Transmit FIFO not full. When 1, the transmit FIFO is not full, so more data can be written. When 0, the transmit FIFO is full and another write would cause it to overflow.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RXNOTEMPTY</name>
              <description>Receive FIFO not empty. When 1, the receive FIFO is not empty, so data can be read. When 0, the receive FIFO is empty.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RXFULL</name>
              <description>Receive FIFO full. When 1, the receive FIFO is full. Data needs to be read out to prevent the peripheral from causing an overflow.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TXLVL</name>
              <description>Transmit FIFO current level. A 0 means the TX FIFO is currently empty, and the TXEMPTY and TXNOTFULL flags will be 1. Other values tell how much data is actually in the TX FIFO at the point where the read occurs. If the TX FIFO is full, the TXEMPTY and TXNOTFULL flags will be 0.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RXLVL</name>
              <description>Receive FIFO current level. A 0 means the RX FIFO is currently empty, and the RXFULL and RXNOTEMPTY flags will be 0. Other values tell how much data is actually in the RX FIFO at the point where the read occurs. If the RX FIFO is full, the RXFULL and RXNOTEMPTY flags will be 1.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>FIFOTRIG</name>
          <description>FIFO trigger settings for interrupt and DMA request.</description>
          <addressOffset>0xE08</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0xF0F03</resetMask>
          <fields>
            <field>
              <name>TXLVLENA</name>
              <description>Transmit FIFO level trigger enable. This trigger will become an interrupt if enabled in FIFOINTENSET, or a DMA trigger if DMATX in FIFOCFG is set.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXLVLENA</name>
              <description>Receive FIFO level trigger enable. This trigger will become an interrupt if enabled in FIFOINTENSET, or a DMA trigger if DMARX in FIFOCFG is set.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TXLVL</name>
              <description>Transmit FIFO level trigger point. This field is used only when TXLVLENA = 1. 0 = trigger when the TX FIFO becomes empty. 1 = trigger when the TX FIFO level decreases to one entry. ... 7 = 1 = trigger when the TX FIFO level decreases to 7 entries (is no longer full).</description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXLVL</name>
              <description>Receive FIFO level trigger point. The RX FIFO level is checked when a new piece of data is received. This field is used only when RXLVLENA = 1. 0 = trigger when the RX FIFO has received one entry (is no longer empty). 1 = trigger when the RX FIFO has received two entries. ... 7 = trigger when the RX FIFO has received 8 entries (has become full).</description>
              <bitOffset>16</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>FIFOINTENSET</name>
          <description>FIFO interrupt enable set (enable) and read register.</description>
          <addressOffset>0xE10</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0xF</resetMask>
          <fields>
            <field>
              <name>TXERR</name>
              <description>Determines whether an interrupt occurs when a transmit error occurs, based on the TXERR flag in the FIFOSTAT register.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXERR</name>
              <description>Determines whether an interrupt occurs when a receive error occurs, based on the RXERR flag in the FIFOSTAT register.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TXLVL</name>
              <description>Determines whether an interrupt occurs when a the transmit FIFO reaches the level specified by the TXLVL field in the FIFOTRIG register.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXLVL</name>
              <description>Determines whether an interrupt occurs when a the receive FIFO reaches the level specified by the TXLVL field in the FIFOTRIG register.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>FIFOINTENCLR</name>
          <description>FIFO interrupt enable clear (disable) and read register.</description>
          <addressOffset>0xE14</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0xF</resetMask>
          <fields>
            <field>
              <name>TXERR</name>
              <description>Writing 1 clears the corresponding bit in the FIFOINTENSET register</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXERR</name>
              <description>Writing 1 clears the corresponding bit in the FIFOINTENSET register</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TXLVL</name>
              <description>Writing 1 clears the corresponding bit in the FIFOINTENSET register</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXLVL</name>
              <description>Writing 1 clears the corresponding bit in the FIFOINTENSET register</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>FIFOINTSTAT</name>
          <description>FIFO interrupt status register.</description>
          <addressOffset>0xE18</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0</resetValue>
          <resetMask>0x1F</resetMask>
          <fields>
            <field>
              <name>TXERR</name>
              <description>TX FIFO error.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RXERR</name>
              <description>RX FIFO error.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TXLVL</name>
              <description>Transmit FIFO level interrupt.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RXLVL</name>
              <description>Receive FIFO level interrupt.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PERINT</name>
              <description>Peripheral interrupt.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>FIFOWR</name>
          <description>FIFO write data. FIFO data not reset by block reset</description>
          <addressOffset>0xE20</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>TXDATA</name>
              <description>Transmit data to the FIFO.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>TXSSEL0_N</name>
              <description>Transmit Slave Select. This field asserts SSEL0 in master mode. The output on the pin is active LOW by default. Remark: The active state of the SSEL0 pin is configured by bits in the CFG register.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>TXSSEL1_N</name>
              <description>Transmit Slave Select. This field asserts SSEL1 in master mode. The output on the pin is active LOW by default. Remark: The active state of the SSEL1 pin is configured by bits in the CFG register.</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>TXSSEL2_N</name>
              <description>Transmit Slave Select. This field asserts SSEL2 in master mode. The output on the pin is active LOW by default. Remark: The active state of the SSEL2 pin is configured by bits in the CFG register.</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>EOT</name>
              <description>End of Transfer. The asserted SSEL will be deasserted at the end of a transfer, and remain so for at least the time specified by the Transfer_delay value in the DLY register.</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>EOF</name>
              <description>End of Frame. Between frames, a delay may be inserted, as defined by the FRAME_DELAY value in the DLY register. The end of a frame may not be particularly meaningful if the FRAME_DELAY value = 0. This control can be used as part of the support for frame lengths greater than 16 bits.</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>RXIGNORE</name>
              <description>Receive Ignore. This allows data to be transmitted using the SPI without the need to read unneeded data from the receiver.Setting this bit simplifies the transmit process and can be used with the DMA.</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>LEN</name>
              <description>Data Length. Specifies the data length from 1 to 16 bits. Note that transfer lengths greater than 16 bits are supported by implementing multiple sequential transmits. 0x0 = Data transfer is 1 bit in length. Note: when LEN = 0, the underrun status is not meaningful. 0x1 = Data transfer is 2 bits in length. 0x2 = Data transfer is 3 bits in length. ... 0xF = Data transfer is 16 bits in length.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>4</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>FIFORD</name>
          <description>FIFO read data.</description>
          <addressOffset>0xE30</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0</resetValue>
          <resetMask>0x1FFFFF</resetMask>
          <fields>
            <field>
              <name>RXDATA</name>
              <description>Received data from the FIFO.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RXSSEL0_N</name>
              <description>Slave Select for receive. This field allows the state of the SSEL0 pin to be saved along with received data. The value will reflect the SSEL0 pin for both master and slave operation. A zero indicates that a slave select is active. The actual polarity of each slave select pin is configured by the related SPOL bit in CFG.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RXSSEL1_N</name>
              <description>Slave Select for receive. This field allows the state of the SSEL1 pin to be saved along with received data. The value will reflect the SSEL1 pin for both master and slave operation. A zero indicates that a slave select is active. The actual polarity of each slave select pin is configured by the related SPOL bit in CFG.</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RXSSEL2_N</name>
              <description>Slave Select for receive. This field allows the state of the SSEL2 pin to be saved along with received data. The value will reflect the SSEL2 pin for both master and slave operation. A zero indicates that a slave select is active. The actual polarity of each slave select pin is configured by the related SPOL bit in CFG.</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>SOT</name>
              <description>Start of Transfer flag. This flag will be 1 if this is the first data after the SSELs went from deasserted to asserted (i.e., any previous transfer has ended). This information can be used to identify the first piece of data in cases where the transfer length is greater than 16 bit.</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>FIFORDNOPOP</name>
          <description>FIFO data read with no FIFO pop.</description>
          <addressOffset>0xE40</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0</resetValue>
          <resetMask>0x1FFFFF</resetMask>
          <fields>
            <field>
              <name>RXDATA</name>
              <description>Received data from the FIFO.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RXSSEL0_N</name>
              <description>Slave Select for receive. This field allows the state of the SSEL0 pin to be saved along with received data. The value will reflect the SSEL0 pin for both master and slave operation. A zero indicates that a slave select is active. The actual polarity of each slave select pin is configured by the related SPOL bit in CFG.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RXSSEL1_N</name>
              <description>Slave Select for receive. This field allows the state of the SSEL1 pin to be saved along with received data. The value will reflect the SSEL1 pin for both master and slave operation. A zero indicates that a slave select is active. The actual polarity of each slave select pin is configured by the related SPOL bit in CFG.</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RXSSEL2_N</name>
              <description>Slave Select for receive. This field allows the state of the SSEL2 pin to be saved along with received data. The value will reflect the SSEL2 pin for both master and slave operation. A zero indicates that a slave select is active. The actual polarity of each slave select pin is configured by the related SPOL bit in CFG.</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>SOT</name>
              <description>Start of Transfer flag. This flag will be 1 if this is the first data after the SSELs went from deasserted to asserted (i.e., any previous transfer has ended). This information can be used to identify the first piece of data in cases where the transfer length is greater than 16 bit.</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PSELID</name>
          <description>Peripheral function select and ID register</description>
          <addressOffset>0xFF8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x101020</resetValue>
          <resetMask>0xFFFFF02F</resetMask>
          <fields>
            <field>
              <name>PERSEL</name>
              <description>Peripheral Select. This field is writable by software. Reset value is 0x0 showing that no peripheral is selected. Write 0x2 to select the SPI function. All other values are not valid.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>LOCK</name>
              <description>Lock the peripheral select. This field is writable by software. 0 Peripheral select can be changed by software. 1 Peripheral select is locked and cannot be changed until this peripheral or the entire device is reset.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SPIPRESENT</name>
              <description>SPI present indicator. This field is Read-only and has value 0x1 to indicate SPI function is present.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ID</name>
              <description>Peripheral Select ID.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ID</name>
          <description>SPI Module Identifier</description>
          <addressOffset>0xFFC</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0xE0201200</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>APERTURE</name>
              <description>Aperture i.e. number minus 1 of consecutive packets 4 Kbytes reserved for this IP</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>MIN_REV</name>
              <description>Minor revision i.e. with no software consequences</description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>MAJ_REV</name>
              <description>Major revision i.e. implies software modifications</description>
              <bitOffset>12</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ID</name>
              <description>Identifier. This is the unique identifier of the module</description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral derivedFrom="SPI0">
      <name>SPI1</name>
      <description>This is the description of component spi. It is a Serial Peripheral Interface with APB bus interface. More details will follow.</description>
      <alternatePeripheral>FLEXCOMM5</alternatePeripheral>
      <groupName>SPI</groupName>
      <baseAddress>0x4008E000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>0x1000</size>
        <usage>registers</usage>
      </addressBlock>
      <interrupt>
        <name>FLEXCOMM5</name>
        <value>16</value>
      </interrupt>
    </peripheral>
    <peripheral>
      <name>SHA0</name>
      <description>SHA</description>
      <groupName>SHA</groupName>
      <baseAddress>0x4008F000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>0x1000</size>
        <usage>registers</usage>
      </addressBlock>
      <interrupt>
        <name>SHA</name>
        <value>55</value>
      </interrupt>
      <registers>
        <register>
          <name>CTRL</name>
          <description>Control register</description>
          <addressOffset>0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0x1307</resetMask>
          <fields>
            <field>
              <name>MODE</name>
              <description>Operational mode: 0: Disabled; 1: SHA1; 2: SHA2-256; 3: SHA2-512; 4-7: Not valid</description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>NEW</name>
              <description>Written with 1 when starting a new Hash. It self clears. Note that the WAITING Status bit will clear for a cycle during the initialization from New=1. Digest/Result is initialized when New is set to 1.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>DMA_I</name>
              <description>Written with 1 to use DMA to fill INDATA. For Hash, will request from DMA for 16 words and then will process the Hash. Normal model is that the DMA interrupts the processor when its length expires.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DMA_O</name>
              <description>Written to 1 to use DMA to drain the digest/output. If both DMA_I and DMA_O are set, the DMA has to know to switch direction and the locations. If written to 0 the DMA is not used and the processor has to read the digest/output in response to the DIGEST interrupt.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>HASHSWPB</name>
              <description>If 1, will swap bytes in the word for SHA hashing. The default is byte order (so LSB is first byte) but this allows swapping to MSB is first.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>STATUS</name>
          <description>Status Regsiter</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0</resetValue>
          <resetMask>0x37</resetMask>
          <fields>
            <field>
              <name>WAITING</name>
              <description>Waiting Status 0: Not waiting for data may be disabled or may be busy. Note that for cryptographic uses, this is not set if IsLast is set nor will it set until at least 1 word is read of the output. 1: Waiting for data to be written in (16 words)</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>DIGEST</name>
              <description>If 1 then a DIGEST is ready and waiting and there is no active next block already started. This is cleared when any data is written, when New is written, or when the block is disabled.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ERROR</name>
              <description>If 1, an error occurred. For normal uses, this is due to an attempted overrun: INDATA was written when it was not appropriate. Write 1 to clear.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>NEEDKEY</name>
              <description>Indicates the block wants the key to be written in (set along with WAITING). 0: no key is needed and writes will not be treated as Key. 1: key is needed and INDATA will be accepted as key. Will also set WAITING.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>NEEDIV</name>
              <description>Indicates the block wants an IV/NONE to be written in (set along with WAITING). 0: no IV is needed, either because written already or because not needed. 1: IV needed and INDATA will be accepted as IV.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTENSET</name>
          <description>Interrupt Enable and Interrupt enable set function</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0x7</resetMask>
          <fields>
            <field>
              <name>WAITING</name>
              <description>0: Will not interrupt when waiting. 1: Will interrupt when waiting. Write 1 to set this bit.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DIGEST</name>
              <description>0: Will not interrupt when Digest is ready. 1: Will interrupt when Digest is ready. Write 1 to set this bit.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ERROR</name>
              <description>0: Will not interrupt on Error. 1: Will interrupt on Error. Write 1 to set this bit.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTENCLR</name>
          <description>Interrupt Clear Register</description>
          <addressOffset>0xC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0x7</resetMask>
          <fields>
            <field>
              <name>WAITING</name>
              <description>Write 1 to clear correspnding bit in INTENSET.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>DIGEST</name>
              <description>Write 1 to clear correspnding bit in INTENSET.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>ERROR</name>
              <description>Write 1 to clear correspnding bit in INTENSET.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MEMCTRL</name>
          <description>Setup Master to access memory</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0x7FF0001</resetMask>
          <fields>
            <field>
              <name>MASTER</name>
              <description>Enables Mastering. 0: Mastering is not used and the normal DMA or Interrupt based model is used with INDATA. 1: Mastering is enabled and DMA and INDATA should not be used.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>COUNT</name>
              <description>Number of 512-bit blocks to copy starting at MEMADDR. This register will decrement after each block is copied, ending in 0. For Hash, the DIGEST interrupt will occur when it reaches 0. If a bus error occurs, it will stop with this field set to the block that failed</description>
              <bitOffset>16</bitOffset>
              <bitWidth>11</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MEMADDR</name>
          <description>Address to start memory access from</description>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BASEADDR</name>
              <description>This field indicates the base address in Internal Flash, SRAM0, SRAMX, or SPIFI to start copying from.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>8</dim>
          <dimIncrement>0x4</dimIncrement>
          <name>INDATA[%s]</name>
          <description>Input Data register</description>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DATA</name>
              <description>In this field the next word is written in little-endian format.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>8</dim>
          <dimIncrement>0x4</dimIncrement>
          <name>DIGEST[%s]</name>
          <description>DIGEST or OUTD0, 5 or 8 bytes of output data, depending upon mode</description>
          <addressOffset>0x40</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DIGEST</name>
              <description>This field contains one word of the Digest.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MASK</name>
          <description>Mask register</description>
          <addressOffset>0x90</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MASK</name>
              <description>Mask register</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ID</name>
          <description>IP identifier</description>
          <addressOffset>0xFFC</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0xEA000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>APERTURE</name>
              <description>Aperture i.e. number minus 1 of consecutive packets 4 Kbytes reserved for this IP</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>MIN_REV</name>
              <description>Minor revision i.e. with no software consequences</description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>MAJ_REV</name>
              <description>Major revision i.e. implies software modifications</description>
              <bitOffset>12</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ID</name>
              <description>Identifier. This is the unique identifier of the module</description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
  </peripherals>
</device>