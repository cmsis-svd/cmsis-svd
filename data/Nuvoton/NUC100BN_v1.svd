<?xml version="1.0" encoding="utf-8"?>
<device schemaVersion="1.1" xmlns:xs="http://www.w3.org/2001/XMLSchema-instance" xs:noNamespaceSchemaLocation="CMSIS-SVD_Schema_1_1.xsd" >
  <name>NUC100BN_v1</name>
  <version>1.0</version>
  <description>NUC100BN_v1 SVD file</description>
  <!-- Bus Interface Properties -->
  <!-- Cortex-M0 is byte addressable -->
  <addressUnitBits>8</addressUnitBits>
  <!-- the maximum data bit width accessible within a single transfer is 32bits -->
  <width>32</width>

  <!-- Register Default Properties -->
  <!-- the size of the registers is set to a bit width of 32. This can be overruled for individual peripherals and/or registers -->
  <size>32</size>
  <!-- the access to all registers is set to be readable and writeable. This can be overruled for individual peripherals and/or registers -->
  <access>read-write</access>
  <!-- for demonstration purposes the resetValue for all registers of the device is set to be 0. This can be overruled within the description -->
  <resetValue>0</resetValue>
  <!-- the resetMask = 0 specifies that by default no register of this device has a defined reset value -->
  <resetMask>0</resetMask>

  <peripherals>
    <peripheral>
      <name>GCR</name>
      <description>GCR Register Map</description>
      <groupName>GCR</groupName>
      <baseAddress>0x50000000</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x0</offset>
        <size>0x14</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x18</offset>
        <size>0x8</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x24</offset>
        <size>0x4</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x30</offset>
        <size>0x14</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x50</offset>
        <size>0x4</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x100</offset>
        <size>0x4</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>PDID</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDID</displayName>
          <description>Part Device Identification Number Register</description>
          <addressOffset>0x0</addressOffset>
          <access>read-only</access>
          <resetValue>0x00140018</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDID</name>
              <description>Part Device Identification Number\nThis register reflects device part number code. S/W can read this register to identify which device is used.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>RSTSRC</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>RSTSRC</displayName>
          <description>System Reset Source Register</description>
          <addressOffset>0x4</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFF00</resetMask>
          <fields>
            <field>
              <name>RSTS_POR</name>
              <description>The RSTS_POR flag is set by the "reset signal" from the Power-On Reset (POR) controller or bit CHIP_RST (IPRSTC1[0]) to indicate the previous reset source.\nWrite 1 to clear this bit to 0.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No reset from POR or CHIP_RST</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Power-On Reset (POR) or CHIP_RST had issued the reset signal to reset the system</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RSTS_RESET</name>
              <description>The RSTS_RESET flag is set by the "reset signal" from the /RESET pin to indicate the previous reset source.\nWrite 1 to clear this bit to 0.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No reset from /RESET pin</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Pin /RESET had issued the reset signal to reset the system</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RSTS_WDT</name>
              <description>The RSTS_WDT flag is set by the "reset signal" from the watchdog timer to indicate the previous reset source.\nWrite 1 to clear this bit to 0.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No reset from watchdog timer</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Watchdog timer had issued the reset signal to reset the system</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RSTS_LVR</name>
              <description>The RSTS_LVR flag is set by the "reset signal" from the Low-Voltage-Reset controller to indicate the previous reset source.\nWrite 1 to clear this bit to 0.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No reset from LVR</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>LVR controller had issued the reset signal to reset the system</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RSTS_BOD</name>
              <description>The RSTS_BOD flag is set by the "reset signal" from the Brown-out-Detector to indicate the previous reset source.\nWrite 1 to clear this bit to 0.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No reset from BOD</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>BOD had issued the reset signal to reset the system</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RSTS_SYS</name>
              <description>The RSTS_SYS flag is set by the "reset signal" from the Cortex_M0 kernel to indicate the previous reset source.\nWrite 1 to clear this bit to 0.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No reset from Cortex_M0</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Cortex_M0 had issued the reset signal to reset the system by writing 1 to bit SYSRESETREQ(AIRCR[2], Application Interrupt and Reset Control Register, address = 0xE000ED0C) in system control registers of Cortex_M0 kernel</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RSTS_CPU</name>
              <description>The RSTS_CPU flag is set by hardware if software writes CPU_RST (IPRSTC1[1]) 1 to reset Cortex-M0 CPU kernel and Flash memory controller (FMC).\nWrite 1 to clear this bit to 0.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No reset from CPU</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Cortex-M0 CPU kernel and FMC are reset by software setting CPU_RST to 1</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>IPRSTC1</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>IPRSTC1</displayName>
          <description>IP Reset Control Register 1</description>
          <addressOffset>0x8</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CHIP_RST</name>
              <description>CHIP One-shot Reset (Write-Protection Bit)\nSetting this bit will reset the whole chip, including CPU kernel and all peripherals, and this bit will automatically return to 0 after the 2 clock cycles.\nThe CHIP_RST is same as the POR reset, all the chip controllers is reset and the chip setting from flash are also reload.\nAbout the difference between CHIP_RST and SYSRESETREQ, please refer to section 5.2.2\nThis bit is the protected bit. It means programming this bit needs to write "59h", "16h", "88h" to address 0x5000_0100 to disable register protection. Refer to the register REGWRPROT at address GCR_BA+0x100\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>CHIP normal operation</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>CHIP one-shot reset</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CPU_RST</name>
              <description>CPU Kernel one-shot reset (Write-protection Bit)\nSetting this bit will only reset the CPU kernel and Flash Memory Controller(FMC), and this bit will automatically return 0 after two clock cycles\nThis bit is the protected bit, It means programming this bit needs to write "59h", "16h", "88h" to address 0x5000_0100 to disable register protection. Refer to the register REGWRPROT at address GCR_BA+0x100.\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>CPU normal operation</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>CPU one-shot reset</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PDMA_RST</name>
              <description>PDMA Controller Reset (Write-protection Bit in NuMicro( NUC100/NUC120 Low Density)\nSetting this bit to 1 will generate a reset signal to the PDMA. User needs to set this bit to 0 to release from reset state.\nThis bit is the protected bit, which means programming this bit needs to write "59h", "16h", "88h" to address 0x5000_0100 to disable register protection. Refer to the register REGWRPROT at address GCR_BA+0x100.\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PDMA controller normal operation</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PDMA controller reset</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>EBI_RST</name>
              <description>EBI Controller Reset (NuMicro( NUC100/NUC120 Low Density 64 pin Package Only) (Write-protection Bit in NuMicro( NUC100/NUC120 Low Density 64-pin Package)\nSet this bit to 1 will generate a reset signal to the EBI. User needs to set this bit to 0 to release from the reset state.\nThis bit is the protected bit, It means programming this bit needs to write "59h", "16h", "88h" to address 0x5000_0100 to disable register protection. Refer to the register REGWRPROT at address GCR_BA+0x100.\n</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>EBI controller normal operation</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>EBI controller reset</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>IPRSTC2</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>IPRSTC2</displayName>
          <description>IP Reset Control Register 2</description>
          <addressOffset>0xC</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>GPIO_RST</name>
              <description>GPIO controller Reset\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO controller normal operation</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIO controller reset</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TMR0_RST</name>
              <description>Timer0 controller Reset\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Timer0 controller normal operation</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Timer0 controller reset</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TMR1_RST</name>
              <description>Timer1 controller Reset\n</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Timer1 controller normal operation</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Timer1 controller reset</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TMR2_RST</name>
              <description>Timer2 controller Reset\n</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Timer2 controller normal operation</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Timer2 controller reset</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TMR3_RST</name>
              <description>Timer3 controller Reset\n</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Timer3 controller normal operation</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Timer3 controller reset</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C0_RST</name>
              <description>I2C0 controller Reset\n</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>I2C0 controller normal operation</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>I2C0 controller reset</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C1_RST</name>
              <description>I2C1 controller Reset\n</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>I2C1 controller normal operation</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>I2C1 controller reset</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SPI0_RST</name>
              <description>SPI0 controller Reset\n</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>SPI0 controller normal operation</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>SPI0 controller reset</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SPI1_RST</name>
              <description>SPI1 controller Reset\n</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>SPI1 controller normal operation</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>SPI1 controller reset</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SPI2_RST</name>
              <description>SPI2 controller Reset (NuMicro( NUC100/NUC120 Medium Density Only)\n</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>SPI2 controller normal operation</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>SPI2 controller reset</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SPI3_RST</name>
              <description>SPI3 controller Reset (NuMicro( NUC100/NUC120 Medium Density Only)\n</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>SPI3 controller normal operation</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>SPI3 controller reset</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>UART0_RST</name>
              <description>UART0 controller Reset\n</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>UART0 controller normal operation</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>UART0 controller reset</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>UART1_RST</name>
              <description>UART1 controller Reset\n</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>UART1 controller normal operation</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>UART1 controller reset</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>UART2_RST</name>
              <description>UART2 controller Reset (NuMicro( NUC100/NUC120 Medium Density Only)\n</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>UART2 controller normal operation</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>UART2 controller reset</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PWM03_RST</name>
              <description>PWM03 controller Reset\n</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM03 controller normal operation</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PWM03 controller reset</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PWM47_RST</name>
              <description>PWM47 controller Reset (NuMicro( NUC100/NUC120 Medium Density Only)\n</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM47 controller normal operation</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PWM47 controller reset</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ACMP_RST</name>
              <description>Analog Comparator Controller Reset\n</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Analog Comparator controller normal operation</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Analog Comparator controller reset</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PS2_RST</name>
              <description>PS/2 Controller Reset\n</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PS/2 controller normal operation</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PS/2 controller reset</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>USBD_RST</name>
              <description>USB Device Controller Reset\n</description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>USB device controller normal operation</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>USB device controller reset</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ADC_RST</name>
              <description>ADC Controller Reset\n</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>ADC controller normal operation</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>ADC controller reset</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>I2S_RST</name>
              <description>I2S Controller Reset\n</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>I2S controller normal operation</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>I2S controller reset</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CPR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CPR</displayName>
          <description>Chip Performance Register</description>
          <addressOffset>0x10</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>HPE</name>
              <description>High Performance Enable (Write-Protection Bit)\nThis bit is used to control chip operation performance.\nWhen this bit set, internal RAM and GPIO access is working with zero wait state, and Flash controller will predict next address more efficiently. The high performance is enabled without limiting by chip operation frequency.\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Chip operation at normal mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Chip operation at high performance mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>BODCR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>BODCR</displayName>
          <description>Brown-out Detector Control Register</description>
          <addressOffset>0x18</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000080</resetValue>
          <resetMask>0xFFFFFFF0</resetMask>
          <fields>
            <field>
              <name>BOD_EN</name>
              <description>Brown-out Detector Enable (write-protection bit)\nThe default value is set by flash controller user configuration register config0 bit[23]\nThis bit is the protected bit, which means programming this needs to write "59h", "16h", "88h" to address 0x5000_0100 to disable register protection. Refer to the register REGWRPROT at address GCR_BA+0x100.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Brown-out Detector function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Brown-out Detector function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BOD_VL</name>
              <description>Brown-out Detector Threshold Voltage Selection (Write-Protection Bit)\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>BOD_RSTEN</name>
              <description>Brown-out Reset Enable (Write-Protection Bit)\nWhile the BOD function is enabled (BOD_EN high) and BOD interrupt function is             enabled (BOD_RSTEN low), BOD will assert an interrupt if BOD_OUT is high. BOD interrupt will keep till to the BOD_EN set to 0. BOD interrupt can be blocked by disabling the NVIC BOD interrupt or disabling BOD function (set BOD_EN low).\nThe default value is set by flash controller user configuration register config0 bit[20].\nThis bit is the protected bit. It means programming this needs to write "59h", "16h", "88h" to address 0x5000_0100 to disable register protection. Refer to the register REGWRPROT at address GCR_BA+0x100.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Brown-out "INTERRUPT" function Enabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Brown-out "RESET" function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BOD_INTF</name>
              <description>Brown-out Detector Interrupt Flag\nWrite 1 to clear this bit to 0.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Brown-out Detector does not detect any voltage draft at VDD down through or up through the voltage of BOD_VL setting</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>When Brown-out Detector detects the VDD is dropped down through the voltage of BOD_VL setting or the VDD is raised up through the voltage of BOD_VL setting, this bit is set to 1 and the Brown-out interrupt is requested if Brown-out interrupt is enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BOD_LPM</name>
              <description>Brown-out Detector Low power Mode (Write-Protection Bit)\nThe BOD consumes about 100 uA in Normal mode, and the low power mode can reduce the current to about 1/10 but slow the BOD response.\nThis bit is the protected bit, which means programming this needs to write "59h", "16h", "88h" to address 0x5000_0100 to disable register protection. Refer to the register REGWRPROT at address GCR_BA+0x100.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>BOD operated in Normal mode (default)</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>BOD low power mode Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BOD_OUT</name>
              <description>Brown-out Detector output status\n</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Brown-out Detector output status is 0. It means the detected voltage is higher than BOD_VL setting or BOD_EN is 0</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Brown-out Detector output status is 1. It means the detected voltage is lower than BOD_VL setting. If the BOD_EN is 0, BOD function disabled , this bit always responds  0</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>LVR_EN</name>
              <description>Low Voltage Reset Enable (Write-Protection Bit)\nThe LVR function reset the chip when the input power voltage is lower than LVR circuit setting. LVR function is enabled in default.\nThis bit is the protected bit. It means programming this needs to write "59h", "16h", "88h" to address 0x5000_0100 to disable register protection. Refer to the register REGWRPROT at address GCR_BA+0x100</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Low Voltage Reset function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Low Voltage Reset function Enabled - After enabling the bit, the LVR function will be active with 100uS delay for LVR output stable. (Default)</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>TEMPCR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>TEMPCR</displayName>
          <description>Temperature Sensor Control Register</description>
          <addressOffset>0x1C</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>VTEMP_EN</name>
              <description>Temperature Sensor Enable\nThis bit is used to enable/disable temperature sensor function.\nAfter this bit is set to 1, the value of temperature can be obtained from ADC conversion result by ADC channel selecting channel 7 and alternative multiplexer channel selecting temperature sensor. Please refer to the ADC function chapter for detailed ADC conversion function description.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Temperature sensor function Disabled (default)</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Temperature sensor function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PORCR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PORCR</displayName>
          <description>Power-On-reset Controller Register</description>
          <addressOffset>0x24</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFF00</resetMask>
          <fields>
            <field>
              <name>POR_DIS_CODE</name>
              <description>Power-On-Reset Enable Control (Write-protection Bits)\nWhen powered on, the POR circuit generates a reset signal to reset the whole chip function, but noise on the power may cause the POR active again. User can disable internal POR circuit to avoid unpredictable noise to cause chip reset by writing 0x5AA5 to this field.\nThe POR function will be active again when  this field is set to another value or chip is reset by other reset source, including:\n/RESET, Watchdog, LVR reset, BOD reset, ICE reset command and the software-chip reset function\nThis bit is the protected bit, which means programming this needs to write "59h", "16h", "88h" to address 0x5000_0100 to disable register protection. Refer to the register REGWRPROT at address GCR_BA+0x100.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>GPA_MFP</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>GPA_MFP</displayName>
          <description>GPIOA Multiple Function and Input Type Control Register</description>
          <addressOffset>0x30</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>GPA_MFP0</name>
              <description>PA.0 Pin Function Selection\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIOA[0] selected to the pin PA.0</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>ADC0 (Analog-to-Digital converter channel 0) function selected to the pin PA.0</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>GPA_MFP1</name>
              <description>PA.1 Pin Function Selection\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GPA_MFP2</name>
              <description>PA.2 Pin Function Selection\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GPA_MFP3</name>
              <description>PA.3 Pin Function Selection\n</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GPA_MFP4</name>
              <description>PA.4 Pin Function Selection\n</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GPA_MFP5</name>
              <description>PA.5 Pin Function Selection\n</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GPA_MFP6</name>
              <description>PA.6 Pin Function Selection\n</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GPA_MFP7</name>
              <description>PA.7 Pin Function Selection\n</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GPA_MFP8</name>
              <description>PA.8 Pin Function Selection\n</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIOA[8] selected to the pin PA.8</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>I2C0 SDA function selected to the pin PA.8</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>GPA_MFP9</name>
              <description>PA.9 Pin Function Selection\n</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIOA[9] selected to the pin PA.9</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>I2C0 SCL function selected to the pin PA.9</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>GPA_MFP10</name>
              <description>PA.10 Pin Function Selection\n</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GPA_MFP11</name>
              <description>PA.11 Pin Function Selection\n</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GPA_MFP12</name>
              <description>PA.12 Pin Function Selection\n</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GPA_MFP13</name>
              <description>PA.13 Pin Function Selection\n</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GPA_MFP14</name>
              <description>PA.14 Pin Function Selection\n</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GPA_MFP15</name>
              <description>PA.15 Pin Function Selection\n</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GPA_TYPEn</name>
              <description></description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIOA[15:0] I/O input Schmitt Trigger function Disabled</description>
                    <value>0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIOA[15:0] I/O input Schmitt Trigger function Enabled</description>
                    <value>1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>GPB_MFP</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>GPB_MFP</displayName>
          <description>GPIOB Multiple Function and Input Type Control Register</description>
          <addressOffset>0x34</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>GPB_MFP0</name>
              <description>PB.0 Pin Function Selection\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIOB[0] selected to the pin PB.0</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>UART0 RXD function selected to the pin PB.0</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>GPB_MFP1</name>
              <description>PB.1 Pin Function Selection\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIOB[1] selected to the pin PB.1</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>UART0 TXD function selected to the pin PB.1</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>GPB_MFP2</name>
              <description>PB.2 Pin Function Selection\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GPB_MFP3</name>
              <description>PB.3 Pin Function Selection\n</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GPB_MFP4</name>
              <description>PB.4 Pin Function Selection\n</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIOB[4] selected to the pin PB.4</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>UART1 RXD function selected to the pin PB.4</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>GPB_MFP5</name>
              <description>PB. 5 Pin Function Selection\n</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIOB[5] is selected to the pin PB.5</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>UART1 TXD function is selected to the pin PB.5</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>GPB_MFP6</name>
              <description>PB.6 Pin Function Selection\n</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GPB_MFP7</name>
              <description>PB.7 Pin Function Selection\n</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GPB_MFP8</name>
              <description>PB.8 Pin Function Selection\n</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIOB[8] selected to the pin PB.8</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>TM0 (Timer/Counter external trigger clock input) function selected to the pin PB.8</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>GPB_MFP9</name>
              <description>PB.9 Pin Function Selection\n</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GPB_MFP10</name>
              <description>PB.10 Pin Function Selection\n</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GPB_MFP11</name>
              <description>PB.11 Pin Function Selection\n</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GPB_MFP12</name>
              <description>PB.12 Pin Function Selection\n</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GPB_MFP13</name>
              <description>PB.13 Pin Function Selection\n</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GPB_MFP14</name>
              <description>PB.14 Pin Function Selection\n</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GPB_MFP15</name>
              <description>PB.15 Pin Function Selection\n</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIOB[15] selected to the pin PB.15</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>External Interrupt INT1 function selected to the pin PB.15</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>GPB_TYPEn</name>
              <description></description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIOB[15:0] I/O input Schmitt Trigger function Disabled</description>
                    <value>0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIOB[15:0] I/O input Schmitt Trigger function Enabled</description>
                    <value>1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>GPC_MFP</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>GPC_MFP</displayName>
          <description>GPIOC Multiple Function and Input Type Control Register</description>
          <addressOffset>0x38</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>GPC_MFP0</name>
              <description>PC.0 Pin Function Selection\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GPC_MFP1</name>
              <description>PC.1 Pin Function Selection\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GPC_MFP2</name>
              <description>PC.2 Pin Function Selection\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GPC_MFP3</name>
              <description>PC.3 Pin Function Selection\n</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GPC_MFP4</name>
              <description>PC.4 Pin Function Selection\n</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIOC[4] is selected to the pin PC.4</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>SPI0 MISO1 (master input, slave output pin-1) function is selected to the pin PC.4</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>GPC_MFP5</name>
              <description>PC.5 Pin Function Selection\n</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIOC[5] is selected to the pin PC.5</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>SPI0 MOSI1 (master output, slave input pin-1) function is selected to the pin PC.5</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>GPC_MFP6</name>
              <description>PC.6 Pin Function Selection\n</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GPC_MFP7</name>
              <description>PC.7 Pin Function Selection\n</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GPC_MFP8</name>
              <description>PC.8 Pin Function Selection\n</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GPC_MFP9</name>
              <description>PC.9 Pin Function Selection\n</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIOC[9] selected to the pin PC.9</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>SPI1 SPICLK function selected to the pin PC.9</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>GPC_MFP10</name>
              <description>PC.10 Pin Function Selection\n</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIOC[10] is selected to the pin PC.10</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>SPI1 MISO0 (master input, slave output pin-0) function selected to the pin PC.10</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>GPC_MFP11</name>
              <description>PC.11 Pin Function Selection\n</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIOC[11] selected to the pin PC.11</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>SPI1 MOSI0 (master output, slave input pin-0) function selected to the pin PC.11</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>GPC_MFP12</name>
              <description>PC.12 Pin Function Selection\n</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIOC[12] selected to the pin PC.12</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>SPI1 MISO1 (master input, slave output pin-1) function selected to the pin PC.12</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>GPC_MFP13</name>
              <description>PC.13 Pin Function Selection\n</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIOC[13] selected to the pin PC.13</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>SPI1 MOSI1 (master output, slave input pin-1) function selected to the pin PC.13</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>GPC_MFP14</name>
              <description>PC.14 Pin Function Selection\n</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GPC_MFP15</name>
              <description>PC.15 Pin Function Selection\n</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GPC_TYPEn</name>
              <description></description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIOC[15:0] I/O input Schmitt Trigger function Disabled</description>
                    <value>0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIOC[15:0] I/O input Schmitt Trigger function Enabled</description>
                    <value>1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>GPD_MFP</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>GPD_MFP</displayName>
          <description>GPIOD Multiple Function and Input Type Control Register</description>
          <addressOffset>0x3C</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>GPD_MFP0</name>
              <description>PD.0 Pin Function Selection (NuMicro( NUC100/NUC120 Medium Density Only)\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIOD[0] selected to the pin PD.0</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>SPI2 SS20 function selected to the pin PD.0</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>GPD_MFP1</name>
              <description>PD.1 Pin Function Selection\nFor NuMicro( NUC100/NUC120 Medium Density:\nFor NuMicro( NUC100/NUC120 Low Density:\nReserved</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIOD[1] selected to the pin PD.1</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>SPI2 SPICLK function selected to the pin PD.1</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>GPD_MFP2</name>
              <description>PD.2 Pin Function Selection\nFor NuMicro( NUC100/NUC120 Medium Density:\nFor NuMicro( NUC100/NUC120 Low Density:\nReserved</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIOD[2] selected to the pin PD.2</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>SPI2 MISO0 (master input, slave output pin-0) function selected to the pin PD.2</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>GPD_MFP3</name>
              <description>PD.3 Pin Function Selection\nFor NuMicro( NUC100/NUC120 Medium Density:\nFor NuMicro( NUC100/NUC120 Low Density:\nReserved</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIOD[3] selected to the pin PD.3</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>SPI2 MOSI0 (master output, slave input pin-0) function selected to the pin PD.3</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>GPD_MFP4</name>
              <description>PD.4 Pin Function Selection (NuMicro( NUC100/NUC120 Medium Density Only)\n</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIOD[4]is selected to the pin PD.4</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>SPI2 MISO1 (master input, slave output pin-1) function selected to the pin PD.4</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>GPD_MFP5</name>
              <description>PD.5 Pin Function Selection (NuMicro( NUC100/NUC120 Medium Density Only)\n</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIOD[5] is selected to the pin PD.5</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>SPI2 MOSI1 (master output, slave input pin-1) function selected to the pin PD.5</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>GPD_MFP6</name>
              <description>Reserved</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GPD_MFP7</name>
              <description>Reserved</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GPD_MFP8</name>
              <description>PD.8 Pin Function Selection (NuMicro( NUC100/NUC120 Medium Density Only)\n</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIOD[8] selected to the pin PD8</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>SPI3 SS30 function selected to the pin PD8</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>GPD_MFP9</name>
              <description>PD.9 Pin Function Selection (NuMicro( NUC100/NUC120 Medium Density Only)\n</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIOD[9] selected to the pin PD.9</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>SPI3 SPICLK function selected to the pin PD.9</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>GPD_MFP10</name>
              <description>PD.10 Pin Function Selection (NuMicro( NUC100/NUC120 Medium Density Only)\n</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIOD[10] selected to the pin PD.10</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>SPI3 MISO0 (master input, slave output pin-0) function selected to the pin PD.10</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>GPD_MFP11</name>
              <description>PD.11 Pin Function Selection (NuMicro( NUC100/NUC120 Medium Density Only)\n</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIOD[11] selected to the pin PD.11</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>SPI3 MOSI0 (master output, slave input pin-0) function selected to the pin PD.11</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>GPD_MFP12</name>
              <description>PD.12 Pin Function Selection (NuMicro( NUC100/NUC120 Medium Density Only)\n</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIOD[12] selected to the pin PD.12</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>SPI3 MISO1 (master input, slave output pin-1) function selected to the pin PD.12</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>GPD_MFP13</name>
              <description>PD.13 Pin Function Selection (NuMicro( NUC100/NUC120 Medium Density Only)\n</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIOD[13] selected to the pin PD.13</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>SPI3 MOSI1 (master output, slave input pin-1) function selected to the pin PD.13</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>GPD_MFP14</name>
              <description>PD.14 Pin Function Selection (NuMicro( NUC100/NUC120 Medium Density Only)\n</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIOD[14] selected to the pin PD.14</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>UART2 RXD function is selected to the pin PD.14</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>GPD_MFP15</name>
              <description>PD.15 Pin Function Selection (NuMicro( NUC100/NUC120 Medium Density Only)\n</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIOD[15] selected to the pin PD.15</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>UART2 TXD function selected to the pin PD.15</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>GPD_TYPEn</name>
              <description></description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIOD[15:0] I/O input Schmitt Trigger function Disabled</description>
                    <value>0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIOD[15:0] I/O input Schmitt Trigger function Enabled</description>
                    <value>1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>GPE_MFP</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>GPE_MFP</displayName>
          <description>GPIOE Multiple Function and Input Type Control Register</description>
          <addressOffset>0x40</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>GPE_MFP0</name>
              <description>PE.0 Pin Function Selection (NuMicro( NUC100/NUC120 Medium Density Only)\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIOE[0] selected to the pin PE.0</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PWM6 function selected to the pin PE.0</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>GPE_MFP1</name>
              <description>PE.1 Pin Function Selection (NuMicro( NUC100/NUC120 Medium Density Only)\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIOE[1] selected to the pin PE.1</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PWM7 function selected to the pin PE.1</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>GPE_MFP5</name>
              <description>PE.5 Pin Function Selection (NuMicro( NUC100/NUC120 Medium Density Only)\n</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIOE[5] selected to the pin PE.5</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PWM5 function selected to the pin PE.5</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>GPE_TYPEn</name>
              <description>Note: In this field, NuMicro( NUC100/NUC120 Low Density only has GPE_TYPE5 bit.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIOE[15:0] I/O input Schmitt Trigger function Disabled</description>
                    <value>0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIOE[15:0] I/O input Schmitt Trigger function Enabled</description>
                    <value>1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>ALT_MFP</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>ALT_MFP</displayName>
          <description>Alternative Multiple Function Pin Control Register</description>
          <addressOffset>0x50</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PB10_S01</name>
              <description>Bits PB10_S01 and GPB_MFP[10] determine the PB.10 function.\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PB9_S11</name>
              <description>Bits PB9_S11 and GPB_MFP[9] determine the PB.9 function.\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PA7_S21</name>
              <description>Bits PA7_S21, GPA_MFP[7] and EBI_EN (ALT_MFP[11]).determine the PA.7 function.\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PB14_S31</name>
              <description>Bits PB14_S31 and GPB_MFP[14] determine the PB.14 function.\n</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PB11_PWM4</name>
              <description>Bits PB11_PWM4 and GPB_MFP[11] determine the PB.11 function.\n</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PC0_I2SLRCLK</name>
              <description>Bits PC0_I2SLRCLK and GPC_MFP[0] determine the PC.0 function.\n</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PC1_I2SBCLK</name>
              <description>Bits PC1_I2SBCLK and GPC_MFP[1] determine the PC.1 function.\n</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PC2_I2SDI</name>
              <description>Bits PC2_I2SDI and GPC_MFP[2] determine the PC.2 function.\n</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PC3_I2SDO</name>
              <description>Bits PC3_I2SDO and GPC_MFP[3] determine the PC.3 function.\n</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PA15_I2SMCLK</name>
              <description>Bits PA15_I2SMCLK and GPA_MFP[15] determine the PA.15 function.\n</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PB12_CLKO</name>
              <description>Bits PB12_CLKO, GPB_MFP[12] and EBI_EN (ALT_MFP[11]) determine the PB.12 function.\n</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EBI_EN</name>
              <description>EBI_EN is used to switch GPIO function to EBI function (AD[15:0], ALE, RE, WE, CS, MCLK), which needs additional registers EBI_EN[7:0] and EBI_MCLK_EN for some GPIO to switch to EBI function(AD[15:8], MCLK).\n</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EBI_MCLK_EN</name>
              <description>Bits EBI_MCLK_EN, EBI_EN and GPC_MFP[8] determine the PC.8 function.\n</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EBI_nWRL_EN</name>
              <description>Bits EBI_nWRL_EN, EBI_EN and GPB_MFP[2] determine the PB.2 function.\n</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EBI_nWRH_EN</name>
              <description>Bits EBI_nWRH_EN, EBI_EN and GPB_MFP[3] determine the PB.3 function.\n</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EBI_HB_EN0</name>
              <description>Bits EBI_HB_EN[0], EBI_EN and GPA_MFP[5] determine the PA.5 function.\n</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EBI_HB_EN1</name>
              <description>Bits EBI_HB_EN[1], EBI_EN and GPA_MFP[4] determine the PA.4 function.\n</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EBI_HB_EN2</name>
              <description>Bits EBI_HB_EN[2], EBI_EN and GPA_MFP[3] determine the PA.3 function.\n</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EBI_HB_EN3</name>
              <description>Bits EBI_HB_EN[3], EBI_EN and GPA_MFP[2] determine the PA.2 function.\n</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EBI_HB_EN4</name>
              <description>Bits EBI_HB_EN[4], EBI_EN and GPA_MFP[1] determine the PA.1 function.\n</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EBI_HB_EN5</name>
              <description>Bits EBI_HB_EN[5], EBI_EN and GPA_MFP[12] determine the PA.12 function.\n</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EBI_HB_EN6</name>
              <description>Bits EBI_HB_EN[6], EBI_EN and GPA_MFP[13] determine the PA.13 function.\n</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EBI_HB_EN7</name>
              <description>EBI_HB_EN is used to switch GPIO function to EBI address/data bus high byte (AD[15:8]), EBI_HB_EN, EBI_EN and the corresponding GPx_MFP[y] determine the Px.y  function.\n</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>REGWRPROT</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>REGWRPROT</displayName>
          <description>Register Write Protect Register</description>
          <addressOffset>0x100</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>REGWRPROT</name>
              <description>Register Write-Protection Code (Write Only)\nSome registers have write-protection function. Writing these registers have to disable the protected function by writing the sequence value "59h", "16h", "88h" to this field. After this sequence is completed, the REGPROTDIS bit will be set to 1 and write-protection registers can be normal write.\nRegister Write-Protection Disable index (Read only)\nThe Protected registers are:\nIPRSTC1: address 0x5000_0008\nCPR: address 0x5000_0010 (Low Density only)\nBODCR: address 0x5000_0018\nPORCR: address 0x5000_0024\nPWRCON: address 0x5000_0200 (bit[6] is not protected for power wake-up interrupt clear) \nAPBCLK bit[0]: address 0x5000_0208 (bit[0] is watchdog clock enable)\nCLKSEL0: address 0x5000_0210 (for HCLK and CPU STCLK clock source select)\nCLKSEL1 bit[1:0]: address 0x5000_0214 (for watchdog clock source select)\nISPCON: address 0x5000_C000 (Flash ISP Control register)\nISPTRG: address 0x5000_C010 (ISP Trigger Control register)\nWTCR: address 0x4000_4000\nFATCON: address 0x5000_C018</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Write-protection Enabled for writing protected registers. Any write to the protected register is ignored</description>
                    <value>0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Write-protection Disabled for writing protected registers</description>
                    <value>1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>write-only</access>
            </field>
          </fields>
       </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>SCS</name>
      <description>SCS Register Map</description>
      <groupName>SCS</groupName>
      <baseAddress>0xE000E000</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x10</offset>
        <size>0xC</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x100</offset>
        <size>0x4</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x180</offset>
        <size>0x4</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x200</offset>
        <size>0x4</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x280</offset>
        <size>0x4</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x400</offset>
        <size>0x20</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0xD00</offset>
        <size>0x8</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0xD0C</offset>
        <size>0x8</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0xD1C</offset>
        <size>0x8</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>SYST_CSR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SYST_CSR</displayName>
          <description>SysTick Control and Status Register</description>
          <addressOffset>0x10</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ENABLE</name>
              <description></description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Counter Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Counter will operate in a multi-shot manner</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TICKINT</name>
              <description></description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Counting down to 0 does not cause the SysTick exception to be pended. Software can use COUNTFLAG to determine if a count to zero has occurred</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Counting down to 0 will cause the SysTick exception to be pended. Clearing the SysTick Current Value register by a register write in software will not cause SysTick to be pended</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CLKSRC</name>
              <description></description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Clock source is (optional) external reference clock</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Core clock used for SysTick</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>COUNTFLAG</name>
              <description>Returns 1 if timer counted to 0 since last time this register was read.\nCOUNTFLAG is set by a count transition from 1 to 0.\nCOUNTFLAG is cleared on read or by a write to the Current Value register.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SYST_RVR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SYST_RVR</displayName>
          <description>SysTick Reload Value Register</description>
          <addressOffset>0x14</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>RELOAD</name>
              <description>Value to load into the Current Value register when the counter reaches 0.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SYST_CVR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SYST_CVR</displayName>
          <description>SysTick Current Value Register</description>
          <addressOffset>0x18</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>CURRENT</name>
              <description>Current counter value. This is the value of the counter at the time it is sampled. The counter does not provide read-modify-write protection. The register is write-clear. A software write of any value will clear the register to 0.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>NVIC_ISER</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>NVIC_ISER</displayName>
          <description>IRQ0 ~ IRQ31 Set-enable Control Register</description>
          <addressOffset>0x100</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SETENA</name>
              <description>Enable one or more interrupts within a group of 32. Each bit represents an interrupt number from IRQ0 ~ IRQ31 (Vector number from 16 ~ 47).\nThe register reads back with the current enable state.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Associated interrupt Enabled</description>
                    <value>1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>NVIC_ICER</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>NVIC_ICER</displayName>
          <description>IRQ0 ~ IRQ31 Clear-enable Control Register</description>
          <addressOffset>0x180</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CLRENA</name>
              <description>Disable one or more interrupts within a group of 32. Each bit represents an interrupt number from IRQ0 ~ IRQ31 (Vector number from 16 ~ 47).\nThe register reads back with the current enable state.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Associated interrupt Disabled</description>
                    <value>1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>NVIC_ISPR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>NVIC_ISPR</displayName>
          <description>IRQ0 ~ IRQ31 Set-pending Control Register</description>
          <addressOffset>0x200</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SETPEND</name>
              <description>The register reads back with the current pending state.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Set pending state of the associated interrupt under software control. Each bit represents an interrupt number from IRQ0 ~ IRQ31 (Vector number from 16 ~ 47)</description>
                    <value>1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>NVIC_ICPR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>NVIC_ICPR</displayName>
          <description>IRQ0 ~ IRQ31 Clear-pending Control Register</description>
          <addressOffset>0x280</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CLRPEND</name>
              <description>The register reads back with the current pending state.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Remove the pending state of associated interrupt under software control. Each bit represents an interrupt number from IRQ0 ~ IRQ31 (Vector number from 16 ~ 47)</description>
                    <value>1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>NVIC_IPR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>NVIC_IPR0</displayName>
          <description>IRQ0 ~ IRQ3 Interrupt Priority Control Register</description>
          <addressOffset>0x400</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PRI_0</name>
              <description>Priority of IRQ0\n"0" denotes the highest priority and "3" denotes the lowest priority.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PRI_1</name>
              <description>Priority of IRQ1\n"0" denotes the highest priority and "3" denotes the lowest priority.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PRI_2</name>
              <description>Priority of IRQ2\n"0" denotes the highest priority and "3" denotes the lowest priority.</description>
              <bitOffset>22</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PRI_3</name>
              <description>Priority of IRQ3\n"0" denotes the highest priority and "3" denotes the lowest priority.</description>
              <bitOffset>30</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>NVIC_IPR1</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>NVIC_IPR1</displayName>
          <description>IRQ4 ~ IRQ7 Interrupt Priority Control Register</description>
          <addressOffset>0x404</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PRI_4</name>
              <description>Priority of IRQ4\n"0" denotes the highest priority and "3" denotes the lowest priority.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PRI_5</name>
              <description>Priority of IRQ5\n"0" denotes the highest priority and "3" denotes the lowest priority.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PRI_6</name>
              <description>Priority of IRQ6\n"0" denotes the highest priority and "3" denotes the lowest priority.</description>
              <bitOffset>22</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PRI_7</name>
              <description>Priority of IRQ7\n"0" denotes the highest priority and "3" denotes the lowest priority.</description>
              <bitOffset>30</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>NVIC_IPR2</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>NVIC_IPR2</displayName>
          <description>IRQ8 ~ IRQ11 Interrupt Priority Control Register</description>
          <addressOffset>0x408</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PRI_8</name>
              <description>Priority of IRQ8\n"0" denotes the highest priority and "3" denotes the lowest priority</description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PRI_9</name>
              <description>Priority of IRQ9\n"0" denotes the highest priority and "3" denotes the lowest priority</description>
              <bitOffset>14</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PRI_10</name>
              <description>Priority of IRQ10\n"0" denotes the highest priority and "3" denotes the lowest priority</description>
              <bitOffset>22</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PRI_11</name>
              <description>Priority of IRQ11\n"0" denotes the highest priority and "3" denotes the lowest priority</description>
              <bitOffset>30</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>NVIC_IPR3</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>NVIC_IPR3</displayName>
          <description>IRQ12 ~ IRQ15 Interrupt Priority Control Register</description>
          <addressOffset>0x40C</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PRI_12</name>
              <description>Priority of IRQ12\n"0" denotes the highest priority and "3" denotes the lowest priority.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PRI_13</name>
              <description>Priority of IRQ13\n"0" denotes the highest priority and "3" denotes the lowest priority.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PRI_14</name>
              <description>Priority of IRQ14\n"0" denotes the highest priority and "3" denotes the lowest priority.</description>
              <bitOffset>22</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PRI_15</name>
              <description>Priority of IRQ15\n"0" denotes the highest priority and "3" denotes the lowest priority.</description>
              <bitOffset>30</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>NVIC_IPR4</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>NVIC_IPR4</displayName>
          <description>IRQ16 ~ IRQ19 Interrupt Priority Control Register</description>
          <addressOffset>0x410</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PRI_16</name>
              <description>Priority of IRQ16\n"0" denotes the highest priority and "3" denotes the lowest priority.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PRI_17</name>
              <description>Priority of IRQ17\n"0" denotes the highest priority and "3" denotes the lowest priority.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PRI_18</name>
              <description>Priority of IRQ18\n"0" denotes the highest priority and "3" denotes the lowest priority.</description>
              <bitOffset>22</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PRI_19</name>
              <description>Priority of IRQ19\n"0" denotes the highest priority and "3" denotes the lowest priority.</description>
              <bitOffset>30</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>NVIC_IPR5</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>NVIC_IPR5</displayName>
          <description>IRQ20 ~ IRQ23 Interrupt Priority Control Register</description>
          <addressOffset>0x414</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PRI_20</name>
              <description>Priority of IRQ20\n"0" denotes the highest priority and "3" denotes the lowest priority.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PRI_21</name>
              <description>Priority of IRQ21\n"0" denotes the highest priority and "3" denotes the lowest priority.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PRI_22</name>
              <description>Priority of IRQ22\n"0" denotes the highest priority and "3" denotes the lowest priority.</description>
              <bitOffset>22</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PRI_23</name>
              <description>Priority of IRQ23\n"0" denotes the highest priority and "3" denotes the lowest priority.</description>
              <bitOffset>30</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>NVIC_IPR6</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>NVIC_IPR6</displayName>
          <description>IRQ24 ~ IRQ27 Interrupt Priority Control Register</description>
          <addressOffset>0x418</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PRI_24</name>
              <description>Priority of IRQ24\n"0" denotes the highest priority and "3" denotes the lowest priority.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PRI_25</name>
              <description>Priority of IRQ25\n"0" denotes the highest priority and "3" denotes the lowest priority.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PRI_26</name>
              <description>Priority of IRQ26\n"0" denotes the highest priority and "3" denotes the lowest priority.</description>
              <bitOffset>22</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PRI_27</name>
              <description>Priority of IRQ27\n"0" denotes the highest priority and "3" denotes the lowest priority.</description>
              <bitOffset>30</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>NVIC_IPR7</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>NVIC_IPR7</displayName>
          <description>IRQ28 ~ IRQ31 Interrupt Priority Control Register</description>
          <addressOffset>0x41C</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PRI_28</name>
              <description>Priority of IRQ28\n"0" denotes the highest priority and "3" denotes the lowest priority</description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PRI_29</name>
              <description>Priority of IRQ29\n"0" denotes the highest priority and "3" denotes the lowest priority</description>
              <bitOffset>14</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PRI_30</name>
              <description>Priority of IRQ30\n"0" denotes the highest priority and "3" denotes the lowest priority</description>
              <bitOffset>22</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PRI_31</name>
              <description>Priority of IRQ31\n"0" denotes the highest priority and "3" denotes the lowest priority</description>
              <bitOffset>30</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CPUID</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CPUID</displayName>
          <description>CPUID Register</description>
          <addressOffset>0xD00</addressOffset>
          <access>read-only</access>
          <resetValue>0x410CC200</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>REVISION</name>
              <description>Read as 0x0</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PARTNO</name>
              <description>Read as 0xC20.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>12</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PART</name>
              <description>Read as 0xC for ARMv6-M parts</description>
              <bitOffset>16</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>IMPLEMENTER</name>
              <description></description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>ICSR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>ICSR</displayName>
          <description>Interrupt Control and State Register</description>
          <addressOffset>0xD04</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>VECTACTIVE</name>
              <description>Contains the active exception number\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>6</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Thread mode</description>
                    <value>0</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>VECTPENDING</name>
              <description>Indicates the exception number of the highest priority pending enabled exception:\n</description>
              <bitOffset>12</bitOffset>
              <bitWidth>6</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No pending exceptions</description>
                    <value>0</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ISRPENDING</name>
              <description>Interrupt pending flag, excluding NMI and Faults:\nThis is a read only bit.</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Interrupt not pending</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Interrupt pending</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ISRPREEMPT</name>
              <description>If set, a pending exception will be serviced on exit from the debug halt state.\nThis is a read only bit.</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PENDSTCLR</name>
              <description>SysTick Exception Clear-pending Bit\nWrite:\nThis is a write only bit. When you want to clear PENDST bit, you must "write 0 to PENDSTSET and write 1 to PENDSTCLR" at the same time.</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Removes the pending state from the SysTick exception</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PENDSTSET</name>
              <description>SysTick Exception Set-pending Bit\nWrite:\n</description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect\nSysTick exception is not pending</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Changes SysTick exception state to pending.\nSysTick exception is pending</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PENDSVCLR</name>
              <description>PendSV clear-pending bit.\nWrite:\nThis is a write only bit. When you want to clear PENDSV bit, you must write 0 to PENDSVSET and write 1 to PENDSVCLR" at the same time.</description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Removes the pending state from the PendSV exception</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PENDSVSET</name>
              <description>PendSV set-pending bit.\nWrite:\nNote: Writing 1 to this bit is the only way to set the PendSV exception state to pending.</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect\nPendSV exception is not pending</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Changes PendSV exception state to pending.\nPendSV exception is pending</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>NMIPENDSET</name>
              <description>NMI set-pending bit\nWrite:\nBecause NMI is the highest-priority exception, normally the processor enters the NMI exception handler as soon as it detects a write of 1 to this bit. Entering the handler then clears this bit to 0. This means a read of this bit by the NMI exception handler returns 1 only if the NMI signal is reasserted while the processor is executing that handler.</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect\nNMI exception not pending</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>changes NMI exception state to pending.\nNMI exception pending</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>AIRCR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>AIRCR</displayName>
          <description>Application Interrupt and Reset Control Register</description>
          <addressOffset>0xD0C</addressOffset>
          <access>read-write</access>
          <resetValue>0xFA050000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>VECTCLRACTIVE</name>
              <description>Setting this bit to 1 will clear all active state information for fixed and configurable exceptions.\nThe bit is a write only bit and can only be written when the core is halted.\nNote: It is the debugger's responsibility to re-initialize the stack.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SYSRESETREQ</name>
              <description>Writing this bit 1 will cause a reset signal to be asserted to the chip to indicate a reset is requested.\nThe bit is a write only bit and self-clears as part of the reset sequence.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>VECTORKEY</name>
              <description>When writing this register, this field should be 0x05FA, otherwise the write action will be unpredictable.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SCR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SCR</displayName>
          <description>System Control Register</description>
          <addressOffset>0xD10</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SLEEPONEXIT</name>
              <description>Indicates sleep-on-exit when returning from Handler mode to Thread mode:\nSetting this bit to 1 enables an interrupt driven application to avoid returning to an empty main application.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Do not sleep when returning to Thread mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enter sleep, or deep sleep, on return from an ISR to Thread mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SLEEPDEEP</name>
              <description>Controls whether the processor uses sleep or deep sleep as its low power mode:\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Sleep</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Deep sleep</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SEVONPEND</name>
              <description>Send Event on Pending bit:\nWhen an event or interrupt enters pending state, the event signal wakes up the processor from WFE. If the processor is not waiting for an event, the event is registered and affects the next WFE.\nThe processor also wakes up on execution of an SEV instruction or an external event.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Only enabled interrupts or events can wake up the processor, disabled interrupts are excluded</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enabled events and all interrupts, including disabled interrupts, can wake up the processor</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SHPR2</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SHPR2</displayName>
          <description>System Handler Priority Register 2</description>
          <addressOffset>0xD1C</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PRI_11</name>
              <description>Priority of system handler 11 - SVCall\n"0" denotes the highest priority and "3" denotes the lowest priority.</description>
              <bitOffset>30</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SHPR3</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SHPR3</displayName>
          <description>System Handler Priority Register 3</description>
          <addressOffset>0xD20</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PRI_14</name>
              <description>Priority of system handler 14 - PendSV\n"0" denotes the highest priority and "3" denotes the lowest priority.</description>
              <bitOffset>22</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PRI_15</name>
              <description>Priority of system handler 15 - SysTick\n"0" denotes the highest priority and "3" denotes the lowest priority.</description>
              <bitOffset>30</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>INT</name>
      <description>INT Register Map</description>
      <groupName>INT</groupName>
      <baseAddress>0x50000300</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x0</offset>
        <size>0x88</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>IRQ0_SRC</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>IRQ0_SRC</displayName>
          <description>IRQ0 (BOD) Interrupt Source Identity</description>
          <addressOffset>0x0</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>INT_SRC</name>
              <description>Interrupt Source\nDefine the interrupt sources for interrupt event.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="IRQ0_SRC">
          <name>IRQ1_SRC</name>
          <displayName>IRQ1_SRC</displayName>
          <description>IRQ1 (WDT) Interrupt Source Identity</description>
          <addressOffset>0x4</addressOffset>
       </register>
       <register derivedFrom="IRQ0_SRC">
          <name>IRQ2_SRC</name>
          <displayName>IRQ2_SRC</displayName>
          <description>IRQ2 (EINT0) Interrupt Source Identity</description>
          <addressOffset>0x8</addressOffset>
       </register>
       <register derivedFrom="IRQ0_SRC">
          <name>IRQ3_SRC</name>
          <displayName>IRQ3_SRC</displayName>
          <description>IRQ3 (EINT1) Interrupt Source Identity</description>
          <addressOffset>0xC</addressOffset>
       </register>
       <register derivedFrom="IRQ0_SRC">
          <name>IRQ4_SRC</name>
          <displayName>IRQ4_SRC</displayName>
          <description>IRQ4 (GPA/B) Interrupt Source Identity</description>
          <addressOffset>0x10</addressOffset>
       </register>
       <register derivedFrom="IRQ0_SRC">
          <name>IRQ5_SRC</name>
          <displayName>IRQ5_SRC</displayName>
          <description>IRQ5 (GPC/D/E) Interrupt Source Identity</description>
          <addressOffset>0x14</addressOffset>
       </register>
       <register derivedFrom="IRQ0_SRC">
          <name>IRQ6_SRC</name>
          <displayName>IRQ6_SRC</displayName>
          <description>IRQ6 (PWMA) Interrupt Source Identity</description>
          <addressOffset>0x18</addressOffset>
       </register>
       <register derivedFrom="IRQ0_SRC">
          <name>IRQ7_SRC</name>
          <displayName>IRQ7_SRC</displayName>
          <description>IRQ7 (PWMB) Interrupt Source Identity</description>
          <addressOffset>0x1C</addressOffset>
       </register>
       <register derivedFrom="IRQ0_SRC">
          <name>IRQ8_SRC</name>
          <displayName>IRQ8_SRC</displayName>
          <description>IRQ8 (TMR0) Interrupt Source Identity</description>
          <addressOffset>0x20</addressOffset>
       </register>
       <register derivedFrom="IRQ0_SRC">
          <name>IRQ9_SRC</name>
          <displayName>IRQ9_SRC</displayName>
          <description>IRQ9 (TMR1) Interrupt Source Identity</description>
          <addressOffset>0x24</addressOffset>
       </register>
       <register derivedFrom="IRQ0_SRC">
          <name>IRQ10_SRC</name>
          <displayName>IRQ10_SRC</displayName>
          <description>IRQ10 (TMR2) Interrupt Source Identity</description>
          <addressOffset>0x28</addressOffset>
       </register>
       <register derivedFrom="IRQ0_SRC">
          <name>IRQ11_SRC</name>
          <displayName>IRQ11_SRC</displayName>
          <description>IRQ11 (TMR3) Interrupt Source Identity</description>
          <addressOffset>0x2C</addressOffset>
       </register>
       <register derivedFrom="IRQ0_SRC">
          <name>IRQ12_SRC</name>
          <displayName>IRQ12_SRC</displayName>
          <description>IRQ12 (UART0) Interrupt Source Identity</description>
          <addressOffset>0x30</addressOffset>
       </register>
       <register derivedFrom="IRQ0_SRC">
          <name>IRQ13_SRC</name>
          <displayName>IRQ13_SRC</displayName>
          <description>IRQ13 (UART1) Interrupt Source Identity</description>
          <addressOffset>0x34</addressOffset>
       </register>
       <register derivedFrom="IRQ0_SRC">
          <name>IRQ14_SRC</name>
          <displayName>IRQ14_SRC</displayName>
          <description>IRQ14 (SPI0) Interrupt Source Identity</description>
          <addressOffset>0x38</addressOffset>
       </register>
       <register derivedFrom="IRQ0_SRC">
          <name>IRQ15_SRC</name>
          <displayName>IRQ15_SRC</displayName>
          <description>IRQ15 (SPI1) Interrupt Source Identity</description>
          <addressOffset>0x3C</addressOffset>
       </register>
       <register derivedFrom="IRQ0_SRC">
          <name>IRQ16_SRC</name>
          <displayName>IRQ16_SRC</displayName>
          <description>IRQ16 (SPI2) Interrupt Source Identity</description>
          <addressOffset>0x40</addressOffset>
       </register>
       <register derivedFrom="IRQ0_SRC">
          <name>IRQ17_SRC</name>
          <displayName>IRQ17_SRC</displayName>
          <description>IRQ17 (SPI3)) Interrupt Source Identity</description>
          <addressOffset>0x44</addressOffset>
       </register>
       <register derivedFrom="IRQ0_SRC">
          <name>IRQ18_SRC</name>
          <displayName>IRQ18_SRC</displayName>
          <description>IRQ18 (I2C0) Interrupt Source Identity</description>
          <addressOffset>0x48</addressOffset>
       </register>
       <register derivedFrom="IRQ0_SRC">
          <name>IRQ19_SRC</name>
          <displayName>IRQ19_SRC</displayName>
          <description>IRQ19 (I2C1) Interrupt Source Identity</description>
          <addressOffset>0x4C</addressOffset>
       </register>
       <register derivedFrom="IRQ0_SRC">
          <name>IRQ20_SRC</name>
          <displayName>IRQ20_SRC</displayName>
          <description>IRQ20 (Reserved) Interrupt Source Identity</description>
          <addressOffset>0x50</addressOffset>
       </register>
       <register derivedFrom="IRQ0_SRC">
          <name>IRQ21_SRC</name>
          <displayName>IRQ21_SRC</displayName>
          <description>IRQ21 (Reserved) Interrupt Source Identity</description>
          <addressOffset>0x54</addressOffset>
       </register>
       <register derivedFrom="IRQ0_SRC">
          <name>IRQ22_SRC</name>
          <displayName>IRQ22_SRC</displayName>
          <description>IRQ22 (Reserved) Interrupt Source Identity</description>
          <addressOffset>0x58</addressOffset>
       </register>
       <register derivedFrom="IRQ0_SRC">
          <name>IRQ23_SRC</name>
          <displayName>IRQ23_SRC</displayName>
          <description>IRQ23 (USBD) Interrupt Source Identity</description>
          <addressOffset>0x5C</addressOffset>
       </register>
       <register derivedFrom="IRQ0_SRC">
          <name>IRQ24_SRC</name>
          <displayName>IRQ24_SRC</displayName>
          <description>IRQ24 (PS/2) Interrupt Source Identity</description>
          <addressOffset>0x60</addressOffset>
       </register>
       <register derivedFrom="IRQ0_SRC">
          <name>IRQ25_SRC</name>
          <displayName>IRQ25_SRC</displayName>
          <description>IRQ25 (ACMP) Interrupt Source Identity</description>
          <addressOffset>0x64</addressOffset>
       </register>
       <register derivedFrom="IRQ0_SRC">
          <name>IRQ26_SRC</name>
          <displayName>IRQ26_SRC</displayName>
          <description>IRQ26 (PDMA) Interrupt Source Identity</description>
          <addressOffset>0x68</addressOffset>
       </register>
       <register derivedFrom="IRQ0_SRC">
          <name>IRQ27_SRC</name>
          <displayName>IRQ27_SRC</displayName>
          <description>IRQ27 (I2S) Interrupt Source Identity</description>
          <addressOffset>0x6C</addressOffset>
       </register>
       <register derivedFrom="IRQ0_SRC">
          <name>IRQ28_SRC</name>
          <displayName>IRQ28_SRC</displayName>
          <description>IRQ28 (PWRWU) Interrupt Source Identity</description>
          <addressOffset>0x70</addressOffset>
       </register>
       <register derivedFrom="IRQ0_SRC">
          <name>IRQ29_SRC</name>
          <displayName>IRQ29_SRC</displayName>
          <description>IRQ29 (ADC) Interrupt Source Identity</description>
          <addressOffset>0x74</addressOffset>
       </register>
       <register derivedFrom="IRQ0_SRC">
          <name>IRQ30_SRC</name>
          <displayName>IRQ30_SRC</displayName>
          <description>IRQ30 (Reserved) Interrupt Source Identity</description>
          <addressOffset>0x78</addressOffset>
       </register>
       <register derivedFrom="IRQ0_SRC">
          <name>IRQ31_SRC</name>
          <displayName>IRQ31_SRC</displayName>
          <description>IRQ31 (RTC) Interrupt Source Identity</description>
          <addressOffset>0x7C</addressOffset>
       </register>
       <register>
          <name>NMI_SEL</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>NMI_SEL</displayName>
          <description>NMI Source Interrupt Select Control Register</description>
          <addressOffset>0x80</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>NMI_SEL</name>
              <description>NMI Interrupt Source Selection\nThe NMI interrupt to Cortex-M0 can be selected from one of the peripheral interrupt by setting NMI_SEL.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>MCU_IRQ</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>MCU_IRQ</displayName>
          <description>MCU IRQ Number Identity Register</description>
          <addressOffset>0x84</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MCU_IRQ</name>
              <description>MCU IRQ Source Register\nThe MCU_IRQ collects all the interrupts from the peripherals and generates the synchronous interrupt to Cortex-M0. There are two modes to generate interrupt to Cortex-M0, the normal mode and test mode.\nThe MCU_IRQ collects all interrupts from each peripheral and synchronizes them and interrupts the Cortex-M0.\nWhen the MCU_IRQ[n] is 0: Set MCU_IRQ[n] 1 will generate an interrupt to Cortex_M0 NVIC[n].\nWhen the MCU_IRQ[n] is 1 (mean an interrupt is assert), setting MCU_IRQ[n] 1 will clear the interrupt and setting MCU_IRQ[n] 0 has no effect.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>CLK</name>
      <description>CLK Register Map</description>
      <groupName>CLK</groupName>
      <baseAddress>0x50000200</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x0</offset>
        <size>0x28</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>PWRCON</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PWRCON</displayName>
          <description>System Power-down Control Register</description>
          <addressOffset>0x0</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000010</resetValue>
          <resetMask>0xFFFFFFF0</resetMask>
          <fields>
            <field>
              <name>XTL12M_EN</name>
              <description>External 4~24 MHz High Speed Crystal Enable (Write-protection Bit)\nThe bit default value is set by flash controller user configuration register config0 [26:24]. When the default clock source is from external 4~24 MHz high speed crystal, this bit is set to 1 automatically\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>External 4~24 MHz high speed crystal Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>External 4~24 MHz high speed crystal Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>XTL32K_EN</name>
              <description>External 32.768 kHz Low Speed Crystal Enable (Write-protection Bit)\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>External 32.768 kHz low speed crystal Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>External 32.768 kHz low speed crystal Enabled (Normal operation)</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>OSC22M_EN</name>
              <description>Internal 22.1184 MHz High Speed Oscillator Enable (Write-protection Bit)\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Internal 22.1184 MHz high speed oscillator Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Internal 22.1184 MHz high speed oscillator Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>OSC10K_EN</name>
              <description>Internal 10 kHz Low Speed Oscillator Enable (Write-protection Bit)\n</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Internal 10 kHz low speed oscillator Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Internal 10 kHz low speed oscillator Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PD_WU_DLY</name>
              <description>Enable the Wake-up Delay Counter (Write-protection Bit)\nWhen the chip wakes up from Power-down mode, the clock control will delay certain clock cycles to wait system clock stable.\nThe delayed clock cycle is 4096 clock cycles when chip work at external 4~24 MHz high speed crystal, and 256 clock cycles when chip work at internal 22.1184 MHz high speed oscillator.\n</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Clock cycles delay Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Clock cycles delay Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PD_WU_INT_EN</name>
              <description>Power-down Mode Wake-up Interrupt Enable (Write-protection Bit)\nThe interrupt will occur when both PD_WU_STS and PD_WU_INT_EN are high.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PD_WU_STS</name>
              <description>Power-down Mode Wake-up Interrupt Status\nSet by "power-down wake-up event", it indicates that resume from Power-down mode" \nThe flag is set if the GPIO, USB, UART, WDT, ACMP, BOD or RTC wake-up occurred\nWrite 1 to clear the bit to 0.\nNote: This bit is working only if PD_WU_INT_EN (PWRCON[5]) set to 1.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PWR_DOWN_EN</name>
              <description>System Power-down Enable Bit (Write-protection Bit)\nWhen this bit is set to 1, the Power-down mode is enabled and chip power-down behavior will depends on the PD_WAIT_CPU bit\n(a) If the PD_WAIT_CPU is 0, then the chip enters Power-down mode immediately after the PWR_DOWN_EN bit set.\n(b) if the PD_WAIT_CPU is 1, then the chip keeps active till the CPU sleep mode is also active and then the chip enters Power-down mode\nWhen chip wakes up from Power-down mode, this bit is auto cleared. Users need to set this bit again for next power-down.\nIn Power-down mode, external 4~24 MHz high speed crystal and the internal 22.1184 MHz high speed oscillator will be disabled in this mode, but the external 32.768 kHz low speed crystal and internal 10 kHz low speed oscillator are not controlled by Power-down mode.\nIn Power-down mode, the PLL and system clock are disabled, and ignored the clock source selection. The clocks of peripheral are not controlled by Power-down mode, if the peripheral clock source is from external 32.768 kHz low speed crystal or the internal 10 kHz low speed oscillator.\n</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Chip operating normally or chip in idle mode because of WFI command</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Chip enters Power-down mode instant or wait CPU sleep command WFI</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PD_WAIT_CPU</name>
              <description>This Bit Control the Power-down Entry Condition (Write-protection Bit)\n</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Chip enters Power-down mode when the PWR_DOWN_EN bit is set to 1</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Chip enters Power-down mode when the both PD_WAIT_CPU and PWR_DOWN_EN bits are set to 1 and CPU runs WFI instruction</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>AHBCLK</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>AHBCLK</displayName>
          <description>AHB Devices Clock Enable Control Register</description>
          <addressOffset>0x4</addressOffset>
          <access>read-write</access>
          <resetValue>0x0000000D</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_EN</name>
              <description>PDMA Controller Clock Enable Control\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PDMA engine clock Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PDMA engine clock Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ISP_EN</name>
              <description>Flash ISP Controller Clock Enable Control\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Flash ISP engine clock Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Flash ISP engine clock Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>EBI_EN</name>
              <description>EBI Controller Clock Enable Control (NuMicro( NUC100/NUC120 Low Density Only)\n</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>EBI engine clock Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>EBI engine clock Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>APBCLK</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>APBCLK</displayName>
          <description>APB Devices Clock Enable Control Register</description>
          <addressOffset>0x8</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFF0</resetMask>
          <fields>
            <field>
              <name>WDT_EN</name>
              <description>Watchdog Timer Clock Enable (write-protection bit)\nThis bit is the protected bit. It means programming this needs to write "59h", "16h", "88h" to address 0x5000_0100 to disable register protection. Refer to the register REGWRPROT at address GCR_BA+0x100.\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Watchdog Timer Clock Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Watchdog Timer Clock Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RTC_EN</name>
              <description>Real-Time-Clock APB interface Clock Enable\nThis bit is used to control the RTC APB clock only, The RTC engine clock source is from the external 32.768 kHz low speed crystal.\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RTC clock Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RTC clock Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TMR0_EN</name>
              <description>Timer0 Clock Enable\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Timer0 clock Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Timer0 clock Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TMR1_EN</name>
              <description>Timer1 Clock Enable\n</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Timer1 clock Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Timer1 clock Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TMR2_EN</name>
              <description>Timer2 Clock Enable\n</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Timer2 clock Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Timer2 clock Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TMR3_EN</name>
              <description>Timer3 Clock Enable\n</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Timer3 clock Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Timer3 clock Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>FDIV_EN</name>
              <description>Frequency Divider Output Clock Enable\n</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>FDIV clock Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>FDIV clock Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C0_EN</name>
              <description>I2C0 Clock Enable\n</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>I2C0 clock Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>I2C0 clock Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C1_EN</name>
              <description>I2C1 Clock Enable\n</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>I2C1 clock Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>I2C1 clock Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SPI0_EN</name>
              <description>SPI0 Clock Enable\n</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>SPI0 clock Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>SPI0 clock Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SPI1_EN</name>
              <description>SPI1 Clock Enable\n</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>SPI1 clock Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>SPI1 clock Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SPI2_EN</name>
              <description>SPI2 Clock Enable (NuMicro( NUC100/NUC120 Medium Density Only)\n</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>SPI2 clock Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>SPI2 clock Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SPI3_EN</name>
              <description>SPI3 Clock Enable (NuMicro( NUC100/NUC120 Medium Density Only)\n</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>SPI3 clock Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>SPI3 clock Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>UART0_EN</name>
              <description>UART0 Clock Enable\n</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>UART0 clock Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>UART0 clock Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>UART1_EN</name>
              <description>UART1 Clock Enable\n</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>UART1 clock Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>UART1 clock Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>UART2_EN</name>
              <description>UART2 Clock Enable (NuMicro( NUC100/NUC120 Medium Density Only)\n</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>UART2 clock Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>UART2 clock Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PWM01_EN</name>
              <description>PWM_01 Clock Enable\n</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM01 clock Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PWM01 clock Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PWM23_EN</name>
              <description>PWM_23 Clock Enable\n</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM23 clock Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PWM23 clock Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PWM45_EN</name>
              <description>PWM_45 Clock Enable (NuMicro( NUC100/NUC120 Medium Density Only)\n</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM45 clock Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PWM45 clock Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PWM67_EN</name>
              <description>PWM_67 Clock Enable (NuMicro( NUC100/NUC120 Medium Density Only)\n</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM67 clock Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PWM67 clock Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>USBD_EN</name>
              <description>USB 2.0 FS Device Controller Clock Enable\n</description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>USB clock Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>USB clock Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ADC_EN</name>
              <description>Analog-Digital-Converter (ADC) Clock Enable\n</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>ADC clock Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>ADC clock Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>I2S_EN</name>
              <description>I2S Clock Enable\n</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>I2S clock Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>I2S clock Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ACMP_EN</name>
              <description>Analog Comparator Clock Enable\n</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Analog Comparator Clock Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Analog Comparator Clock Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PS2_EN</name>
              <description>PS/2 Clock Enable\n</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PS/2 clock Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PS/2 clock Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CLKSTATUS</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CLKSTATUS</displayName>
          <description>Clock Status Monitor Register\n(NuMicro( NUC100/NUC120 Low Density Only)</description>
          <addressOffset>0xC</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFF00</resetMask>
          <fields>
            <field>
              <name>XTL12M_STB</name>
              <description>External 4~24 MHz High Speed crystal clock source stable flag\nThis is read only bit.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>External 4~24 MHz high speed crystal clock is not stable or disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>External 4~24 MHz high speed crystal clock is stable</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>XTL32K_STB</name>
              <description>External 32.768 kHz Low Speed Crystal Clock Source Stable Flag\nThis is read only bit.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>External 32.768 kHz low speed crystal clock is not stable or disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>External 32.768 kHz low speed crystal clock is stable</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PLL_STB</name>
              <description>Internal PLL clock source stable flag\nThis is read only bit.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Internal PLL clock is not stable or disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Internal PLL clock is stable</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>OSC10K_STB</name>
              <description>Internal 10 kHz Low Speed oscillator clock source stable flag\nThis is read only bit.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Internal 10 kHz low speed oscillator clock is not stable or disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Internal 10 kHz low speed oscillator clock is stable</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>OSC22M_STB</name>
              <description>Internal 22.1184 MHz High Speed oscillator clock source stable flag\nThis is read only bit.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Internal 22.1184 MHz high speed oscillator clock is not stable or disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Internal 22.1184 MHz high speed oscillator clock is stable</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_SW_FAIL</name>
              <description>Clock Switching Fail Flag\nThis bit is updated when software switches system clock source. If switch target clock is stable, this bit will be set to 0. If switch target clock is not stable, this bit will be set to 1.\nWrite 1 to clear the bit to zero.\nNote: This bit only support in NuMicro( NUC100/NUC120 Low Density.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Clock switching success</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Clock switching failure</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CLKSEL0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CLKSEL0</displayName>
          <description>Clock Source Select Control Register 0</description>
          <addressOffset>0x10</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000030</resetValue>
          <resetMask>0xFFFFFFF0</resetMask>
          <fields>
            <field>
              <name>HCLK_S</name>
              <description>HCLK Clock Source Selection (Write-Protection Bits)\nBefore clock switching, the related clock sources (both pre-select and new-select) must be turn on\nThe 3-bit default value is reloaded from the value of CFOSC (Config0[26:24]) in user configuration register of Flash controller by any reset. Therefore the default value is either 000b or 111b.\nThese bits are protected bit, It means programming this bit needs to write "59h", "16h", "88h" to address 0x5000_0100 to disable register protection. Refer to the register REGWRPROT at address GCR_BA+0x100.\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Clock source from external 4~24 MHz high speed crystal clock</description>
                    <value>#000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Clock source from external 32.768 kHz low speed crystal clock</description>
                    <value>#001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Clock source from PLL clock</description>
                    <value>#010</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Clock source from internal 10 kHz low speed oscillator clock</description>
                    <value>#011</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>7</name>
                    <description>Clock source from internal 22.1184 MHz high speed oscillator clock</description>
                    <value>#111</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>STCLK_S</name>
              <description>Cortex_M0 SysTick Clock Source Selection (Write-Protection Bits)\n</description>
              <bitOffset>3</bitOffset>
              <bitWidth>3</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Clock source from external 4~24 MHz high speed crystal clock</description>
                    <value>#000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Clock source from external 32.768 kHz low speed crystal clock</description>
                    <value>#001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Clock source from external 4~24 MHz high speed crystal clock/2</description>
                    <value>#010</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Clock source from HCLK/2</description>
                    <value>#011</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>7</name>
                    <description>Clock source from internal 22.1184 MHz high speed oscillator clock/2</description>
                    <value>#111</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CLKSEL1</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CLKSEL1</displayName>
          <description>Clock Source Select Control Register 1</description>
          <addressOffset>0x14</addressOffset>
          <access>read-write</access>
          <resetValue>0xFFFFFFFF</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WDT_S</name>
              <description>Watchdog Timer Clock Source Selection (Write-Protection Bits)\nThese bits are protected bit, program this need to write "59h", "16h", "88h" to address 0x5000_0100 to disable register protection. Refer to the register REGWRPROT at address GCR_BA+0x100.\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Clock source from HCLK/2048 clock</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Clock source from internal 10 kHz low speed oscillator clock</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ADC_S</name>
              <description>ADC Clock Source Selection\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Clock source from external 4~24 MHz high speed crystal clock</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Clock source from PLL clock</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Clock source from internal 22.1184 MHz high speed oscillator clock</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TMR0_S</name>
              <description>TIMER0 Clock Source Selection\n</description>
              <bitOffset>8</bitOffset>
              <bitWidth>3</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Clock source from external 4~24 MHz high speed crystal clock</description>
                    <value>#000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Clock source from external 32.768 kHz low speed crystal clock</description>
                    <value>#001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Clock source from HCLK</description>
                    <value>#010</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>7</name>
                    <description>Clock source from internal 22.1184 MHz high speed oscillator clock</description>
                    <value>#111</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TMR1_S</name>
              <description>TIMER1 Clock Source Selection\n</description>
              <bitOffset>12</bitOffset>
              <bitWidth>3</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Clock source from external 4~24 MHz high speed crystal clock</description>
                    <value>#000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Clock source from external 32.768 kHz low speed crystal clock</description>
                    <value>#001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Clock source from HCLK</description>
                    <value>#010</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>7</name>
                    <description>Clock source from internal 22.1184 MHz high speed oscillator clock</description>
                    <value>#111</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TMR2_S</name>
              <description>TIMER2 Clock Source Selection\n</description>
              <bitOffset>16</bitOffset>
              <bitWidth>3</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Clock source from external 4~24 MHz high speed crystal clock</description>
                    <value>#000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Clock source from external 32.768 kHz low speed crystal clock</description>
                    <value>#001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Clock source from HCLK</description>
                    <value>#010</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>7</name>
                    <description>Clock source from internal 22.1184 MHz high speed oscillator clock</description>
                    <value>#111</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TMR3_S</name>
              <description>TIMER3 Clock Source Selection\n</description>
              <bitOffset>20</bitOffset>
              <bitWidth>3</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Clock source from external 4~24 MHz high speed crystal clock</description>
                    <value>#000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Clock source from external 32.768 kHz low speed crystal clock</description>
                    <value>#001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Clock source from HCLK</description>
                    <value>#010</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>7</name>
                    <description>Clock source from internal 22.1184 MHz high speed oscillator clock</description>
                    <value>#111</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>UART_S</name>
              <description>UART Clock Source Selection\n</description>
              <bitOffset>24</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Clock source from external 4~24 MHz high speed crystal clock</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Clock source from PLL clock</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Clock source from internal 22.1184 MHz high speed oscillator clock</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PWM01_S</name>
              <description>PWM0 and PWM1 Clock Source Selection\nPWM0 and PWM1 use the same Engine clock source; both of them use the same prescaler.\n</description>
              <bitOffset>28</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Clock source from external 4~24 MHz high speed crystal clock</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Clock source from external 32.768 kHz low speed crystal clock</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Clock source from HCLK</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Clock source from internal 22.1184 MHz high speed oscillator clock</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PWM23_S</name>
              <description>PWM2 and PWM3 Clock Source Selection\nPWM2 and PWM3 use the same Engine clock source; both of them use the same prescaler.\n</description>
              <bitOffset>30</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Clock source from external 4~24 MHz high speed crystal clock</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Clock source from external 32.768 kHz low speed crystal clock</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Clock source from HCLK</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Clock source from internal 22.1184 MHz high speed oscillator clock</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CLKDIV</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CLKDIV</displayName>
          <description>Clock Divider Number Register</description>
          <addressOffset>0x18</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>HCLK_N</name>
              <description>HCLK Clock Divide Number from HCLK Clock Source\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>USB_N</name>
              <description>USB clock divide number from PLL Clock\n</description>
              <bitOffset>4</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>UART_N</name>
              <description>UART Clock Divide Number from UART Clock Source\n</description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ADC_N</name>
              <description>ADC clock divide number from ADC Clock Source\n</description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CLKSEL2</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CLKSEL2</displayName>
          <description>Clock Source Select Control Register 2</description>
          <addressOffset>0x1C</addressOffset>
          <access>read-write</access>
          <resetValue>0x000000F0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>I2S_S</name>
              <description>I2S Clock Source Selection\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Clock source from external 4~24 MHz high speed crystal clock</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Clock source from PLL clock</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Clock source from HCLK</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Clock source from internal 22.1184 MHz high speed oscillator clock</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>FRQDIV_S</name>
              <description>Clock Divider Clock Source Selection\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Clock source from external 4~24 MHz high speed crystal clock</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Clock source from external 32.768 kHz low speed crystal clock</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Clock source from HCLK</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Clock source from internal 22.1184 MHz high speed oscillator clock</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PWM45_S</name>
              <description>PWM4 and PWM5 Clock Source Selection (NuMicro( NUC100/NUC120 Medium Density Only)\nPWM4 and PWM5 use the same Engine clock source; both of them use the same prescaler\n</description>
              <bitOffset>4</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Clock source from external 4~24 MHz high speed crystal clock</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Clock source from external 32.768 kHz low speed crystal clock</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Clock source from HCLK</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Clock source from internal 22.1184 MHz high speed oscillator clock</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PWM67_S</name>
              <description>PWM6 and PWM7 Clock Source Selection (NuMicro( NUC100/NUC120 Medium Density Only)\nPWM6 and PWM7 use the same Engine clock source; both of them use the same prescaler\n</description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Clock source from external 4~24 MHz high speed crystal clock</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Clock source from external 32.768 kHz low speed crystal clock</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Clock source from HCLK</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Clock source from internal 22.1184 MHz high speed oscillator clock</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PLLCON</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PLLCON</displayName>
          <description>PLL Control Register</description>
          <addressOffset>0x20</addressOffset>
          <access>read-write</access>
          <resetValue>0x0005C22E</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>FB_DV</name>
              <description>PLL Feedback Divider Control Pins\nRefer to the formulas below the table.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>9</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>IN_DV</name>
              <description>PLL Input Divider Control Pins\nRefer to the formulas below the table.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OUT_DV</name>
              <description>PLL Output Divider Control Pins\nRefer to the formulas below the table.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PD</name>
              <description>Power-down Mode\nIf set the PWR_DOWN_EN bit is set to 1 in PWRCON register, the PLL will enter Power-down mode too.\n</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PLL is in Normal mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PLL is in Power-down mode (default)</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BP</name>
              <description>PLL Bypass Control\n</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PLL is in normal mode (default)</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PLL clock output is same as clock input (XTALin)</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>OE</name>
              <description>PLL OE (FOUT Enable) Pin Control\n</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PLL FOUT Enabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PLL FOUT Fixed Low</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PLL_SRC</name>
              <description>PLL Source Clock Selection\n</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PLL source clock from external 4~24 MHz high speed crystal</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PLL source clock from internal 22.1184 MHz high speed oscillator</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>FRQDIV</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>FRQDIV</displayName>
          <description>Frequency Divider Control Register</description>
          <addressOffset>0x24</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>FSEL</name>
              <description>Divider Output Frequency Selection Bits\nThe formula of output frequency is\nFin is the input clock frequency.\nFout is the frequency of divider output clock.\nN is the 4-bit value of FSEL[3:0].</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DIVIDER_EN</name>
              <description>Frequency Divider Enable Bit\n</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Frequency Divider Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Frequency Divider Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>USB</name>
      <description>USB Register Map</description>
      <groupName>USB</groupName>
      <baseAddress>0x40060000</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x0</offset>
        <size>0x1C</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x20</offset>
        <size>0x60</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x90</offset>
        <size>0x4</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>USB_INTEN</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>USB_INTEN</displayName>
          <description>USB Interrupt Enable Register</description>
          <addressOffset>0x0</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BUS_IE</name>
              <description>Bus Event Interrupt Enable\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>BUS event interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>BUS event interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>USB_IE</name>
              <description>USB Event Interrupt Enable\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>USB event interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>USB event interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>FLDET_IE</name>
              <description>Floating Detected Interrupt Enable\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Floating detect Interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Floating detect Interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>WAKEUP_IE</name>
              <description>USB Wake-up Interrupt Enable\n</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Wake-up Interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Wake-up Interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>WAKEUP_EN</name>
              <description>Wake-up Function Enable\n</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>USB wake-up function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>USB wake-up function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>INNAK_EN</name>
              <description>Active NAK Function and its Status in IN Token\n</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>NAK status is not updated into the endpoint status register when it was set to 0. It also disables the interrupt event when device responds to NAK after receiving IN token</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>NAK status is updated into the endpoint status register, USB_EPSTS, when it  is set to 1 and there is NAK response in IN token. It also enable the interrupt  event when the device responds NAK after receiving IN token</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>USB_INTSTS</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>USB_INTSTS</displayName>
          <description>USB Interrupt Event Status Register</description>
          <addressOffset>0x4</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BUS_STS</name>
              <description>BUS Interrupt Status\nThe BUS event means that there is one of the suspense or the resume function in the bus.\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No BUS event occurred</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Bus event occurred; check USB_ATTR[3:0] to know which kind of bus event was occurred, cleared by write 1 to USB_INTSTS[0]</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>USB_STS</name>
              <description>USB event Interrupt Status\nThe USB event includes the Setup Token, IN Token, OUT ACK, ISO IN, or ISO OUT events in the bus.\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No USB event occurred</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>USB event occurred, check EPSTS0~5[2:0] to know which kind of USB event was occurred, cleared by write 1 to USB_INTSTS[1] or EPSTS0~5 and SETUP (USB_INTSTS[31])</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>FLDET_STS</name>
              <description>Floating Detected Interrupt Status\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>There is not attached/detached event in the USB</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>There is attached/detached event in the USB bus and it is cleared by write 1 to USB_INTSTS[2]</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>WAKEUP_STS</name>
              <description>Wake-up Interrupt Status\n</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No Wake-up event occurred</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Wake-up event occurred, cleared by write 1 to USB_INTSTS[3]</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>EPEVT0</name>
              <description>Endpoint 0's USB Event Status\n</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No event occurred in endpoint 0</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>USB event occurred on Endpoint 0, check USB_EPSTS[10:8] to know which kind of USB event was occurred, cleared by write 1 to USB_INTSTS[16] or USB_INTSTS[1]</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>EPEVT1</name>
              <description>Endpoint 1's USB Event Status\n</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No event occurred in endpoint 1</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>USB event occurred on Endpoint 1, check USB_EPSTS[13:11] to know which kind of USB event was occurred, cleared by write 1 to USB_INTSTS[17] or USB_INTSTS[1]</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>EPEVT2</name>
              <description>Endpoint 2's USB Event Status\n</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No event occurred in endpoint 2</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>USB event occurred on Endpoint 2, check USB_EPSTS[16:14] to know which kind of USB event was occurred, cleared by write 1 to USB_INTSTS[18] or USB_INTSTS[1]</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>EPEVT3</name>
              <description>Endpoint 3's USB Event Status\n</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No event occurred in endpoint 3</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>USB event occurred on Endpoint 3, check USB_EPSTS[19:17] to know which kind of USB event was occurred, cleared by write 1 to USB_INTSTS[19] or USB_INTSTS[1]</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>EPEVT4</name>
              <description>Endpoint 4's USB Event Status\n</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No event occurred in endpoint 4</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>USB event occurred on Endpoint 4, check USB_EPSTS[22:20] to know which kind of USB event was occurred, cleared by write 1 to USB_INTSTS[20] or USB_INTSTS[1]</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>EPEVT5</name>
              <description>Endpoint 5's USB Event Status\n</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No event occurred in endpoint 5</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>USB event occurred on Endpoint 5, check USB_EPSTS[25:23] to know which kind of USB event was occurred, cleared by write 1 to USB_INTSTS[21] or USB_INTSTS[1]</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SETUP</name>
              <description>Setup Event Status\n</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No Setup event</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Setup event occurred, cleared by write 1 to USB_INTSTS[31]</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>USB_FADDR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>USB_FADDR</displayName>
          <description>USB Device Function Address Register</description>
          <addressOffset>0x8</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>FADDR</name>
              <description>USB Device Function Address</description>
              <bitOffset>0</bitOffset>
              <bitWidth>7</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>USB_EPSTS</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>USB_EPSTS</displayName>
          <description>USB Endpoint Status Register</description>
          <addressOffset>0xC</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFF0F</resetMask>
          <fields>
            <field>
              <name>OVERRUN</name>
              <description>Overrun\nIt indicates that the received data is over the maximum payload number or not.\n</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No overrun</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Out Data is more than the Max Payload in MXPLD register or the Setup Data is more than 8 Bytes</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>EPSTS0</name>
              <description>Endpoint 0 Bus Status\nThese bits are used to indicate the current status of this endpoint.\n</description>
              <bitOffset>8</bitOffset>
              <bitWidth>3</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>In ACK</description>
                    <value>#000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>In NAK</description>
                    <value>#001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Out Packet Data0 ACK</description>
                    <value>#010</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Setup ACK</description>
                    <value>#011</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>6</name>
                    <description>Out Packet Data1 ACK</description>
                    <value>#110</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>7</name>
                    <description>Isochronous transfer end</description>
                    <value>#111</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>EPSTS1</name>
              <description>Endpoint 1 Bus Status\nThese bits are used to indicate the current status of this endpoint.\n</description>
              <bitOffset>11</bitOffset>
              <bitWidth>3</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>In ACK</description>
                    <value>#000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>In NAK</description>
                    <value>#001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Out Packet Data0 ACK</description>
                    <value>#010</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Setup ACK</description>
                    <value>#011</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>6</name>
                    <description>Out Packet Data1 ACK</description>
                    <value>#110</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>7</name>
                    <description>Isochronous transfer end</description>
                    <value>#111</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>EPSTS2</name>
              <description>Endpoint 2 Bus Status\nThese bits are used to indicate the current status of this endpoint.\n</description>
              <bitOffset>14</bitOffset>
              <bitWidth>3</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>In ACK</description>
                    <value>#000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>In NAK</description>
                    <value>#001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Out Packet Data0 ACK</description>
                    <value>#010</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Setup ACK</description>
                    <value>#011</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>6</name>
                    <description>Out Packet Data1 ACK</description>
                    <value>#110</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>7</name>
                    <description>Isochronous transfer end</description>
                    <value>#111</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>EPSTS3</name>
              <description>Endpoint 3 Bus Status\nThese bits are used to indicate the current status of this endpoint.\n</description>
              <bitOffset>17</bitOffset>
              <bitWidth>3</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>In ACK</description>
                    <value>#000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>In NAK</description>
                    <value>#001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Out Packet Data0 ACK</description>
                    <value>#010</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Setup ACK</description>
                    <value>#011</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>6</name>
                    <description>Out Packet Data1 ACK</description>
                    <value>#110</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>7</name>
                    <description>Isochronous transfer end</description>
                    <value>#111</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>EPSTS4</name>
              <description>Endpoint 4 Bus Status\nThese bits are used to indicate the current status of this endpoint.\n</description>
              <bitOffset>20</bitOffset>
              <bitWidth>3</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>In ACK</description>
                    <value>#000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>In NAK</description>
                    <value>#001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Out Packet Data0 ACK</description>
                    <value>#010</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Setup ACK</description>
                    <value>#011</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>6</name>
                    <description>Out Packet Data1 ACK</description>
                    <value>#110</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>7</name>
                    <description>Isochronous transfer end</description>
                    <value>#111</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>EPSTS5</name>
              <description>Endpoint 5 Bus Status\nThese bits are used to indicate the current status of this endpoint.\n</description>
              <bitOffset>23</bitOffset>
              <bitWidth>3</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>In ACK</description>
                    <value>#000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>In NAK</description>
                    <value>#001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Out Packet Data0 ACK</description>
                    <value>#010</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Setup ACK</description>
                    <value>#011</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>6</name>
                    <description>Out Packet Data1 ACK</description>
                    <value>#110</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>7</name>
                    <description>Isochronous transfer end</description>
                    <value>#111</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>USB_ATTR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>USB_ATTR</displayName>
          <description>USB Bus Status and Attribution Register</description>
          <addressOffset>0x10</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000040</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>USBRST</name>
              <description>USB Reset Status\nIt is a read only bit.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Bus no reset</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Bus reset when SE0 (single-ended 0) more than 2.5us</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SUSPEND</name>
              <description>Suspend Status\nIt is a read only bit.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Bus no suspend</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Bus idle more than 3ms, either cable is plugged off or host is sleeping</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RESUME</name>
              <description>Resume Status\nIt is a read only bit.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No bus resume</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Resume from suspend</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TIMEOUT</name>
              <description>Time Out Status\nIt is a read only bit.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No time-out</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>No Bus response more than 18 bits time</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PHY_EN</name>
              <description>PHY Transceiver Function Enable\n</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PHY transceiver function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PHY transceiver function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RWAKEUP</name>
              <description>Remote Wake-up\n</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Release the USB bus from K state</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Force USB bus to K (USB_DP low, USB_DM: high) state, used for remote wake-up</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>USB_EN</name>
              <description>USB Controller Enable\n</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>USB Controller Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>USB Controller Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DPPU_EN</name>
              <description>Pull-up resistor on USB_DP enable\n</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Pull-up resistor in USB_DP bus Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Pull-up resistor in USB_DP bus Active</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PWRDN</name>
              <description>Power-down PHY Transceiver, low active\n</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Power-down related circuit of PHY transceiver</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Turn on related circuit of  PHY transceiver</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BYTEM</name>
              <description>CPU access USB SRAM Size Mode Select\n</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Word mode: The size of the transfer from CPU to USB SRAM can be Word only</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Byte mode: The size of the transfer from CPU to USB SRAM can be Byte only</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>USB_FLDET</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>USB_FLDET</displayName>
          <description>USB Floating Detected Register</description>
          <addressOffset>0x14</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>FLDET</name>
              <description>Device Floating Detected\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Controller is not attached into the USB host</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Controller is attached into the BUS</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>USB_STBUFSEG</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>USB_STBUFSEG</displayName>
          <description>Setup Token Buffer Segmentation Register</description>
          <addressOffset>0x18</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>STBUFSEG</name>
              <description>It is used to indicate the offset address for the Setup token with the USB SRAM starting address. The effective starting address is\nUSB_SRAM address + { STBUFSEG[8:3], 3'b000} \nNote: It is used for Setup token only.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>USB_BUFSEG0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>USB_BUFSEG0</displayName>
          <description>Endpoint 0 Buffer Segmentation Register</description>
          <addressOffset>0x20</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BUFSEG</name>
              <description>It is used to indicate the offset address for each endpoint with the USB SRAM starting address. The effective starting address of the endpoint is:\nUSB_SRAM address + { BUFSEG[8:3], 3'b000}\nRefer to the section 5.4.4.7 for the endpoint SRAM structure and its description.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>USB_MXPLD0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>USB_MXPLD0</displayName>
          <description>Endpoint 0 Maximal Payload Register</description>
          <addressOffset>0x24</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MXPLD</name>
              <description>Maximal Payload\nDefine the data length which is transmitted to host (IN token) or the actual data length which is received from the host (OUT token). It also used to indicate that the endpoint is ready to be transmitted in IN token or received in OUT token.\n(1) When the register is written by CPU, \nFor IN token, the value of MXPLD is used to define the data length to be transmitted and indicate the data buffer is ready.\nFor OUT token, it means that the controller is ready to receive data from the host and the value of MXPLD is the maximal data length comes from host.\n(2)  When the register is read by CPU,\nFor IN token, the value of MXPLD is indicated by the data length be transmitted to host.\nFor OUT token, the value of MXPLD is indicated the actual data length receiving from host.\nNote: Once MXPLD is written, the data packets will be transmitted/received immediately after IN/OUT token arrived.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>9</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>USB_CFG0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>USB_CFG0</displayName>
          <description>Endpoint 0 Configuration Register</description>
          <addressOffset>0x28</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>EP_NUM</name>
              <description>Endpoint Number\nThese bits are used to define the endpoint number of the current endpoint</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ISOCH</name>
              <description>Isochronous Endpoint\nThis bit is used to set the endpoint as Isochronous endpoint, no handshake.\n</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No Isochronous endpoint</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Isochronous endpoint</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>STATE</name>
              <description>Endpoint STATE\n</description>
              <bitOffset>5</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Endpoint Disabled</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Out endpoint</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>IN endpoint</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Undefined</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DSQ_SYNC</name>
              <description>Data Sequence Synchronization\nIt is used to specify the DATA0 or DATA1 PID in the following IN token transaction. H/W will toggle automatically in IN token base on the bit.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>DATA0 PID</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>DATA1 PID</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CSTALL</name>
              <description>Clear STALL Response\n</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disable the device to clear the STALL handshake in setup stage</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Clear the device to response STALL handshake in setup stage</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>USB_CFGP0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>USB_CFGP0</displayName>
          <description>Endpoint 0 Set Stall and Clear In/Out Ready Control Register</description>
          <addressOffset>0x2C</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CLRRDY</name>
              <description>Clear Ready\nWhen the MXPLD register is set by user, it means that the endpoint is ready to transmit or receive data. If the user wants to turn off this transaction before the transaction start, user can set this bit to 1 to turn it off and it is auto clear to 0.\nFor IN token, write '1' to clear the IN token had ready to transmit the data to USB.\nFor OUT token, write '1' to clear the OUT token had ready to receive the data from USB.\nThis bit writes 1 only and is always 0 when it was read back.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SSTALL</name>
              <description>Set STALL\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disable the device to response STALL</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Set the device to respond STALL automatically</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="USB_BUFSEG0">
          <name>USB_BUFSEG1</name>
          <displayName>USB_BUFSEG1</displayName>
          <description>Endpoint 1 Buffer Segmentation Register</description>
          <addressOffset>0x30</addressOffset>
       </register>
       <register derivedFrom="USB_MXPLD0">
          <name>USB_MXPLD1</name>
          <displayName>USB_MXPLD1</displayName>
          <description>Endpoint 1 Maximal Payload Register</description>
          <addressOffset>0x34</addressOffset>
       </register>
       <register derivedFrom="USB_CFG0">
          <name>USB_CFG1</name>
          <displayName>USB_CFG1</displayName>
          <description>Endpoint 1 Configuration Register</description>
          <addressOffset>0x38</addressOffset>
       </register>
       <register derivedFrom="USB_CFGP0">
          <name>USB_CFGP1</name>
          <displayName>USB_CFGP1</displayName>
          <description>Endpoint 1 Set Stall and Clear In/Out Ready Control Register</description>
          <addressOffset>0x3C</addressOffset>
       </register>
       <register derivedFrom="USB_BUFSEG0">
          <name>USB_BUFSEG2</name>
          <displayName>USB_BUFSEG2</displayName>
          <description>Endpoint 2 Buffer Segmentation Register</description>
          <addressOffset>0x40</addressOffset>
       </register>
       <register derivedFrom="USB_MXPLD0">
          <name>USB_MXPLD2</name>
          <displayName>USB_MXPLD2</displayName>
          <description>Endpoint 2 Maximal Payload Register</description>
          <addressOffset>0x44</addressOffset>
       </register>
       <register derivedFrom="USB_CFG0">
          <name>USB_CFG2</name>
          <displayName>USB_CFG2</displayName>
          <description>Endpoint 2 Configuration Register</description>
          <addressOffset>0x48</addressOffset>
       </register>
       <register derivedFrom="USB_CFGP0">
          <name>USB_CFGP2</name>
          <displayName>USB_CFGP2</displayName>
          <description>Endpoint 2 Set Stall and Clear In/Out Ready Control Register</description>
          <addressOffset>0x4C</addressOffset>
       </register>
       <register derivedFrom="USB_BUFSEG0">
          <name>USB_BUFSEG3</name>
          <displayName>USB_BUFSEG3</displayName>
          <description>Endpoint 3 Buffer Segmentation Register</description>
          <addressOffset>0x50</addressOffset>
       </register>
       <register derivedFrom="USB_MXPLD0">
          <name>USB_MXPLD3</name>
          <displayName>USB_MXPLD3</displayName>
          <description>Endpoint 3 Maximal Payload Register</description>
          <addressOffset>0x54</addressOffset>
       </register>
       <register derivedFrom="USB_CFG0">
          <name>USB_CFG3</name>
          <displayName>USB_CFG3</displayName>
          <description>Endpoint 3 Configuration Register</description>
          <addressOffset>0x58</addressOffset>
       </register>
       <register derivedFrom="USB_CFGP0">
          <name>USB_CFGP3</name>
          <displayName>USB_CFGP3</displayName>
          <description>Endpoint 3 Set Stall and Clear In/Out Ready Control Register</description>
          <addressOffset>0x5C</addressOffset>
       </register>
       <register derivedFrom="USB_BUFSEG0">
          <name>USB_BUFSEG4</name>
          <displayName>USB_BUFSEG4</displayName>
          <description>Endpoint 4 Buffer Segmentation Register</description>
          <addressOffset>0x60</addressOffset>
       </register>
       <register derivedFrom="USB_MXPLD0">
          <name>USB_MXPLD4</name>
          <displayName>USB_MXPLD4</displayName>
          <description>Endpoint 4 Maximal Payload Register</description>
          <addressOffset>0x64</addressOffset>
       </register>
       <register derivedFrom="USB_CFG0">
          <name>USB_CFG4</name>
          <displayName>USB_CFG4</displayName>
          <description>Endpoint 4 Configuration Register</description>
          <addressOffset>0x68</addressOffset>
       </register>
       <register derivedFrom="USB_CFGP0">
          <name>USB_CFGP4</name>
          <displayName>USB_CFGP4</displayName>
          <description>Endpoint 4 Set Stall and Clear In/Out Ready Control Register</description>
          <addressOffset>0x6C</addressOffset>
       </register>
       <register derivedFrom="USB_BUFSEG0">
          <name>USB_BUFSEG5</name>
          <displayName>USB_BUFSEG5</displayName>
          <description>Endpoint 5 Buffer Segmentation Register</description>
          <addressOffset>0x70</addressOffset>
       </register>
       <register derivedFrom="USB_MXPLD0">
          <name>USB_MXPLD5</name>
          <displayName>USB_MXPLD5</displayName>
          <description>Endpoint 5 Maximal Payload Register</description>
          <addressOffset>0x74</addressOffset>
       </register>
       <register derivedFrom="USB_CFG0">
          <name>USB_CFG5</name>
          <displayName>USB_CFG5</displayName>
          <description>Endpoint 5 Configuration Register</description>
          <addressOffset>0x78</addressOffset>
       </register>
       <register derivedFrom="USB_CFGP0">
          <name>USB_CFGP5</name>
          <displayName>USB_CFGP5</displayName>
          <description>Endpoint 5 Set Stall and Clear In/Out Ready Control Register</description>
          <addressOffset>0x7C</addressOffset>
       </register>
       <register>
          <name>USB_DRVSE0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>USB_DRVSE0</displayName>
          <description>USB Drive SE0 Control Register</description>
          <addressOffset>0x90</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000001</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DRVSE0</name>
              <description>Drive Single Ended Zero in USB Bus\nThe Single Ended Zero (SE0) is when both lines (USB_DP and USB_DM) are being pulled low.\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>None</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Force USB PHY transceiver to drive SE0</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>GP</name>
      <description>GPIO Register Map</description>
      <groupName>GPIO</groupName>
      <baseAddress>0x50004000</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x0</offset>
        <size>0x24</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x40</offset>
        <size>0x24</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x80</offset>
        <size>0x24</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0xC0</offset>
        <size>0x24</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x100</offset>
        <size>0x24</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x180</offset>
        <size>0x4</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x200</offset>
        <size>0x100</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x314</offset>
        <size>0x4</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>GPIOA_PMD</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>GPIOA_PMD</displayName>
          <description>GPIO Port A Pin I/O Mode Control</description>
          <addressOffset>0x0</addressOffset>
          <access>read-write</access>
          <resetValue>0xFFFFFFFF</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PMD0</name>
              <description>GPIOx I/O Pin[n] Mode Control\nDetermine each I/O type GPIOx pin.\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO port [n] pin is in INPUT mode</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIO port [n] pin is in OUTPUT mode</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>GPIO port [n] pin is in Open-Drain mode</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>GPIO port [n] pin is in Quasi-bidirectional mode</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PMD1</name>
              <description>GPIOx I/O Pin[n] Mode Control\nDetermine each I/O type GPIOx pin.\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO port [n] pin is in INPUT mode</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIO port [n] pin is in OUTPUT mode</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>GPIO port [n] pin is in Open-Drain mode</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>GPIO port [n] pin is in Quasi-bidirectional mode</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PMD2</name>
              <description>GPIOx I/O Pin[n] Mode Control\nDetermine each I/O type GPIOx pin.\n</description>
              <bitOffset>4</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO port [n] pin is in INPUT mode</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIO port [n] pin is in OUTPUT mode</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>GPIO port [n] pin is in Open-Drain mode</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>GPIO port [n] pin is in Quasi-bidirectional mode</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PMD3</name>
              <description>GPIOx I/O Pin[n] Mode Control\nDetermine each I/O type GPIOx pin.\n</description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO port [n] pin is in INPUT mode</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIO port [n] pin is in OUTPUT mode</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>GPIO port [n] pin is in Open-Drain mode</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>GPIO port [n] pin is in Quasi-bidirectional mode</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PMD4</name>
              <description>GPIOx I/O Pin[n] Mode Control\nDetermine each I/O type GPIOx pin.\n</description>
              <bitOffset>8</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO port [n] pin is in INPUT mode</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIO port [n] pin is in OUTPUT mode</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>GPIO port [n] pin is in Open-Drain mode</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>GPIO port [n] pin is in Quasi-bidirectional mode</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PMD5</name>
              <description>GPIOx I/O Pin[n] Mode Control\nDetermine each I/O type GPIOx pin.\n</description>
              <bitOffset>10</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO port [n] pin is in INPUT mode</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIO port [n] pin is in OUTPUT mode</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>GPIO port [n] pin is in Open-Drain mode</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>GPIO port [n] pin is in Quasi-bidirectional mode</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PMD6</name>
              <description>GPIOx I/O Pin[n] Mode Control\nDetermine each I/O type GPIOx pin.\n</description>
              <bitOffset>12</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO port [n] pin is in INPUT mode</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIO port [n] pin is in OUTPUT mode</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>GPIO port [n] pin is in Open-Drain mode</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>GPIO port [n] pin is in Quasi-bidirectional mode</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PMD7</name>
              <description>GPIOx I/O Pin[n] Mode Control\nDetermine each I/O type GPIOx pin.\n</description>
              <bitOffset>14</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO port [n] pin is in INPUT mode</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIO port [n] pin is in OUTPUT mode</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>GPIO port [n] pin is in Open-Drain mode</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>GPIO port [n] pin is in Quasi-bidirectional mode</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PMD8</name>
              <description>GPIOx I/O Pin[n] Mode Control\nDetermine each I/O type GPIOx pin.\n</description>
              <bitOffset>16</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO port [n] pin is in INPUT mode</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIO port [n] pin is in OUTPUT mode</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>GPIO port [n] pin is in Open-Drain mode</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>GPIO port [n] pin is in Quasi-bidirectional mode</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PMD9</name>
              <description>GPIOx I/O Pin[n] Mode Control\nDetermine each I/O type GPIOx pin.\n</description>
              <bitOffset>18</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO port [n] pin is in INPUT mode</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIO port [n] pin is in OUTPUT mode</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>GPIO port [n] pin is in Open-Drain mode</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>GPIO port [n] pin is in Quasi-bidirectional mode</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PMD10</name>
              <description>GPIOx I/O Pin[n] Mode Control\nDetermine each I/O type GPIOx pin.\n</description>
              <bitOffset>20</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO port [n] pin is in INPUT mode</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIO port [n] pin is in OUTPUT mode</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>GPIO port [n] pin is in Open-Drain mode</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>GPIO port [n] pin is in Quasi-bidirectional mode</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PMD11</name>
              <description>GPIOx I/O Pin[n] Mode Control\nDetermine each I/O type GPIOx pin.\n</description>
              <bitOffset>22</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO port [n] pin is in INPUT mode</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIO port [n] pin is in OUTPUT mode</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>GPIO port [n] pin is in Open-Drain mode</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>GPIO port [n] pin is in Quasi-bidirectional mode</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PMD12</name>
              <description>GPIOx I/O Pin[n] Mode Control\nDetermine each I/O type GPIOx pin.\n</description>
              <bitOffset>24</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO port [n] pin is in INPUT mode</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIO port [n] pin is in OUTPUT mode</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>GPIO port [n] pin is in Open-Drain mode</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>GPIO port [n] pin is in Quasi-bidirectional mode</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PMD13</name>
              <description>GPIOx I/O Pin[n] Mode Control\nDetermine each I/O type GPIOx pin.\n</description>
              <bitOffset>26</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO port [n] pin is in INPUT mode</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIO port [n] pin is in OUTPUT mode</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>GPIO port [n] pin is in Open-Drain mode</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>GPIO port [n] pin is in Quasi-bidirectional mode</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PMD14</name>
              <description>GPIOx I/O Pin[n] Mode Control\nDetermine each I/O type GPIOx pin.\n</description>
              <bitOffset>28</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO port [n] pin is in INPUT mode</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIO port [n] pin is in OUTPUT mode</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>GPIO port [n] pin is in Open-Drain mode</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>GPIO port [n] pin is in Quasi-bidirectional mode</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PMD15</name>
              <description>GPIOx I/O Pin[n] Mode Control\nDetermine each I/O type GPIOx pin.\n</description>
              <bitOffset>30</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO port [n] pin is in INPUT mode</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIO port [n] pin is in OUTPUT mode</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>GPIO port [n] pin is in Open-Drain mode</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>GPIO port [n] pin is in Quasi-bidirectional mode</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>GPIOA_OFFD</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>GPIOA_OFFD</displayName>
          <description>GPIO Port A Pin Digital Input Path Disable Control</description>
          <addressOffset>0x4</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>OFFD</name>
              <description>GPIOx Pin[n] Digital Input Path Disable Control\nEach of these bits is used to control if the digital input path of corresponding GPIO pin is disabled. If input is analog signal, user can disable GPIO digital input path to avoid creepage\n</description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Digital I/O input path Enabled</description>
                    <value>0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Digital I/O input path Disabled (digital input tied to low)</description>
                    <value>1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>GPIOA_DOUT</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>GPIOA_DOUT</displayName>
          <description>GPIO Port A Data Output Value</description>
          <addressOffset>0x8</addressOffset>
          <access>read-write</access>
          <resetValue>0x0000FFFF</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DOUT0</name>
              <description>GPIOx Pin[n] Output Value\nEach of these bits control the status of a GPIO pin when the GPIO pin is configured as output, open-drain and quasi-mode.\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO port [A/B/C/D/E] Pin[n] will drive Low if the GPIO pin is configured as output, open-drain and quasi-mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIO port [A/B/C/D/E] Pin[n] will drive High if the GPIO pin is configured as output, open-drain and quasi-mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DOUT1</name>
              <description>GPIOx Pin[n] Output Value\nEach of these bits control the status of a GPIO pin when the GPIO pin is configured as output, open-drain and quasi-mode.\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO port [A/B/C/D/E] Pin[n] will drive Low if the GPIO pin is configured as output, open-drain and quasi-mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIO port [A/B/C/D/E] Pin[n] will drive High if the GPIO pin is configured as output, open-drain and quasi-mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DOUT2</name>
              <description>GPIOx Pin[n] Output Value\nEach of these bits control the status of a GPIO pin when the GPIO pin is configured as output, open-drain and quasi-mode.\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO port [A/B/C/D/E] Pin[n] will drive Low if the GPIO pin is configured as output, open-drain and quasi-mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIO port [A/B/C/D/E] Pin[n] will drive High if the GPIO pin is configured as output, open-drain and quasi-mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DOUT3</name>
              <description>GPIOx Pin[n] Output Value\nEach of these bits control the status of a GPIO pin when the GPIO pin is configured as output, open-drain and quasi-mode.\n</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO port [A/B/C/D/E] Pin[n] will drive Low if the GPIO pin is configured as output, open-drain and quasi-mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIO port [A/B/C/D/E] Pin[n] will drive High if the GPIO pin is configured as output, open-drain and quasi-mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DOUT4</name>
              <description>GPIOx Pin[n] Output Value\nEach of these bits control the status of a GPIO pin when the GPIO pin is configured as output, open-drain and quasi-mode.\n</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO port [A/B/C/D/E] Pin[n] will drive Low if the GPIO pin is configured as output, open-drain and quasi-mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIO port [A/B/C/D/E] Pin[n] will drive High if the GPIO pin is configured as output, open-drain and quasi-mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DOUT5</name>
              <description>GPIOx Pin[n] Output Value\nEach of these bits control the status of a GPIO pin when the GPIO pin is configured as output, open-drain and quasi-mode.\n</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO port [A/B/C/D/E] Pin[n] will drive Low if the GPIO pin is configured as output, open-drain and quasi-mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIO port [A/B/C/D/E] Pin[n] will drive High if the GPIO pin is configured as output, open-drain and quasi-mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DOUT6</name>
              <description>GPIOx Pin[n] Output Value\nEach of these bits control the status of a GPIO pin when the GPIO pin is configured as output, open-drain and quasi-mode.\n</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO port [A/B/C/D/E] Pin[n] will drive Low if the GPIO pin is configured as output, open-drain and quasi-mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIO port [A/B/C/D/E] Pin[n] will drive High if the GPIO pin is configured as output, open-drain and quasi-mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DOUT7</name>
              <description>GPIOx Pin[n] Output Value\nEach of these bits control the status of a GPIO pin when the GPIO pin is configured as output, open-drain and quasi-mode.\n</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO port [A/B/C/D/E] Pin[n] will drive Low if the GPIO pin is configured as output, open-drain and quasi-mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIO port [A/B/C/D/E] Pin[n] will drive High if the GPIO pin is configured as output, open-drain and quasi-mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DOUT8</name>
              <description>GPIOx Pin[n] Output Value\nEach of these bits control the status of a GPIO pin when the GPIO pin is configured as output, open-drain and quasi-mode.\n</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO port [A/B/C/D/E] Pin[n] will drive Low if the GPIO pin is configured as output, open-drain and quasi-mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIO port [A/B/C/D/E] Pin[n] will drive High if the GPIO pin is configured as output, open-drain and quasi-mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DOUT9</name>
              <description>GPIOx Pin[n] Output Value\nEach of these bits control the status of a GPIO pin when the GPIO pin is configured as output, open-drain and quasi-mode.\n</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO port [A/B/C/D/E] Pin[n] will drive Low if the GPIO pin is configured as output, open-drain and quasi-mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIO port [A/B/C/D/E] Pin[n] will drive High if the GPIO pin is configured as output, open-drain and quasi-mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DOUT10</name>
              <description>GPIOx Pin[n] Output Value\nEach of these bits control the status of a GPIO pin when the GPIO pin is configured as output, open-drain and quasi-mode.\n</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO port [A/B/C/D/E] Pin[n] will drive Low if the GPIO pin is configured as output, open-drain and quasi-mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIO port [A/B/C/D/E] Pin[n] will drive High if the GPIO pin is configured as output, open-drain and quasi-mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DOUT11</name>
              <description>GPIOx Pin[n] Output Value\nEach of these bits control the status of a GPIO pin when the GPIO pin is configured as output, open-drain and quasi-mode.\n</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO port [A/B/C/D/E] Pin[n] will drive Low if the GPIO pin is configured as output, open-drain and quasi-mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIO port [A/B/C/D/E] Pin[n] will drive High if the GPIO pin is configured as output, open-drain and quasi-mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DOUT12</name>
              <description>GPIOx Pin[n] Output Value\nEach of these bits control the status of a GPIO pin when the GPIO pin is configured as output, open-drain and quasi-mode.\n</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO port [A/B/C/D/E] Pin[n] will drive Low if the GPIO pin is configured as output, open-drain and quasi-mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIO port [A/B/C/D/E] Pin[n] will drive High if the GPIO pin is configured as output, open-drain and quasi-mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DOUT13</name>
              <description>GPIOx Pin[n] Output Value\nEach of these bits control the status of a GPIO pin when the GPIO pin is configured as output, open-drain and quasi-mode.\n</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO port [A/B/C/D/E] Pin[n] will drive Low if the GPIO pin is configured as output, open-drain and quasi-mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIO port [A/B/C/D/E] Pin[n] will drive High if the GPIO pin is configured as output, open-drain and quasi-mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DOUT14</name>
              <description>GPIOx Pin[n] Output Value\nEach of these bits control the status of a GPIO pin when the GPIO pin is configured as output, open-drain and quasi-mode.\n</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO port [A/B/C/D/E] Pin[n] will drive Low if the GPIO pin is configured as output, open-drain and quasi-mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIO port [A/B/C/D/E] Pin[n] will drive High if the GPIO pin is configured as output, open-drain and quasi-mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DOUT15</name>
              <description>GPIOx Pin[n] Output Value\nEach of these bits control the status of a GPIO pin when the GPIO pin is configured as output, open-drain and quasi-mode.\n</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO port [A/B/C/D/E] Pin[n] will drive Low if the GPIO pin is configured as output, open-drain and quasi-mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIO port [A/B/C/D/E] Pin[n] will drive High if the GPIO pin is configured as output, open-drain and quasi-mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>GPIOA_DMASK</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>GPIOA_DMASK</displayName>
          <description>GPIO Port A Data Output Write Mask</description>
          <addressOffset>0xC</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DMASK0</name>
              <description>Port [A/B/C/D/E] Data Output Write Mask\nThese bits are used to protect the corresponding register of GPIOx_DOUT bit[n]. When set the DMASK bit[n] to 1, the corresponding GPIOx_DOUT[n] bit is protected. If the write signal is masked, write data to the protect bit is ignored.\nNote: This function only protects the corresponding GPIOx_DOUT[n] bit, and will not protect corresponding bit control register (GPIOAx_DOUT, GPIOBx_DOUT, GPIOCx_DOUT, GPIODx_DOUT, GPIOEx_DOUT).</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Corresponding GPIOx_DOUT[n] bit can be updated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Corresponding GPIOx_DOUT[n] bit protected</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DMASK1</name>
              <description>Port [A/B/C/D/E] Data Output Write Mask\nThese bits are used to protect the corresponding register of GPIOx_DOUT bit[n]. When set the DMASK bit[n] to 1, the corresponding GPIOx_DOUT[n] bit is protected. If the write signal is masked, write data to the protect bit is ignored.\nNote: This function only protects the corresponding GPIOx_DOUT[n] bit, and will not protect corresponding bit control register (GPIOAx_DOUT, GPIOBx_DOUT, GPIOCx_DOUT, GPIODx_DOUT, GPIOEx_DOUT).</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Corresponding GPIOx_DOUT[n] bit can be updated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Corresponding GPIOx_DOUT[n] bit protected</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DMASK2</name>
              <description>Port [A/B/C/D/E] Data Output Write Mask\nThese bits are used to protect the corresponding register of GPIOx_DOUT bit[n]. When set the DMASK bit[n] to 1, the corresponding GPIOx_DOUT[n] bit is protected. If the write signal is masked, write data to the protect bit is ignored.\nNote: This function only protects the corresponding GPIOx_DOUT[n] bit, and will not protect corresponding bit control register (GPIOAx_DOUT, GPIOBx_DOUT, GPIOCx_DOUT, GPIODx_DOUT, GPIOEx_DOUT).</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Corresponding GPIOx_DOUT[n] bit can be updated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Corresponding GPIOx_DOUT[n] bit protected</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DMASK3</name>
              <description>Port [A/B/C/D/E] Data Output Write Mask\nThese bits are used to protect the corresponding register of GPIOx_DOUT bit[n]. When set the DMASK bit[n] to 1, the corresponding GPIOx_DOUT[n] bit is protected. If the write signal is masked, write data to the protect bit is ignored.\nNote: This function only protects the corresponding GPIOx_DOUT[n] bit, and will not protect corresponding bit control register (GPIOAx_DOUT, GPIOBx_DOUT, GPIOCx_DOUT, GPIODx_DOUT, GPIOEx_DOUT).</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Corresponding GPIOx_DOUT[n] bit can be updated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Corresponding GPIOx_DOUT[n] bit protected</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DMASK4</name>
              <description>Port [A/B/C/D/E] Data Output Write Mask\nThese bits are used to protect the corresponding register of GPIOx_DOUT bit[n]. When set the DMASK bit[n] to 1, the corresponding GPIOx_DOUT[n] bit is protected. If the write signal is masked, write data to the protect bit is ignored.\nNote: This function only protects the corresponding GPIOx_DOUT[n] bit, and will not protect corresponding bit control register (GPIOAx_DOUT, GPIOBx_DOUT, GPIOCx_DOUT, GPIODx_DOUT, GPIOEx_DOUT).</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Corresponding GPIOx_DOUT[n] bit can be updated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Corresponding GPIOx_DOUT[n] bit protected</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DMASK5</name>
              <description>Port [A/B/C/D/E] Data Output Write Mask\nThese bits are used to protect the corresponding register of GPIOx_DOUT bit[n]. When set the DMASK bit[n] to 1, the corresponding GPIOx_DOUT[n] bit is protected. If the write signal is masked, write data to the protect bit is ignored.\nNote: This function only protects the corresponding GPIOx_DOUT[n] bit, and will not protect corresponding bit control register (GPIOAx_DOUT, GPIOBx_DOUT, GPIOCx_DOUT, GPIODx_DOUT, GPIOEx_DOUT).</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Corresponding GPIOx_DOUT[n] bit can be updated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Corresponding GPIOx_DOUT[n] bit protected</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DMASK6</name>
              <description>Port [A/B/C/D/E] Data Output Write Mask\nThese bits are used to protect the corresponding register of GPIOx_DOUT bit[n]. When set the DMASK bit[n] to 1, the corresponding GPIOx_DOUT[n] bit is protected. If the write signal is masked, write data to the protect bit is ignored.\nNote: This function only protects the corresponding GPIOx_DOUT[n] bit, and will not protect corresponding bit control register (GPIOAx_DOUT, GPIOBx_DOUT, GPIOCx_DOUT, GPIODx_DOUT, GPIOEx_DOUT).</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Corresponding GPIOx_DOUT[n] bit can be updated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Corresponding GPIOx_DOUT[n] bit protected</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DMASK7</name>
              <description>Port [A/B/C/D/E] Data Output Write Mask\nThese bits are used to protect the corresponding register of GPIOx_DOUT bit[n]. When set the DMASK bit[n] to 1, the corresponding GPIOx_DOUT[n] bit is protected. If the write signal is masked, write data to the protect bit is ignored.\nNote: This function only protects the corresponding GPIOx_DOUT[n] bit, and will not protect corresponding bit control register (GPIOAx_DOUT, GPIOBx_DOUT, GPIOCx_DOUT, GPIODx_DOUT, GPIOEx_DOUT).</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Corresponding GPIOx_DOUT[n] bit can be updated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Corresponding GPIOx_DOUT[n] bit protected</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DMASK8</name>
              <description>Port [A/B/C/D/E] Data Output Write Mask\nThese bits are used to protect the corresponding register of GPIOx_DOUT bit[n]. When set the DMASK bit[n] to 1, the corresponding GPIOx_DOUT[n] bit is protected. If the write signal is masked, write data to the protect bit is ignored.\nNote: This function only protects the corresponding GPIOx_DOUT[n] bit, and will not protect corresponding bit control register (GPIOAx_DOUT, GPIOBx_DOUT, GPIOCx_DOUT, GPIODx_DOUT, GPIOEx_DOUT).</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Corresponding GPIOx_DOUT[n] bit can be updated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Corresponding GPIOx_DOUT[n] bit protected</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DMASK9</name>
              <description>Port [A/B/C/D/E] Data Output Write Mask\nThese bits are used to protect the corresponding register of GPIOx_DOUT bit[n]. When set the DMASK bit[n] to 1, the corresponding GPIOx_DOUT[n] bit is protected. If the write signal is masked, write data to the protect bit is ignored.\nNote: This function only protects the corresponding GPIOx_DOUT[n] bit, and will not protect corresponding bit control register (GPIOAx_DOUT, GPIOBx_DOUT, GPIOCx_DOUT, GPIODx_DOUT, GPIOEx_DOUT).</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Corresponding GPIOx_DOUT[n] bit can be updated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Corresponding GPIOx_DOUT[n] bit protected</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DMASK10</name>
              <description>Port [A/B/C/D/E] Data Output Write Mask\nThese bits are used to protect the corresponding register of GPIOx_DOUT bit[n]. When set the DMASK bit[n] to 1, the corresponding GPIOx_DOUT[n] bit is protected. If the write signal is masked, write data to the protect bit is ignored.\nNote: This function only protects the corresponding GPIOx_DOUT[n] bit, and will not protect corresponding bit control register (GPIOAx_DOUT, GPIOBx_DOUT, GPIOCx_DOUT, GPIODx_DOUT, GPIOEx_DOUT).</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Corresponding GPIOx_DOUT[n] bit can be updated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Corresponding GPIOx_DOUT[n] bit protected</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DMASK11</name>
              <description>Port [A/B/C/D/E] Data Output Write Mask\nThese bits are used to protect the corresponding register of GPIOx_DOUT bit[n]. When set the DMASK bit[n] to 1, the corresponding GPIOx_DOUT[n] bit is protected. If the write signal is masked, write data to the protect bit is ignored.\nNote: This function only protects the corresponding GPIOx_DOUT[n] bit, and will not protect corresponding bit control register (GPIOAx_DOUT, GPIOBx_DOUT, GPIOCx_DOUT, GPIODx_DOUT, GPIOEx_DOUT).</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Corresponding GPIOx_DOUT[n] bit can be updated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Corresponding GPIOx_DOUT[n] bit protected</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DMASK12</name>
              <description>Port [A/B/C/D/E] Data Output Write Mask\nThese bits are used to protect the corresponding register of GPIOx_DOUT bit[n]. When set the DMASK bit[n] to 1, the corresponding GPIOx_DOUT[n] bit is protected. If the write signal is masked, write data to the protect bit is ignored.\nNote: This function only protects the corresponding GPIOx_DOUT[n] bit, and will not protect corresponding bit control register (GPIOAx_DOUT, GPIOBx_DOUT, GPIOCx_DOUT, GPIODx_DOUT, GPIOEx_DOUT).</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Corresponding GPIOx_DOUT[n] bit can be updated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Corresponding GPIOx_DOUT[n] bit protected</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DMASK13</name>
              <description>Port [A/B/C/D/E] Data Output Write Mask\nThese bits are used to protect the corresponding register of GPIOx_DOUT bit[n]. When set the DMASK bit[n] to 1, the corresponding GPIOx_DOUT[n] bit is protected. If the write signal is masked, write data to the protect bit is ignored.\nNote: This function only protects the corresponding GPIOx_DOUT[n] bit, and will not protect corresponding bit control register (GPIOAx_DOUT, GPIOBx_DOUT, GPIOCx_DOUT, GPIODx_DOUT, GPIOEx_DOUT).</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Corresponding GPIOx_DOUT[n] bit can be updated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Corresponding GPIOx_DOUT[n] bit protected</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DMASK14</name>
              <description>Port [A/B/C/D/E] Data Output Write Mask\nThese bits are used to protect the corresponding register of GPIOx_DOUT bit[n]. When set the DMASK bit[n] to 1, the corresponding GPIOx_DOUT[n] bit is protected. If the write signal is masked, write data to the protect bit is ignored.\nNote: This function only protects the corresponding GPIOx_DOUT[n] bit, and will not protect corresponding bit control register (GPIOAx_DOUT, GPIOBx_DOUT, GPIOCx_DOUT, GPIODx_DOUT, GPIOEx_DOUT).</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Corresponding GPIOx_DOUT[n] bit can be updated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Corresponding GPIOx_DOUT[n] bit protected</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DMASK15</name>
              <description>Port [A/B/C/D/E] Data Output Write Mask\nThese bits are used to protect the corresponding register of GPIOx_DOUT bit[n]. When set the DMASK bit[n] to 1, the corresponding GPIOx_DOUT[n] bit is protected. If the write signal is masked, write data to the protect bit is ignored.\nNote: This function only protects the corresponding GPIOx_DOUT[n] bit, and will not protect corresponding bit control register (GPIOAx_DOUT, GPIOBx_DOUT, GPIOCx_DOUT, GPIODx_DOUT, GPIOEx_DOUT).</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Corresponding GPIOx_DOUT[n] bit can be updated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Corresponding GPIOx_DOUT[n] bit protected</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>GPIOA_PIN</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>GPIOA_PIN</displayName>
          <description>GPIO Port A Pin Value</description>
          <addressOffset>0x10</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFF0000</resetMask>
          <fields>
            <field>
              <name>PIN0</name>
              <description>Port [A/B/C/D/E] Pin Values\nEach bit of the register reflects the actual status of the respective GPIO pin If the bit is 1. The corresponding pin status is high; otherwise, the pin status is low.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PIN1</name>
              <description>Port [A/B/C/D/E] Pin Values\nEach bit of the register reflects the actual status of the respective GPIO pin If the bit is 1. The corresponding pin status is high; otherwise, the pin status is low.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PIN2</name>
              <description>Port [A/B/C/D/E] Pin Values\nEach bit of the register reflects the actual status of the respective GPIO pin If the bit is 1. The corresponding pin status is high; otherwise, the pin status is low.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PIN3</name>
              <description>Port [A/B/C/D/E] Pin Values\nEach bit of the register reflects the actual status of the respective GPIO pin If the bit is 1. The corresponding pin status is high; otherwise, the pin status is low.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PIN4</name>
              <description>Port [A/B/C/D/E] Pin Values\nEach bit of the register reflects the actual status of the respective GPIO pin If the bit is 1. The corresponding pin status is high; otherwise, the pin status is low.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PIN5</name>
              <description>Port [A/B/C/D/E] Pin Values\nEach bit of the register reflects the actual status of the respective GPIO pin If the bit is 1. The corresponding pin status is high; otherwise, the pin status is low.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PIN6</name>
              <description>Port [A/B/C/D/E] Pin Values\nEach bit of the register reflects the actual status of the respective GPIO pin If the bit is 1. The corresponding pin status is high; otherwise, the pin status is low.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PIN7</name>
              <description>Port [A/B/C/D/E] Pin Values\nEach bit of the register reflects the actual status of the respective GPIO pin If the bit is 1. The corresponding pin status is high; otherwise, the pin status is low.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PIN8</name>
              <description>Port [A/B/C/D/E] Pin Values\nEach bit of the register reflects the actual status of the respective GPIO pin If the bit is 1. The corresponding pin status is high; otherwise, the pin status is low.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PIN9</name>
              <description>Port [A/B/C/D/E] Pin Values\nEach bit of the register reflects the actual status of the respective GPIO pin If the bit is 1. The corresponding pin status is high; otherwise, the pin status is low.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PIN10</name>
              <description>Port [A/B/C/D/E] Pin Values\nEach bit of the register reflects the actual status of the respective GPIO pin If the bit is 1. The corresponding pin status is high; otherwise, the pin status is low.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PIN11</name>
              <description>Port [A/B/C/D/E] Pin Values\nEach bit of the register reflects the actual status of the respective GPIO pin If the bit is 1. The corresponding pin status is high; otherwise, the pin status is low.</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PIN12</name>
              <description>Port [A/B/C/D/E] Pin Values\nEach bit of the register reflects the actual status of the respective GPIO pin If the bit is 1. The corresponding pin status is high; otherwise, the pin status is low.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PIN13</name>
              <description>Port [A/B/C/D/E] Pin Values\nEach bit of the register reflects the actual status of the respective GPIO pin If the bit is 1. The corresponding pin status is high; otherwise, the pin status is low.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PIN14</name>
              <description>Port [A/B/C/D/E] Pin Values\nEach bit of the register reflects the actual status of the respective GPIO pin If the bit is 1. The corresponding pin status is high; otherwise, the pin status is low.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PIN15</name>
              <description>Port [A/B/C/D/E] Pin Values\nEach bit of the register reflects the actual status of the respective GPIO pin If the bit is 1. The corresponding pin status is high; otherwise, the pin status is low.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>GPIOA_DBEN</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>GPIOA_DBEN</displayName>
          <description>GPIO Port A De-bounce Enable</description>
          <addressOffset>0x14</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DBEN0</name>
              <description>Port [A/B/C/D/E] Input Signal De-bounce Enable\nDBEN[n] is used to enable the de-bounce function for each corresponding bit. If the input signal pulse width can't be sampled by continuous two de-bounce sample cycle The input signal transition is seen as the signal bounce and will not trigger the interrupt. The de-bounce clock  source is controlled by DBNCECON[4], one de-bounce sample cycle is controlled by DBNCECON[3:0]\nThe de-bounce function is valid for edge triggered interrupt. If the interrupt mode is level triggered, the de-bounce enable bit is ignored.\nNote: It is recommended to set this bit to '0' if GPIO is chosen as power-down wakeup source. If setting this bit to '1', it will cause GPIO to produce interrupt twice. One is caused by wake up event, and the other is caused by delayed de-bounce results.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Bit[n] de-bounce function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Bit[n] de-bounce function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DBEN1</name>
              <description>Port [A/B/C/D/E] Input Signal De-bounce Enable\nDBEN[n] is used to enable the de-bounce function for each corresponding bit. If the input signal pulse width can't be sampled by continuous two de-bounce sample cycle The input signal transition is seen as the signal bounce and will not trigger the interrupt. The de-bounce clock  source is controlled by DBNCECON[4], one de-bounce sample cycle is controlled by DBNCECON[3:0]\nThe de-bounce function is valid for edge triggered interrupt. If the interrupt mode is level triggered, the de-bounce enable bit is ignored.\nNote: It is recommended to set this bit to '0' if GPIO is chosen as power-down wakeup source. If setting this bit to '1', it will cause GPIO to produce interrupt twice. One is caused by wake up event, and the other is caused by delayed de-bounce results.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Bit[n] de-bounce function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Bit[n] de-bounce function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DBEN2</name>
              <description>Port [A/B/C/D/E] Input Signal De-bounce Enable\nDBEN[n] is used to enable the de-bounce function for each corresponding bit. If the input signal pulse width can't be sampled by continuous two de-bounce sample cycle The input signal transition is seen as the signal bounce and will not trigger the interrupt. The de-bounce clock  source is controlled by DBNCECON[4], one de-bounce sample cycle is controlled by DBNCECON[3:0]\nThe de-bounce function is valid for edge triggered interrupt. If the interrupt mode is level triggered, the de-bounce enable bit is ignored.\nNote: It is recommended to set this bit to '0' if GPIO is chosen as power-down wakeup source. If setting this bit to '1', it will cause GPIO to produce interrupt twice. One is caused by wake up event, and the other is caused by delayed de-bounce results.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Bit[n] de-bounce function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Bit[n] de-bounce function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DBEN3</name>
              <description>Port [A/B/C/D/E] Input Signal De-bounce Enable\nDBEN[n] is used to enable the de-bounce function for each corresponding bit. If the input signal pulse width can't be sampled by continuous two de-bounce sample cycle The input signal transition is seen as the signal bounce and will not trigger the interrupt. The de-bounce clock  source is controlled by DBNCECON[4], one de-bounce sample cycle is controlled by DBNCECON[3:0]\nThe de-bounce function is valid for edge triggered interrupt. If the interrupt mode is level triggered, the de-bounce enable bit is ignored.\nNote: It is recommended to set this bit to '0' if GPIO is chosen as power-down wakeup source. If setting this bit to '1', it will cause GPIO to produce interrupt twice. One is caused by wake up event, and the other is caused by delayed de-bounce results.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Bit[n] de-bounce function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Bit[n] de-bounce function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DBEN4</name>
              <description>Port [A/B/C/D/E] Input Signal De-bounce Enable\nDBEN[n] is used to enable the de-bounce function for each corresponding bit. If the input signal pulse width can't be sampled by continuous two de-bounce sample cycle The input signal transition is seen as the signal bounce and will not trigger the interrupt. The de-bounce clock  source is controlled by DBNCECON[4], one de-bounce sample cycle is controlled by DBNCECON[3:0]\nThe de-bounce function is valid for edge triggered interrupt. If the interrupt mode is level triggered, the de-bounce enable bit is ignored.\nNote: It is recommended to set this bit to '0' if GPIO is chosen as power-down wakeup source. If setting this bit to '1', it will cause GPIO to produce interrupt twice. One is caused by wake up event, and the other is caused by delayed de-bounce results.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Bit[n] de-bounce function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Bit[n] de-bounce function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DBEN5</name>
              <description>Port [A/B/C/D/E] Input Signal De-bounce Enable\nDBEN[n] is used to enable the de-bounce function for each corresponding bit. If the input signal pulse width can't be sampled by continuous two de-bounce sample cycle The input signal transition is seen as the signal bounce and will not trigger the interrupt. The de-bounce clock  source is controlled by DBNCECON[4], one de-bounce sample cycle is controlled by DBNCECON[3:0]\nThe de-bounce function is valid for edge triggered interrupt. If the interrupt mode is level triggered, the de-bounce enable bit is ignored.\nNote: It is recommended to set this bit to '0' if GPIO is chosen as power-down wakeup source. If setting this bit to '1', it will cause GPIO to produce interrupt twice. One is caused by wake up event, and the other is caused by delayed de-bounce results.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Bit[n] de-bounce function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Bit[n] de-bounce function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DBEN6</name>
              <description>Port [A/B/C/D/E] Input Signal De-bounce Enable\nDBEN[n] is used to enable the de-bounce function for each corresponding bit. If the input signal pulse width can't be sampled by continuous two de-bounce sample cycle The input signal transition is seen as the signal bounce and will not trigger the interrupt. The de-bounce clock  source is controlled by DBNCECON[4], one de-bounce sample cycle is controlled by DBNCECON[3:0]\nThe de-bounce function is valid for edge triggered interrupt. If the interrupt mode is level triggered, the de-bounce enable bit is ignored.\nNote: It is recommended to set this bit to '0' if GPIO is chosen as power-down wakeup source. If setting this bit to '1', it will cause GPIO to produce interrupt twice. One is caused by wake up event, and the other is caused by delayed de-bounce results.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Bit[n] de-bounce function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Bit[n] de-bounce function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DBEN7</name>
              <description>Port [A/B/C/D/E] Input Signal De-bounce Enable\nDBEN[n] is used to enable the de-bounce function for each corresponding bit. If the input signal pulse width can't be sampled by continuous two de-bounce sample cycle The input signal transition is seen as the signal bounce and will not trigger the interrupt. The de-bounce clock  source is controlled by DBNCECON[4], one de-bounce sample cycle is controlled by DBNCECON[3:0]\nThe de-bounce function is valid for edge triggered interrupt. If the interrupt mode is level triggered, the de-bounce enable bit is ignored.\nNote: It is recommended to set this bit to '0' if GPIO is chosen as power-down wakeup source. If setting this bit to '1', it will cause GPIO to produce interrupt twice. One is caused by wake up event, and the other is caused by delayed de-bounce results.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Bit[n] de-bounce function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Bit[n] de-bounce function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DBEN8</name>
              <description>Port [A/B/C/D/E] Input Signal De-bounce Enable\nDBEN[n] is used to enable the de-bounce function for each corresponding bit. If the input signal pulse width can't be sampled by continuous two de-bounce sample cycle The input signal transition is seen as the signal bounce and will not trigger the interrupt. The de-bounce clock  source is controlled by DBNCECON[4], one de-bounce sample cycle is controlled by DBNCECON[3:0]\nThe de-bounce function is valid for edge triggered interrupt. If the interrupt mode is level triggered, the de-bounce enable bit is ignored.\nNote: It is recommended to set this bit to '0' if GPIO is chosen as power-down wakeup source. If setting this bit to '1', it will cause GPIO to produce interrupt twice. One is caused by wake up event, and the other is caused by delayed de-bounce results.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Bit[n] de-bounce function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Bit[n] de-bounce function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DBEN9</name>
              <description>Port [A/B/C/D/E] Input Signal De-bounce Enable\nDBEN[n] is used to enable the de-bounce function for each corresponding bit. If the input signal pulse width can't be sampled by continuous two de-bounce sample cycle The input signal transition is seen as the signal bounce and will not trigger the interrupt. The de-bounce clock  source is controlled by DBNCECON[4], one de-bounce sample cycle is controlled by DBNCECON[3:0]\nThe de-bounce function is valid for edge triggered interrupt. If the interrupt mode is level triggered, the de-bounce enable bit is ignored.\nNote: It is recommended to set this bit to '0' if GPIO is chosen as power-down wakeup source. If setting this bit to '1', it will cause GPIO to produce interrupt twice. One is caused by wake up event, and the other is caused by delayed de-bounce results.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Bit[n] de-bounce function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Bit[n] de-bounce function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DBEN10</name>
              <description>Port [A/B/C/D/E] Input Signal De-bounce Enable\nDBEN[n] is used to enable the de-bounce function for each corresponding bit. If the input signal pulse width can't be sampled by continuous two de-bounce sample cycle The input signal transition is seen as the signal bounce and will not trigger the interrupt. The de-bounce clock  source is controlled by DBNCECON[4], one de-bounce sample cycle is controlled by DBNCECON[3:0]\nThe de-bounce function is valid for edge triggered interrupt. If the interrupt mode is level triggered, the de-bounce enable bit is ignored.\nNote: It is recommended to set this bit to '0' if GPIO is chosen as power-down wakeup source. If setting this bit to '1', it will cause GPIO to produce interrupt twice. One is caused by wake up event, and the other is caused by delayed de-bounce results.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Bit[n] de-bounce function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Bit[n] de-bounce function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DBEN11</name>
              <description>Port [A/B/C/D/E] Input Signal De-bounce Enable\nDBEN[n] is used to enable the de-bounce function for each corresponding bit. If the input signal pulse width can't be sampled by continuous two de-bounce sample cycle The input signal transition is seen as the signal bounce and will not trigger the interrupt. The de-bounce clock  source is controlled by DBNCECON[4], one de-bounce sample cycle is controlled by DBNCECON[3:0]\nThe de-bounce function is valid for edge triggered interrupt. If the interrupt mode is level triggered, the de-bounce enable bit is ignored.\nNote: It is recommended to set this bit to '0' if GPIO is chosen as power-down wakeup source. If setting this bit to '1', it will cause GPIO to produce interrupt twice. One is caused by wake up event, and the other is caused by delayed de-bounce results.</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Bit[n] de-bounce function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Bit[n] de-bounce function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DBEN12</name>
              <description>Port [A/B/C/D/E] Input Signal De-bounce Enable\nDBEN[n] is used to enable the de-bounce function for each corresponding bit. If the input signal pulse width can't be sampled by continuous two de-bounce sample cycle The input signal transition is seen as the signal bounce and will not trigger the interrupt. The de-bounce clock  source is controlled by DBNCECON[4], one de-bounce sample cycle is controlled by DBNCECON[3:0]\nThe de-bounce function is valid for edge triggered interrupt. If the interrupt mode is level triggered, the de-bounce enable bit is ignored.\nNote: It is recommended to set this bit to '0' if GPIO is chosen as power-down wakeup source. If setting this bit to '1', it will cause GPIO to produce interrupt twice. One is caused by wake up event, and the other is caused by delayed de-bounce results.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Bit[n] de-bounce function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Bit[n] de-bounce function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DBEN13</name>
              <description>Port [A/B/C/D/E] Input Signal De-bounce Enable\nDBEN[n] is used to enable the de-bounce function for each corresponding bit. If the input signal pulse width can't be sampled by continuous two de-bounce sample cycle The input signal transition is seen as the signal bounce and will not trigger the interrupt. The de-bounce clock  source is controlled by DBNCECON[4], one de-bounce sample cycle is controlled by DBNCECON[3:0]\nThe de-bounce function is valid for edge triggered interrupt. If the interrupt mode is level triggered, the de-bounce enable bit is ignored.\nNote: It is recommended to set this bit to '0' if GPIO is chosen as power-down wakeup source. If setting this bit to '1', it will cause GPIO to produce interrupt twice. One is caused by wake up event, and the other is caused by delayed de-bounce results.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Bit[n] de-bounce function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Bit[n] de-bounce function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DBEN14</name>
              <description>Port [A/B/C/D/E] Input Signal De-bounce Enable\nDBEN[n] is used to enable the de-bounce function for each corresponding bit. If the input signal pulse width can't be sampled by continuous two de-bounce sample cycle The input signal transition is seen as the signal bounce and will not trigger the interrupt. The de-bounce clock  source is controlled by DBNCECON[4], one de-bounce sample cycle is controlled by DBNCECON[3:0]\nThe de-bounce function is valid for edge triggered interrupt. If the interrupt mode is level triggered, the de-bounce enable bit is ignored.\nNote: It is recommended to set this bit to '0' if GPIO is chosen as power-down wakeup source. If setting this bit to '1', it will cause GPIO to produce interrupt twice. One is caused by wake up event, and the other is caused by delayed de-bounce results.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Bit[n] de-bounce function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Bit[n] de-bounce function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DBEN15</name>
              <description>Port [A/B/C/D/E] Input Signal De-bounce Enable\nDBEN[n] is used to enable the de-bounce function for each corresponding bit. If the input signal pulse width can't be sampled by continuous two de-bounce sample cycle The input signal transition is seen as the signal bounce and will not trigger the interrupt. The de-bounce clock  source is controlled by DBNCECON[4], one de-bounce sample cycle is controlled by DBNCECON[3:0]\nThe de-bounce function is valid for edge triggered interrupt. If the interrupt mode is level triggered, the de-bounce enable bit is ignored.\nNote: It is recommended to set this bit to '0' if GPIO is chosen as power-down wakeup source. If setting this bit to '1', it will cause GPIO to produce interrupt twice. One is caused by wake up event, and the other is caused by delayed de-bounce results.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Bit[n] de-bounce function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Bit[n] de-bounce function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>GPIOA_IMD</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>GPIOA_IMD</displayName>
          <description>GPIO Port A Interrupt Mode Control</description>
          <addressOffset>0x18</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>IMD0</name>
              <description>Port [A/B/C/D/E] Edge or Level Detection Interrupt Control\nIMD[n] is used to control the interrupt is by level trigger or by edge trigger. If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce. If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrupt.\nIf pin is set as the level trigger interrupt, only one level can be set on the registers GPIOx_IEN. If both levels to trigger interrupt are set, the setting is ignored and no interrupt will occur.\nThe de-bounce function is valid for edge triggered interrupt. If the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Edge trigger interrupt</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Level trigger interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IMD1</name>
              <description>Port [A/B/C/D/E] Edge or Level Detection Interrupt Control\nIMD[n] is used to control the interrupt is by level trigger or by edge trigger. If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce. If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrupt.\nIf pin is set as the level trigger interrupt, only one level can be set on the registers GPIOx_IEN. If both levels to trigger interrupt are set, the setting is ignored and no interrupt will occur.\nThe de-bounce function is valid for edge triggered interrupt. If the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Edge trigger interrupt</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Level trigger interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IMD2</name>
              <description>Port [A/B/C/D/E] Edge or Level Detection Interrupt Control\nIMD[n] is used to control the interrupt is by level trigger or by edge trigger. If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce. If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrupt.\nIf pin is set as the level trigger interrupt, only one level can be set on the registers GPIOx_IEN. If both levels to trigger interrupt are set, the setting is ignored and no interrupt will occur.\nThe de-bounce function is valid for edge triggered interrupt. If the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Edge trigger interrupt</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Level trigger interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IMD3</name>
              <description>Port [A/B/C/D/E] Edge or Level Detection Interrupt Control\nIMD[n] is used to control the interrupt is by level trigger or by edge trigger. If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce. If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrupt.\nIf pin is set as the level trigger interrupt, only one level can be set on the registers GPIOx_IEN. If both levels to trigger interrupt are set, the setting is ignored and no interrupt will occur.\nThe de-bounce function is valid for edge triggered interrupt. If the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Edge trigger interrupt</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Level trigger interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IMD4</name>
              <description>Port [A/B/C/D/E] Edge or Level Detection Interrupt Control\nIMD[n] is used to control the interrupt is by level trigger or by edge trigger. If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce. If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrupt.\nIf pin is set as the level trigger interrupt, only one level can be set on the registers GPIOx_IEN. If both levels to trigger interrupt are set, the setting is ignored and no interrupt will occur.\nThe de-bounce function is valid for edge triggered interrupt. If the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Edge trigger interrupt</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Level trigger interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IMD5</name>
              <description>Port [A/B/C/D/E] Edge or Level Detection Interrupt Control\nIMD[n] is used to control the interrupt is by level trigger or by edge trigger. If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce. If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrupt.\nIf pin is set as the level trigger interrupt, only one level can be set on the registers GPIOx_IEN. If both levels to trigger interrupt are set, the setting is ignored and no interrupt will occur.\nThe de-bounce function is valid for edge triggered interrupt. If the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Edge trigger interrupt</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Level trigger interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IMD6</name>
              <description>Port [A/B/C/D/E] Edge or Level Detection Interrupt Control\nIMD[n] is used to control the interrupt is by level trigger or by edge trigger. If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce. If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrupt.\nIf pin is set as the level trigger interrupt, only one level can be set on the registers GPIOx_IEN. If both levels to trigger interrupt are set, the setting is ignored and no interrupt will occur.\nThe de-bounce function is valid for edge triggered interrupt. If the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Edge trigger interrupt</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Level trigger interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IMD7</name>
              <description>Port [A/B/C/D/E] Edge or Level Detection Interrupt Control\nIMD[n] is used to control the interrupt is by level trigger or by edge trigger. If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce. If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrupt.\nIf pin is set as the level trigger interrupt, only one level can be set on the registers GPIOx_IEN. If both levels to trigger interrupt are set, the setting is ignored and no interrupt will occur.\nThe de-bounce function is valid for edge triggered interrupt. If the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Edge trigger interrupt</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Level trigger interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IMD8</name>
              <description>Port [A/B/C/D/E] Edge or Level Detection Interrupt Control\nIMD[n] is used to control the interrupt is by level trigger or by edge trigger. If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce. If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrupt.\nIf pin is set as the level trigger interrupt, only one level can be set on the registers GPIOx_IEN. If both levels to trigger interrupt are set, the setting is ignored and no interrupt will occur.\nThe de-bounce function is valid for edge triggered interrupt. If the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Edge trigger interrupt</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Level trigger interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IMD9</name>
              <description>Port [A/B/C/D/E] Edge or Level Detection Interrupt Control\nIMD[n] is used to control the interrupt is by level trigger or by edge trigger. If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce. If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrupt.\nIf pin is set as the level trigger interrupt, only one level can be set on the registers GPIOx_IEN. If both levels to trigger interrupt are set, the setting is ignored and no interrupt will occur.\nThe de-bounce function is valid for edge triggered interrupt. If the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Edge trigger interrupt</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Level trigger interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IMD10</name>
              <description>Port [A/B/C/D/E] Edge or Level Detection Interrupt Control\nIMD[n] is used to control the interrupt is by level trigger or by edge trigger. If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce. If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrupt.\nIf pin is set as the level trigger interrupt, only one level can be set on the registers GPIOx_IEN. If both levels to trigger interrupt are set, the setting is ignored and no interrupt will occur.\nThe de-bounce function is valid for edge triggered interrupt. If the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Edge trigger interrupt</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Level trigger interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IMD11</name>
              <description>Port [A/B/C/D/E] Edge or Level Detection Interrupt Control\nIMD[n] is used to control the interrupt is by level trigger or by edge trigger. If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce. If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrupt.\nIf pin is set as the level trigger interrupt, only one level can be set on the registers GPIOx_IEN. If both levels to trigger interrupt are set, the setting is ignored and no interrupt will occur.\nThe de-bounce function is valid for edge triggered interrupt. If the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Edge trigger interrupt</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Level trigger interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IMD12</name>
              <description>Port [A/B/C/D/E] Edge or Level Detection Interrupt Control\nIMD[n] is used to control the interrupt is by level trigger or by edge trigger. If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce. If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrupt.\nIf pin is set as the level trigger interrupt, only one level can be set on the registers GPIOx_IEN. If both levels to trigger interrupt are set, the setting is ignored and no interrupt will occur.\nThe de-bounce function is valid for edge triggered interrupt. If the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Edge trigger interrupt</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Level trigger interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IMD13</name>
              <description>Port [A/B/C/D/E] Edge or Level Detection Interrupt Control\nIMD[n] is used to control the interrupt is by level trigger or by edge trigger. If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce. If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrupt.\nIf pin is set as the level trigger interrupt, only one level can be set on the registers GPIOx_IEN. If both levels to trigger interrupt are set, the setting is ignored and no interrupt will occur.\nThe de-bounce function is valid for edge triggered interrupt. If the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Edge trigger interrupt</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Level trigger interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IMD14</name>
              <description>Port [A/B/C/D/E] Edge or Level Detection Interrupt Control\nIMD[n] is used to control the interrupt is by level trigger or by edge trigger. If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce. If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrupt.\nIf pin is set as the level trigger interrupt, only one level can be set on the registers GPIOx_IEN. If both levels to trigger interrupt are set, the setting is ignored and no interrupt will occur.\nThe de-bounce function is valid for edge triggered interrupt. If the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Edge trigger interrupt</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Level trigger interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IMD15</name>
              <description>Port [A/B/C/D/E] Edge or Level Detection Interrupt Control\nIMD[n] is used to control the interrupt is by level trigger or by edge trigger. If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce. If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrupt.\nIf pin is set as the level trigger interrupt, only one level can be set on the registers GPIOx_IEN. If both levels to trigger interrupt are set, the setting is ignored and no interrupt will occur.\nThe de-bounce function is valid for edge triggered interrupt. If the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Edge trigger interrupt</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Level trigger interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>GPIOA_IEN</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>GPIOA_IEN</displayName>
          <description>GPIO Port A Interrupt Enable</description>
          <addressOffset>0x1C</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>IF_EN0</name>
              <description>Port [A/B/C/D/E] Interrupt Enable by Input Falling Edge or Input Level Low\nIF_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wake-up function\nWhen setting the IF_EN[n] bit to 1:\nIf the interrupt is level trigger, the input PIN[n] state at level "low" will generate the interrupt.\nIf the interrupt is edge trigger, the input PIN[n] state change from "high-to-low" will generate the interrupt.\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PIN[n] state low-level or high-to-low change interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PIN[n] state low-level or high-to-low change interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IF_EN1</name>
              <description>Port [A/B/C/D/E] Interrupt Enable by Input Falling Edge or Input Level Low\nIF_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wake-up function\nWhen setting the IF_EN[n] bit to 1:\nIf the interrupt is level trigger, the input PIN[n] state at level "low" will generate the interrupt.\nIf the interrupt is edge trigger, the input PIN[n] state change from "high-to-low" will generate the interrupt.\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PIN[n] state low-level or high-to-low change interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PIN[n] state low-level or high-to-low change interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IF_EN2</name>
              <description>Port [A/B/C/D/E] Interrupt Enable by Input Falling Edge or Input Level Low\nIF_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wake-up function\nWhen setting the IF_EN[n] bit to 1:\nIf the interrupt is level trigger, the input PIN[n] state at level "low" will generate the interrupt.\nIf the interrupt is edge trigger, the input PIN[n] state change from "high-to-low" will generate the interrupt.\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PIN[n] state low-level or high-to-low change interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PIN[n] state low-level or high-to-low change interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IF_EN3</name>
              <description>Port [A/B/C/D/E] Interrupt Enable by Input Falling Edge or Input Level Low\nIF_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wake-up function\nWhen setting the IF_EN[n] bit to 1:\nIf the interrupt is level trigger, the input PIN[n] state at level "low" will generate the interrupt.\nIf the interrupt is edge trigger, the input PIN[n] state change from "high-to-low" will generate the interrupt.\n</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PIN[n] state low-level or high-to-low change interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PIN[n] state low-level or high-to-low change interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IF_EN4</name>
              <description>Port [A/B/C/D/E] Interrupt Enable by Input Falling Edge or Input Level Low\nIF_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wake-up function\nWhen setting the IF_EN[n] bit to 1:\nIf the interrupt is level trigger, the input PIN[n] state at level "low" will generate the interrupt.\nIf the interrupt is edge trigger, the input PIN[n] state change from "high-to-low" will generate the interrupt.\n</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PIN[n] state low-level or high-to-low change interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PIN[n] state low-level or high-to-low change interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IF_EN5</name>
              <description>Port [A/B/C/D/E] Interrupt Enable by Input Falling Edge or Input Level Low\nIF_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wake-up function\nWhen setting the IF_EN[n] bit to 1:\nIf the interrupt is level trigger, the input PIN[n] state at level "low" will generate the interrupt.\nIf the interrupt is edge trigger, the input PIN[n] state change from "high-to-low" will generate the interrupt.\n</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PIN[n] state low-level or high-to-low change interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PIN[n] state low-level or high-to-low change interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IF_EN6</name>
              <description>Port [A/B/C/D/E] Interrupt Enable by Input Falling Edge or Input Level Low\nIF_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wake-up function\nWhen setting the IF_EN[n] bit to 1:\nIf the interrupt is level trigger, the input PIN[n] state at level "low" will generate the interrupt.\nIf the interrupt is edge trigger, the input PIN[n] state change from "high-to-low" will generate the interrupt.\n</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PIN[n] state low-level or high-to-low change interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PIN[n] state low-level or high-to-low change interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IF_EN7</name>
              <description>Port [A/B/C/D/E] Interrupt Enable by Input Falling Edge or Input Level Low\nIF_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wake-up function\nWhen setting the IF_EN[n] bit to 1:\nIf the interrupt is level trigger, the input PIN[n] state at level "low" will generate the interrupt.\nIf the interrupt is edge trigger, the input PIN[n] state change from "high-to-low" will generate the interrupt.\n</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PIN[n] state low-level or high-to-low change interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PIN[n] state low-level or high-to-low change interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IF_EN8</name>
              <description>Port [A/B/C/D/E] Interrupt Enable by Input Falling Edge or Input Level Low\nIF_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wake-up function\nWhen setting the IF_EN[n] bit to 1:\nIf the interrupt is level trigger, the input PIN[n] state at level "low" will generate the interrupt.\nIf the interrupt is edge trigger, the input PIN[n] state change from "high-to-low" will generate the interrupt.\n</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PIN[n] state low-level or high-to-low change interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PIN[n] state low-level or high-to-low change interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IF_EN9</name>
              <description>Port [A/B/C/D/E] Interrupt Enable by Input Falling Edge or Input Level Low\nIF_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wake-up function\nWhen setting the IF_EN[n] bit to 1:\nIf the interrupt is level trigger, the input PIN[n] state at level "low" will generate the interrupt.\nIf the interrupt is edge trigger, the input PIN[n] state change from "high-to-low" will generate the interrupt.\n</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PIN[n] state low-level or high-to-low change interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PIN[n] state low-level or high-to-low change interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IF_EN10</name>
              <description>Port [A/B/C/D/E] Interrupt Enable by Input Falling Edge or Input Level Low\nIF_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wake-up function\nWhen setting the IF_EN[n] bit to 1:\nIf the interrupt is level trigger, the input PIN[n] state at level "low" will generate the interrupt.\nIf the interrupt is edge trigger, the input PIN[n] state change from "high-to-low" will generate the interrupt.\n</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PIN[n] state low-level or high-to-low change interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PIN[n] state low-level or high-to-low change interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IF_EN11</name>
              <description>Port [A/B/C/D/E] Interrupt Enable by Input Falling Edge or Input Level Low\nIF_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wake-up function\nWhen setting the IF_EN[n] bit to 1:\nIf the interrupt is level trigger, the input PIN[n] state at level "low" will generate the interrupt.\nIf the interrupt is edge trigger, the input PIN[n] state change from "high-to-low" will generate the interrupt.\n</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PIN[n] state low-level or high-to-low change interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PIN[n] state low-level or high-to-low change interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IF_EN12</name>
              <description>Port [A/B/C/D/E] Interrupt Enable by Input Falling Edge or Input Level Low\nIF_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wake-up function\nWhen setting the IF_EN[n] bit to 1:\nIf the interrupt is level trigger, the input PIN[n] state at level "low" will generate the interrupt.\nIf the interrupt is edge trigger, the input PIN[n] state change from "high-to-low" will generate the interrupt.\n</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PIN[n] state low-level or high-to-low change interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PIN[n] state low-level or high-to-low change interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IF_EN13</name>
              <description>Port [A/B/C/D/E] Interrupt Enable by Input Falling Edge or Input Level Low\nIF_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wake-up function\nWhen setting the IF_EN[n] bit to 1:\nIf the interrupt is level trigger, the input PIN[n] state at level "low" will generate the interrupt.\nIf the interrupt is edge trigger, the input PIN[n] state change from "high-to-low" will generate the interrupt.\n</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PIN[n] state low-level or high-to-low change interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PIN[n] state low-level or high-to-low change interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IF_EN14</name>
              <description>Port [A/B/C/D/E] Interrupt Enable by Input Falling Edge or Input Level Low\nIF_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wake-up function\nWhen setting the IF_EN[n] bit to 1:\nIf the interrupt is level trigger, the input PIN[n] state at level "low" will generate the interrupt.\nIf the interrupt is edge trigger, the input PIN[n] state change from "high-to-low" will generate the interrupt.\n</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PIN[n] state low-level or high-to-low change interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PIN[n] state low-level or high-to-low change interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IF_EN15</name>
              <description>Port [A/B/C/D/E] Interrupt Enable by Input Falling Edge or Input Level Low\nIF_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wake-up function\nWhen setting the IF_EN[n] bit to 1:\nIf the interrupt is level trigger, the input PIN[n] state at level "low" will generate the interrupt.\nIf the interrupt is edge trigger, the input PIN[n] state change from "high-to-low" will generate the interrupt.\n</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PIN[n] state low-level or high-to-low change interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PIN[n] state low-level or high-to-low change interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IR_EN0</name>
              <description>Port [A/B/C/D/E] Interrupt Enable by Input Rising Edge or Input Level High\nIR_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wake-up function \nWhen setting the IR_EN[n] bit to 1:\nIf the interrupt is level trigger, the input PIN[n] state at level "high" will generate the interrupt.\nIf the interrupt is edge trigger, the input PIN[n] state change from "low-to-high" will generate the interrupt.\n</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PIN[n] level-high or low-to-high interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PIN[n] level-high or low-to-high interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IR_EN1</name>
              <description>Port [A/B/C/D/E] Interrupt Enable by Input Rising Edge or Input Level High\nIR_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wake-up function \nWhen setting the IR_EN[n] bit to 1:\nIf the interrupt is level trigger, the input PIN[n] state at level "high" will generate the interrupt.\nIf the interrupt is edge trigger, the input PIN[n] state change from "low-to-high" will generate the interrupt.\n</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PIN[n] level-high or low-to-high interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PIN[n] level-high or low-to-high interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IR_EN2</name>
              <description>Port [A/B/C/D/E] Interrupt Enable by Input Rising Edge or Input Level High\nIR_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wake-up function \nWhen setting the IR_EN[n] bit to 1:\nIf the interrupt is level trigger, the input PIN[n] state at level "high" will generate the interrupt.\nIf the interrupt is edge trigger, the input PIN[n] state change from "low-to-high" will generate the interrupt.\n</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PIN[n] level-high or low-to-high interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PIN[n] level-high or low-to-high interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IR_EN3</name>
              <description>Port [A/B/C/D/E] Interrupt Enable by Input Rising Edge or Input Level High\nIR_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wake-up function \nWhen setting the IR_EN[n] bit to 1:\nIf the interrupt is level trigger, the input PIN[n] state at level "high" will generate the interrupt.\nIf the interrupt is edge trigger, the input PIN[n] state change from "low-to-high" will generate the interrupt.\n</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PIN[n] level-high or low-to-high interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PIN[n] level-high or low-to-high interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IR_EN4</name>
              <description>Port [A/B/C/D/E] Interrupt Enable by Input Rising Edge or Input Level High\nIR_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wake-up function \nWhen setting the IR_EN[n] bit to 1:\nIf the interrupt is level trigger, the input PIN[n] state at level "high" will generate the interrupt.\nIf the interrupt is edge trigger, the input PIN[n] state change from "low-to-high" will generate the interrupt.\n</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PIN[n] level-high or low-to-high interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PIN[n] level-high or low-to-high interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IR_EN5</name>
              <description>Port [A/B/C/D/E] Interrupt Enable by Input Rising Edge or Input Level High\nIR_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wake-up function \nWhen setting the IR_EN[n] bit to 1:\nIf the interrupt is level trigger, the input PIN[n] state at level "high" will generate the interrupt.\nIf the interrupt is edge trigger, the input PIN[n] state change from "low-to-high" will generate the interrupt.\n</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PIN[n] level-high or low-to-high interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PIN[n] level-high or low-to-high interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IR_EN6</name>
              <description>Port [A/B/C/D/E] Interrupt Enable by Input Rising Edge or Input Level High\nIR_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wake-up function \nWhen setting the IR_EN[n] bit to 1:\nIf the interrupt is level trigger, the input PIN[n] state at level "high" will generate the interrupt.\nIf the interrupt is edge trigger, the input PIN[n] state change from "low-to-high" will generate the interrupt.\n</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PIN[n] level-high or low-to-high interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PIN[n] level-high or low-to-high interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IR_EN7</name>
              <description>Port [A/B/C/D/E] Interrupt Enable by Input Rising Edge or Input Level High\nIR_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wake-up function \nWhen setting the IR_EN[n] bit to 1:\nIf the interrupt is level trigger, the input PIN[n] state at level "high" will generate the interrupt.\nIf the interrupt is edge trigger, the input PIN[n] state change from "low-to-high" will generate the interrupt.\n</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PIN[n] level-high or low-to-high interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PIN[n] level-high or low-to-high interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IR_EN8</name>
              <description>Port [A/B/C/D/E] Interrupt Enable by Input Rising Edge or Input Level High\nIR_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wake-up function \nWhen setting the IR_EN[n] bit to 1:\nIf the interrupt is level trigger, the input PIN[n] state at level "high" will generate the interrupt.\nIf the interrupt is edge trigger, the input PIN[n] state change from "low-to-high" will generate the interrupt.\n</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PIN[n] level-high or low-to-high interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PIN[n] level-high or low-to-high interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IR_EN9</name>
              <description>Port [A/B/C/D/E] Interrupt Enable by Input Rising Edge or Input Level High\nIR_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wake-up function \nWhen setting the IR_EN[n] bit to 1:\nIf the interrupt is level trigger, the input PIN[n] state at level "high" will generate the interrupt.\nIf the interrupt is edge trigger, the input PIN[n] state change from "low-to-high" will generate the interrupt.\n</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PIN[n] level-high or low-to-high interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PIN[n] level-high or low-to-high interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IR_EN10</name>
              <description>Port [A/B/C/D/E] Interrupt Enable by Input Rising Edge or Input Level High\nIR_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wake-up function \nWhen setting the IR_EN[n] bit to 1:\nIf the interrupt is level trigger, the input PIN[n] state at level "high" will generate the interrupt.\nIf the interrupt is edge trigger, the input PIN[n] state change from "low-to-high" will generate the interrupt.\n</description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PIN[n] level-high or low-to-high interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PIN[n] level-high or low-to-high interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IR_EN11</name>
              <description>Port [A/B/C/D/E] Interrupt Enable by Input Rising Edge or Input Level High\nIR_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wake-up function \nWhen setting the IR_EN[n] bit to 1:\nIf the interrupt is level trigger, the input PIN[n] state at level "high" will generate the interrupt.\nIf the interrupt is edge trigger, the input PIN[n] state change from "low-to-high" will generate the interrupt.\n</description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PIN[n] level-high or low-to-high interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PIN[n] level-high or low-to-high interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IR_EN12</name>
              <description>Port [A/B/C/D/E] Interrupt Enable by Input Rising Edge or Input Level High\nIR_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wake-up function \nWhen setting the IR_EN[n] bit to 1:\nIf the interrupt is level trigger, the input PIN[n] state at level "high" will generate the interrupt.\nIf the interrupt is edge trigger, the input PIN[n] state change from "low-to-high" will generate the interrupt.\n</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PIN[n] level-high or low-to-high interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PIN[n] level-high or low-to-high interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IR_EN13</name>
              <description>Port [A/B/C/D/E] Interrupt Enable by Input Rising Edge or Input Level High\nIR_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wake-up function \nWhen setting the IR_EN[n] bit to 1:\nIf the interrupt is level trigger, the input PIN[n] state at level "high" will generate the interrupt.\nIf the interrupt is edge trigger, the input PIN[n] state change from "low-to-high" will generate the interrupt.\n</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PIN[n] level-high or low-to-high interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PIN[n] level-high or low-to-high interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IR_EN14</name>
              <description>Port [A/B/C/D/E] Interrupt Enable by Input Rising Edge or Input Level High\nIR_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wake-up function \nWhen setting the IR_EN[n] bit to 1:\nIf the interrupt is level trigger, the input PIN[n] state at level "high" will generate the interrupt.\nIf the interrupt is edge trigger, the input PIN[n] state change from "low-to-high" will generate the interrupt.\n</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PIN[n] level-high or low-to-high interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PIN[n] level-high or low-to-high interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IR_EN15</name>
              <description>Port [A/B/C/D/E] Interrupt Enable by Input Rising Edge or Input Level High\nIR_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wake-up function \nWhen setting the IR_EN[n] bit to 1:\nIf the interrupt is level trigger, the input PIN[n] state at level "high" will generate the interrupt.\nIf the interrupt is edge trigger, the input PIN[n] state change from "low-to-high" will generate the interrupt.\n</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PIN[n] level-high or low-to-high interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PIN[n] level-high or low-to-high interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>GPIOA_ISRC</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>GPIOA_ISRC</displayName>
          <description>GPIO Port A Interrupt Source Flag</description>
          <addressOffset>0x20</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>ISRC0</name>
              <description>Port [A/B/C/D/E] Interrupt Source Flag\nRead :\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No interrupt at GPIOx[n].\nNo action</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIOx[n] generates an interrupt.\nClear the corresponding pending interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ISRC1</name>
              <description>Port [A/B/C/D/E] Interrupt Source Flag\nRead :\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No interrupt at GPIOx[n].\nNo action</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIOx[n] generates an interrupt.\nClear the corresponding pending interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ISRC2</name>
              <description>Port [A/B/C/D/E] Interrupt Source Flag\nRead :\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No interrupt at GPIOx[n].\nNo action</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIOx[n] generates an interrupt.\nClear the corresponding pending interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ISRC3</name>
              <description>Port [A/B/C/D/E] Interrupt Source Flag\nRead :\n</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No interrupt at GPIOx[n].\nNo action</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIOx[n] generates an interrupt.\nClear the corresponding pending interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ISRC4</name>
              <description>Port [A/B/C/D/E] Interrupt Source Flag\nRead :\n</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No interrupt at GPIOx[n].\nNo action</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIOx[n] generates an interrupt.\nClear the corresponding pending interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ISRC5</name>
              <description>Port [A/B/C/D/E] Interrupt Source Flag\nRead :\n</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No interrupt at GPIOx[n].\nNo action</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIOx[n] generates an interrupt.\nClear the corresponding pending interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ISRC6</name>
              <description>Port [A/B/C/D/E] Interrupt Source Flag\nRead :\n</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No interrupt at GPIOx[n].\nNo action</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIOx[n] generates an interrupt.\nClear the corresponding pending interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ISRC7</name>
              <description>Port [A/B/C/D/E] Interrupt Source Flag\nRead :\n</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No interrupt at GPIOx[n].\nNo action</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIOx[n] generates an interrupt.\nClear the corresponding pending interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ISRC8</name>
              <description>Port [A/B/C/D/E] Interrupt Source Flag\nRead :\n</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No interrupt at GPIOx[n].\nNo action</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIOx[n] generates an interrupt.\nClear the corresponding pending interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ISRC9</name>
              <description>Port [A/B/C/D/E] Interrupt Source Flag\nRead :\n</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No interrupt at GPIOx[n].\nNo action</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIOx[n] generates an interrupt.\nClear the corresponding pending interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ISRC10</name>
              <description>Port [A/B/C/D/E] Interrupt Source Flag\nRead :\n</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No interrupt at GPIOx[n].\nNo action</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIOx[n] generates an interrupt.\nClear the corresponding pending interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ISRC11</name>
              <description>Port [A/B/C/D/E] Interrupt Source Flag\nRead :\n</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No interrupt at GPIOx[n].\nNo action</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIOx[n] generates an interrupt.\nClear the corresponding pending interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ISRC12</name>
              <description>Port [A/B/C/D/E] Interrupt Source Flag\nRead :\n</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No interrupt at GPIOx[n].\nNo action</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIOx[n] generates an interrupt.\nClear the corresponding pending interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ISRC13</name>
              <description>Port [A/B/C/D/E] Interrupt Source Flag\nRead :\n</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No interrupt at GPIOx[n].\nNo action</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIOx[n] generates an interrupt.\nClear the corresponding pending interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ISRC14</name>
              <description>Port [A/B/C/D/E] Interrupt Source Flag\nRead :\n</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No interrupt at GPIOx[n].\nNo action</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIOx[n] generates an interrupt.\nClear the corresponding pending interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ISRC15</name>
              <description>Port [A/B/C/D/E] Interrupt Source Flag\nRead :\n</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No interrupt at GPIOx[n].\nNo action</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIOx[n] generates an interrupt.\nClear the corresponding pending interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="GPIOA_PMD">
          <name>GPIOB_PMD</name>
          <displayName>GPIOB_PMD</displayName>
          <description>GPIO Port B Pin I/O Mode Control</description>
          <addressOffset>0x40</addressOffset>
       </register>
       <register derivedFrom="GPIOA_OFFD">
          <name>GPIOB_OFFD</name>
          <displayName>GPIOB_OFFD</displayName>
          <description>GPIO Port B Pin Digital Input Path Disable Control</description>
          <addressOffset>0x44</addressOffset>
       </register>
       <register derivedFrom="GPIOA_DOUT">
          <name>GPIOB_DOUT</name>
          <displayName>GPIOB_DOUT</displayName>
          <description>GPIO Port B Data Output Value</description>
          <addressOffset>0x48</addressOffset>
       </register>
       <register derivedFrom="GPIOA_DMASK">
          <name>GPIOB_DMASK</name>
          <displayName>GPIOB_DMASK</displayName>
          <description>GPIO Port B Data Output Write Mask</description>
          <addressOffset>0x4C</addressOffset>
       </register>
       <register derivedFrom="GPIOA_PIN">
          <name>GPIOB_PIN</name>
          <displayName>GPIOB_PIN</displayName>
          <description>GPIO Port B Pin Value</description>
          <addressOffset>0x50</addressOffset>
       </register>
       <register derivedFrom="GPIOA_DBEN">
          <name>GPIOB_DBEN</name>
          <displayName>GPIOB_DBEN</displayName>
          <description>GPIO Port B De-bounce Enable</description>
          <addressOffset>0x54</addressOffset>
       </register>
       <register derivedFrom="GPIOA_IMD">
          <name>GPIOB_IMD</name>
          <displayName>GPIOB_IMD</displayName>
          <description>GPIO Port B Interrupt Mode Control</description>
          <addressOffset>0x58</addressOffset>
       </register>
       <register derivedFrom="GPIOA_IEN">
          <name>GPIOB_IEN</name>
          <displayName>GPIOB_IEN</displayName>
          <description>GPIO Port B Interrupt Enable</description>
          <addressOffset>0x5C</addressOffset>
       </register>
       <register derivedFrom="GPIOA_ISRC">
          <name>GPIOB_ISRC</name>
          <displayName>GPIOB_ISRC</displayName>
          <description>GPIO Port B Interrupt Source Flag</description>
          <addressOffset>0x60</addressOffset>
       </register>
       <register derivedFrom="GPIOA_PMD">
          <name>GPIOC_PMD</name>
          <displayName>GPIOC_PMD</displayName>
          <description>GPIO Port C Pin I/O Mode Control</description>
          <addressOffset>0x80</addressOffset>
       </register>
       <register derivedFrom="GPIOA_OFFD">
          <name>GPIOC_OFFD</name>
          <displayName>GPIOC_OFFD</displayName>
          <description>GPIO Port C Pin Digital Input Path Disable Control</description>
          <addressOffset>0x84</addressOffset>
       </register>
       <register derivedFrom="GPIOA_DOUT">
          <name>GPIOC_DOUT</name>
          <displayName>GPIOC_DOUT</displayName>
          <description>GPIO Port C Data Output Value</description>
          <addressOffset>0x88</addressOffset>
       </register>
       <register derivedFrom="GPIOA_DMASK">
          <name>GPIOC_DMASK</name>
          <displayName>GPIOC_DMASK</displayName>
          <description>GPIO Port C Data Output Write Mask</description>
          <addressOffset>0x8C</addressOffset>
       </register>
       <register derivedFrom="GPIOA_PIN">
          <name>GPIOC_PIN</name>
          <displayName>GPIOC_PIN</displayName>
          <description>GPIO Port C Pin Value</description>
          <addressOffset>0x90</addressOffset>
       </register>
       <register derivedFrom="GPIOA_DBEN">
          <name>GPIOC_DBEN</name>
          <displayName>GPIOC_DBEN</displayName>
          <description>GPIO Port C De-bounce Enable</description>
          <addressOffset>0x94</addressOffset>
       </register>
       <register derivedFrom="GPIOA_IMD">
          <name>GPIOC_IMD</name>
          <displayName>GPIOC_IMD</displayName>
          <description>GPIO Port C Interrupt Mode Control</description>
          <addressOffset>0x98</addressOffset>
       </register>
       <register derivedFrom="GPIOA_IEN">
          <name>GPIOC_IEN</name>
          <displayName>GPIOC_IEN</displayName>
          <description>GPIO Port C Interrupt Enable</description>
          <addressOffset>0x9C</addressOffset>
       </register>
       <register derivedFrom="GPIOA_ISRC">
          <name>GPIOC_ISRC</name>
          <displayName>GPIOC_ISRC</displayName>
          <description>GPIO Port C Interrupt Source Flag</description>
          <addressOffset>0xA0</addressOffset>
       </register>
       <register derivedFrom="GPIOA_PMD">
          <name>GPIOD_PMD</name>
          <displayName>GPIOD_PMD</displayName>
          <description>GPIO Port D Pin I/O Mode Control</description>
          <addressOffset>0xC0</addressOffset>
       </register>
       <register derivedFrom="GPIOA_OFFD">
          <name>GPIOD_OFFD</name>
          <displayName>GPIOD_OFFD</displayName>
          <description>GPIO Port D Pin Digital Input Path Disable Control</description>
          <addressOffset>0xC4</addressOffset>
       </register>
       <register derivedFrom="GPIOA_DOUT">
          <name>GPIOD_DOUT</name>
          <displayName>GPIOD_DOUT</displayName>
          <description>GPIO Port D Data Output Value</description>
          <addressOffset>0xC8</addressOffset>
       </register>
       <register derivedFrom="GPIOA_DMASK">
          <name>GPIOD_DMASK</name>
          <displayName>GPIOD_DMASK</displayName>
          <description>GPIO Port D Data Output Write Mask</description>
          <addressOffset>0xCC</addressOffset>
       </register>
       <register derivedFrom="GPIOA_PIN">
          <name>GPIOD_PIN</name>
          <displayName>GPIOD_PIN</displayName>
          <description>GPIO Port D Pin Value</description>
          <addressOffset>0xD0</addressOffset>
       </register>
       <register derivedFrom="GPIOA_DBEN">
          <name>GPIOD_DBEN</name>
          <displayName>GPIOD_DBEN</displayName>
          <description>GPIO Port D De-bounce Enable</description>
          <addressOffset>0xD4</addressOffset>
       </register>
       <register derivedFrom="GPIOA_IMD">
          <name>GPIOD_IMD</name>
          <displayName>GPIOD_IMD</displayName>
          <description>GPIO Port D Interrupt Mode Control</description>
          <addressOffset>0xD8</addressOffset>
       </register>
       <register derivedFrom="GPIOA_IEN">
          <name>GPIOD_IEN</name>
          <displayName>GPIOD_IEN</displayName>
          <description>GPIO Port D Interrupt Enable</description>
          <addressOffset>0xDC</addressOffset>
       </register>
       <register derivedFrom="GPIOA_ISRC">
          <name>GPIOD_ISRC</name>
          <displayName>GPIOD_ISRC</displayName>
          <description>GPIO Port D Interrupt Source Flag</description>
          <addressOffset>0xE0</addressOffset>
       </register>
       <register derivedFrom="GPIOA_PMD">
          <name>GPIOE_PMD</name>
          <displayName>GPIOE_PMD</displayName>
          <description>GPIO Port E Pin I/O Mode Control</description>
          <addressOffset>0x100</addressOffset>
       </register>
       <register derivedFrom="GPIOA_OFFD">
          <name>GPIOE_OFFD</name>
          <displayName>GPIOE_OFFD</displayName>
          <description>GPIO Port E Pin Digital Input Path Disable Control</description>
          <addressOffset>0x104</addressOffset>
       </register>
       <register derivedFrom="GPIOA_DOUT">
          <name>GPIOE_DOUT</name>
          <displayName>GPIOE_DOUT</displayName>
          <description>GPIO Port E Data Output Value</description>
          <addressOffset>0x108</addressOffset>
       </register>
       <register derivedFrom="GPIOA_DMASK">
          <name>GPIOE_DMASK</name>
          <displayName>GPIOE_DMASK</displayName>
          <description>GPIO Port E Data Output Write Mask</description>
          <addressOffset>0x10C</addressOffset>
       </register>
       <register derivedFrom="GPIOA_PIN">
          <name>GPIOE_PIN</name>
          <displayName>GPIOE_PIN</displayName>
          <description>GPIO Port E Pin Value</description>
          <addressOffset>0x110</addressOffset>
       </register>
       <register derivedFrom="GPIOA_DBEN">
          <name>GPIOE_DBEN</name>
          <displayName>GPIOE_DBEN</displayName>
          <description>GPIO Port E De-bounce Enable</description>
          <addressOffset>0x114</addressOffset>
       </register>
       <register derivedFrom="GPIOA_IMD">
          <name>GPIOE_IMD</name>
          <displayName>GPIOE_IMD</displayName>
          <description>GPIO Port E Interrupt Mode Control</description>
          <addressOffset>0x118</addressOffset>
       </register>
       <register derivedFrom="GPIOA_IEN">
          <name>GPIOE_IEN</name>
          <displayName>GPIOE_IEN</displayName>
          <description>GPIO Port E Interrupt Enable</description>
          <addressOffset>0x11C</addressOffset>
       </register>
       <register derivedFrom="GPIOA_ISRC">
          <name>GPIOE_ISRC</name>
          <displayName>GPIOE_ISRC</displayName>
          <description>GPIO Port E Interrupt Source Flag</description>
          <addressOffset>0x120</addressOffset>
       </register>
       <register>
          <name>DBNCECON</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>DBNCECON</displayName>
          <description>De-bounce Cycle Control</description>
          <addressOffset>0x180</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000020</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DBCLKSEL</name>
              <description>De-bounce Sampling Cycle Selection\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DBCLKSRC</name>
              <description>De-bounce counter clock source select\n</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>De-bounce counter clock source is the HCLK</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>De-bounce counter clock source is the internal 10 kHz low speed oscillator</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ICLK_ON</name>
              <description>Interrupt clock On mode\nIt is recommended to turn off this bit to save system power, if on special application concern.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Edge detection circuit is active only if I/O pin corresponding GPIOx_IEN bit is set to 1</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>All I/O pins edge detection circuit is always active after reset</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PA0_PDIO</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PA0_PDIO</displayName>
          <description>GPIO PA.n Pin Data Input/Output\n(NuMicro( NUC100/NUC120 Low Density Only)</description>
          <addressOffset>0x200</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000001</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>Pxn_PDIO</name>
              <description>GPIO Px.n Pin Data I/O\nWrite this bit can control one GPIO pin output value\nRead this register to get GPIO pin status.\nFor example, writing PA0_PDIO will reflect the written value to bit GPIOA_DOUT[0], read PA0_PDIO will return the value of GPIOA_PIN[0]\nNote: The write operation will not be affected by register GPIOx_DMASK.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Corresponding GPIO pin set to low</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Corresponding GPIO pin set to high</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PA0_PDIO">
          <name>PA1_PDIO</name>
          <displayName>PA1_PDIO</displayName>
          <description>GPIO PA.n Pin Data Input/Output\n(NuMicro( NUC100/NUC120 Low Density Only)</description>
          <addressOffset>0x204</addressOffset>
       </register>
       <register derivedFrom="PA0_PDIO">
          <name>PA2_PDIO</name>
          <displayName>PA2_PDIO</displayName>
          <description>GPIO PA.n Pin Data Input/Output\n(NuMicro( NUC100/NUC120 Low Density Only)</description>
          <addressOffset>0x208</addressOffset>
       </register>
       <register derivedFrom="PA0_PDIO">
          <name>PA3_PDIO</name>
          <displayName>PA3_PDIO</displayName>
          <description>GPIO PA.n Pin Data Input/Output\n(NuMicro( NUC100/NUC120 Low Density Only)</description>
          <addressOffset>0x20C</addressOffset>
       </register>
       <register derivedFrom="PA0_PDIO">
          <name>PA4_PDIO</name>
          <displayName>PA4_PDIO</displayName>
          <description>GPIO PA.n Pin Data Input/Output\n(NuMicro( NUC100/NUC120 Low Density Only)</description>
          <addressOffset>0x210</addressOffset>
       </register>
       <register derivedFrom="PA0_PDIO">
          <name>PA5_PDIO</name>
          <displayName>PA5_PDIO</displayName>
          <description>GPIO PA.n Pin Data Input/Output\n(NuMicro( NUC100/NUC120 Low Density Only)</description>
          <addressOffset>0x214</addressOffset>
       </register>
       <register derivedFrom="PA0_PDIO">
          <name>PA6_PDIO</name>
          <displayName>PA6_PDIO</displayName>
          <description>GPIO PA.n Pin Data Input/Output\n(NuMicro( NUC100/NUC120 Low Density Only)</description>
          <addressOffset>0x218</addressOffset>
       </register>
       <register derivedFrom="PA0_PDIO">
          <name>PA7_PDIO</name>
          <displayName>PA7_PDIO</displayName>
          <description>GPIO PA.n Pin Data Input/Output\n(NuMicro( NUC100/NUC120 Low Density Only)</description>
          <addressOffset>0x21C</addressOffset>
       </register>
       <register derivedFrom="PA0_PDIO">
          <name>PA8_PDIO</name>
          <displayName>PA8_PDIO</displayName>
          <description>GPIO PA.n Pin Data Input/Output\n(NuMicro( NUC100/NUC120 Low Density Only)</description>
          <addressOffset>0x220</addressOffset>
       </register>
       <register derivedFrom="PA0_PDIO">
          <name>PA9_PDIO</name>
          <displayName>PA9_PDIO</displayName>
          <description>GPIO PA.n Pin Data Input/Output\n(NuMicro( NUC100/NUC120 Low Density Only)</description>
          <addressOffset>0x224</addressOffset>
       </register>
       <register derivedFrom="PA0_PDIO">
          <name>PA10_PDIO</name>
          <displayName>PA10_PDIO</displayName>
          <description>GPIO PA.n Pin Data Input/Output\n(NuMicro( NUC100/NUC120 Low Density Only)</description>
          <addressOffset>0x228</addressOffset>
       </register>
       <register derivedFrom="PA0_PDIO">
          <name>PA11_PDIO</name>
          <displayName>PA11_PDIO</displayName>
          <description>GPIO PA.n Pin Data Input/Output\n(NuMicro( NUC100/NUC120 Low Density Only)</description>
          <addressOffset>0x22C</addressOffset>
       </register>
       <register derivedFrom="PA0_PDIO">
          <name>PA12_PDIO</name>
          <displayName>PA12_PDIO</displayName>
          <description>GPIO PA.n Pin Data Input/Output\n(NuMicro( NUC100/NUC120 Low Density Only)</description>
          <addressOffset>0x230</addressOffset>
       </register>
       <register derivedFrom="PA0_PDIO">
          <name>PA13_PDIO</name>
          <displayName>PA13_PDIO</displayName>
          <description>GPIO PA.n Pin Data Input/Output\n(NuMicro( NUC100/NUC120 Low Density Only)</description>
          <addressOffset>0x234</addressOffset>
       </register>
       <register derivedFrom="PA0_PDIO">
          <name>PA14_PDIO</name>
          <displayName>PA14_PDIO</displayName>
          <description>GPIO PA.n Pin Data Input/Output\n(NuMicro( NUC100/NUC120 Low Density Only)</description>
          <addressOffset>0x238</addressOffset>
       </register>
       <register derivedFrom="PA0_PDIO">
          <name>PA15_PDIO</name>
          <displayName>PA15_PDIO</displayName>
          <description>GPIO PA.n Pin Data Input/Output\n(NuMicro( NUC100/NUC120 Low Density Only)</description>
          <addressOffset>0x23C</addressOffset>
       </register>
       <register derivedFrom="PA0_PDIO">
          <name>PB0_PDIO</name>
          <displayName>PB0_PDIO</displayName>
          <description>GPIO PB.n Pin Data Input/Output\n(NuMicro( NUC100/NUC120 Low Density Only)</description>
          <addressOffset>0x240</addressOffset>
       </register>
       <register derivedFrom="PB0_PDIO">
          <name>PB1_PDIO</name>
          <displayName>PB1_PDIO</displayName>
          <description>GPIO PB.n Pin Data Input/Output\n(NuMicro( NUC100/NUC120 Low Density Only)</description>
          <addressOffset>0x244</addressOffset>
       </register>
       <register derivedFrom="PB0_PDIO">
          <name>PB2_PDIO</name>
          <displayName>PB2_PDIO</displayName>
          <description>GPIO PB.n Pin Data Input/Output\n(NuMicro( NUC100/NUC120 Low Density Only)</description>
          <addressOffset>0x248</addressOffset>
       </register>
       <register derivedFrom="PB0_PDIO">
          <name>PB3_PDIO</name>
          <displayName>PB3_PDIO</displayName>
          <description>GPIO PB.n Pin Data Input/Output\n(NuMicro( NUC100/NUC120 Low Density Only)</description>
          <addressOffset>0x24C</addressOffset>
       </register>
       <register derivedFrom="PB0_PDIO">
          <name>PB4_PDIO</name>
          <displayName>PB4_PDIO</displayName>
          <description>GPIO PB.n Pin Data Input/Output\n(NuMicro( NUC100/NUC120 Low Density Only)</description>
          <addressOffset>0x250</addressOffset>
       </register>
       <register derivedFrom="PB0_PDIO">
          <name>PB5_PDIO</name>
          <displayName>PB5_PDIO</displayName>
          <description>GPIO PB.n Pin Data Input/Output\n(NuMicro( NUC100/NUC120 Low Density Only)</description>
          <addressOffset>0x254</addressOffset>
       </register>
       <register derivedFrom="PB0_PDIO">
          <name>PB6_PDIO</name>
          <displayName>PB6_PDIO</displayName>
          <description>GPIO PB.n Pin Data Input/Output\n(NuMicro( NUC100/NUC120 Low Density Only)</description>
          <addressOffset>0x258</addressOffset>
       </register>
       <register derivedFrom="PB0_PDIO">
          <name>PB7_PDIO</name>
          <displayName>PB7_PDIO</displayName>
          <description>GPIO PB.n Pin Data Input/Output\n(NuMicro( NUC100/NUC120 Low Density Only)</description>
          <addressOffset>0x25C</addressOffset>
       </register>
       <register derivedFrom="PB0_PDIO">
          <name>PB8_PDIO</name>
          <displayName>PB8_PDIO</displayName>
          <description>GPIO PB.n Pin Data Input/Output\n(NuMicro( NUC100/NUC120 Low Density Only)</description>
          <addressOffset>0x260</addressOffset>
       </register>
       <register derivedFrom="PB0_PDIO">
          <name>PB9_PDIO</name>
          <displayName>PB9_PDIO</displayName>
          <description>GPIO PB.n Pin Data Input/Output\n(NuMicro( NUC100/NUC120 Low Density Only)</description>
          <addressOffset>0x264</addressOffset>
       </register>
       <register derivedFrom="PB0_PDIO">
          <name>PB10_PDIO</name>
          <displayName>PB10_PDIO</displayName>
          <description>GPIO PB.n Pin Data Input/Output\n(NuMicro( NUC100/NUC120 Low Density Only)</description>
          <addressOffset>0x268</addressOffset>
       </register>
       <register derivedFrom="PB0_PDIO">
          <name>PB11_PDIO</name>
          <displayName>PB11_PDIO</displayName>
          <description>GPIO PB.n Pin Data Input/Output\n(NuMicro( NUC100/NUC120 Low Density Only)</description>
          <addressOffset>0x26C</addressOffset>
       </register>
       <register derivedFrom="PB0_PDIO">
          <name>PB12_PDIO</name>
          <displayName>PB12_PDIO</displayName>
          <description>GPIO PB.n Pin Data Input/Output\n(NuMicro( NUC100/NUC120 Low Density Only)</description>
          <addressOffset>0x270</addressOffset>
       </register>
       <register derivedFrom="PB0_PDIO">
          <name>PB13_PDIO</name>
          <displayName>PB13_PDIO</displayName>
          <description>GPIO PB.n Pin Data Input/Output\n(NuMicro( NUC100/NUC120 Low Density Only)</description>
          <addressOffset>0x274</addressOffset>
       </register>
       <register derivedFrom="PB0_PDIO">
          <name>PB14_PDIO</name>
          <displayName>PB14_PDIO</displayName>
          <description>GPIO PB.n Pin Data Input/Output\n(NuMicro( NUC100/NUC120 Low Density Only)</description>
          <addressOffset>0x278</addressOffset>
       </register>
       <register derivedFrom="PB0_PDIO">
          <name>PB15_PDIO</name>
          <displayName>PB15_PDIO</displayName>
          <description>GPIO PB.n Pin Data Input/Output\n(NuMicro( NUC100/NUC120 Low Density Only)</description>
          <addressOffset>0x27C</addressOffset>
       </register>
       <register derivedFrom="PA0_PDIO">
          <name>PC0_PDIO</name>
          <displayName>PC0_PDIO</displayName>
          <description>GPIO PC.n Pin Data Input/Output\n(NuMicro( NUC100/NUC120 Low Density Only)</description>
          <addressOffset>0x280</addressOffset>
       </register>
       <register derivedFrom="PC0_PDIO">
          <name>PC1_PDIO</name>
          <displayName>PC1_PDIO</displayName>
          <description>GPIO PC.n Pin Data Input/Output\n(NuMicro( NUC100/NUC120 Low Density Only)</description>
          <addressOffset>0x284</addressOffset>
       </register>
       <register derivedFrom="PC0_PDIO">
          <name>PC2_PDIO</name>
          <displayName>PC2_PDIO</displayName>
          <description>GPIO PC.n Pin Data Input/Output\n(NuMicro( NUC100/NUC120 Low Density Only)</description>
          <addressOffset>0x288</addressOffset>
       </register>
       <register derivedFrom="PC0_PDIO">
          <name>PC3_PDIO</name>
          <displayName>PC3_PDIO</displayName>
          <description>GPIO PC.n Pin Data Input/Output\n(NuMicro( NUC100/NUC120 Low Density Only)</description>
          <addressOffset>0x28C</addressOffset>
       </register>
       <register derivedFrom="PC0_PDIO">
          <name>PC4_PDIO</name>
          <displayName>PC4_PDIO</displayName>
          <description>GPIO PC.n Pin Data Input/Output\n(NuMicro( NUC100/NUC120 Low Density Only)</description>
          <addressOffset>0x290</addressOffset>
       </register>
       <register derivedFrom="PC0_PDIO">
          <name>PC5_PDIO</name>
          <displayName>PC5_PDIO</displayName>
          <description>GPIO PC.n Pin Data Input/Output\n(NuMicro( NUC100/NUC120 Low Density Only)</description>
          <addressOffset>0x294</addressOffset>
       </register>
       <register derivedFrom="PC0_PDIO">
          <name>PC6_PDIO</name>
          <displayName>PC6_PDIO</displayName>
          <description>GPIO PC.n Pin Data Input/Output\n(NuMicro( NUC100/NUC120 Low Density Only)</description>
          <addressOffset>0x298</addressOffset>
       </register>
       <register derivedFrom="PC0_PDIO">
          <name>PC7_PDIO</name>
          <displayName>PC7_PDIO</displayName>
          <description>GPIO PC.n Pin Data Input/Output\n(NuMicro( NUC100/NUC120 Low Density Only)</description>
          <addressOffset>0x29C</addressOffset>
       </register>
       <register derivedFrom="PC0_PDIO">
          <name>PC8_PDIO</name>
          <displayName>PC8_PDIO</displayName>
          <description>GPIO PC.n Pin Data Input/Output\n(NuMicro( NUC100/NUC120 Low Density Only)</description>
          <addressOffset>0x2A0</addressOffset>
       </register>
       <register derivedFrom="PC0_PDIO">
          <name>PC9_PDIO</name>
          <displayName>PC9_PDIO</displayName>
          <description>GPIO PC.n Pin Data Input/Output\n(NuMicro( NUC100/NUC120 Low Density Only)</description>
          <addressOffset>0x2A4</addressOffset>
       </register>
       <register derivedFrom="PC0_PDIO">
          <name>PC10_PDIO</name>
          <displayName>PC10_PDIO</displayName>
          <description>GPIO PC.n Pin Data Input/Output\n(NuMicro( NUC100/NUC120 Low Density Only)</description>
          <addressOffset>0x2A8</addressOffset>
       </register>
       <register derivedFrom="PC0_PDIO">
          <name>PC11_PDIO</name>
          <displayName>PC11_PDIO</displayName>
          <description>GPIO PC.n Pin Data Input/Output\n(NuMicro( NUC100/NUC120 Low Density Only)</description>
          <addressOffset>0x2AC</addressOffset>
       </register>
       <register derivedFrom="PC0_PDIO">
          <name>PC12_PDIO</name>
          <displayName>PC12_PDIO</displayName>
          <description>GPIO PC.n Pin Data Input/Output\n(NuMicro( NUC100/NUC120 Low Density Only)</description>
          <addressOffset>0x2B0</addressOffset>
       </register>
       <register derivedFrom="PC0_PDIO">
          <name>PC13_PDIO</name>
          <displayName>PC13_PDIO</displayName>
          <description>GPIO PC.n Pin Data Input/Output\n(NuMicro( NUC100/NUC120 Low Density Only)</description>
          <addressOffset>0x2B4</addressOffset>
       </register>
       <register derivedFrom="PC0_PDIO">
          <name>PC14_PDIO</name>
          <displayName>PC14_PDIO</displayName>
          <description>GPIO PC.n Pin Data Input/Output\n(NuMicro( NUC100/NUC120 Low Density Only)</description>
          <addressOffset>0x2B8</addressOffset>
       </register>
       <register derivedFrom="PC0_PDIO">
          <name>PC15_PDIO</name>
          <displayName>PC15_PDIO</displayName>
          <description>GPIO PC.n Pin Data Input/Output\n(NuMicro( NUC100/NUC120 Low Density Only)</description>
          <addressOffset>0x2BC</addressOffset>
       </register>
       <register derivedFrom="PA0_PDIO">
          <name>PD0_PDIO</name>
          <displayName>PD0_PDIO</displayName>
          <description>GPIO PD.n Pin Data Input/Output\n(NuMicro( NUC100/NUC120 Low Density Only)</description>
          <addressOffset>0x2C0</addressOffset>
       </register>
       <register derivedFrom="PD0_PDIO">
          <name>PD1_PDIO</name>
          <displayName>PD1_PDIO</displayName>
          <description>GPIO PD.n Pin Data Input/Output\n(NuMicro( NUC100/NUC120 Low Density Only)</description>
          <addressOffset>0x2C4</addressOffset>
       </register>
       <register derivedFrom="PD0_PDIO">
          <name>PD2_PDIO</name>
          <displayName>PD2_PDIO</displayName>
          <description>GPIO PD.n Pin Data Input/Output\n(NuMicro( NUC100/NUC120 Low Density Only)</description>
          <addressOffset>0x2C8</addressOffset>
       </register>
       <register derivedFrom="PD0_PDIO">
          <name>PD3_PDIO</name>
          <displayName>PD3_PDIO</displayName>
          <description>GPIO PD.n Pin Data Input/Output\n(NuMicro( NUC100/NUC120 Low Density Only)</description>
          <addressOffset>0x2CC</addressOffset>
       </register>
       <register derivedFrom="PD0_PDIO">
          <name>PD4_PDIO</name>
          <displayName>PD4_PDIO</displayName>
          <description>GPIO PD.n Pin Data Input/Output\n(NuMicro( NUC100/NUC120 Low Density Only)</description>
          <addressOffset>0x2D0</addressOffset>
       </register>
       <register derivedFrom="PD0_PDIO">
          <name>PD5_PDIO</name>
          <displayName>PD5_PDIO</displayName>
          <description>GPIO PD.n Pin Data Input/Output\n(NuMicro( NUC100/NUC120 Low Density Only)</description>
          <addressOffset>0x2D4</addressOffset>
       </register>
       <register derivedFrom="PD0_PDIO">
          <name>PD6_PDIO</name>
          <displayName>PD6_PDIO</displayName>
          <description>GPIO PD.n Pin Data Input/Output\n(NuMicro( NUC100/NUC120 Low Density Only)</description>
          <addressOffset>0x2D8</addressOffset>
       </register>
       <register derivedFrom="PD0_PDIO">
          <name>PD7_PDIO</name>
          <displayName>PD7_PDIO</displayName>
          <description>GPIO PD.n Pin Data Input/Output\n(NuMicro( NUC100/NUC120 Low Density Only)</description>
          <addressOffset>0x2DC</addressOffset>
       </register>
       <register derivedFrom="PD0_PDIO">
          <name>PD8_PDIO</name>
          <displayName>PD8_PDIO</displayName>
          <description>GPIO PD.n Pin Data Input/Output\n(NuMicro( NUC100/NUC120 Low Density Only)</description>
          <addressOffset>0x2E0</addressOffset>
       </register>
       <register derivedFrom="PD0_PDIO">
          <name>PD9_PDIO</name>
          <displayName>PD9_PDIO</displayName>
          <description>GPIO PD.n Pin Data Input/Output\n(NuMicro( NUC100/NUC120 Low Density Only)</description>
          <addressOffset>0x2E4</addressOffset>
       </register>
       <register derivedFrom="PD0_PDIO">
          <name>PD10_PDIO</name>
          <displayName>PD10_PDIO</displayName>
          <description>GPIO PD.n Pin Data Input/Output\n(NuMicro( NUC100/NUC120 Low Density Only)</description>
          <addressOffset>0x2E8</addressOffset>
       </register>
       <register derivedFrom="PD0_PDIO">
          <name>PD11_PDIO</name>
          <displayName>PD11_PDIO</displayName>
          <description>GPIO PD.n Pin Data Input/Output\n(NuMicro( NUC100/NUC120 Low Density Only)</description>
          <addressOffset>0x2EC</addressOffset>
       </register>
       <register derivedFrom="PD0_PDIO">
          <name>PD12_PDIO</name>
          <displayName>PD12_PDIO</displayName>
          <description>GPIO PD.n Pin Data Input/Output\n(NuMicro( NUC100/NUC120 Low Density Only)</description>
          <addressOffset>0x2F0</addressOffset>
       </register>
       <register derivedFrom="PD0_PDIO">
          <name>PD13_PDIO</name>
          <displayName>PD13_PDIO</displayName>
          <description>GPIO PD.n Pin Data Input/Output\n(NuMicro( NUC100/NUC120 Low Density Only)</description>
          <addressOffset>0x2F4</addressOffset>
       </register>
       <register derivedFrom="PD0_PDIO">
          <name>PD14_PDIO</name>
          <displayName>PD14_PDIO</displayName>
          <description>GPIO PD.n Pin Data Input/Output\n(NuMicro( NUC100/NUC120 Low Density Only)</description>
          <addressOffset>0x2F8</addressOffset>
       </register>
       <register derivedFrom="PD0_PDIO">
          <name>PD15_PDIO</name>
          <displayName>PD15_PDIO</displayName>
          <description>GPIO PD.n Pin Data Input/Output\n(NuMicro( NUC100/NUC120 Low Density Only)</description>
          <addressOffset>0x2FC</addressOffset>
       </register>
       <register derivedFrom="PA0_PDIO">
          <name>PE5_PDIO</name>
          <displayName>PE5_PDIO</displayName>
          <description>GPIO PE.5 Pin Data Input/Output\n(NuMicro( NUC100/NUC120 Low Density Only)</description>
          <addressOffset>0x314</addressOffset>
       </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>I2C0</name>
      <description>I2C Register Map</description>
      <groupName>I2C</groupName>
      <baseAddress>0x40020000</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x0</offset>
        <size>0x34</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>I2CON</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>I2CON</displayName>
          <description>I2C Control Register</description>
          <addressOffset>0x0</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>AA</name>
              <description>Assert Acknowledge Control Bit\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SI</name>
              <description>I2C Interrupt Flag\nWhen a new I2C state is present in the I2CSTATUS register, the SI flag is set by hardware, and if bit EI (I2CON [7]) is set, the I2C interrupt is requested. SI must be cleared by software. Clear SI is by writing 1 to this bit.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>STO</name>
              <description>I2C STOP Control Bit\nIn Master mode, setting STO to transmit a STOP condition to bus then I2C hardware will check the bus condition if a STOP condition is detected this bit will be cleared by hardware automatically. In Slave mode, setting STO resets I2C hardware to the defined "not addressed" Slave mode. This means it is NO LONGER in the slave receiver mode to receive data from the master transmit device.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>STA</name>
              <description>I2C START Control Bit\nSetting STA to logic 1 to enter Master mode, the I2C hardware sends a START or repeat START condition to bus when the bus is free.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ENS1</name>
              <description>I2C Controller Enable Bit\n</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>EI</name>
              <description>Enable Interrupt\n</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>I2C interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>I2C interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>I2CADDR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>I2CADDR0</displayName>
          <description>I2C Slave Address Register0</description>
          <addressOffset>0x4</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>GC</name>
              <description>General Call Function\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>General Call function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>General Call function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>I2CADDR</name>
              <description>I2C Address Register\nThe content of this register is irrelevant when I2C is in Master mode. In Slave mode, the seven most significant bits must be loaded with the chip's own address. The I2C hardware will react if either of the address is matched.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>7</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>I2CDAT</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>I2CDAT</displayName>
          <description>I2C Data Register</description>
          <addressOffset>0x8</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>I2CDAT</name>
              <description>I2C Data Register\nBit [7:0] is located with the 8-bit transferred data of I2C serial port.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>I2CSTATUS</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>I2CSTATUS</displayName>
          <description>I2C Status Register</description>
          <addressOffset>0xC</addressOffset>
          <access>read-only</access>
          <resetValue>0x000000F8</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>I2CSTATUS</name>
              <description>I2C Status Register\nThe status register of I2C:\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>I2CLK</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>I2CLK</displayName>
          <description>I2C Clock Divided Register</description>
          <addressOffset>0x10</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>I2CLK</name>
              <description>I2C clock divided Register\nNote: the minimum value of I2CLK is 4.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>I2CTOC</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>I2CTOC</displayName>
          <description>I2C Time Out Control Register</description>
          <addressOffset>0x14</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TIF</name>
              <description>Time-Out Flag\nThis bit is set by H/W when I2C time-out happened and it can interrupt CPU if I2C interrupt enable bit (EI) is set to 1.\nS/W can write 1 to clear this bit.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DIV4</name>
              <description>Time-Out counter input clock is divided by 4\nWhen Enabled, The time-Out period is extend 4 times.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ENTI</name>
              <description>Time-out counter is enabled/disable\nWhen Enabled, the 14-bit time-out counter will start counting when SI is clear. Setting flag SI to high will reset counter and re-start up counting after SI is cleared.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="I2CADDR0">
          <name>I2CADDR1</name>
          <displayName>I2CADDR1</displayName>
          <description>I2C Slave Address Register1</description>
          <addressOffset>0x18</addressOffset>
       </register>
       <register derivedFrom="I2CADDR0">
          <name>I2CADDR2</name>
          <displayName>I2CADDR2</displayName>
          <description>I2C Slave Address Register2</description>
          <addressOffset>0x1C</addressOffset>
       </register>
       <register derivedFrom="I2CADDR0">
          <name>I2CADDR3</name>
          <displayName>I2CADDR3</displayName>
          <description>I2C Slave Address Register3</description>
          <addressOffset>0x20</addressOffset>
       </register>
       <register>
          <name>I2CADM0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>I2CADM0</displayName>
          <description>I2C Slave Address Mask Register0</description>
          <addressOffset>0x24</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>I2CADM</name>
              <description>I2C Address Mask register\nI2C bus controllers support multiple address recognition with four address mask register. When the bit in the address mask register is set to one, it means the received corresponding address bit is don't-care. If the bit is set to zero, that means the received corresponding register bit should be exact the same as address register.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>7</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Mask disable (the received corresponding register bit should be exact the same as address register.)</description>
                    <value>0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Mask enable (the received corresponding address bit is don't care.)</description>
                    <value>1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="I2CADM0">
          <name>I2CADM1</name>
          <displayName>I2CADM1</displayName>
          <description>I2C Slave Address Mask Register1</description>
          <addressOffset>0x28</addressOffset>
       </register>
       <register derivedFrom="I2CADM0">
          <name>I2CADM2</name>
          <displayName>I2CADM2</displayName>
          <description>I2C Slave Address Mask Register2</description>
          <addressOffset>0x2C</addressOffset>
       </register>
       <register derivedFrom="I2CADM0">
          <name>I2CADM3</name>
          <displayName>I2CADM3</displayName>
          <description>I2C Slave Address Mask Register3</description>
          <addressOffset>0x30</addressOffset>
       </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>I2C1</name>
      <description>I2C Register Map</description>
      <groupName>I2C</groupName>
      <baseAddress>0x400386A0</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x0</offset>
        <size>0x34</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>I2CON</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>I2CON</displayName>
          <description>I2C Control Register</description>
          <addressOffset>0x0</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>AA</name>
              <description>Assert Acknowledge Control Bit\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SI</name>
              <description>I2C Interrupt Flag\nWhen a new I2C state is present in the I2CSTATUS register, the SI flag is set by hardware, and if bit EI (I2CON [7]) is set, the I2C interrupt is requested. SI must be cleared by software. Clear SI is by writing 1 to this bit.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>STO</name>
              <description>I2C STOP Control Bit\nIn Master mode, setting STO to transmit a STOP condition to bus then I2C hardware will check the bus condition if a STOP condition is detected this bit will be cleared by hardware automatically. In Slave mode, setting STO resets I2C hardware to the defined "not addressed" Slave mode. This means it is NO LONGER in the slave receiver mode to receive data from the master transmit device.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>STA</name>
              <description>I2C START Control Bit\nSetting STA to logic 1 to enter Master mode, the I2C hardware sends a START or repeat START condition to bus when the bus is free.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ENS1</name>
              <description>I2C Controller Enable Bit\n</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>EI</name>
              <description>Enable Interrupt\n</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>I2C interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>I2C interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>I2CADDR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>I2CADDR0</displayName>
          <description>I2C Slave Address Register0</description>
          <addressOffset>0x4</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>GC</name>
              <description>General Call Function\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>General Call function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>General Call function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>I2CADDR</name>
              <description>I2C Address Register\nThe content of this register is irrelevant when I2C is in Master mode. In Slave mode, the seven most significant bits must be loaded with the chip's own address. The I2C hardware will react if either of the address is matched.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>7</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>I2CDAT</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>I2CDAT</displayName>
          <description>I2C Data Register</description>
          <addressOffset>0x8</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>I2CDAT</name>
              <description>I2C Data Register\nBit [7:0] is located with the 8-bit transferred data of I2C serial port.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>I2CSTATUS</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>I2CSTATUS</displayName>
          <description>I2C Status Register</description>
          <addressOffset>0xC</addressOffset>
          <access>read-only</access>
          <resetValue>0x000000F8</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>I2CSTATUS</name>
              <description>I2C Status Register\nThe status register of I2C:\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>I2CLK</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>I2CLK</displayName>
          <description>I2C Clock Divided Register</description>
          <addressOffset>0x10</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>I2CLK</name>
              <description>I2C clock divided Register\nNote: the minimum value of I2CLK is 4.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>I2CTOC</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>I2CTOC</displayName>
          <description>I2C Time Out Control Register</description>
          <addressOffset>0x14</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TIF</name>
              <description>Time-Out Flag\nThis bit is set by H/W when I2C time-out happened and it can interrupt CPU if I2C interrupt enable bit (EI) is set to 1.\nS/W can write 1 to clear this bit.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DIV4</name>
              <description>Time-Out counter input clock is divided by 4\nWhen Enabled, The time-Out period is extend 4 times.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ENTI</name>
              <description>Time-out counter is enabled/disable\nWhen Enabled, the 14-bit time-out counter will start counting when SI is clear. Setting flag SI to high will reset counter and re-start up counting after SI is cleared.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="I2CADDR0">
          <name>I2CADDR1</name>
          <displayName>I2CADDR1</displayName>
          <description>I2C Slave Address Register1</description>
          <addressOffset>0x18</addressOffset>
       </register>
       <register derivedFrom="I2CADDR0">
          <name>I2CADDR2</name>
          <displayName>I2CADDR2</displayName>
          <description>I2C Slave Address Register2</description>
          <addressOffset>0x1C</addressOffset>
       </register>
       <register derivedFrom="I2CADDR0">
          <name>I2CADDR3</name>
          <displayName>I2CADDR3</displayName>
          <description>I2C Slave Address Register3</description>
          <addressOffset>0x20</addressOffset>
       </register>
       <register>
          <name>I2CADM0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>I2CADM0</displayName>
          <description>I2C Slave Address Mask Register0</description>
          <addressOffset>0x24</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>I2CADM</name>
              <description>I2C Address Mask register\nI2C bus controllers support multiple address recognition with four address mask register. When the bit in the address mask register is set to one, it means the received corresponding address bit is don't-care. If the bit is set to zero, that means the received corresponding register bit should be exact the same as address register.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>7</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Mask disable (the received corresponding register bit should be exact the same as address register.)</description>
                    <value>0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Mask enable (the received corresponding address bit is don't care.)</description>
                    <value>1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="I2CADM0">
          <name>I2CADM1</name>
          <displayName>I2CADM1</displayName>
          <description>I2C Slave Address Mask Register1</description>
          <addressOffset>0x28</addressOffset>
       </register>
       <register derivedFrom="I2CADM0">
          <name>I2CADM2</name>
          <displayName>I2CADM2</displayName>
          <description>I2C Slave Address Mask Register2</description>
          <addressOffset>0x2C</addressOffset>
       </register>
       <register derivedFrom="I2CADM0">
          <name>I2CADM3</name>
          <displayName>I2CADM3</displayName>
          <description>I2C Slave Address Mask Register3</description>
          <addressOffset>0x30</addressOffset>
       </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>PWMA</name>
      <description>PWM Register Map</description>
      <groupName>PWM</groupName>
      <baseAddress>0x40040000</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x0</offset>
        <size>0x48</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x50</offset>
        <size>0x30</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>PPR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PPR</displayName>
          <description>PWM Group A Prescaler Register\nPWM Group B Prescaler Register\n(NuMicro( NUC100/NUC120 Medium Density Only)</description>
          <addressOffset>0x0</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CP01</name>
              <description>Clock Prescaler 0  (PWM-timer 0 / 1 for group A and PWM-timer 4 / 5 for Group B)\nClock input is divided by (CP01 + 1) before it is fed to the corresponding PWM-timer\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CP23</name>
              <description>Clock Prescaler 2 (PWM-timer2 /3 for group A and PWM-timer 6 / 7 for Group B)\nClock input is divided by (CP23 + 1) before it is fed to the corresponding PWM-timer\n</description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DZI01</name>
              <description>Dead-zone Interval for Pair of Channel 0 and Channel 1 (PWM0 and PWM1 Pair for PWM group A, PWM4 and PWM5 pair for PWM group B)\nThese 8-bit determine the dead-zone length.\nThe unit time of dead-zone length is received from corresponding CSR bits.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DZI23</name>
              <description>Dead-zone Interval for Pair of Channel2 and Channel3 (PWM2 and PWM3 pair for PWM group A, PWM6 and PWM7 pair for PWM group B)\nThese 8-bit determine the dead-zone length.\nThe unit time of dead-zone length is received from corresponding CSR bits.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CSR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CSR</displayName>
          <description>PWM Group A Clock Source Divider Select Register\nPWM Group B Clock Source Divider Select Register\n(NuMicro( NUC100/NUC120 Medium Density Only)</description>
          <addressOffset>0x4</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CSR0</name>
              <description>PWM Timer 0 Clock Source Divider Selection (PWM timer 0 for group A and PWM timer 4 for group B)\nSelect clock source divider for PWM timer 0.\n(Table is the same as CSR3.)</description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CSR1</name>
              <description>PWM Timer 1 Clock Source Divider Selection (PWM timer 1 for group A and PWM timer 5 for group B)\nSelect clock source divider for PWM timer 1.\n(Table is the same as CSR3.)</description>
              <bitOffset>4</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CSR2</name>
              <description>PWM Timer 2 Clock Source Divider Selection (PWM timer 2 for group A and PWM timer 6 for group B)\nSelect clock source divider for PWM timer 2.\n(Table is the same as CSR3.)</description>
              <bitOffset>8</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CSR3</name>
              <description>PWM Timer 3 Clock Source Divider Selection (PWM timer 3 for group A and PWM timer 7 for group B)\n</description>
              <bitOffset>12</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PCR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PCR</displayName>
          <description>PWM Group A Control Register\nPWM Group B Control Register\n(NuMicro( NUC100/NUC120 Medium Density Only)</description>
          <addressOffset>0x8</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CH0EN</name>
              <description>PWM-Timer 0 Enable (PWM timer 0 for group A and PWM timer 4 for group B)\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Corresponding PWM-Timer Running Stopped</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Corresponding PWM-Timer Start Run Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CH0INV</name>
              <description>PWM-Timer 0 Output Inverter Enable (PWM timer 0 for group A and PWM timer 4 for group B)\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Inverter Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Inverter Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CH0MOD</name>
              <description>PWM-Timer 0 Auto-reload/One-Shot Mode (PWM Timer 0 for Group A and PWM Timer 4 for Group B)\nNote: If there is a transition at this bit, it will cause CNR0 and CMR0 be cleared.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>One-shot mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Auto-reload mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DZEN01</name>
              <description>Dead-Zone 0 Generator Enable (PWM0 and PWM1 Pair for PWM Group A, PWM4 and PWM5 Pair for PWM Group B)\nNote: When Dead-Zone Generator is enabled, the pair of PWM0 and PWM1 becomes a complementary pair for PWM group A and the pair of PWM4 and PWM5 becomes a complementary pair for PWM group B.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DZEN23</name>
              <description>Dead-Zone 2 Generator Enable (PWM2 and PWM3 Pair for PWM Group A, PWM6 and PWM7 Pair for PWM Group B)\nNote: When the Dead-Zone Generator is enabled, the pair of PWM2 and PWM3 becomes a complementary pair for PWM group A and the pair of PWM6 and PWM7 becomes a complementary pair for PWM group B.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CH1EN</name>
              <description>PWM-Timer 1 Enable (PWM Timer 1 for Group A and PWM Timer 5 for Group B)\n</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Corresponding PWM-Timer Running Stopped</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Corresponding PWM-Timer Start Run Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CH1INV</name>
              <description>PWM-Timer 1 Output Inverter Enable (PWM Timer 1 for Group A and PWM Timer 5 for Group B)\n</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Inverter Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Inverter Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CH1MOD</name>
              <description>PWM-Timer 1 Auto-reload/One-Shot Mode (PWM timer 1 for Group A and PWM timer 5 for Group B)\nNote: If there is a transition at this bit, it will cause CNR1 and CMR1 be cleared.</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>One-shot mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Auto-load mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CH2EN</name>
              <description>PWM-Timer 2 Enable (PWM timer 2 for group A and PWM timer 6 for Group B)\n</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>corresponding PWM-Timer Running Stopped</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>corresponding PWM-Timer Start Run Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CH2INV</name>
              <description>PWM-Timer 2 Output Inverter Enable (PWM timer 2 for group A and PWM timer 6 for group B)\n</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Inverter Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Inverter Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CH2MOD</name>
              <description>PWM-Timer 2 Auto-reload/One-Shot Mode (PWM timer 2 for group A and PWM timer 6 for group B)\nNote: If there is a transition at this bit, it will cause CNR2 and CMR2 be cleared.</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>One-shot mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Auto-reload mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CH3EN</name>
              <description>PWM-Timer 3 Enable (PWM timer 3 for group A and PWM timer 7 for group B)\n</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Corresponding PWM-Timer Running Stopped</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Corresponding PWM-Timer Start Run Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CH3INV</name>
              <description>PWM-Timer 3 Output Inverter Enable (PWM timer 3 for group A and PWM timer 7 for group B)\n</description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Inverter Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Inverter Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CH3MOD</name>
              <description>PWM-Timer 3 Auto-reload/One-Shot Mode (PWM timer 3 for group A and PWM timer 7 for group B)\nNote: If there is a transition at this bit, it will cause CNR3 and CMR3 be cleared.</description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>One-shot mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Auto-reload mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CNR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CNR0</displayName>
          <description>PWM Group A Counter Register 0\nPWM Group B Counter Register 0\n(NuMicro( NUC100/NUC120 Medium Density Only)</description>
          <addressOffset>0xC</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CNRx</name>
              <description>PWM Timer Loaded Value\nCNR determines the PWM period.\nNote: Any write to CNR will take effect in next PWM cycle.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CMR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CMR0</displayName>
          <description>PWM Group A Comparator Register 0\nPWM Group B Comparator Register 0\n(NuMicro( NUC100/NUC120 Medium Density Only)</description>
          <addressOffset>0x10</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CMRx</name>
              <description>PWM Comparator Register\nCMR determines the PWM duty.\nNote: Any write to CMR will take effect in next PWM cycle.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PDR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDR0</displayName>
          <description>PWM Group A Data Register 0\nPWM Group B Data Register 0\n(NuMicro( NUC100/NUC120 Medium Density Only)</description>
          <addressOffset>0x14</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDRx</name>
              <description>PWM Data Register\nUser can monitor PDR to know the current value in 16-bit down counter.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="CNR0">
          <name>CNR1</name>
          <displayName>CNR1</displayName>
          <description>PWM Group A Counter Register 1\nPWM Group B Counter Register 1\n(NuMicro( NUC100/NUC120 Medium Density Only)</description>
          <addressOffset>0x18</addressOffset>
       </register>
       <register derivedFrom="CMR0">
          <name>CMR1</name>
          <displayName>CMR1</displayName>
          <description>PWM Group A Comparator Register 1\nPWM Group B Comparator Register 1\n(NuMicro( NUC100/NUC120 Medium Density Only)</description>
          <addressOffset>0x1C</addressOffset>
       </register>
       <register derivedFrom="PDR0">
          <name>PDR1</name>
          <displayName>PDR1</displayName>
          <description>PWM Group A Data Register 1\nPWM Group B Data Register 1\n(NuMicro( NUC100/NUC120 Medium Density Only)</description>
          <addressOffset>0x20</addressOffset>
       </register>
       <register derivedFrom="CNR0">
          <name>CNR2</name>
          <displayName>CNR2</displayName>
          <description>PWM Group A Counter Register 2\nPWM Group B Counter Register 2\n(NuMicro( NUC100/NUC120 Medium Density Only)</description>
          <addressOffset>0x24</addressOffset>
       </register>
       <register derivedFrom="CMR0">
          <name>CMR2</name>
          <displayName>CMR2</displayName>
          <description>PWM Group A Comparator Register 2\nPWM Group B Comparator Register 2\n(NuMicro( NUC100/NUC120 Medium Density Only)</description>
          <addressOffset>0x28</addressOffset>
       </register>
       <register derivedFrom="PDR0">
          <name>PDR2</name>
          <displayName>PDR2</displayName>
          <description>PWM Group A Data Register 2\nPWM Group B Data Register 2\n(NuMicro( NUC100/NUC120 Medium Density Only)</description>
          <addressOffset>0x2C</addressOffset>
       </register>
       <register derivedFrom="CNR0">
          <name>CNR3</name>
          <displayName>CNR3</displayName>
          <description>PWM Group A Counter Register 3\nPWM Group B Counter Register 3\n(NuMicro( NUC100/NUC120 Medium Density Only)</description>
          <addressOffset>0x30</addressOffset>
       </register>
       <register derivedFrom="CMR0">
          <name>CMR3</name>
          <displayName>CMR3</displayName>
          <description>PWM Group A Comparator Register 3\nPWM Group B Comparator Register 3\n(NuMicro( NUC100/NUC120 Medium Density Only)</description>
          <addressOffset>0x34</addressOffset>
       </register>
       <register derivedFrom="PDR0">
          <name>PDR3</name>
          <displayName>PDR3</displayName>
          <description>PWM Group A Data Register 3\nPWM Group B Data Register 3\n(NuMicro( NUC100/NUC120 Medium Density Only)</description>
          <addressOffset>0x38</addressOffset>
       </register>
       <register>
          <name>PBCR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PBCR</displayName>
          <description>PWM Backward Compatible Register\n(NuMicro( NUC100/NUC120 Low Density Only)</description>
          <addressOffset>0x3C</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BCn</name>
              <description>PWM Backward Compatible Register\nRefer to the CCR0/CCR2 register bit 6, 7, 22, 23 descriptions.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Configure write 0 to clear CFLRI0~3 and CRLRI0~3</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Configure write 1 to clear CFLRI0~3 and CRLRI0~3</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PIER</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PIER</displayName>
          <description>PWM Group A Interrupt Enable Register\nPWM Group B Interrupt Enable Register\n(NuMicro( NUC100/NUC120 Medium Density Only)</description>
          <addressOffset>0x40</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PWMIE0</name>
              <description>PWM channel 0 Interrupt Enable\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PWMIE1</name>
              <description>PWM channel 1 Interrupt Enable\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PWMIE2</name>
              <description>PWM channel 2 Interrupt Enable\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PWMIE3</name>
              <description>PWM channel 3 Interrupt Enable\n</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PIIR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PIIR</displayName>
          <description>PWM Group A Interrupt Indication Register\nPWM Group B Interrupt Indication Register\n(NuMicro( NUC100/NUC120 Medium Density Only)</description>
          <addressOffset>0x44</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PWMIF0</name>
              <description>PWM channel 0 Interrupt Status\nThis bit is set by hardware when PWM0 down counter reaches zero if PWM3 interrupt enable bit (PWMIE0) is 1, software can write 1 to clear this bit to zero</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PWMIF1</name>
              <description>PWM channel 1 Interrupt Status\nThis bit is set by hardware when PWM1 down counter reaches zero if PWM3 interrupt enable bit (PWMIE1) is 1, software can write 1 to clear this bit to zero</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PWMIF2</name>
              <description>PWM channel 2 Interrupt Status\nThis bit is set by hardware when PWM2 down counter reaches zero if PWM3 interrupt enable bit (PWMIE2) is 1, software can write 1 to clear this bit to zero</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PWMIF3</name>
              <description>PWM channel 3 Interrupt Status\nThis bit is set by hardware when PWM3 down counter reaches zero if PWM3 interrupt enable bit (PWMIE3) is 1, software can write 1 to clear this bit to zero</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CCR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CCR0</displayName>
          <description>PWM Group A Capture Control Register 0\nPWM Group B Capture Control Register 0\n(NuMicro( NUC100/NUC120 Medium Density Only)</description>
          <addressOffset>0x50</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>INV0</name>
              <description>Channel 0 Inverter Enable\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Inverter Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Inverter Enabled. Reverse the input signal from GPIO before fed to Capture timer</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CRL_IE0</name>
              <description>Channel 0 Rising Latch Interrupt Enable\nWhen Enabled, if Capture detects PWM group channel 0 has rising transition, Capture will issue an Interrupt.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Rising latch interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Rising latch interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CFL_IE0</name>
              <description>Channel 0 Falling Latch Interrupt Enable\nWhen Enabled, if Capture detects PWM group channel 0 has falling transition, Capture will issue an Interrupt.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Falling latch interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Falling latch interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CAPCH0EN</name>
              <description>Channel 0 Capture Function Enable\nWhen Enabled, Capture latched the PWM-counter value and saved to CRLR (Rising latch) and CFLR (Falling latch).\nWhen Disabled, Capture does not update CRLR and CFLR, and disable PWM group channel 0 Interrupt.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Capture function on PWM group channel 0 Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Capture function on PWM group channel 0 Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CAPIF0</name>
              <description>Channel 0 Capture Interrupt Indication Flag\nWrite 1 to clear this bit to zero</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CRLRI0</name>
              <description>CRLR0 Latched Indicator Bit\nWhen PWM group input channel 0 has a rising transition, CRLR0 was latched with the value of PWM down-counter and this bit is set by hardware.\nIn NuMicro( NUC100/NUC120 Medium Density, software can write 0 to clear this bit to zero.\nIn NuMicro( NUC100/NUC120 Low Density, software can write 0 to clear this bit to zero if BCn bit is 0, and can Write 1 to clear this bit to zero if BCn bit is 1.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CFLRI0</name>
              <description>CFLR0 Latched Indicator Bit\nWhen PWM group input channel 0 has a falling transition, CFLR0 was latched with the value of PWM down-counter and this bit is set by hardware.\nIn NuMicro( NUC100/NUC120 Medium Density, software can write 0 to clear this bit to zero.\nIn NuMicro( NUC100/NUC120 Low Density, software can write 0 to clear this bit to zero if BCn bit is 0, and can Write 1 to clear this bit to zero if BCn bit is 1.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>INV1</name>
              <description>Channel 1 Inverter Enable\n</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Inverter Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Inverter Enabled. Reverse the input signal from GPIO before fed to Capture timer</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CRL_IE1</name>
              <description>Channel 1 Rising Latch Interrupt Enable\nWhen Enabled, if Capture detects PWM group channel 1 has rising transition, Capture will issue an Interrupt.</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Rising latch interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Rising latch interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CFL_IE1</name>
              <description>Channel 1 Falling Latch Interrupt Enable\nWhen Enabled, if Capture detects PWM group channel 1 has falling transition, Capture will issue an Interrupt.</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Falling latch interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Falling latch interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CAPCH1EN</name>
              <description>Channel 1 Capture Function Enable\nWhen Enabled, Capture latched the PWM-counter and saved to CRLR (Rising latch) and CFLR (Falling latch).\nWhen Disabled, Capture does not update CRLR and CFLR, and disable PWM group channel 1 Interrupt.</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Capture function on PWM group channel 1 Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Capture function on PWM group channel 1 Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CAPIF1</name>
              <description>Channel 1 Capture Interrupt Indication Flag\nWrite 1 to clear this bit to zero</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CRLRI1</name>
              <description>CRLR1 Latched Indicator Bit\nWhen PWM group input channel 1 has a rising transition, CRLR1 was latched with the value of PWM down-counter and this bit is set by hardware.\nIn NuMicro( NUC100/NUC120 Medium Density, software can write 0 to clear this bit to zero.\nIn NuMicro( NUC100/NUC120 Low Density, software can write 0 to clear this bit to zero if BCn bit is 0, and can Write 1 to clear this bit to zero if BCn bit is 1.</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CFLRI1</name>
              <description>CFLR1 Latched Indicator Bit\nWhen PWM group input channel 1 has a falling transition, CFLR1 was latched with the value of PWM down-counter and this bit is set by hardware.\nIn NuMicro( NUC100/NUC120 Medium Density, software can write 0 to clear this bit to zero.\nIn NuMicro( NUC100/NUC120 Low Density, software can write 0 to clear this bit to zero if BCn bit is 0, and can Write 1 to clear this bit to zero if BCn bit is 1.</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CCR2</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CCR2</displayName>
          <description>PWM Group A Capture Control Register 2\nPWM Group B Capture Control Register 2\n(NuMicro( NUC100/NUC120 Medium Density Only)</description>
          <addressOffset>0x54</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>INV2</name>
              <description>Channel 2 Inverter Enable\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Inverter Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Inverter Enabled. Reverse the input signal from GPIO before fed to Capture timer</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CRL_IE2</name>
              <description>Channel 2 Rising Latch Interrupt Enable\nWhen Enabled, if Capture detects PWM group channel 2 has rising transition, Capture will issue an Interrupt.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Rising latch interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Rising latch interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CFL_IE2</name>
              <description>Channel 2 Falling Latch Interrupt Enable\nWhen Enabled, if Capture detects PWM group channel 2 has falling transition, Capture will issue an Interrupt.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Falling latch interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Falling latch interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CAPCH2EN</name>
              <description>Channel 2 Capture Function Enable\nWhen Enabled, Capture latched the PWM-counter value and saved to CRLR (Rising latch) and CFLR (Falling latch).\nWhen Disabled, Capture does not update CRLR and CFLR, and disable PWM group channel 2 Interrupt.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Capture function on PWM group channel 2 Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Capture function on PWM group channel 2 Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CAPIF2</name>
              <description>Channel 2 Capture Interrupt Indication Flag\nWrite 1 to clear this bit to zero</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CRLRI2</name>
              <description>CRLR2 Latched Indicator Bit\nWhen PWM group input channel 2 has a rising transition, CRLR2 was latched with the value of PWM down-counter and this bit is set by hardware.\nIn NuMicro( NUC100/NUC120 Medium Density, software can write 0 to clear this bit to zero.\nIn NuMicro( NUC100/NUC120 Low Density, software can write 0 to clear this bit to zero if BCn bit is 0, and can Write 1 to clear this bit to zero if BCn bit is 1.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CFLRI2</name>
              <description>CFLR2 Latched Indicator Bit\nWhen PWM group input channel 2 has a falling transition, CFLR2 was latched with the value of PWM down-counter and this bit is set by hardware.\nIn NuMicro( NUC100/NUC120 Medium Density, software can write 0 to clear this bit to zero.\nIn NuMicro( NUC100/NUC120 Low Density, software can write 0 to clear this bit to zero if BCn bit is 0, and can Write 1 to clear this bit to zero if BCn bit is 1.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>INV3</name>
              <description>Channel 3 Inverter Enable\n</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Inverter Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Inverter Enabled. Reverse the input signal from GPIO before fed to Capture timer</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CRL_IE3</name>
              <description>Channel 3 Rising Latch Interrupt Enable\nWhen Enabled, if Capture detects PWM group channel 3 has rising transition, Capture will issue an Interrupt.</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Rising latch interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Rising latch interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CFL_IE3</name>
              <description>Channel 3 Falling Latch Interrupt Enable\nWhen Enabled, if Capture detects PWM group channel 3 has falling transition, Capture will issue an Interrupt.</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Falling latch interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Falling latch interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CAPCH3EN</name>
              <description>Channel 3 Capture Function Enable\nWhen Enabled, Capture latched the PWM-counter and saved to CRLR (Rising latch) and CFLR (Falling latch).\nWhen Disabled, Capture does not update CRLR and CFLR, and disable PWM group channel 3 Interrupt.</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Capture function on PWM group channel 3 Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Capture function on PWM group channel 3 Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CAPIF3</name>
              <description>Channel 3 Capture Interrupt Indication Flag\nWrite 1 to clear this bit to 0.</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CRLRI3</name>
              <description>CRLR3 Latched Indicator Bit\nWhen PWM group input channel 3 has a rising transition, CRLR3 was latched with the value of PWM down-counter and this bit is set by hardware.\nIn NuMicro( NUC100/NUC120 Medium Density, software can write 0 to clear this bit to zero.\nIn NuMicro( NUC100/NUC120 Low Density, software can write 0 to clear this bit to zero if BCn bit is 0, and can write 1 to clear this bit to zero if BCn bit is 1.</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CFLRI3</name>
              <description>CFLR3 Latched Indicator Bit\nWhen PWM group input channel 3 has a falling transition, CFLR3 was latched with the value of PWM down-counter and this bit is set by hardware.\nIn NuMicro( NUC100/NUC120 Medium Density, software can write 0 to clear this bit to zero.\nIn NuMicro( NUC100/NUC120 Low Density, software can write 0 to clear this bit to zero if BCn bit is 0, and can Write 1 to clear this bit to zero if BCn bit is 1.</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CRLR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CRLR0</displayName>
          <description>PWM Group A Capture Rising Latch Register (Channel 0)\nPWM Group B Capture Rising Latch Register (Channel 0) \n(NuMicro( NUC100/NUC120 Medium Density Only)</description>
          <addressOffset>0x58</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CRLRx</name>
              <description>Capture Rising Latch Register\nLatch the PWM counter when Channel 0/1/2/3 has rising transition.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CFLR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CFLR0</displayName>
          <description>PWM Group A Capture Falling Latch Register (Channel 0)\nPWM Group B Capture Falling Latch Register (Channel 0) \n(NuMicro( NUC100/NUC120 Medium Density Only)</description>
          <addressOffset>0x5C</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CFLRx</name>
              <description>Capture Falling Latch Register\nLatch the PWM counter when Channel 0/1/2/3 has Falling transition.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="CRLR0">
          <name>CRLR1</name>
          <displayName>CRLR1</displayName>
          <description>PWM Group A Capture Rising Latch Register (Channel 1)\nPWM Group B Capture Rising Latch Register (Channel 1) \n(NuMicro( NUC100/NUC120 Medium Density Only)</description>
          <addressOffset>0x60</addressOffset>
       </register>
       <register derivedFrom="CFLR0">
          <name>CFLR1</name>
          <displayName>CFLR1</displayName>
          <description>PWM Group A Capture Falling Latch Register (Channel 1)\nPWM Group B Capture Falling Latch Register (Channel 1) \n(NuMicro( NUC100/NUC120 Medium Density Only)</description>
          <addressOffset>0x64</addressOffset>
       </register>
       <register derivedFrom="CRLR0">
          <name>CRLR2</name>
          <displayName>CRLR2</displayName>
          <description>PWM Group A Capture Rising Latch Register (Channel 2)\nPWM Group B Capture Rising Latch Register (Channel 2) \n(NuMicro( NUC100/NUC120 Medium Density Only)</description>
          <addressOffset>0x68</addressOffset>
       </register>
       <register derivedFrom="CFLR0">
          <name>CFLR2</name>
          <displayName>CFLR2</displayName>
          <description>PWM Group A Capture Falling Latch Register (Channel 2)\nPWM Group B Capture Falling Latch Register (Channel 2) \n(NuMicro( NUC100/NUC120 Medium Density Only)</description>
          <addressOffset>0x6C</addressOffset>
       </register>
       <register derivedFrom="CRLR0">
          <name>CRLR3</name>
          <displayName>CRLR3</displayName>
          <description>PWM Group A Capture Rising Latch Register (Channel 3)\nPWM Group B Capture Rising Latch Register (Channel 3) \n(NuMicro( NUC100/NUC120 Medium Density Only)</description>
          <addressOffset>0x70</addressOffset>
       </register>
       <register derivedFrom="CFLR0">
          <name>CFLR3</name>
          <displayName>CFLR3</displayName>
          <description>PWM Group A Capture Falling Latch Register (Channel 3)\nPWM Group B Capture Falling Latch Register (Channel 3) \n(NuMicro( NUC100/NUC120 Medium Density Only)</description>
          <addressOffset>0x74</addressOffset>
       </register>
       <register>
          <name>CAPENR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CAPENR</displayName>
          <description>PWM Group A Capture Input 0~3 Enable Register\nPWM Group B Capture Input 0~3 Enable Register\n(NuMicro( NUC100/NUC120 Medium Density Only)</description>
          <addressOffset>0x78</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CINEN0</name>
              <description>Channel 0 Capture Input Enable\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM Channel 0 capture input path Disabled. The input of PWM channel 0 capture function is always regarded as 0</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PWM Channel 0 capture input path Enabled. The input of PWM channel 0 capture function comes from correlative multifunction pin if GPIO multi-function is set as PWM0</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CINEN1</name>
              <description>Channel 1 Capture Input Enable\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM Channel 1 capture input path Disabled. The input of PWM channel 1 capture function is always regarded as 0</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PWM Channel 1 capture input path Enabled. The input of PWM channel 1 capture function comes from correlative multifunction pin if GPIO multi-function is set as PWM1</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CINEN2</name>
              <description>Channel 2 Capture Input Enable\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM Channel 2 capture input path Disabled. The input of PWM channel 2 capture function is always regarded as 0</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PWM Channel 2 capture input path Enabled. The input of PWM channel 2 capture function comes from correlative multifunction pin if GPIO multi-function is set as PWM2</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CINEN3</name>
              <description>Channel 3 Capture Input Enable\n</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM Channel 3 capture input path Disabled. The input of PWM channel 3 capture function is always regarded as 0</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PWM Channel 3 capture input path Enabled. The input of PWM channel 3 capture function comes from correlative multifunction pin if GPIO multi-function is set as PWM3</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>POE</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>POE</displayName>
          <description>PWM Group A Output Enable for Channel 0~3\nPWM Group B Output Enable for Channel 0~3\n(NuMicro( NUC100/NUC120 Medium Density Only)</description>
          <addressOffset>0x7C</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>POE0</name>
              <description>Channel 0 Output Enable Register\nNote: The corresponding GPIO pin must also be switched to PWM function.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM channel 0 output to pin Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PWM channel 0 output to pin Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>POE1</name>
              <description>Channel 1 Output Enable Register\nNote: The corresponding GPIO pin must also be switched to PWM function.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM channel 1 output to pin Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PWM channel 1 output to pin Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>POE2</name>
              <description>Channel 2 Output Enable Register\nNote: The corresponding GPIO pin must also be switched to PWM function.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM channel 2 output to pin Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PWM channel 2 output to pin Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>POE3</name>
              <description>Channel 3 Output Enable Register\nNote: The corresponding GPIO pin must also be switched to PWM function.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM channel 3 output to pin Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PWM channel 3 output to pin Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>PWMB</name>
      <description>PWM Register Map</description>
      <groupName>PWM</groupName>
      <baseAddress>0x40140000</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x0</offset>
        <size>0x3C</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x40</offset>
        <size>0x8</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x50</offset>
        <size>0x30</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>PPR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PPR</displayName>
          <description>PWM Group A Prescaler Register\nPWM Group B Prescaler Register\n(NuMicro( NUC100/NUC120 Medium Density Only)</description>
          <addressOffset>0x0</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CP01</name>
              <description>Clock Prescaler 0  (PWM-timer 0 / 1 for group A and PWM-timer 4 / 5 for Group B)\nClock input is divided by (CP01 + 1) before it is fed to the corresponding PWM-timer\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CP23</name>
              <description>Clock Prescaler 2 (PWM-timer2 /3 for group A and PWM-timer 6 / 7 for Group B)\nClock input is divided by (CP23 + 1) before it is fed to the corresponding PWM-timer\n</description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DZI01</name>
              <description>Dead-zone Interval for Pair of Channel 0 and Channel 1 (PWM0 and PWM1 Pair for PWM group A, PWM4 and PWM5 pair for PWM group B)\nThese 8-bit determine the dead-zone length.\nThe unit time of dead-zone length is received from corresponding CSR bits.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DZI23</name>
              <description>Dead-zone Interval for Pair of Channel2 and Channel3 (PWM2 and PWM3 pair for PWM group A, PWM6 and PWM7 pair for PWM group B)\nThese 8-bit determine the dead-zone length.\nThe unit time of dead-zone length is received from corresponding CSR bits.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CSR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CSR</displayName>
          <description>PWM Group A Clock Source Divider Select Register\nPWM Group B Clock Source Divider Select Register\n(NuMicro( NUC100/NUC120 Medium Density Only)</description>
          <addressOffset>0x4</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CSR0</name>
              <description>PWM Timer 0 Clock Source Divider Selection (PWM timer 0 for group A and PWM timer 4 for group B)\nSelect clock source divider for PWM timer 0.\n(Table is the same as CSR3.)</description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CSR1</name>
              <description>PWM Timer 1 Clock Source Divider Selection (PWM timer 1 for group A and PWM timer 5 for group B)\nSelect clock source divider for PWM timer 1.\n(Table is the same as CSR3.)</description>
              <bitOffset>4</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CSR2</name>
              <description>PWM Timer 2 Clock Source Divider Selection (PWM timer 2 for group A and PWM timer 6 for group B)\nSelect clock source divider for PWM timer 2.\n(Table is the same as CSR3.)</description>
              <bitOffset>8</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CSR3</name>
              <description>PWM Timer 3 Clock Source Divider Selection (PWM timer 3 for group A and PWM timer 7 for group B)\n</description>
              <bitOffset>12</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PCR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PCR</displayName>
          <description>PWM Group A Control Register\nPWM Group B Control Register\n(NuMicro( NUC100/NUC120 Medium Density Only)</description>
          <addressOffset>0x8</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CH0EN</name>
              <description>PWM-Timer 0 Enable (PWM timer 0 for group A and PWM timer 4 for group B)\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Corresponding PWM-Timer Running Stopped</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Corresponding PWM-Timer Start Run Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CH0INV</name>
              <description>PWM-Timer 0 Output Inverter Enable (PWM timer 0 for group A and PWM timer 4 for group B)\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Inverter Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Inverter Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CH0MOD</name>
              <description>PWM-Timer 0 Auto-reload/One-Shot Mode (PWM Timer 0 for Group A and PWM Timer 4 for Group B)\nNote: If there is a transition at this bit, it will cause CNR0 and CMR0 be cleared.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>One-shot mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Auto-reload mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DZEN01</name>
              <description>Dead-Zone 0 Generator Enable (PWM0 and PWM1 Pair for PWM Group A, PWM4 and PWM5 Pair for PWM Group B)\nNote: When Dead-Zone Generator is enabled, the pair of PWM0 and PWM1 becomes a complementary pair for PWM group A and the pair of PWM4 and PWM5 becomes a complementary pair for PWM group B.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DZEN23</name>
              <description>Dead-Zone 2 Generator Enable (PWM2 and PWM3 Pair for PWM Group A, PWM6 and PWM7 Pair for PWM Group B)\nNote: When the Dead-Zone Generator is enabled, the pair of PWM2 and PWM3 becomes a complementary pair for PWM group A and the pair of PWM6 and PWM7 becomes a complementary pair for PWM group B.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CH1EN</name>
              <description>PWM-Timer 1 Enable (PWM Timer 1 for Group A and PWM Timer 5 for Group B)\n</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Corresponding PWM-Timer Running Stopped</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Corresponding PWM-Timer Start Run Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CH1INV</name>
              <description>PWM-Timer 1 Output Inverter Enable (PWM Timer 1 for Group A and PWM Timer 5 for Group B)\n</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Inverter Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Inverter Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CH1MOD</name>
              <description>PWM-Timer 1 Auto-reload/One-Shot Mode (PWM timer 1 for Group A and PWM timer 5 for Group B)\nNote: If there is a transition at this bit, it will cause CNR1 and CMR1 be cleared.</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>One-shot mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Auto-load mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CH2EN</name>
              <description>PWM-Timer 2 Enable (PWM timer 2 for group A and PWM timer 6 for Group B)\n</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>corresponding PWM-Timer Running Stopped</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>corresponding PWM-Timer Start Run Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CH2INV</name>
              <description>PWM-Timer 2 Output Inverter Enable (PWM timer 2 for group A and PWM timer 6 for group B)\n</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Inverter Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Inverter Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CH2MOD</name>
              <description>PWM-Timer 2 Auto-reload/One-Shot Mode (PWM timer 2 for group A and PWM timer 6 for group B)\nNote: If there is a transition at this bit, it will cause CNR2 and CMR2 be cleared.</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>One-shot mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Auto-reload mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CH3EN</name>
              <description>PWM-Timer 3 Enable (PWM timer 3 for group A and PWM timer 7 for group B)\n</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Corresponding PWM-Timer Running Stopped</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Corresponding PWM-Timer Start Run Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CH3INV</name>
              <description>PWM-Timer 3 Output Inverter Enable (PWM timer 3 for group A and PWM timer 7 for group B)\n</description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Inverter Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Inverter Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CH3MOD</name>
              <description>PWM-Timer 3 Auto-reload/One-Shot Mode (PWM timer 3 for group A and PWM timer 7 for group B)\nNote: If there is a transition at this bit, it will cause CNR3 and CMR3 be cleared.</description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>One-shot mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Auto-reload mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CNR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CNR0</displayName>
          <description>PWM Group A Counter Register 0\nPWM Group B Counter Register 0\n(NuMicro( NUC100/NUC120 Medium Density Only)</description>
          <addressOffset>0xC</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CNRx</name>
              <description>PWM Timer Loaded Value\nCNR determines the PWM period.\nNote: Any write to CNR will take effect in next PWM cycle.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CMR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CMR0</displayName>
          <description>PWM Group A Comparator Register 0\nPWM Group B Comparator Register 0\n(NuMicro( NUC100/NUC120 Medium Density Only)</description>
          <addressOffset>0x10</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CMRx</name>
              <description>PWM Comparator Register\nCMR determines the PWM duty.\nNote: Any write to CMR will take effect in next PWM cycle.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PDR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDR0</displayName>
          <description>PWM Group A Data Register 0\nPWM Group B Data Register 0\n(NuMicro( NUC100/NUC120 Medium Density Only)</description>
          <addressOffset>0x14</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDRx</name>
              <description>PWM Data Register\nUser can monitor PDR to know the current value in 16-bit down counter.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="CNR0">
          <name>CNR1</name>
          <displayName>CNR1</displayName>
          <description>PWM Group A Counter Register 1\nPWM Group B Counter Register 1\n(NuMicro( NUC100/NUC120 Medium Density Only)</description>
          <addressOffset>0x18</addressOffset>
       </register>
       <register derivedFrom="CMR0">
          <name>CMR1</name>
          <displayName>CMR1</displayName>
          <description>PWM Group A Comparator Register 1\nPWM Group B Comparator Register 1\n(NuMicro( NUC100/NUC120 Medium Density Only)</description>
          <addressOffset>0x1C</addressOffset>
       </register>
       <register derivedFrom="PDR0">
          <name>PDR1</name>
          <displayName>PDR1</displayName>
          <description>PWM Group A Data Register 1\nPWM Group B Data Register 1\n(NuMicro( NUC100/NUC120 Medium Density Only)</description>
          <addressOffset>0x20</addressOffset>
       </register>
       <register derivedFrom="CNR0">
          <name>CNR2</name>
          <displayName>CNR2</displayName>
          <description>PWM Group A Counter Register 2\nPWM Group B Counter Register 2\n(NuMicro( NUC100/NUC120 Medium Density Only)</description>
          <addressOffset>0x24</addressOffset>
       </register>
       <register derivedFrom="CMR0">
          <name>CMR2</name>
          <displayName>CMR2</displayName>
          <description>PWM Group A Comparator Register 2\nPWM Group B Comparator Register 2\n(NuMicro( NUC100/NUC120 Medium Density Only)</description>
          <addressOffset>0x28</addressOffset>
       </register>
       <register derivedFrom="PDR0">
          <name>PDR2</name>
          <displayName>PDR2</displayName>
          <description>PWM Group A Data Register 2\nPWM Group B Data Register 2\n(NuMicro( NUC100/NUC120 Medium Density Only)</description>
          <addressOffset>0x2C</addressOffset>
       </register>
       <register derivedFrom="CNR0">
          <name>CNR3</name>
          <displayName>CNR3</displayName>
          <description>PWM Group A Counter Register 3\nPWM Group B Counter Register 3\n(NuMicro( NUC100/NUC120 Medium Density Only)</description>
          <addressOffset>0x30</addressOffset>
       </register>
       <register derivedFrom="CMR0">
          <name>CMR3</name>
          <displayName>CMR3</displayName>
          <description>PWM Group A Comparator Register 3\nPWM Group B Comparator Register 3\n(NuMicro( NUC100/NUC120 Medium Density Only)</description>
          <addressOffset>0x34</addressOffset>
       </register>
       <register derivedFrom="PDR0">
          <name>PDR3</name>
          <displayName>PDR3</displayName>
          <description>PWM Group A Data Register 3\nPWM Group B Data Register 3\n(NuMicro( NUC100/NUC120 Medium Density Only)</description>
          <addressOffset>0x38</addressOffset>
       </register>
       <register>
          <name>PIER</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PIER</displayName>
          <description>PWM Group A Interrupt Enable Register\nPWM Group B Interrupt Enable Register\n(NuMicro( NUC100/NUC120 Medium Density Only)</description>
          <addressOffset>0x40</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PWMIE0</name>
              <description>PWM channel 0 Interrupt Enable\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PWMIE1</name>
              <description>PWM channel 1 Interrupt Enable\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PWMIE2</name>
              <description>PWM channel 2 Interrupt Enable\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PWMIE3</name>
              <description>PWM channel 3 Interrupt Enable\n</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PIIR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PIIR</displayName>
          <description>PWM Group A Interrupt Indication Register\nPWM Group B Interrupt Indication Register\n(NuMicro( NUC100/NUC120 Medium Density Only)</description>
          <addressOffset>0x44</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PWMIF0</name>
              <description>PWM channel 0 Interrupt Status\nThis bit is set by hardware when PWM0 down counter reaches zero if PWM3 interrupt enable bit (PWMIE0) is 1, software can write 1 to clear this bit to zero</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PWMIF1</name>
              <description>PWM channel 1 Interrupt Status\nThis bit is set by hardware when PWM1 down counter reaches zero if PWM3 interrupt enable bit (PWMIE1) is 1, software can write 1 to clear this bit to zero</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PWMIF2</name>
              <description>PWM channel 2 Interrupt Status\nThis bit is set by hardware when PWM2 down counter reaches zero if PWM3 interrupt enable bit (PWMIE2) is 1, software can write 1 to clear this bit to zero</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PWMIF3</name>
              <description>PWM channel 3 Interrupt Status\nThis bit is set by hardware when PWM3 down counter reaches zero if PWM3 interrupt enable bit (PWMIE3) is 1, software can write 1 to clear this bit to zero</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CCR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CCR0</displayName>
          <description>PWM Group A Capture Control Register 0\nPWM Group B Capture Control Register 0\n(NuMicro( NUC100/NUC120 Medium Density Only)</description>
          <addressOffset>0x50</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>INV0</name>
              <description>Channel 0 Inverter Enable\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Inverter Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Inverter Enabled. Reverse the input signal from GPIO before fed to Capture timer</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CRL_IE0</name>
              <description>Channel 0 Rising Latch Interrupt Enable\nWhen Enabled, if Capture detects PWM group channel 0 has rising transition, Capture will issue an Interrupt.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Rising latch interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Rising latch interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CFL_IE0</name>
              <description>Channel 0 Falling Latch Interrupt Enable\nWhen Enabled, if Capture detects PWM group channel 0 has falling transition, Capture will issue an Interrupt.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Falling latch interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Falling latch interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CAPCH0EN</name>
              <description>Channel 0 Capture Function Enable\nWhen Enabled, Capture latched the PWM-counter value and saved to CRLR (Rising latch) and CFLR (Falling latch).\nWhen Disabled, Capture does not update CRLR and CFLR, and disable PWM group channel 0 Interrupt.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Capture function on PWM group channel 0 Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Capture function on PWM group channel 0 Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CAPIF0</name>
              <description>Channel 0 Capture Interrupt Indication Flag\nWrite 1 to clear this bit to zero</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CRLRI0</name>
              <description>CRLR0 Latched Indicator Bit\nWhen PWM group input channel 0 has a rising transition, CRLR0 was latched with the value of PWM down-counter and this bit is set by hardware.\nIn NuMicro( NUC100/NUC120 Medium Density, software can write 0 to clear this bit to zero.\nIn NuMicro( NUC100/NUC120 Low Density, software can write 0 to clear this bit to zero if BCn bit is 0, and can Write 1 to clear this bit to zero if BCn bit is 1.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CFLRI0</name>
              <description>CFLR0 Latched Indicator Bit\nWhen PWM group input channel 0 has a falling transition, CFLR0 was latched with the value of PWM down-counter and this bit is set by hardware.\nIn NuMicro( NUC100/NUC120 Medium Density, software can write 0 to clear this bit to zero.\nIn NuMicro( NUC100/NUC120 Low Density, software can write 0 to clear this bit to zero if BCn bit is 0, and can Write 1 to clear this bit to zero if BCn bit is 1.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>INV1</name>
              <description>Channel 1 Inverter Enable\n</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Inverter Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Inverter Enabled. Reverse the input signal from GPIO before fed to Capture timer</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CRL_IE1</name>
              <description>Channel 1 Rising Latch Interrupt Enable\nWhen Enabled, if Capture detects PWM group channel 1 has rising transition, Capture will issue an Interrupt.</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Rising latch interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Rising latch interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CFL_IE1</name>
              <description>Channel 1 Falling Latch Interrupt Enable\nWhen Enabled, if Capture detects PWM group channel 1 has falling transition, Capture will issue an Interrupt.</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Falling latch interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Falling latch interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CAPCH1EN</name>
              <description>Channel 1 Capture Function Enable\nWhen Enabled, Capture latched the PWM-counter and saved to CRLR (Rising latch) and CFLR (Falling latch).\nWhen Disabled, Capture does not update CRLR and CFLR, and disable PWM group channel 1 Interrupt.</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Capture function on PWM group channel 1 Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Capture function on PWM group channel 1 Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CAPIF1</name>
              <description>Channel 1 Capture Interrupt Indication Flag\nWrite 1 to clear this bit to zero</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CRLRI1</name>
              <description>CRLR1 Latched Indicator Bit\nWhen PWM group input channel 1 has a rising transition, CRLR1 was latched with the value of PWM down-counter and this bit is set by hardware.\nIn NuMicro( NUC100/NUC120 Medium Density, software can write 0 to clear this bit to zero.\nIn NuMicro( NUC100/NUC120 Low Density, software can write 0 to clear this bit to zero if BCn bit is 0, and can Write 1 to clear this bit to zero if BCn bit is 1.</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CFLRI1</name>
              <description>CFLR1 Latched Indicator Bit\nWhen PWM group input channel 1 has a falling transition, CFLR1 was latched with the value of PWM down-counter and this bit is set by hardware.\nIn NuMicro( NUC100/NUC120 Medium Density, software can write 0 to clear this bit to zero.\nIn NuMicro( NUC100/NUC120 Low Density, software can write 0 to clear this bit to zero if BCn bit is 0, and can Write 1 to clear this bit to zero if BCn bit is 1.</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CCR2</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CCR2</displayName>
          <description>PWM Group A Capture Control Register 2\nPWM Group B Capture Control Register 2\n(NuMicro( NUC100/NUC120 Medium Density Only)</description>
          <addressOffset>0x54</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>INV2</name>
              <description>Channel 2 Inverter Enable\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Inverter Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Inverter Enabled. Reverse the input signal from GPIO before fed to Capture timer</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CRL_IE2</name>
              <description>Channel 2 Rising Latch Interrupt Enable\nWhen Enabled, if Capture detects PWM group channel 2 has rising transition, Capture will issue an Interrupt.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Rising latch interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Rising latch interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CFL_IE2</name>
              <description>Channel 2 Falling Latch Interrupt Enable\nWhen Enabled, if Capture detects PWM group channel 2 has falling transition, Capture will issue an Interrupt.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Falling latch interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Falling latch interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CAPCH2EN</name>
              <description>Channel 2 Capture Function Enable\nWhen Enabled, Capture latched the PWM-counter value and saved to CRLR (Rising latch) and CFLR (Falling latch).\nWhen Disabled, Capture does not update CRLR and CFLR, and disable PWM group channel 2 Interrupt.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Capture function on PWM group channel 2 Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Capture function on PWM group channel 2 Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CAPIF2</name>
              <description>Channel 2 Capture Interrupt Indication Flag\nWrite 1 to clear this bit to zero</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CRLRI2</name>
              <description>CRLR2 Latched Indicator Bit\nWhen PWM group input channel 2 has a rising transition, CRLR2 was latched with the value of PWM down-counter and this bit is set by hardware.\nIn NuMicro( NUC100/NUC120 Medium Density, software can write 0 to clear this bit to zero.\nIn NuMicro( NUC100/NUC120 Low Density, software can write 0 to clear this bit to zero if BCn bit is 0, and can Write 1 to clear this bit to zero if BCn bit is 1.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CFLRI2</name>
              <description>CFLR2 Latched Indicator Bit\nWhen PWM group input channel 2 has a falling transition, CFLR2 was latched with the value of PWM down-counter and this bit is set by hardware.\nIn NuMicro( NUC100/NUC120 Medium Density, software can write 0 to clear this bit to zero.\nIn NuMicro( NUC100/NUC120 Low Density, software can write 0 to clear this bit to zero if BCn bit is 0, and can Write 1 to clear this bit to zero if BCn bit is 1.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>INV3</name>
              <description>Channel 3 Inverter Enable\n</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Inverter Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Inverter Enabled. Reverse the input signal from GPIO before fed to Capture timer</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CRL_IE3</name>
              <description>Channel 3 Rising Latch Interrupt Enable\nWhen Enabled, if Capture detects PWM group channel 3 has rising transition, Capture will issue an Interrupt.</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Rising latch interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Rising latch interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CFL_IE3</name>
              <description>Channel 3 Falling Latch Interrupt Enable\nWhen Enabled, if Capture detects PWM group channel 3 has falling transition, Capture will issue an Interrupt.</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Falling latch interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Falling latch interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CAPCH3EN</name>
              <description>Channel 3 Capture Function Enable\nWhen Enabled, Capture latched the PWM-counter and saved to CRLR (Rising latch) and CFLR (Falling latch).\nWhen Disabled, Capture does not update CRLR and CFLR, and disable PWM group channel 3 Interrupt.</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Capture function on PWM group channel 3 Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Capture function on PWM group channel 3 Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CAPIF3</name>
              <description>Channel 3 Capture Interrupt Indication Flag\nWrite 1 to clear this bit to 0.</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CRLRI3</name>
              <description>CRLR3 Latched Indicator Bit\nWhen PWM group input channel 3 has a rising transition, CRLR3 was latched with the value of PWM down-counter and this bit is set by hardware.\nIn NuMicro( NUC100/NUC120 Medium Density, software can write 0 to clear this bit to zero.\nIn NuMicro( NUC100/NUC120 Low Density, software can write 0 to clear this bit to zero if BCn bit is 0, and can write 1 to clear this bit to zero if BCn bit is 1.</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CFLRI3</name>
              <description>CFLR3 Latched Indicator Bit\nWhen PWM group input channel 3 has a falling transition, CFLR3 was latched with the value of PWM down-counter and this bit is set by hardware.\nIn NuMicro( NUC100/NUC120 Medium Density, software can write 0 to clear this bit to zero.\nIn NuMicro( NUC100/NUC120 Low Density, software can write 0 to clear this bit to zero if BCn bit is 0, and can Write 1 to clear this bit to zero if BCn bit is 1.</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CRLR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CRLR0</displayName>
          <description>PWM Group A Capture Rising Latch Register (Channel 0)\nPWM Group B Capture Rising Latch Register (Channel 0) \n(NuMicro( NUC100/NUC120 Medium Density Only)</description>
          <addressOffset>0x58</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CRLRx</name>
              <description>Capture Rising Latch Register\nLatch the PWM counter when Channel 0/1/2/3 has rising transition.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CFLR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CFLR0</displayName>
          <description>PWM Group A Capture Falling Latch Register (Channel 0)\nPWM Group B Capture Falling Latch Register (Channel 0) \n(NuMicro( NUC100/NUC120 Medium Density Only)</description>
          <addressOffset>0x5C</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CFLRx</name>
              <description>Capture Falling Latch Register\nLatch the PWM counter when Channel 0/1/2/3 has Falling transition.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="CRLR0">
          <name>CRLR1</name>
          <displayName>CRLR1</displayName>
          <description>PWM Group A Capture Rising Latch Register (Channel 1)\nPWM Group B Capture Rising Latch Register (Channel 1) \n(NuMicro( NUC100/NUC120 Medium Density Only)</description>
          <addressOffset>0x60</addressOffset>
       </register>
       <register derivedFrom="CFLR0">
          <name>CFLR1</name>
          <displayName>CFLR1</displayName>
          <description>PWM Group A Capture Falling Latch Register (Channel 1)\nPWM Group B Capture Falling Latch Register (Channel 1) \n(NuMicro( NUC100/NUC120 Medium Density Only)</description>
          <addressOffset>0x64</addressOffset>
       </register>
       <register derivedFrom="CRLR0">
          <name>CRLR2</name>
          <displayName>CRLR2</displayName>
          <description>PWM Group A Capture Rising Latch Register (Channel 2)\nPWM Group B Capture Rising Latch Register (Channel 2) \n(NuMicro( NUC100/NUC120 Medium Density Only)</description>
          <addressOffset>0x68</addressOffset>
       </register>
       <register derivedFrom="CFLR0">
          <name>CFLR2</name>
          <displayName>CFLR2</displayName>
          <description>PWM Group A Capture Falling Latch Register (Channel 2)\nPWM Group B Capture Falling Latch Register (Channel 2) \n(NuMicro( NUC100/NUC120 Medium Density Only)</description>
          <addressOffset>0x6C</addressOffset>
       </register>
       <register derivedFrom="CRLR0">
          <name>CRLR3</name>
          <displayName>CRLR3</displayName>
          <description>PWM Group A Capture Rising Latch Register (Channel 3)\nPWM Group B Capture Rising Latch Register (Channel 3) \n(NuMicro( NUC100/NUC120 Medium Density Only)</description>
          <addressOffset>0x70</addressOffset>
       </register>
       <register derivedFrom="CFLR0">
          <name>CFLR3</name>
          <displayName>CFLR3</displayName>
          <description>PWM Group A Capture Falling Latch Register (Channel 3)\nPWM Group B Capture Falling Latch Register (Channel 3) \n(NuMicro( NUC100/NUC120 Medium Density Only)</description>
          <addressOffset>0x74</addressOffset>
       </register>
       <register>
          <name>CAPENR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CAPENR</displayName>
          <description>PWM Group A Capture Input 0~3 Enable Register\nPWM Group B Capture Input 0~3 Enable Register\n(NuMicro( NUC100/NUC120 Medium Density Only)</description>
          <addressOffset>0x78</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CINEN0</name>
              <description>Channel 0 Capture Input Enable\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM Channel 0 capture input path Disabled. The input of PWM channel 0 capture function is always regarded as 0</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PWM Channel 0 capture input path Enabled. The input of PWM channel 0 capture function comes from correlative multifunction pin if GPIO multi-function is set as PWM0</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CINEN1</name>
              <description>Channel 1 Capture Input Enable\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM Channel 1 capture input path Disabled. The input of PWM channel 1 capture function is always regarded as 0</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PWM Channel 1 capture input path Enabled. The input of PWM channel 1 capture function comes from correlative multifunction pin if GPIO multi-function is set as PWM1</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CINEN2</name>
              <description>Channel 2 Capture Input Enable\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM Channel 2 capture input path Disabled. The input of PWM channel 2 capture function is always regarded as 0</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PWM Channel 2 capture input path Enabled. The input of PWM channel 2 capture function comes from correlative multifunction pin if GPIO multi-function is set as PWM2</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CINEN3</name>
              <description>Channel 3 Capture Input Enable\n</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM Channel 3 capture input path Disabled. The input of PWM channel 3 capture function is always regarded as 0</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PWM Channel 3 capture input path Enabled. The input of PWM channel 3 capture function comes from correlative multifunction pin if GPIO multi-function is set as PWM3</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>POE</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>POE</displayName>
          <description>PWM Group A Output Enable for Channel 0~3\nPWM Group B Output Enable for Channel 0~3\n(NuMicro( NUC100/NUC120 Medium Density Only)</description>
          <addressOffset>0x7C</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>POE0</name>
              <description>Channel 0 Output Enable Register\nNote: The corresponding GPIO pin must also be switched to PWM function.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM channel 0 output to pin Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PWM channel 0 output to pin Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>POE1</name>
              <description>Channel 1 Output Enable Register\nNote: The corresponding GPIO pin must also be switched to PWM function.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM channel 1 output to pin Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PWM channel 1 output to pin Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>POE2</name>
              <description>Channel 2 Output Enable Register\nNote: The corresponding GPIO pin must also be switched to PWM function.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM channel 2 output to pin Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PWM channel 2 output to pin Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>POE3</name>
              <description>Channel 3 Output Enable Register\nNote: The corresponding GPIO pin must also be switched to PWM function.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM channel 3 output to pin Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PWM channel 3 output to pin Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>RTC</name>
      <description>RTC Register Map</description>
      <groupName>RTC</groupName>
      <baseAddress>0x40008000</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x0</offset>
        <size>0x34</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>INIR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>INIR</displayName>
          <description>RTC Initiation Register</description>
          <addressOffset>0x0</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>INIR</name>
              <description>RTC Initiation (Write only)\nWhen RTC block is powered on, RTC is at reset state. User has to write a number (0x a5eb1357) to INIR to make RTC leaving reset state. Once the INIR is written as 0xa5eb1357, the RTC will be in un-reset state permanently.\nThe INIR is a write-only field and read value will be always "0".\nRTC Active Status (Read only)\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RTC is at reset state</description>
                    <value>0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RTC is at normal active state</description>
                    <value>1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>write-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>AER</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>AER</displayName>
          <description>RTC Access Enable Register</description>
          <addressOffset>0x4</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>AER</name>
              <description>RTC Register Access Enable Password (Write Only)\nWriting 0xA965 to this register will enable RTC access and keep 1024 RTC clock</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>ENF</name>
              <description>RTC Register Access Enable Flag (Read only)\n</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RTC register read/write Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RTC register read/write Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>FCR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>FCR</displayName>
          <description>RTC Frequency Compensation Register</description>
          <addressOffset>0x8</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000700</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>FRACTION</name>
              <description>Fraction Part\nNote: Digit in FCR must be expressed as hexadecimal number. Refer to 5.8.4.4 for the examples.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>INTEGER</name>
              <description>Integer Part\n</description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>TLR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>TLR</displayName>
          <description>Time Loading Register</description>
          <addressOffset>0xC</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>_1SEC</name>
              <description>1-Sec Time Digit (0~9)</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>_10SEC</name>
              <description>10-Sec Time Digit (0~5)</description>
              <bitOffset>4</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>_1MIN</name>
              <description>1-Min Time Digit (0~9)</description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>_10MIN</name>
              <description>10-Min Time Digit (0~5)</description>
              <bitOffset>12</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>_1HR</name>
              <description>1-Hour Time Digit (0~9)</description>
              <bitOffset>16</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>_10HR</name>
              <description>10-Hour Time Digit (0~2)</description>
              <bitOffset>20</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CLR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CLR</displayName>
          <description>Calendar Loading Register</description>
          <addressOffset>0x10</addressOffset>
          <access>read-write</access>
          <resetValue>0x00050101</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>_1DAY</name>
              <description>1-Day Calendar Digit (0~9)</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>_10DAY</name>
              <description>10-Day Calendar Digit (0~3)</description>
              <bitOffset>4</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>_1MON</name>
              <description>1-Month Calendar Digit (0~9)</description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>_10MON</name>
              <description>10-Month Calendar Digit (0~1)</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>_1YEAR</name>
              <description>1-Year Calendar Digit (0~9)</description>
              <bitOffset>16</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>_10YEAR</name>
              <description>10-Year Calendar Digit (0~9)</description>
              <bitOffset>20</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>TSSR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>TSSR</displayName>
          <description>Time Scale Selection Register</description>
          <addressOffset>0x14</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000001</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>_24H_12H</name>
              <description>24-Hour / 12-Hour Time Scale Selection\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Selected as 12-hour time scale with AM and PM indication</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Selected as 24-hour time scale</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>DWR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>DWR</displayName>
          <description>Day of the Week Register</description>
          <addressOffset>0x18</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000006</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DWR</name>
              <description>Day of the Week Register \n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>TAR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>TAR</displayName>
          <description>Time Alarm Register</description>
          <addressOffset>0x1C</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>_1SEC</name>
              <description>1-Sec Time Digit of Alarm Setting (0~9)</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>_10SEC</name>
              <description>10-Sec Time Digit of Alarm Setting (0~5)</description>
              <bitOffset>4</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>_1MIN</name>
              <description>1-Min Time Digit of Alarm Setting (0~9)</description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>_10MIN</name>
              <description>10-Min Time Digit of Alarm Setting (0~5)</description>
              <bitOffset>12</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>_1HR</name>
              <description>1-Hour Time Digit of Alarm Setting (0~9)</description>
              <bitOffset>16</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>_10HR</name>
              <description>10-Hour Time Digit of Alarm Setting (0~2)</description>
              <bitOffset>20</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CAR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CAR</displayName>
          <description>Calendar Alarm Register</description>
          <addressOffset>0x20</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>_1DAY</name>
              <description>1-Day Calendar Digit of Alarm Setting (0~9)</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>_10DAY</name>
              <description>10-Day Calendar Digit of Alarm Setting (0~3)</description>
              <bitOffset>4</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>_1MON</name>
              <description>1-Month Calendar Digit of Alarm Setting (0~9)</description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>_10MON</name>
              <description>10-Month Calendar Digit of Alarm Setting (0~1)</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>_1YEAR</name>
              <description>1-Year Calendar Digit of Alarm Setting (0~9)</description>
              <bitOffset>16</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>_10YEAR</name>
              <description>10-Year Calendar Digit of Alarm Setting (0~9)</description>
              <bitOffset>20</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>LIR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>LIR</displayName>
          <description>Leap Year Indicator Register</description>
          <addressOffset>0x24</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>LIR</name>
              <description>Leap Year Indication Register (Read Only)\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>This year is not a leap year</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>This year is leap year</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>RIER</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>RIER</displayName>
          <description>RTC Interrupt Enable Register</description>
          <addressOffset>0x28</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>AIER</name>
              <description>Alarm Interrupt Enable\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RTC Alarm Interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RTC Alarm Interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TIER</name>
              <description>Time Tick Interrupt Enable\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RTC Time Tick Interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RTC Time Tick Interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>RIIR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>RIIR</displayName>
          <description>RTC Interrupt Indicator Register</description>
          <addressOffset>0x2C</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>AIF</name>
              <description>RTC Alarm Interrupt Flag\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RCT Alarm Interrupt condition never occurred</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RTC Alarm Interrupt is requested if RIER.AIER = 1</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TIF</name>
              <description>RTC Time Tick Interrupt Flag\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RCT Time Tick Interrupt condition never occurred</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RTC Time Tick Interrupt is requested if RIER.TIER = 1</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>TTR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>TTR</displayName>
          <description>RTC Time Tick Register</description>
          <addressOffset>0x30</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TTR</name>
              <description>Time Tick Register\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TWKE</name>
              <description>RTC Timer Wake-up Function Enable\nIf TWKE is set before chip is in Power-down mode, chip will be woken up by RTC controller when a RTC Time Tick occurs.\nNote1: Tick timer setting follows the TTR[2:0] description.\nNote2: When Alarm Match occurs, chip will be woken up from Power-down mode no matter TWKE is 1 or 0.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RTC Timer wake-up Disabled by Timer Tick occur function</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RTC Timer wake-up function Enabled so that chip can be woken up from Power-down mode by Time Tick</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>SPI0</name>
      <description>SPI Register Map</description>
      <groupName>SPI</groupName>
      <baseAddress>0x40030000</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x0</offset>
        <size>0xC</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x10</offset>
        <size>0x8</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x20</offset>
        <size>0x8</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x34</offset>
        <size>0x8</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>SPI_CNTRL</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SPI_CNTRL</displayName>
          <description>Control and Status Register</description>
          <addressOffset>0x0</addressOffset>
          <access>read-write</access>
          <resetValue>0x05000004</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>GO_BUSY</name>
              <description>Go and Busy Status\nDuring the data transfer, this bit keeps the value of 1. As the transfer is finished, this bit will be cleared automatically.\nNote: All registers should be set before writing 1 to this GO_BUSY bit.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Stop data transfer if SPI is transferring</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>In Master mode, start the SPI data transfer; in Slave mode, writing 1 to this bit indicates that the slave is ready to communicate with a master</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_NEG</name>
              <description>Receive At Negative Edge\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Received data input signal is latched at the rising edge of SPICLK</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Received data input signal is latched at the falling edge of SPICLK</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_NEG</name>
              <description>Transmit At Negative Edge\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Transmitted data output signal is changed at the rising edge of SPICLK</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Transmitted data output signal is changed at the falling edge of SPICLK</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_BIT_LEN</name>
              <description>Transmit Bit Length\nThis field specifies how many bits can be transmitted / received in one transaction. The minimum bit length is 8 bits and can up to 32 bits.\n</description>
              <bitOffset>3</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_NUM</name>
              <description>Numbers of Transmit/Receive Word\nThis field specifies how many transmit/receive word numbers should be executed in one transfer.\nNote: In Slave mode with level-trigger configuration, if TX_NUM is set to 01, the slave select pin must be kept at active state during the successive data transfer.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Only one transmit/receive word will be executed in one transfer</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Two successive transmit/receive words will be executed in one transfer. (burst mode)</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Reserved</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Reserved</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>LSB</name>
              <description>LSB First\n</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>MSB is transmitted/received first (which bit in SPI_TX0/1 and SPI_RX0/1 register that is depends on the TX_BIT_LEN field)</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>LSB is sent first on the line (bit 0 of SPI_TX0/1), and the first bit received from the line will be put in the LSB position in the RX register (bit 0 of SPI_RX0/1)</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CLKP</name>
              <description>Clock Polarity\n</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>SPICLK idle low</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>SPICLK idle high</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SP_CYCLE</name>
              <description>Suspend Interval (Master Only)\n</description>
              <bitOffset>12</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>IF</name>
              <description>Interrupt Flag\nNote: This bit will be cleared by writing 1 to itself.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Indicates the transfer dose not finish</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Indicates the transfer is done</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IE</name>
              <description>Interrupt Enable\n</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>SPI Interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>SPI Interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SLAVE</name>
              <description>Slave Mode Enable Bit\n</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Master mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Slave mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>REORDER</name>
              <description>Reorder Mode Select\nNote:\nByte reorder function is only available when TX_BIT_LEN is defined as 16, 24, and 32 bits.\nIn Slave mode with level-trigger configuration, if the byte suspend function is enabled, the slave select pin must be kept at active state during the successive four bytes transfer.</description>
              <bitOffset>19</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Both byte reorder and byte suspend functions Disabled</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Byte reorder function Enabled, and a byte suspend interval (2~17 SPICLK cycles) inserted among each byte. The setting of TX_BIT_LEN must be configured as 0x00. (32 bits/word)</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Byte reorder function Enabled, but byte suspend function Disabled</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Byte reorder function Disabled, but a suspend interval (2~17 SPICLK cycles) inserted among each byte. The setting of TX_BIT_LEN must be configured as 0x00. (32 bits/word)</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TWOB</name>
              <description>Two Bits Transfer Mode Active\nNote: When TWOB is enabled, the serial transmitted 2-bit data output are from SPI_TX1/0, and the received 2-bit data input are put in SPI_RX1/0.\nNote: When TWOB is enabled, the setting of TX_NUM must be programmed as 0x00.</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Two-bit Transfer mode Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Two-bit Transfer mode Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>VARCLK_EN</name>
              <description>Variable Clock Enable (Master Only)\nNote: When this VARCLK_EN bit is enabled, the setting of TX_BIT_LEN must be programmed as 0x10 (16-bit mode)</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Serial clock output frequency is fixed and decided only by the value of DIVIDER</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Serial clock output frequency is variable. The output frequency is decided by the value of VARCLK, DIVIDER, and DIVIDER2</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SPI_DIVIDER</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SPI_DIVIDER</displayName>
          <description>Clock Divider Register (Master Only)</description>
          <addressOffset>0x4</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DIVIDER</name>
              <description>Clock Divider 1 (Master Only)\nThe value in this field is the frequency divider for generating the serial clock on the output SPICLK. The desired frequency is obtained according to the following equation:\n\nIn Slave mode, the period of SPI clock driven by a master shall equal or over 5 times the period of PCLK. In other words, the maximum frequency of SPI clock is the fifth of the frequency of slave's PCLK.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DIVIDER2</name>
              <description>Clock Divider 2 (Master Only)\nThe value in this field is the 2nd frequency divider for generating the serial clock on the output SPICLK. The desired frequency is obtained according to the following equation:\n\nIf VARCLK_EN is cleared to 0, this setting is unmeaning.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SPI_SSR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SPI_SSR</displayName>
          <description>Slave Select Register</description>
          <addressOffset>0x8</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SSR</name>
              <description>Slave Select Control Bits (Master only)\nIf AUTOSS bit is cleared, writing 1 to any bit location of this field sets the proper SPISSx0/1 line to an active state and writing 0 sets the line back to inactive state.\nIf AUTOSS bit is set, writing 0 to any bit location of this field will keep the corresponding SPISSx0/1 line at inactive state; writing 1 to any bit location of this field will select appropriate SPISSx0/1 line to be automatically driven to active state for the duration of the transmit/receive, and will be driven to inactive state for the rest of the time. The active state of SPISSx0/1 is specified in SS_LVL. \nNote: SPISSx0 is also defined as slave select input in Slave mode.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SS_LVL</name>
              <description>Slave Select Active Level\nIt defines the active status of slave select signal (SPISSx0/1).\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Slave select signal SPISSx0/1 is active at low-level/falling-edge</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Slave select signal SPISSx0/1 is active at high-level/rising-edge</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>AUTOSS</name>
              <description>Automatic Slave Select Enable Bit (Master only)\n</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>If this bit is cleared, slave select signals will be asserted/de-asserted by setting /clearing related bits in SSR[1:0]</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>If this bit is set, SPISSx0/1 signals will be generated automatically. It means that device/slave select signal, which is set in SSR[1:0], will be asserted by the SPI controller when transmit/receive is started by setting GO_BUSY, and will be de-asserted after each transmit/receive is finished</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SS_LTRIG</name>
              <description>Slave Select Level Trigger Enable Bit (Slave only)\n</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Input slave select signal is edge-trigger. This is the default value. It depends on SS_LVL to decide the signal is active at falling-edge or rising-edge</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Slave select signal will be level-trigger. It depends on SS_LVL to decide the signal is active low or active high</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>LTRIG_FLAG</name>
              <description>Level Trigger Accomplish Flag\nWhen the SS_LTRIG bit is set in Slave mode, this bit can be read to indicate the received bit number is met the requirement or not.\nNote: This bit is READ only.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Transaction number or the transferred bit length of one transaction does not meet the specified requirements</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Transaction number and the transferred bit length met the specified requirements which defined in TX_NUM and TX_BIT_LEN</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SPI_RX0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SPI_RX0</displayName>
          <description>Data Receive Register 0</description>
          <addressOffset>0x10</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RX</name>
              <description>Data Receive Register\nThe Data Receive Registers hold the value of received data of the last executed transfer. Valid bits depend on the transmit bit length field in the SPI_CNTRL register.\nFor example, if TX_BIT_LEN is set to 0x08 and TX_NUM is set to 0x0, bit RX0[7:0] holds the received data. The values of the other bits are unknown.\nNote: The Data Receive Registers are read only.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="SPI_RX0">
          <name>SPI_RX1</name>
          <displayName>SPI_RX1</displayName>
          <description>Data Receive Register 1</description>
          <addressOffset>0x14</addressOffset>
       </register>
       <register>
          <name>SPI_TX0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SPI_TX0</displayName>
          <description>Data Transmit Register 0</description>
          <addressOffset>0x20</addressOffset>
          <access>write-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TX</name>
              <description>Data Transmit Register\nThe Data Transmit Registers hold the data to be transmitted in the next transfer. The valid bits depend on the transmit bit length field in the CNTRL register.\nFor example, if TX_BIT_LEN is set to 0x08 and the TX_NUM is set to 0x0, the bit TX0[7:0] will be transmitted in next transfer. If TX_BIT_LEN is set to 0x00 and TX_NUM is set to 0x1, the SPI controller will perform two 32-bit transmit/receive successive using the same setting. The transmission sequence is TX0[31:0] first and then TX1[31:0].</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="SPI_TX0">
          <name>SPI_TX1</name>
          <displayName>SPI_TX1</displayName>
          <description>Data Transmit Register 1</description>
          <addressOffset>0x24</addressOffset>
       </register>
       <register>
          <name>SPI_VARCLK</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SPI_VARCLK</displayName>
          <description>Variable Clock Pattern Register</description>
          <addressOffset>0x34</addressOffset>
          <access>read-write</access>
          <resetValue>0x007FFF87</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>VARCLK</name>
              <description>Variable Clock Pattern\nThe value in this field is the frequency patterns of the SPI clock. If the bit pattern of VARCLK is '0', the output frequency of SPICLK is in accordance with the value of DIVIDER. If the bit patterns of VARCLK are '1', the output frequency of SPICLK is in accordance with the value of DIVIDER2. Refer to register SPI_DIVIDER.\nRefer to the Variable Serial Clock Frequency paragraph for more detailed description.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SPI_DMA</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SPI_DMA</displayName>
          <description>SPI DMA Control Register</description>
          <addressOffset>0x38</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TX_DMA_GO</name>
              <description>Transmit DMA Start\nSetting this bit to 1 will start the transmit PDMA process. SPI controller will issue request to PDMA controller automatically.\nIf using PDMA mode to transfer data, remember not to set GO_BUSY bit of SPI_CNTRL register. The DMA controller inside SPI controller will set it automatically whenever necessary.\nHardware will clear this bit to 0 automatically after PDMA transfer done.\nNote: In DMA mode, the burst mode is not supported.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_DMA_GO</name>
              <description>Receive DMA Start\nSetting this bit to 1 will start the receive PDMA process. SPI controller will issue request to PDMA controller automatically.\nHardware will clear this bit to 0 automatically after PDMA transfer done.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>SPI1</name>
      <description>SPI Register Map</description>
      <groupName>SPI</groupName>
      <baseAddress>0x40034000</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x0</offset>
        <size>0xC</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x10</offset>
        <size>0x8</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x20</offset>
        <size>0x8</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x34</offset>
        <size>0x8</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>SPI_CNTRL</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SPI_CNTRL</displayName>
          <description>Control and Status Register</description>
          <addressOffset>0x0</addressOffset>
          <access>read-write</access>
          <resetValue>0x05000004</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>GO_BUSY</name>
              <description>Go and Busy Status\nDuring the data transfer, this bit keeps the value of 1. As the transfer is finished, this bit will be cleared automatically.\nNote: All registers should be set before writing 1 to this GO_BUSY bit.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Stop data transfer if SPI is transferring</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>In Master mode, start the SPI data transfer; in Slave mode, writing 1 to this bit indicates that the slave is ready to communicate with a master</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_NEG</name>
              <description>Receive At Negative Edge\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Received data input signal is latched at the rising edge of SPICLK</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Received data input signal is latched at the falling edge of SPICLK</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_NEG</name>
              <description>Transmit At Negative Edge\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Transmitted data output signal is changed at the rising edge of SPICLK</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Transmitted data output signal is changed at the falling edge of SPICLK</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_BIT_LEN</name>
              <description>Transmit Bit Length\nThis field specifies how many bits can be transmitted / received in one transaction. The minimum bit length is 8 bits and can up to 32 bits.\n</description>
              <bitOffset>3</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_NUM</name>
              <description>Numbers of Transmit/Receive Word\nThis field specifies how many transmit/receive word numbers should be executed in one transfer.\nNote: In Slave mode with level-trigger configuration, if TX_NUM is set to 01, the slave select pin must be kept at active state during the successive data transfer.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Only one transmit/receive word will be executed in one transfer</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Two successive transmit/receive words will be executed in one transfer. (burst mode)</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Reserved</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Reserved</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>LSB</name>
              <description>LSB First\n</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>MSB is transmitted/received first (which bit in SPI_TX0/1 and SPI_RX0/1 register that is depends on the TX_BIT_LEN field)</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>LSB is sent first on the line (bit 0 of SPI_TX0/1), and the first bit received from the line will be put in the LSB position in the RX register (bit 0 of SPI_RX0/1)</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CLKP</name>
              <description>Clock Polarity\n</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>SPICLK idle low</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>SPICLK idle high</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SP_CYCLE</name>
              <description>Suspend Interval (Master Only)\n</description>
              <bitOffset>12</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>IF</name>
              <description>Interrupt Flag\nNote: This bit will be cleared by writing 1 to itself.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Indicates the transfer dose not finish</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Indicates the transfer is done</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IE</name>
              <description>Interrupt Enable\n</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>SPI Interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>SPI Interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SLAVE</name>
              <description>Slave Mode Enable Bit\n</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Master mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Slave mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>REORDER</name>
              <description>Reorder Mode Select\nNote:\nByte reorder function is only available when TX_BIT_LEN is defined as 16, 24, and 32 bits.\nIn Slave mode with level-trigger configuration, if the byte suspend function is enabled, the slave select pin must be kept at active state during the successive four bytes transfer.</description>
              <bitOffset>19</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Both byte reorder and byte suspend functions Disabled</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Byte reorder function Enabled, and a byte suspend interval (2~17 SPICLK cycles) inserted among each byte. The setting of TX_BIT_LEN must be configured as 0x00. (32 bits/word)</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Byte reorder function Enabled, but byte suspend function Disabled</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Byte reorder function Disabled, but a suspend interval (2~17 SPICLK cycles) inserted among each byte. The setting of TX_BIT_LEN must be configured as 0x00. (32 bits/word)</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TWOB</name>
              <description>Two Bits Transfer Mode Active\nNote: When TWOB is enabled, the serial transmitted 2-bit data output are from SPI_TX1/0, and the received 2-bit data input are put in SPI_RX1/0.\nNote: When TWOB is enabled, the setting of TX_NUM must be programmed as 0x00.</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Two-bit Transfer mode Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Two-bit Transfer mode Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>VARCLK_EN</name>
              <description>Variable Clock Enable (Master Only)\nNote: When this VARCLK_EN bit is enabled, the setting of TX_BIT_LEN must be programmed as 0x10 (16-bit mode)</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Serial clock output frequency is fixed and decided only by the value of DIVIDER</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Serial clock output frequency is variable. The output frequency is decided by the value of VARCLK, DIVIDER, and DIVIDER2</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SPI_DIVIDER</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SPI_DIVIDER</displayName>
          <description>Clock Divider Register (Master Only)</description>
          <addressOffset>0x4</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DIVIDER</name>
              <description>Clock Divider 1 (Master Only)\nThe value in this field is the frequency divider for generating the serial clock on the output SPICLK. The desired frequency is obtained according to the following equation:\n\nIn Slave mode, the period of SPI clock driven by a master shall equal or over 5 times the period of PCLK. In other words, the maximum frequency of SPI clock is the fifth of the frequency of slave's PCLK.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DIVIDER2</name>
              <description>Clock Divider 2 (Master Only)\nThe value in this field is the 2nd frequency divider for generating the serial clock on the output SPICLK. The desired frequency is obtained according to the following equation:\n\nIf VARCLK_EN is cleared to 0, this setting is unmeaning.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SPI_SSR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SPI_SSR</displayName>
          <description>Slave Select Register</description>
          <addressOffset>0x8</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SSR</name>
              <description>Slave Select Control Bits (Master only)\nIf AUTOSS bit is cleared, writing 1 to any bit location of this field sets the proper SPISSx0/1 line to an active state and writing 0 sets the line back to inactive state.\nIf AUTOSS bit is set, writing 0 to any bit location of this field will keep the corresponding SPISSx0/1 line at inactive state; writing 1 to any bit location of this field will select appropriate SPISSx0/1 line to be automatically driven to active state for the duration of the transmit/receive, and will be driven to inactive state for the rest of the time. The active state of SPISSx0/1 is specified in SS_LVL. \nNote: SPISSx0 is also defined as slave select input in Slave mode.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SS_LVL</name>
              <description>Slave Select Active Level\nIt defines the active status of slave select signal (SPISSx0/1).\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Slave select signal SPISSx0/1 is active at low-level/falling-edge</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Slave select signal SPISSx0/1 is active at high-level/rising-edge</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>AUTOSS</name>
              <description>Automatic Slave Select Enable Bit (Master only)\n</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>If this bit is cleared, slave select signals will be asserted/de-asserted by setting /clearing related bits in SSR[1:0]</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>If this bit is set, SPISSx0/1 signals will be generated automatically. It means that device/slave select signal, which is set in SSR[1:0], will be asserted by the SPI controller when transmit/receive is started by setting GO_BUSY, and will be de-asserted after each transmit/receive is finished</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SS_LTRIG</name>
              <description>Slave Select Level Trigger Enable Bit (Slave only)\n</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Input slave select signal is edge-trigger. This is the default value. It depends on SS_LVL to decide the signal is active at falling-edge or rising-edge</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Slave select signal will be level-trigger. It depends on SS_LVL to decide the signal is active low or active high</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>LTRIG_FLAG</name>
              <description>Level Trigger Accomplish Flag\nWhen the SS_LTRIG bit is set in Slave mode, this bit can be read to indicate the received bit number is met the requirement or not.\nNote: This bit is READ only.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Transaction number or the transferred bit length of one transaction does not meet the specified requirements</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Transaction number and the transferred bit length met the specified requirements which defined in TX_NUM and TX_BIT_LEN</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SPI_RX0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SPI_RX0</displayName>
          <description>Data Receive Register 0</description>
          <addressOffset>0x10</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RX</name>
              <description>Data Receive Register\nThe Data Receive Registers hold the value of received data of the last executed transfer. Valid bits depend on the transmit bit length field in the SPI_CNTRL register.\nFor example, if TX_BIT_LEN is set to 0x08 and TX_NUM is set to 0x0, bit RX0[7:0] holds the received data. The values of the other bits are unknown.\nNote: The Data Receive Registers are read only.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="SPI_RX0">
          <name>SPI_RX1</name>
          <displayName>SPI_RX1</displayName>
          <description>Data Receive Register 1</description>
          <addressOffset>0x14</addressOffset>
       </register>
       <register>
          <name>SPI_TX0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SPI_TX0</displayName>
          <description>Data Transmit Register 0</description>
          <addressOffset>0x20</addressOffset>
          <access>write-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TX</name>
              <description>Data Transmit Register\nThe Data Transmit Registers hold the data to be transmitted in the next transfer. The valid bits depend on the transmit bit length field in the CNTRL register.\nFor example, if TX_BIT_LEN is set to 0x08 and the TX_NUM is set to 0x0, the bit TX0[7:0] will be transmitted in next transfer. If TX_BIT_LEN is set to 0x00 and TX_NUM is set to 0x1, the SPI controller will perform two 32-bit transmit/receive successive using the same setting. The transmission sequence is TX0[31:0] first and then TX1[31:0].</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="SPI_TX0">
          <name>SPI_TX1</name>
          <displayName>SPI_TX1</displayName>
          <description>Data Transmit Register 1</description>
          <addressOffset>0x24</addressOffset>
       </register>
       <register>
          <name>SPI_VARCLK</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SPI_VARCLK</displayName>
          <description>Variable Clock Pattern Register</description>
          <addressOffset>0x34</addressOffset>
          <access>read-write</access>
          <resetValue>0x007FFF87</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>VARCLK</name>
              <description>Variable Clock Pattern\nThe value in this field is the frequency patterns of the SPI clock. If the bit pattern of VARCLK is '0', the output frequency of SPICLK is in accordance with the value of DIVIDER. If the bit patterns of VARCLK are '1', the output frequency of SPICLK is in accordance with the value of DIVIDER2. Refer to register SPI_DIVIDER.\nRefer to the Variable Serial Clock Frequency paragraph for more detailed description.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SPI_DMA</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SPI_DMA</displayName>
          <description>SPI DMA Control Register</description>
          <addressOffset>0x38</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TX_DMA_GO</name>
              <description>Transmit DMA Start\nSetting this bit to 1 will start the transmit PDMA process. SPI controller will issue request to PDMA controller automatically.\nIf using PDMA mode to transfer data, remember not to set GO_BUSY bit of SPI_CNTRL register. The DMA controller inside SPI controller will set it automatically whenever necessary.\nHardware will clear this bit to 0 automatically after PDMA transfer done.\nNote: In DMA mode, the burst mode is not supported.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_DMA_GO</name>
              <description>Receive DMA Start\nSetting this bit to 1 will start the receive PDMA process. SPI controller will issue request to PDMA controller automatically.\nHardware will clear this bit to 0 automatically after PDMA transfer done.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>SPI2</name>
      <description>SPI Register Map</description>
      <groupName>SPI</groupName>
      <baseAddress>0x40130000</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x0</offset>
        <size>0xC</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x10</offset>
        <size>0x8</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x20</offset>
        <size>0x8</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x34</offset>
        <size>0x8</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>SPI_CNTRL</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SPI_CNTRL</displayName>
          <description>Control and Status Register</description>
          <addressOffset>0x0</addressOffset>
          <access>read-write</access>
          <resetValue>0x05000004</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>GO_BUSY</name>
              <description>Go and Busy Status\nDuring the data transfer, this bit keeps the value of 1. As the transfer is finished, this bit will be cleared automatically.\nNote: All registers should be set before writing 1 to this GO_BUSY bit.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Stop data transfer if SPI is transferring</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>In Master mode, start the SPI data transfer; in Slave mode, writing 1 to this bit indicates that the slave is ready to communicate with a master</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_NEG</name>
              <description>Receive At Negative Edge\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Received data input signal is latched at the rising edge of SPICLK</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Received data input signal is latched at the falling edge of SPICLK</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_NEG</name>
              <description>Transmit At Negative Edge\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Transmitted data output signal is changed at the rising edge of SPICLK</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Transmitted data output signal is changed at the falling edge of SPICLK</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_BIT_LEN</name>
              <description>Transmit Bit Length\nThis field specifies how many bits can be transmitted / received in one transaction. The minimum bit length is 8 bits and can up to 32 bits.\n</description>
              <bitOffset>3</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_NUM</name>
              <description>Numbers of Transmit/Receive Word\nThis field specifies how many transmit/receive word numbers should be executed in one transfer.\nNote: In Slave mode with level-trigger configuration, if TX_NUM is set to 01, the slave select pin must be kept at active state during the successive data transfer.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Only one transmit/receive word will be executed in one transfer</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Two successive transmit/receive words will be executed in one transfer. (burst mode)</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Reserved</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Reserved</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>LSB</name>
              <description>LSB First\n</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>MSB is transmitted/received first (which bit in SPI_TX0/1 and SPI_RX0/1 register that is depends on the TX_BIT_LEN field)</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>LSB is sent first on the line (bit 0 of SPI_TX0/1), and the first bit received from the line will be put in the LSB position in the RX register (bit 0 of SPI_RX0/1)</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CLKP</name>
              <description>Clock Polarity\n</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>SPICLK idle low</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>SPICLK idle high</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SP_CYCLE</name>
              <description>Suspend Interval (Master Only)\n</description>
              <bitOffset>12</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>IF</name>
              <description>Interrupt Flag\nNote: This bit will be cleared by writing 1 to itself.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Indicates the transfer dose not finish</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Indicates the transfer is done</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IE</name>
              <description>Interrupt Enable\n</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>SPI Interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>SPI Interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SLAVE</name>
              <description>Slave Mode Enable Bit\n</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Master mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Slave mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>REORDER</name>
              <description>Reorder Mode Select\nNote:\nByte reorder function is only available when TX_BIT_LEN is defined as 16, 24, and 32 bits.\nIn Slave mode with level-trigger configuration, if the byte suspend function is enabled, the slave select pin must be kept at active state during the successive four bytes transfer.</description>
              <bitOffset>19</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Both byte reorder and byte suspend functions Disabled</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Byte reorder function Enabled, and a byte suspend interval (2~17 SPICLK cycles) inserted among each byte. The setting of TX_BIT_LEN must be configured as 0x00. (32 bits/word)</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Byte reorder function Enabled, but byte suspend function Disabled</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Byte reorder function Disabled, but a suspend interval (2~17 SPICLK cycles) inserted among each byte. The setting of TX_BIT_LEN must be configured as 0x00. (32 bits/word)</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TWOB</name>
              <description>Two Bits Transfer Mode Active\nNote: When TWOB is enabled, the serial transmitted 2-bit data output are from SPI_TX1/0, and the received 2-bit data input are put in SPI_RX1/0.\nNote: When TWOB is enabled, the setting of TX_NUM must be programmed as 0x00.</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Two-bit Transfer mode Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Two-bit Transfer mode Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>VARCLK_EN</name>
              <description>Variable Clock Enable (Master Only)\nNote: When this VARCLK_EN bit is enabled, the setting of TX_BIT_LEN must be programmed as 0x10 (16-bit mode)</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Serial clock output frequency is fixed and decided only by the value of DIVIDER</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Serial clock output frequency is variable. The output frequency is decided by the value of VARCLK, DIVIDER, and DIVIDER2</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SPI_DIVIDER</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SPI_DIVIDER</displayName>
          <description>Clock Divider Register (Master Only)</description>
          <addressOffset>0x4</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DIVIDER</name>
              <description>Clock Divider 1 (Master Only)\nThe value in this field is the frequency divider for generating the serial clock on the output SPICLK. The desired frequency is obtained according to the following equation:\n\nIn Slave mode, the period of SPI clock driven by a master shall equal or over 5 times the period of PCLK. In other words, the maximum frequency of SPI clock is the fifth of the frequency of slave's PCLK.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DIVIDER2</name>
              <description>Clock Divider 2 (Master Only)\nThe value in this field is the 2nd frequency divider for generating the serial clock on the output SPICLK. The desired frequency is obtained according to the following equation:\n\nIf VARCLK_EN is cleared to 0, this setting is unmeaning.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SPI_SSR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SPI_SSR</displayName>
          <description>Slave Select Register</description>
          <addressOffset>0x8</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SSR</name>
              <description>Slave Select Control Bits (Master only)\nIf AUTOSS bit is cleared, writing 1 to any bit location of this field sets the proper SPISSx0/1 line to an active state and writing 0 sets the line back to inactive state.\nIf AUTOSS bit is set, writing 0 to any bit location of this field will keep the corresponding SPISSx0/1 line at inactive state; writing 1 to any bit location of this field will select appropriate SPISSx0/1 line to be automatically driven to active state for the duration of the transmit/receive, and will be driven to inactive state for the rest of the time. The active state of SPISSx0/1 is specified in SS_LVL. \nNote: SPISSx0 is also defined as slave select input in Slave mode.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SS_LVL</name>
              <description>Slave Select Active Level\nIt defines the active status of slave select signal (SPISSx0/1).\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Slave select signal SPISSx0/1 is active at low-level/falling-edge</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Slave select signal SPISSx0/1 is active at high-level/rising-edge</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>AUTOSS</name>
              <description>Automatic Slave Select Enable Bit (Master only)\n</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>If this bit is cleared, slave select signals will be asserted/de-asserted by setting /clearing related bits in SSR[1:0]</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>If this bit is set, SPISSx0/1 signals will be generated automatically. It means that device/slave select signal, which is set in SSR[1:0], will be asserted by the SPI controller when transmit/receive is started by setting GO_BUSY, and will be de-asserted after each transmit/receive is finished</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SS_LTRIG</name>
              <description>Slave Select Level Trigger Enable Bit (Slave only)\n</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Input slave select signal is edge-trigger. This is the default value. It depends on SS_LVL to decide the signal is active at falling-edge or rising-edge</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Slave select signal will be level-trigger. It depends on SS_LVL to decide the signal is active low or active high</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>LTRIG_FLAG</name>
              <description>Level Trigger Accomplish Flag\nWhen the SS_LTRIG bit is set in Slave mode, this bit can be read to indicate the received bit number is met the requirement or not.\nNote: This bit is READ only.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Transaction number or the transferred bit length of one transaction does not meet the specified requirements</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Transaction number and the transferred bit length met the specified requirements which defined in TX_NUM and TX_BIT_LEN</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SPI_RX0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SPI_RX0</displayName>
          <description>Data Receive Register 0</description>
          <addressOffset>0x10</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RX</name>
              <description>Data Receive Register\nThe Data Receive Registers hold the value of received data of the last executed transfer. Valid bits depend on the transmit bit length field in the SPI_CNTRL register.\nFor example, if TX_BIT_LEN is set to 0x08 and TX_NUM is set to 0x0, bit RX0[7:0] holds the received data. The values of the other bits are unknown.\nNote: The Data Receive Registers are read only.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="SPI_RX0">
          <name>SPI_RX1</name>
          <displayName>SPI_RX1</displayName>
          <description>Data Receive Register 1</description>
          <addressOffset>0x14</addressOffset>
       </register>
       <register>
          <name>SPI_TX0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SPI_TX0</displayName>
          <description>Data Transmit Register 0</description>
          <addressOffset>0x20</addressOffset>
          <access>write-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TX</name>
              <description>Data Transmit Register\nThe Data Transmit Registers hold the data to be transmitted in the next transfer. The valid bits depend on the transmit bit length field in the CNTRL register.\nFor example, if TX_BIT_LEN is set to 0x08 and the TX_NUM is set to 0x0, the bit TX0[7:0] will be transmitted in next transfer. If TX_BIT_LEN is set to 0x00 and TX_NUM is set to 0x1, the SPI controller will perform two 32-bit transmit/receive successive using the same setting. The transmission sequence is TX0[31:0] first and then TX1[31:0].</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="SPI_TX0">
          <name>SPI_TX1</name>
          <displayName>SPI_TX1</displayName>
          <description>Data Transmit Register 1</description>
          <addressOffset>0x24</addressOffset>
       </register>
       <register>
          <name>SPI_VARCLK</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SPI_VARCLK</displayName>
          <description>Variable Clock Pattern Register</description>
          <addressOffset>0x34</addressOffset>
          <access>read-write</access>
          <resetValue>0x007FFF87</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>VARCLK</name>
              <description>Variable Clock Pattern\nThe value in this field is the frequency patterns of the SPI clock. If the bit pattern of VARCLK is '0', the output frequency of SPICLK is in accordance with the value of DIVIDER. If the bit patterns of VARCLK are '1', the output frequency of SPICLK is in accordance with the value of DIVIDER2. Refer to register SPI_DIVIDER.\nRefer to the Variable Serial Clock Frequency paragraph for more detailed description.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SPI_DMA</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SPI_DMA</displayName>
          <description>SPI DMA Control Register</description>
          <addressOffset>0x38</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TX_DMA_GO</name>
              <description>Transmit DMA Start\nSetting this bit to 1 will start the transmit PDMA process. SPI controller will issue request to PDMA controller automatically.\nIf using PDMA mode to transfer data, remember not to set GO_BUSY bit of SPI_CNTRL register. The DMA controller inside SPI controller will set it automatically whenever necessary.\nHardware will clear this bit to 0 automatically after PDMA transfer done.\nNote: In DMA mode, the burst mode is not supported.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_DMA_GO</name>
              <description>Receive DMA Start\nSetting this bit to 1 will start the receive PDMA process. SPI controller will issue request to PDMA controller automatically.\nHardware will clear this bit to 0 automatically after PDMA transfer done.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>SPI3</name>
      <description>SPI Register Map</description>
      <groupName>SPI</groupName>
      <baseAddress>0x40134000</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x0</offset>
        <size>0xC</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x10</offset>
        <size>0x8</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x20</offset>
        <size>0x8</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x34</offset>
        <size>0x8</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>SPI_CNTRL</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SPI_CNTRL</displayName>
          <description>Control and Status Register</description>
          <addressOffset>0x0</addressOffset>
          <access>read-write</access>
          <resetValue>0x05000004</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>GO_BUSY</name>
              <description>Go and Busy Status\nDuring the data transfer, this bit keeps the value of 1. As the transfer is finished, this bit will be cleared automatically.\nNote: All registers should be set before writing 1 to this GO_BUSY bit.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Stop data transfer if SPI is transferring</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>In Master mode, start the SPI data transfer; in Slave mode, writing 1 to this bit indicates that the slave is ready to communicate with a master</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_NEG</name>
              <description>Receive At Negative Edge\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Received data input signal is latched at the rising edge of SPICLK</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Received data input signal is latched at the falling edge of SPICLK</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_NEG</name>
              <description>Transmit At Negative Edge\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Transmitted data output signal is changed at the rising edge of SPICLK</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Transmitted data output signal is changed at the falling edge of SPICLK</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_BIT_LEN</name>
              <description>Transmit Bit Length\nThis field specifies how many bits can be transmitted / received in one transaction. The minimum bit length is 8 bits and can up to 32 bits.\n</description>
              <bitOffset>3</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_NUM</name>
              <description>Numbers of Transmit/Receive Word\nThis field specifies how many transmit/receive word numbers should be executed in one transfer.\nNote: In Slave mode with level-trigger configuration, if TX_NUM is set to 01, the slave select pin must be kept at active state during the successive data transfer.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Only one transmit/receive word will be executed in one transfer</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Two successive transmit/receive words will be executed in one transfer. (burst mode)</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Reserved</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Reserved</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>LSB</name>
              <description>LSB First\n</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>MSB is transmitted/received first (which bit in SPI_TX0/1 and SPI_RX0/1 register that is depends on the TX_BIT_LEN field)</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>LSB is sent first on the line (bit 0 of SPI_TX0/1), and the first bit received from the line will be put in the LSB position in the RX register (bit 0 of SPI_RX0/1)</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CLKP</name>
              <description>Clock Polarity\n</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>SPICLK idle low</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>SPICLK idle high</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SP_CYCLE</name>
              <description>Suspend Interval (Master Only)\n</description>
              <bitOffset>12</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>IF</name>
              <description>Interrupt Flag\nNote: This bit will be cleared by writing 1 to itself.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Indicates the transfer dose not finish</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Indicates the transfer is done</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IE</name>
              <description>Interrupt Enable\n</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>SPI Interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>SPI Interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SLAVE</name>
              <description>Slave Mode Enable Bit\n</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Master mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Slave mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>REORDER</name>
              <description>Reorder Mode Select\nNote:\nByte reorder function is only available when TX_BIT_LEN is defined as 16, 24, and 32 bits.\nIn Slave mode with level-trigger configuration, if the byte suspend function is enabled, the slave select pin must be kept at active state during the successive four bytes transfer.</description>
              <bitOffset>19</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Both byte reorder and byte suspend functions Disabled</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Byte reorder function Enabled, and a byte suspend interval (2~17 SPICLK cycles) inserted among each byte. The setting of TX_BIT_LEN must be configured as 0x00. (32 bits/word)</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Byte reorder function Enabled, but byte suspend function Disabled</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Byte reorder function Disabled, but a suspend interval (2~17 SPICLK cycles) inserted among each byte. The setting of TX_BIT_LEN must be configured as 0x00. (32 bits/word)</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TWOB</name>
              <description>Two Bits Transfer Mode Active\nNote: When TWOB is enabled, the serial transmitted 2-bit data output are from SPI_TX1/0, and the received 2-bit data input are put in SPI_RX1/0.\nNote: When TWOB is enabled, the setting of TX_NUM must be programmed as 0x00.</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Two-bit Transfer mode Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Two-bit Transfer mode Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>VARCLK_EN</name>
              <description>Variable Clock Enable (Master Only)\nNote: When this VARCLK_EN bit is enabled, the setting of TX_BIT_LEN must be programmed as 0x10 (16-bit mode)</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Serial clock output frequency is fixed and decided only by the value of DIVIDER</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Serial clock output frequency is variable. The output frequency is decided by the value of VARCLK, DIVIDER, and DIVIDER2</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SPI_DIVIDER</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SPI_DIVIDER</displayName>
          <description>Clock Divider Register (Master Only)</description>
          <addressOffset>0x4</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DIVIDER</name>
              <description>Clock Divider 1 (Master Only)\nThe value in this field is the frequency divider for generating the serial clock on the output SPICLK. The desired frequency is obtained according to the following equation:\n\nIn Slave mode, the period of SPI clock driven by a master shall equal or over 5 times the period of PCLK. In other words, the maximum frequency of SPI clock is the fifth of the frequency of slave's PCLK.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DIVIDER2</name>
              <description>Clock Divider 2 (Master Only)\nThe value in this field is the 2nd frequency divider for generating the serial clock on the output SPICLK. The desired frequency is obtained according to the following equation:\n\nIf VARCLK_EN is cleared to 0, this setting is unmeaning.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SPI_SSR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SPI_SSR</displayName>
          <description>Slave Select Register</description>
          <addressOffset>0x8</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SSR</name>
              <description>Slave Select Control Bits (Master only)\nIf AUTOSS bit is cleared, writing 1 to any bit location of this field sets the proper SPISSx0/1 line to an active state and writing 0 sets the line back to inactive state.\nIf AUTOSS bit is set, writing 0 to any bit location of this field will keep the corresponding SPISSx0/1 line at inactive state; writing 1 to any bit location of this field will select appropriate SPISSx0/1 line to be automatically driven to active state for the duration of the transmit/receive, and will be driven to inactive state for the rest of the time. The active state of SPISSx0/1 is specified in SS_LVL. \nNote: SPISSx0 is also defined as slave select input in Slave mode.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SS_LVL</name>
              <description>Slave Select Active Level\nIt defines the active status of slave select signal (SPISSx0/1).\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Slave select signal SPISSx0/1 is active at low-level/falling-edge</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Slave select signal SPISSx0/1 is active at high-level/rising-edge</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>AUTOSS</name>
              <description>Automatic Slave Select Enable Bit (Master only)\n</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>If this bit is cleared, slave select signals will be asserted/de-asserted by setting /clearing related bits in SSR[1:0]</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>If this bit is set, SPISSx0/1 signals will be generated automatically. It means that device/slave select signal, which is set in SSR[1:0], will be asserted by the SPI controller when transmit/receive is started by setting GO_BUSY, and will be de-asserted after each transmit/receive is finished</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SS_LTRIG</name>
              <description>Slave Select Level Trigger Enable Bit (Slave only)\n</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Input slave select signal is edge-trigger. This is the default value. It depends on SS_LVL to decide the signal is active at falling-edge or rising-edge</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Slave select signal will be level-trigger. It depends on SS_LVL to decide the signal is active low or active high</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>LTRIG_FLAG</name>
              <description>Level Trigger Accomplish Flag\nWhen the SS_LTRIG bit is set in Slave mode, this bit can be read to indicate the received bit number is met the requirement or not.\nNote: This bit is READ only.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Transaction number or the transferred bit length of one transaction does not meet the specified requirements</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Transaction number and the transferred bit length met the specified requirements which defined in TX_NUM and TX_BIT_LEN</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SPI_RX0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SPI_RX0</displayName>
          <description>Data Receive Register 0</description>
          <addressOffset>0x10</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RX</name>
              <description>Data Receive Register\nThe Data Receive Registers hold the value of received data of the last executed transfer. Valid bits depend on the transmit bit length field in the SPI_CNTRL register.\nFor example, if TX_BIT_LEN is set to 0x08 and TX_NUM is set to 0x0, bit RX0[7:0] holds the received data. The values of the other bits are unknown.\nNote: The Data Receive Registers are read only.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="SPI_RX0">
          <name>SPI_RX1</name>
          <displayName>SPI_RX1</displayName>
          <description>Data Receive Register 1</description>
          <addressOffset>0x14</addressOffset>
       </register>
       <register>
          <name>SPI_TX0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SPI_TX0</displayName>
          <description>Data Transmit Register 0</description>
          <addressOffset>0x20</addressOffset>
          <access>write-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TX</name>
              <description>Data Transmit Register\nThe Data Transmit Registers hold the data to be transmitted in the next transfer. The valid bits depend on the transmit bit length field in the CNTRL register.\nFor example, if TX_BIT_LEN is set to 0x08 and the TX_NUM is set to 0x0, the bit TX0[7:0] will be transmitted in next transfer. If TX_BIT_LEN is set to 0x00 and TX_NUM is set to 0x1, the SPI controller will perform two 32-bit transmit/receive successive using the same setting. The transmission sequence is TX0[31:0] first and then TX1[31:0].</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="SPI_TX0">
          <name>SPI_TX1</name>
          <displayName>SPI_TX1</displayName>
          <description>Data Transmit Register 1</description>
          <addressOffset>0x24</addressOffset>
       </register>
       <register>
          <name>SPI_VARCLK</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SPI_VARCLK</displayName>
          <description>Variable Clock Pattern Register</description>
          <addressOffset>0x34</addressOffset>
          <access>read-write</access>
          <resetValue>0x007FFF87</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>VARCLK</name>
              <description>Variable Clock Pattern\nThe value in this field is the frequency patterns of the SPI clock. If the bit pattern of VARCLK is '0', the output frequency of SPICLK is in accordance with the value of DIVIDER. If the bit patterns of VARCLK are '1', the output frequency of SPICLK is in accordance with the value of DIVIDER2. Refer to register SPI_DIVIDER.\nRefer to the Variable Serial Clock Frequency paragraph for more detailed description.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SPI_DMA</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SPI_DMA</displayName>
          <description>SPI DMA Control Register</description>
          <addressOffset>0x38</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TX_DMA_GO</name>
              <description>Transmit DMA Start\nSetting this bit to 1 will start the transmit PDMA process. SPI controller will issue request to PDMA controller automatically.\nIf using PDMA mode to transfer data, remember not to set GO_BUSY bit of SPI_CNTRL register. The DMA controller inside SPI controller will set it automatically whenever necessary.\nHardware will clear this bit to 0 automatically after PDMA transfer done.\nNote: In DMA mode, the burst mode is not supported.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_DMA_GO</name>
              <description>Receive DMA Start\nSetting this bit to 1 will start the receive PDMA process. SPI controller will issue request to PDMA controller automatically.\nHardware will clear this bit to 0 automatically after PDMA transfer done.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>TMR01</name>
      <description>TMR Register Map</description>
      <groupName>TMR</groupName>
      <baseAddress>0x40010000</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x0</offset>
        <size>0x10</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x20</offset>
        <size>0x10</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>TCSR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>TCSR0</displayName>
          <description>Timer0 Control and Status Register</description>
          <addressOffset>0x0</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000005</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PRESCALE</name>
              <description>Pre-scale Counter\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TDR_EN</name>
              <description>Data Load Enable\nWhen TDR_EN is set, TDR (Timer Data Register) will be updated continuously with the 24-bit up-timer value as the timer is counting.\n</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Timer Data Register update Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Timer Data Register update Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CTB</name>
              <description>Counter Mode Enable Bit (NuMicro( NUC100/NUC120 Low Density Only)\nThis bit is the counter mode enable bit. When Timer is used as an event counter, this bit should be set to 1 and Timer will work as an event counter. The event is triggered by rising edge from external pin\n</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disabled counter mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>counter mode Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CACT</name>
              <description>Timer Active Status Bit (Read Only)\nThis bit indicates the up-timer status.\n</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Timer is not active</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Timer is active</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>CRST</name>
              <description>Timer Reset Bit\nSetting this bit will reset the 24-bit up-timer, 8-bit pre-scale counter and also force CEN to 0.\n</description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reset Timer's 8-bit pre-scale counter, internal 24-bit up-timer and CEN bit</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>MODE</name>
              <description>Timer Operating Mode\n</description>
              <bitOffset>27</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>IE</name>
              <description>Interrupt Enable Bit\nIf timer interrupt is enabled, the timer asserts its interrupt signal when the associated up-timer value is equal to TCMPR.</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Timer Interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Timer Interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CEN</name>
              <description>Timer Enable Bit\n</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Stops/Suspends counting</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Starts counting</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DBGACK_TMR</name>
              <description>ICE Debug Mode Acknowledge Disable (Write-protection Bit)\nTIMER counter will keep going no matter ICE debug mode acknowledged or not.</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>ICE debug mode acknowledgement effects TIMER counting</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>ICE debug mode acknowledgement disabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>TCMPR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>TCMPR0</displayName>
          <description>Timer0 Compare Register</description>
          <addressOffset>0x4</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TCMP</name>
              <description>Timer Compared Value\nNote1: Never write 0x0 or 0x1 in TCMP, or the core will run into unknown state.\nNote2: When timer is operating at continuous counting mode, the 24-bit up-timer will count continuously if software writes a new value into TCMP. If timer is operating at other modes, the 24-bit up-timer will restart counting and using newest TCMP value to be the compared value if software writes a new value into TCMP.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>TISR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>TISR0</displayName>
          <description>Timer0 Interrupt Status Register</description>
          <addressOffset>0x8</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TIF</name>
              <description>Timer Interrupt Flag\nThis bit indicates the interrupt status of Timer.\nTIF bit is set by hardware when the up counting value of internal 24-bit up-timer matches the timer compared value (TCMP). It is cleared by writing 1 to this bit.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>TDR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>TDR0</displayName>
          <description>Timer0 Data Register</description>
          <addressOffset>0xC</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TDR</name>
              <description>Timer Data Register\nWhen TCSR.TDR_EN is set to 1, the internal 24-bit up-timer value will be loaded into TDR. User can read this register for the up-timer value.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="TCSR0">
          <name>TCSR1</name>
          <displayName>TCSR1</displayName>
          <description>Timer1 Control and Status Register</description>
          <addressOffset>0x20</addressOffset>
       </register>
       <register derivedFrom="TCMPR0">
          <name>TCMPR1</name>
          <displayName>TCMPR1</displayName>
          <description>Timer1 Compare Register</description>
          <addressOffset>0x24</addressOffset>
       </register>
       <register derivedFrom="TISR0">
          <name>TISR1</name>
          <displayName>TISR1</displayName>
          <description>Timer1 Interrupt Status Register</description>
          <addressOffset>0x28</addressOffset>
       </register>
       <register derivedFrom="TDR0">
          <name>TDR1</name>
          <displayName>TDR1</displayName>
          <description>Timer1 Data Register</description>
          <addressOffset>0x2C</addressOffset>
       </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>TMR23</name>
      <description>TMR Register Map</description>
      <groupName>TMR</groupName>
      <baseAddress>0x40110000</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x0</offset>
        <size>0x10</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x20</offset>
        <size>0x10</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>TCSR2</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>TCSR2</displayName>
          <description>Timer2 Control and Status Register</description>
          <addressOffset>0x0</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000005</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PRESCALE</name>
              <description>Pre-scale Counter\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TDR_EN</name>
              <description>Data Load Enable\nWhen TDR_EN is set, TDR (Timer Data Register) will be updated continuously with the 24-bit up-timer value as the timer is counting.\n</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Timer Data Register update Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Timer Data Register update Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CTB</name>
              <description>Counter Mode Enable Bit (NuMicro( NUC100/NUC120 Low Density Only)\nThis bit is the counter mode enable bit. When Timer is used as an event counter, this bit should be set to 1 and Timer will work as an event counter. The event is triggered by rising edge from external pin\n</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disabled counter mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>counter mode Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CACT</name>
              <description>Timer Active Status Bit (Read Only)\nThis bit indicates the up-timer status.\n</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Timer is not active</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Timer is active</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>CRST</name>
              <description>Timer Reset Bit\nSetting this bit will reset the 24-bit up-timer, 8-bit pre-scale counter and also force CEN to 0.\n</description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reset Timer's 8-bit pre-scale counter, internal 24-bit up-timer and CEN bit</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>MODE</name>
              <description>Timer Operating Mode\n</description>
              <bitOffset>27</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>IE</name>
              <description>Interrupt Enable Bit\nIf timer interrupt is enabled, the timer asserts its interrupt signal when the associated up-timer value is equal to TCMPR.</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Timer Interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Timer Interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CEN</name>
              <description>Timer Enable Bit\n</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Stops/Suspends counting</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Starts counting</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DBGACK_TMR</name>
              <description>ICE Debug Mode Acknowledge Disable (Write-protection Bit)\nTIMER counter will keep going no matter ICE debug mode acknowledged or not.</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>ICE debug mode acknowledgement effects TIMER counting</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>ICE debug mode acknowledgement disabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>TCMPR2</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>TCMPR2</displayName>
          <description>Timer2 Compare Register</description>
          <addressOffset>0x4</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TCMP</name>
              <description>Timer Compared Value\nNote1: Never write 0x0 or 0x1 in TCMP, or the core will run into unknown state.\nNote2: When timer is operating at continuous counting mode, the 24-bit up-timer will count continuously if software writes a new value into TCMP. If timer is operating at other modes, the 24-bit up-timer will restart counting and using newest TCMP value to be the compared value if software writes a new value into TCMP.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>TISR2</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>TISR2</displayName>
          <description>Timer2 Interrupt Status Register</description>
          <addressOffset>0x8</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TIF</name>
              <description>Timer Interrupt Flag\nThis bit indicates the interrupt status of Timer.\nTIF bit is set by hardware when the up counting value of internal 24-bit up-timer matches the timer compared value (TCMP). It is cleared by writing 1 to this bit.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>TDR2</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>TDR2</displayName>
          <description>Timer2 Data Register</description>
          <addressOffset>0xC</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TDR</name>
              <description>Timer Data Register\nWhen TCSR.TDR_EN is set to 1, the internal 24-bit up-timer value will be loaded into TDR. User can read this register for the up-timer value.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="TCSR2">
          <name>TCSR3</name>
          <displayName>TCSR3</displayName>
          <description>Timer3 Control and Status Register</description>
          <addressOffset>0x20</addressOffset>
       </register>
       <register derivedFrom="TCMPR2">
          <name>TCMPR3</name>
          <displayName>TCMPR3</displayName>
          <description>Timer3 Compare Register</description>
          <addressOffset>0x24</addressOffset>
       </register>
       <register derivedFrom="TISR2">
          <name>TISR3</name>
          <displayName>TISR3</displayName>
          <description>Timer3 Interrupt Status Register</description>
          <addressOffset>0x28</addressOffset>
       </register>
       <register derivedFrom="TDR2">
          <name>TDR3</name>
          <displayName>TDR3</displayName>
          <description>Timer3 Data Register</description>
          <addressOffset>0x2C</addressOffset>
       </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>WDT</name>
      <description>WDT Register Map</description>
      <groupName>WDT</groupName>
      <baseAddress>0x40004000</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x0</offset>
        <size>0x4</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>WTCR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>WTCR</displayName>
          <description>Watchdog Timer Control Register</description>
          <addressOffset>0x0</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000700</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WTR</name>
              <description>Clear Watchdog Timer (Write-protection Bit)\nSet this bit will clear the Watchdog timer.\nNote: This bit will be automatically cleared by hardware.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reset the contents of the Watchdog timer</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>WTRE</name>
              <description>Watchdog Timer Reset Enable (Write-protection Bit)\nSetting this bit will enable the Watchdog timer reset function.\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Watchdog timer reset function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Watchdog timer reset function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>WTRF</name>
              <description>Watchdog Timer Reset Flag\nWhen the Watchdog timer initiates a reset, the hardware will set this bit. This flag can be read by software to determine the source of reset. Software is responsible to clear it manually by writing 1 to it. If WTRE is disabled, then the Watchdog timer has no effect on this bit.\nNote: This bit is cleared by writing 1 to this bit.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Watchdog timer reset did not occur</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Watchdog timer reset occurred</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>WTIF</name>
              <description>Watchdog Timer Interrupt Flag\nIf the Watchdog timer interrupt is enabled, this bit will be set to indicate that Watchdog timer interrupt has occurred.\nNote: This bit is cleared by writing 1 to this bit.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Watchdog timer interrupt did not occur</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Watchdog timer interrupt occurred</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>WTWKE</name>
              <description>Watchdog Timer Wake-up Function Enable bit (Write-protection Bit)\nNote: Chip can be woken up by WDT only if WDT clock source selects RC10K.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Watchdog timer Wake-up chip function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Wake-up function Enabled so that Watchdog timer timeout can wake-up chip from Power-down mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>WTWKF</name>
              <description>Watchdog Timer Wake-up Flag\nIf Watchdog timer causes chip wakes up from Power-down mode, this bit will be set to high. It must be cleared by software with a write 1 to this bit.\n</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Watchdog timer does not cause chip wake-up</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Chip wake-up from Idle or Power-down mode by Watchdog timeout</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>WTIE</name>
              <description>Watchdog Timer Interrupt Enable (Write-protection Bit)\n</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Watchdog timer interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Watchdog timer interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>WTE</name>
              <description>Watchdog Timer Enable (Write-protection Bit)\n</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Watchdog timer Disabled (This action will reset the internal counter)</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Watchdog timer Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>WTIS</name>
              <description>Watchdog Timer Interval Selection (Write-protection Bits)\n</description>
              <bitOffset>8</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DBGACK_WDT</name>
              <description>ICE Debug Mode Acknowledge Disable (Write-protection Bit)\nWatchdog Timer counter will keep going no matter ICE debug mode acknowledged or not.</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>ICE debug mode acknowledgement affects Watchdog Timer counting</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>ICE debug mode acknowledgement disabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>UART0</name>
      <description>UART Register Map</description>
      <groupName>UART</groupName>
      <baseAddress>0x40050000</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x0</offset>
        <size>0x34</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>UA_RBR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UA_RBR</displayName>
          <description>UART Receive Buffer Register</description>
          <addressOffset>0x0</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>RBR</name>
              <description>Receive Buffer Register (Read Only)\nBy reading this register, the UART will return an 8-bit data received from RX pin (LSB first).</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UA_THR</name>
          <alternateRegister>UA_RBR</alternateRegister>
          <!-- the display name is an unrestricted string. -->
          <displayName>UA_THR</displayName>
          <description>UART Transmit Holding Register</description>
          <addressOffset>0x0</addressOffset>
          <access>write-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>THR</name>
              <description>Transmit Holding Register\nBy writing to this register, the UART will send out an 8-bit data through the TX pin (LSB first).</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UA_IER</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UA_IER</displayName>
          <description>UART Interrupt Enable Register</description>
          <addressOffset>0x4</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RDA_IEN</name>
              <description>Receive Data Available Interrupt Enable.\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>INT_RDA Masked off</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>INT_RDA Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>THRE_IEN</name>
              <description>Transmit Holding Register Empty Interrupt Enable\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>INT_THRE Masked off</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>INT_THRE Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RLS_IEN</name>
              <description>Receive Line Status Interrupt Enable \n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>INT_RLS Masked off</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>INT_RLS Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>MODEM_IEN</name>
              <description>Modem Status Interrupt Enable (Not Available in UART2 Channel)\n</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>INT_MODEM Masked off</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>INT_MODEM Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RTO_IEN</name>
              <description>RX Time Out Interrupt Enable\n</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>INT_TOUT Masked off</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>INT_TOUT Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BUF_ERR_IEN</name>
              <description>Buffer Error Interrupt Enable\n</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>INT_BUF_ERR Maskdd off</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>INT_BUF_ERR Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>WAKE_EN</name>
              <description>UART Wake-up Function Enable (Not Available in UART2 Channel)\n</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>UART wake-up function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>UART wake-up function Enabled; when the chip is in Power-down mode, an external CTS change will wake-up chip from Power-down mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TIME_OUT_EN</name>
              <description>Time Out Counter Enable\n</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Time-out counter Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Time-out counter Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>AUTO_RTS_EN</name>
              <description>RTS Auto Flow Control Enable (Not Available in UART2 Channel)\nWhen RTS auto-flow is enabled, if the number of bytes in the RX FIFO equals the UA_FCR [RTS_TRI_LEV], the UART will de-assert RTS signal.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RTS auto flow control Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RTS auto flow control Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>AUTO_CTS_EN</name>
              <description>CTS Auto Flow Control Enable (Not Available in UART2 Channel)\nWhen CTS auto-flow is enabled, the UART will send data to external device when CTS input assert (UART will not send data to device until CTS is asserted).</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>CTS auto flow control Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>CTS auto flow control Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DMA_TX_EN</name>
              <description>TX DMA Enable (Not Available in UART2 Channel)\nThis bit can enable or disable TX DMA service.\n</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>TX DMA Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>TX DMA Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DMA_RX_EN</name>
              <description>RX DMA Enable (Not Available in UART2 Channel)\nThis bit can enable or disable RX DMA service.\n</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RX DMA Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RX DMA Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UA_FCR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UA_FCR</displayName>
          <description>UART FIFO Control Register</description>
          <addressOffset>0x8</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000101</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RFR</name>
              <description>RX Field Software Reset\nWhen RX_RST is set, all the byte in the receiver FIFO and RX internal state machine are cleared.\nNote: This bit will automatically clear at least 3 UART engine clock cycles.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reset the RX internal state machine and pointers</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TFR</name>
              <description>TX Field Software Reset\nWhen TX_RST is set, all the byte in the transmit FIFO and TX internal state machine are cleared.\nNote: This bit will automatically clear at least 3 UART engine clock cycles.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reset the TX internal state machine and pointers</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RFITL</name>
              <description>RX FIFO Interrupt (INT_RDA) Trigger Level\n</description>
              <bitOffset>4</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_DIS</name>
              <description>Receiver Disable Register.\nThe receiver is disabled or not (set 1  to disable receiver)\nNote: This field is used for RS-485 Normal Multi-drop mode. It should be programmed before UA_ALT_CSR [RS-485_NMM] is programmed.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Receiver Enabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Receiver Disabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RTS_TRI_LEV</name>
              <description>RTS Trigger Level for Auto-flow Control Use (Not Available in UART2 Channel)\n</description>
              <bitOffset>16</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UA_LCR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UA_LCR</displayName>
          <description>UART Line Control Register</description>
          <addressOffset>0xC</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WLS</name>
              <description>Word Length Selection\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>NSB</name>
              <description>Number of "STOP bit"\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>1 STOP bit</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>2 STOP bits (1.5 STOP bits if WLS[1:0]=00)</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PBE</name>
              <description>Parity Bit Enable\n</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No parity bit</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Parity bit is generated on each outgoing character and is checked on each incoming data</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>EPE</name>
              <description>Even Parity Enable\nThis bit has effect only when bit 3 (parity bit enable) is set.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Odd number of logic 1's is transmitted and checked in each word</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Even number of logic 1's is transmitted and checked in each word</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SPE</name>
              <description>Stick Parity Enable\n</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Stick parity Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>If bit 3 and 4 are logic 1, the parity bit is transmitted and checked as logic 0. If bit 3 is 1 and bit 4 is 0 then the parity bit is transmitted and checked as 1</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BCB</name>
              <description>Break Control Bit\nWhen this bit is set to logic 1, the serial data output (TX) is forced to the Spacing State (logic 0). This bit acts only on TX and has no effect on the transmitter logic.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UA_MCR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UA_MCR</displayName>
          <description>UART Modem Control Register\nReserved</description>
          <addressOffset>0x10</addressOffset>
          <access>read-write</access>
          <resetValue>0x00002000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RTS</name>
              <description>RTS (Request-To-Send) Signal (Not Available in UART2 Channel)\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Drive RTS pin to logic 1 (If the LEV_RTS set to low level triggered).\nDrive RTS pin to logic 0 (If the LEV_RTS set to high level triggered)</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Drive RTS pin to logic 0 (If the LEV_RTS set to low level triggered).\nDrive RTS pin to logic 1 (If the LEV_RTS set to high level triggered)</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>LEV_RTS</name>
              <description>RTS Trigger Level (Not Available in UART2 Channel)\nThis bit can change the RTS trigger level.\n</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Low level triggered</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>High level triggered</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RTS_ST</name>
              <description>RTS Pin State (Read Only) (Not Available in UART2 Channel)\nThis bit is the output pin status of RTS.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UA_MSR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UA_MSR</displayName>
          <description>UART Modem Status Register\nReserved</description>
          <addressOffset>0x14</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000001</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DCTSF</name>
              <description>Detect CTS State Change Flag (Read Only) (Not Available in UART2 Channel)\nThis bit is set whenever CTS input has change state, and it will generate Modem interrupt to CPU when UA_IER [MODEM_IEN] is set to 1.\nWrite 1 to clear this bit to 0.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>CTS_ST</name>
              <description>CTS Pin Status (Read Only) (Not Available in UART2 Channel)\nThis bit is the pin status of CTS.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>LEV_CTS</name>
              <description>CTS Trigger Level (Not Available in UART2 Channel)\nThis bit can change the CTS trigger level.\n</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Low level triggered</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>High level triggered</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UA_FSR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UA_FSR</displayName>
          <description>UART FIFO Status Register</description>
          <addressOffset>0x18</addressOffset>
          <access>read-write</access>
          <resetValue>0x10404000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RX_OVER_IF</name>
              <description>RX Overflow Error IF (Read Only)\nThis bit is set when RX FIFO overflow.\nIf the number of bytes of received data is greater than RX_FIFO (UA_RBR) size, 64/16 bytes of UART0/UART1, this bit will be set.\nNote: This bit is read only, but can be cleared by writing '1' to it.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RS485_ADD_DETF</name>
              <description>RS-485 Address Byte Detection Flag (NuMicro( NUC100/NUC120Low Density Only)\nNote: This field is used for RS-485 function mode.\nNote: This bit is read only, but can be cleared by writing '1' to it.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PEF</name>
              <description>Parity Error Flag (Read Only)\nThis bit is set to logic 1 whenever the received character does not have a valid "parity bit", and is reset whenever the CPU writes 1 to this bit.\nNote: This bit is read only, but can be cleared by writing '1' to it.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>FEF</name>
              <description>Framing Error Flag (Read Only)\nThis bit is set to logic 1 whenever the received character does not have a valid "stop bit" (that is, the stop bit following the last data bit or parity bit is detected as logic 0), and is reset whenever the CPU writes 1 to this bit.\nNote: This bit is read only, but can be cleared by writing '1' to it.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>BIF</name>
              <description>Break Interrupt Flag (Read Only)\nThis bit is set to a logic 1 whenever the received data input(RX) is held in the "spacing state" (logic 0) for longer than a full word transmission time (that is, the total time of "start bit" + data bits + parity + stop bits) and is reset whenever the CPU writes 1 to this bit.\nNote:Note: This bit is read only, but can be cleared by writing '1' to it.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RX_POINTER</name>
              <description>RX FIFO Pointer (Read Only)\nThis field indicates the RX FIFO Buffer Pointer. When UART receives one byte from external device, RX_POINTER increases one. When one byte of RX FIFO is read by CPU, RX_POINTER decreases one.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RX_EMPTY</name>
              <description>Receiver FIFO Empty (Read Only)\nThis bit initiates RX FIFO empty or not.\nWhen the last byte of RX FIFO has been read by CPU, hardware sets this bit high. It will be cleared when UART receives any new data.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TX_POINTER</name>
              <description>TX FIFO Pointer (Read Only)\nThis field indicates the TX FIFO Buffer Pointer. When CPU writes one byte into UA_THR, TX_POINTER increases one. When one byte of TX FIFO is transferred to Transmitter Shift Register, TX_POINTER decreases one.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TX_EMPTY</name>
              <description>Transmitter FIFO Empty (Read Only)\nThis bit indicates TX FIFO empty or not.\nWhen the last byte of TX FIFO has been transferred to Transmitter Shift Register, hardware sets this bit high. It will be cleared when writing data into THR (TX FIFO not empty).</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TX_OVER_IF</name>
              <description>TX Overflow Error Interrupt Flag (Read Only)\nIf TX FIFO (UA_THR) is full, an additional write to UA_THR will cause this bit to logic 1. \nNote: This bit is read only, but can be cleared by writing '1' to it.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TE_FLAG</name>
              <description>Transmitter Empty Flag (Read Only)\nBit is set by hardware when TX FIFO (UA_THR) is empty and the STOP bit of the last byte has been transmitted.\nBit is cleared automatically when TX FIFO is not empty or the last byte transmission has not completed.</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UA_ISR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UA_ISR</displayName>
          <description>UART Interrupt Status Register</description>
          <addressOffset>0x1C</addressOffset>
          <access>read-write</access>
          <resetValue>0x0000000A</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RDA_IF</name>
              <description>Receive Data Available Interrupt Flag (Read Only).\nWhen the number of bytes in the RX FIFO equals the RFITL then the RDA_IF will be set. If UA_IER [RDA_IEN] is enabled, the RDA interrupt will be generated. \nNote: This bit is read only and it will be cleared when the number of unread bytes of RX FIFO drops below the threshold level (RFITL).</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>THRE_IF</name>
              <description>Transmit Holding Register Empty Interrupt Flag (Read Only). \nThis bit is set when the last data of TX FIFO is transferred to Transmitter Shift Register. If UA_IER [THRE_IEN] is enabled, the THRE interrupt will be generated.\nNote: This bit is read only and it will be cleared when writing data into THR (TX FIFO not empty).</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RLS_IF</name>
              <description>Receive Line Interrupt Flag (Read Only).\nThis bit is set when the RX receive data have parity error, framing error or break error (at least one of 3 bits, BIF, FEF and PEF, is set). If UA_IER [RLS_IEN] is enabled, the RLS interrupt will be generated.\nNote: This bit is read only and reset to 0 when all bits of BIF, FEF and PEF are cleared.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>MODEM_IF</name>
              <description>MODEM Interrupt Flag (Read Only) (Not Available in UART2 Channel)\nNote: This bit is read only and reset to 0 when bit DCTSF is cleared by a write 1 on DCTSF.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TOUT_IF</name>
              <description>Time Out Interrupt Flag (Read Only)\nThis bit is set when the RX FIFO is not empty and no activities occurred in the RX FIFO and the time out counter equal to TOIC. If UA_IER [TOUT_IEN] is enabled, the Tout interrupt will be generated. \nNote: This bit is read only and user can read UA_RBR (RX is in active) to clear it.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>BUF_ERR_IF</name>
              <description>Buffer Error Interrupt Flag (Read Only)\nThis bit is set when the TX or RX FIFO overflows or Break Interrupt Flag or Parity Error Flag or Frame Error Flag (TX_OVER_IF or RX_OVER_IF or BIF or PEF or FEF) is set. When BUF_ERR_IF is set, the transfer is not correct. If UA_IER [BUF_ERR_IEN] is enabled, the buffer error interrupt will be generated.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RDA_INT</name>
              <description>Receive Data Available Interrupt Indicator (Read Only).\nThis bit is set if RDA_IEN and RDA_IF are both set to 1.\n</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No RDA interrupt is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RDA interrupt is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>THRE_INT</name>
              <description>Transmit Holding Register Empty Interrupt Indicator (Read Only)\nThis bit is set if THRE_IEN and THRE_IF are both set to 1.\n</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No THRE interrupt is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>THRE interrupt is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>RLS_INT</name>
              <description>Receive Line Status Interrupt Indicator (Read Only). \nThis bit is set if RLS_IEN and RLS_IF are both set to 1.\n</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No RLS interrupt is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RLS interrupt is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>MODEM_INT</name>
              <description>MODEM Status Interrupt Indicator (Read Only) (Not Available in UART2 Channel)\nThis bit is set if MODEM_IEN and MODEM_IF are both set to 1.\n</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No Modem interrupt is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Modem interrupt is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>TOUT_INT</name>
              <description>Time Out Interrupt Indicator (Read Only)\nThis bit is set if TOUT_IEN and TOUT_IF are both set to 1.\n</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No Tout interrupt is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Tout interrupt is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>BUF_ERR_INT</name>
              <description>Buffer Error Interrupt Indicator (Read Only)\nThis bit is set if BUF_ERR_IEN and BUF_ERR_IF are both set to 1.\n</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No buffer error interrupt is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Buffer error interrupt is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>HW_RLS_IF</name>
              <description>In DMA Mode, Receive Line Status Flag (Read Only)\nThis bit is set when the RX receive data have parity error, framing error or break error (at least one of 3 bits, BIF, FEF and PEF, is set). If UA_IER [RLS_IEN] is enabled, the RLS interrupt will be generated.\nNote: This bit is read only and reset to 0 when all bits of BIF, FEF and PEF are cleared.</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>HW_MODEM_IF</name>
              <description>In DMA Mode, MODEM Interrupt Flag (Read Only) (Not Available in UART2 Channel)\nNote: This bit is read only and reset to 0 when bit DCTSF is cleared by a write 1 on DCTSF.</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>HW_TOUT_IF</name>
              <description>In DMA Mode, Time Out Interrupt Flag (Read Only)\nThis bit is set when the RX FIFO is not empty and no activities occurred in the RX FIFO and the time out counter equal to TOIC. If UA_IER [TOUT_IEN] is enabled, the Tout interrupt will be generated. \nNote: This bit is read only and user can read UA_RBR (RX is in active) to clear it.</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>HW_BUF_ERR_IF</name>
              <description>In DMA Mode, Buffer Error Interrupt Flag (Read Only)\nThis bit is set when the TX or RX FIFO overflows (TX_OVER_IF or RX_OVER_IF is set). When BUF_ERR_IF is set, the transfer maybe is not correct. If UA_IER [BUF_ERR_IEN] is enabled, the buffer error interrupt will be generated.\nNote: This bit is cleared when both TX_OVER_IF and RX_OVER_IF are cleared.</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>HW_RLS_INT</name>
              <description>In DMA Mode, Receive Line Status Interrupt Indicator (Read Only)\nThis bit is set if RLS_IEN and HW_RLS_IF are both set to 1.\n</description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No RLS interrupt is generated in DMA mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RLS interrupt is generated in DMA mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>HW_MODEM_INT</name>
              <description>In DMA Mode, MODEM Status Interrupt Indicator (Read Only)&#160; (Not Available in UART2 Channel)\nThis bit is set if MODEM_IEN and HW_MODEM_IF are both set to 1.\n</description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No Modem interrupt is generated in DMA mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Modem interrupt is generated in DMA mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>HW_TOUT_INT</name>
              <description>In DMA Mode, Time Out Interrupt Indicator (Read Only)\nThis bit is set if TOUT_IEN and HW_TOUT_IF are both set to 1.\n</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No Tout interrupt is generated in DMA mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Tout interrupt is generated in DMA mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>HW_BUF_ERR_INT</name>
              <description>In DMA Mode, Buffer Error Interrupt Indicator (Read Only)\nThis bit is set if BUF_ERR_IEN and HW_BUF_ERR_IF are both set to 1.\n</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No buffer error interrupt is generated in DMA mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Buffer error interrupt is generated in DMA mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UA_TOR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UA_TOR</displayName>
          <description>UART Time Out Register</description>
          <addressOffset>0x20</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TOIC</name>
              <description>Time Out Interrupt Comparator\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DLY</name>
              <description>TX Delay Time Value (NuMicro( NUC100/NUC120 Low Density Only)\nThis field is use to programming the transfer delay time between the last stop bit and next start bit.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UA_BAUD</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UA_BAUD</displayName>
          <description>UART Baud Rate Divisor Register</description>
          <addressOffset>0x24</addressOffset>
          <access>read-write</access>
          <resetValue>0x0F000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BRD</name>
              <description>Baud Rate Divider\nThe field indicates the baud rate divider.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DIVIDER_X</name>
              <description>Divider X\n</description>
              <bitOffset>24</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DIV_X_ONE</name>
              <description>Divider X Equal to 1\nRefer to the Table 513 below for more information.</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Divider M = X (the equation of M = X+1, but DIVIDER_X[27:24] must &gt;= 8)</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Divider M = 1 (the equation of M = 1, but BRD [15:0] must &gt;= 3)</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DIV_X_EN</name>
              <description>Divider X Enable\nRefer to the table below for more information.\nNote: In IrDA mode, this bit must be disabled.</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Divider X Disabled (the equation of M = 16)</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Divider X Enabled (the equation of M = X+1, but DIVIDER_X [27:24] must &gt;= 8)</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UA_IRCR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UA_IRCR</displayName>
          <description>UART IrDA Control Register</description>
          <addressOffset>0x28</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000040</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TX_SELECT</name>
              <description>TX_SELECT\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>IrDA receiver Enabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>IrDA transmitter Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>INV_TX</name>
              <description>INV_TX\n</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No inversion</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Inverse TX output signal</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>INV_RX</name>
              <description>INV_RX\n</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No inversion</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Inverse RX input signal</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UA_ALT_CSR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UA_ALT_CSR</displayName>
          <description>UART Alternate Control/Status Register</description>
          <addressOffset>0x2C</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RS485_NMM</name>
              <description>RS-485 Normal Multi-drop Operation Mode (NMM) (NuMicro( NUC100/NUC120 Low Density Only)\nNote: It can't be active with RS-485_AAD operation mode.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RS-485 Normal Multi-drop Operation mode (NMM) Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RS-485 Normal Multi-drop Operation mode (NMM) Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RS485_AAD</name>
              <description>RS-485 Auto Address Detection Operation Mode (AAD) (NuMicro( NUC100/NUC120 Low Density Only)\nNote: It can't be active with RS-485_NMM operation mode.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RS-485 Auto Address Detection Operation Mode (AAD) Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RS-485 Auto Address Detection Operation Mode (AAD) Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RS485_AUD</name>
              <description>RS-485 Auto Direction Mode (AUD) (NuMicro( NUC100/NUC120 Low Density Only)\nNote: It can be active with RS-485_AAD or RS-485_NMM operation mode.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RS-485 Auto Direction Operation Mode (AUO) Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RS-485 Auto Direction Operation mode (AUO) Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RS485_ADD_EN</name>
              <description>RS-485 Address Detection Enable (NuMicro( NUC100/NUC120 Low Density Only)\nThis bit is use to enable RS-485 address detection mode. \nNote: This field is used for RS-485 any operation mode.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Address detection mode Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Address detection mode Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ADDR_MATCH</name>
              <description>Address Match Value Register (NuMicro( NUC100/NUC120 Low Density Only)\nThis field contains the RS-485 address match values.\nNote: This field is used for RS-485 auto address detection mode.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UA_FUN_SEL</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UA_FUN_SEL</displayName>
          <description>UART Function Select Register</description>
          <addressOffset>0x30</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>FUN_SEL</name>
              <description>Function Select Enable\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>UART function</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reserved</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>IrDA function Enabled</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>RS-485 Function Enabled (NuMicro( NUC100/NUC120 Low Density Only)</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>UART1</name>
      <description>UART Register Map</description>
      <groupName>UART</groupName>
      <baseAddress>0x40150000</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x0</offset>
        <size>0x34</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>UA_RBR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UA_RBR</displayName>
          <description>UART Receive Buffer Register</description>
          <addressOffset>0x0</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>RBR</name>
              <description>Receive Buffer Register (Read Only)\nBy reading this register, the UART will return an 8-bit data received from RX pin (LSB first).</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UA_THR</name>
          <alternateRegister>UA_RBR</alternateRegister>
          <!-- the display name is an unrestricted string. -->
          <displayName>UA_THR</displayName>
          <description>UART Transmit Holding Register</description>
          <addressOffset>0x0</addressOffset>
          <access>write-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>THR</name>
              <description>Transmit Holding Register\nBy writing to this register, the UART will send out an 8-bit data through the TX pin (LSB first).</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UA_IER</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UA_IER</displayName>
          <description>UART Interrupt Enable Register</description>
          <addressOffset>0x4</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RDA_IEN</name>
              <description>Receive Data Available Interrupt Enable.\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>INT_RDA Masked off</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>INT_RDA Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>THRE_IEN</name>
              <description>Transmit Holding Register Empty Interrupt Enable\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>INT_THRE Masked off</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>INT_THRE Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RLS_IEN</name>
              <description>Receive Line Status Interrupt Enable \n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>INT_RLS Masked off</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>INT_RLS Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>MODEM_IEN</name>
              <description>Modem Status Interrupt Enable (Not Available in UART2 Channel)\n</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>INT_MODEM Masked off</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>INT_MODEM Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RTO_IEN</name>
              <description>RX Time Out Interrupt Enable\n</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>INT_TOUT Masked off</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>INT_TOUT Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BUF_ERR_IEN</name>
              <description>Buffer Error Interrupt Enable\n</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>INT_BUF_ERR Maskdd off</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>INT_BUF_ERR Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>WAKE_EN</name>
              <description>UART Wake-up Function Enable (Not Available in UART2 Channel)\n</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>UART wake-up function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>UART wake-up function Enabled; when the chip is in Power-down mode, an external CTS change will wake-up chip from Power-down mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TIME_OUT_EN</name>
              <description>Time Out Counter Enable\n</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Time-out counter Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Time-out counter Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>AUTO_RTS_EN</name>
              <description>RTS Auto Flow Control Enable (Not Available in UART2 Channel)\nWhen RTS auto-flow is enabled, if the number of bytes in the RX FIFO equals the UA_FCR [RTS_TRI_LEV], the UART will de-assert RTS signal.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RTS auto flow control Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RTS auto flow control Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>AUTO_CTS_EN</name>
              <description>CTS Auto Flow Control Enable (Not Available in UART2 Channel)\nWhen CTS auto-flow is enabled, the UART will send data to external device when CTS input assert (UART will not send data to device until CTS is asserted).</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>CTS auto flow control Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>CTS auto flow control Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DMA_TX_EN</name>
              <description>TX DMA Enable (Not Available in UART2 Channel)\nThis bit can enable or disable TX DMA service.\n</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>TX DMA Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>TX DMA Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DMA_RX_EN</name>
              <description>RX DMA Enable (Not Available in UART2 Channel)\nThis bit can enable or disable RX DMA service.\n</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RX DMA Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RX DMA Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UA_FCR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UA_FCR</displayName>
          <description>UART FIFO Control Register</description>
          <addressOffset>0x8</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000101</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RFR</name>
              <description>RX Field Software Reset\nWhen RX_RST is set, all the byte in the receiver FIFO and RX internal state machine are cleared.\nNote: This bit will automatically clear at least 3 UART engine clock cycles.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reset the RX internal state machine and pointers</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TFR</name>
              <description>TX Field Software Reset\nWhen TX_RST is set, all the byte in the transmit FIFO and TX internal state machine are cleared.\nNote: This bit will automatically clear at least 3 UART engine clock cycles.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reset the TX internal state machine and pointers</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RFITL</name>
              <description>RX FIFO Interrupt (INT_RDA) Trigger Level\n</description>
              <bitOffset>4</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_DIS</name>
              <description>Receiver Disable Register.\nThe receiver is disabled or not (set 1  to disable receiver)\nNote: This field is used for RS-485 Normal Multi-drop mode. It should be programmed before UA_ALT_CSR [RS-485_NMM] is programmed.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Receiver Enabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Receiver Disabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RTS_TRI_LEV</name>
              <description>RTS Trigger Level for Auto-flow Control Use (Not Available in UART2 Channel)\n</description>
              <bitOffset>16</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UA_LCR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UA_LCR</displayName>
          <description>UART Line Control Register</description>
          <addressOffset>0xC</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WLS</name>
              <description>Word Length Selection\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>NSB</name>
              <description>Number of "STOP bit"\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>1 STOP bit</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>2 STOP bits (1.5 STOP bits if WLS[1:0]=00)</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PBE</name>
              <description>Parity Bit Enable\n</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No parity bit</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Parity bit is generated on each outgoing character and is checked on each incoming data</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>EPE</name>
              <description>Even Parity Enable\nThis bit has effect only when bit 3 (parity bit enable) is set.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Odd number of logic 1's is transmitted and checked in each word</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Even number of logic 1's is transmitted and checked in each word</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SPE</name>
              <description>Stick Parity Enable\n</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Stick parity Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>If bit 3 and 4 are logic 1, the parity bit is transmitted and checked as logic 0. If bit 3 is 1 and bit 4 is 0 then the parity bit is transmitted and checked as 1</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BCB</name>
              <description>Break Control Bit\nWhen this bit is set to logic 1, the serial data output (TX) is forced to the Spacing State (logic 0). This bit acts only on TX and has no effect on the transmitter logic.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UA_MCR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UA_MCR</displayName>
          <description>UART Modem Control Register\nReserved</description>
          <addressOffset>0x10</addressOffset>
          <access>read-write</access>
          <resetValue>0x00002000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RTS</name>
              <description>RTS (Request-To-Send) Signal (Not Available in UART2 Channel)\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Drive RTS pin to logic 1 (If the LEV_RTS set to low level triggered).\nDrive RTS pin to logic 0 (If the LEV_RTS set to high level triggered)</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Drive RTS pin to logic 0 (If the LEV_RTS set to low level triggered).\nDrive RTS pin to logic 1 (If the LEV_RTS set to high level triggered)</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>LEV_RTS</name>
              <description>RTS Trigger Level (Not Available in UART2 Channel)\nThis bit can change the RTS trigger level.\n</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Low level triggered</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>High level triggered</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RTS_ST</name>
              <description>RTS Pin State (Read Only) (Not Available in UART2 Channel)\nThis bit is the output pin status of RTS.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UA_MSR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UA_MSR</displayName>
          <description>UART Modem Status Register\nReserved</description>
          <addressOffset>0x14</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000001</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DCTSF</name>
              <description>Detect CTS State Change Flag (Read Only) (Not Available in UART2 Channel)\nThis bit is set whenever CTS input has change state, and it will generate Modem interrupt to CPU when UA_IER [MODEM_IEN] is set to 1.\nWrite 1 to clear this bit to 0.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>CTS_ST</name>
              <description>CTS Pin Status (Read Only) (Not Available in UART2 Channel)\nThis bit is the pin status of CTS.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>LEV_CTS</name>
              <description>CTS Trigger Level (Not Available in UART2 Channel)\nThis bit can change the CTS trigger level.\n</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Low level triggered</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>High level triggered</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UA_FSR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UA_FSR</displayName>
          <description>UART FIFO Status Register</description>
          <addressOffset>0x18</addressOffset>
          <access>read-write</access>
          <resetValue>0x10404000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RX_OVER_IF</name>
              <description>RX Overflow Error IF (Read Only)\nThis bit is set when RX FIFO overflow.\nIf the number of bytes of received data is greater than RX_FIFO (UA_RBR) size, 64/16 bytes of UART0/UART1, this bit will be set.\nNote: This bit is read only, but can be cleared by writing '1' to it.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RS485_ADD_DETF</name>
              <description>RS-485 Address Byte Detection Flag (NuMicro( NUC100/NUC120Low Density Only)\nNote: This field is used for RS-485 function mode.\nNote: This bit is read only, but can be cleared by writing '1' to it.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PEF</name>
              <description>Parity Error Flag (Read Only)\nThis bit is set to logic 1 whenever the received character does not have a valid "parity bit", and is reset whenever the CPU writes 1 to this bit.\nNote: This bit is read only, but can be cleared by writing '1' to it.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>FEF</name>
              <description>Framing Error Flag (Read Only)\nThis bit is set to logic 1 whenever the received character does not have a valid "stop bit" (that is, the stop bit following the last data bit or parity bit is detected as logic 0), and is reset whenever the CPU writes 1 to this bit.\nNote: This bit is read only, but can be cleared by writing '1' to it.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>BIF</name>
              <description>Break Interrupt Flag (Read Only)\nThis bit is set to a logic 1 whenever the received data input(RX) is held in the "spacing state" (logic 0) for longer than a full word transmission time (that is, the total time of "start bit" + data bits + parity + stop bits) and is reset whenever the CPU writes 1 to this bit.\nNote:Note: This bit is read only, but can be cleared by writing '1' to it.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RX_POINTER</name>
              <description>RX FIFO Pointer (Read Only)\nThis field indicates the RX FIFO Buffer Pointer. When UART receives one byte from external device, RX_POINTER increases one. When one byte of RX FIFO is read by CPU, RX_POINTER decreases one.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RX_EMPTY</name>
              <description>Receiver FIFO Empty (Read Only)\nThis bit initiates RX FIFO empty or not.\nWhen the last byte of RX FIFO has been read by CPU, hardware sets this bit high. It will be cleared when UART receives any new data.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TX_POINTER</name>
              <description>TX FIFO Pointer (Read Only)\nThis field indicates the TX FIFO Buffer Pointer. When CPU writes one byte into UA_THR, TX_POINTER increases one. When one byte of TX FIFO is transferred to Transmitter Shift Register, TX_POINTER decreases one.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TX_EMPTY</name>
              <description>Transmitter FIFO Empty (Read Only)\nThis bit indicates TX FIFO empty or not.\nWhen the last byte of TX FIFO has been transferred to Transmitter Shift Register, hardware sets this bit high. It will be cleared when writing data into THR (TX FIFO not empty).</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TX_OVER_IF</name>
              <description>TX Overflow Error Interrupt Flag (Read Only)\nIf TX FIFO (UA_THR) is full, an additional write to UA_THR will cause this bit to logic 1. \nNote: This bit is read only, but can be cleared by writing '1' to it.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TE_FLAG</name>
              <description>Transmitter Empty Flag (Read Only)\nBit is set by hardware when TX FIFO (UA_THR) is empty and the STOP bit of the last byte has been transmitted.\nBit is cleared automatically when TX FIFO is not empty or the last byte transmission has not completed.</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UA_ISR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UA_ISR</displayName>
          <description>UART Interrupt Status Register</description>
          <addressOffset>0x1C</addressOffset>
          <access>read-write</access>
          <resetValue>0x0000000A</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RDA_IF</name>
              <description>Receive Data Available Interrupt Flag (Read Only).\nWhen the number of bytes in the RX FIFO equals the RFITL then the RDA_IF will be set. If UA_IER [RDA_IEN] is enabled, the RDA interrupt will be generated. \nNote: This bit is read only and it will be cleared when the number of unread bytes of RX FIFO drops below the threshold level (RFITL).</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>THRE_IF</name>
              <description>Transmit Holding Register Empty Interrupt Flag (Read Only). \nThis bit is set when the last data of TX FIFO is transferred to Transmitter Shift Register. If UA_IER [THRE_IEN] is enabled, the THRE interrupt will be generated.\nNote: This bit is read only and it will be cleared when writing data into THR (TX FIFO not empty).</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RLS_IF</name>
              <description>Receive Line Interrupt Flag (Read Only).\nThis bit is set when the RX receive data have parity error, framing error or break error (at least one of 3 bits, BIF, FEF and PEF, is set). If UA_IER [RLS_IEN] is enabled, the RLS interrupt will be generated.\nNote: This bit is read only and reset to 0 when all bits of BIF, FEF and PEF are cleared.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>MODEM_IF</name>
              <description>MODEM Interrupt Flag (Read Only) (Not Available in UART2 Channel)\nNote: This bit is read only and reset to 0 when bit DCTSF is cleared by a write 1 on DCTSF.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TOUT_IF</name>
              <description>Time Out Interrupt Flag (Read Only)\nThis bit is set when the RX FIFO is not empty and no activities occurred in the RX FIFO and the time out counter equal to TOIC. If UA_IER [TOUT_IEN] is enabled, the Tout interrupt will be generated. \nNote: This bit is read only and user can read UA_RBR (RX is in active) to clear it.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>BUF_ERR_IF</name>
              <description>Buffer Error Interrupt Flag (Read Only)\nThis bit is set when the TX or RX FIFO overflows or Break Interrupt Flag or Parity Error Flag or Frame Error Flag (TX_OVER_IF or RX_OVER_IF or BIF or PEF or FEF) is set. When BUF_ERR_IF is set, the transfer is not correct. If UA_IER [BUF_ERR_IEN] is enabled, the buffer error interrupt will be generated.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RDA_INT</name>
              <description>Receive Data Available Interrupt Indicator (Read Only).\nThis bit is set if RDA_IEN and RDA_IF are both set to 1.\n</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No RDA interrupt is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RDA interrupt is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>THRE_INT</name>
              <description>Transmit Holding Register Empty Interrupt Indicator (Read Only)\nThis bit is set if THRE_IEN and THRE_IF are both set to 1.\n</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No THRE interrupt is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>THRE interrupt is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>RLS_INT</name>
              <description>Receive Line Status Interrupt Indicator (Read Only). \nThis bit is set if RLS_IEN and RLS_IF are both set to 1.\n</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No RLS interrupt is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RLS interrupt is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>MODEM_INT</name>
              <description>MODEM Status Interrupt Indicator (Read Only) (Not Available in UART2 Channel)\nThis bit is set if MODEM_IEN and MODEM_IF are both set to 1.\n</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No Modem interrupt is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Modem interrupt is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>TOUT_INT</name>
              <description>Time Out Interrupt Indicator (Read Only)\nThis bit is set if TOUT_IEN and TOUT_IF are both set to 1.\n</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No Tout interrupt is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Tout interrupt is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>BUF_ERR_INT</name>
              <description>Buffer Error Interrupt Indicator (Read Only)\nThis bit is set if BUF_ERR_IEN and BUF_ERR_IF are both set to 1.\n</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No buffer error interrupt is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Buffer error interrupt is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>HW_RLS_IF</name>
              <description>In DMA Mode, Receive Line Status Flag (Read Only)\nThis bit is set when the RX receive data have parity error, framing error or break error (at least one of 3 bits, BIF, FEF and PEF, is set). If UA_IER [RLS_IEN] is enabled, the RLS interrupt will be generated.\nNote: This bit is read only and reset to 0 when all bits of BIF, FEF and PEF are cleared.</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>HW_MODEM_IF</name>
              <description>In DMA Mode, MODEM Interrupt Flag (Read Only) (Not Available in UART2 Channel)\nNote: This bit is read only and reset to 0 when bit DCTSF is cleared by a write 1 on DCTSF.</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>HW_TOUT_IF</name>
              <description>In DMA Mode, Time Out Interrupt Flag (Read Only)\nThis bit is set when the RX FIFO is not empty and no activities occurred in the RX FIFO and the time out counter equal to TOIC. If UA_IER [TOUT_IEN] is enabled, the Tout interrupt will be generated. \nNote: This bit is read only and user can read UA_RBR (RX is in active) to clear it.</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>HW_BUF_ERR_IF</name>
              <description>In DMA Mode, Buffer Error Interrupt Flag (Read Only)\nThis bit is set when the TX or RX FIFO overflows (TX_OVER_IF or RX_OVER_IF is set). When BUF_ERR_IF is set, the transfer maybe is not correct. If UA_IER [BUF_ERR_IEN] is enabled, the buffer error interrupt will be generated.\nNote: This bit is cleared when both TX_OVER_IF and RX_OVER_IF are cleared.</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>HW_RLS_INT</name>
              <description>In DMA Mode, Receive Line Status Interrupt Indicator (Read Only)\nThis bit is set if RLS_IEN and HW_RLS_IF are both set to 1.\n</description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No RLS interrupt is generated in DMA mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RLS interrupt is generated in DMA mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>HW_MODEM_INT</name>
              <description>In DMA Mode, MODEM Status Interrupt Indicator (Read Only)&#160; (Not Available in UART2 Channel)\nThis bit is set if MODEM_IEN and HW_MODEM_IF are both set to 1.\n</description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No Modem interrupt is generated in DMA mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Modem interrupt is generated in DMA mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>HW_TOUT_INT</name>
              <description>In DMA Mode, Time Out Interrupt Indicator (Read Only)\nThis bit is set if TOUT_IEN and HW_TOUT_IF are both set to 1.\n</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No Tout interrupt is generated in DMA mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Tout interrupt is generated in DMA mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>HW_BUF_ERR_INT</name>
              <description>In DMA Mode, Buffer Error Interrupt Indicator (Read Only)\nThis bit is set if BUF_ERR_IEN and HW_BUF_ERR_IF are both set to 1.\n</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No buffer error interrupt is generated in DMA mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Buffer error interrupt is generated in DMA mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UA_TOR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UA_TOR</displayName>
          <description>UART Time Out Register</description>
          <addressOffset>0x20</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TOIC</name>
              <description>Time Out Interrupt Comparator\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DLY</name>
              <description>TX Delay Time Value (NuMicro( NUC100/NUC120 Low Density Only)\nThis field is use to programming the transfer delay time between the last stop bit and next start bit.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UA_BAUD</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UA_BAUD</displayName>
          <description>UART Baud Rate Divisor Register</description>
          <addressOffset>0x24</addressOffset>
          <access>read-write</access>
          <resetValue>0x0F000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BRD</name>
              <description>Baud Rate Divider\nThe field indicates the baud rate divider.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DIVIDER_X</name>
              <description>Divider X\n</description>
              <bitOffset>24</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DIV_X_ONE</name>
              <description>Divider X Equal to 1\nRefer to the Table 513 below for more information.</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Divider M = X (the equation of M = X+1, but DIVIDER_X[27:24] must &gt;= 8)</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Divider M = 1 (the equation of M = 1, but BRD [15:0] must &gt;= 3)</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DIV_X_EN</name>
              <description>Divider X Enable\nRefer to the table below for more information.\nNote: In IrDA mode, this bit must be disabled.</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Divider X Disabled (the equation of M = 16)</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Divider X Enabled (the equation of M = X+1, but DIVIDER_X [27:24] must &gt;= 8)</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UA_IRCR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UA_IRCR</displayName>
          <description>UART IrDA Control Register</description>
          <addressOffset>0x28</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000040</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TX_SELECT</name>
              <description>TX_SELECT\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>IrDA receiver Enabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>IrDA transmitter Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>INV_TX</name>
              <description>INV_TX\n</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No inversion</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Inverse TX output signal</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>INV_RX</name>
              <description>INV_RX\n</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No inversion</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Inverse RX input signal</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UA_ALT_CSR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UA_ALT_CSR</displayName>
          <description>UART Alternate Control/Status Register</description>
          <addressOffset>0x2C</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RS485_NMM</name>
              <description>RS-485 Normal Multi-drop Operation Mode (NMM) (NuMicro( NUC100/NUC120 Low Density Only)\nNote: It can't be active with RS-485_AAD operation mode.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RS-485 Normal Multi-drop Operation mode (NMM) Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RS-485 Normal Multi-drop Operation mode (NMM) Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RS485_AAD</name>
              <description>RS-485 Auto Address Detection Operation Mode (AAD) (NuMicro( NUC100/NUC120 Low Density Only)\nNote: It can't be active with RS-485_NMM operation mode.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RS-485 Auto Address Detection Operation Mode (AAD) Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RS-485 Auto Address Detection Operation Mode (AAD) Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RS485_AUD</name>
              <description>RS-485 Auto Direction Mode (AUD) (NuMicro( NUC100/NUC120 Low Density Only)\nNote: It can be active with RS-485_AAD or RS-485_NMM operation mode.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RS-485 Auto Direction Operation Mode (AUO) Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RS-485 Auto Direction Operation mode (AUO) Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RS485_ADD_EN</name>
              <description>RS-485 Address Detection Enable (NuMicro( NUC100/NUC120 Low Density Only)\nThis bit is use to enable RS-485 address detection mode. \nNote: This field is used for RS-485 any operation mode.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Address detection mode Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Address detection mode Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ADDR_MATCH</name>
              <description>Address Match Value Register (NuMicro( NUC100/NUC120 Low Density Only)\nThis field contains the RS-485 address match values.\nNote: This field is used for RS-485 auto address detection mode.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UA_FUN_SEL</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UA_FUN_SEL</displayName>
          <description>UART Function Select Register</description>
          <addressOffset>0x30</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>FUN_SEL</name>
              <description>Function Select Enable\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>UART function</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reserved</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>IrDA function Enabled</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>RS-485 Function Enabled (NuMicro( NUC100/NUC120 Low Density Only)</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>UART2</name>
      <description>UART Register Map</description>
      <groupName>UART</groupName>
      <baseAddress>0x40154000</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x0</offset>
        <size>0x34</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>UA_RBR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UA_RBR</displayName>
          <description>UART Receive Buffer Register</description>
          <addressOffset>0x0</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>RBR</name>
              <description>Receive Buffer Register (Read Only)\nBy reading this register, the UART will return an 8-bit data received from RX pin (LSB first).</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UA_THR</name>
          <alternateRegister>UA_RBR</alternateRegister>
          <!-- the display name is an unrestricted string. -->
          <displayName>UA_THR</displayName>
          <description>UART Transmit Holding Register</description>
          <addressOffset>0x0</addressOffset>
          <access>write-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>THR</name>
              <description>Transmit Holding Register\nBy writing to this register, the UART will send out an 8-bit data through the TX pin (LSB first).</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UA_IER</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UA_IER</displayName>
          <description>UART Interrupt Enable Register</description>
          <addressOffset>0x4</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RDA_IEN</name>
              <description>Receive Data Available Interrupt Enable.\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>INT_RDA Masked off</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>INT_RDA Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>THRE_IEN</name>
              <description>Transmit Holding Register Empty Interrupt Enable\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>INT_THRE Masked off</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>INT_THRE Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RLS_IEN</name>
              <description>Receive Line Status Interrupt Enable \n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>INT_RLS Masked off</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>INT_RLS Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>MODEM_IEN</name>
              <description>Modem Status Interrupt Enable (Not Available in UART2 Channel)\n</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>INT_MODEM Masked off</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>INT_MODEM Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RTO_IEN</name>
              <description>RX Time Out Interrupt Enable\n</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>INT_TOUT Masked off</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>INT_TOUT Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BUF_ERR_IEN</name>
              <description>Buffer Error Interrupt Enable\n</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>INT_BUF_ERR Maskdd off</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>INT_BUF_ERR Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>WAKE_EN</name>
              <description>UART Wake-up Function Enable (Not Available in UART2 Channel)\n</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>UART wake-up function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>UART wake-up function Enabled; when the chip is in Power-down mode, an external CTS change will wake-up chip from Power-down mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TIME_OUT_EN</name>
              <description>Time Out Counter Enable\n</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Time-out counter Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Time-out counter Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>AUTO_RTS_EN</name>
              <description>RTS Auto Flow Control Enable (Not Available in UART2 Channel)\nWhen RTS auto-flow is enabled, if the number of bytes in the RX FIFO equals the UA_FCR [RTS_TRI_LEV], the UART will de-assert RTS signal.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RTS auto flow control Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RTS auto flow control Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>AUTO_CTS_EN</name>
              <description>CTS Auto Flow Control Enable (Not Available in UART2 Channel)\nWhen CTS auto-flow is enabled, the UART will send data to external device when CTS input assert (UART will not send data to device until CTS is asserted).</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>CTS auto flow control Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>CTS auto flow control Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DMA_TX_EN</name>
              <description>TX DMA Enable (Not Available in UART2 Channel)\nThis bit can enable or disable TX DMA service.\n</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>TX DMA Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>TX DMA Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DMA_RX_EN</name>
              <description>RX DMA Enable (Not Available in UART2 Channel)\nThis bit can enable or disable RX DMA service.\n</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RX DMA Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RX DMA Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UA_FCR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UA_FCR</displayName>
          <description>UART FIFO Control Register</description>
          <addressOffset>0x8</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000101</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RFR</name>
              <description>RX Field Software Reset\nWhen RX_RST is set, all the byte in the receiver FIFO and RX internal state machine are cleared.\nNote: This bit will automatically clear at least 3 UART engine clock cycles.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reset the RX internal state machine and pointers</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TFR</name>
              <description>TX Field Software Reset\nWhen TX_RST is set, all the byte in the transmit FIFO and TX internal state machine are cleared.\nNote: This bit will automatically clear at least 3 UART engine clock cycles.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reset the TX internal state machine and pointers</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RFITL</name>
              <description>RX FIFO Interrupt (INT_RDA) Trigger Level\n</description>
              <bitOffset>4</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_DIS</name>
              <description>Receiver Disable Register.\nThe receiver is disabled or not (set 1  to disable receiver)\nNote: This field is used for RS-485 Normal Multi-drop mode. It should be programmed before UA_ALT_CSR [RS-485_NMM] is programmed.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Receiver Enabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Receiver Disabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RTS_TRI_LEV</name>
              <description>RTS Trigger Level for Auto-flow Control Use (Not Available in UART2 Channel)\n</description>
              <bitOffset>16</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UA_LCR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UA_LCR</displayName>
          <description>UART Line Control Register</description>
          <addressOffset>0xC</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WLS</name>
              <description>Word Length Selection\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>NSB</name>
              <description>Number of "STOP bit"\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>1 STOP bit</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>2 STOP bits (1.5 STOP bits if WLS[1:0]=00)</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PBE</name>
              <description>Parity Bit Enable\n</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No parity bit</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Parity bit is generated on each outgoing character and is checked on each incoming data</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>EPE</name>
              <description>Even Parity Enable\nThis bit has effect only when bit 3 (parity bit enable) is set.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Odd number of logic 1's is transmitted and checked in each word</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Even number of logic 1's is transmitted and checked in each word</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SPE</name>
              <description>Stick Parity Enable\n</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Stick parity Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>If bit 3 and 4 are logic 1, the parity bit is transmitted and checked as logic 0. If bit 3 is 1 and bit 4 is 0 then the parity bit is transmitted and checked as 1</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BCB</name>
              <description>Break Control Bit\nWhen this bit is set to logic 1, the serial data output (TX) is forced to the Spacing State (logic 0). This bit acts only on TX and has no effect on the transmitter logic.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UA_MCR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UA_MCR</displayName>
          <description>UART Modem Control Register\nReserved</description>
          <addressOffset>0x10</addressOffset>
          <access>read-write</access>
          <resetValue>0x00002000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RTS</name>
              <description>RTS (Request-To-Send) Signal (Not Available in UART2 Channel)\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Drive RTS pin to logic 1 (If the LEV_RTS set to low level triggered).\nDrive RTS pin to logic 0 (If the LEV_RTS set to high level triggered)</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Drive RTS pin to logic 0 (If the LEV_RTS set to low level triggered).\nDrive RTS pin to logic 1 (If the LEV_RTS set to high level triggered)</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>LEV_RTS</name>
              <description>RTS Trigger Level (Not Available in UART2 Channel)\nThis bit can change the RTS trigger level.\n</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Low level triggered</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>High level triggered</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RTS_ST</name>
              <description>RTS Pin State (Read Only) (Not Available in UART2 Channel)\nThis bit is the output pin status of RTS.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UA_MSR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UA_MSR</displayName>
          <description>UART Modem Status Register\nReserved</description>
          <addressOffset>0x14</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000001</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DCTSF</name>
              <description>Detect CTS State Change Flag (Read Only) (Not Available in UART2 Channel)\nThis bit is set whenever CTS input has change state, and it will generate Modem interrupt to CPU when UA_IER [MODEM_IEN] is set to 1.\nWrite 1 to clear this bit to 0.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>CTS_ST</name>
              <description>CTS Pin Status (Read Only) (Not Available in UART2 Channel)\nThis bit is the pin status of CTS.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>LEV_CTS</name>
              <description>CTS Trigger Level (Not Available in UART2 Channel)\nThis bit can change the CTS trigger level.\n</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Low level triggered</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>High level triggered</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UA_FSR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UA_FSR</displayName>
          <description>UART FIFO Status Register</description>
          <addressOffset>0x18</addressOffset>
          <access>read-write</access>
          <resetValue>0x10404000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RX_OVER_IF</name>
              <description>RX Overflow Error IF (Read Only)\nThis bit is set when RX FIFO overflow.\nIf the number of bytes of received data is greater than RX_FIFO (UA_RBR) size, 64/16 bytes of UART0/UART1, this bit will be set.\nNote: This bit is read only, but can be cleared by writing '1' to it.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RS485_ADD_DETF</name>
              <description>RS-485 Address Byte Detection Flag (NuMicro( NUC100/NUC120Low Density Only)\nNote: This field is used for RS-485 function mode.\nNote: This bit is read only, but can be cleared by writing '1' to it.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PEF</name>
              <description>Parity Error Flag (Read Only)\nThis bit is set to logic 1 whenever the received character does not have a valid "parity bit", and is reset whenever the CPU writes 1 to this bit.\nNote: This bit is read only, but can be cleared by writing '1' to it.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>FEF</name>
              <description>Framing Error Flag (Read Only)\nThis bit is set to logic 1 whenever the received character does not have a valid "stop bit" (that is, the stop bit following the last data bit or parity bit is detected as logic 0), and is reset whenever the CPU writes 1 to this bit.\nNote: This bit is read only, but can be cleared by writing '1' to it.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>BIF</name>
              <description>Break Interrupt Flag (Read Only)\nThis bit is set to a logic 1 whenever the received data input(RX) is held in the "spacing state" (logic 0) for longer than a full word transmission time (that is, the total time of "start bit" + data bits + parity + stop bits) and is reset whenever the CPU writes 1 to this bit.\nNote:Note: This bit is read only, but can be cleared by writing '1' to it.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RX_POINTER</name>
              <description>RX FIFO Pointer (Read Only)\nThis field indicates the RX FIFO Buffer Pointer. When UART receives one byte from external device, RX_POINTER increases one. When one byte of RX FIFO is read by CPU, RX_POINTER decreases one.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RX_EMPTY</name>
              <description>Receiver FIFO Empty (Read Only)\nThis bit initiates RX FIFO empty or not.\nWhen the last byte of RX FIFO has been read by CPU, hardware sets this bit high. It will be cleared when UART receives any new data.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TX_POINTER</name>
              <description>TX FIFO Pointer (Read Only)\nThis field indicates the TX FIFO Buffer Pointer. When CPU writes one byte into UA_THR, TX_POINTER increases one. When one byte of TX FIFO is transferred to Transmitter Shift Register, TX_POINTER decreases one.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TX_EMPTY</name>
              <description>Transmitter FIFO Empty (Read Only)\nThis bit indicates TX FIFO empty or not.\nWhen the last byte of TX FIFO has been transferred to Transmitter Shift Register, hardware sets this bit high. It will be cleared when writing data into THR (TX FIFO not empty).</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TX_OVER_IF</name>
              <description>TX Overflow Error Interrupt Flag (Read Only)\nIf TX FIFO (UA_THR) is full, an additional write to UA_THR will cause this bit to logic 1. \nNote: This bit is read only, but can be cleared by writing '1' to it.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TE_FLAG</name>
              <description>Transmitter Empty Flag (Read Only)\nBit is set by hardware when TX FIFO (UA_THR) is empty and the STOP bit of the last byte has been transmitted.\nBit is cleared automatically when TX FIFO is not empty or the last byte transmission has not completed.</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UA_ISR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UA_ISR</displayName>
          <description>UART Interrupt Status Register</description>
          <addressOffset>0x1C</addressOffset>
          <access>read-write</access>
          <resetValue>0x0000000A</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RDA_IF</name>
              <description>Receive Data Available Interrupt Flag (Read Only).\nWhen the number of bytes in the RX FIFO equals the RFITL then the RDA_IF will be set. If UA_IER [RDA_IEN] is enabled, the RDA interrupt will be generated. \nNote: This bit is read only and it will be cleared when the number of unread bytes of RX FIFO drops below the threshold level (RFITL).</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>THRE_IF</name>
              <description>Transmit Holding Register Empty Interrupt Flag (Read Only). \nThis bit is set when the last data of TX FIFO is transferred to Transmitter Shift Register. If UA_IER [THRE_IEN] is enabled, the THRE interrupt will be generated.\nNote: This bit is read only and it will be cleared when writing data into THR (TX FIFO not empty).</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RLS_IF</name>
              <description>Receive Line Interrupt Flag (Read Only).\nThis bit is set when the RX receive data have parity error, framing error or break error (at least one of 3 bits, BIF, FEF and PEF, is set). If UA_IER [RLS_IEN] is enabled, the RLS interrupt will be generated.\nNote: This bit is read only and reset to 0 when all bits of BIF, FEF and PEF are cleared.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>MODEM_IF</name>
              <description>MODEM Interrupt Flag (Read Only) (Not Available in UART2 Channel)\nNote: This bit is read only and reset to 0 when bit DCTSF is cleared by a write 1 on DCTSF.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TOUT_IF</name>
              <description>Time Out Interrupt Flag (Read Only)\nThis bit is set when the RX FIFO is not empty and no activities occurred in the RX FIFO and the time out counter equal to TOIC. If UA_IER [TOUT_IEN] is enabled, the Tout interrupt will be generated. \nNote: This bit is read only and user can read UA_RBR (RX is in active) to clear it.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>BUF_ERR_IF</name>
              <description>Buffer Error Interrupt Flag (Read Only)\nThis bit is set when the TX or RX FIFO overflows or Break Interrupt Flag or Parity Error Flag or Frame Error Flag (TX_OVER_IF or RX_OVER_IF or BIF or PEF or FEF) is set. When BUF_ERR_IF is set, the transfer is not correct. If UA_IER [BUF_ERR_IEN] is enabled, the buffer error interrupt will be generated.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RDA_INT</name>
              <description>Receive Data Available Interrupt Indicator (Read Only).\nThis bit is set if RDA_IEN and RDA_IF are both set to 1.\n</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No RDA interrupt is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RDA interrupt is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>THRE_INT</name>
              <description>Transmit Holding Register Empty Interrupt Indicator (Read Only)\nThis bit is set if THRE_IEN and THRE_IF are both set to 1.\n</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No THRE interrupt is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>THRE interrupt is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>RLS_INT</name>
              <description>Receive Line Status Interrupt Indicator (Read Only). \nThis bit is set if RLS_IEN and RLS_IF are both set to 1.\n</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No RLS interrupt is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RLS interrupt is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>MODEM_INT</name>
              <description>MODEM Status Interrupt Indicator (Read Only) (Not Available in UART2 Channel)\nThis bit is set if MODEM_IEN and MODEM_IF are both set to 1.\n</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No Modem interrupt is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Modem interrupt is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>TOUT_INT</name>
              <description>Time Out Interrupt Indicator (Read Only)\nThis bit is set if TOUT_IEN and TOUT_IF are both set to 1.\n</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No Tout interrupt is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Tout interrupt is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>BUF_ERR_INT</name>
              <description>Buffer Error Interrupt Indicator (Read Only)\nThis bit is set if BUF_ERR_IEN and BUF_ERR_IF are both set to 1.\n</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No buffer error interrupt is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Buffer error interrupt is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>HW_RLS_IF</name>
              <description>In DMA Mode, Receive Line Status Flag (Read Only)\nThis bit is set when the RX receive data have parity error, framing error or break error (at least one of 3 bits, BIF, FEF and PEF, is set). If UA_IER [RLS_IEN] is enabled, the RLS interrupt will be generated.\nNote: This bit is read only and reset to 0 when all bits of BIF, FEF and PEF are cleared.</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>HW_MODEM_IF</name>
              <description>In DMA Mode, MODEM Interrupt Flag (Read Only) (Not Available in UART2 Channel)\nNote: This bit is read only and reset to 0 when bit DCTSF is cleared by a write 1 on DCTSF.</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>HW_TOUT_IF</name>
              <description>In DMA Mode, Time Out Interrupt Flag (Read Only)\nThis bit is set when the RX FIFO is not empty and no activities occurred in the RX FIFO and the time out counter equal to TOIC. If UA_IER [TOUT_IEN] is enabled, the Tout interrupt will be generated. \nNote: This bit is read only and user can read UA_RBR (RX is in active) to clear it.</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>HW_BUF_ERR_IF</name>
              <description>In DMA Mode, Buffer Error Interrupt Flag (Read Only)\nThis bit is set when the TX or RX FIFO overflows (TX_OVER_IF or RX_OVER_IF is set). When BUF_ERR_IF is set, the transfer maybe is not correct. If UA_IER [BUF_ERR_IEN] is enabled, the buffer error interrupt will be generated.\nNote: This bit is cleared when both TX_OVER_IF and RX_OVER_IF are cleared.</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>HW_RLS_INT</name>
              <description>In DMA Mode, Receive Line Status Interrupt Indicator (Read Only)\nThis bit is set if RLS_IEN and HW_RLS_IF are both set to 1.\n</description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No RLS interrupt is generated in DMA mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RLS interrupt is generated in DMA mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>HW_MODEM_INT</name>
              <description>In DMA Mode, MODEM Status Interrupt Indicator (Read Only)&#160; (Not Available in UART2 Channel)\nThis bit is set if MODEM_IEN and HW_MODEM_IF are both set to 1.\n</description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No Modem interrupt is generated in DMA mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Modem interrupt is generated in DMA mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>HW_TOUT_INT</name>
              <description>In DMA Mode, Time Out Interrupt Indicator (Read Only)\nThis bit is set if TOUT_IEN and HW_TOUT_IF are both set to 1.\n</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No Tout interrupt is generated in DMA mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Tout interrupt is generated in DMA mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>HW_BUF_ERR_INT</name>
              <description>In DMA Mode, Buffer Error Interrupt Indicator (Read Only)\nThis bit is set if BUF_ERR_IEN and HW_BUF_ERR_IF are both set to 1.\n</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No buffer error interrupt is generated in DMA mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Buffer error interrupt is generated in DMA mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UA_TOR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UA_TOR</displayName>
          <description>UART Time Out Register</description>
          <addressOffset>0x20</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TOIC</name>
              <description>Time Out Interrupt Comparator\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DLY</name>
              <description>TX Delay Time Value (NuMicro( NUC100/NUC120 Low Density Only)\nThis field is use to programming the transfer delay time between the last stop bit and next start bit.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UA_BAUD</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UA_BAUD</displayName>
          <description>UART Baud Rate Divisor Register</description>
          <addressOffset>0x24</addressOffset>
          <access>read-write</access>
          <resetValue>0x0F000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BRD</name>
              <description>Baud Rate Divider\nThe field indicates the baud rate divider.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DIVIDER_X</name>
              <description>Divider X\n</description>
              <bitOffset>24</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DIV_X_ONE</name>
              <description>Divider X Equal to 1\nRefer to the Table 513 below for more information.</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Divider M = X (the equation of M = X+1, but DIVIDER_X[27:24] must &gt;= 8)</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Divider M = 1 (the equation of M = 1, but BRD [15:0] must &gt;= 3)</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DIV_X_EN</name>
              <description>Divider X Enable\nRefer to the table below for more information.\nNote: In IrDA mode, this bit must be disabled.</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Divider X Disabled (the equation of M = 16)</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Divider X Enabled (the equation of M = X+1, but DIVIDER_X [27:24] must &gt;= 8)</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UA_IRCR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UA_IRCR</displayName>
          <description>UART IrDA Control Register</description>
          <addressOffset>0x28</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000040</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TX_SELECT</name>
              <description>TX_SELECT\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>IrDA receiver Enabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>IrDA transmitter Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>INV_TX</name>
              <description>INV_TX\n</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No inversion</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Inverse TX output signal</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>INV_RX</name>
              <description>INV_RX\n</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No inversion</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Inverse RX input signal</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UA_ALT_CSR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UA_ALT_CSR</displayName>
          <description>UART Alternate Control/Status Register</description>
          <addressOffset>0x2C</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RS485_NMM</name>
              <description>RS-485 Normal Multi-drop Operation Mode (NMM) (NuMicro( NUC100/NUC120 Low Density Only)\nNote: It can't be active with RS-485_AAD operation mode.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RS-485 Normal Multi-drop Operation mode (NMM) Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RS-485 Normal Multi-drop Operation mode (NMM) Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RS485_AAD</name>
              <description>RS-485 Auto Address Detection Operation Mode (AAD) (NuMicro( NUC100/NUC120 Low Density Only)\nNote: It can't be active with RS-485_NMM operation mode.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RS-485 Auto Address Detection Operation Mode (AAD) Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RS-485 Auto Address Detection Operation Mode (AAD) Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RS485_AUD</name>
              <description>RS-485 Auto Direction Mode (AUD) (NuMicro( NUC100/NUC120 Low Density Only)\nNote: It can be active with RS-485_AAD or RS-485_NMM operation mode.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RS-485 Auto Direction Operation Mode (AUO) Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RS-485 Auto Direction Operation mode (AUO) Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RS485_ADD_EN</name>
              <description>RS-485 Address Detection Enable (NuMicro( NUC100/NUC120 Low Density Only)\nThis bit is use to enable RS-485 address detection mode. \nNote: This field is used for RS-485 any operation mode.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Address detection mode Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Address detection mode Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ADDR_MATCH</name>
              <description>Address Match Value Register (NuMicro( NUC100/NUC120 Low Density Only)\nThis field contains the RS-485 address match values.\nNote: This field is used for RS-485 auto address detection mode.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UA_FUN_SEL</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UA_FUN_SEL</displayName>
          <description>UART Function Select Register</description>
          <addressOffset>0x30</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>FUN_SEL</name>
              <description>Function Select Enable\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>UART function</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reserved</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>IrDA function Enabled</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>RS-485 Function Enabled (NuMicro( NUC100/NUC120 Low Density Only)</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>PS2</name>
      <description>PS2 Register Map</description>
      <groupName>PS2</groupName>
      <baseAddress>0x40100000</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x0</offset>
        <size>0x20</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>PS2CON</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PS2CON</displayName>
          <description>PS/2 Control Register</description>
          <addressOffset>0x0</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PS2EN</name>
              <description>Enable PS/2 Device\nEnable PS/2 device controller\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TXINTEN</name>
              <description>Enable Transmit Interrupt\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Data transmit complete interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Data transmit complete interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RXINTEN</name>
              <description>Enable Receive Interrupt\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Data receive complete interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Data receive complete interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TXFIFODIPTH</name>
              <description>Transmit Data FIFO Depth\nThere is 16 bytes buffer for data transmit. S/W can define the FIFO depth from 1 to 16 bytes depends on application.\n</description>
              <bitOffset>3</bitOffset>
              <bitWidth>4</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>1 byte</description>
                    <value>0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>2 bytes</description>
                    <value>1</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>14</name>
                    <description>15 bytes</description>
                    <value>14</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>15</name>
                    <description>16 bytes</description>
                    <value>15</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ACK</name>
              <description>Acknowledge Enable\n</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Always send acknowledge to host at 12th clock for host to device communication</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>If parity error or stop bit is not received correctly, acknowledge bit will not be sent to host at 12th clock</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CLRFIFO</name>
              <description>Clear TX FIFO\nWrite 1 to this bit to terminate device to host transmission. The TXEMPTY bit in PS2STATUS bit will be set to 1 and pointer BYTEIDEX is reset to 0 regardless there is residue data in buffer or not. The buffer content is not been cleared.\n</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Not active</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Clear FIFO</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>OVERRIDE</name>
              <description>Software Override PS/2 CLK/DATA Pin State\n</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PS2CLK and PS2DATA pins are controlled by internal state machine</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PS2CLK and PS2DATA pins are controlled by S/W</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>FPS2CLK</name>
              <description>Force PS2CLK Line\nIt forces PS2CLK line high or low regardless of the internal state of the device controller if OVERRIDE is set to high.\n</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Force PS2CLK line low</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Force PS2CLK line high</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>FPS2DAT</name>
              <description>Force PS2DATA Line\nIt forces PS2DATA high or low regardless of the internal state of the device controller if OVERRIDE is set to high.\n</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Force PS2DATA low</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Force PS2DATA high</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PS2TXDATA0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PS2TXDATA0</displayName>
          <description>PS/2 Transmit Data Register 0</description>
          <addressOffset>0x4</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PS2TXDATAx</name>
              <description>Transmit Data\nWriting data to this register starts device to host communication if bus is in IDLE state. Software must enable PS2EN before writing data to TX buffer.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PS2TXDATA0">
          <name>PS2TXDATA1</name>
          <displayName>PS2TXDATA1</displayName>
          <description>PS/2 Transmit Data Register 1</description>
          <addressOffset>0x8</addressOffset>
       </register>
       <register derivedFrom="PS2TXDATA0">
          <name>PS2TXDATA2</name>
          <displayName>PS2TXDATA2</displayName>
          <description>PS/2 Transmit Data Register 2</description>
          <addressOffset>0xC</addressOffset>
       </register>
       <register derivedFrom="PS2TXDATA0">
          <name>PS2TXDATA3</name>
          <displayName>PS2TXDATA3</displayName>
          <description>PS/2 Transmit Data Register 3</description>
          <addressOffset>0x10</addressOffset>
       </register>
       <register>
          <name>PS2RXDATA</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PS2RXDATA</displayName>
          <description>PS/2 Receive Data Register</description>
          <addressOffset>0x14</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PS2RXDATA</name>
              <description>Received Data\nFor host to device communication, after acknowledge bit is sent, the received data is copied from receive shift register to PS2RXDATA register. CPU must read this register before next byte reception complete; otherwise, the data will be overwritten and RXOVF bit in PS2STATUS[6] will be set to 1.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PS2STATUS</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PS2STATUS</displayName>
          <description>PS/2 Status Register</description>
          <addressOffset>0x18</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000083</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PS2CLK</name>
              <description>CLK Pin State\nThis bit reflects the status of the PS2CLK line after synchronizing.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PS2DATA</name>
              <description>DATA Pin State\nThis bit reflects the status of the PS2DATA line after synchronizing and sampling.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FRAMERR</name>
              <description>Frame Error\nFor host to device communication, if STOP bit (logic 1) is not received it is a frame error. If frame error occurs, DATA line may keep at low state after 12th clock. At this moment, S/W overrides PS2CLK to send clock till PS2DATA release to high state. After that, device sends a "Resend" command to host.\nWrite 1 to clear this bit.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No frame error</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Frame error occur</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RXPARITY</name>
              <description>Received Parity\nThis bit reflects the parity bit for the last received data byte (odd parity).\nRead only bit.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXBUSY</name>
              <description>Receive Busy\nThis bit indicates that the PS/2 device is currently receiving data.\nRead only bit.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Idle</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Currently receiving data</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TXBUSY</name>
              <description>Transmit Busy\nThis bit indicates that the PS/2 device is currently sending data.\nRead only bit.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Idle</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Currently sending data</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RXOVF</name>
              <description>RX Buffer Overwrite\nWrite 1 to clear this bit.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No overwrite</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Data in PS2RXDATA register is overwritten by new received data</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TXEMPTY</name>
              <description>TX FIFO Empty\nWhen S/W writes any data to PS2TXDATA0-3 the TXEMPTY bit is cleared to 0 immediately if PS2EN is enabled. When transmitted data byte number is equal to FIFODEPTH then TXEMPTY bit is set to 1.\nRead only bit.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>There is data to be transmitted</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>FIFO is empty</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BYTEIDX</name>
              <description>Byte Index\n</description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PS2INTID</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PS2INTID</displayName>
          <description>PS/2 Interrupt Identification Register</description>
          <addressOffset>0x1C</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RXINT</name>
              <description>Receive Interrupt\nThis bit is set to 1 when acknowledge bit is sent for Host to device communication. Interrupt occurs if RXINTEN bit is set to 1.\nWrite 1 to clear this bit to 0.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No interrupt</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Receive interrupt occurs</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TXINT</name>
              <description>Transmit Interrupt\nThis bit is set to 1 after STOP bit is transmitted. Interrupt occur if TXINTEN bit is set to 1.\nWrite 1 to clear this bit to 0.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No interrupt</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Transmit interrupt occurs</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>I2S</name>
      <description>I2S Register Map</description>
      <groupName>I2S</groupName>
      <baseAddress>0x401A0000</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x0</offset>
        <size>0x18</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>I2SCON</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>I2SCON</displayName>
          <description>I2S Control Register</description>
          <addressOffset>0x0</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>I2SEN</name>
              <description>I2S Controller Enable\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TXEN</name>
              <description>Transmit Enable\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Data transmission Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Data transmission Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RXEN</name>
              <description>Receive Enable\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Data receiving Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Data receiving Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>MUTE</name>
              <description>Transmit Mute Enable\n</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Transmit data is shifted from buffer</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Transmit channel zero</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>WORDWIDTH</name>
              <description>Word Width\n</description>
              <bitOffset>4</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>data is 8-bit</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>data is 16-bit</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>data is 24-bit</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>data is 32-bit</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>MONO</name>
              <description>Monaural Data\nNote: when chip records data, only right channel data will be saved if monaural format is select.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Data is stereo format</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Data is monaural format</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>FORMAT</name>
              <description>Data Format\n</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>I2S data format</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>MSB justified data format</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SLAVE</name>
              <description>Slave Mode\nI2S can operate as master or slave. For Master mode, I2S_BCLK and I2S_LRCLK pins are output mode and send bit clock from NuMicro( NUC100 series to Audio CODEC chip. In Slave mode, I2S_BCLK and I2S_LRCLK pins are input mode and I2S_BCLK and I2S_LRCLK signals are received from outer Audio CODEC chip.\n</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Master mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Slave mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TXTH</name>
              <description>Transmit FIFO Threshold Level\nIf remain data word (32 bits) in transmit FIFO is the same or less than threshold level then TXTHF flag is set.\n</description>
              <bitOffset>9</bitOffset>
              <bitWidth>3</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>0 word data in transmit FIFO</description>
                    <value>#000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>1 word data in transmit FIFO</description>
                    <value>#001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>2 words data in transmit FIFO</description>
                    <value>#010</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>3 words data in transmit FIFO</description>
                    <value>#011</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>4</name>
                    <description>4 words data in transmit FIFO</description>
                    <value>#100</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>5</name>
                    <description>5 words data in transmit FIFO</description>
                    <value>#101</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>6</name>
                    <description>6 words data in transmit FIFO</description>
                    <value>#110</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>7</name>
                    <description>7 words data in transmit FIFO</description>
                    <value>#111</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RXTH</name>
              <description>Receive FIFO Threshold Level\nWhen received data word(s) in buffer is equal to or higher than threshold level then RXTHF flag is set.\n</description>
              <bitOffset>12</bitOffset>
              <bitWidth>3</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>1 word data in receive FIFO</description>
                    <value>#000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>2 word data in receive FIFO</description>
                    <value>#001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>3 word data in receive FIFO</description>
                    <value>#010</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>4 word data in receive FIFO</description>
                    <value>#011</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>4</name>
                    <description>5 word data in receive FIFO</description>
                    <value>#100</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>5</name>
                    <description>6 word data in receive FIFO</description>
                    <value>#101</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>6</name>
                    <description>7 word data in receive FIFO</description>
                    <value>#110</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>7</name>
                    <description>8 word data in receive FIFO</description>
                    <value>#111</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>MCLKEN</name>
              <description>Master Clock Enable\nIf the external crystal clock in NuMicro( NUC100 series is frequency 2*N*256fs, software can program MCLK_DIV[2:0] in I2SCLKDIV register to get 256fs clock to audio codec chip.\n</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Master clock Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Master clock Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RCHZCEN</name>
              <description>Right Channel Zero-cross Detection Enable\nIf this bit is set to 1, when right channel data sign bit change or next shift data bits are all zero then RZCF flag in I2SSTATUS register is set to 1.\n</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Right channel zero-cross detect Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Right channel zero-cross detect Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>LCHZCEN</name>
              <description>Left channel zero-cross Detect Enable\nIf this bit is set to 1, when left channel data sign bit change or next shift data bits are all zero then LZCF flag in I2SSTATUS register is set to 1.\n</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Left channel zero-cross detect Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Left channel zero-cross detect Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CLR_TXFIFO</name>
              <description>Clear Transmit FIFO\nWrite 1 to clear transmit FIFO, internal pointer is reset to FIFO start point, and TXFIFO_LEVEL[3:0] returns 0 and transmit FIFO becomes empty but data in transmit FIFO is not changed. \nThis bit is clear by hardware automatically, read it return zero.</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CLR_RXFIFO</name>
              <description>Clear Receive FIFO\nWrite 1 to clear receive FIFO, internal pointer is reset to FIFO start point, and RXFIFO_LEVEL[3:0] returns 0 and receive FIFO becomes empty.\nThis bit is cleared by hardware automatically, read it return zero.</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TXDMA</name>
              <description>Enable Transmit DMA\nWhen TX DMA is enables, I2S request DMA to transfer data from SRAM to transmit FIFO if FIFO is not full.\n</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>TX DMA Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>TX DMA Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RXDMA</name>
              <description>Enable Receive DMA\nWhen RX DMA is enabled, I2S requests DMA to transfer data from receive FIFO to SRAM if FIFO is not empty.\n</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RX DMA Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RX DMA Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>I2SCLKDIV</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>I2SCLKDIV</displayName>
          <description>I2S Clock Divider Register</description>
          <addressOffset>0x4</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MCLK_DIV</name>
              <description>Master Clock Divider\nIf chip external crystal frequency is (2xMCLK_DIV)*256fs then software can program these bits to generate 256fs clock frequency to audio codec chip. If MCLK_DIV is set to 0, MCLK is the same as external clock input.\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>BCLK_DIV</name>
              <description>Bit Clock Divider\nIf I2S operates in Master mode, bit clock is provided by the NuMicro( NUC100 series. Software can program these bits to generate sampling rate clock frequency.\n</description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>I2SIE</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>I2SIE</displayName>
          <description>I2S Interrupt Enable Register</description>
          <addressOffset>0x8</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RXUDFIE</name>
              <description>Receive FIFO Underflow Interrupt Enable\nIf software read receive FIFO when it is empty then RXUDF flag in I2SSTATUS register is set to 1.\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RXOVFIE</name>
              <description>Receive FIFO Overflow Interrupt Enable\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RXTHIE</name>
              <description>Receive FIFO Threshold Level Interrupt Enable\nWhen data word in receive FIFO is equal or higher then RXTH[2:0] and the RXTHF bit is set to 1. If RXTHIE bit is enabled, interrupt occur.\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TXUDFIE</name>
              <description>Transmit FIFO Underflow Interrupt Enable\nInterrupt occur if this bit is set to 1 and transmit FIFO underflow flag is set to 1.\n</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TXOVFIE</name>
              <description>Transmit FIFO Overflow Interrupt Enable\nInterrupt occurs if this bit is set to 1 and transmit FIFO overflow flag is set to 1\n</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TXTHIE</name>
              <description>Transmit FIFO Threshold Level Interrupt Enable\nInterrupt occurs if this bit is set to 1 and data words in transmit FIFO is less than TXTH[2:0].\n</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RZCIE</name>
              <description>Right Channel zero-cross interrupt Enable\n</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>LZCIE</name>
              <description>Left Channel Zero-cross interrupt Enable\nInterrupt occur if this bit is set to 1 and left channel zero-cross \n</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>I2SSTATUS</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>I2SSTATUS</displayName>
          <description>I2S Status Register</description>
          <addressOffset>0xC</addressOffset>
          <access>read-write</access>
          <resetValue>0x00141000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>I2SINT</name>
              <description>I2S Interrupt Flag\nIt is wire-OR of I2STXINT and I2SRXINT bits.\nThis bit is read only.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No I2S interrupt</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>I2S interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>I2SRXINT</name>
              <description>I2S Receive Interrupt\nThis bit is read only.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No receive interrupt</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Receive interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>I2STXINT</name>
              <description>I2S Transmit Interrupt\nThis bit is read only</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No transmit interrupt</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Transmit interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RIGHT</name>
              <description>Right Channel\nThis bit indicate current transmit data is belong to right channel\nThis bit is read only</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Left channel</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Right channel</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RXUDF</name>
              <description>Receive FIFO Underflow Flag\nRead receive FIFO when it is empty, this bit set to 1 indicate underflow occur.\nWrite 1 to clear this bit to zero</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No underflow occur</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Underflow occur</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RXOVF</name>
              <description>Receive FIFO Overflow Flag\nWhen receive FIFO is full and receive hardware attempt write to data into receive FIFO then this bit is set to 1, data in 1st buffer is overwrote.\nWrite 1 to clear this bit to 0.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No overflow occur</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Overflow occur</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RXTHF</name>
              <description>Receive FIFO Threshold Flag\nWhen data word(s) in receive FIFO is equal or higher than threshold value set in RXTH[2:0] the RXTHF bit becomes to 1. It keeps at 1 till RXFIFO_LEVEL[3:0] less than RXTH[1:0] after software read RXFIFO register.\nThis bit is read only.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Data word(s) in FIFO is lower than threshold level</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Data word(s) in FIFO is equal or higher than threshold level</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RXFULL</name>
              <description>Receive FIFO Full\nThis bit reflect data words number in receive FIFO is 8\nThis bit is read only.</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Not full</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Full</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RXEMPTY</name>
              <description>Receive FIFO Empty\nThis bit reflects data words number in receive FIFO is zero\nThis bit is read only.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Not empty</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Empty</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TXUDF</name>
              <description>Transmit FIFO Underflow Flag\nWhen transmit FIFO is empty and shift logic hardware read data from data FIFO causes this set to 1.\nWrite 1 to clear this bit to 0.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No underflow</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Underflow</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TXOVF</name>
              <description>Transmit FIFO Overflow Flag\nWrite data to transmit FIFO when it is full and this bit set to 1\nWrite 1 to clear this bit to 0.</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No overflow</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Overflow</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TXTHF</name>
              <description>Transmit FIFO Threshold Flag\nWhen data word(s) in transmit FIFO is equal or lower than threshold value set in TXTH[2:0] the TXTHF bit becomes to 1. It keeps at 1 till TXFIFO_LEVEL[3:0] is higher than TXTH[1:0] after software write TXFIFO register.\nThis bit is read only</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Data word(s) in FIFO is higher than threshold level</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Data word(s) in FIFO is equal or lower than threshold level</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TXFULL</name>
              <description>Transmit FIFO Full\nThis bit reflect data word number in transmit FIFO is 8\nThis bit is read only</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Not full</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Full</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TXEMPTY</name>
              <description>Transmit FIFO Empty\nThis bit reflect data word number in transmit FIFO is zero\nThis bit is read only.</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Not empty</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Empty</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TXBUSY</name>
              <description>Transmit Busy\nThis bit is clear to 0 when all data in transmit FIFO and shift buffer is shifted out. And set to 1 when 1st data is load to shift buffer. \nThis bit is read only.</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Transmit shift buffer is empty</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Transmit shift buffer is busy</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RZCF</name>
              <description>Right Channel Zero-cross Flag\nIt indicates right channel next sample data sign bit is changed or all data bits are zero.\nWrite 1 to clear this bit to 0.</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No zero-cross</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Right channel zero-cross is detected</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>LZCF</name>
              <description>Left Channel Zero-cross Flag\nIt indicates left channel next sample data sign bit is changed or all data bits are zero.\nWrite 1 to clear this bit to 0.</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No zero-cross</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Left channel zero-cross is detected</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_LEVEL</name>
              <description>Receive FIFO Level\nThese bits indicate word number in receive FIFO\n</description>
              <bitOffset>24</bitOffset>
              <bitWidth>4</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No data</description>
                    <value>#0000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>1 word in receive FIFO</description>
                    <value>#0001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>8</name>
                    <description>8 words in receive FIFO</description>
                    <value>#1000</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_LEVEL</name>
              <description>Transmit FIFO Level\nThese bits indicate word number in transmit FIFO\n</description>
              <bitOffset>28</bitOffset>
              <bitWidth>4</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No data</description>
                    <value>#0000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>1 word in transmit FIFO</description>
                    <value>#0001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>8</name>
                    <description>8 words in transmit FIFO</description>
                    <value>#1000</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>I2STXFIFO</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>I2STXFIFO</displayName>
          <description>I2S Transmit FIFO Register</description>
          <addressOffset>0x10</addressOffset>
          <access>write-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TXFIFO</name>
              <description>Transmit FIFO Register\nI2S contains 8 words (8x32 bit) data buffer for data transmit. Write data to this register to prepare data for transmit. The remaining word number is indicated by TX_LEVEL[3:0] in I2SSTATUS.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>I2SRXFIFO</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>I2SRXFIFO</displayName>
          <description>I2S Receive FIFO Register</description>
          <addressOffset>0x14</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RXFIFO</name>
              <description>Receive FIFO register\nI2S contains 8 words (8x32 bit) data buffer for data receive. Read this register to get data in FIFO. The remaining data word number is indicated by RX_LEVEL[3:0] in I2SSTATUS register.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>ADC</name>
      <description>ADC Register Map</description>
      <groupName>ADC</groupName>
      <baseAddress>0x400E0000</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x0</offset>
        <size>0x38</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x40</offset>
        <size>0x4</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>ADDR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>ADDR0</displayName>
          <description>A/D Data Register 0</description>
          <addressOffset>0x0</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RSLT</name>
              <description>A/D Conversion Result\nThis field contains conversion result of ADC.\nFor NuMicro( NUC100/NUC120 Medium density, RSLT[15:12] always read as 0.\nThe following description is only support in NuMicro( NUC100/NUC120 Low Density:\nWhen DMOF bit (ADCR[31]) set to 0, 12-bit ADC conversion result with unsigned format will be filled in RSLT[11:0] and zero will be filled in RSLT[15:12].\nWhen DMOF bit (ADCR[31]) set to 1, 12-bit ADC conversion result with 2'complement format will be filled in RSLT[11:0] and signed bits to will be filled in RSLT[15:12].</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>OVERRUN</name>
              <description>Over Run Flag\nIf converted data in RSLT[15:0] has not been read before new conversion result is loaded to this register, OVERRUN is set to 1 and previous conversion result is gone. It is cleared by hardware after ADDR register is read.\nThis is a read only bit</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Data in RSLT[15:0] is recent conversion result</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Data in RSLT[15:0] is overwrite</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>VALID</name>
              <description>Valid Flag\nThis bit is set to 1 when corresponding channel analog input conversion is completed and cleared by hardware after ADDR register is read.\nThis is a read only bit</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Data in RSLT[15:0] bits is not valid</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Data in RSLT[15:0] bits is valid</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="ADDR0">
          <name>ADDR1</name>
          <displayName>ADDR1</displayName>
          <description>A/D Data Register 1</description>
          <addressOffset>0x4</addressOffset>
       </register>
       <register derivedFrom="ADDR0">
          <name>ADDR2</name>
          <displayName>ADDR2</displayName>
          <description>A/D Data Register 2</description>
          <addressOffset>0x8</addressOffset>
       </register>
       <register derivedFrom="ADDR0">
          <name>ADDR3</name>
          <displayName>ADDR3</displayName>
          <description>A/D Data Register 3</description>
          <addressOffset>0xC</addressOffset>
       </register>
       <register derivedFrom="ADDR0">
          <name>ADDR4</name>
          <displayName>ADDR4</displayName>
          <description>A/D Data Register 4</description>
          <addressOffset>0x10</addressOffset>
       </register>
       <register derivedFrom="ADDR0">
          <name>ADDR5</name>
          <displayName>ADDR5</displayName>
          <description>A/D Data Register 5</description>
          <addressOffset>0x14</addressOffset>
       </register>
       <register derivedFrom="ADDR0">
          <name>ADDR6</name>
          <displayName>ADDR6</displayName>
          <description>A/D Data Register 6</description>
          <addressOffset>0x18</addressOffset>
       </register>
       <register derivedFrom="ADDR0">
          <name>ADDR7</name>
          <displayName>ADDR7</displayName>
          <description>A/D Data Register 7</description>
          <addressOffset>0x1C</addressOffset>
       </register>
       <register>
          <name>ADCR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>ADCR</displayName>
          <description>A/D Control Register</description>
          <addressOffset>0x20</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ADEN</name>
              <description>A/D Converter Enable\nBefore starting A/D conversion function, this bit should be set to 1. Clear it to 0 to disable A/D converter analog circuit for saving power consumption.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ADIE</name>
              <description>A/D Interrupt Enable\nA/D conversion end interrupt request is generated if ADIE bit is set to 1.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>A/D interrupt function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>A/D interrupt function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ADMD</name>
              <description>A/D Converter Operation Mode\nWhen changing the operation mode, software should disable ADST bit firstly.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Single conversion</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reserved</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Single-cycle scan</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Continuous scan</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TRGS</name>
              <description>Hardware Trigger Source\nSoftware should disable TRGEN and ADST before change TRGS.\nIn hardware trigger mode, the ADST bit is set by the external trigger from STADC.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>A/D conversion is started by external STADC pin</description>
                    <value>#00</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TRGCOND</name>
              <description>External Trigger Conditions\nThese two bits decide external pin STADC trigger event is level or edge. The signal must be kept at stable state at least 8 PCLKs for level trigger and 4 PCLKs at high and low state for edge trigger.\n</description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Low level</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>High level</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Falling edge</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Rising edge</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TRGEN</name>
              <description>External Trigger Enable\nEnable or disable triggering of A/D conversion by external STADC pin.\nADC external trigger function is only supported in single-cycle scan mode.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PTEN</name>
              <description>PDMA Transfer Enable\n</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PDMA data transfer Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PDMA data transfer in ADDR 0~7 Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DIFFEN</name>
              <description>Differential Input Mode Enable\n</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Single-end analog input mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Differential analog input mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ADST</name>
              <description>A/D Conversion Start\nADST bit can be set to 1 from two sources: software and external pin STADC. ADST will be cleared to 0 by hardware automatically at the ends of single mode and single-cycle scan mode. In continuous scan mode, A/D conversion is continuously performed until software write 0 to this bit or chip reset.</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Conversion stopped and A/D converter enter idle state</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Conversion start</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DMOF</name>
              <description>A/D Differential Input Mode Output Format (Only Supported in NuMicro( NUC100/NUC120 Low Density)\n</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>A/D Conversion result will be filled in RSLT at ADDRx registers with unsigned format</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>A/D Conversion result will be filled in RSLT at ADDRx registers with 2'complement format</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>ADCHER</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>ADCHER</displayName>
          <description>A/D Channel Enable Register</description>
          <addressOffset>0x24</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CHEN0</name>
              <description>Analog Input Channel 0 Enable\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CHEN1</name>
              <description>Analog Input Channel 1 Enable\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CHEN2</name>
              <description>Analog Input Channel 2 Enable\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CHEN3</name>
              <description>Analog Input Channel 3 Enable\n</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CHEN4</name>
              <description>Analog Input Channel 4 Enable\n</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CHEN5</name>
              <description>Analog Input Channel 5 Enable\n</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CHEN6</name>
              <description>Analog Input Channel 6 Enable\n</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CHEN7</name>
              <description>Analog Input Channel 7 Enable\n</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PRESEL</name>
              <description>Analog Input Channel 7 select\nNote:\nWhen software selects the band-gap voltage as the analog input source of ADC channel 7, ADC clock rate needs to be limited to lower than 300 kHz.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>External analog input</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Internal band-gap voltage</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Internal temperature sensor</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Reserved</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>ADCMPR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>ADCMPR0</displayName>
          <description>A/D Compare Register 0</description>
          <addressOffset>0x28</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CMPEN</name>
              <description>Compare Enable\nSet this bit to 1 to enable ADC controller to compare CMPD[11:0] with specified channel conversion result when converted data is loaded into ADDR register.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Compare function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Compare function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CMPIE</name>
              <description>Compare Interrupt Enable\nIf the compare function is enabled and the compare condition matches the setting of CMPCOND and CMPMATCNT, CMPF bit will be asserted, in the meanwhile, if CMPIE is set to 1, a compare interrupt request is generated.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Compare function interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Compare function interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CMPCOND</name>
              <description>Compare Condition\nNote: When the internal counter reaches the value to (CMPMATCNT +1), the CMPFx bit will be set.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Set the compare condition as that when a 12-bit A/D conversion result is less than the 12-bit CMPD (ADCMPRx[27:16]), the internal match counter will increase one</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Set the compare condition as that when a 12-bit A/D conversion result is greater or equal to the 12-bit CMPD (ADCMPRx[27:16]), the internal match counter will increase one</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CMPCH</name>
              <description>Compare Channel Selection\n</description>
              <bitOffset>3</bitOffset>
              <bitWidth>3</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Channel 0 conversion result is selected to be compared</description>
                    <value>#000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Channel 1 conversion result is selected to be compared</description>
                    <value>#001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Channel 2 conversion result is selected to be compared</description>
                    <value>#010</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Channel 3 conversion result is selected to be compared</description>
                    <value>#011</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>4</name>
                    <description>Channel 4 conversion result is selected to be compared</description>
                    <value>#100</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>5</name>
                    <description>Channel 5 conversion result is selected to be compared</description>
                    <value>#101</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>6</name>
                    <description>Channel 6 conversion result is selected to be compared</description>
                    <value>#110</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>7</name>
                    <description>Channel 7 conversion result is selected to be compared</description>
                    <value>#111</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CMPMATCNT</name>
              <description>Compare Match Count\nWhen the specified A/D channel analog conversion result matches the compare condition defined by CMPCOND[2], the internal match counter will increase 1. When the internal counter reaches the value to (CMPMATCNT +1), the CMPFx bit will be set.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CMPD</name>
              <description>Comparison Data\nThe 12-bit data is used to compare with conversion result of specified channel.\nThe following description is only support in NuMicro( NUC100/NUC120 Low Density:\nWhen DMOF bit is set to 0, ADC comparator compares CMPD with conversion result with unsigned format. CMPD should be filled in unsigned format.\nWhen DMOF bit is set to 1, ADC comparator compares CMPD with conversion result with 2'complement format. CMPD should be filled in 2'complement format.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>12</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="ADCMPR0">
          <name>ADCMPR1</name>
          <displayName>ADCMPR1</displayName>
          <description>A/D Compare Register 1</description>
          <addressOffset>0x2C</addressOffset>
       </register>
       <register>
          <name>ADSR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>ADSR</displayName>
          <description>A/D Status Register</description>
          <addressOffset>0x30</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ADF</name>
              <description>A/D Conversion End Flag\nA status flag that indicates the end of A/D conversion.\nADF is set to 1 at these two conditions:\n1. When A/D conversion ends in Single mode\n2. When A/D conversion ends on all specified channels in Scan mode\nThis flag can be cleared by writing 1 to itself.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CMPF0</name>
              <description>Compare Flag\nWhen the selected channel A/D conversion result meets setting condition in ADCMPR0 then this bit is set to 1. And it is cleared by writing 1 to self.\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Conversion result in ADDR does not meet ADCMPR0 setting</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Conversion result in ADDR meets ADCMPR0 setting</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CMPF1</name>
              <description>Compare Flag\nWhen the selected channel A/D conversion result meets setting condition in ADCMPR1 then this bit is set to 1. And it is cleared by writing 1 to self.\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Conversion result in ADDR does not meet ADCMPR1 setting</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Conversion result in ADDR meets ADCMPR1 setting</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BUSY</name>
              <description>BUSY/IDLE\nThis bit is mirror of as ADST bit in ADCR.\nIt is read only.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>A/D converter is in idle state</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>A/D converter is busy at conversion</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CHANNEL</name>
              <description>Current Conversion Channel\nIt is read only.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>VALID</name>
              <description>Data Valid flag\nIt is a mirror of VALID bit in ADDRx\nIt is read only.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OVERRUN</name>
              <description>Over Run flag\nIt is a mirror to OVERRUN bit in ADDRx\nIt is read only.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>ADCALR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>ADCALR</displayName>
          <description>A/D Calibration Register</description>
          <addressOffset>0x34</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CALEN</name>
              <description>Self-calibration Enable\nSoftware can set this bit to 1 to enable A/D converter to do self-calibration function. It needs 127 ADC clocks to complete calibration. This bit must be kept at 1 after CALDONE asserted. Clearing this bit will disable self-calibration function.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Self-calibration Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Self-calibration Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CALDONE</name>
              <description>Calibration Complete\nWhen writing 0 to CALEN bit, CALDONE bit is cleared by hardware immediately. It is a read only bit.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>A/D converter has not been calibrated or calibration is in progress if CALEN bit is set</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>A/D converter self-calibration is done</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>ADPDMA</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>ADPDMA</displayName>
          <description>ADC PDMA Current Transfer Data</description>
          <addressOffset>0x40</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>AD_PDMA</name>
              <description>ADC PDMA Current Transfer Data Register\nWhen PDMA transferring, read this register can monitor current PDMA transfer data.\nThis is a read only register.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>12</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>CMP</name>
      <description>CMP Register Map</description>
      <groupName>CMP</groupName>
      <baseAddress>0x400D0000</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x0</offset>
        <size>0xC</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>CMP0CR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CMP0CR</displayName>
          <description>Comparator0 Control Register</description>
          <addressOffset>0x0</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CMP0EN</name>
              <description>Comparator0 Enable\nComparator output needs wait 2 us stable time after CMP0EN is set.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CMP0IE</name>
              <description>Comparator0 Interrupt Enable\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Interrupt function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Interrupt function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CMP0_HYSEN</name>
              <description>Comparator0 Hysteresis Enable\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Hysteresis function Disabled (Default)</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Hysteresis function Enabled. The typical range is 20mV</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CMP0CN</name>
              <description>Comparator0 Negative Input Selection\n</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The source of the negative comparator input is from CPN0 pin</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Internal band-gap reference voltage is selected as the source of negative comparator input</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CMP1CR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CMP1CR</displayName>
          <description>Comparator1 Control Register</description>
          <addressOffset>0x4</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CMP1EN</name>
              <description>Comparator1 Enable\nComparator output needs to wait 2 us stable time after CMP1EN is set.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CMP1IE</name>
              <description>Comparator1 Interrupt Enable\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Interrupt function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Interrupt function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CMP1_HYSEN</name>
              <description>Comparator1 Hysteresis Enable\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Hysteresis function Disabled (default)</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Hysteresis function Enabled. The typical range is 20mV</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CMP1CN</name>
              <description>Comparator1 Negative Input Selection\n</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The source of the negative comparator input is from CPN1 pin</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Internal band-gap reference voltage is selected as the source of negative comparator input</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CMPSR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CMPSR</displayName>
          <description>Comparator Status Register</description>
          <addressOffset>0x8</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CMPF0</name>
              <description>Comparator0 Flag\nThis bit is set by hardware whenever the comparator0 output changes state. This will cause an interrupt if CMP0IE set.\nWrite 1 to clear this bit to 0.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CMPF1</name>
              <description>Comparator1 Flag\nThis bit is set by hardware whenever the comparator1 output changes state. This will cause an interrupt if CMP1IE set.\nWrite 1 to clear this bit to 0.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CO0</name>
              <description>Comparator0 Output\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CO1</name>
              <description>Comparator1 Output\n</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>PDMA_GCR</name>
      <description>PDMA Register Map</description>
      <groupName>PDMA</groupName>
      <baseAddress>0x50008F00</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x0</offset>
        <size>0x14</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>PDMA_GCRCSR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_GCRCSR</displayName>
          <description>PDMA Global Control Register</description>
          <addressOffset>0x0</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CLK0_EN</name>
              <description>PDMA Controller Channel 0 Clock Enable Control\n</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK1_EN</name>
              <description>PDMA Controller Channel 1 Clock Enable Control (NuMicro( NUC100/NUC120 Medium Density Only)\n</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK2_EN</name>
              <description>PDMA Controller Channel 2 Clock Enable Control (NuMicro( NUC100/NUC120 Medium Density Only)\n</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK3_EN</name>
              <description>PDMA Controller Channel 3 Clock Enable Control (NuMicro( NUC100/NUC120 Medium Density Only)\n</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK4_EN</name>
              <description>PDMA Controller Channel 4 Clock Enable Control (NuMicro( NUC100/NUC120 Medium Density Only)\n</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK5_EN</name>
              <description>PDMA Controller Channel 5 Clock Enable Control (NuMicro( NUC100/NUC120 Medium Density Only)\n</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK6_EN</name>
              <description>PDMA Controller Channel 6 Clock Enable Control (NuMicro( NUC100/NUC120 Medium Density Only)\n</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK7_EN</name>
              <description>PDMA Controller Channel 7 Clock Enable Control (NuMicro( NUC100/NUC120 Medium Density Only)\n</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK8_EN</name>
              <description>PDMA Controller Channel 8 Clock Enable Control (NuMicro( NUC100/NUC120 Medium Density Only)\n</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PDMA_PDSSR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_PDSSR0</displayName>
          <description>PDMA Service Selection Control Register 0</description>
          <addressOffset>0x4</addressOffset>
          <access>read-write</access>
          <resetValue>0xFFFFFFFF</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SPI0_RXSEL</name>
              <description>PDMA SPI0 RX Selection\nThis filed defines which PDMA channel is connected to the on-chip peripheral SPI0 RX. Software can change the channel RX setting by SPI0_RXSEL\n4'b0000: CH0\n4'b0001: CH1\n4'b0010: CH2\n4'b0011: CH3 \n4'b0100: CH4 \n4'b0101: CH5\n4'b0110: CH6\n4'b0111: CH7\n4'b1000: CH8\nOthers : Reserved\n(The NuMicro( NUC100/NUC120 Low Density should ne set as 4'b0000 for PDMA channel 0 only.)</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SPI0_TXSEL</name>
              <description>PDMA SPI0 TX Selection\nThis filed defines which PDMA channel is connected to the on-chip peripheral SPI0 TX. Software can configure the TX channel setting by SPI0_TXSEL. The channel configuration is the same as SPI0_RXSEL field. Please refer to the explanation of SPI0_RXSEL.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SPI1_RXSEL</name>
              <description>PDMA SPI1 RX Selection\nThis filed defines which PDMA channel is connected to the on-chip peripheral SPI1 RX. Software can configure the RX channel setting by SPI1_RXSEL. The channel configuration is the same as SPI0_RXSEL field. Please refer to the explanation of SPI0_RXSEL.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SPI1_TXSEL</name>
              <description>PDMA SPI1 TX Selection\nThis filed defines which PDMA channel is connected to the on-chip peripheral SPI1 TX. Software can configure the TX channel setting by SPI1_TXSEL. The channel configuration is the same as SPI0_RXSEL field. Please refer to the explanation of SPI0_RXSEL.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SPI2_RXSEL</name>
              <description>PDMA SPI2 RX Selection (NuMicro( NUC100/NUC120 Medium Density Only)\nThis filed defines which PDMA channel is connected to the on-chip peripheral SPI2 RX. Software can configure the RX channel setting by SPI2_RXSEL. The channel configuration is the same as SPI0_RXSEL field. Please refer to the explanation of SPI0_RXSEL.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SPI2_TXSEL</name>
              <description>PDMA SPI2 TX Selection (NuMicro( NUC100/NUC120 Medium Density Only)\nThis filed defines which PDMA channel is connected to the on-chip peripheral SPI2 TX. Software can configure the TX channel setting by SPI2_TXSEL. The channel configuration is the same as SPI0_RXSEL field. Please refer to the explanation of SPI0_RXSEL.</description>
              <bitOffset>20</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SPI3_RXSEL</name>
              <description>PDMA SPI3 RX Selection (NuMicro( NUC100/NUC120 Medium Density Only)\nThis filed defines which PDMA channel is connected to the on-chip peripheral SPI3 RX. Software can configure the RX channel setting by SPI3_RXSEL. The channel configuration is the same as SPI0_RXSEL field. Please refer to the explanation of SPI0_RXSEL.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SPI3_TXSEL</name>
              <description>PDMA SPI3 TX Selection (NuMicro( NUC100/NUC120 Medium Density Only)\nThis filed defines which PDMA channel is connected to the on-chip peripheral SPI3 TX. Software can configure the TX channel setting by SPI3_TXSEL. The channel configuration is the same as SPI0_RXSEL field. Please refer to the explanation of SPI0_RXSEL.</description>
              <bitOffset>28</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PDMA_PDSSR1</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_PDSSR1</displayName>
          <description>PDMA Service Selection Control Register 1</description>
          <addressOffset>0x8</addressOffset>
          <access>read-write</access>
          <resetValue>0xFFFFFFFF</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>UART0_RXSEL</name>
              <description>This filed defines which PDMA channel is connected to the on-chip peripheral UART0 RX. Software can change the channel RX setting by UART0_RXSEL\n4'b0000: CH0\n4'b0001: CH1\n4'b0010: CH2\n4'b0011: CH3 \n4'b0100: CH4 \n4'b0101: CH5\n4'b0110: CH6\n4'b0111: CH7\n4'b1000: CH8\nOthers : Reserved\n(The NuMicro( NUC100/NUC120 Low Density should be set as 4'b0000 for PDMA channel 0 only.)</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>UART0_TXSEL</name>
              <description>PDMA UART0 TX Selection\nThis filed defines which PDMA channel is connected to the on-chip peripheral UART0 TX. Software can configure the TX channel setting by UART0_TXSEL. The channel configuration is the same as UART0_RXSEL field. Please refer to the explanation of UART0_RXSEL</description>
              <bitOffset>4</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>UART1_RXSEL</name>
              <description>PDMA UART1 RX Selection\nThis filed defines which PDMA channel is connected to the on-chip peripheral UART1 RX. Software can configure the RX channel setting by UART1_RXSEL. The channel configuration is the same as UART0_RXSEL field. Please refer to the explanation of UART0_RXSEL</description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>UART1_TXSEL</name>
              <description>PDMA UART1 TX Selection\nThis filed defines which PDMA channel is connected to the on-chip peripheral UART1 TX. Software can configure the TX channel setting by UART1_TXSEL. The channel configuration is the same as UART0_RXSEL field. Please refer to the explanation of UART0_RXSEL</description>
              <bitOffset>12</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ADC_RXSEL</name>
              <description>PDMA ADC RX Selection\nThis filed defines which PDMA channel is connected to the on-chip peripheral ADC RX. Software can configure the RX channel setting by ADC_RXSEL. The channel configuration is the same as UART0_RXSEL field. Please refer to the explanation of UART0_RXSEL</description>
              <bitOffset>24</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PDMA_GCRISR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_GCRISR</displayName>
          <description>PDMA Global Interrupt Register</description>
          <addressOffset>0xC</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>INTR0</name>
              <description>Interrupt Pin Status of Channel 0\nThis bit is the Interrupt status of PDMA channel0.\nNote: This bit is read only</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>INTR1</name>
              <description>Interrupt Pin Status of Channel 1 (NuMicro( NUC100/NUC120 Medium Density Only)\nThis bit is the Interrupt status of PDMA channel1.\nNote: This bit is read only</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>INTR2</name>
              <description>Interrupt Pin Status of Channel 2 (NuMicro( NUC100/NUC120 Medium Density Only)\nThis bit is the Interrupt status of PDMA channel2.\nNote: This bit is read only</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>INTR3</name>
              <description>Interrupt Pin Status of Channel 3 (NuMicro( NUC100/NUC120 Medium Density Only)\nThis bit is the Interrupt status of PDMA channel3.\nNote: This bit is read only</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>INTR4</name>
              <description>Interrupt Pin Status of Channel 4 (NuMicro( NUC100/NUC120 Medium Density Only)\nThis bit is the Interrupt status of PDMA channel4.\nNote: This bit is read only</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>INTR5</name>
              <description>Interrupt Pin Status of Channel 5 (NuMicro( NUC100/NUC120 Medium Density Only)\nThis bit is the Interrupt status of PDMA channel5.\nNote: This bit is read only</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>INTR6</name>
              <description>Interrupt Pin Status of Channel 6 (NuMicro( NUC100/NUC120 Medium Density Only)\nThis bit is the Interrupt status of PDMA channel6.\nNote: This bit is read only</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>INTR7</name>
              <description>Interrupt Pin Status of Channel 7 (NuMicro( NUC100/NUC120 Medium Density Only)\nThis bit is the Interrupt status of PDMA channel7.\nNote: This bit is read only</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>INTR8</name>
              <description>Interrupt Pin Status of Channel 8 (NuMicro( NUC100/NUC120 Medium Density Only)\nThis bit is the Interrupt status of PDMA channel8.\nNote: This bit is read only</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>INTR</name>
              <description>Interrupt Pin Status\nThis bit is the Interrupt status of PDMA controller.\nNote: This bit is read only</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PDMA_PDSSR2</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_PDSSR2</displayName>
          <description>PDMA Service Selection Control Register 2</description>
          <addressOffset>0x10</addressOffset>
          <access>read-write</access>
          <resetValue>0x000000FF</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>I2S_RXSEL</name>
              <description>PDMA I2S RX Selection\nThis filed defines which PDMA channel is connected to the on-chip peripheral I2S RX.  Software can change the channel RX setting by I2S_RXSEL.\n4'b0000: CH0\n4'b0001: CH1\n4'b0010: CH2\n4'b0011: CH3\n4'b0100: CH4\n4'b0101: CH5\n4'b0110: CH6\n4'b0111: CH7\n4'b1000: CH8\nOthers : Reserved\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>I2S_TXSEL</name>
              <description>PDMA I2S TX Selection\nThis filed defines which PDMA channel is connected to the on-chip peripheral I2S TX. Software can configure the TX channel setting by I2S_TXSEL. The channel configuration is the same as I2S_RXSEL field. Please refer to the explanation of I2S_RXSEL.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>PDMA_ch0</name>
      <description>PDMA Register Map</description>
      <groupName>PDMA</groupName>
      <baseAddress>0x50008000</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x0</offset>
        <size>0x28</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x80</offset>
        <size>0x4</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>PDMA_CSR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_CSR</displayName>
          <description>PDMA Control Register</description>
          <addressOffset>0x0</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMACEN</name>
              <description>PDMA Channel Enable\nSetting this bit to 1 enables PDMA's operation. If this bit is cleared, PDMA will ignore all PDMA request and force Bus Master into IDLE state.\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_RST</name>
              <description>Software Engine Reset\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reset the internal state machine, pointers and internal buffer. The contents of control register will not be cleared. This bit will auto clear after few clock cycles</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>MODE_SEL</name>
              <description>PDMA Mode Selection\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Memory to Memory mode (Memory-to-Memory)</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Peripheral to Memory mode (Peripheral-to-Memory)</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Memory to Peripheral mode (Memory-to-Peripheral)</description>
                    <value>#10</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SAD_SEL</name>
              <description>Transfer Source Address Direction Selection\n</description>
              <bitOffset>4</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Transfer Source address is increasing successively</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reserved</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Transfer Source address is fixed (This feature can be used when data where transferred from a single source to multiple destinations)</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Reserved</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DAD_SEL</name>
              <description>Transfer Destination Address Direction Selection\n</description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Transfer Destination address is increasing successively</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reserved</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Transfer Destination address is fixed (This feature can be used when data where transferred from multiple sources to a single destination)</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Reserved</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>APB_TWS</name>
              <description>Peripheral transfer Width Selection\nNote: This field is meaningful only when MODE_SEL is Peripheral to Memory mode (Peripheral-to-Memory) or Memory to Peripheral mode (Memory-to-Peripheral).</description>
              <bitOffset>19</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>One word (32-bit) is transferred for every PDMA operation</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>One byte (8-bit) is transferred for every PDMA operation</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>One half-word (16-bit) is transferred for every PDMA operation</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Reserved</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TRIG_EN</name>
              <description>Trigger Enable\nNote: When PDMA transfer is completed, this bit will be cleared automatically.\nIf the bus error occurs, all PDMA transfer will be stopped. Software must reset all PDMA channel, and then trigger again.</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PDMA data read or write transfer Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PDMA_SAR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_SAR</displayName>
          <description>PDMA Source Address Register</description>
          <addressOffset>0x4</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_SAR</name>
              <description>PDMA Transfer Source Address Register\nThis field indicates a 32-bit source address of PDMA.\nNote: The source address must be word alignment</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PDMA_DAR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_DAR</displayName>
          <description>PDMA Destination Address Register</description>
          <addressOffset>0x8</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_DAR</name>
              <description>PDMA Transfer Destination Address Register\nThis field indicates a 32-bit destination address of PDMA.\nNote: The destination address must be word alignment.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PDMA_BCR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_BCR</displayName>
          <description>PDMA Transfer Byte Count Register</description>
          <addressOffset>0xC</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_BCR</name>
              <description>PDMA Transfer Byte Count Register\nThis field indicates a 16-bit transfer byte count number of PDMA, which must be word alignment.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PDMA_POINT</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_POINT</displayName>
          <description>PDMA Internal Buffer Pointer</description>
          <addressOffset>0x10</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_POINT</name>
              <description>PDMA Internal Buffer Pointer Register (Read Only)\nThis field indicates the internal buffer pointer.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PDMA_CSAR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_CSAR</displayName>
          <description>PDMA Current Source Address Register</description>
          <addressOffset>0x14</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_CSAR</name>
              <description>PDMA Current Source Address Register (Read Only)\nThis field indicates the source address where the PDMA transfer just occurred.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PDMA_CDAR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_CDAR</displayName>
          <description>PDMA Current Destination Address Register</description>
          <addressOffset>0x18</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_CDAR</name>
              <description>PDMA Current Destination Address Register (Read Only)\nThis field indicates the destination address where the PDMA transfer just occurred.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PDMA_CBCR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_CBCR</displayName>
          <description>PDMA Current Transfer Byte Count Register</description>
          <addressOffset>0x1C</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_CBCR</name>
              <description>PDMA Current Byte Count Register (Read Only)\nThis field indicates the current remained byte count of PDMA.\nNote: SW_RST will clear this register value.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PDMA_IER</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_IER</displayName>
          <description>PDMA Interrupt Enable Register</description>
          <addressOffset>0x20</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000001</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TABORT_IE</name>
              <description>PDMA Read/Write Target Abort Interrupt Enable\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Target abort interrupt generation Disabled during PDMA transfer</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Target abort interrupt generation Enabled during PDMA transfer</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BLKD_IE</name>
              <description>PDMA Transfer Done Interrupt Enable\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Interrupt generator Disabled when PDMA transfer is done</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Interrupt generator Enabled when PDMA transfer is done</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PDMA_ISR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_ISR</displayName>
          <description>PDMA Interrupt Status Register</description>
          <addressOffset>0x24</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TABORT_IF</name>
              <description>PDMA Read/Write Target Abort Interrupt Flag\nWrite 1 to clear this bit to 0.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No bus ERROR response received</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Bus ERROR response received</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BLKD_IF</name>
              <description>Block Transfer Done Interrupt Flag\nThis bit indicates that PDMA has finished all transfer.\nWrite 1 to clear this bit to 0.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Not finished</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Done</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PDMA_SBUF0_c</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_SBUF0_c</displayName>
          <description>PDMA Shared Buffer FIFO 0</description>
          <addressOffset>0x80</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_SBUF0</name>
              <description>PDMA Shared Buffer FIFO 0 (Read Only)\nEach channel has its own 1 words internal buffer.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>PDMA_ch1</name>
      <description>PDMA Register Map</description>
      <groupName>PDMA</groupName>
      <baseAddress>0x50008100</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x0</offset>
        <size>0x28</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x80</offset>
        <size>0x4</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>PDMA_CSR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_CSR</displayName>
          <description>PDMA Control Register</description>
          <addressOffset>0x0</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMACEN</name>
              <description>PDMA Channel Enable\nSetting this bit to 1 enables PDMA's operation. If this bit is cleared, PDMA will ignore all PDMA request and force Bus Master into IDLE state.\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_RST</name>
              <description>Software Engine Reset\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reset the internal state machine, pointers and internal buffer. The contents of control register will not be cleared. This bit will auto clear after few clock cycles</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>MODE_SEL</name>
              <description>PDMA Mode Selection\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Memory to Memory mode (Memory-to-Memory)</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Peripheral to Memory mode (Peripheral-to-Memory)</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Memory to Peripheral mode (Memory-to-Peripheral)</description>
                    <value>#10</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SAD_SEL</name>
              <description>Transfer Source Address Direction Selection\n</description>
              <bitOffset>4</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Transfer Source address is increasing successively</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reserved</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Transfer Source address is fixed (This feature can be used when data where transferred from a single source to multiple destinations)</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Reserved</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DAD_SEL</name>
              <description>Transfer Destination Address Direction Selection\n</description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Transfer Destination address is increasing successively</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reserved</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Transfer Destination address is fixed (This feature can be used when data where transferred from multiple sources to a single destination)</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Reserved</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>APB_TWS</name>
              <description>Peripheral transfer Width Selection\nNote: This field is meaningful only when MODE_SEL is Peripheral to Memory mode (Peripheral-to-Memory) or Memory to Peripheral mode (Memory-to-Peripheral).</description>
              <bitOffset>19</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>One word (32-bit) is transferred for every PDMA operation</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>One byte (8-bit) is transferred for every PDMA operation</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>One half-word (16-bit) is transferred for every PDMA operation</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Reserved</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TRIG_EN</name>
              <description>Trigger Enable\nNote: When PDMA transfer is completed, this bit will be cleared automatically.\nIf the bus error occurs, all PDMA transfer will be stopped. Software must reset all PDMA channel, and then trigger again.</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PDMA data read or write transfer Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PDMA_SAR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_SAR</displayName>
          <description>PDMA Source Address Register</description>
          <addressOffset>0x4</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_SAR</name>
              <description>PDMA Transfer Source Address Register\nThis field indicates a 32-bit source address of PDMA.\nNote: The source address must be word alignment</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PDMA_DAR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_DAR</displayName>
          <description>PDMA Destination Address Register</description>
          <addressOffset>0x8</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_DAR</name>
              <description>PDMA Transfer Destination Address Register\nThis field indicates a 32-bit destination address of PDMA.\nNote: The destination address must be word alignment.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PDMA_BCR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_BCR</displayName>
          <description>PDMA Transfer Byte Count Register</description>
          <addressOffset>0xC</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_BCR</name>
              <description>PDMA Transfer Byte Count Register\nThis field indicates a 16-bit transfer byte count number of PDMA, which must be word alignment.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PDMA_POINT</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_POINT</displayName>
          <description>PDMA Internal Buffer Pointer</description>
          <addressOffset>0x10</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_POINT</name>
              <description>PDMA Internal Buffer Pointer Register (Read Only)\nThis field indicates the internal buffer pointer.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PDMA_CSAR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_CSAR</displayName>
          <description>PDMA Current Source Address Register</description>
          <addressOffset>0x14</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_CSAR</name>
              <description>PDMA Current Source Address Register (Read Only)\nThis field indicates the source address where the PDMA transfer just occurred.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PDMA_CDAR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_CDAR</displayName>
          <description>PDMA Current Destination Address Register</description>
          <addressOffset>0x18</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_CDAR</name>
              <description>PDMA Current Destination Address Register (Read Only)\nThis field indicates the destination address where the PDMA transfer just occurred.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PDMA_CBCR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_CBCR</displayName>
          <description>PDMA Current Transfer Byte Count Register</description>
          <addressOffset>0x1C</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_CBCR</name>
              <description>PDMA Current Byte Count Register (Read Only)\nThis field indicates the current remained byte count of PDMA.\nNote: SW_RST will clear this register value.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PDMA_IER</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_IER</displayName>
          <description>PDMA Interrupt Enable Register</description>
          <addressOffset>0x20</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000001</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TABORT_IE</name>
              <description>PDMA Read/Write Target Abort Interrupt Enable\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Target abort interrupt generation Disabled during PDMA transfer</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Target abort interrupt generation Enabled during PDMA transfer</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BLKD_IE</name>
              <description>PDMA Transfer Done Interrupt Enable\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Interrupt generator Disabled when PDMA transfer is done</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Interrupt generator Enabled when PDMA transfer is done</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PDMA_ISR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_ISR</displayName>
          <description>PDMA Interrupt Status Register</description>
          <addressOffset>0x24</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TABORT_IF</name>
              <description>PDMA Read/Write Target Abort Interrupt Flag\nWrite 1 to clear this bit to 0.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No bus ERROR response received</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Bus ERROR response received</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BLKD_IF</name>
              <description>Block Transfer Done Interrupt Flag\nThis bit indicates that PDMA has finished all transfer.\nWrite 1 to clear this bit to 0.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Not finished</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Done</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PDMA_SBUF0_c</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_SBUF0_c</displayName>
          <description>PDMA Shared Buffer FIFO 0</description>
          <addressOffset>0x80</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_SBUF0</name>
              <description>PDMA Shared Buffer FIFO 0 (Read Only)\nEach channel has its own 1 words internal buffer.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>PDMA_ch2</name>
      <description>PDMA Register Map</description>
      <groupName>PDMA</groupName>
      <baseAddress>0x50008200</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x0</offset>
        <size>0x28</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x80</offset>
        <size>0x4</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>PDMA_CSR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_CSR</displayName>
          <description>PDMA Control Register</description>
          <addressOffset>0x0</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMACEN</name>
              <description>PDMA Channel Enable\nSetting this bit to 1 enables PDMA's operation. If this bit is cleared, PDMA will ignore all PDMA request and force Bus Master into IDLE state.\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_RST</name>
              <description>Software Engine Reset\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reset the internal state machine, pointers and internal buffer. The contents of control register will not be cleared. This bit will auto clear after few clock cycles</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>MODE_SEL</name>
              <description>PDMA Mode Selection\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Memory to Memory mode (Memory-to-Memory)</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Peripheral to Memory mode (Peripheral-to-Memory)</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Memory to Peripheral mode (Memory-to-Peripheral)</description>
                    <value>#10</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SAD_SEL</name>
              <description>Transfer Source Address Direction Selection\n</description>
              <bitOffset>4</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Transfer Source address is increasing successively</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reserved</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Transfer Source address is fixed (This feature can be used when data where transferred from a single source to multiple destinations)</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Reserved</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DAD_SEL</name>
              <description>Transfer Destination Address Direction Selection\n</description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Transfer Destination address is increasing successively</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reserved</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Transfer Destination address is fixed (This feature can be used when data where transferred from multiple sources to a single destination)</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Reserved</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>APB_TWS</name>
              <description>Peripheral transfer Width Selection\nNote: This field is meaningful only when MODE_SEL is Peripheral to Memory mode (Peripheral-to-Memory) or Memory to Peripheral mode (Memory-to-Peripheral).</description>
              <bitOffset>19</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>One word (32-bit) is transferred for every PDMA operation</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>One byte (8-bit) is transferred for every PDMA operation</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>One half-word (16-bit) is transferred for every PDMA operation</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Reserved</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TRIG_EN</name>
              <description>Trigger Enable\nNote: When PDMA transfer is completed, this bit will be cleared automatically.\nIf the bus error occurs, all PDMA transfer will be stopped. Software must reset all PDMA channel, and then trigger again.</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PDMA data read or write transfer Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PDMA_SAR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_SAR</displayName>
          <description>PDMA Source Address Register</description>
          <addressOffset>0x4</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_SAR</name>
              <description>PDMA Transfer Source Address Register\nThis field indicates a 32-bit source address of PDMA.\nNote: The source address must be word alignment</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PDMA_DAR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_DAR</displayName>
          <description>PDMA Destination Address Register</description>
          <addressOffset>0x8</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_DAR</name>
              <description>PDMA Transfer Destination Address Register\nThis field indicates a 32-bit destination address of PDMA.\nNote: The destination address must be word alignment.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PDMA_BCR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_BCR</displayName>
          <description>PDMA Transfer Byte Count Register</description>
          <addressOffset>0xC</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_BCR</name>
              <description>PDMA Transfer Byte Count Register\nThis field indicates a 16-bit transfer byte count number of PDMA, which must be word alignment.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PDMA_POINT</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_POINT</displayName>
          <description>PDMA Internal Buffer Pointer</description>
          <addressOffset>0x10</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_POINT</name>
              <description>PDMA Internal Buffer Pointer Register (Read Only)\nThis field indicates the internal buffer pointer.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PDMA_CSAR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_CSAR</displayName>
          <description>PDMA Current Source Address Register</description>
          <addressOffset>0x14</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_CSAR</name>
              <description>PDMA Current Source Address Register (Read Only)\nThis field indicates the source address where the PDMA transfer just occurred.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PDMA_CDAR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_CDAR</displayName>
          <description>PDMA Current Destination Address Register</description>
          <addressOffset>0x18</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_CDAR</name>
              <description>PDMA Current Destination Address Register (Read Only)\nThis field indicates the destination address where the PDMA transfer just occurred.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PDMA_CBCR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_CBCR</displayName>
          <description>PDMA Current Transfer Byte Count Register</description>
          <addressOffset>0x1C</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_CBCR</name>
              <description>PDMA Current Byte Count Register (Read Only)\nThis field indicates the current remained byte count of PDMA.\nNote: SW_RST will clear this register value.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PDMA_IER</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_IER</displayName>
          <description>PDMA Interrupt Enable Register</description>
          <addressOffset>0x20</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000001</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TABORT_IE</name>
              <description>PDMA Read/Write Target Abort Interrupt Enable\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Target abort interrupt generation Disabled during PDMA transfer</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Target abort interrupt generation Enabled during PDMA transfer</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BLKD_IE</name>
              <description>PDMA Transfer Done Interrupt Enable\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Interrupt generator Disabled when PDMA transfer is done</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Interrupt generator Enabled when PDMA transfer is done</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PDMA_ISR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_ISR</displayName>
          <description>PDMA Interrupt Status Register</description>
          <addressOffset>0x24</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TABORT_IF</name>
              <description>PDMA Read/Write Target Abort Interrupt Flag\nWrite 1 to clear this bit to 0.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No bus ERROR response received</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Bus ERROR response received</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BLKD_IF</name>
              <description>Block Transfer Done Interrupt Flag\nThis bit indicates that PDMA has finished all transfer.\nWrite 1 to clear this bit to 0.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Not finished</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Done</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PDMA_SBUF0_c</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_SBUF0_c</displayName>
          <description>PDMA Shared Buffer FIFO 0</description>
          <addressOffset>0x80</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_SBUF0</name>
              <description>PDMA Shared Buffer FIFO 0 (Read Only)\nEach channel has its own 1 words internal buffer.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>PDMA_ch3</name>
      <description>PDMA Register Map</description>
      <groupName>PDMA</groupName>
      <baseAddress>0x50008300</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x0</offset>
        <size>0x28</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x80</offset>
        <size>0x4</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>PDMA_CSR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_CSR</displayName>
          <description>PDMA Control Register</description>
          <addressOffset>0x0</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMACEN</name>
              <description>PDMA Channel Enable\nSetting this bit to 1 enables PDMA's operation. If this bit is cleared, PDMA will ignore all PDMA request and force Bus Master into IDLE state.\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_RST</name>
              <description>Software Engine Reset\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reset the internal state machine, pointers and internal buffer. The contents of control register will not be cleared. This bit will auto clear after few clock cycles</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>MODE_SEL</name>
              <description>PDMA Mode Selection\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Memory to Memory mode (Memory-to-Memory)</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Peripheral to Memory mode (Peripheral-to-Memory)</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Memory to Peripheral mode (Memory-to-Peripheral)</description>
                    <value>#10</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SAD_SEL</name>
              <description>Transfer Source Address Direction Selection\n</description>
              <bitOffset>4</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Transfer Source address is increasing successively</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reserved</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Transfer Source address is fixed (This feature can be used when data where transferred from a single source to multiple destinations)</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Reserved</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DAD_SEL</name>
              <description>Transfer Destination Address Direction Selection\n</description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Transfer Destination address is increasing successively</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reserved</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Transfer Destination address is fixed (This feature can be used when data where transferred from multiple sources to a single destination)</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Reserved</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>APB_TWS</name>
              <description>Peripheral transfer Width Selection\nNote: This field is meaningful only when MODE_SEL is Peripheral to Memory mode (Peripheral-to-Memory) or Memory to Peripheral mode (Memory-to-Peripheral).</description>
              <bitOffset>19</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>One word (32-bit) is transferred for every PDMA operation</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>One byte (8-bit) is transferred for every PDMA operation</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>One half-word (16-bit) is transferred for every PDMA operation</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Reserved</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TRIG_EN</name>
              <description>Trigger Enable\nNote: When PDMA transfer is completed, this bit will be cleared automatically.\nIf the bus error occurs, all PDMA transfer will be stopped. Software must reset all PDMA channel, and then trigger again.</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PDMA data read or write transfer Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PDMA_SAR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_SAR</displayName>
          <description>PDMA Source Address Register</description>
          <addressOffset>0x4</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_SAR</name>
              <description>PDMA Transfer Source Address Register\nThis field indicates a 32-bit source address of PDMA.\nNote: The source address must be word alignment</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PDMA_DAR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_DAR</displayName>
          <description>PDMA Destination Address Register</description>
          <addressOffset>0x8</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_DAR</name>
              <description>PDMA Transfer Destination Address Register\nThis field indicates a 32-bit destination address of PDMA.\nNote: The destination address must be word alignment.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PDMA_BCR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_BCR</displayName>
          <description>PDMA Transfer Byte Count Register</description>
          <addressOffset>0xC</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_BCR</name>
              <description>PDMA Transfer Byte Count Register\nThis field indicates a 16-bit transfer byte count number of PDMA, which must be word alignment.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PDMA_POINT</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_POINT</displayName>
          <description>PDMA Internal Buffer Pointer</description>
          <addressOffset>0x10</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_POINT</name>
              <description>PDMA Internal Buffer Pointer Register (Read Only)\nThis field indicates the internal buffer pointer.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PDMA_CSAR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_CSAR</displayName>
          <description>PDMA Current Source Address Register</description>
          <addressOffset>0x14</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_CSAR</name>
              <description>PDMA Current Source Address Register (Read Only)\nThis field indicates the source address where the PDMA transfer just occurred.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PDMA_CDAR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_CDAR</displayName>
          <description>PDMA Current Destination Address Register</description>
          <addressOffset>0x18</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_CDAR</name>
              <description>PDMA Current Destination Address Register (Read Only)\nThis field indicates the destination address where the PDMA transfer just occurred.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PDMA_CBCR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_CBCR</displayName>
          <description>PDMA Current Transfer Byte Count Register</description>
          <addressOffset>0x1C</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_CBCR</name>
              <description>PDMA Current Byte Count Register (Read Only)\nThis field indicates the current remained byte count of PDMA.\nNote: SW_RST will clear this register value.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PDMA_IER</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_IER</displayName>
          <description>PDMA Interrupt Enable Register</description>
          <addressOffset>0x20</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000001</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TABORT_IE</name>
              <description>PDMA Read/Write Target Abort Interrupt Enable\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Target abort interrupt generation Disabled during PDMA transfer</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Target abort interrupt generation Enabled during PDMA transfer</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BLKD_IE</name>
              <description>PDMA Transfer Done Interrupt Enable\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Interrupt generator Disabled when PDMA transfer is done</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Interrupt generator Enabled when PDMA transfer is done</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PDMA_ISR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_ISR</displayName>
          <description>PDMA Interrupt Status Register</description>
          <addressOffset>0x24</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TABORT_IF</name>
              <description>PDMA Read/Write Target Abort Interrupt Flag\nWrite 1 to clear this bit to 0.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No bus ERROR response received</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Bus ERROR response received</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BLKD_IF</name>
              <description>Block Transfer Done Interrupt Flag\nThis bit indicates that PDMA has finished all transfer.\nWrite 1 to clear this bit to 0.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Not finished</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Done</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PDMA_SBUF0_c</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_SBUF0_c</displayName>
          <description>PDMA Shared Buffer FIFO 0</description>
          <addressOffset>0x80</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_SBUF0</name>
              <description>PDMA Shared Buffer FIFO 0 (Read Only)\nEach channel has its own 1 words internal buffer.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>PDMA_ch4</name>
      <description>PDMA Register Map</description>
      <groupName>PDMA</groupName>
      <baseAddress>0x50008400</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x0</offset>
        <size>0x28</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x80</offset>
        <size>0x4</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>PDMA_CSR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_CSR</displayName>
          <description>PDMA Control Register</description>
          <addressOffset>0x0</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMACEN</name>
              <description>PDMA Channel Enable\nSetting this bit to 1 enables PDMA's operation. If this bit is cleared, PDMA will ignore all PDMA request and force Bus Master into IDLE state.\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_RST</name>
              <description>Software Engine Reset\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reset the internal state machine, pointers and internal buffer. The contents of control register will not be cleared. This bit will auto clear after few clock cycles</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>MODE_SEL</name>
              <description>PDMA Mode Selection\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Memory to Memory mode (Memory-to-Memory)</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Peripheral to Memory mode (Peripheral-to-Memory)</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Memory to Peripheral mode (Memory-to-Peripheral)</description>
                    <value>#10</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SAD_SEL</name>
              <description>Transfer Source Address Direction Selection\n</description>
              <bitOffset>4</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Transfer Source address is increasing successively</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reserved</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Transfer Source address is fixed (This feature can be used when data where transferred from a single source to multiple destinations)</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Reserved</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DAD_SEL</name>
              <description>Transfer Destination Address Direction Selection\n</description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Transfer Destination address is increasing successively</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reserved</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Transfer Destination address is fixed (This feature can be used when data where transferred from multiple sources to a single destination)</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Reserved</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>APB_TWS</name>
              <description>Peripheral transfer Width Selection\nNote: This field is meaningful only when MODE_SEL is Peripheral to Memory mode (Peripheral-to-Memory) or Memory to Peripheral mode (Memory-to-Peripheral).</description>
              <bitOffset>19</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>One word (32-bit) is transferred for every PDMA operation</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>One byte (8-bit) is transferred for every PDMA operation</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>One half-word (16-bit) is transferred for every PDMA operation</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Reserved</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TRIG_EN</name>
              <description>Trigger Enable\nNote: When PDMA transfer is completed, this bit will be cleared automatically.\nIf the bus error occurs, all PDMA transfer will be stopped. Software must reset all PDMA channel, and then trigger again.</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PDMA data read or write transfer Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PDMA_SAR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_SAR</displayName>
          <description>PDMA Source Address Register</description>
          <addressOffset>0x4</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_SAR</name>
              <description>PDMA Transfer Source Address Register\nThis field indicates a 32-bit source address of PDMA.\nNote: The source address must be word alignment</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PDMA_DAR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_DAR</displayName>
          <description>PDMA Destination Address Register</description>
          <addressOffset>0x8</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_DAR</name>
              <description>PDMA Transfer Destination Address Register\nThis field indicates a 32-bit destination address of PDMA.\nNote: The destination address must be word alignment.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PDMA_BCR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_BCR</displayName>
          <description>PDMA Transfer Byte Count Register</description>
          <addressOffset>0xC</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_BCR</name>
              <description>PDMA Transfer Byte Count Register\nThis field indicates a 16-bit transfer byte count number of PDMA, which must be word alignment.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PDMA_POINT</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_POINT</displayName>
          <description>PDMA Internal Buffer Pointer</description>
          <addressOffset>0x10</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_POINT</name>
              <description>PDMA Internal Buffer Pointer Register (Read Only)\nThis field indicates the internal buffer pointer.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PDMA_CSAR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_CSAR</displayName>
          <description>PDMA Current Source Address Register</description>
          <addressOffset>0x14</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_CSAR</name>
              <description>PDMA Current Source Address Register (Read Only)\nThis field indicates the source address where the PDMA transfer just occurred.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PDMA_CDAR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_CDAR</displayName>
          <description>PDMA Current Destination Address Register</description>
          <addressOffset>0x18</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_CDAR</name>
              <description>PDMA Current Destination Address Register (Read Only)\nThis field indicates the destination address where the PDMA transfer just occurred.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PDMA_CBCR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_CBCR</displayName>
          <description>PDMA Current Transfer Byte Count Register</description>
          <addressOffset>0x1C</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_CBCR</name>
              <description>PDMA Current Byte Count Register (Read Only)\nThis field indicates the current remained byte count of PDMA.\nNote: SW_RST will clear this register value.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PDMA_IER</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_IER</displayName>
          <description>PDMA Interrupt Enable Register</description>
          <addressOffset>0x20</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000001</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TABORT_IE</name>
              <description>PDMA Read/Write Target Abort Interrupt Enable\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Target abort interrupt generation Disabled during PDMA transfer</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Target abort interrupt generation Enabled during PDMA transfer</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BLKD_IE</name>
              <description>PDMA Transfer Done Interrupt Enable\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Interrupt generator Disabled when PDMA transfer is done</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Interrupt generator Enabled when PDMA transfer is done</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PDMA_ISR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_ISR</displayName>
          <description>PDMA Interrupt Status Register</description>
          <addressOffset>0x24</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TABORT_IF</name>
              <description>PDMA Read/Write Target Abort Interrupt Flag\nWrite 1 to clear this bit to 0.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No bus ERROR response received</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Bus ERROR response received</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BLKD_IF</name>
              <description>Block Transfer Done Interrupt Flag\nThis bit indicates that PDMA has finished all transfer.\nWrite 1 to clear this bit to 0.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Not finished</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Done</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PDMA_SBUF0_c</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_SBUF0_c</displayName>
          <description>PDMA Shared Buffer FIFO 0</description>
          <addressOffset>0x80</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_SBUF0</name>
              <description>PDMA Shared Buffer FIFO 0 (Read Only)\nEach channel has its own 1 words internal buffer.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>PDMA_ch5</name>
      <description>PDMA Register Map</description>
      <groupName>PDMA</groupName>
      <baseAddress>0x50008500</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x0</offset>
        <size>0x28</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x80</offset>
        <size>0x4</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>PDMA_CSR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_CSR</displayName>
          <description>PDMA Control Register</description>
          <addressOffset>0x0</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMACEN</name>
              <description>PDMA Channel Enable\nSetting this bit to 1 enables PDMA's operation. If this bit is cleared, PDMA will ignore all PDMA request and force Bus Master into IDLE state.\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_RST</name>
              <description>Software Engine Reset\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reset the internal state machine, pointers and internal buffer. The contents of control register will not be cleared. This bit will auto clear after few clock cycles</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>MODE_SEL</name>
              <description>PDMA Mode Selection\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Memory to Memory mode (Memory-to-Memory)</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Peripheral to Memory mode (Peripheral-to-Memory)</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Memory to Peripheral mode (Memory-to-Peripheral)</description>
                    <value>#10</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SAD_SEL</name>
              <description>Transfer Source Address Direction Selection\n</description>
              <bitOffset>4</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Transfer Source address is increasing successively</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reserved</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Transfer Source address is fixed (This feature can be used when data where transferred from a single source to multiple destinations)</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Reserved</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DAD_SEL</name>
              <description>Transfer Destination Address Direction Selection\n</description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Transfer Destination address is increasing successively</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reserved</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Transfer Destination address is fixed (This feature can be used when data where transferred from multiple sources to a single destination)</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Reserved</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>APB_TWS</name>
              <description>Peripheral transfer Width Selection\nNote: This field is meaningful only when MODE_SEL is Peripheral to Memory mode (Peripheral-to-Memory) or Memory to Peripheral mode (Memory-to-Peripheral).</description>
              <bitOffset>19</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>One word (32-bit) is transferred for every PDMA operation</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>One byte (8-bit) is transferred for every PDMA operation</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>One half-word (16-bit) is transferred for every PDMA operation</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Reserved</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TRIG_EN</name>
              <description>Trigger Enable\nNote: When PDMA transfer is completed, this bit will be cleared automatically.\nIf the bus error occurs, all PDMA transfer will be stopped. Software must reset all PDMA channel, and then trigger again.</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PDMA data read or write transfer Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PDMA_SAR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_SAR</displayName>
          <description>PDMA Source Address Register</description>
          <addressOffset>0x4</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_SAR</name>
              <description>PDMA Transfer Source Address Register\nThis field indicates a 32-bit source address of PDMA.\nNote: The source address must be word alignment</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PDMA_DAR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_DAR</displayName>
          <description>PDMA Destination Address Register</description>
          <addressOffset>0x8</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_DAR</name>
              <description>PDMA Transfer Destination Address Register\nThis field indicates a 32-bit destination address of PDMA.\nNote: The destination address must be word alignment.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PDMA_BCR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_BCR</displayName>
          <description>PDMA Transfer Byte Count Register</description>
          <addressOffset>0xC</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_BCR</name>
              <description>PDMA Transfer Byte Count Register\nThis field indicates a 16-bit transfer byte count number of PDMA, which must be word alignment.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PDMA_POINT</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_POINT</displayName>
          <description>PDMA Internal Buffer Pointer</description>
          <addressOffset>0x10</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_POINT</name>
              <description>PDMA Internal Buffer Pointer Register (Read Only)\nThis field indicates the internal buffer pointer.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PDMA_CSAR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_CSAR</displayName>
          <description>PDMA Current Source Address Register</description>
          <addressOffset>0x14</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_CSAR</name>
              <description>PDMA Current Source Address Register (Read Only)\nThis field indicates the source address where the PDMA transfer just occurred.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PDMA_CDAR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_CDAR</displayName>
          <description>PDMA Current Destination Address Register</description>
          <addressOffset>0x18</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_CDAR</name>
              <description>PDMA Current Destination Address Register (Read Only)\nThis field indicates the destination address where the PDMA transfer just occurred.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PDMA_CBCR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_CBCR</displayName>
          <description>PDMA Current Transfer Byte Count Register</description>
          <addressOffset>0x1C</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_CBCR</name>
              <description>PDMA Current Byte Count Register (Read Only)\nThis field indicates the current remained byte count of PDMA.\nNote: SW_RST will clear this register value.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PDMA_IER</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_IER</displayName>
          <description>PDMA Interrupt Enable Register</description>
          <addressOffset>0x20</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000001</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TABORT_IE</name>
              <description>PDMA Read/Write Target Abort Interrupt Enable\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Target abort interrupt generation Disabled during PDMA transfer</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Target abort interrupt generation Enabled during PDMA transfer</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BLKD_IE</name>
              <description>PDMA Transfer Done Interrupt Enable\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Interrupt generator Disabled when PDMA transfer is done</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Interrupt generator Enabled when PDMA transfer is done</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PDMA_ISR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_ISR</displayName>
          <description>PDMA Interrupt Status Register</description>
          <addressOffset>0x24</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TABORT_IF</name>
              <description>PDMA Read/Write Target Abort Interrupt Flag\nWrite 1 to clear this bit to 0.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No bus ERROR response received</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Bus ERROR response received</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BLKD_IF</name>
              <description>Block Transfer Done Interrupt Flag\nThis bit indicates that PDMA has finished all transfer.\nWrite 1 to clear this bit to 0.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Not finished</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Done</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PDMA_SBUF0_c</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_SBUF0_c</displayName>
          <description>PDMA Shared Buffer FIFO 0</description>
          <addressOffset>0x80</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_SBUF0</name>
              <description>PDMA Shared Buffer FIFO 0 (Read Only)\nEach channel has its own 1 words internal buffer.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>PDMA_ch6</name>
      <description>PDMA Register Map</description>
      <groupName>PDMA</groupName>
      <baseAddress>0x50008600</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x0</offset>
        <size>0x28</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x80</offset>
        <size>0x4</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>PDMA_CSR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_CSR</displayName>
          <description>PDMA Control Register</description>
          <addressOffset>0x0</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMACEN</name>
              <description>PDMA Channel Enable\nSetting this bit to 1 enables PDMA's operation. If this bit is cleared, PDMA will ignore all PDMA request and force Bus Master into IDLE state.\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_RST</name>
              <description>Software Engine Reset\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reset the internal state machine, pointers and internal buffer. The contents of control register will not be cleared. This bit will auto clear after few clock cycles</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>MODE_SEL</name>
              <description>PDMA Mode Selection\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Memory to Memory mode (Memory-to-Memory)</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Peripheral to Memory mode (Peripheral-to-Memory)</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Memory to Peripheral mode (Memory-to-Peripheral)</description>
                    <value>#10</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SAD_SEL</name>
              <description>Transfer Source Address Direction Selection\n</description>
              <bitOffset>4</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Transfer Source address is increasing successively</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reserved</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Transfer Source address is fixed (This feature can be used when data where transferred from a single source to multiple destinations)</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Reserved</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DAD_SEL</name>
              <description>Transfer Destination Address Direction Selection\n</description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Transfer Destination address is increasing successively</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reserved</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Transfer Destination address is fixed (This feature can be used when data where transferred from multiple sources to a single destination)</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Reserved</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>APB_TWS</name>
              <description>Peripheral transfer Width Selection\nNote: This field is meaningful only when MODE_SEL is Peripheral to Memory mode (Peripheral-to-Memory) or Memory to Peripheral mode (Memory-to-Peripheral).</description>
              <bitOffset>19</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>One word (32-bit) is transferred for every PDMA operation</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>One byte (8-bit) is transferred for every PDMA operation</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>One half-word (16-bit) is transferred for every PDMA operation</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Reserved</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TRIG_EN</name>
              <description>Trigger Enable\nNote: When PDMA transfer is completed, this bit will be cleared automatically.\nIf the bus error occurs, all PDMA transfer will be stopped. Software must reset all PDMA channel, and then trigger again.</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PDMA data read or write transfer Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PDMA_SAR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_SAR</displayName>
          <description>PDMA Source Address Register</description>
          <addressOffset>0x4</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_SAR</name>
              <description>PDMA Transfer Source Address Register\nThis field indicates a 32-bit source address of PDMA.\nNote: The source address must be word alignment</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PDMA_DAR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_DAR</displayName>
          <description>PDMA Destination Address Register</description>
          <addressOffset>0x8</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_DAR</name>
              <description>PDMA Transfer Destination Address Register\nThis field indicates a 32-bit destination address of PDMA.\nNote: The destination address must be word alignment.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PDMA_BCR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_BCR</displayName>
          <description>PDMA Transfer Byte Count Register</description>
          <addressOffset>0xC</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_BCR</name>
              <description>PDMA Transfer Byte Count Register\nThis field indicates a 16-bit transfer byte count number of PDMA, which must be word alignment.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PDMA_POINT</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_POINT</displayName>
          <description>PDMA Internal Buffer Pointer</description>
          <addressOffset>0x10</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_POINT</name>
              <description>PDMA Internal Buffer Pointer Register (Read Only)\nThis field indicates the internal buffer pointer.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PDMA_CSAR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_CSAR</displayName>
          <description>PDMA Current Source Address Register</description>
          <addressOffset>0x14</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_CSAR</name>
              <description>PDMA Current Source Address Register (Read Only)\nThis field indicates the source address where the PDMA transfer just occurred.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PDMA_CDAR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_CDAR</displayName>
          <description>PDMA Current Destination Address Register</description>
          <addressOffset>0x18</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_CDAR</name>
              <description>PDMA Current Destination Address Register (Read Only)\nThis field indicates the destination address where the PDMA transfer just occurred.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PDMA_CBCR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_CBCR</displayName>
          <description>PDMA Current Transfer Byte Count Register</description>
          <addressOffset>0x1C</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_CBCR</name>
              <description>PDMA Current Byte Count Register (Read Only)\nThis field indicates the current remained byte count of PDMA.\nNote: SW_RST will clear this register value.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PDMA_IER</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_IER</displayName>
          <description>PDMA Interrupt Enable Register</description>
          <addressOffset>0x20</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000001</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TABORT_IE</name>
              <description>PDMA Read/Write Target Abort Interrupt Enable\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Target abort interrupt generation Disabled during PDMA transfer</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Target abort interrupt generation Enabled during PDMA transfer</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BLKD_IE</name>
              <description>PDMA Transfer Done Interrupt Enable\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Interrupt generator Disabled when PDMA transfer is done</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Interrupt generator Enabled when PDMA transfer is done</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PDMA_ISR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_ISR</displayName>
          <description>PDMA Interrupt Status Register</description>
          <addressOffset>0x24</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TABORT_IF</name>
              <description>PDMA Read/Write Target Abort Interrupt Flag\nWrite 1 to clear this bit to 0.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No bus ERROR response received</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Bus ERROR response received</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BLKD_IF</name>
              <description>Block Transfer Done Interrupt Flag\nThis bit indicates that PDMA has finished all transfer.\nWrite 1 to clear this bit to 0.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Not finished</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Done</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PDMA_SBUF0_c</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_SBUF0_c</displayName>
          <description>PDMA Shared Buffer FIFO 0</description>
          <addressOffset>0x80</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_SBUF0</name>
              <description>PDMA Shared Buffer FIFO 0 (Read Only)\nEach channel has its own 1 words internal buffer.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>PDMA_ch7</name>
      <description>PDMA Register Map</description>
      <groupName>PDMA</groupName>
      <baseAddress>0x50008700</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x0</offset>
        <size>0x28</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x80</offset>
        <size>0x4</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>PDMA_CSR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_CSR</displayName>
          <description>PDMA Control Register</description>
          <addressOffset>0x0</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMACEN</name>
              <description>PDMA Channel Enable\nSetting this bit to 1 enables PDMA's operation. If this bit is cleared, PDMA will ignore all PDMA request and force Bus Master into IDLE state.\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_RST</name>
              <description>Software Engine Reset\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reset the internal state machine, pointers and internal buffer. The contents of control register will not be cleared. This bit will auto clear after few clock cycles</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>MODE_SEL</name>
              <description>PDMA Mode Selection\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Memory to Memory mode (Memory-to-Memory)</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Peripheral to Memory mode (Peripheral-to-Memory)</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Memory to Peripheral mode (Memory-to-Peripheral)</description>
                    <value>#10</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SAD_SEL</name>
              <description>Transfer Source Address Direction Selection\n</description>
              <bitOffset>4</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Transfer Source address is increasing successively</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reserved</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Transfer Source address is fixed (This feature can be used when data where transferred from a single source to multiple destinations)</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Reserved</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DAD_SEL</name>
              <description>Transfer Destination Address Direction Selection\n</description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Transfer Destination address is increasing successively</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reserved</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Transfer Destination address is fixed (This feature can be used when data where transferred from multiple sources to a single destination)</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Reserved</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>APB_TWS</name>
              <description>Peripheral transfer Width Selection\nNote: This field is meaningful only when MODE_SEL is Peripheral to Memory mode (Peripheral-to-Memory) or Memory to Peripheral mode (Memory-to-Peripheral).</description>
              <bitOffset>19</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>One word (32-bit) is transferred for every PDMA operation</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>One byte (8-bit) is transferred for every PDMA operation</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>One half-word (16-bit) is transferred for every PDMA operation</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Reserved</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TRIG_EN</name>
              <description>Trigger Enable\nNote: When PDMA transfer is completed, this bit will be cleared automatically.\nIf the bus error occurs, all PDMA transfer will be stopped. Software must reset all PDMA channel, and then trigger again.</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PDMA data read or write transfer Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PDMA_SAR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_SAR</displayName>
          <description>PDMA Source Address Register</description>
          <addressOffset>0x4</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_SAR</name>
              <description>PDMA Transfer Source Address Register\nThis field indicates a 32-bit source address of PDMA.\nNote: The source address must be word alignment</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PDMA_DAR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_DAR</displayName>
          <description>PDMA Destination Address Register</description>
          <addressOffset>0x8</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_DAR</name>
              <description>PDMA Transfer Destination Address Register\nThis field indicates a 32-bit destination address of PDMA.\nNote: The destination address must be word alignment.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PDMA_BCR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_BCR</displayName>
          <description>PDMA Transfer Byte Count Register</description>
          <addressOffset>0xC</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_BCR</name>
              <description>PDMA Transfer Byte Count Register\nThis field indicates a 16-bit transfer byte count number of PDMA, which must be word alignment.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PDMA_POINT</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_POINT</displayName>
          <description>PDMA Internal Buffer Pointer</description>
          <addressOffset>0x10</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_POINT</name>
              <description>PDMA Internal Buffer Pointer Register (Read Only)\nThis field indicates the internal buffer pointer.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PDMA_CSAR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_CSAR</displayName>
          <description>PDMA Current Source Address Register</description>
          <addressOffset>0x14</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_CSAR</name>
              <description>PDMA Current Source Address Register (Read Only)\nThis field indicates the source address where the PDMA transfer just occurred.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PDMA_CDAR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_CDAR</displayName>
          <description>PDMA Current Destination Address Register</description>
          <addressOffset>0x18</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_CDAR</name>
              <description>PDMA Current Destination Address Register (Read Only)\nThis field indicates the destination address where the PDMA transfer just occurred.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PDMA_CBCR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_CBCR</displayName>
          <description>PDMA Current Transfer Byte Count Register</description>
          <addressOffset>0x1C</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_CBCR</name>
              <description>PDMA Current Byte Count Register (Read Only)\nThis field indicates the current remained byte count of PDMA.\nNote: SW_RST will clear this register value.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PDMA_IER</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_IER</displayName>
          <description>PDMA Interrupt Enable Register</description>
          <addressOffset>0x20</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000001</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TABORT_IE</name>
              <description>PDMA Read/Write Target Abort Interrupt Enable\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Target abort interrupt generation Disabled during PDMA transfer</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Target abort interrupt generation Enabled during PDMA transfer</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BLKD_IE</name>
              <description>PDMA Transfer Done Interrupt Enable\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Interrupt generator Disabled when PDMA transfer is done</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Interrupt generator Enabled when PDMA transfer is done</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PDMA_ISR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_ISR</displayName>
          <description>PDMA Interrupt Status Register</description>
          <addressOffset>0x24</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TABORT_IF</name>
              <description>PDMA Read/Write Target Abort Interrupt Flag\nWrite 1 to clear this bit to 0.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No bus ERROR response received</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Bus ERROR response received</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BLKD_IF</name>
              <description>Block Transfer Done Interrupt Flag\nThis bit indicates that PDMA has finished all transfer.\nWrite 1 to clear this bit to 0.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Not finished</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Done</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PDMA_SBUF0_c</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_SBUF0_c</displayName>
          <description>PDMA Shared Buffer FIFO 0</description>
          <addressOffset>0x80</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_SBUF0</name>
              <description>PDMA Shared Buffer FIFO 0 (Read Only)\nEach channel has its own 1 words internal buffer.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>PDMA_ch8</name>
      <description>PDMA Register Map</description>
      <groupName>PDMA</groupName>
      <baseAddress>0x50008800</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x0</offset>
        <size>0x28</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x80</offset>
        <size>0x4</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>PDMA_CSR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_CSR</displayName>
          <description>PDMA Control Register</description>
          <addressOffset>0x0</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMACEN</name>
              <description>PDMA Channel Enable\nSetting this bit to 1 enables PDMA's operation. If this bit is cleared, PDMA will ignore all PDMA request and force Bus Master into IDLE state.\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_RST</name>
              <description>Software Engine Reset\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reset the internal state machine, pointers and internal buffer. The contents of control register will not be cleared. This bit will auto clear after few clock cycles</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>MODE_SEL</name>
              <description>PDMA Mode Selection\n</description>
              <bitOffset>2</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Memory to Memory mode (Memory-to-Memory)</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Peripheral to Memory mode (Peripheral-to-Memory)</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Memory to Peripheral mode (Memory-to-Peripheral)</description>
                    <value>#10</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SAD_SEL</name>
              <description>Transfer Source Address Direction Selection\n</description>
              <bitOffset>4</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Transfer Source address is increasing successively</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reserved</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Transfer Source address is fixed (This feature can be used when data where transferred from a single source to multiple destinations)</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Reserved</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DAD_SEL</name>
              <description>Transfer Destination Address Direction Selection\n</description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Transfer Destination address is increasing successively</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reserved</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Transfer Destination address is fixed (This feature can be used when data where transferred from multiple sources to a single destination)</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Reserved</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>APB_TWS</name>
              <description>Peripheral transfer Width Selection\nNote: This field is meaningful only when MODE_SEL is Peripheral to Memory mode (Peripheral-to-Memory) or Memory to Peripheral mode (Memory-to-Peripheral).</description>
              <bitOffset>19</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>One word (32-bit) is transferred for every PDMA operation</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>One byte (8-bit) is transferred for every PDMA operation</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>One half-word (16-bit) is transferred for every PDMA operation</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Reserved</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TRIG_EN</name>
              <description>Trigger Enable\nNote: When PDMA transfer is completed, this bit will be cleared automatically.\nIf the bus error occurs, all PDMA transfer will be stopped. Software must reset all PDMA channel, and then trigger again.</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PDMA data read or write transfer Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PDMA_SAR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_SAR</displayName>
          <description>PDMA Source Address Register</description>
          <addressOffset>0x4</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_SAR</name>
              <description>PDMA Transfer Source Address Register\nThis field indicates a 32-bit source address of PDMA.\nNote: The source address must be word alignment</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PDMA_DAR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_DAR</displayName>
          <description>PDMA Destination Address Register</description>
          <addressOffset>0x8</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_DAR</name>
              <description>PDMA Transfer Destination Address Register\nThis field indicates a 32-bit destination address of PDMA.\nNote: The destination address must be word alignment.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PDMA_BCR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_BCR</displayName>
          <description>PDMA Transfer Byte Count Register</description>
          <addressOffset>0xC</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_BCR</name>
              <description>PDMA Transfer Byte Count Register\nThis field indicates a 16-bit transfer byte count number of PDMA, which must be word alignment.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PDMA_POINT</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_POINT</displayName>
          <description>PDMA Internal Buffer Pointer</description>
          <addressOffset>0x10</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_POINT</name>
              <description>PDMA Internal Buffer Pointer Register (Read Only)\nThis field indicates the internal buffer pointer.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PDMA_CSAR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_CSAR</displayName>
          <description>PDMA Current Source Address Register</description>
          <addressOffset>0x14</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_CSAR</name>
              <description>PDMA Current Source Address Register (Read Only)\nThis field indicates the source address where the PDMA transfer just occurred.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PDMA_CDAR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_CDAR</displayName>
          <description>PDMA Current Destination Address Register</description>
          <addressOffset>0x18</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_CDAR</name>
              <description>PDMA Current Destination Address Register (Read Only)\nThis field indicates the destination address where the PDMA transfer just occurred.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PDMA_CBCR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_CBCR</displayName>
          <description>PDMA Current Transfer Byte Count Register</description>
          <addressOffset>0x1C</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_CBCR</name>
              <description>PDMA Current Byte Count Register (Read Only)\nThis field indicates the current remained byte count of PDMA.\nNote: SW_RST will clear this register value.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PDMA_IER</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_IER</displayName>
          <description>PDMA Interrupt Enable Register</description>
          <addressOffset>0x20</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000001</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TABORT_IE</name>
              <description>PDMA Read/Write Target Abort Interrupt Enable\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Target abort interrupt generation Disabled during PDMA transfer</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Target abort interrupt generation Enabled during PDMA transfer</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BLKD_IE</name>
              <description>PDMA Transfer Done Interrupt Enable\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Interrupt generator Disabled when PDMA transfer is done</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Interrupt generator Enabled when PDMA transfer is done</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PDMA_ISR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_ISR</displayName>
          <description>PDMA Interrupt Status Register</description>
          <addressOffset>0x24</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TABORT_IF</name>
              <description>PDMA Read/Write Target Abort Interrupt Flag\nWrite 1 to clear this bit to 0.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No bus ERROR response received</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Bus ERROR response received</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BLKD_IF</name>
              <description>Block Transfer Done Interrupt Flag\nThis bit indicates that PDMA has finished all transfer.\nWrite 1 to clear this bit to 0.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Not finished</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Done</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PDMA_SBUF0_c</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_SBUF0_c</displayName>
          <description>PDMA Shared Buffer FIFO 0</description>
          <addressOffset>0x80</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_SBUF0</name>
              <description>PDMA Shared Buffer FIFO 0 (Read Only)\nEach channel has its own 1 words internal buffer.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>EBI</name>
      <description>EBI Register Map</description>
      <groupName>EBI</groupName>
      <baseAddress>0x50010000</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x0</offset>
        <size>0x8</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>EBICON</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>EBICON</displayName>
          <description>External Bus Interface General Control Register</description>
          <addressOffset>0x0</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ExtEN</name>
              <description>EBI Enable\nThis bit is the functional enable bit for EBI.\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>EBI function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>EBI function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ExtBW16</name>
              <description>EBI Data Width 16-bit\nThis bit defines if the data bus is 8-bit or 16-bit.\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>EBI data width is 8-bit</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>EBI data width is 16-bit</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>MCLKDIV</name>
              <description>External Output Clock Divider\n</description>
              <bitOffset>8</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ExttALE</name>
              <description>Expand Time of ALE\nThe ALE width (tALE) to latch the address can be controlled by ExttALE.\n</description>
              <bitOffset>16</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>EXTIME</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>EXTIME</displayName>
          <description>External Bus Interface Timing Control Register</description>
          <addressOffset>0x4</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ExttACC</name>
              <description>EBI Data Access Time\nExttACC defines data access time (tACC).\n</description>
              <bitOffset>3</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ExttAHD</name>
              <description>EBI Data Access Hold Time\nExttAHD defines data access hold time (tAHD).\n</description>
              <bitOffset>8</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ExtIW2X</name>
              <description>Idle State Cycle After Write\nWhen write action is finished, idle state is inserted and nCS return to high if ExtIW2X is not zero.\n</description>
              <bitOffset>12</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ExtIR2R</name>
              <description>Idle State Cycle Between Read-Read\nWhen read action is finished and the next action is going to read, idle state is inserted and nCS return to high if ExtIR2R is not zero.\n</description>
              <bitOffset>24</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>FMC</name>
      <description>FMC Register Map</description>
      <groupName>FMC</groupName>
      <baseAddress>0x5000C000</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x0</offset>
        <size>0x1C</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>ISPCON</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>ISPCON</displayName>
          <description>ISP Control Register</description>
          <addressOffset>0x0</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ISPEN</name>
              <description>ISP Enable (Write-protection Bit)\nISP function enable bit. Set this bit to enable ISP function.\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>ISP function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>ISP function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BS</name>
              <description>Boot Selection (Write-protection Bit)\nSet/clear this bit to select next booting from LDROM/APROM, respectively. This bit also functions as chip booting status flag, which can be used to check where chip booted from. This bit is initiated with the inversed value of CBS in Config0 after any reset is happened except CPU reset (RSTS_CPU is 1) or system reset (RSTS_SYS) is happened\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Boot from APROM</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Boot from LDROM</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CFGUEN</name>
              <description>Enable Config-bits Update by ISP (Write-protection Bit)\n</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>ISP Disabled for config-bits update</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>ISP Enabled for config-bits update</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>LDUEN</name>
              <description>LDROM Update Enable (Write-protection Bit)\n</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>LDROM cannot be updated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>LDROM can be updated when the chip runs in APROM</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ISPFF</name>
              <description>ISP Fail Flag (Write-protection Bit)\nThis bit is set by hardware when a triggered ISP meets any of the following conditions:\n(1) APROM writes to itself\n(2) LDROM writes to itself\n(3) CONFIG is erased/programmed if CFGUEN is set to 0\n(4) Destination address is illegal, such as over an available range\nWrite 1 to clear.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>ISPADR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>ISPADR</displayName>
          <description>ISP Address Register</description>
          <addressOffset>0x4</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ISPADR</name>
              <description>ISP Address\nThe NuMicro( NUC100 Series has a maximum of 32Kx32 embedded flash; it supports word program only. ISPADR[1:0] must be kept 00b for ISP operation.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>ISPDAT</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>ISPDAT</displayName>
          <description>ISP Data Register</description>
          <addressOffset>0x8</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ISPDAT</name>
              <description>ISP Data\nWrite data to this register before ISP program operation.\nRead data from this register after ISP read operation.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>ISPCMD</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>ISPCMD</displayName>
          <description>ISP Command Register</description>
          <addressOffset>0xC</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>FCTRL</name>
              <description>ISP Command</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FCEN</name>
              <description>ISP Command</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FOEN</name>
              <description>ISP Command\n</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>ISPTRG</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>ISPTRG</displayName>
          <description>ISP Trigger Register</description>
          <addressOffset>0x10</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ISPGO</name>
              <description>ISP start trigger (Write-protection Bit)\nWrite 1 to start ISP operation and this bit will be cleared to 0 by hardware automatically when ISP operation is finished.\nThis bit is the protected bit, It means programming this bit needs to write "59h", "16h", "88h" to address 0x5000_0100 to disable register protection. Refer to the register REGWRPROT at address GCR_BA+0x100.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>ISP operation finished</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>ISP progressed</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>DFBADR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>DFBADR</displayName>
          <description>Data Flash Start Address (AP ROM Size Is Less Than 128KB)</description>
          <addressOffset>0x14</addressOffset>
          <access>read-only</access>
          <resetValue>0x0001F000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DFBADR</name>
              <description>Data Flash Base Address\nThis register indicates data flash start address. It is read only.\nFor 128KB flash memory device, the data flash size is defined by user configuration, register content is loaded from Config1 when chip power on but for 64/32KB device, it is fixed at 0x0001_F000.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>FATCON</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>FATCON</displayName>
          <description>Flash Access Window Control Register</description>
          <addressOffset>0x18</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>FPSEN</name>
              <description>Flash Power Save Enable (Write-protection Bit)\nIf CPU clock is slower than 24 MHz, software can enable flash power saving function.\n</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Flash power saving Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Flash power saving Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>FATS</name>
              <description>Flash Access Time Window Selection (Write-protection Bits)\n</description>
              <bitOffset>1</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>LFOM</name>
              <description>Low Frequency Optimization Mode (Write-protection Bit)\nWhen chip operation frequency is lower than 25 MHz, chip can work more efficiently by setting this bit to 1\n(This bit is only for NuMicro( NUC100/NUC120 Low Density.)</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Low frequency optimization mode Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Low frequency optimization mode Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
      </registers>
    </peripheral>
  </peripherals>
</device>
